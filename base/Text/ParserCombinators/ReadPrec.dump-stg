
==================== Pre unarise: ====================
2018-03-16 15:58:07.131907981 UTC

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec2
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [h_s3tB0 ds_s3tB1 n_s3tB2]
        let {
          ds1_s3tB3 [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tu3
          [LclId] =
              [ds_s3tB1 n_s3tB2] \u [] ds_s3tB1 n_s3tB2; } in
        let {
          sat_s3tB6 [Occ=Once]
            :: forall b1.
               (b_a3tu4 -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [h_s3tB0 ds1_s3tB3] \r [k_s3tB4]
                  let {
                    sat_s3tB5 [Occ=Once]
                      :: a_a3tu3 -> Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [h_s3tB0 k_s3tB4] \r [eta_B1] GHC.Base.. k_s3tB4 h_s3tB0 eta_B1;
                  } in  ds1_s3tB3 sat_s3tB5;
        } in  sat_s3tB6;

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec1
  :: forall b a.
     a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [x_s3tB7 eta_s3tB8 eta1_s3tB9]
        let {
          ds_s3tBa [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP b_a3tug
          [LclId] =
              [eta_s3tB8 eta1_s3tB9] \u [] eta_s3tB8 eta1_s3tB9; } in
        let {
          sat_s3tBf [Occ=Once]
            :: forall b1.
               (a_a3tuf -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [x_s3tB7 ds_s3tBa] \r [k_s3tBb]
                  let {
                    lvl1_s3tBc [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [x_s3tB7 k_s3tBb] \u [] k_s3tBb x_s3tB7; } in
                  let {
                    sat_s3tBe [Occ=Once]
                      :: b_a3tug -> Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [lvl1_s3tBc] \r [x1_s3tBd] lvl1_s3tBc;
                  } in  ds_s3tBa sat_s3tBe;
        } in  sat_s3tBf;

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadPrec.$fFunctorReadPrec2
                                       Text.ParserCombinators.ReadPrec.$fFunctorReadPrec1];

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
  :: forall a.
     a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,A><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3tBg ds_s3tBh k_s3tBi] k_s3tBi x_s3tBg;

Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1
  :: forall a.
     GHC.Base.String
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [s_s3tBj ds_s3tBk ds1_s3tBl]
        Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.$fMonadReadPrec1
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> (a -> Text.ParserCombinators.ReadPrec.ReadPrec b)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3tBm k_s3tBn n_s3tBo]
        let {
          ds1_s3tBp [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tsh
          [LclId] =
              [ds_s3tBm n_s3tBo] \u [] ds_s3tBm n_s3tBo; } in
        let {
          sat_s3tBt [Occ=Once]
            :: forall b1.
               (b_a3tsi -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [k_s3tBn n_s3tBo ds1_s3tBp] \r [k1_s3tBq]
                  let {
                    sat_s3tBs [Occ=Once]
                      :: a_a3tsh -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3tBn n_s3tBo k1_s3tBq] \r [a1_s3tBr]
                            k_s3tBn a1_s3tBr n_s3tBo k1_s3tBq;
                  } in  ds1_s3tBp sat_s3tBs;
        } in  sat_s3tBt;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec3
  :: forall c b a.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s3tBu m1_s3tBv m2_s3tBw n_s3tBx]
        let {
          ds_s3tBy [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttu
          [LclId] =
              [m1_s3tBv n_s3tBx] \u [] m1_s3tBv n_s3tBx; } in
        let {
          sat_s3tBF [Occ=Once]
            :: forall b1.
               (c_a3ttw -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [f_s3tBu m2_s3tBw n_s3tBx ds_s3tBy] \r [k_s3tBz]
                  let {
                    sat_s3tBE [Occ=Once]
                      :: a_a3ttu -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [f_s3tBu m2_s3tBw n_s3tBx k_s3tBz] \r [a1_s3tBA]
                            let {
                              sat_s3tBD [Occ=Once]
                                :: b_a3ttv -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [f_s3tBu k_s3tBz a1_s3tBA] \r [a2_s3tBB]
                                      let {
                                        sat_s3tBC [Occ=Once] :: c_a3ttw
                                        [LclId] =
                                            [f_s3tBu a1_s3tBA a2_s3tBB] \u []
                                                f_s3tBu a1_s3tBA a2_s3tBB;
                                      } in  k_s3tBz sat_s3tBC;
                            } in  m2_s3tBw n_s3tBx sat_s3tBD;
                  } in  ds_s3tBy sat_s3tBE;
        } in  sat_s3tBF;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec1
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [m1_s3tBG m2_s3tBH n_s3tBI]
        let {
          ds_s3tBJ [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttR
          [LclId] =
              [m1_s3tBG n_s3tBI] \u [] m1_s3tBG n_s3tBI; } in
        let {
          sat_s3tBQ [Occ=Once]
            :: forall b1.
               (a_a3ttR -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [m2_s3tBH n_s3tBI ds_s3tBJ] \r [k_s3tBK]
                  let {
                    sat_s3tBP [Occ=Once]
                      :: a_a3ttR -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [m2_s3tBH n_s3tBI k_s3tBK] \r [a1_s3tBL]
                            let {
                              lvl1_s3tBM [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3tBK a1_s3tBL] \u [] k_s3tBK a1_s3tBL; } in
                            let {
                              sat_s3tBO [Occ=Once]
                                :: b_a3ttS -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl1_s3tBM] \r [a2_s3tBN] lvl1_s3tBM;
                            } in  m2_s3tBH n_s3tBI sat_s3tBO;
                  } in  ds_s3tBJ sat_s3tBP;
        } in  sat_s3tBQ;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec4
  :: forall b a.
     Text.ParserCombinators.ReadPrec.ReadPrec (a -> b)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [m1_s3tBR m2_s3tBS n_s3tBT]
        let {
          ds_s3tBU [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP (a_a3ttj -> b_a3ttk)
          [LclId] =
              [m1_s3tBR n_s3tBT] \u [] m1_s3tBR n_s3tBT; } in
        let {
          sat_s3tC1 [Occ=Once]
            :: forall b1.
               (b_a3ttk -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [m2_s3tBS n_s3tBT ds_s3tBU] \r [k_s3tBV]
                  let {
                    sat_s3tC0 [Occ=Once]
                      :: (a_a3ttj -> b_a3ttk) -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [m2_s3tBS n_s3tBT k_s3tBV] \r [a1_s3tBW]
                            let {
                              sat_s3tBZ [Occ=Once]
                                :: a_a3ttj -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3tBV a1_s3tBW] \r [a2_s3tBX]
                                      let {
                                        sat_s3tBY [Occ=Once] :: b_a3ttk
                                        [LclId] =
                                            [a1_s3tBW a2_s3tBX] \u [] a1_s3tBW a2_s3tBX;
                                      } in  k_s3tBV sat_s3tBY;
                            } in  m2_s3tBS n_s3tBT sat_s3tBZ;
                  } in  ds_s3tBU sat_s3tC0;
        } in  sat_s3tC1;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [a1_s3tC2 a2_s3tC3 eta_s3tC4]
        let {
          ds_s3tC5 [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttH
          [LclId] =
              [a1_s3tC2 eta_s3tC4] \u [] a1_s3tC2 eta_s3tC4; } in
        let {
          sat_s3tCc [Occ=Once]
            :: forall b1.
               (b_a3ttI -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [a2_s3tC3 eta_s3tC4 ds_s3tC5] \r [k_s3tC6]
                  let {
                    lvl1_s3tC7 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [a2_s3tC3 eta_s3tC4 k_s3tC6] \u []
                            let {
                              sat_s3tC9 [Occ=Once]
                                :: b_a3ttI -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3tC6] \r [a4_s3tC8] k_s3tC6 a4_s3tC8;
                            } in  a2_s3tC3 eta_s3tC4 sat_s3tC9; } in
                  let {
                    sat_s3tCb [Occ=Once]
                      :: a_a3ttH -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl1_s3tC7] \r [x_s3tCa] lvl1_s3tC7;
                  } in  ds_s3tC5 sat_s3tCb;
        } in  sat_s3tCc;

$c>>_r3tAR
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [eta_s3tCd eta1_s3tCe n_s3tCf]
        let {
          ds_s3tCg [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tsB
          [LclId] =
              [eta_s3tCd n_s3tCf] \u [] eta_s3tCd n_s3tCf; } in
        let {
          sat_s3tCl [Occ=Once]
            :: forall b1.
               (b_a3tsC -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [eta1_s3tCe n_s3tCf ds_s3tCg] \r [k_s3tCh]
                  let {
                    lvl1_s3tCi [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [eta1_s3tCe n_s3tCf k_s3tCh] \u [] eta1_s3tCe n_s3tCf k_s3tCh; } in
                  let {
                    sat_s3tCk [Occ=Once]
                      :: a_a3tsB -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl1_s3tCi] \r [a1_s3tCj] lvl1_s3tCi;
                  } in  ds_s3tCg sat_s3tCk;
        } in  sat_s3tCl;

Text.ParserCombinators.ReadPrec.$fMonadReadPrec_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $c>>_r3tAR eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadPrec.$fFunctorReadPrec
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec4
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec3
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec2
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec
                                     Text.ParserCombinators.ReadPrec.$fMonadReadPrec1
                                     Text.ParserCombinators.ReadPrec.$fMonadReadPrec_$c>>
                                     Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
                                     Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail
       Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadPrec.$fMonadReadPrec
                                                   Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1];

Text.ParserCombinators.ReadPrec.minPrec
  :: Text.ParserCombinators.ReadPrec.Prec
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Text.ParserCombinators.ReadPrec.reset1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s3tCm ds1_s3tCn]
        ds_s3tCm Text.ParserCombinators.ReadPrec.minPrec;

Text.ParserCombinators.ReadPrec.reset
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.reset1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.lift1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [m_s3tCo ds_s3tCp] m_s3tCo;

Text.ParserCombinators.ReadPrec.lift
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.lift1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.get1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall a.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P a)
        -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m1,
 Unf=OtherCon []] =
    [] \r [ds_s3tCq eta_s3tCr]
        Text.ParserCombinators.ReadP.Get [eta_s3tCr];

Text.ParserCombinators.ReadPrec.get
  :: Text.ParserCombinators.ReadPrec.ReadPrec GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.get1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.look1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall a.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P a)
        -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m2,
 Unf=OtherCon []] =
    [] \r [ds_s3tCs eta_s3tCt]
        Text.ParserCombinators.ReadP.Look [eta_s3tCt];

Text.ParserCombinators.ReadPrec.look
  :: Text.ParserCombinators.ReadPrec.ReadPrec GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.look1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s3tCu eta_s3tCv] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.pfail
  :: forall a. Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
            eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.step1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3tCw n_s3tCx]
        let {
          sat_s3tCB [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec
          [LclId] =
              [n_s3tCx] \u []
                  case n_s3tCx of {
                    GHC.Types.I# x_s3tCz [Occ=Once] ->
                        case +# [x_s3tCz 1#] of sat_s3tCA {
                          __DEFAULT -> GHC.Types.I# [sat_s3tCA];
                        };
                  };
        } in  ds_s3tCw sat_s3tCB;

Text.ParserCombinators.ReadPrec.step
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.step1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.prec1
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*C1(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [n_s3tCC ds_s3tCD c_s3tCE]
        case c_s3tCE of {
          GHC.Types.I# x_s3tCG [Occ=Once] ->
              case n_s3tCC of wild1_s3tCH {
                GHC.Types.I# y_s3tCI [Occ=Once] ->
                    case <=# [x_s3tCG y_s3tCI] of {
                      __DEFAULT -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
                      1# -> ds_s3tCD wild1_s3tCH;
                    };
              };
        };

Text.ParserCombinators.ReadPrec.prec
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*C1(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.prec1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3tCK ds1_s3tCL n_s3tCM]
        let {
          ds2_s3tCN [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqi
          [LclId] =
              [ds_s3tCK n_s3tCM] \u [] ds_s3tCK n_s3tCM; } in
        let {
          ds3_s3tCO [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqi
          [LclId] =
              [ds1_s3tCL n_s3tCM] \u [] ds1_s3tCL n_s3tCM; } in
        let {
          sat_s3tCS [Occ=Once]
            :: forall b.
               (a_a3tqi -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [ds2_s3tCN ds3_s3tCO] \r [k_s3tCP]
                  let {
                    sat_s3tCR [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                    [LclId] =
                        [ds3_s3tCO k_s3tCP] \u [] ds3_s3tCO k_s3tCP;
                  } in 
                    case ds2_s3tCN k_s3tCP of sat_s3tCQ {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3tCQ sat_s3tCR;
                    };
        } in  sat_s3tCS;

Text.ParserCombinators.ReadPrec.+++
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
            eta_B3 eta_B2 eta_B1;

lvl_r3tAS
  :: forall a b.
     (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s3tCT] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.choice2 [Occ=LoopBreaker]
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ds_s3tCU eta_s3tCV]
        case ds_s3tCU of {
          [] -> lvl_r3tAS;
          : y_s3tCX ys_s3tCY [Occ=Once] ->
              let {
                ds1_s3tCZ [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Text.ParserCombinators.ReadP.ReadP a_a3tqM
                [LclId] =
                    [eta_s3tCV y_s3tCX] \u [] y_s3tCX eta_s3tCV; } in
              let {
                ds2_s3tD0 [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Text.ParserCombinators.ReadP.ReadP a_a3tqM
                [LclId] =
                    [eta_s3tCV ys_s3tCY] \u []
                        Text.ParserCombinators.ReadPrec.choice2 ys_s3tCY eta_s3tCV; } in
              let {
                sat_s3tD4 [Occ=Once]
                  :: forall b.
                     (a_a3tqM -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b
                [LclId] =
                    [ds1_s3tCZ ds2_s3tD0] \r [k_s3tD1]
                        let {
                          sat_s3tD3 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                          [LclId] =
                              [ds2_s3tD0 k_s3tD1] \u [] ds2_s3tD0 k_s3tD1;
                        } in 
                          case ds1_s3tCZ k_s3tD1 of sat_s3tD2 {
                            __DEFAULT ->
                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                    sat_s3tD2 sat_s3tD3;
                          };
              } in  sat_s3tD4;
        };

Text.ParserCombinators.ReadPrec.choice1
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ps_s3tD5 eta_s3tD6]
        Text.ParserCombinators.ReadPrec.choice2 ps_s3tD5 eta_s3tD6;

Text.ParserCombinators.ReadPrec.choice
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.choice1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec2
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [v_s3tD7 eta_s3tD8]
        let {
          some_v_s3tD9 [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_a3trf]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [v_s3tD7 some_v_s3tD9] \r [n_s3tDa]
                  let {
                    ds_s3tDb [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadP a_a3trf
                    [LclId] =
                        [v_s3tD7 n_s3tDa] \u [] v_s3tD7 n_s3tDa; } in
                  let {
                    sat_s3tDl [Occ=Once]
                      :: forall b1.
                         ([a_a3trf] -> Text.ParserCombinators.ReadP.P b1)
                         -> Text.ParserCombinators.ReadP.P b1
                    [LclId] =
                        [some_v_s3tD9 n_s3tDa ds_s3tDb] \r [k_s3tDc]
                            let {
                              sat_s3tDk [Occ=Once]
                                :: a_a3trf -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [some_v_s3tD9 n_s3tDa k_s3tDc] \r [a1_s3tDd]
                                      let {
                                        sat_s3tDj [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3tDc a1_s3tDd] \u []
                                                let {
                                                  sat_s3tDi [Occ=Once] :: [a_a3trf]
                                                  [LclId] =
                                                      CCCS :! [a1_s3tDd GHC.Types.[]];
                                                } in  k_s3tDc sat_s3tDi; } in
                                      let {
                                        sat_s3tDg [Occ=Once]
                                          :: [a_a3trf] -> Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3tDc a1_s3tDd] \r [a2_s3tDe]
                                                let {
                                                  sat_s3tDf [Occ=Once] :: [a_a3trf]
                                                  [LclId] =
                                                      CCCS :! [a1_s3tDd a2_s3tDe];
                                                } in  k_s3tDc sat_s3tDf;
                                      } in 
                                        case some_v_s3tD9 n_s3tDa sat_s3tDg of sat_s3tDh {
                                          __DEFAULT ->
                                              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                  sat_s3tDh sat_s3tDj;
                                        };
                            } in  ds_s3tDb sat_s3tDk;
                  } in  sat_s3tDl;
        } in  some_v_s3tD9 eta_s3tD8;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [v_s3tDm eta_s3tDn]
        let {
          many_v_s3tDo [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_a3trn]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [v_s3tDm many_v_s3tDo] \r [n_s3tDp]
                  let {
                    ds_s3tDq [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadP a_a3trn
                    [LclId] =
                        [v_s3tDm n_s3tDp] \u [] v_s3tDm n_s3tDp; } in
                  let {
                    sat_s3tDz [Occ=Once]
                      :: forall b.
                         ([a_a3trn] -> Text.ParserCombinators.ReadP.P b)
                         -> Text.ParserCombinators.ReadP.P b
                    [LclId] =
                        [many_v_s3tDo n_s3tDp ds_s3tDq] \r [k_s3tDr]
                            let {
                              sat_s3tDy [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                              [LclId] =
                                  [k_s3tDr] \u [] k_s3tDr GHC.Types.[]; } in
                            let {
                              sat_s3tDw [Occ=Once]
                                :: a_a3trn -> Text.ParserCombinators.ReadP.P b_a3nvJ
                              [LclId] =
                                  [many_v_s3tDo n_s3tDp k_s3tDr] \r [a1_s3tDs]
                                      let {
                                        sat_s3tDv [Occ=Once]
                                          :: [a_a3trn] -> Text.ParserCombinators.ReadP.P b_a3nvJ
                                        [LclId] =
                                            [k_s3tDr a1_s3tDs] \r [a2_s3tDt]
                                                let {
                                                  sat_s3tDu [Occ=Once] :: [a_a3trn]
                                                  [LclId] =
                                                      CCCS :! [a1_s3tDs a2_s3tDt];
                                                } in  k_s3tDr sat_s3tDu;
                                      } in  many_v_s3tDo n_s3tDp sat_s3tDv;
                            } in 
                              case ds_s3tDq sat_s3tDw of sat_s3tDx {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3tDx sat_s3tDy;
                              };
                  } in  sat_s3tDz;
        } in  many_v_s3tDo eta_s3tDn;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec2
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadPlusReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec
                                         Text.ParserCombinators.ReadPrec.$fMonadReadPrec
                                         Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                         Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3];

Text.ParserCombinators.ReadPrec.<++1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3tDA ds1_s3tDB n_s3tDC]
        let {
          w_s3tDD [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqe
          [LclId] =
              [ds_s3tDA n_s3tDC] \u [] ds_s3tDA n_s3tDC; } in
        let {
          w1_s3tDE [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqe
          [LclId] =
              [ds1_s3tDB n_s3tDC] \u [] ds1_s3tDB n_s3tDC; } in
        let {
          sat_s3tDI [Occ=OnceT[0]]
            :: forall b.
               (a_a3tqe -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w_s3tDD w1_s3tDE] \r [w2_s3tDF]
                  case
                      Text.ParserCombinators.ReadP.$w<++ w_s3tDD w1_s3tDE w2_s3tDF
                  of
                  { Unit# ww1_s3tDH [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3tDH];
                  };
        } in  sat_s3tDI;

Text.ParserCombinators.ReadPrec.<++
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.<++1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.readPrec_to_P1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s3tDJ] ds_s3tDJ;

Text.ParserCombinators.ReadPrec.readPrec_to_P
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadPrec.readPrec_to_P1 eta_B1;

Text.ParserCombinators.ReadPrec.readP_to_Prec1
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [f_s3tDK] f_s3tDK;

Text.ParserCombinators.ReadPrec.readP_to_Prec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadPrec.readP_to_Prec1 eta_B1;

Text.ParserCombinators.ReadPrec.readPrec_to_S
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3tDL n_s3tDM]
        let {
          sat_s3tDN [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3tq6
          [LclId] =
              [ds_s3tDL n_s3tDM] \u []
                  ds_s3tDL
                      n_s3tDM Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s3tDN;

Text.ParserCombinators.ReadPrec.readS_to_Prec1
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s3tDO n_s3tDP]
        let {
          w_s3tDQ [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS a_a3tq2
          [LclId] =
              [f_s3tDO n_s3tDP] \u [] f_s3tDO n_s3tDP; } in
        let {
          sat_s3tDU [Occ=OnceT[0]]
            :: forall b.
               (a_a3tq2 -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w_s3tDQ] \r [w1_s3tDR]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w_s3tDQ w1_s3tDR
                  of
                  { Unit# ww1_s3tDT [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3tDT];
                  };
        } in  sat_s3tDU;

Text.ParserCombinators.ReadPrec.readS_to_Prec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.readS_to_Prec1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Text.ParserCombinators.ReadPrec.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$trModule4];

Text.ParserCombinators.ReadPrec.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text.ParserCombinators.ReadPrec"#;

Text.ParserCombinators.ReadPrec.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$trModule2];

Text.ParserCombinators.ReadPrec.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Text.ParserCombinators.ReadPrec.$trModule3
                                     Text.ParserCombinators.ReadPrec.$trModule1];

$krep_r3tAT :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcInt
                                              GHC.Types.[]];

$krep1_r3tAU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r3tAV :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r3tAU GHC.Types.[]];

$krep3_r3tAW :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadP.$tcReadP
                                              $krep2_r3tAV];

$krep4_r3tAX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r3tAT $krep3_r3tAW];

Text.ParserCombinators.ReadPrec.$tcReadPrec2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ReadPrec"#;

Text.ParserCombinators.ReadPrec.$tcReadPrec1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$tcReadPrec2];

Text.ParserCombinators.ReadPrec.$tcReadPrec :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17656447446138014199##
                                    97878223355588575##
                                    Text.ParserCombinators.ReadPrec.$trModule
                                    Text.ParserCombinators.ReadPrec.$tcReadPrec1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep5_r3tAY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadPrec.$tcReadPrec
                                              $krep2_r3tAV];

Text.ParserCombinators.ReadPrec.$tc'P1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r3tAX $krep5_r3tAY];

Text.ParserCombinators.ReadPrec.$tc'P3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'P"#;

Text.ParserCombinators.ReadPrec.$tc'P2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$tc'P3];

Text.ParserCombinators.ReadPrec.$tc'P :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14970691021354513070##
                                    16104245447600145137##
                                    Text.ParserCombinators.ReadPrec.$trModule
                                    Text.ParserCombinators.ReadPrec.$tc'P2
                                    1#
                                    Text.ParserCombinators.ReadPrec.$tc'P1];


==================== STG syntax: ====================
2018-03-16 15:58:07.148186911 UTC

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec2
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [h_s3tB0 ds_s3tB1 n_s3tB2]
        let {
          ds1_s3tB3 [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tu3
          [LclId] =
              [ds_s3tB1 n_s3tB2] \u [] ds_s3tB1 n_s3tB2; } in
        let {
          sat_s3tB6 [Occ=Once]
            :: forall b1.
               (b_a3tu4 -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [h_s3tB0 ds1_s3tB3] \r [k_s3tB4]
                  let {
                    sat_s3tB5 [Occ=Once]
                      :: a_a3tu3 -> Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [h_s3tB0 k_s3tB4] \r [eta_B1] GHC.Base.. k_s3tB4 h_s3tB0 eta_B1;
                  } in  ds1_s3tB3 sat_s3tB5;
        } in  sat_s3tB6;

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec1
  :: forall b a.
     a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [x_s3tB7 eta_s3tB8 eta1_s3tB9]
        let {
          ds_s3tBa [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP b_a3tug
          [LclId] =
              [eta_s3tB8 eta1_s3tB9] \u [] eta_s3tB8 eta1_s3tB9; } in
        let {
          sat_s3tBf [Occ=Once]
            :: forall b1.
               (a_a3tuf -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [x_s3tB7 ds_s3tBa] \r [k_s3tBb]
                  let {
                    lvl1_s3tBc [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [x_s3tB7 k_s3tBb] \u [] k_s3tBb x_s3tB7; } in
                  let {
                    sat_s3tBe [Occ=Once]
                      :: b_a3tug -> Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [lvl1_s3tBc] \r [x1_s3tBd] lvl1_s3tBc;
                  } in  ds_s3tBa sat_s3tBe;
        } in  sat_s3tBf;

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadPrec.$fFunctorReadPrec2
                                       Text.ParserCombinators.ReadPrec.$fFunctorReadPrec1];

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
  :: forall a.
     a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,A><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3tBg ds_s3tBh k_s3tBi] k_s3tBi x_s3tBg;

Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1
  :: forall a.
     GHC.Base.String
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [s_s3tBj ds_s3tBk ds1_s3tBl]
        Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.$fMonadReadPrec1
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> (a -> Text.ParserCombinators.ReadPrec.ReadPrec b)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3tBm k_s3tBn n_s3tBo]
        let {
          ds1_s3tBp [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tsh
          [LclId] =
              [ds_s3tBm n_s3tBo] \u [] ds_s3tBm n_s3tBo; } in
        let {
          sat_s3tBt [Occ=Once]
            :: forall b1.
               (b_a3tsi -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [k_s3tBn n_s3tBo ds1_s3tBp] \r [k1_s3tBq]
                  let {
                    sat_s3tBs [Occ=Once]
                      :: a_a3tsh -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3tBn n_s3tBo k1_s3tBq] \r [a1_s3tBr]
                            k_s3tBn a1_s3tBr n_s3tBo k1_s3tBq;
                  } in  ds1_s3tBp sat_s3tBs;
        } in  sat_s3tBt;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec3
  :: forall c b a.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s3tBu m1_s3tBv m2_s3tBw n_s3tBx]
        let {
          ds_s3tBy [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttu
          [LclId] =
              [m1_s3tBv n_s3tBx] \u [] m1_s3tBv n_s3tBx; } in
        let {
          sat_s3tBF [Occ=Once]
            :: forall b1.
               (c_a3ttw -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [f_s3tBu m2_s3tBw n_s3tBx ds_s3tBy] \r [k_s3tBz]
                  let {
                    sat_s3tBE [Occ=Once]
                      :: a_a3ttu -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [f_s3tBu m2_s3tBw n_s3tBx k_s3tBz] \r [a1_s3tBA]
                            let {
                              sat_s3tBD [Occ=Once]
                                :: b_a3ttv -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [f_s3tBu k_s3tBz a1_s3tBA] \r [a2_s3tBB]
                                      let {
                                        sat_s3tBC [Occ=Once] :: c_a3ttw
                                        [LclId] =
                                            [f_s3tBu a1_s3tBA a2_s3tBB] \u []
                                                f_s3tBu a1_s3tBA a2_s3tBB;
                                      } in  k_s3tBz sat_s3tBC;
                            } in  m2_s3tBw n_s3tBx sat_s3tBD;
                  } in  ds_s3tBy sat_s3tBE;
        } in  sat_s3tBF;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec1
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [m1_s3tBG m2_s3tBH n_s3tBI]
        let {
          ds_s3tBJ [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttR
          [LclId] =
              [m1_s3tBG n_s3tBI] \u [] m1_s3tBG n_s3tBI; } in
        let {
          sat_s3tBQ [Occ=Once]
            :: forall b1.
               (a_a3ttR -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [m2_s3tBH n_s3tBI ds_s3tBJ] \r [k_s3tBK]
                  let {
                    sat_s3tBP [Occ=Once]
                      :: a_a3ttR -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [m2_s3tBH n_s3tBI k_s3tBK] \r [a1_s3tBL]
                            let {
                              lvl1_s3tBM [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3tBK a1_s3tBL] \u [] k_s3tBK a1_s3tBL; } in
                            let {
                              sat_s3tBO [Occ=Once]
                                :: b_a3ttS -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl1_s3tBM] \r [a2_s3tBN] lvl1_s3tBM;
                            } in  m2_s3tBH n_s3tBI sat_s3tBO;
                  } in  ds_s3tBJ sat_s3tBP;
        } in  sat_s3tBQ;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec4
  :: forall b a.
     Text.ParserCombinators.ReadPrec.ReadPrec (a -> b)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [m1_s3tBR m2_s3tBS n_s3tBT]
        let {
          ds_s3tBU [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP (a_a3ttj -> b_a3ttk)
          [LclId] =
              [m1_s3tBR n_s3tBT] \u [] m1_s3tBR n_s3tBT; } in
        let {
          sat_s3tC1 [Occ=Once]
            :: forall b1.
               (b_a3ttk -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [m2_s3tBS n_s3tBT ds_s3tBU] \r [k_s3tBV]
                  let {
                    sat_s3tC0 [Occ=Once]
                      :: (a_a3ttj -> b_a3ttk) -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [m2_s3tBS n_s3tBT k_s3tBV] \r [a1_s3tBW]
                            let {
                              sat_s3tBZ [Occ=Once]
                                :: a_a3ttj -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3tBV a1_s3tBW] \r [a2_s3tBX]
                                      let {
                                        sat_s3tBY [Occ=Once] :: b_a3ttk
                                        [LclId] =
                                            [a1_s3tBW a2_s3tBX] \u [] a1_s3tBW a2_s3tBX;
                                      } in  k_s3tBV sat_s3tBY;
                            } in  m2_s3tBS n_s3tBT sat_s3tBZ;
                  } in  ds_s3tBU sat_s3tC0;
        } in  sat_s3tC1;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [a1_s3tC2 a2_s3tC3 eta_s3tC4]
        let {
          ds_s3tC5 [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttH
          [LclId] =
              [a1_s3tC2 eta_s3tC4] \u [] a1_s3tC2 eta_s3tC4; } in
        let {
          sat_s3tCc [Occ=Once]
            :: forall b1.
               (b_a3ttI -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [a2_s3tC3 eta_s3tC4 ds_s3tC5] \r [k_s3tC6]
                  let {
                    lvl1_s3tC7 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [a2_s3tC3 eta_s3tC4 k_s3tC6] \u []
                            let {
                              sat_s3tC9 [Occ=Once]
                                :: b_a3ttI -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3tC6] \r [a4_s3tC8] k_s3tC6 a4_s3tC8;
                            } in  a2_s3tC3 eta_s3tC4 sat_s3tC9; } in
                  let {
                    sat_s3tCb [Occ=Once]
                      :: a_a3ttH -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl1_s3tC7] \r [x_s3tCa] lvl1_s3tC7;
                  } in  ds_s3tC5 sat_s3tCb;
        } in  sat_s3tCc;

$c>>_r3tAR
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [eta_s3tCd eta1_s3tCe n_s3tCf]
        let {
          ds_s3tCg [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tsB
          [LclId] =
              [eta_s3tCd n_s3tCf] \u [] eta_s3tCd n_s3tCf; } in
        let {
          sat_s3tCl [Occ=Once]
            :: forall b1.
               (b_a3tsC -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [eta1_s3tCe n_s3tCf ds_s3tCg] \r [k_s3tCh]
                  let {
                    lvl1_s3tCi [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [eta1_s3tCe n_s3tCf k_s3tCh] \u [] eta1_s3tCe n_s3tCf k_s3tCh; } in
                  let {
                    sat_s3tCk [Occ=Once]
                      :: a_a3tsB -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl1_s3tCi] \r [a1_s3tCj] lvl1_s3tCi;
                  } in  ds_s3tCg sat_s3tCk;
        } in  sat_s3tCl;

Text.ParserCombinators.ReadPrec.$fMonadReadPrec_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $c>>_r3tAR eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadPrec.$fFunctorReadPrec
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec4
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec3
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec2
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec
                                     Text.ParserCombinators.ReadPrec.$fMonadReadPrec1
                                     Text.ParserCombinators.ReadPrec.$fMonadReadPrec_$c>>
                                     Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
                                     Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail
       Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadPrec.$fMonadReadPrec
                                                   Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1];

Text.ParserCombinators.ReadPrec.minPrec
  :: Text.ParserCombinators.ReadPrec.Prec
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Text.ParserCombinators.ReadPrec.reset1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s3tCm ds1_s3tCn]
        ds_s3tCm Text.ParserCombinators.ReadPrec.minPrec;

Text.ParserCombinators.ReadPrec.reset
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.reset1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.lift1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [m_s3tCo ds_s3tCp] m_s3tCo;

Text.ParserCombinators.ReadPrec.lift
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.lift1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.get1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall a.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P a)
        -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m1,
 Unf=OtherCon []] =
    [] \r [ds_s3tCq eta_s3tCr]
        Text.ParserCombinators.ReadP.Get [eta_s3tCr];

Text.ParserCombinators.ReadPrec.get
  :: Text.ParserCombinators.ReadPrec.ReadPrec GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.get1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.look1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall a.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P a)
        -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m2,
 Unf=OtherCon []] =
    [] \r [ds_s3tCs eta_s3tCt]
        Text.ParserCombinators.ReadP.Look [eta_s3tCt];

Text.ParserCombinators.ReadPrec.look
  :: Text.ParserCombinators.ReadPrec.ReadPrec GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.look1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s3tCu eta_s3tCv] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.pfail
  :: forall a. Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
            eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.step1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3tCw n_s3tCx]
        let {
          sat_s3tCB [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec
          [LclId] =
              [n_s3tCx] \u []
                  case n_s3tCx of {
                    GHC.Types.I# x_s3tCz [Occ=Once] ->
                        case +# [x_s3tCz 1#] of sat_s3tCA {
                          __DEFAULT -> GHC.Types.I# [sat_s3tCA];
                        };
                  };
        } in  ds_s3tCw sat_s3tCB;

Text.ParserCombinators.ReadPrec.step
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.step1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.prec1
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*C1(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [n_s3tCC ds_s3tCD c_s3tCE]
        case c_s3tCE of {
          GHC.Types.I# x_s3tCG [Occ=Once] ->
              case n_s3tCC of wild1_s3tCH {
                GHC.Types.I# y_s3tCI [Occ=Once] ->
                    case <=# [x_s3tCG y_s3tCI] of {
                      __DEFAULT -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
                      1# -> ds_s3tCD wild1_s3tCH;
                    };
              };
        };

Text.ParserCombinators.ReadPrec.prec
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*C1(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.prec1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3tCK ds1_s3tCL n_s3tCM]
        let {
          ds2_s3tCN [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqi
          [LclId] =
              [ds_s3tCK n_s3tCM] \u [] ds_s3tCK n_s3tCM; } in
        let {
          ds3_s3tCO [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqi
          [LclId] =
              [ds1_s3tCL n_s3tCM] \u [] ds1_s3tCL n_s3tCM; } in
        let {
          sat_s3tCS [Occ=Once]
            :: forall b.
               (a_a3tqi -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [ds2_s3tCN ds3_s3tCO] \r [k_s3tCP]
                  let {
                    sat_s3tCR [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                    [LclId] =
                        [ds3_s3tCO k_s3tCP] \u [] ds3_s3tCO k_s3tCP;
                  } in 
                    case ds2_s3tCN k_s3tCP of sat_s3tCQ {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3tCQ sat_s3tCR;
                    };
        } in  sat_s3tCS;

Text.ParserCombinators.ReadPrec.+++
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
            eta_B3 eta_B2 eta_B1;

lvl_r3tAS
  :: forall a b.
     (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s3tCT] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.choice2 [Occ=LoopBreaker]
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ds_s3tCU eta_s3tCV]
        case ds_s3tCU of {
          [] -> lvl_r3tAS;
          : y_s3tCX ys_s3tCY [Occ=Once] ->
              let {
                ds1_s3tCZ [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Text.ParserCombinators.ReadP.ReadP a_a3tqM
                [LclId] =
                    [eta_s3tCV y_s3tCX] \u [] y_s3tCX eta_s3tCV; } in
              let {
                ds2_s3tD0 [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Text.ParserCombinators.ReadP.ReadP a_a3tqM
                [LclId] =
                    [eta_s3tCV ys_s3tCY] \u []
                        Text.ParserCombinators.ReadPrec.choice2 ys_s3tCY eta_s3tCV; } in
              let {
                sat_s3tD4 [Occ=Once]
                  :: forall b.
                     (a_a3tqM -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b
                [LclId] =
                    [ds1_s3tCZ ds2_s3tD0] \r [k_s3tD1]
                        let {
                          sat_s3tD3 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                          [LclId] =
                              [ds2_s3tD0 k_s3tD1] \u [] ds2_s3tD0 k_s3tD1;
                        } in 
                          case ds1_s3tCZ k_s3tD1 of sat_s3tD2 {
                            __DEFAULT ->
                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                    sat_s3tD2 sat_s3tD3;
                          };
              } in  sat_s3tD4;
        };

Text.ParserCombinators.ReadPrec.choice1
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ps_s3tD5 eta_s3tD6]
        Text.ParserCombinators.ReadPrec.choice2 ps_s3tD5 eta_s3tD6;

Text.ParserCombinators.ReadPrec.choice
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.choice1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec2
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [v_s3tD7 eta_s3tD8]
        let {
          some_v_s3tD9 [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_a3trf]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [v_s3tD7 some_v_s3tD9] \r [n_s3tDa]
                  let {
                    ds_s3tDb [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadP a_a3trf
                    [LclId] =
                        [v_s3tD7 n_s3tDa] \u [] v_s3tD7 n_s3tDa; } in
                  let {
                    sat_s3tDl [Occ=Once]
                      :: forall b1.
                         ([a_a3trf] -> Text.ParserCombinators.ReadP.P b1)
                         -> Text.ParserCombinators.ReadP.P b1
                    [LclId] =
                        [some_v_s3tD9 n_s3tDa ds_s3tDb] \r [k_s3tDc]
                            let {
                              sat_s3tDk [Occ=Once]
                                :: a_a3trf -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [some_v_s3tD9 n_s3tDa k_s3tDc] \r [a1_s3tDd]
                                      let {
                                        sat_s3tDj [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3tDc a1_s3tDd] \u []
                                                let {
                                                  sat_s3tDi [Occ=Once] :: [a_a3trf]
                                                  [LclId] =
                                                      CCCS :! [a1_s3tDd GHC.Types.[]];
                                                } in  k_s3tDc sat_s3tDi; } in
                                      let {
                                        sat_s3tDg [Occ=Once]
                                          :: [a_a3trf] -> Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3tDc a1_s3tDd] \r [a2_s3tDe]
                                                let {
                                                  sat_s3tDf [Occ=Once] :: [a_a3trf]
                                                  [LclId] =
                                                      CCCS :! [a1_s3tDd a2_s3tDe];
                                                } in  k_s3tDc sat_s3tDf;
                                      } in 
                                        case some_v_s3tD9 n_s3tDa sat_s3tDg of sat_s3tDh {
                                          __DEFAULT ->
                                              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                  sat_s3tDh sat_s3tDj;
                                        };
                            } in  ds_s3tDb sat_s3tDk;
                  } in  sat_s3tDl;
        } in  some_v_s3tD9 eta_s3tD8;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [v_s3tDm eta_s3tDn]
        let {
          many_v_s3tDo [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_a3trn]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [v_s3tDm many_v_s3tDo] \r [n_s3tDp]
                  let {
                    ds_s3tDq [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadP a_a3trn
                    [LclId] =
                        [v_s3tDm n_s3tDp] \u [] v_s3tDm n_s3tDp; } in
                  let {
                    sat_s3tDz [Occ=Once]
                      :: forall b.
                         ([a_a3trn] -> Text.ParserCombinators.ReadP.P b)
                         -> Text.ParserCombinators.ReadP.P b
                    [LclId] =
                        [many_v_s3tDo n_s3tDp ds_s3tDq] \r [k_s3tDr]
                            let {
                              sat_s3tDy [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                              [LclId] =
                                  [k_s3tDr] \u [] k_s3tDr GHC.Types.[]; } in
                            let {
                              sat_s3tDw [Occ=Once]
                                :: a_a3trn -> Text.ParserCombinators.ReadP.P b_a3nvJ
                              [LclId] =
                                  [many_v_s3tDo n_s3tDp k_s3tDr] \r [a1_s3tDs]
                                      let {
                                        sat_s3tDv [Occ=Once]
                                          :: [a_a3trn] -> Text.ParserCombinators.ReadP.P b_a3nvJ
                                        [LclId] =
                                            [k_s3tDr a1_s3tDs] \r [a2_s3tDt]
                                                let {
                                                  sat_s3tDu [Occ=Once] :: [a_a3trn]
                                                  [LclId] =
                                                      CCCS :! [a1_s3tDs a2_s3tDt];
                                                } in  k_s3tDr sat_s3tDu;
                                      } in  many_v_s3tDo n_s3tDp sat_s3tDv;
                            } in 
                              case ds_s3tDq sat_s3tDw of sat_s3tDx {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3tDx sat_s3tDy;
                              };
                  } in  sat_s3tDz;
        } in  many_v_s3tDo eta_s3tDn;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec2
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadPlusReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec
                                         Text.ParserCombinators.ReadPrec.$fMonadReadPrec
                                         Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                         Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3];

Text.ParserCombinators.ReadPrec.<++1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3tDA ds1_s3tDB n_s3tDC]
        let {
          w_s3tDD [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqe
          [LclId] =
              [ds_s3tDA n_s3tDC] \u [] ds_s3tDA n_s3tDC; } in
        let {
          w1_s3tDE [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqe
          [LclId] =
              [ds1_s3tDB n_s3tDC] \u [] ds1_s3tDB n_s3tDC; } in
        let {
          sat_s3tDI [Occ=OnceT[0]]
            :: forall b.
               (a_a3tqe -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w_s3tDD w1_s3tDE] \r [w2_s3tDF]
                  case
                      Text.ParserCombinators.ReadP.$w<++ w_s3tDD w1_s3tDE w2_s3tDF
                  of
                  { Unit# ww1_s3tDH [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3tDH];
                  };
        } in  sat_s3tDI;

Text.ParserCombinators.ReadPrec.<++
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.<++1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.readPrec_to_P1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s3tDJ] ds_s3tDJ;

Text.ParserCombinators.ReadPrec.readPrec_to_P
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadPrec.readPrec_to_P1 eta_B1;

Text.ParserCombinators.ReadPrec.readP_to_Prec1
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [f_s3tDK] f_s3tDK;

Text.ParserCombinators.ReadPrec.readP_to_Prec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadPrec.readP_to_Prec1 eta_B1;

Text.ParserCombinators.ReadPrec.readPrec_to_S
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3tDL n_s3tDM]
        let {
          sat_s3tDN [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3tq6
          [LclId] =
              [ds_s3tDL n_s3tDM] \u []
                  ds_s3tDL
                      n_s3tDM Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s3tDN;

Text.ParserCombinators.ReadPrec.readS_to_Prec1
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s3tDO n_s3tDP]
        let {
          w_s3tDQ [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS a_a3tq2
          [LclId] =
              [f_s3tDO n_s3tDP] \u [] f_s3tDO n_s3tDP; } in
        let {
          sat_s3tDU [Occ=OnceT[0]]
            :: forall b.
               (a_a3tq2 -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w_s3tDQ] \r [w1_s3tDR]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w_s3tDQ w1_s3tDR
                  of
                  { Unit# ww1_s3tDT [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3tDT];
                  };
        } in  sat_s3tDU;

Text.ParserCombinators.ReadPrec.readS_to_Prec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.readS_to_Prec1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Text.ParserCombinators.ReadPrec.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$trModule4];

Text.ParserCombinators.ReadPrec.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text.ParserCombinators.ReadPrec"#;

Text.ParserCombinators.ReadPrec.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$trModule2];

Text.ParserCombinators.ReadPrec.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Text.ParserCombinators.ReadPrec.$trModule3
                                     Text.ParserCombinators.ReadPrec.$trModule1];

$krep_r3tAT :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcInt
                                              GHC.Types.[]];

$krep1_r3tAU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r3tAV :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r3tAU GHC.Types.[]];

$krep3_r3tAW :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadP.$tcReadP
                                              $krep2_r3tAV];

$krep4_r3tAX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r3tAT $krep3_r3tAW];

Text.ParserCombinators.ReadPrec.$tcReadPrec2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ReadPrec"#;

Text.ParserCombinators.ReadPrec.$tcReadPrec1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$tcReadPrec2];

Text.ParserCombinators.ReadPrec.$tcReadPrec :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17656447446138014199##
                                    97878223355588575##
                                    Text.ParserCombinators.ReadPrec.$trModule
                                    Text.ParserCombinators.ReadPrec.$tcReadPrec1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep5_r3tAY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadPrec.$tcReadPrec
                                              $krep2_r3tAV];

Text.ParserCombinators.ReadPrec.$tc'P1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r3tAX $krep5_r3tAY];

Text.ParserCombinators.ReadPrec.$tc'P3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'P"#;

Text.ParserCombinators.ReadPrec.$tc'P2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$tc'P3];

Text.ParserCombinators.ReadPrec.$tc'P :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14970691021354513070##
                                    16104245447600145137##
                                    Text.ParserCombinators.ReadPrec.$trModule
                                    Text.ParserCombinators.ReadPrec.$tc'P2
                                    1#
                                    Text.ParserCombinators.ReadPrec.$tc'P1];


==================== Pre unarise: ====================
2018-03-16 15:58:08.366167572 UTC

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec2
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [h_s3umE ds_s3umF n_s3umG]
        let {
          ds1_s3umH [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tu3
          [LclId] =
              [ds_s3umF n_s3umG] \u [] ds_s3umF n_s3umG; } in
        let {
          sat_s3umK [Occ=Once]
            :: forall b1.
               (b_a3tu4 -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [h_s3umE ds1_s3umH] \r [k_s3umI]
                  let {
                    sat_s3umJ [Occ=Once]
                      :: a_a3tu3 -> Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [h_s3umE k_s3umI] \r [eta_B1] GHC.Base.. k_s3umI h_s3umE eta_B1;
                  } in  ds1_s3umH sat_s3umJ;
        } in  sat_s3umK;

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec1
  :: forall b a.
     a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [x_s3umL eta_s3umM eta1_s3umN]
        let {
          ds_s3umO [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP b_a3tug
          [LclId] =
              [eta_s3umM eta1_s3umN] \u [] eta_s3umM eta1_s3umN; } in
        let {
          sat_s3umT [Occ=Once]
            :: forall b1.
               (a_a3tuf -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [x_s3umL ds_s3umO] \r [k_s3umP]
                  let {
                    lvl1_s3umQ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [x_s3umL k_s3umP] \u [] k_s3umP x_s3umL; } in
                  let {
                    sat_s3umS [Occ=Once]
                      :: b_a3tug -> Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [lvl1_s3umQ] \r [x1_s3umR] lvl1_s3umQ;
                  } in  ds_s3umO sat_s3umS;
        } in  sat_s3umT;

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadPrec.$fFunctorReadPrec2
                                       Text.ParserCombinators.ReadPrec.$fFunctorReadPrec1];

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
  :: forall a.
     a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,A><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3umU ds_s3umV k_s3umW] k_s3umW x_s3umU;

Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1
  :: forall a.
     GHC.Base.String
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [s_s3umX ds_s3umY ds1_s3umZ]
        Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.$fMonadReadPrec1
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> (a -> Text.ParserCombinators.ReadPrec.ReadPrec b)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3un0 k_s3un1 n_s3un2]
        let {
          ds1_s3un3 [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tsh
          [LclId] =
              [ds_s3un0 n_s3un2] \u [] ds_s3un0 n_s3un2; } in
        let {
          sat_s3un7 [Occ=Once]
            :: forall b1.
               (b_a3tsi -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [k_s3un1 n_s3un2 ds1_s3un3] \r [k1_s3un4]
                  let {
                    sat_s3un6 [Occ=Once]
                      :: a_a3tsh -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3un1 n_s3un2 k1_s3un4] \r [a1_s3un5]
                            k_s3un1 a1_s3un5 n_s3un2 k1_s3un4;
                  } in  ds1_s3un3 sat_s3un6;
        } in  sat_s3un7;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec3
  :: forall c b a.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s3un8 m1_s3un9 m2_s3una n_s3unb]
        let {
          ds_s3unc [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttu
          [LclId] =
              [m1_s3un9 n_s3unb] \u [] m1_s3un9 n_s3unb; } in
        let {
          sat_s3unj [Occ=Once]
            :: forall b1.
               (c_a3ttw -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [f_s3un8 m2_s3una n_s3unb ds_s3unc] \r [k_s3und]
                  let {
                    sat_s3uni [Occ=Once]
                      :: a_a3ttu -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [f_s3un8 m2_s3una n_s3unb k_s3und] \r [a1_s3une]
                            let {
                              sat_s3unh [Occ=Once]
                                :: b_a3ttv -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [f_s3un8 k_s3und a1_s3une] \r [a2_s3unf]
                                      let {
                                        sat_s3ung [Occ=Once] :: c_a3ttw
                                        [LclId] =
                                            [f_s3un8 a1_s3une a2_s3unf] \u []
                                                f_s3un8 a1_s3une a2_s3unf;
                                      } in  k_s3und sat_s3ung;
                            } in  m2_s3una n_s3unb sat_s3unh;
                  } in  ds_s3unc sat_s3uni;
        } in  sat_s3unj;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec1
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [m1_s3unk m2_s3unl n_s3unm]
        let {
          ds_s3unn [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttR
          [LclId] =
              [m1_s3unk n_s3unm] \u [] m1_s3unk n_s3unm; } in
        let {
          sat_s3unu [Occ=Once]
            :: forall b1.
               (a_a3ttR -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [m2_s3unl n_s3unm ds_s3unn] \r [k_s3uno]
                  let {
                    sat_s3unt [Occ=Once]
                      :: a_a3ttR -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [m2_s3unl n_s3unm k_s3uno] \r [a1_s3unp]
                            let {
                              lvl1_s3unq [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3uno a1_s3unp] \u [] k_s3uno a1_s3unp; } in
                            let {
                              sat_s3uns [Occ=Once]
                                :: b_a3ttS -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl1_s3unq] \r [a2_s3unr] lvl1_s3unq;
                            } in  m2_s3unl n_s3unm sat_s3uns;
                  } in  ds_s3unn sat_s3unt;
        } in  sat_s3unu;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec4
  :: forall b a.
     Text.ParserCombinators.ReadPrec.ReadPrec (a -> b)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [m1_s3unv m2_s3unw n_s3unx]
        let {
          ds_s3uny [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP (a_a3ttj -> b_a3ttk)
          [LclId] =
              [m1_s3unv n_s3unx] \u [] m1_s3unv n_s3unx; } in
        let {
          sat_s3unF [Occ=Once]
            :: forall b1.
               (b_a3ttk -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [m2_s3unw n_s3unx ds_s3uny] \r [k_s3unz]
                  let {
                    sat_s3unE [Occ=Once]
                      :: (a_a3ttj -> b_a3ttk) -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [m2_s3unw n_s3unx k_s3unz] \r [a1_s3unA]
                            let {
                              sat_s3unD [Occ=Once]
                                :: a_a3ttj -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3unz a1_s3unA] \r [a2_s3unB]
                                      let {
                                        sat_s3unC [Occ=Once] :: b_a3ttk
                                        [LclId] =
                                            [a1_s3unA a2_s3unB] \u [] a1_s3unA a2_s3unB;
                                      } in  k_s3unz sat_s3unC;
                            } in  m2_s3unw n_s3unx sat_s3unD;
                  } in  ds_s3uny sat_s3unE;
        } in  sat_s3unF;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [a1_s3unG a2_s3unH eta_s3unI]
        let {
          ds_s3unJ [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttH
          [LclId] =
              [a1_s3unG eta_s3unI] \u [] a1_s3unG eta_s3unI; } in
        let {
          sat_s3unQ [Occ=Once]
            :: forall b1.
               (b_a3ttI -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [a2_s3unH eta_s3unI ds_s3unJ] \r [k_s3unK]
                  let {
                    lvl1_s3unL [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [a2_s3unH eta_s3unI k_s3unK] \u []
                            let {
                              sat_s3unN [Occ=Once]
                                :: b_a3ttI -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3unK] \r [a4_s3unM] k_s3unK a4_s3unM;
                            } in  a2_s3unH eta_s3unI sat_s3unN; } in
                  let {
                    sat_s3unP [Occ=Once]
                      :: a_a3ttH -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl1_s3unL] \r [x_s3unO] lvl1_s3unL;
                  } in  ds_s3unJ sat_s3unP;
        } in  sat_s3unQ;

$c>>_r3tAR
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [eta_s3unR eta1_s3unS n_s3unT]
        let {
          ds_s3unU [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tsB
          [LclId] =
              [eta_s3unR n_s3unT] \u [] eta_s3unR n_s3unT; } in
        let {
          sat_s3unZ [Occ=Once]
            :: forall b1.
               (b_a3tsC -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [eta1_s3unS n_s3unT ds_s3unU] \r [k_s3unV]
                  let {
                    lvl1_s3unW [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [eta1_s3unS n_s3unT k_s3unV] \u [] eta1_s3unS n_s3unT k_s3unV; } in
                  let {
                    sat_s3unY [Occ=Once]
                      :: a_a3tsB -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl1_s3unW] \r [a1_s3unX] lvl1_s3unW;
                  } in  ds_s3unU sat_s3unY;
        } in  sat_s3unZ;

Text.ParserCombinators.ReadPrec.$fMonadReadPrec_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $c>>_r3tAR eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadPrec.$fFunctorReadPrec
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec4
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec3
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec2
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec
                                     Text.ParserCombinators.ReadPrec.$fMonadReadPrec1
                                     Text.ParserCombinators.ReadPrec.$fMonadReadPrec_$c>>
                                     Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
                                     Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail
       Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadPrec.$fMonadReadPrec
                                                   Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1];

Text.ParserCombinators.ReadPrec.minPrec
  :: Text.ParserCombinators.ReadPrec.Prec
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Text.ParserCombinators.ReadPrec.reset1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s3uo0 ds1_s3uo1]
        ds_s3uo0 Text.ParserCombinators.ReadPrec.minPrec;

Text.ParserCombinators.ReadPrec.reset
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.reset1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.lift1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [m_s3uo2 ds_s3uo3] m_s3uo2;

Text.ParserCombinators.ReadPrec.lift
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.lift1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.get1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall a.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P a)
        -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m1,
 Unf=OtherCon []] =
    [] \r [ds_s3uo4 eta_s3uo5]
        Text.ParserCombinators.ReadP.Get [eta_s3uo5];

Text.ParserCombinators.ReadPrec.get
  :: Text.ParserCombinators.ReadPrec.ReadPrec GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.get1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.look1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall a.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P a)
        -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m2,
 Unf=OtherCon []] =
    [] \r [ds_s3uo6 eta_s3uo7]
        Text.ParserCombinators.ReadP.Look [eta_s3uo7];

Text.ParserCombinators.ReadPrec.look
  :: Text.ParserCombinators.ReadPrec.ReadPrec GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.look1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s3uo8 eta_s3uo9] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.pfail
  :: forall a. Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
            eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.step1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3uoa n_s3uob]
        let {
          sat_s3uof [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec
          [LclId] =
              [n_s3uob] \u []
                  case n_s3uob of {
                    GHC.Types.I# x_s3uod [Occ=Once] ->
                        case +# [x_s3uod 1#] of sat_s3uoe {
                          __DEFAULT -> GHC.Types.I# [sat_s3uoe];
                        };
                  };
        } in  ds_s3uoa sat_s3uof;

Text.ParserCombinators.ReadPrec.step
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.step1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.prec1
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*C1(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [n_s3uog ds_s3uoh c_s3uoi]
        case c_s3uoi of {
          GHC.Types.I# x_s3uok [Occ=Once] ->
              case n_s3uog of wild1_s3uol {
                GHC.Types.I# y_s3uom [Occ=Once] ->
                    case <=# [x_s3uok y_s3uom] of {
                      __DEFAULT -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
                      1# -> ds_s3uoh wild1_s3uol;
                    };
              };
        };

Text.ParserCombinators.ReadPrec.prec
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*C1(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.prec1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3uoo ds1_s3uop n_s3uoq]
        let {
          ds2_s3uor [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqi
          [LclId] =
              [ds_s3uoo n_s3uoq] \u [] ds_s3uoo n_s3uoq; } in
        let {
          ds3_s3uos [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqi
          [LclId] =
              [ds1_s3uop n_s3uoq] \u [] ds1_s3uop n_s3uoq; } in
        let {
          sat_s3uow [Occ=Once]
            :: forall b.
               (a_a3tqi -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [ds2_s3uor ds3_s3uos] \r [k_s3uot]
                  let {
                    sat_s3uov [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                    [LclId] =
                        [ds3_s3uos k_s3uot] \u [] ds3_s3uos k_s3uot;
                  } in 
                    case ds2_s3uor k_s3uot of sat_s3uou {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3uou sat_s3uov;
                    };
        } in  sat_s3uow;

Text.ParserCombinators.ReadPrec.+++
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
            eta_B3 eta_B2 eta_B1;

lvl_r3tAS
  :: forall a b.
     (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s3uox] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.choice2 [Occ=LoopBreaker]
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ds_s3uoy eta_s3uoz]
        case ds_s3uoy of {
          [] -> lvl_r3tAS;
          : y_s3uoB ys_s3uoC [Occ=Once] ->
              let {
                ds1_s3uoD [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Text.ParserCombinators.ReadP.ReadP a_a3tqM
                [LclId] =
                    [eta_s3uoz y_s3uoB] \u [] y_s3uoB eta_s3uoz; } in
              let {
                ds2_s3uoE [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Text.ParserCombinators.ReadP.ReadP a_a3tqM
                [LclId] =
                    [eta_s3uoz ys_s3uoC] \u []
                        Text.ParserCombinators.ReadPrec.choice2 ys_s3uoC eta_s3uoz; } in
              let {
                sat_s3uoI [Occ=Once]
                  :: forall b.
                     (a_a3tqM -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b
                [LclId] =
                    [ds1_s3uoD ds2_s3uoE] \r [k_s3uoF]
                        let {
                          sat_s3uoH [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                          [LclId] =
                              [ds2_s3uoE k_s3uoF] \u [] ds2_s3uoE k_s3uoF;
                        } in 
                          case ds1_s3uoD k_s3uoF of sat_s3uoG {
                            __DEFAULT ->
                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                    sat_s3uoG sat_s3uoH;
                          };
              } in  sat_s3uoI;
        };

Text.ParserCombinators.ReadPrec.choice1
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ps_s3uoJ eta_s3uoK]
        Text.ParserCombinators.ReadPrec.choice2 ps_s3uoJ eta_s3uoK;

Text.ParserCombinators.ReadPrec.choice
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.choice1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec2
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [v_s3uoL eta_s3uoM]
        let {
          some_v_s3uoN [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_a3trf]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [v_s3uoL some_v_s3uoN] \r [n_s3uoO]
                  let {
                    ds_s3uoP [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadP a_a3trf
                    [LclId] =
                        [v_s3uoL n_s3uoO] \u [] v_s3uoL n_s3uoO; } in
                  let {
                    sat_s3uoZ [Occ=Once]
                      :: forall b1.
                         ([a_a3trf] -> Text.ParserCombinators.ReadP.P b1)
                         -> Text.ParserCombinators.ReadP.P b1
                    [LclId] =
                        [some_v_s3uoN n_s3uoO ds_s3uoP] \r [k_s3uoQ]
                            let {
                              sat_s3uoY [Occ=Once]
                                :: a_a3trf -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [some_v_s3uoN n_s3uoO k_s3uoQ] \r [a1_s3uoR]
                                      let {
                                        sat_s3uoX [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3uoQ a1_s3uoR] \u []
                                                let {
                                                  sat_s3uoW [Occ=Once] :: [a_a3trf]
                                                  [LclId] =
                                                      CCCS :! [a1_s3uoR GHC.Types.[]];
                                                } in  k_s3uoQ sat_s3uoW; } in
                                      let {
                                        sat_s3uoU [Occ=Once]
                                          :: [a_a3trf] -> Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3uoQ a1_s3uoR] \r [a2_s3uoS]
                                                let {
                                                  sat_s3uoT [Occ=Once] :: [a_a3trf]
                                                  [LclId] =
                                                      CCCS :! [a1_s3uoR a2_s3uoS];
                                                } in  k_s3uoQ sat_s3uoT;
                                      } in 
                                        case some_v_s3uoN n_s3uoO sat_s3uoU of sat_s3uoV {
                                          __DEFAULT ->
                                              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                  sat_s3uoV sat_s3uoX;
                                        };
                            } in  ds_s3uoP sat_s3uoY;
                  } in  sat_s3uoZ;
        } in  some_v_s3uoN eta_s3uoM;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [v_s3up0 eta_s3up1]
        let {
          many_v_s3up2 [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_a3trn]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [v_s3up0 many_v_s3up2] \r [n_s3up3]
                  let {
                    ds_s3up4 [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadP a_a3trn
                    [LclId] =
                        [v_s3up0 n_s3up3] \u [] v_s3up0 n_s3up3; } in
                  let {
                    sat_s3upd [Occ=Once]
                      :: forall b.
                         ([a_a3trn] -> Text.ParserCombinators.ReadP.P b)
                         -> Text.ParserCombinators.ReadP.P b
                    [LclId] =
                        [many_v_s3up2 n_s3up3 ds_s3up4] \r [k_s3up5]
                            let {
                              sat_s3upc [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                              [LclId] =
                                  [k_s3up5] \u [] k_s3up5 GHC.Types.[]; } in
                            let {
                              sat_s3upa [Occ=Once]
                                :: a_a3trn -> Text.ParserCombinators.ReadP.P b_a3nvJ
                              [LclId] =
                                  [many_v_s3up2 n_s3up3 k_s3up5] \r [a1_s3up6]
                                      let {
                                        sat_s3up9 [Occ=Once]
                                          :: [a_a3trn] -> Text.ParserCombinators.ReadP.P b_a3nvJ
                                        [LclId] =
                                            [k_s3up5 a1_s3up6] \r [a2_s3up7]
                                                let {
                                                  sat_s3up8 [Occ=Once] :: [a_a3trn]
                                                  [LclId] =
                                                      CCCS :! [a1_s3up6 a2_s3up7];
                                                } in  k_s3up5 sat_s3up8;
                                      } in  many_v_s3up2 n_s3up3 sat_s3up9;
                            } in 
                              case ds_s3up4 sat_s3upa of sat_s3upb {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3upb sat_s3upc;
                              };
                  } in  sat_s3upd;
        } in  many_v_s3up2 eta_s3up1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec2
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadPlusReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec
                                         Text.ParserCombinators.ReadPrec.$fMonadReadPrec
                                         Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                         Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3];

Text.ParserCombinators.ReadPrec.<++1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3upe ds1_s3upf n_s3upg]
        let {
          w_s3uph [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqe
          [LclId] =
              [ds_s3upe n_s3upg] \u [] ds_s3upe n_s3upg; } in
        let {
          w1_s3upi [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqe
          [LclId] =
              [ds1_s3upf n_s3upg] \u [] ds1_s3upf n_s3upg; } in
        let {
          sat_s3upm [Occ=OnceT[0]]
            :: forall b.
               (a_a3tqe -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w_s3uph w1_s3upi] \r [w2_s3upj]
                  case
                      Text.ParserCombinators.ReadP.$w<++ w_s3uph w1_s3upi w2_s3upj
                  of
                  { Unit# ww1_s3upl [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3upl];
                  };
        } in  sat_s3upm;

Text.ParserCombinators.ReadPrec.<++
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.<++1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.readPrec_to_P1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s3upn] ds_s3upn;

Text.ParserCombinators.ReadPrec.readPrec_to_P
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadPrec.readPrec_to_P1 eta_B1;

Text.ParserCombinators.ReadPrec.readP_to_Prec1
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [f_s3upo] f_s3upo;

Text.ParserCombinators.ReadPrec.readP_to_Prec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadPrec.readP_to_Prec1 eta_B1;

Text.ParserCombinators.ReadPrec.readPrec_to_S
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3upp n_s3upq]
        let {
          sat_s3upr [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3tq6
          [LclId] =
              [ds_s3upp n_s3upq] \u []
                  ds_s3upp
                      n_s3upq Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s3upr;

Text.ParserCombinators.ReadPrec.readS_to_Prec1
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s3ups n_s3upt]
        let {
          w_s3upu [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS a_a3tq2
          [LclId] =
              [f_s3ups n_s3upt] \u [] f_s3ups n_s3upt; } in
        let {
          sat_s3upy [Occ=OnceT[0]]
            :: forall b.
               (a_a3tq2 -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w_s3upu] \r [w1_s3upv]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w_s3upu w1_s3upv
                  of
                  { Unit# ww1_s3upx [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3upx];
                  };
        } in  sat_s3upy;

Text.ParserCombinators.ReadPrec.readS_to_Prec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.readS_to_Prec1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Text.ParserCombinators.ReadPrec.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$trModule4];

Text.ParserCombinators.ReadPrec.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text.ParserCombinators.ReadPrec"#;

Text.ParserCombinators.ReadPrec.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$trModule2];

Text.ParserCombinators.ReadPrec.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Text.ParserCombinators.ReadPrec.$trModule3
                                     Text.ParserCombinators.ReadPrec.$trModule1];

$krep_r3tAT :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcInt
                                              GHC.Types.[]];

$krep1_r3tAU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r3tAV :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r3tAU GHC.Types.[]];

$krep3_r3tAW :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadP.$tcReadP
                                              $krep2_r3tAV];

$krep4_r3tAX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r3tAT $krep3_r3tAW];

Text.ParserCombinators.ReadPrec.$tcReadPrec2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ReadPrec"#;

Text.ParserCombinators.ReadPrec.$tcReadPrec1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$tcReadPrec2];

Text.ParserCombinators.ReadPrec.$tcReadPrec :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17656447446138014199##
                                    97878223355588575##
                                    Text.ParserCombinators.ReadPrec.$trModule
                                    Text.ParserCombinators.ReadPrec.$tcReadPrec1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep5_r3tAY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadPrec.$tcReadPrec
                                              $krep2_r3tAV];

Text.ParserCombinators.ReadPrec.$tc'P1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r3tAX $krep5_r3tAY];

Text.ParserCombinators.ReadPrec.$tc'P3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'P"#;

Text.ParserCombinators.ReadPrec.$tc'P2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$tc'P3];

Text.ParserCombinators.ReadPrec.$tc'P :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14970691021354513070##
                                    16104245447600145137##
                                    Text.ParserCombinators.ReadPrec.$trModule
                                    Text.ParserCombinators.ReadPrec.$tc'P2
                                    1#
                                    Text.ParserCombinators.ReadPrec.$tc'P1];


==================== STG syntax: ====================
2018-03-16 15:58:08.386542631 UTC

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec2
  :: forall a b.
     (a -> b)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [h_s3umE ds_s3umF n_s3umG]
        let {
          ds1_s3umH [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tu3
          [LclId] =
              [ds_s3umF n_s3umG] \u [] ds_s3umF n_s3umG; } in
        let {
          sat_s3umK [Occ=Once]
            :: forall b1.
               (b_a3tu4 -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [h_s3umE ds1_s3umH] \r [k_s3umI]
                  let {
                    sat_s3umJ [Occ=Once]
                      :: a_a3tu3 -> Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [h_s3umE k_s3umI] \r [eta_B1] GHC.Base.. k_s3umI h_s3umE eta_B1;
                  } in  ds1_s3umH sat_s3umJ;
        } in  sat_s3umK;

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec1
  :: forall b a.
     a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [x_s3umL eta_s3umM eta1_s3umN]
        let {
          ds_s3umO [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP b_a3tug
          [LclId] =
              [eta_s3umM eta1_s3umN] \u [] eta_s3umM eta1_s3umN; } in
        let {
          sat_s3umT [Occ=Once]
            :: forall b1.
               (a_a3tuf -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [x_s3umL ds_s3umO] \r [k_s3umP]
                  let {
                    lvl1_s3umQ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [x_s3umL k_s3umP] \u [] k_s3umP x_s3umL; } in
                  let {
                    sat_s3umS [Occ=Once]
                      :: b_a3tug -> Text.ParserCombinators.ReadP.P b1_a3nKT
                    [LclId] =
                        [lvl1_s3umQ] \r [x1_s3umR] lvl1_s3umQ;
                  } in  ds_s3umO sat_s3umS;
        } in  sat_s3umT;

Text.ParserCombinators.ReadPrec.$fFunctorReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Text.ParserCombinators.ReadPrec.$fFunctorReadPrec2
                                       Text.ParserCombinators.ReadPrec.$fFunctorReadPrec1];

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
  :: forall a.
     a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,A><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s3umU ds_s3umV k_s3umW] k_s3umW x_s3umU;

Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1
  :: forall a.
     GHC.Base.String
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [s_s3umX ds_s3umY ds1_s3umZ]
        Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.$fMonadReadPrec1
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> (a -> Text.ParserCombinators.ReadPrec.ReadPrec b)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3un0 k_s3un1 n_s3un2]
        let {
          ds1_s3un3 [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tsh
          [LclId] =
              [ds_s3un0 n_s3un2] \u [] ds_s3un0 n_s3un2; } in
        let {
          sat_s3un7 [Occ=Once]
            :: forall b1.
               (b_a3tsi -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [k_s3un1 n_s3un2 ds1_s3un3] \r [k1_s3un4]
                  let {
                    sat_s3un6 [Occ=Once]
                      :: a_a3tsh -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [k_s3un1 n_s3un2 k1_s3un4] \r [a1_s3un5]
                            k_s3un1 a1_s3un5 n_s3un2 k1_s3un4;
                  } in  ds1_s3un3 sat_s3un6;
        } in  sat_s3un7;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec3
  :: forall c b a.
     (a -> b -> c)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s3un8 m1_s3un9 m2_s3una n_s3unb]
        let {
          ds_s3unc [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttu
          [LclId] =
              [m1_s3un9 n_s3unb] \u [] m1_s3un9 n_s3unb; } in
        let {
          sat_s3unj [Occ=Once]
            :: forall b1.
               (c_a3ttw -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [f_s3un8 m2_s3una n_s3unb ds_s3unc] \r [k_s3und]
                  let {
                    sat_s3uni [Occ=Once]
                      :: a_a3ttu -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [f_s3un8 m2_s3una n_s3unb k_s3und] \r [a1_s3une]
                            let {
                              sat_s3unh [Occ=Once]
                                :: b_a3ttv -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [f_s3un8 k_s3und a1_s3une] \r [a2_s3unf]
                                      let {
                                        sat_s3ung [Occ=Once] :: c_a3ttw
                                        [LclId] =
                                            [f_s3un8 a1_s3une a2_s3unf] \u []
                                                f_s3un8 a1_s3une a2_s3unf;
                                      } in  k_s3und sat_s3ung;
                            } in  m2_s3una n_s3unb sat_s3unh;
                  } in  ds_s3unc sat_s3uni;
        } in  sat_s3unj;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec1
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [m1_s3unk m2_s3unl n_s3unm]
        let {
          ds_s3unn [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttR
          [LclId] =
              [m1_s3unk n_s3unm] \u [] m1_s3unk n_s3unm; } in
        let {
          sat_s3unu [Occ=Once]
            :: forall b1.
               (a_a3ttR -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [m2_s3unl n_s3unm ds_s3unn] \r [k_s3uno]
                  let {
                    sat_s3unt [Occ=Once]
                      :: a_a3ttR -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [m2_s3unl n_s3unm k_s3uno] \r [a1_s3unp]
                            let {
                              lvl1_s3unq [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3uno a1_s3unp] \u [] k_s3uno a1_s3unp; } in
                            let {
                              sat_s3uns [Occ=Once]
                                :: b_a3ttS -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [lvl1_s3unq] \r [a2_s3unr] lvl1_s3unq;
                            } in  m2_s3unl n_s3unm sat_s3uns;
                  } in  ds_s3unn sat_s3unt;
        } in  sat_s3unu;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec4
  :: forall b a.
     Text.ParserCombinators.ReadPrec.ReadPrec (a -> b)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [m1_s3unv m2_s3unw n_s3unx]
        let {
          ds_s3uny [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP (a_a3ttj -> b_a3ttk)
          [LclId] =
              [m1_s3unv n_s3unx] \u [] m1_s3unv n_s3unx; } in
        let {
          sat_s3unF [Occ=Once]
            :: forall b1.
               (b_a3ttk -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [m2_s3unw n_s3unx ds_s3uny] \r [k_s3unz]
                  let {
                    sat_s3unE [Occ=Once]
                      :: (a_a3ttj -> b_a3ttk) -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [m2_s3unw n_s3unx k_s3unz] \r [a1_s3unA]
                            let {
                              sat_s3unD [Occ=Once]
                                :: a_a3ttj -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3unz a1_s3unA] \r [a2_s3unB]
                                      let {
                                        sat_s3unC [Occ=Once] :: b_a3ttk
                                        [LclId] =
                                            [a1_s3unA a2_s3unB] \u [] a1_s3unA a2_s3unB;
                                      } in  k_s3unz sat_s3unC;
                            } in  m2_s3unw n_s3unx sat_s3unD;
                  } in  ds_s3uny sat_s3unE;
        } in  sat_s3unF;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [a1_s3unG a2_s3unH eta_s3unI]
        let {
          ds_s3unJ [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3ttH
          [LclId] =
              [a1_s3unG eta_s3unI] \u [] a1_s3unG eta_s3unI; } in
        let {
          sat_s3unQ [Occ=Once]
            :: forall b1.
               (b_a3ttI -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [a2_s3unH eta_s3unI ds_s3unJ] \r [k_s3unK]
                  let {
                    lvl1_s3unL [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [a2_s3unH eta_s3unI k_s3unK] \u []
                            let {
                              sat_s3unN [Occ=Once]
                                :: b_a3ttI -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [k_s3unK] \r [a4_s3unM] k_s3unK a4_s3unM;
                            } in  a2_s3unH eta_s3unI sat_s3unN; } in
                  let {
                    sat_s3unP [Occ=Once]
                      :: a_a3ttH -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl1_s3unL] \r [x_s3unO] lvl1_s3unL;
                  } in  ds_s3unJ sat_s3unP;
        } in  sat_s3unQ;

$c>>_r3tAR
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [eta_s3unR eta1_s3unS n_s3unT]
        let {
          ds_s3unU [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tsB
          [LclId] =
              [eta_s3unR n_s3unT] \u [] eta_s3unR n_s3unT; } in
        let {
          sat_s3unZ [Occ=Once]
            :: forall b1.
               (b_a3tsC -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [eta1_s3unS n_s3unT ds_s3unU] \r [k_s3unV]
                  let {
                    lvl1_s3unW [Occ=OnceL] :: Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [eta1_s3unS n_s3unT k_s3unV] \u [] eta1_s3unS n_s3unT k_s3unV; } in
                  let {
                    sat_s3unY [Occ=Once]
                      :: a_a3tsB -> Text.ParserCombinators.ReadP.P b1_a3nIU
                    [LclId] =
                        [lvl1_s3unW] \r [a1_s3unX] lvl1_s3unW;
                  } in  ds_s3unU sat_s3unY;
        } in  sat_s3unZ;

Text.ParserCombinators.ReadPrec.$fMonadReadPrec_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $c>>_r3tAR eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Text.ParserCombinators.ReadPrec.$fFunctorReadPrec
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec4
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec3
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec2
                                           Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec
                                     Text.ParserCombinators.ReadPrec.$fMonadReadPrec1
                                     Text.ParserCombinators.ReadPrec.$fMonadReadPrec_$c>>
                                     Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec5
                                     Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fail.MonadFail
       Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fail.C:MonadFail! [Text.ParserCombinators.ReadPrec.$fMonadReadPrec
                                                   Text.ParserCombinators.ReadPrec.$fMonadFailReadPrec1];

Text.ParserCombinators.ReadPrec.minPrec
  :: Text.ParserCombinators.ReadPrec.Prec
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Text.ParserCombinators.ReadPrec.reset1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s3uo0 ds1_s3uo1]
        ds_s3uo0 Text.ParserCombinators.ReadPrec.minPrec;

Text.ParserCombinators.ReadPrec.reset
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.reset1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.lift1
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [m_s3uo2 ds_s3uo3] m_s3uo2;

Text.ParserCombinators.ReadPrec.lift
  :: forall a.
     Text.ParserCombinators.ReadP.ReadP a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.lift1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.get1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall a.
        (GHC.Types.Char -> Text.ParserCombinators.ReadP.P a)
        -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m1,
 Unf=OtherCon []] =
    [] \r [ds_s3uo4 eta_s3uo5]
        Text.ParserCombinators.ReadP.Get [eta_s3uo5];

Text.ParserCombinators.ReadPrec.get
  :: Text.ParserCombinators.ReadPrec.ReadPrec GHC.Types.Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.get1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.look1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall a.
        (GHC.Base.String -> Text.ParserCombinators.ReadP.P a)
        -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m2,
 Unf=OtherCon []] =
    [] \r [ds_s3uo6 eta_s3uo7]
        Text.ParserCombinators.ReadP.Look [eta_s3uo7];

Text.ParserCombinators.ReadPrec.look
  :: Text.ParserCombinators.ReadPrec.ReadPrec GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.look1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s3uo8 eta_s3uo9] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.pfail
  :: forall a. Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
            eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.step1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s3uoa n_s3uob]
        let {
          sat_s3uof [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec
          [LclId] =
              [n_s3uob] \u []
                  case n_s3uob of {
                    GHC.Types.I# x_s3uod [Occ=Once] ->
                        case +# [x_s3uod 1#] of sat_s3uoe {
                          __DEFAULT -> GHC.Types.I# [sat_s3uoe];
                        };
                  };
        } in  ds_s3uoa sat_s3uof;

Text.ParserCombinators.ReadPrec.step
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.step1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.prec1
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*C1(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [n_s3uog ds_s3uoh c_s3uoi]
        case c_s3uoi of {
          GHC.Types.I# x_s3uok [Occ=Once] ->
              case n_s3uog of wild1_s3uol {
                GHC.Types.I# y_s3uom [Occ=Once] ->
                    case <=# [x_s3uok y_s3uom] of {
                      __DEFAULT -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
                      1# -> ds_s3uoh wild1_s3uol;
                    };
              };
        };

Text.ParserCombinators.ReadPrec.prec
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*C1(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.prec1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3uoo ds1_s3uop n_s3uoq]
        let {
          ds2_s3uor [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqi
          [LclId] =
              [ds_s3uoo n_s3uoq] \u [] ds_s3uoo n_s3uoq; } in
        let {
          ds3_s3uos [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqi
          [LclId] =
              [ds1_s3uop n_s3uoq] \u [] ds1_s3uop n_s3uoq; } in
        let {
          sat_s3uow [Occ=Once]
            :: forall b.
               (a_a3tqi -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [ds2_s3uor ds3_s3uos] \r [k_s3uot]
                  let {
                    sat_s3uov [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                    [LclId] =
                        [ds3_s3uos k_s3uot] \u [] ds3_s3uos k_s3uot;
                  } in 
                    case ds2_s3uor k_s3uot of sat_s3uou {
                      __DEFAULT ->
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                              sat_s3uou sat_s3uov;
                    };
        } in  sat_s3uow;

Text.ParserCombinators.ReadPrec.+++
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
            eta_B3 eta_B2 eta_B1;

lvl_r3tAS
  :: forall a b.
     (a -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s3uox] Text.ParserCombinators.ReadP.Fail [];

Text.ParserCombinators.ReadPrec.choice2 [Occ=LoopBreaker]
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ds_s3uoy eta_s3uoz]
        case ds_s3uoy of {
          [] -> lvl_r3tAS;
          : y_s3uoB ys_s3uoC [Occ=Once] ->
              let {
                ds1_s3uoD [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Text.ParserCombinators.ReadP.ReadP a_a3tqM
                [LclId] =
                    [eta_s3uoz y_s3uoB] \u [] y_s3uoB eta_s3uoz; } in
              let {
                ds2_s3uoE [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Text.ParserCombinators.ReadP.ReadP a_a3tqM
                [LclId] =
                    [eta_s3uoz ys_s3uoC] \u []
                        Text.ParserCombinators.ReadPrec.choice2 ys_s3uoC eta_s3uoz; } in
              let {
                sat_s3uoI [Occ=Once]
                  :: forall b.
                     (a_a3tqM -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b
                [LclId] =
                    [ds1_s3uoD ds2_s3uoE] \r [k_s3uoF]
                        let {
                          sat_s3uoH [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                          [LclId] =
                              [ds2_s3uoE k_s3uoF] \u [] ds2_s3uoE k_s3uoF;
                        } in 
                          case ds1_s3uoD k_s3uoF of sat_s3uoG {
                            __DEFAULT ->
                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                    sat_s3uoG sat_s3uoH;
                          };
              } in  sat_s3uoI;
        };

Text.ParserCombinators.ReadPrec.choice1
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ps_s3uoJ eta_s3uoK]
        Text.ParserCombinators.ReadPrec.choice2 ps_s3uoJ eta_s3uoK;

Text.ParserCombinators.ReadPrec.choice
  :: forall a.
     [Text.ParserCombinators.ReadPrec.ReadPrec a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.choice1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec2
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [v_s3uoL eta_s3uoM]
        let {
          some_v_s3uoN [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_a3trf]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [v_s3uoL some_v_s3uoN] \r [n_s3uoO]
                  let {
                    ds_s3uoP [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadP a_a3trf
                    [LclId] =
                        [v_s3uoL n_s3uoO] \u [] v_s3uoL n_s3uoO; } in
                  let {
                    sat_s3uoZ [Occ=Once]
                      :: forall b1.
                         ([a_a3trf] -> Text.ParserCombinators.ReadP.P b1)
                         -> Text.ParserCombinators.ReadP.P b1
                    [LclId] =
                        [some_v_s3uoN n_s3uoO ds_s3uoP] \r [k_s3uoQ]
                            let {
                              sat_s3uoY [Occ=Once]
                                :: a_a3trf -> Text.ParserCombinators.ReadP.P b1_a3nIU
                              [LclId] =
                                  [some_v_s3uoN n_s3uoO k_s3uoQ] \r [a1_s3uoR]
                                      let {
                                        sat_s3uoX [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3uoQ a1_s3uoR] \u []
                                                let {
                                                  sat_s3uoW [Occ=Once] :: [a_a3trf]
                                                  [LclId] =
                                                      CCCS :! [a1_s3uoR GHC.Types.[]];
                                                } in  k_s3uoQ sat_s3uoW; } in
                                      let {
                                        sat_s3uoU [Occ=Once]
                                          :: [a_a3trf] -> Text.ParserCombinators.ReadP.P b1_a3nIU
                                        [LclId] =
                                            [k_s3uoQ a1_s3uoR] \r [a2_s3uoS]
                                                let {
                                                  sat_s3uoT [Occ=Once] :: [a_a3trf]
                                                  [LclId] =
                                                      CCCS :! [a1_s3uoR a2_s3uoS];
                                                } in  k_s3uoQ sat_s3uoT;
                                      } in 
                                        case some_v_s3uoN n_s3uoO sat_s3uoU of sat_s3uoV {
                                          __DEFAULT ->
                                              Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                                  sat_s3uoV sat_s3uoX;
                                        };
                            } in  ds_s3uoP sat_s3uoY;
                  } in  sat_s3uoZ;
        } in  some_v_s3uoN eta_s3uoM;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [a]
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [v_s3up0 eta_s3up1]
        let {
          many_v_s3up2 [Occ=LoopBreaker]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP [a_a3trn]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [v_s3up0 many_v_s3up2] \r [n_s3up3]
                  let {
                    ds_s3up4 [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadP a_a3trn
                    [LclId] =
                        [v_s3up0 n_s3up3] \u [] v_s3up0 n_s3up3; } in
                  let {
                    sat_s3upd [Occ=Once]
                      :: forall b.
                         ([a_a3trn] -> Text.ParserCombinators.ReadP.P b)
                         -> Text.ParserCombinators.ReadP.P b
                    [LclId] =
                        [many_v_s3up2 n_s3up3 ds_s3up4] \r [k_s3up5]
                            let {
                              sat_s3upc [Occ=Once] :: Text.ParserCombinators.ReadP.P b_a3nvJ
                              [LclId] =
                                  [k_s3up5] \u [] k_s3up5 GHC.Types.[]; } in
                            let {
                              sat_s3upa [Occ=Once]
                                :: a_a3trn -> Text.ParserCombinators.ReadP.P b_a3nvJ
                              [LclId] =
                                  [many_v_s3up2 n_s3up3 k_s3up5] \r [a1_s3up6]
                                      let {
                                        sat_s3up9 [Occ=Once]
                                          :: [a_a3trn] -> Text.ParserCombinators.ReadP.P b_a3nvJ
                                        [LclId] =
                                            [k_s3up5 a1_s3up6] \r [a2_s3up7]
                                                let {
                                                  sat_s3up8 [Occ=Once] :: [a_a3trn]
                                                  [LclId] =
                                                      CCCS :! [a1_s3up6 a2_s3up7];
                                                } in  k_s3up5 sat_s3up8;
                                      } in  many_v_s3up2 n_s3up3 sat_s3up9;
                            } in 
                              case ds_s3up4 sat_s3upa of sat_s3upb {
                                __DEFAULT ->
                                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                        sat_s3upb sat_s3upc;
                              };
                  } in  sat_s3upd;
        } in  many_v_s3up2 eta_s3up1;

Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Text.ParserCombinators.ReadPrec.$fApplicativeReadPrec
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec2
                                           Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec1];

Text.ParserCombinators.ReadPrec.$fMonadPlusReadPrec [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Text.ParserCombinators.ReadPrec.ReadPrec
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec
                                         Text.ParserCombinators.ReadPrec.$fMonadReadPrec
                                         Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                         Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec3];

Text.ParserCombinators.ReadPrec.<++1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3upe ds1_s3upf n_s3upg]
        let {
          w_s3uph [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqe
          [LclId] =
              [ds_s3upe n_s3upg] \u [] ds_s3upe n_s3upg; } in
        let {
          w1_s3upi [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_a3tqe
          [LclId] =
              [ds1_s3upf n_s3upg] \u [] ds1_s3upf n_s3upg; } in
        let {
          sat_s3upm [Occ=OnceT[0]]
            :: forall b.
               (a_a3tqe -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w_s3uph w1_s3upi] \r [w2_s3upj]
                  case
                      Text.ParserCombinators.ReadP.$w<++ w_s3uph w1_s3upi w2_s3upj
                  of
                  { Unit# ww1_s3upl [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3upl];
                  };
        } in  sat_s3upm;

Text.ParserCombinators.ReadPrec.<++
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=3,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.<++1 eta_B3 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.readPrec_to_P1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s3upn] ds_s3upn;

Text.ParserCombinators.ReadPrec.readPrec_to_P
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadPrec.readPrec_to_P1 eta_B1;

Text.ParserCombinators.ReadPrec.readP_to_Prec1
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [f_s3upo] f_s3upo;

Text.ParserCombinators.ReadPrec.readP_to_Prec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadPrec.readP_to_Prec1 eta_B1;

Text.ParserCombinators.ReadPrec.readPrec_to_S
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_s3upp n_s3upq]
        let {
          sat_s3upr [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a3tq6
          [LclId] =
              [ds_s3upp n_s3upq] \u []
                  ds_s3upp
                      n_s3upq Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s3upr;

Text.ParserCombinators.ReadPrec.readS_to_Prec1
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s3ups n_s3upt]
        let {
          w_s3upu [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS a_a3tq2
          [LclId] =
              [f_s3ups n_s3upt] \u [] f_s3ups n_s3upt; } in
        let {
          sat_s3upy [Occ=OnceT[0]]
            :: forall b.
               (a_a3tq2 -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w_s3upu] \r [w1_s3upv]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w_s3upu w1_s3upv
                  of
                  { Unit# ww1_s3upx [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_s3upx];
                  };
        } in  sat_s3upy;

Text.ParserCombinators.ReadPrec.readS_to_Prec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Text.ParserCombinators.ReadPrec.readS_to_Prec1 eta_B2 eta_B1;

Text.ParserCombinators.ReadPrec.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Text.ParserCombinators.ReadPrec.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$trModule4];

Text.ParserCombinators.ReadPrec.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Text.ParserCombinators.ReadPrec"#;

Text.ParserCombinators.ReadPrec.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$trModule2];

Text.ParserCombinators.ReadPrec.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Text.ParserCombinators.ReadPrec.$trModule3
                                     Text.ParserCombinators.ReadPrec.$trModule1];

$krep_r3tAT :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcInt
                                              GHC.Types.[]];

$krep1_r3tAU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r3tAV :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r3tAU GHC.Types.[]];

$krep3_r3tAW :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadP.$tcReadP
                                              $krep2_r3tAV];

$krep4_r3tAX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r3tAT $krep3_r3tAW];

Text.ParserCombinators.ReadPrec.$tcReadPrec2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ReadPrec"#;

Text.ParserCombinators.ReadPrec.$tcReadPrec1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$tcReadPrec2];

Text.ParserCombinators.ReadPrec.$tcReadPrec :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17656447446138014199##
                                    97878223355588575##
                                    Text.ParserCombinators.ReadPrec.$trModule
                                    Text.ParserCombinators.ReadPrec.$tcReadPrec1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep5_r3tAY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Text.ParserCombinators.ReadPrec.$tcReadPrec
                                              $krep2_r3tAV];

Text.ParserCombinators.ReadPrec.$tc'P1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r3tAX $krep5_r3tAY];

Text.ParserCombinators.ReadPrec.$tc'P3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'P"#;

Text.ParserCombinators.ReadPrec.$tc'P2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Text.ParserCombinators.ReadPrec.$tc'P3];

Text.ParserCombinators.ReadPrec.$tc'P :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14970691021354513070##
                                    16104245447600145137##
                                    Text.ParserCombinators.ReadPrec.$trModule
                                    Text.ParserCombinators.ReadPrec.$tc'P2
                                    1#
                                    Text.ParserCombinators.ReadPrec.$tc'P1];

