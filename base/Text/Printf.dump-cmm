
==================== Output Cmm ====================
2018-03-16 16:07:03.715909185 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:03.716873066 UTC

[section ""data" . Text.Printf.toChar_closure" {
     Text.Printf.toChar_closure:
         const Text.Printf.toChar_info;
 },
 Text.Printf.toChar_entry() //  [R2]
         { info_tbl: [(cccFh,
                       label: Text.Printf.toChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccFh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccFi; else goto cccFj;
       cccFi: // global
           R2 = R2;
           R1 = Text.Printf.toChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccFj: // global
           I64[Sp - 8] = block_cccFe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccFn; else goto cccFf;
       uccFn: // global
           call _cccFe(R1) args: 0, res: 0, upd: 0;
       cccFf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccFe() //  [R1]
         { info_tbl: [(cccFe,
                       label: block_cccFe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccFe: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.71813125 UTC

[section ""data" . Text.Printf.fromChar_closure" {
     Text.Printf.fromChar_closure:
         const Text.Printf.fromChar_info;
 },
 Text.Printf.fromChar_entry() //  [R2]
         { info_tbl: [(cccFv,
                       label: Text.Printf.fromChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccFv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccFw; else goto cccFx;
       cccFw: // global
           R2 = R2;
           R1 = Text.Printf.fromChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccFx: // global
           I64[Sp - 8] = block_cccFs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccFB; else goto cccFt;
       uccFB: // global
           call _cccFs(R1) args: 0, res: 0, upd: 0;
       cccFt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccFs() //  [R1]
         { info_tbl: [(cccFs,
                       label: block_cccFs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccFs: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.719241421 UTC

[section ""data" . Text.Printf.formatArg_closure" {
     Text.Printf.formatArg_closure:
         const Text.Printf.formatArg_info;
 },
 Text.Printf.formatArg_entry() //  [R2]
         { info_tbl: [(cccFJ,
                       label: Text.Printf.formatArg_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccFJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccFK; else goto cccFL;
       cccFK: // global
           R2 = R2;
           R1 = Text.Printf.formatArg_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccFL: // global
           I64[Sp - 8] = block_cccFG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccFP; else goto cccFH;
       uccFP: // global
           call _cccFG(R1) args: 0, res: 0, upd: 0;
       cccFH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccFG() //  [R1]
         { info_tbl: [(cccFG,
                       label: block_cccFG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccFG: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.720415592 UTC

[section ""data" . Text.Printf.parseFormat_closure" {
     Text.Printf.parseFormat_closure:
         const Text.Printf.parseFormat_info;
 },
 Text.Printf.parseFormat_entry() //  [R2]
         { info_tbl: [(cccFX,
                       label: Text.Printf.parseFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccFX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccFY; else goto cccFZ;
       cccFY: // global
           R2 = R2;
           R1 = Text.Printf.parseFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccFZ: // global
           I64[Sp - 8] = block_cccFU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccG3; else goto cccFV;
       uccG3: // global
           call _cccFU(R1) args: 0, res: 0, upd: 0;
       cccFV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccFU() //  [R1]
         { info_tbl: [(cccFU,
                       label: block_cccFU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccFU: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.721502339 UTC

[section ""data" . Text.Printf.hspr_closure" {
     Text.Printf.hspr_closure:
         const Text.Printf.hspr_info;
 },
 Text.Printf.hspr_entry() //  [R2]
         { info_tbl: [(cccG8,
                       label: Text.Printf.hspr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccG8: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.722310363 UTC

[section ""data" . Text.Printf.spr_closure" {
     Text.Printf.spr_closure:
         const Text.Printf.spr_info;
 },
 Text.Printf.spr_entry() //  [R2]
         { info_tbl: [(cccGf,
                       label: Text.Printf.spr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccGf: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.723103113 UTC

[section ""data" . Text.Printf.$fIsCharChar_$cfromChar_closure" {
     Text.Printf.$fIsCharChar_$cfromChar_closure:
         const Text.Printf.$fIsCharChar_$cfromChar_info;
 },
 Text.Printf.$fIsCharChar_$cfromChar_entry() //  [R2]
         { info_tbl: [(cccGm,
                       label: Text.Printf.$fIsCharChar_$cfromChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccGm: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.72387112 UTC

[section ""data" . Text.Printf.$fIsCharChar_closure" {
     Text.Printf.$fIsCharChar_closure:
         const Text.Printf.C:IsChar_con_info;
         const Text.Printf.$fIsCharChar_$cfromChar_closure+1;
         const Text.Printf.$fIsCharChar_$cfromChar_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.725025098 UTC

[section ""data" . Text.Printf.$fHPrintfType(->)_$chspr_closure" {
     Text.Printf.$fHPrintfType(->)_$chspr_closure:
         const Text.Printf.$fHPrintfType(->)_$chspr_info;
 },
 sat_sccdo_entry() //  [R1]
         { info_tbl: [(cccGx,
                       label: sat_sccdo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccGx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cccGy; else goto cccGz;
       cccGy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccGz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.formatArg_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sccdn_entry() //  [R1]
         { info_tbl: [(cccGE,
                       label: sat_sccdn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccGE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cccGF; else goto cccGG;
       cccGF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccGG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.parseFormat_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Text.Printf.$fHPrintfType(->)_$chspr_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(cccGJ,
                       label: Text.Printf.$fHPrintfType(->)_$chspr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccGJ: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cccGN; else goto cccGM;
       cccGN: // global
           HpAlloc = 112;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fHPrintfType(->)_$chspr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cccGM: // global
           I64[Hp - 104] = sat_sccdo_info;
           P64[Hp - 88] = R2;
           _sccdm::P64 = P64[Sp];
           P64[Hp - 80] = _sccdm::P64;
           I64[Hp - 72] = sat_sccdn_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = _sccdm::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = R6;
           _sccdj::P64 = R4;
           R4 = Hp - 14;
           _sccdi::P64 = R3;
           R3 = R5;
           R2 = _sccdj::P64;
           R1 = _sccdi::P64;
           Sp = Sp + 8;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.726701096 UTC

[section ""data" . Text.Printf.$fHPrintfType(->)_closure" {
     Text.Printf.$fHPrintfType(->)_closure:
         const Text.Printf.$fHPrintfType(->)_info;
 },
 Text.Printf.$fHPrintfType(->)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cccGS,
                       label: Text.Printf.$fHPrintfType(->)_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccGS: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fHPrintfType(->)_$chspr_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.727956845 UTC

[section ""data" . Text.Printf.$fPrintfType(->)_$cspr_closure" {
     Text.Printf.$fPrintfType(->)_$cspr_closure:
         const Text.Printf.$fPrintfType(->)_$cspr_info;
 },
 sat_sccdx_entry() //  [R1]
         { info_tbl: [(cccH3,
                       label: sat_sccdx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccH3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cccH4; else goto cccH5;
       cccH4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccH5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.formatArg_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sccdw_entry() //  [R1]
         { info_tbl: [(cccHa,
                       label: sat_sccdw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccHa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cccHb; else goto cccHc;
       cccHb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccHc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.parseFormat_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfType(->)_$cspr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cccHf,
                       label: Text.Printf.$fPrintfType(->)_$cspr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccHf: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cccHj; else goto cccHi;
       cccHj: // global
           HpAlloc = 112;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfType(->)_$cspr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cccHi: // global
           I64[Hp - 104] = sat_sccdx_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R6;
           I64[Hp - 72] = sat_sccdw_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R6;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = R5;
           _sccds::P64 = R3;
           R3 = Hp - 14;
           R2 = R4;
           R1 = _sccds::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.729578729 UTC

[section ""data" . Text.Printf.$fPrintfType(->)_closure" {
     Text.Printf.$fPrintfType(->)_closure:
         const Text.Printf.$fPrintfType(->)_info;
 },
 Text.Printf.$fPrintfType(->)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cccHo,
                       label: Text.Printf.$fPrintfType(->)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccHo: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfType(->)_$cspr_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.730570538 UTC

[section ""data" . Text.Printf.fmtChar_closure" {
     Text.Printf.fmtChar_closure:
         const Text.Printf.fmtChar_info;
 },
 Text.Printf.fmtChar_entry() //  [R2]
         { info_tbl: [(cccHy,
                       label: Text.Printf.fmtChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccHy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccHz; else goto cccHA;
       cccHz: // global
           R2 = R2;
           R1 = Text.Printf.fmtChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccHA: // global
           I64[Sp - 8] = block_cccHv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccHE; else goto cccHw;
       uccHE: // global
           call _cccHv(R1) args: 0, res: 0, upd: 0;
       cccHw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccHv() //  [R1]
         { info_tbl: [(cccHv,
                       label: block_cccHv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccHv: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.731741268 UTC

[section ""data" . Text.Printf.fmtModifiers_closure" {
     Text.Printf.fmtModifiers_closure:
         const Text.Printf.fmtModifiers_info;
 },
 Text.Printf.fmtModifiers_entry() //  [R2]
         { info_tbl: [(cccHM,
                       label: Text.Printf.fmtModifiers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccHM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccHN; else goto cccHO;
       cccHN: // global
           R2 = R2;
           R1 = Text.Printf.fmtModifiers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccHO: // global
           I64[Sp - 8] = block_cccHJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccHS; else goto cccHK;
       uccHS: // global
           call _cccHJ(R1) args: 0, res: 0, upd: 0;
       cccHK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccHJ() //  [R1]
         { info_tbl: [(cccHJ,
                       label: block_cccHJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccHJ: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.732892399 UTC

[section ""data" . Text.Printf.fmtAlternate_closure" {
     Text.Printf.fmtAlternate_closure:
         const Text.Printf.fmtAlternate_info;
 },
 Text.Printf.fmtAlternate_entry() //  [R2]
         { info_tbl: [(cccI0,
                       label: Text.Printf.fmtAlternate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccI0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccI1; else goto cccI2;
       cccI1: // global
           R2 = R2;
           R1 = Text.Printf.fmtAlternate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccI2: // global
           I64[Sp - 8] = block_cccHX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccI6; else goto cccHY;
       uccI6: // global
           call _cccHX(R1) args: 0, res: 0, upd: 0;
       cccHY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccHX() //  [R1]
         { info_tbl: [(cccHX,
                       label: block_cccHX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccHX: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.73415797 UTC

[section ""data" . Text.Printf.fmtSign_closure" {
     Text.Printf.fmtSign_closure:
         const Text.Printf.fmtSign_info;
 },
 Text.Printf.fmtSign_entry() //  [R2]
         { info_tbl: [(cccIe,
                       label: Text.Printf.fmtSign_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccIe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccIf; else goto cccIg;
       cccIf: // global
           R2 = R2;
           R1 = Text.Printf.fmtSign_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccIg: // global
           I64[Sp - 8] = block_cccIb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccIk; else goto cccIc;
       uccIk: // global
           call _cccIb(R1) args: 0, res: 0, upd: 0;
       cccIc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccIb() //  [R1]
         { info_tbl: [(cccIb,
                       label: block_cccIb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccIb: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.735346305 UTC

[section ""data" . Text.Printf.fmtAdjust_closure" {
     Text.Printf.fmtAdjust_closure:
         const Text.Printf.fmtAdjust_info;
 },
 Text.Printf.fmtAdjust_entry() //  [R2]
         { info_tbl: [(cccIs,
                       label: Text.Printf.fmtAdjust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccIs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccIt; else goto cccIu;
       cccIt: // global
           R2 = R2;
           R1 = Text.Printf.fmtAdjust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccIu: // global
           I64[Sp - 8] = block_cccIp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccIy; else goto cccIq;
       uccIy: // global
           call _cccIp(R1) args: 0, res: 0, upd: 0;
       cccIq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccIp() //  [R1]
         { info_tbl: [(cccIp,
                       label: block_cccIp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccIp: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.736505453 UTC

[section ""data" . Text.Printf.fmtPrecision_closure" {
     Text.Printf.fmtPrecision_closure:
         const Text.Printf.fmtPrecision_info;
 },
 Text.Printf.fmtPrecision_entry() //  [R2]
         { info_tbl: [(cccIG,
                       label: Text.Printf.fmtPrecision_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccIG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccIH; else goto cccII;
       cccIH: // global
           R2 = R2;
           R1 = Text.Printf.fmtPrecision_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccII: // global
           I64[Sp - 8] = block_cccID_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccIM; else goto cccIE;
       uccIM: // global
           call _cccID(R1) args: 0, res: 0, upd: 0;
       cccIE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccID() //  [R1]
         { info_tbl: [(cccID,
                       label: block_cccID_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccID: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.737709003 UTC

[section ""data" . Text.Printf.fmtWidth_closure" {
     Text.Printf.fmtWidth_closure:
         const Text.Printf.fmtWidth_info;
 },
 Text.Printf.fmtWidth_entry() //  [R2]
         { info_tbl: [(cccIU,
                       label: Text.Printf.fmtWidth_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccIU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccIV; else goto cccIW;
       cccIV: // global
           R2 = R2;
           R1 = Text.Printf.fmtWidth_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccIW: // global
           I64[Sp - 8] = block_cccIR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccJ0; else goto cccIS;
       uccJ0: // global
           call _cccIR(R1) args: 0, res: 0, upd: 0;
       cccIS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccIR() //  [R1]
         { info_tbl: [(cccIR,
                       label: block_cccIR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccIR: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.738825306 UTC

[section ""data" . Text.Printf.fpRest_closure" {
     Text.Printf.fpRest_closure:
         const Text.Printf.fpRest_info;
 },
 Text.Printf.fpRest_entry() //  [R2]
         { info_tbl: [(cccJ8,
                       label: Text.Printf.fpRest_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccJ8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccJ9; else goto cccJa;
       cccJ9: // global
           R2 = R2;
           R1 = Text.Printf.fpRest_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccJa: // global
           I64[Sp - 8] = block_cccJ5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccJe; else goto cccJ6;
       uccJe: // global
           call _cccJ5(R1) args: 0, res: 0, upd: 0;
       cccJ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccJ5() //  [R1]
         { info_tbl: [(cccJ5,
                       label: block_cccJ5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccJ5: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.739993318 UTC

[section ""data" . Text.Printf.fpChar_closure" {
     Text.Printf.fpChar_closure:
         const Text.Printf.fpChar_info;
 },
 Text.Printf.fpChar_entry() //  [R2]
         { info_tbl: [(cccJm,
                       label: Text.Printf.fpChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccJm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccJn; else goto cccJo;
       cccJn: // global
           R2 = R2;
           R1 = Text.Printf.fpChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccJo: // global
           I64[Sp - 8] = block_cccJj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccJs; else goto cccJk;
       uccJs: // global
           call _cccJj(R1) args: 0, res: 0, upd: 0;
       cccJk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccJj() //  [R1]
         { info_tbl: [(cccJj,
                       label: block_cccJj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccJj: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.741146776 UTC

[section ""data" . Text.Printf.fpModifiers_closure" {
     Text.Printf.fpModifiers_closure:
         const Text.Printf.fpModifiers_info;
 },
 Text.Printf.fpModifiers_entry() //  [R2]
         { info_tbl: [(cccJA,
                       label: Text.Printf.fpModifiers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccJA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccJB; else goto cccJC;
       cccJB: // global
           R2 = R2;
           R1 = Text.Printf.fpModifiers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccJC: // global
           I64[Sp - 8] = block_cccJx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccJG; else goto cccJy;
       uccJG: // global
           call _cccJx(R1) args: 0, res: 0, upd: 0;
       cccJy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccJx() //  [R1]
         { info_tbl: [(cccJx,
                       label: block_cccJx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccJx: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.742290998 UTC

[section ""data" . Text.Printf.printf_closure" {
     Text.Printf.printf_closure:
         const Text.Printf.printf_info;
 },
 Text.Printf.printf_entry() //  [R2, R3]
         { info_tbl: [(cccJL,
                       label: Text.Printf.printf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccJL: // global
           _scceR::P64 = R3;
           R3 = GHC.Types.[]_closure+1;
           _scceQ::P64 = R2;
           R2 = _scceR::P64;
           R1 = _scceQ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.743175973 UTC

[section ""data" . Text.Printf.hPrintf_closure" {
     Text.Printf.hPrintf_closure:
         const Text.Printf.hPrintf_info;
 },
 Text.Printf.hPrintf_entry() //  [R2, R3, R4]
         { info_tbl: [(cccJS,
                       label: Text.Printf.hPrintf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccJS: // global
           _scceU::P64 = R4;
           R4 = GHC.Types.[]_closure+1;
           _scceT::P64 = R3;
           R3 = _scceU::P64;
           _scceS::P64 = R2;
           R2 = _scceT::P64;
           R1 = _scceS::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.744460887 UTC

[section ""data" . Text.Printf.vFmt_closure" {
     Text.Printf.vFmt_closure:
         const Text.Printf.vFmt_info;
 },
 Text.Printf.vFmt_entry() //  [R2, R3]
         { info_tbl: [(cccK2,
                       label: Text.Printf.vFmt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccK2: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cccK6; else goto cccK7;
       cccK6: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.vFmt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cccK7: // global
           I64[Sp - 16] = block_cccJZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uccKo; else goto cccK0;
       uccKo: // global
           call _cccJZ(R1) args: 0, res: 0, upd: 0;
       cccK0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccJZ() //  [R1]
         { info_tbl: [(cccJZ,
                       label: block_cccJZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccJZ: // global
           I64[Sp - 56] = block_cccK5_info;
           _scceX::P64 = R1;
           _scceY::P64 = P64[R1 + 7];
           _scceZ::P64 = P64[R1 + 15];
           _sccf0::P64 = P64[R1 + 23];
           _sccf1::P64 = P64[R1 + 31];
           _sccf2::P64 = P64[R1 + 39];
           _sccf3::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 48] = _scceY::P64;
           P64[Sp - 40] = _scceZ::P64;
           P64[Sp - 32] = _sccf0::P64;
           P64[Sp - 24] = _sccf1::P64;
           P64[Sp - 16] = _sccf2::P64;
           P64[Sp - 8] = _sccf3::P64;
           P64[Sp] = _scceX::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uccKn; else goto cccK9;
       uccKn: // global
           call _cccK5(R1) args: 0, res: 0, upd: 0;
       cccK9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccK5() //  [R1]
         { info_tbl: [(cccK5,
                       label: block_cccK5_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccK5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cccKf; else goto cccKe;
       cccKf: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cccKe: // global
           if (I64[R1 + 7] == 118) goto cccKm; else goto cccKi;
       cccKm: // global
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 64];
           R1 = Hp - 55;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cccKi: // global
           Hp = Hp - 64;
           R1 = P64[Sp + 56] & (-8);
           Sp = Sp + 72;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.746338761 UTC

[section ""cstring" . lvl_rccbg_bytes" {
     lvl_rccbg_bytes:
         I8[] [112,114,105,110,116,102,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.747030113 UTC

[section ""data" . Text.Printf.perror_closure" {
     Text.Printf.perror_closure:
         const Text.Printf.perror_info;
         const 0;
 },
 Text.Printf.perror_entry() //  [R2]
         { info_tbl: [(cccKv,
                       label: Text.Printf.perror_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccKv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccKw; else goto cccKx;
       cccKw: // global
           R2 = R2;
           R1 = Text.Printf.perror_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccKx: // global
           I64[Sp - 8] = block_cccKt_info;
           R3 = R2;
           R2 = lvl_rccbg_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccKt() //  [R1]
         { info_tbl: [(cccKt,
                       label: block_cccKt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccKt: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.747984794 UTC

[section ""data" . lvl1_rccbh_closure" {
     lvl1_rccbh_closure:
         const :_con_info;
         const GHC.Show.$fShowChar3_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.748553232 UTC

[section ""cstring" . lvl2_rccbi_bytes" {
     lvl2_rccbi_bytes:
         I8[] [98,97,100,32,102,111,114,109,97,116,116,105,110,103,32,99,104,97,114,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.74982345 UTC

[section ""data" . Text.Printf.$werrorBadFormat_closure" {
     Text.Printf.$werrorBadFormat_closure:
         const Text.Printf.$werrorBadFormat_info;
         const 0;
 },
 sat_sccfc_entry() //  [R1]
         { info_tbl: [(cccKU,
                       label: sat_sccfc_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccKU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccKV; else goto cccKW;
       cccKV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccKW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = lvl1_rccbh_closure+2;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$wshowLitChar_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccfd_entry() //  [R1]
         { info_tbl: [(cccL0,
                       label: sat_sccfd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccL0: // global
           _sccfd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cccL1; else goto cccL2;
       cccL2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cccL4; else goto cccL3;
       cccL4: // global
           HpAlloc = 48;
           goto cccL1;
       cccL1: // global
           R1 = _sccfd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccL3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccfd::P64;
           _sccfb::I64 = I64[_sccfd::P64 + 16];
           if (_sccfb::I64 != 39) goto cccKY; else goto cccKZ;
       cccKY: // global
           I64[Hp - 40] = sat_sccfc_info;
           I64[Hp - 24] = _sccfb::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShowChar3_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cccKZ: // global
           Hp = Hp - 48;
           R1 = GHC.Show.$fShowChar1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccfe_entry() //  [R1]
         { info_tbl: [(cccL6,
                       label: sat_sccfe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccL6: // global
           _sccfe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cccL7; else goto cccL8;
       cccL8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cccLa; else goto cccL9;
       cccLa: // global
           HpAlloc = 24;
           goto cccL7;
       cccL7: // global
           R1 = _sccfe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccL9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccfe::P64;
           _sccfa::I64 = I64[_sccfe::P64 + 16];
           I64[Hp - 16] = sat_sccfd_info;
           I64[Hp] = _sccfa::I64;
           R3 = Hp - 16;
           R2 = lvl2_rccbi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$werrorBadFormat_entry() //  [R2]
         { info_tbl: [(cccLd,
                       label: Text.Printf.$werrorBadFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccLd: // global
           _sccfa::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cccLe; else goto cccLf;
       cccLf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cccLh; else goto cccLg;
       cccLh: // global
           HpAlloc = 24;
           goto cccLe;
       cccLe: // global
           R2 = _sccfa::I64;
           R1 = Text.Printf.$werrorBadFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccLg: // global
           I64[Hp - 16] = sat_sccfe_info;
           I64[Hp] = _sccfa::I64;
           I64[Sp - 8] = block_cccLb_info;
           R3 = Hp - 16;
           R2 = lvl_rccbg_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccLb() //  [R1]
         { info_tbl: [(cccLb,
                       label: block_cccLb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccLb: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.751955919 UTC

[section ""data" . Text.Printf.errorBadFormat_closure" {
     Text.Printf.errorBadFormat_closure:
         const Text.Printf.errorBadFormat_info;
         const 0;
 },
 Text.Printf.errorBadFormat_entry() //  [R2]
         { info_tbl: [(cccLs,
                       label: Text.Printf.errorBadFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccLs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccLt; else goto cccLu;
       cccLt: // global
           R2 = R2;
           R1 = Text.Printf.errorBadFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cccLu: // global
           I64[Sp - 8] = block_cccLp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccLy; else goto cccLq;
       uccLy: // global
           call _cccLp(R1) args: 0, res: 0, upd: 0;
       cccLq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccLp() //  [R1]
         { info_tbl: [(cccLp,
                       label: block_cccLp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccLp: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.752932865 UTC

[section ""cstring" . lvl3_rccbj_bytes" {
     lvl3_rccbj_bytes:
         I8[] [112,114,105,110,116,102,58,32,102,111,114,109,97,116,116,105,110,103,32,115,116,114,105,110,103,32,101,110,100,101,100,32,112,114,101,109,97,116,117,114,101,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.753730414 UTC

[section ""data" . Text.Printf.errorShortFormat_closure" {
     Text.Printf.errorShortFormat_closure:
         const Text.Printf.errorShortFormat_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorShortFormat_entry() //  [R1]
         { info_tbl: [(cccLH,
                       label: Text.Printf.errorShortFormat_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccLH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cccLI; else goto cccLJ;
       cccLI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccLJ: // global
           (_cccLC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccLC::I64 == 0) goto cccLE; else goto cccLD;
       cccLE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccLD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccLC::I64;
           I64[Sp - 24] = block_cccLF_info;
           R2 = lvl3_rccbj_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cccLF() //  [R1]
         { info_tbl: [(cccLF,
                       label: block_cccLF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccLF: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.755068637 UTC

[section ""data" . Text.Printf.$dmparseFormat_closure" {
     Text.Printf.$dmparseFormat_closure:
         const Text.Printf.$dmparseFormat_info;
         const 0;
 },
 Text.Printf.$dmparseFormat_entry() //  [R2, R3, R4]
         { info_tbl: [(cccLY,
                       label: Text.Printf.$dmparseFormat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccLY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cccLZ; else goto cccM0;
       cccLZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$dmparseFormat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cccM0: // global
           I64[Sp - 8] = block_cccLR_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uccMa; else goto cccLS;
       uccMa: // global
           call _cccLR(R1) args: 0, res: 0, upd: 0;
       cccLS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccLR() //  [R1]
         { info_tbl: [(cccLR,
                       label: block_cccLR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccLR: // global
           if (R1 & 7 == 1) goto cccLV; else goto cccLW;
       cccLV: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cccLW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cccM9; else goto cccM8;
       cccM9: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cccM8: // global
           _sccfo::P64 = P64[R1 + 6];
           _sccfp::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccfo::P64;
           P64[Hp] = _sccfp::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.756282603 UTC

[section ""cstring" . lvl4_rccbk_bytes" {
     lvl4_rccbk_bytes:
         I8[] [112,114,105,110,116,102,58,32,97,114,103,117,109,101,110,116,32,108,105,115,116,32,101,110,100,101,100,32,112,114,101,109,97,116,117,114,101,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.75705082 UTC

[section ""data" . Text.Printf.errorMissingArgument_closure" {
     Text.Printf.errorMissingArgument_closure:
         const Text.Printf.errorMissingArgument_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorMissingArgument_entry() //  [R1]
         { info_tbl: [(cccMj,
                       label: Text.Printf.errorMissingArgument_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccMj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cccMk; else goto cccMl;
       cccMk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccMl: // global
           (_cccMe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccMe::I64 == 0) goto cccMg; else goto cccMf;
       cccMg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccMf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccMe::I64;
           I64[Sp - 24] = block_cccMh_info;
           R2 = lvl4_rccbk_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cccMh() //  [R1]
         { info_tbl: [(cccMh,
                       label: block_cccMh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccMh: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.758097252 UTC

[section ""cstring" . lvl5_rccbl_bytes" {
     lvl5_rccbl_bytes:
         I8[] [112,114,105,110,116,102,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.758844952 UTC

[section ""data" . Text.Printf.errorBadArgument_closure" {
     Text.Printf.errorBadArgument_closure:
         const Text.Printf.errorBadArgument_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorBadArgument_entry() //  [R1]
         { info_tbl: [(cccMx,
                       label: Text.Printf.errorBadArgument_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccMx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cccMy; else goto cccMz;
       cccMy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccMz: // global
           (_cccMs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccMs::I64 == 0) goto cccMu; else goto cccMt;
       cccMu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccMt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccMs::I64;
           I64[Sp - 24] = block_cccMv_info;
           R2 = lvl5_rccbl_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cccMv() //  [R1]
         { info_tbl: [(cccMv,
                       label: block_cccMv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccMv: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.759877811 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble9_bytes" {
     Text.Printf.$fPrintfArgDouble9_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.760630407 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble8_closure" {
     Text.Printf.$fPrintfArgDouble8_closure:
         const Text.Printf.$fPrintfArgDouble8_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble8_entry() //  [R1]
         { info_tbl: [(cccMJ,
                       label: Text.Printf.$fPrintfArgDouble8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccMJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccMK; else goto cccML;
       cccMK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccML: // global
           (_cccMG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccMG::I64 == 0) goto cccMI; else goto cccMH;
       cccMI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccMH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccMG::I64;
           R2 = Text.Printf.$fPrintfArgDouble9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.761559795 UTC

[section ""cstring" . lvl6_rccbm_bytes" {
     lvl6_rccbm_bytes:
         I8[] [112,114,105,110,116,102,58,32,105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,105,109,112,111,115,115,105,98,108,101,32,100,102,109,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.763902425 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble7_closure" {
     Text.Printf.$fPrintfArgDouble7_closure:
         const Text.Printf.$fPrintfArgDouble7_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble7_entry() //  [R1]
         { info_tbl: [(cccMU,
                       label: Text.Printf.$fPrintfArgDouble7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccMU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cccMV; else goto cccMW;
       cccMV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccMW: // global
           (_cccMP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccMP::I64 == 0) goto cccMR; else goto cccMQ;
       cccMR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccMQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccMP::I64;
           I64[Sp - 24] = block_cccMS_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cccMS() //  [R1]
         { info_tbl: [(cccMS,
                       label: block_cccMS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccMS: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.767269582 UTC

[section ""data" . Text.Printf.$w$sdfmt_closure" {
     Text.Printf.$w$sdfmt_closure:
         const Text.Printf.$w$sdfmt_info;
         const 0;
 },
 Text.Printf.$w$sdfmt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccN1: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2,
                                           R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$w$sdfmt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cccN7,
                       label: Text.Printf.$w$sdfmt_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccN7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cccN8; else goto cccN9;
       cccN8: // global
           R1 = Text.Printf.$w$sdfmt_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cccN9: // global
           _sccfw::P64 = R5;
           _sccfv::P64 = R4;
           _sccfu::P64 = R3;
           (_sccfB::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(R2);
           (_sccfG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(R2);
           if (_sccfG::I64 > 1114111) goto cccNo; else goto cccQ2;
       cccNo: // global
           R2 = _sccfG::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cccQ2: // global
           if (_sccfG::I64 < 103) goto uccQ7; else goto uccQ9;
       uccQ7: // global
           if (_sccfG::I64 < 102) goto uccQ8; else goto cccOP;
       uccQ8: // global
           if (_sccfG::I64 < 101) goto cccOp; else goto cccOD;
       cccOD: // global
           I64[Sp - 24] = block_cccOx_info;
           R1 = _sccfw::P64;
           P64[Sp - 16] = _sccfu::P64;
           I64[Sp - 8] = _sccfB::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uccQh; else goto cccOy;
       uccQh: // global
           call _cccOx(R1) args: 0, res: 0, upd: 0;
       cccOy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cccOP: // global
           I64[Sp - 32] = block_cccOO_info;
           R1 = _sccfv::P64;
           P64[Sp - 24] = _sccfu::P64;
           P64[Sp - 16] = _sccfw::P64;
           I64[Sp - 8] = _sccfB::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uccQi; else goto cccOR;
       uccQi: // global
           call _cccOO(R1) args: 0, res: 0, upd: 0;
       cccOR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uccQ9: // global
           if (_sccfG::I64 >= 104) goto cccOp; else goto cccPt;
       cccOp: // global
           R1 = Text.Printf.$fPrintfArgDouble7_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cccPt: // global
           I64[Sp - 32] = block_cccPs_info;
           R1 = _sccfv::P64;
           P64[Sp - 24] = _sccfu::P64;
           P64[Sp - 16] = _sccfw::P64;
           I64[Sp - 8] = _sccfB::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uccQj; else goto cccPv;
       uccQj: // global
           call _cccPs(R1) args: 0, res: 0, upd: 0;
       cccPv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccOx() //  [R1]
         { info_tbl: [(cccOx,
                       label: block_cccOx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccOx: // global
           _sccfu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cccOC_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = _sccfu::P64;
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 8;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccOC() //  [R1]
         { info_tbl: [(cccOC,
                       label: block_cccOC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccOC: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _cccOO() //  [R1]
         { info_tbl: [(cccOO,
                       label: block_cccOO_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccOO: // global
           _sccfw::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cccP3; else goto cccPi;
       cccP3: // global
           I64[Sp] = block_cccOV_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto uccQp; else goto cccOW;
       uccQp: // global
           call _cccOV(R1) args: 0, res: 0, upd: 0;
       cccOW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cccPi: // global
           I64[Sp] = block_cccPb_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto uccQq; else goto cccPc;
       uccQq: // global
           call _cccPb(R1) args: 0, res: 0, upd: 0;
       cccPc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccOV() //  [R1]
         { info_tbl: [(cccOV,
                       label: block_cccOV_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccOV: // global
           I64[Sp + 16] = block_cccP0_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccP0() //  [R1]
         { info_tbl: [(cccP0,
                       label: block_cccP0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccP0: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _cccPb() //  [R1]
         { info_tbl: [(cccPb,
                       label: block_cccPb_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccPb: // global
           I64[Sp + 16] = block_cccPg_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccPg() //  [R1]
         { info_tbl: [(cccPg,
                       label: block_cccPg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccPg: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _cccPs() //  [R1]
         { info_tbl: [(cccPs,
                       label: block_cccPs_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccPs: // global
           _sccfw::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cccPH; else goto cccPW;
       cccPH: // global
           I64[Sp] = block_cccPz_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto uccQt; else goto cccPA;
       uccQt: // global
           call _cccPz(R1) args: 0, res: 0, upd: 0;
       cccPA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cccPW: // global
           I64[Sp] = block_cccPP_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto uccQu; else goto cccPQ;
       uccQu: // global
           call _cccPP(R1) args: 0, res: 0, upd: 0;
       cccPQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccPz() //  [R1]
         { info_tbl: [(cccPz,
                       label: block_cccPz_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccPz: // global
           I64[Sp + 16] = block_cccPE_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccPE() //  [R1]
         { info_tbl: [(cccPE,
                       label: block_cccPE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccPE: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _cccPP() //  [R1]
         { info_tbl: [(cccPP,
                       label: block_cccPP_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccPP: // global
           I64[Sp + 16] = block_cccPU_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccPU() //  [R1]
         { info_tbl: [(cccPU,
                       label: block_cccPU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccPU: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _sccfK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccfK: // global
           _sccfL::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto cccNY; else goto cccNB;
       cccNY: // global
           I64[Sp + 8] = block_cccNX_info;
           R1 = _sccfL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uccQx; else goto cccNZ;
       uccQx: // global
           call _cccNX(R1) args: 0, res: 0, upd: 0;
       cccNZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cccNB: // global
           I64[Sp + 8] = block_cccNz_info;
           R3 = _sccfL::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccNX() //  [R1]
         { info_tbl: [(cccNX,
                       label: block_cccNX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccNX: // global
           if (R1 & 7 == 1) goto uccQg; else goto cccOa;
       uccQg: // global
           Sp = Sp + 8;
           call _cccO5() args: 0, res: 0, upd: 0;
       cccOa: // global
           I64[Sp - 16] = block_cccO8_info;
           _sccfT::P64 = R1;
           _sccfV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccfV::P64;
           P64[Sp] = _sccfT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uccQm; else goto cccOb;
       uccQm: // global
           call _cccO8(R1) args: 0, res: 0, upd: 0;
       cccOb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccO8() //  [R1]
         { info_tbl: [(cccO8,
                       label: block_cccO8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccO8: // global
           if (I64[R1 + 7] == 45) goto cccOj; else goto cccOi;
       cccOj: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cccOi: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cccNz() //  [R1]
         { info_tbl: [(cccNz,
                       label: block_cccNz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccNz: // global
           if (R1 & 7 == 1) goto uccQf; else goto cccNM;
       uccQf: // global
           Sp = Sp + 8;
           call _cccO5() args: 0, res: 0, upd: 0;
       cccNM: // global
           I64[Sp - 16] = block_cccNK_info;
           _sccfN::P64 = R1;
           _sccfP::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccfP::P64;
           P64[Sp] = _sccfN::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uccQk; else goto cccNN;
       uccQk: // global
           call _cccNK(R1) args: 0, res: 0, upd: 0;
       cccNN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccO5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccO5: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cccNK() //  [R1]
         { info_tbl: [(cccNK,
                       label: block_cccNK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccNK: // global
           if (I64[R1 + 7] == 45) goto cccNV; else goto cccNU;
       cccNV: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cccNU: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.772388532 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat1_closure" {
     Text.Printf.$fPrintfArgFloat1_closure:
         const Text.Printf.$fPrintfArgFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat1_entry() //  [R1]
         { info_tbl: [(cccQG,
                       label: Text.Printf.$fPrintfArgFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccQG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cccQH; else goto cccQI;
       cccQH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccQI: // global
           (_cccQB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccQB::I64 == 0) goto cccQD; else goto cccQC;
       cccQD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccQC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccQB::I64;
           I64[Sp - 24] = block_cccQE_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cccQE() //  [R1]
         { info_tbl: [(cccQE,
                       label: block_cccQE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccQE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.775474483 UTC

[section ""data" . Text.Printf.$w$sdfmt1_closure" {
     Text.Printf.$w$sdfmt1_closure:
         const Text.Printf.$w$sdfmt1_info;
         const 0;
 },
 Text.Printf.$w$sdfmt1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccQN: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$w$sdfmt1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cccQT,
                       label: Text.Printf.$w$sdfmt1_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccQT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cccQU; else goto cccQV;
       cccQU: // global
           R1 = Text.Printf.$w$sdfmt1_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cccQV: // global
           _sccgm::P64 = R5;
           _sccgl::P64 = R4;
           _sccgk::P64 = R3;
           (_sccgr::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(R2);
           (_sccgw::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(R2);
           if (_sccgw::I64 > 1114111) goto cccRa; else goto cccTO;
       cccRa: // global
           R2 = _sccgw::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cccTO: // global
           if (_sccgw::I64 < 103) goto uccTT; else goto uccTV;
       uccTT: // global
           if (_sccgw::I64 < 102) goto uccTU; else goto cccSB;
       uccTU: // global
           if (_sccgw::I64 < 101) goto cccSb; else goto cccSp;
       cccSp: // global
           I64[Sp - 24] = block_cccSj_info;
           R1 = _sccgm::P64;
           P64[Sp - 16] = _sccgk::P64;
           I64[Sp - 8] = _sccgr::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uccU3; else goto cccSk;
       uccU3: // global
           call _cccSj(R1) args: 0, res: 0, upd: 0;
       cccSk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cccSB: // global
           I64[Sp - 32] = block_cccSA_info;
           R1 = _sccgl::P64;
           P64[Sp - 24] = _sccgk::P64;
           P64[Sp - 16] = _sccgm::P64;
           I64[Sp - 8] = _sccgr::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uccU4; else goto cccSD;
       uccU4: // global
           call _cccSA(R1) args: 0, res: 0, upd: 0;
       cccSD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uccTV: // global
           if (_sccgw::I64 >= 104) goto cccSb; else goto cccTf;
       cccSb: // global
           R1 = Text.Printf.$fPrintfArgFloat1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cccTf: // global
           I64[Sp - 32] = block_cccTe_info;
           R1 = _sccgl::P64;
           P64[Sp - 24] = _sccgk::P64;
           P64[Sp - 16] = _sccgm::P64;
           I64[Sp - 8] = _sccgr::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uccU5; else goto cccTh;
       uccU5: // global
           call _cccTe(R1) args: 0, res: 0, upd: 0;
       cccTh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccSj() //  [R1]
         { info_tbl: [(cccSj,
                       label: block_cccSj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccSj: // global
           _sccgk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cccSo_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = _sccgk::P64;
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 8;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccSo() //  [R1]
         { info_tbl: [(cccSo,
                       label: block_cccSo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccSo: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _cccSA() //  [R1]
         { info_tbl: [(cccSA,
                       label: block_cccSA_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccSA: // global
           _sccgm::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cccSP; else goto cccT4;
       cccSP: // global
           I64[Sp] = block_cccSH_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto uccUb; else goto cccSI;
       uccUb: // global
           call _cccSH(R1) args: 0, res: 0, upd: 0;
       cccSI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cccT4: // global
           I64[Sp] = block_cccSX_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto uccUc; else goto cccSY;
       uccUc: // global
           call _cccSX(R1) args: 0, res: 0, upd: 0;
       cccSY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccSH() //  [R1]
         { info_tbl: [(cccSH,
                       label: block_cccSH_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccSH: // global
           I64[Sp + 16] = block_cccSM_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccSM() //  [R1]
         { info_tbl: [(cccSM,
                       label: block_cccSM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccSM: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _cccSX() //  [R1]
         { info_tbl: [(cccSX,
                       label: block_cccSX_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccSX: // global
           I64[Sp + 16] = block_cccT2_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccT2() //  [R1]
         { info_tbl: [(cccT2,
                       label: block_cccT2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccT2: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _cccTe() //  [R1]
         { info_tbl: [(cccTe,
                       label: block_cccTe_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccTe: // global
           _sccgm::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cccTt; else goto cccTI;
       cccTt: // global
           I64[Sp] = block_cccTl_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto uccUf; else goto cccTm;
       uccUf: // global
           call _cccTl(R1) args: 0, res: 0, upd: 0;
       cccTm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cccTI: // global
           I64[Sp] = block_cccTB_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto uccUg; else goto cccTC;
       uccUg: // global
           call _cccTB(R1) args: 0, res: 0, upd: 0;
       cccTC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccTl() //  [R1]
         { info_tbl: [(cccTl,
                       label: block_cccTl_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccTl: // global
           I64[Sp + 16] = block_cccTq_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccTq() //  [R1]
         { info_tbl: [(cccTq,
                       label: block_cccTq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccTq: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _cccTB() //  [R1]
         { info_tbl: [(cccTB,
                       label: block_cccTB_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccTB: // global
           I64[Sp + 16] = block_cccTG_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccTG() //  [R1]
         { info_tbl: [(cccTG,
                       label: block_cccTG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccTG: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _sccgA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccgA: // global
           _sccgB::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto cccRK; else goto cccRn;
       cccRK: // global
           I64[Sp + 8] = block_cccRJ_info;
           R1 = _sccgB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uccUj; else goto cccRL;
       uccUj: // global
           call _cccRJ(R1) args: 0, res: 0, upd: 0;
       cccRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cccRn: // global
           I64[Sp + 8] = block_cccRl_info;
           R3 = _sccgB::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccRJ() //  [R1]
         { info_tbl: [(cccRJ,
                       label: block_cccRJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccRJ: // global
           if (R1 & 7 == 1) goto uccU2; else goto cccRW;
       uccU2: // global
           Sp = Sp + 8;
           call _cccRR() args: 0, res: 0, upd: 0;
       cccRW: // global
           I64[Sp - 16] = block_cccRU_info;
           _sccgJ::P64 = R1;
           _sccgL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccgL::P64;
           P64[Sp] = _sccgJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uccU8; else goto cccRX;
       uccU8: // global
           call _cccRU(R1) args: 0, res: 0, upd: 0;
       cccRX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccRU() //  [R1]
         { info_tbl: [(cccRU,
                       label: block_cccRU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccRU: // global
           if (I64[R1 + 7] == 45) goto cccS5; else goto cccS4;
       cccS5: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cccS4: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cccRl() //  [R1]
         { info_tbl: [(cccRl,
                       label: block_cccRl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccRl: // global
           if (R1 & 7 == 1) goto uccU1; else goto cccRy;
       uccU1: // global
           Sp = Sp + 8;
           call _cccRR() args: 0, res: 0, upd: 0;
       cccRy: // global
           I64[Sp - 16] = block_cccRw_info;
           _sccgD::P64 = R1;
           _sccgF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccgF::P64;
           P64[Sp] = _sccgD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uccU6; else goto cccRz;
       uccU6: // global
           call _cccRw(R1) args: 0, res: 0, upd: 0;
       cccRz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccRR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccRR: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cccRw() //  [R1]
         { info_tbl: [(cccRw,
                       label: block_cccRw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccRw: // global
           if (I64[R1 + 7] == 45) goto cccRH; else goto cccRG;
       cccRH: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cccRG: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.780533164 UTC

[section ""data" . Text.Printf.formatRealFloat1_closure" {
     Text.Printf.formatRealFloat1_closure:
         const Text.Printf.formatRealFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.formatRealFloat1_entry() //  [R1]
         { info_tbl: [(cccUs,
                       label: Text.Printf.formatRealFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccUs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cccUt; else goto cccUu;
       cccUt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccUu: // global
           (_cccUn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccUn::I64 == 0) goto cccUp; else goto cccUo;
       cccUp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccUo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccUn::I64;
           I64[Sp - 24] = block_cccUq_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cccUq() //  [R1]
         { info_tbl: [(cccUq,
                       label: block_cccUq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccUq: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.783746219 UTC

[section ""data" . Text.Printf.$wdfmt_closure" {
     Text.Printf.$wdfmt_closure:
         const Text.Printf.$wdfmt_info;
         const 0;
 },
 Text.Printf.$wdfmt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccUz: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2,
                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wdfmt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cccUF,
                       label: Text.Printf.$wdfmt_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccUF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cccUG; else goto cccUH;
       cccUG: // global
           R1 = Text.Printf.$wdfmt_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cccUH: // global
           _scchd::P64 = R6;
           _scchc::P64 = R5;
           _scchb::P64 = R4;
           _sccha::I64 = R3;
           _cccUK::I64 = R3;
           (_scchi::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(_cccUK::I64);
           (_scchn::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(_sccha::I64);
           if (_scchn::I64 > 1114111) goto cccUW; else goto cccX6;
       cccUW: // global
           R2 = _scchn::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cccX6: // global
           if (_scchn::I64 < 103) goto uccXb; else goto uccXd;
       uccXb: // global
           if (_scchn::I64 < 102) goto uccXc; else goto cccWh;
       uccXc: // global
           if (_scchn::I64 < 101) goto cccVX; else goto cccW6;
       cccW6: // global
           I64[Sp - 16] = block_cccW5_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFExponent_closure+1;
           R2 = R2;
           I64[Sp - 8] = _scchi::I64;
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       cccWh: // global
           I64[Sp - 40] = block_cccWg_info;
           R1 = _scchc::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = _scchb::P64;
           P64[Sp - 16] = _scchd::P64;
           I64[Sp - 8] = _scchi::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uccXl; else goto cccWj;
       uccXl: // global
           call _cccWg(R1) args: 0, res: 0, upd: 0;
       cccWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uccXd: // global
           if (_scchn::I64 >= 104) goto cccVX; else goto cccWJ;
       cccVX: // global
           R1 = Text.Printf.formatRealFloat1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cccWJ: // global
           I64[Sp - 40] = block_cccWI_info;
           R1 = _scchc::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = _scchb::P64;
           P64[Sp - 16] = _scchd::P64;
           I64[Sp - 8] = _scchi::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uccXm; else goto cccWL;
       uccXm: // global
           call _cccWI(R1) args: 0, res: 0, upd: 0;
       cccWL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccW5() //  [R1]
         { info_tbl: [(cccW5,
                       label: block_cccW5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccW5: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _cccWg() //  [R1]
         { info_tbl: [(cccWg,
                       label: block_cccWg_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccWg: // global
           _scch9::P64 = P64[Sp + 8];
           _scchb::P64 = P64[Sp + 16];
           _scchd::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cccWq; else goto cccWz;
       cccWq: // global
           I64[Sp + 24] = block_cccWn_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       cccWz: // global
           I64[Sp + 24] = block_cccWx_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.True_closure+2;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccWn() //  [R1]
         { info_tbl: [(cccWn,
                       label: block_cccWn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccWn: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _cccWx() //  [R1]
         { info_tbl: [(cccWx,
                       label: block_cccWx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccWx: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _cccWI() //  [R1]
         { info_tbl: [(cccWI,
                       label: block_cccWI_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccWI: // global
           _scch9::P64 = P64[Sp + 8];
           _scchb::P64 = P64[Sp + 16];
           _scchd::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cccWS; else goto cccX1;
       cccWS: // global
           I64[Sp + 24] = block_cccWP_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       cccX1: // global
           I64[Sp + 24] = block_cccWZ_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.True_closure+2;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccWP() //  [R1]
         { info_tbl: [(cccWP,
                       label: block_cccWP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccWP: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _cccWZ() //  [R1]
         { info_tbl: [(cccWZ,
                       label: block_cccWZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccWZ: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _scchr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scchr: // global
           _scchs::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto cccVw; else goto cccV9;
       cccVw: // global
           I64[Sp + 8] = block_cccVv_info;
           R1 = _scchs::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uccXw; else goto cccVx;
       uccXw: // global
           call _cccVv(R1) args: 0, res: 0, upd: 0;
       cccVx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cccV9: // global
           I64[Sp + 8] = block_cccV7_info;
           R3 = _scchs::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccVv() //  [R1]
         { info_tbl: [(cccVv,
                       label: block_cccVv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccVv: // global
           if (R1 & 7 == 1) goto uccXk; else goto cccVI;
       uccXk: // global
           Sp = Sp + 8;
           call _cccVD() args: 0, res: 0, upd: 0;
       cccVI: // global
           I64[Sp - 16] = block_cccVG_info;
           _scchA::P64 = R1;
           _scchC::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scchC::P64;
           P64[Sp] = _scchA::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uccXp; else goto cccVJ;
       uccXp: // global
           call _cccVG(R1) args: 0, res: 0, upd: 0;
       cccVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccVG() //  [R1]
         { info_tbl: [(cccVG,
                       label: block_cccVG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccVG: // global
           if (I64[R1 + 7] == 45) goto cccVR; else goto cccVQ;
       cccVR: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cccVQ: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cccV7() //  [R1]
         { info_tbl: [(cccV7,
                       label: block_cccV7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccV7: // global
           if (R1 & 7 == 1) goto uccXj; else goto cccVk;
       uccXj: // global
           Sp = Sp + 8;
           call _cccVD() args: 0, res: 0, upd: 0;
       cccVk: // global
           I64[Sp - 16] = block_cccVi_info;
           _scchu::P64 = R1;
           _scchw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scchw::P64;
           P64[Sp] = _scchu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uccXn; else goto cccVl;
       uccXn: // global
           call _cccVi(R1) args: 0, res: 0, upd: 0;
       cccVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccVD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccVD: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cccVi() //  [R1]
         { info_tbl: [(cccVi,
                       label: block_cccVi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccVi: // global
           if (I64[R1 + 7] == 45) goto cccVt; else goto cccVs;
       cccVt: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cccVs: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.78792556 UTC

[section ""cstring" . Text.Printf.$trModule4_bytes" {
     Text.Printf.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.788455275 UTC

[section ""data" . Text.Printf.$trModule3_closure" {
     Text.Printf.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.789005777 UTC

[section ""cstring" . Text.Printf.$trModule2_bytes" {
     Text.Printf.$trModule2_bytes:
         I8[] [84,101,120,116,46,80,114,105,110,116,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.78958369 UTC

[section ""data" . Text.Printf.$trModule1_closure" {
     Text.Printf.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.790132639 UTC

[section ""data" . Text.Printf.$trModule_closure" {
     Text.Printf.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Text.Printf.$trModule3_closure+1;
         const Text.Printf.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.790721725 UTC

[section ""data" . $krep_rccbn_closure" {
     $krep_rccbn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.791271395 UTC

[section ""data" . $krep1_rccbo_closure" {
     $krep1_rccbo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.791866946 UTC

[section ""data" . $krep2_rccbp_closure" {
     $krep2_rccbp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.792475606 UTC

[section ""data" . $krep3_rccbq_closure" {
     $krep3_rccbq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.793069268 UTC

[section ""data" . $krep4_rccbr_closure" {
     $krep4_rccbr_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.793674806 UTC

[section ""data" . $krep5_rccbs_closure" {
     $krep5_rccbs_closure:
         const :_con_info;
         const $krep1_rccbo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.794246048 UTC

[section ""data" . $krep6_rccbt_closure" {
     $krep6_rccbt_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep5_rccbs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.794867251 UTC

[section ""data" . $krep7_rccbu_closure" {
     $krep7_rccbu_closure:
         const :_con_info;
         const $krep3_rccbq_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.795445682 UTC

[section ""data" . $krep8_rccbv_closure" {
     $krep8_rccbv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep7_rccbu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.79606318 UTC

[section ""data" . $krep9_rccbw_closure" {
     $krep9_rccbw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep8_rccbv_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.796670294 UTC

[section ""data" . Text.Printf.$tcHPrintfType1_closure" {
     Text.Printf.$tcHPrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep4_rccbr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.797383546 UTC

[section ""data" . $krep10_rccbx_closure" {
     $krep10_rccbx_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.797928489 UTC

[section ""data" . $krep11_rccby_closure" {
     $krep11_rccby_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep3_rccbq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.798525572 UTC

[section ""data" . $krep12_rccbz_closure" {
     $krep12_rccbz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep10_rccbx_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.79909266 UTC

[section ""cstring" . Text.Printf.$tcIsChar2_bytes" {
     Text.Printf.$tcIsChar2_bytes:
         I8[] [73,115,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.799643695 UTC

[section ""data" . Text.Printf.$tcIsChar1_closure" {
     Text.Printf.$tcIsChar1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcIsChar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.800241489 UTC

[section ""data" . Text.Printf.$tcIsChar_closure" {
     Text.Printf.$tcIsChar_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcIsChar1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 660225335504909605;
         const 5800397900948792736;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.800846432 UTC

[section ""data" . $krep13_rccbA_closure" {
     $krep13_rccbA_closure:
         const :_con_info;
         const $krep10_rccbx_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.80141158 UTC

[section ""data" . $krep14_rccbB_closure" {
     $krep14_rccbB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcIsChar_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.802001399 UTC

[section ""data" . $krep15_rccbC_closure" {
     $krep15_rccbC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_rccbz_closure+4;
         const $krep14_rccbB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.802581362 UTC

[section ""data" . Text.Printf.$tc'C:IsChar1_closure" {
     Text.Printf.$tc'C:IsChar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rccby_closure+4;
         const $krep15_rccbC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.803188809 UTC

[section ""cstring" . Text.Printf.$tc'C:IsChar3_bytes" {
     Text.Printf.$tc'C:IsChar3_bytes:
         I8[] [39,67,58,73,115,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.80374042 UTC

[section ""data" . Text.Printf.$tc'C:IsChar2_closure" {
     Text.Printf.$tc'C:IsChar2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:IsChar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.804292036 UTC

[section ""data" . Text.Printf.$tc'C:IsChar_closure" {
     Text.Printf.$tc'C:IsChar_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:IsChar2_closure+1;
         const Text.Printf.$tc'C:IsChar1_closure+4;
         const 15586488259906363003;
         const 17643381548147423706;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.804859488 UTC

[section ""cstring" . Text.Printf.$tcFormatAdjustment2_bytes" {
     Text.Printf.$tcFormatAdjustment2_bytes:
         I8[] [70,111,114,109,97,116,65,100,106,117,115,116,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.805410336 UTC

[section ""data" . Text.Printf.$tcFormatAdjustment1_closure" {
     Text.Printf.$tcFormatAdjustment1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatAdjustment2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.805948454 UTC

[section ""data" . Text.Printf.$tcFormatAdjustment_closure" {
     Text.Printf.$tcFormatAdjustment_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatAdjustment1_closure+1;
         const GHC.Types.krep$*_closure;
         const 7532892403054408380;
         const 17299592949916286280;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.806574845 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust1_closure" {
     Text.Printf.$tc'LeftAdjust1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatAdjustment_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.807169682 UTC

[section ""cstring" . Text.Printf.$tc'LeftAdjust3_bytes" {
     Text.Printf.$tc'LeftAdjust3_bytes:
         I8[] [39,76,101,102,116,65,100,106,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.807726881 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust2_closure" {
     Text.Printf.$tc'LeftAdjust2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'LeftAdjust3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.808303428 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust_closure" {
     Text.Printf.$tc'LeftAdjust_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'LeftAdjust2_closure+1;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const 3724221440131574524;
         const 12430068224974793646;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.808907683 UTC

[section ""cstring" . Text.Printf.$tc'ZeroPad2_bytes" {
     Text.Printf.$tc'ZeroPad2_bytes:
         I8[] [39,90,101,114,111,80,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.810978734 UTC

[section ""data" . Text.Printf.$tc'ZeroPad1_closure" {
     Text.Printf.$tc'ZeroPad1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'ZeroPad2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.811589309 UTC

[section ""data" . Text.Printf.$tc'ZeroPad_closure" {
     Text.Printf.$tc'ZeroPad_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'ZeroPad1_closure+1;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const 4688343247861108158;
         const 7307113320833774212;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.81224184 UTC

[section ""data" . $krep16_rccbD_closure" {
     $krep16_rccbD_closure:
         const :_con_info;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.812820002 UTC

[section ""data" . $krep17_rccbE_closure" {
     $krep17_rccbE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep16_rccbD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.813464224 UTC

[section ""cstring" . Text.Printf.$tcFormatSign2_bytes" {
     Text.Printf.$tcFormatSign2_bytes:
         I8[] [70,111,114,109,97,116,83,105,103,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.813983471 UTC

[section ""data" . Text.Printf.$tcFormatSign1_closure" {
     Text.Printf.$tcFormatSign1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatSign2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.814562917 UTC

[section ""data" . Text.Printf.$tcFormatSign_closure" {
     Text.Printf.$tcFormatSign_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatSign1_closure+1;
         const GHC.Types.krep$*_closure;
         const 35986971025498593;
         const 9833165860459639351;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.815199928 UTC

[section ""data" . Text.Printf.$tc'SignPlus1_closure" {
     Text.Printf.$tc'SignPlus1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatSign_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.815797651 UTC

[section ""cstring" . Text.Printf.$tc'SignPlus3_bytes" {
     Text.Printf.$tc'SignPlus3_bytes:
         I8[] [39,83,105,103,110,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.816380531 UTC

[section ""data" . Text.Printf.$tc'SignPlus2_closure" {
     Text.Printf.$tc'SignPlus2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'SignPlus3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.816968536 UTC

[section ""data" . Text.Printf.$tc'SignPlus_closure" {
     Text.Printf.$tc'SignPlus_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'SignPlus2_closure+1;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const 18302065795158432479;
         const 11830941225366619964;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.817950307 UTC

[section ""cstring" . Text.Printf.$tc'SignSpace2_bytes" {
     Text.Printf.$tc'SignSpace2_bytes:
         I8[] [39,83,105,103,110,83,112,97,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.818484025 UTC

[section ""data" . Text.Printf.$tc'SignSpace1_closure" {
     Text.Printf.$tc'SignSpace1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'SignSpace2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.818989259 UTC

[section ""data" . Text.Printf.$tc'SignSpace_closure" {
     Text.Printf.$tc'SignSpace_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'SignSpace1_closure+1;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const 111286303843533919;
         const 13624428119758319457;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.819589685 UTC

[section ""data" . $krep18_rccbF_closure" {
     $krep18_rccbF_closure:
         const :_con_info;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.820178314 UTC

[section ""data" . $krep19_rccbG_closure" {
     $krep19_rccbG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep18_rccbF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.820795524 UTC

[section ""cstring" . Text.Printf.$tcFieldFormat2_bytes" {
     Text.Printf.$tcFieldFormat2_bytes:
         I8[] [70,105,101,108,100,70,111,114,109,97,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.821395929 UTC

[section ""data" . Text.Printf.$tcFieldFormat1_closure" {
     Text.Printf.$tcFieldFormat1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFieldFormat2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.822023828 UTC

[section ""data" . Text.Printf.$tcFieldFormat_closure" {
     Text.Printf.$tcFieldFormat_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFieldFormat1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12330325036165183082;
         const 5846211506648458401;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.822683416 UTC

[section ""data" . $krep20_rccbH_closure" {
     $krep20_rccbH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFieldFormat_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.823265029 UTC

[section ""data" . $krep21_rccbI_closure" {
     $krep21_rccbI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep20_rccbH_closure+1;
         const $krep9_rccbw_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.823870481 UTC

[section ""data" . $krep22_rccbJ_closure" {
     $krep22_rccbJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep21_rccbI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.82461572 UTC

[section ""data" . $krep23_rccbK_closure" {
     $krep23_rccbK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep20_rccbH_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.825277235 UTC

[section ""data" . $krep24_rccbL_closure" {
     $krep24_rccbL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep23_rccbK_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.825894707 UTC

[section ""data" . $krep25_rccbM_closure" {
     $krep25_rccbM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rccbn_closure+1;
         const $krep24_rccbL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.82655933 UTC

[section ""data" . $krep26_rccbN_closure" {
     $krep26_rccbN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep19_rccbG_closure+1;
         const $krep25_rccbM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.827144623 UTC

[section ""data" . $krep27_rccbO_closure" {
     $krep27_rccbO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_rccbE_closure+1;
         const $krep26_rccbN_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.827705809 UTC

[section ""data" . $krep28_rccbP_closure" {
     $krep28_rccbP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rccbt_closure+1;
         const $krep27_rccbO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.828365005 UTC

[section ""data" . Text.Printf.$tc'FieldFormat1_closure" {
     Text.Printf.$tc'FieldFormat1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rccbt_closure+1;
         const $krep28_rccbP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.829082441 UTC

[section ""cstring" . Text.Printf.$tc'FieldFormat3_bytes" {
     Text.Printf.$tc'FieldFormat3_bytes:
         I8[] [39,70,105,101,108,100,70,111,114,109,97,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.830403761 UTC

[section ""data" . Text.Printf.$tc'FieldFormat2_closure" {
     Text.Printf.$tc'FieldFormat2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'FieldFormat3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.830999376 UTC

[section ""data" . Text.Printf.$tc'FieldFormat_closure" {
     Text.Printf.$tc'FieldFormat_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'FieldFormat2_closure+1;
         const Text.Printf.$tc'FieldFormat1_closure+4;
         const 11348432599023007686;
         const 6814357301696130957;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.831607775 UTC

[section ""cstring" . Text.Printf.$tcFormatParse2_bytes" {
     Text.Printf.$tcFormatParse2_bytes:
         I8[] [70,111,114,109,97,116,80,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.832137378 UTC

[section ""data" . Text.Printf.$tcFormatParse1_closure" {
     Text.Printf.$tcFormatParse1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatParse2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.832704587 UTC

[section ""data" . Text.Printf.$tcFormatParse_closure" {
     Text.Printf.$tcFormatParse_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatParse1_closure+1;
         const GHC.Types.krep$*_closure;
         const 5517048358589873764;
         const 8326725038359313810;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.833392877 UTC

[section ""data" . $krep29_rccbQ_closure" {
     $krep29_rccbQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatParse_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.833972178 UTC

[section ""data" . $krep30_rccbR_closure" {
     $krep30_rccbR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep29_rccbQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.834526943 UTC

[section ""data" . $krep31_rccbS_closure" {
     $krep31_rccbS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep30_rccbR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.835078206 UTC

[section ""data" . $krep32_rccbT_closure" {
     $krep32_rccbT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep30_rccbR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.835655334 UTC

[section ""data" . Text.Printf.$tc'FormatParse1_closure" {
     Text.Printf.$tc'FormatParse1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep32_rccbT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.836235508 UTC

[section ""cstring" . Text.Printf.$tc'FormatParse3_bytes" {
     Text.Printf.$tc'FormatParse3_bytes:
         I8[] [39,70,111,114,109,97,116,80,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.836780125 UTC

[section ""data" . Text.Printf.$tc'FormatParse2_closure" {
     Text.Printf.$tc'FormatParse2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'FormatParse3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.837391069 UTC

[section ""data" . Text.Printf.$tc'FormatParse_closure" {
     Text.Printf.$tc'FormatParse_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'FormatParse2_closure+1;
         const Text.Printf.$tc'FormatParse1_closure+4;
         const 549767054447046648;
         const 1116614444935710689;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.838868541 UTC

[section ""data" . $krep33_rccbU_closure" {
     $krep33_rccbU_closure:
         const :_con_info;
         const $krep21_rccbI_closure+4;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.839441075 UTC

[section ""data" . $krep34_rccbV_closure" {
     $krep34_rccbV_closure:
         const :_con_info;
         const $krep30_rccbR_closure+4;
         const $krep33_rccbU_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.84001582 UTC

[section ""data" . $krep35_rccbW_closure" {
     $krep35_rccbW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep34_rccbV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.840577245 UTC

[section ""data" . $krep36_rccbX_closure" {
     $krep36_rccbX_closure:
         const :_con_info;
         const $krep35_rccbW_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.841130307 UTC

[section ""data" . $krep37_rccbY_closure" {
     $krep37_rccbY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep36_rccbX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.841761295 UTC

[section ""data" . $krep38_rccbZ_closure" {
     $krep38_rccbZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep37_rccbY_closure+1;
         const $krep10_rccbx_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.842321735 UTC

[section ""data" . $krep39_rccc0_closure" {
     $krep39_rccc0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep38_rccbZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.842891313 UTC

[section ""data" . $krep40_rccc1_closure" {
     $krep40_rccc1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rccbp_closure+1;
         const $krep39_rccc0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.843493029 UTC

[section ""cstring" . Text.Printf.$tcPrintfArg2_bytes" {
     Text.Printf.$tcPrintfArg2_bytes:
         I8[] [80,114,105,110,116,102,65,114,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.844101946 UTC

[section ""data" . Text.Printf.$tcPrintfArg1_closure" {
     Text.Printf.$tcPrintfArg1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcPrintfArg2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.844680784 UTC

[section ""data" . Text.Printf.$tcPrintfArg_closure" {
     Text.Printf.$tcPrintfArg_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcPrintfArg1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 14684532792197610005;
         const 5760551473172190061;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.845361119 UTC

[section ""data" . $krep41_rccc2_closure" {
     $krep41_rccc2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcPrintfArg_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.845932747 UTC

[section ""data" . $krep42_rccc3_closure" {
     $krep42_rccc3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep31_rccbS_closure+4;
         const $krep41_rccc2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.846505432 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg1_closure" {
     Text.Printf.$tc'C:PrintfArg1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep22_rccbJ_closure+4;
         const $krep42_rccc3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.847049819 UTC

[section ""cstring" . Text.Printf.$tc'C:PrintfArg3_bytes" {
     Text.Printf.$tc'C:PrintfArg3_bytes:
         I8[] [39,67,58,80,114,105,110,116,102,65,114,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.847645146 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg2_closure" {
     Text.Printf.$tc'C:PrintfArg2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:PrintfArg3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.84826399 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg_closure" {
     Text.Printf.$tc'C:PrintfArg_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:PrintfArg2_closure+1;
         const Text.Printf.$tc'C:PrintfArg1_closure+4;
         const 11923342243699112506;
         const 8346787778082712340;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.848906918 UTC

[section ""cstring" . Text.Printf.$tcHPrintfType3_bytes" {
     Text.Printf.$tcHPrintfType3_bytes:
         I8[] [72,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.849928576 UTC

[section ""data" . Text.Printf.$tcHPrintfType2_closure" {
     Text.Printf.$tcHPrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcHPrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.85047351 UTC

[section ""data" . Text.Printf.$tcHPrintfType_closure" {
     Text.Printf.$tcHPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcHPrintfType2_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 13104883804062546050;
         const 15477829653093370802;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.851074223 UTC

[section ""data" . $krep43_rccc4_closure" {
     $krep43_rccc4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcHPrintfType_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.851654308 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType1_closure" {
     Text.Printf.$tc'C:HPrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep40_rccc1_closure+4;
         const $krep43_rccc4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.852215318 UTC

[section ""cstring" . Text.Printf.$tc'C:HPrintfType3_bytes" {
     Text.Printf.$tc'C:HPrintfType3_bytes:
         I8[] [39,67,58,72,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.852768509 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType2_closure" {
     Text.Printf.$tc'C:HPrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:HPrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.85341575 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType_closure" {
     Text.Printf.$tc'C:HPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:HPrintfType2_closure+1;
         const Text.Printf.$tc'C:HPrintfType1_closure+4;
         const 16716104921226462095;
         const 4043378586122981700;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.854019242 UTC

[section ""cstring" . Text.Printf.$tcPrintfType2_bytes" {
     Text.Printf.$tcPrintfType2_bytes:
         I8[] [80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.854597304 UTC

[section ""data" . Text.Printf.$tcPrintfType1_closure" {
     Text.Printf.$tcPrintfType1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcPrintfType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.855171867 UTC

[section ""data" . Text.Printf.$tcPrintfType_closure" {
     Text.Printf.$tcPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcPrintfType1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 16100185319445667829;
         const 10371264040433388740;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.855786565 UTC

[section ""data" . $krep44_rccc5_closure" {
     $krep44_rccc5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcPrintfType_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.856392669 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType1_closure" {
     Text.Printf.$tc'C:PrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep39_rccc0_closure+4;
         const $krep44_rccc5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.857013347 UTC

[section ""cstring" . Text.Printf.$tc'C:PrintfType3_bytes" {
     Text.Printf.$tc'C:PrintfType3_bytes:
         I8[] [39,67,58,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.857675485 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType2_closure" {
     Text.Printf.$tc'C:PrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:PrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.858240799 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType_closure" {
     Text.Printf.$tc'C:PrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:PrintfType2_closure+1;
         const Text.Printf.$tc'C:PrintfType1_closure+4;
         const 6199067271817529220;
         const 10070277982064886839;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.858826937 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar24_bytes" {
     Text.Printf.$fPrintfArgChar24_bytes:
         I8[] [104,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.859675061 UTC

[section ""data" . Text.Printf.$fPrintfArgChar23_closure" {
     Text.Printf.$fPrintfArgChar23_closure:
         const Text.Printf.$fPrintfArgChar23_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar23_entry() //  [R1]
         { info_tbl: [(cccXD,
                       label: Text.Printf.$fPrintfArgChar23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccXD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccXE; else goto cccXF;
       cccXE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccXF: // global
           (_cccXA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccXA::I64 == 0) goto cccXC; else goto cccXB;
       cccXC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccXB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccXA::I64;
           R2 = Text.Printf.$fPrintfArgChar24_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.860638692 UTC

[section ""data" . sat_scchP_closure" {
     sat_scchP_closure:
         const GHC.Types.I#_con_info;
         const 128;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.861281361 UTC

[section ""data" . sat_scchQ_closure" {
     sat_scchQ_closure:
         const :_con_info;
         const sat_scchP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.862071494 UTC

[section ""data" . Text.Printf.$fPrintfArgChar22_closure" {
     Text.Printf.$fPrintfArgChar22_closure:
         const Text.Printf.$fPrintfArgChar22_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar22_entry() //  [R1]
         { info_tbl: [(cccXM,
                       label: Text.Printf.$fPrintfArgChar22_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccXM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccXN; else goto cccXO;
       cccXN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccXO: // global
           (_cccXJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccXJ::I64 == 0) goto cccXL; else goto cccXK;
       cccXL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccXK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccXJ::I64;
           R3 = sat_scchQ_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.863001706 UTC

[section ""data" . Text.Printf.$fPrintfArgChar21_closure" {
     Text.Printf.$fPrintfArgChar21_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar23_closure;
         const Text.Printf.$fPrintfArgChar22_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.863563298 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar20_bytes" {
     Text.Printf.$fPrintfArgChar20_bytes:
         I8[] [104]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.864252831 UTC

[section ""data" . Text.Printf.$fPrintfArgChar19_closure" {
     Text.Printf.$fPrintfArgChar19_closure:
         const Text.Printf.$fPrintfArgChar19_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar19_entry() //  [R1]
         { info_tbl: [(cccXV,
                       label: Text.Printf.$fPrintfArgChar19_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccXV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccXW; else goto cccXX;
       cccXW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccXX: // global
           (_cccXS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccXS::I64 == 0) goto cccXU; else goto cccXT;
       cccXU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccXT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccXS::I64;
           R2 = Text.Printf.$fPrintfArgChar20_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.865156166 UTC

[section ""data" . sat_scchR_closure" {
     sat_scchR_closure:
         const GHC.Types.I#_con_info;
         const 32768;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.866389569 UTC

[section ""data" . sat_scchS_closure" {
     sat_scchS_closure:
         const :_con_info;
         const sat_scchR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.867146946 UTC

[section ""data" . Text.Printf.$fPrintfArgChar18_closure" {
     Text.Printf.$fPrintfArgChar18_closure:
         const Text.Printf.$fPrintfArgChar18_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar18_entry() //  [R1]
         { info_tbl: [(cccY4,
                       label: Text.Printf.$fPrintfArgChar18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccY4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccY5; else goto cccY6;
       cccY5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccY6: // global
           (_cccY1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccY1::I64 == 0) goto cccY3; else goto cccY2;
       cccY3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccY2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccY1::I64;
           R3 = sat_scchS_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.868101351 UTC

[section ""data" . Text.Printf.$fPrintfArgChar17_closure" {
     Text.Printf.$fPrintfArgChar17_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar19_closure;
         const Text.Printf.$fPrintfArgChar18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.868701715 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar16_bytes" {
     Text.Printf.$fPrintfArgChar16_bytes:
         I8[] [108]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.869945991 UTC

[section ""data" . Text.Printf.$fPrintfArgChar15_closure" {
     Text.Printf.$fPrintfArgChar15_closure:
         const Text.Printf.$fPrintfArgChar15_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar15_entry() //  [R1]
         { info_tbl: [(cccYd,
                       label: Text.Printf.$fPrintfArgChar15_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccYd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccYe; else goto cccYf;
       cccYe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccYf: // global
           (_cccYa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccYa::I64 == 0) goto cccYc; else goto cccYb;
       cccYc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccYb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccYa::I64;
           R2 = Text.Printf.$fPrintfArgChar16_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.870833322 UTC

[section ""data" . sat_scchU_closure" {
     sat_scchU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.871351992 UTC

[section ""data" . sat_scchV_closure" {
     sat_scchV_closure:
         const :_con_info;
         const sat_scchU_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.871881998 UTC

[section ""data" . sat_scchT_closure" {
     sat_scchT_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.87245 UTC

[section ""data" . sat_scchW_closure" {
     sat_scchW_closure:
         const :_con_info;
         const sat_scchT_closure+1;
         const sat_scchV_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.873144268 UTC

[section ""data" . Text.Printf.$fPrintfArgChar14_closure" {
     Text.Printf.$fPrintfArgChar14_closure:
         const Text.Printf.$fPrintfArgChar14_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar14_entry() //  [R1]
         { info_tbl: [(cccYm,
                       label: Text.Printf.$fPrintfArgChar14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccYn; else goto cccYo;
       cccYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccYo: // global
           (_cccYj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccYj::I64 == 0) goto cccYl; else goto cccYk;
       cccYl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccYk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccYj::I64;
           R3 = sat_scchW_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.874073846 UTC

[section ""data" . Text.Printf.$fPrintfArgChar13_closure" {
     Text.Printf.$fPrintfArgChar13_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar15_closure;
         const Text.Printf.$fPrintfArgChar14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.874644592 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar12_bytes" {
     Text.Printf.$fPrintfArgChar12_bytes:
         I8[] [108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.875320208 UTC

[section ""data" . Text.Printf.$fPrintfArgChar11_closure" {
     Text.Printf.$fPrintfArgChar11_closure:
         const Text.Printf.$fPrintfArgChar11_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar11_entry() //  [R1]
         { info_tbl: [(cccYv,
                       label: Text.Printf.$fPrintfArgChar11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccYv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccYw; else goto cccYx;
       cccYw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccYx: // global
           (_cccYs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccYs::I64 == 0) goto cccYu; else goto cccYt;
       cccYu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccYt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccYs::I64;
           R2 = Text.Printf.$fPrintfArgChar12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.876172381 UTC

[section ""data" . sat_scchZ_closure" {
     sat_scchZ_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.876725353 UTC

[section ""data" . sat_scci0_closure" {
     sat_scci0_closure:
         const :_con_info;
         const sat_scchZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.877768238 UTC

[section ""data" . sat_scchY_closure" {
     sat_scchY_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.878313907 UTC

[section ""data" . sat_scci1_closure" {
     sat_scci1_closure:
         const :_con_info;
         const sat_scchY_closure+1;
         const sat_scci0_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.878871165 UTC

[section ""data" . sat_scchX_closure" {
     sat_scchX_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.879405863 UTC

[section ""data" . sat_scci2_closure" {
     sat_scci2_closure:
         const :_con_info;
         const sat_scchX_closure+1;
         const sat_scci1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.880159921 UTC

[section ""data" . Text.Printf.$fPrintfArgChar7_closure" {
     Text.Printf.$fPrintfArgChar7_closure:
         const Text.Printf.$fPrintfArgChar7_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar7_entry() //  [R1]
         { info_tbl: [(cccYE,
                       label: Text.Printf.$fPrintfArgChar7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccYE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccYF; else goto cccYG;
       cccYF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccYG: // global
           (_cccYB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccYB::I64 == 0) goto cccYD; else goto cccYC;
       cccYD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccYC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccYB::I64;
           R3 = sat_scci2_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.881094504 UTC

[section ""data" . Text.Printf.$fPrintfArgChar10_closure" {
     Text.Printf.$fPrintfArgChar10_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar11_closure;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.881690539 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar9_bytes" {
     Text.Printf.$fPrintfArgChar9_bytes:
         I8[] [76]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.882389239 UTC

[section ""data" . Text.Printf.$fPrintfArgChar8_closure" {
     Text.Printf.$fPrintfArgChar8_closure:
         const Text.Printf.$fPrintfArgChar8_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar8_entry() //  [R1]
         { info_tbl: [(cccYN,
                       label: Text.Printf.$fPrintfArgChar8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccYN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccYO; else goto cccYP;
       cccYO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccYP: // global
           (_cccYK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccYK::I64 == 0) goto cccYM; else goto cccYL;
       cccYM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccYL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccYK::I64;
           R2 = Text.Printf.$fPrintfArgChar9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.883265881 UTC

[section ""data" . Text.Printf.$fPrintfArgChar6_closure" {
     Text.Printf.$fPrintfArgChar6_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar8_closure;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.883855627 UTC

[section ""data" . Text.Printf.$fPrintfArgChar5_closure" {
     Text.Printf.$fPrintfArgChar5_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.884489379 UTC

[section ""data" . Text.Printf.$fPrintfArgChar4_closure" {
     Text.Printf.$fPrintfArgChar4_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar10_closure+1;
         const Text.Printf.$fPrintfArgChar5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.885067211 UTC

[section ""data" . Text.Printf.$fPrintfArgChar3_closure" {
     Text.Printf.$fPrintfArgChar3_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar13_closure+1;
         const Text.Printf.$fPrintfArgChar4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.885677995 UTC

[section ""data" . Text.Printf.$fPrintfArgChar2_closure" {
     Text.Printf.$fPrintfArgChar2_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar17_closure+1;
         const Text.Printf.$fPrintfArgChar3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.886255208 UTC

[section ""data" . Text.Printf.intModifierMap_closure" {
     Text.Printf.intModifierMap_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar21_closure+1;
         const Text.Printf.$fPrintfArgChar2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.886813735 UTC

[section ""cstring" . lvl7_rccc6_bytes" {
     lvl7_rccc6_bytes:
         I8[] [112,114,105,110,116,102,58,32,117,110,107,110,111,119,110,32,102,111,114,109,97,116,32,109,111,100,105,102,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.887598532 UTC

[section ""data" . Text.Printf.$fPrintfArgInt2_closure" {
     Text.Printf.$fPrintfArgInt2_closure:
         const Text.Printf.$fPrintfArgInt2_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgInt2_entry() //  [R1]
         { info_tbl: [(cccYY,
                       label: Text.Printf.$fPrintfArgInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccYY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cccYZ; else goto cccZ0;
       cccYZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccZ0: // global
           (_cccYT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cccYT::I64 == 0) goto cccYV; else goto cccYU;
       cccYV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cccYU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cccYT::I64;
           I64[Sp - 24] = block_cccYW_info;
           R2 = lvl7_rccc6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cccYW() //  [R1]
         { info_tbl: [(cccYW,
                       label: block_cccYW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccYW: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.889011383 UTC

[section ""data" . Text.Printf.$wfixupMods_closure" {
     Text.Printf.$wfixupMods_closure:
         const Text.Printf.$wfixupMods_info;
         const 0;
 },
 Text.Printf.$wfixupMods_entry() //  [R2, R3]
         { info_tbl: [(cccZf,
                       label: Text.Printf.$wfixupMods_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccZf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccZg; else goto cccZh;
       cccZg: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$wfixupMods_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cccZh: // global
           I64[Sp - 16] = block_cccZ8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uccZA; else goto cccZ9;
       uccZA: // global
           call _cccZ8(R1) args: 0, res: 0, upd: 0;
       cccZ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccZ8() //  [R1]
         { info_tbl: [(cccZ8,
                       label: block_cccZ8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccZ8: // global
           if (R1 & 7 == 1) goto cccZc; else goto cccZd;
       cccZc: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cccZd: // global
           I64[Sp + 8] = block_cccZn_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           Sp = Sp + 8;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cccZn() //  [R1]
         { info_tbl: [(cccZn,
                       label: block_cccZn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccZn: // global
           if (R1 & 7 == 1) goto cccZu; else goto cccZy;
       cccZu: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cccZy: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.890841559 UTC

[section ""data" . Text.Printf.fixupMods_closure" {
     Text.Printf.fixupMods_closure:
         const Text.Printf.fixupMods_info;
         const 0;
 },
 Text.Printf.fixupMods_entry() //  [R2, R3]
         { info_tbl: [(cccZI,
                       label: Text.Printf.fixupMods_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccZI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccZJ; else goto cccZK;
       cccZJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.fixupMods_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cccZK: // global
           I64[Sp - 16] = block_cccZF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uccZO; else goto cccZG;
       uccZO: // global
           call _cccZF(R1) args: 0, res: 0, upd: 0;
       cccZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccZF() //  [R1]
         { info_tbl: [(cccZF,
                       label: block_cccZF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccZF: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 47];
           Sp = Sp + 16;
           call Text.Printf.$wfixupMods_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.893864549 UTC

[section ""data" . Text.Printf.$wparseIntFormat_closure" {
     Text.Printf.$wparseIntFormat_closure:
         const Text.Printf.$wparseIntFormat_info;
         const 0;
 },
 go_sccim_entry() //  [R1, R2]
         { info_tbl: [(ccd05,
                       label: go_sccim_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd05: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccd06; else goto ccd07;
       ccd06: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccd07: // global
           I64[Sp - 24] = block_cccZY_info;
           _sccim::P64 = R1;
           _sccil::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sccil::P64;
           P64[Sp - 8] = _sccim::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucd1W; else goto cccZZ;
       ucd1W: // global
           call _cccZY(R1) args: 0, res: 0, upd: 0;
       cccZZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cccZY() //  [R1]
         { info_tbl: [(cccZY,
                       label: block_cccZY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccZY: // global
           if (R1 & 7 == 1) goto ucd1O; else goto ccd03;
       ucd1O: // global
           Sp = Sp + 24;
           call _ccd0x() args: 0, res: 0, upd: 0;
       ccd03: // global
           I64[Sp - 8] = block_ccd0d_info;
           _scciq::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scciq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucd1U; else goto ccd0f;
       ucd1U: // global
           call _ccd0d(R1) args: 0, res: 0, upd: 0;
       ccd0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd0d() //  [R1]
         { info_tbl: [(ccd0d,
                       label: block_ccd0d_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd0d: // global
           _scciq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccd0j_info;
           R2 = _scciq::P64;
           _sccis::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sccis::P64;
           Sp = Sp + 8;
           call go_sccim_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd0j() //  [R1]
         { info_tbl: [(ccd0j,
                       label: block_ccd0j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd0j: // global
           if (R1 & 7 == 1) goto ccd0r; else goto ccd15;
       ccd0r: // global
           _sccil::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccd0o_info;
           R4 = _sccil::P64;
           R3 = P64[Sp + 16];
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp + 8;
           call Data.OldList.stripPrefix_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
       ccd15: // global
           I64[Sp - 8] = block_ccd0U_info;
           _scciu::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _scciu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucd1X; else goto ccd0V;
       ucd1X: // global
           call _ccd0U(R1) args: 0, res: 0, upd: 0;
       ccd0V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd0o() //  [R1]
         { info_tbl: [(ccd0o,
                       label: block_ccd0o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd0o: // global
           if (R1 & 7 == 1) goto ucd1S; else goto ccd0C;
       ucd1S: // global
           Sp = Sp + 16;
           call _ccd0x() args: 0, res: 0, upd: 0;
       ccd0C: // global
           I64[Sp] = block_ccd0A_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucd1Y; else goto ccd0D;
       ucd1Y: // global
           call _ccd0A(R1) args: 0, res: 0, upd: 0;
       ccd0D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd0x() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd0x: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccd0A() //  [R1]
         { info_tbl: [(ccd0A,
                       label: block_ccd0A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd0A: // global
           if (R1 & 7 == 1) goto ucd1T; else goto ccd0O;
       ucd1T: // global
           Sp = Sp + 16;
           call _ccd1z() args: 0, res: 0, upd: 0;
       ccd0O: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccd0R; else goto ccd0Q;
       ccd0R: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccd0Q: // global
           _scciy::P64 = P64[R1 + 6];
           _scciz::P64 = P64[R1 + 14];
           I64[Hp - 40] = Text.Printf.FormatParse_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _scciy::P64;
           P64[Hp - 16] = _scciz::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccd0U() //  [R1]
         { info_tbl: [(ccd0U,
                       label: block_ccd0U_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd0U: // global
           I64[Sp] = block_ccd0Z_info;
           R3 = 0;
           R2 = P64[R1 + 7];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccd0Z() //  [R1]
         { info_tbl: [(ccd0Z,
                       label: block_ccd0Z_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd0Z: // global
           I64[Sp - 8] = block_ccd13_info;
           R3 = 0;
           R2 = P64[Sp + 24];
           I64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccd13() //  [R1]
         { info_tbl: [(ccd13,
                       label: block_ccd13_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd13: // global
           if (%MO_S_Lt_W64(I64[Sp + 8], R1)) goto ccd1h; else goto ucd1P;
       ccd1h: // global
           I64[Sp + 8] = block_ccd1f_info;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp + 8;
           call Data.OldList.stripPrefix_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
       ucd1P: // global
           Sp = Sp + 16;
           call _ccd1I() args: 0, res: 0, upd: 0;
     }
 },
 _ccd1f() //  [R1]
         { info_tbl: [(ccd1f,
                       label: block_ccd1f_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd1f: // global
           if (R1 & 7 == 1) goto ucd1Q; else goto ccd1s;
       ucd1Q: // global
           Sp = Sp + 8;
           call _ccd1I() args: 0, res: 0, upd: 0;
       ccd1s: // global
           I64[Sp + 16] = block_ccd1q_info;
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ucd22; else goto ccd1t;
       ucd22: // global
           call _ccd1q(R1) args: 0, res: 0, upd: 0;
       ccd1t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd1q() //  [R1]
         { info_tbl: [(ccd1q,
                       label: block_ccd1q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd1q: // global
           if (R1 & 7 == 1) goto ucd1R; else goto ccd1E;
       ucd1R: // global
           Sp = Sp + 16;
           call _ccd1z() args: 0, res: 0, upd: 0;
       ccd1E: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccd1H; else goto ccd1G;
       ccd1H: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccd1G: // global
           _scciN::P64 = P64[R1 + 6];
           _scciO::P64 = P64[R1 + 14];
           I64[Hp - 40] = Text.Printf.FormatParse_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _scciN::P64;
           P64[Hp - 16] = _scciO::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccd1z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd1z: // global
           R1 = Text.Printf.errorShortFormat_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccd1I() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd1I: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wparseIntFormat_entry() //  [R2]
         { info_tbl: [(ccd2b,
                       label: Text.Printf.$wparseIntFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd2b: // global
           _sccil::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccd2c; else goto ccd2d;
       ccd2d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccd2f; else goto ccd2e;
       ccd2f: // global
           HpAlloc = 16;
           goto ccd2c;
       ccd2c: // global
           R2 = _sccil::P64;
           R1 = Text.Printf.$wparseIntFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccd2e: // global
           I64[Hp - 8] = go_sccim_info;
           P64[Hp] = _sccil::P64;
           I64[Sp - 16] = block_ccd25_info;
           R2 = Text.Printf.intModifierMap_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sccil::P64;
           Sp = Sp - 16;
           call go_sccim_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd25() //  [R1]
         { info_tbl: [(ccd25,
                       label: block_ccd25_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd25: // global
           if (R1 & 7 == 1) goto ccd28; else goto ccd29;
       ccd28: // global
           _sccil::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccd2i_info;
           R1 = _sccil::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucd2C; else goto ccd2k;
       ucd2C: // global
           call _ccd2i(R1) args: 0, res: 0, upd: 0;
       ccd2k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccd29: // global
           R1 = P64[R1 + 6] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccd2i() //  [R1]
         { info_tbl: [(ccd2i,
                       label: block_ccd2i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd2i: // global
           if (R1 & 7 == 1) goto ccd2q; else goto ccd2u;
       ccd2q: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccd2u: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccd2x; else goto ccd2w;
       ccd2x: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccd2w: // global
           _scciS::P64 = P64[R1 + 6];
           _scciT::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _scciS::P64;
           P64[Hp] = _scciT::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.898519338 UTC

[section ""data" . Text.Printf.parseIntFormat_closure" {
     Text.Printf.parseIntFormat_closure:
         const Text.Printf.parseIntFormat_info;
         const 0;
 },
 Text.Printf.parseIntFormat_entry() //  [R3]
         { info_tbl: [(ccd2H,
                       label: Text.Printf.parseIntFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd2H: // global
           R2 = R3;
           call Text.Printf.$wparseIntFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.899270083 UTC

[section ""cstring" . lvl8_rccc7_bytes" {
     lvl8_rccc7_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.900016878 UTC

[section ""data" . lvl9_rccc8_closure" {
     lvl9_rccc8_closure:
         const lvl9_rccc8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rccc8_entry() //  [R1]
         { info_tbl: [(ccd2Q,
                       label: lvl9_rccc8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd2Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd2R; else goto ccd2S;
       ccd2R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd2S: // global
           (_ccd2N::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccd2N::I64 == 0) goto ccd2P; else goto ccd2O;
       ccd2P: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccd2O: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccd2N::I64;
           R2 = lvl8_rccc7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.901067653 UTC

[section ""data" . lvl10_rccc9_closure" {
     lvl10_rccc9_closure:
         const lvl10_rccc9_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_rccc9_entry() //  [R1]
         { info_tbl: [(ccd2Z,
                       label: lvl10_rccc9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd2Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd30; else goto ccd31;
       ccd30: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd31: // global
           (_ccd2W::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccd2W::I64 == 0) goto ccd2Y; else goto ccd2X;
       ccd2Y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccd2X: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccd2W::I64;
           R2 = Text.Printf.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.902146688 UTC

[section ""data" . lvl11_rccca_closure" {
     lvl11_rccca_closure:
         const lvl11_rccca_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rccca_entry() //  [R1]
         { info_tbl: [(ccd38,
                       label: lvl11_rccca_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd38: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd39; else goto ccd3a;
       ccd39: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd3a: // global
           (_ccd35::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccd35::I64 == 0) goto ccd37; else goto ccd36;
       ccd37: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccd36: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccd35::I64;
           R2 = Text.Printf.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.903020956 UTC

[section ""cstring" . lvl12_rcccb_bytes" {
     lvl12_rcccb_bytes:
         I8[] [46,47,84,101,120,116,47,80,114,105,110,116,102,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.903757198 UTC

[section ""data" . lvl13_rcccc_closure" {
     lvl13_rcccc_closure:
         const lvl13_rcccc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rcccc_entry() //  [R1]
         { info_tbl: [(ccd3h,
                       label: lvl13_rcccc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd3h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd3i; else goto ccd3j;
       ccd3i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd3j: // global
           (_ccd3e::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccd3e::I64 == 0) goto ccd3g; else goto ccd3f;
       ccd3g: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccd3f: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccd3e::I64;
           R2 = lvl12_rcccb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.904667959 UTC

[section ""data" . lvl14_rcccd_closure" {
     lvl14_rcccd_closure:
         const GHC.Types.I#_con_info;
         const 323;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.905274473 UTC

[section ""data" . lvl15_rccce_closure" {
     lvl15_rccce_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.906837154 UTC

[section ""data" . lvl16_rcccf_closure" {
     lvl16_rcccf_closure:
         const GHC.Types.I#_con_info;
         const 49;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.907442896 UTC

[section ""data" . lvl17_rcccg_closure" {
     lvl17_rcccg_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl10_rccc9_closure;
         const lvl11_rccca_closure;
         const lvl13_rcccc_closure;
         const lvl14_rcccd_closure+1;
         const lvl15_rccce_closure+1;
         const lvl14_rcccd_closure+1;
         const lvl16_rcccf_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.908032838 UTC

[section ""data" . lvl18_rccch_closure" {
     lvl18_rccch_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl9_rccc8_closure;
         const lvl17_rcccg_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.908750146 UTC

[section ""data" . Text.Printf.$fPrintfArgChar1_closure" {
     Text.Printf.$fPrintfArgChar1_closure:
         const Text.Printf.$fPrintfArgChar1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar1_entry() //  [R1]
         { info_tbl: [(ccd3q,
                       label: Text.Printf.$fPrintfArgChar1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd3q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd3r; else goto ccd3s;
       ccd3r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd3s: // global
           (_ccd3n::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccd3n::I64 == 0) goto ccd3p; else goto ccd3o;
       ccd3p: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccd3o: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccd3n::I64;
           R2 = lvl18_rccch_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.910041814 UTC

[section ""data" . Text.Printf.$fPrintfArgChar_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgChar_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgChar_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgChar_$cparseFormat_entry() //  [R3]
         { info_tbl: [(ccd3x,
                       label: Text.Printf.$fPrintfArgChar_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd3x: // global
           R2 = R3;
           call Text.Printf.$wparseIntFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.910773296 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble5_closure" {
     Text.Printf.$fPrintfArgDouble5_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.912773993 UTC

[section ""data" . integral_prec_rc8qj_closure" {
     integral_prec_rc8qj_closure:
         const integral_prec_rc8qj_info;
 },
 sat_sccjf_entry() //  [R1]
         { info_tbl: [(ccd4j,
                       label: sat_sccjf_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd4j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd4k; else goto ccd4l;
       ccd4k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd4l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sccjb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_sccjb_entry() //  [R1, R2]
         { info_tbl: [(ccd4p,
                       label: $wxs_sccjb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd4p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccd4t; else goto ccd4s;
       ccd4t: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccd4s: // global
           if (R2 == 1) goto ccd4o; else goto ccd4n;
       ccd4o: // global
           _sccja::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _sccja::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccd4n: // global
           I64[Hp - 48] = sat_sccjf_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Text.Printf.$fPrintfArgDouble5_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 integral_prec_rc8qj_entry() //  [R2, R3]
         { info_tbl: [(ccd4z,
                       label: integral_prec_rc8qj_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd4z: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccd4A; else goto ccd4B;
       ccd4A: // global
           R3 = R3;
           R2 = R2;
           R1 = integral_prec_rc8qj_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccd4B: // global
           I64[Sp - 16] = block_ccd3E_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucd5C; else goto ccd3F;
       ucd5C: // global
           call _ccd3E(R1) args: 0, res: 0, upd: 0;
       ccd3F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd3E() //  [R1]
         { info_tbl: [(ccd3E,
                       label: block_ccd3E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd3E: // global
           if (R1 & 7 == 1) goto ccd4w; else goto ccd4x;
       ccd4w: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccd4x: // global
           I64[Sp] = block_ccd3K_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucd5z; else goto ccd3L;
       ucd5z: // global
           call _ccd3K(R1) args: 0, res: 0, upd: 0;
       ccd3L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd3K() //  [R1]
         { info_tbl: [(ccd3K,
                       label: block_ccd3K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd3K: // global
           _sccj4::I64 = I64[R1 + 7];
           if (_sccj4::I64 == 0) goto ccd4T; else goto ucd5v;
       ccd4T: // global
           I64[Sp - 8] = block_ccd4S_info;
           R1 = P64[Sp + 8];
           I64[Sp] = _sccj4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucd5A; else goto ccd4U;
       ucd5A: // global
           call _ccd4S(R1) args: 0, res: 0, upd: 0;
       ccd4U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucd5v: // global
           I64[Sp] = _sccj4::I64;
           call _sccj5() args: 0, res: 0, upd: 0;
     }
 },
 _ccd4S() //  [R1]
         { info_tbl: [(ccd4S,
                       label: block_ccd4S_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd4S: // global
           if (R1 & 7 == 1) goto ucd5w; else goto ccd55;
       ucd5w: // global
           Sp = Sp + 8;
           call _sccj5() args: 0, res: 0, upd: 0;
       ccd55: // global
           I64[Sp - 8] = block_ccd53_info;
           _sccjj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccjj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucd5D; else goto ccd56;
       ucd5D: // global
           call _ccd53(R1) args: 0, res: 0, upd: 0;
       ccd56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd53() //  [R1]
         { info_tbl: [(ccd53,
                       label: block_ccd53_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd53: // global
           if (I64[R1 + 7] == 48) goto ccd5h; else goto ucd5x;
       ccd5h: // global
           _sccjj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccd5g_info;
           R1 = _sccjj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucd5F; else goto ccd5i;
       ucd5F: // global
           call _ccd5g(R1) args: 0, res: 0, upd: 0;
       ccd5i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucd5x: // global
           Sp = Sp + 16;
           call _sccj5() args: 0, res: 0, upd: 0;
     }
 },
 _ccd5g() //  [R1]
         { info_tbl: [(ccd5g,
                       label: block_ccd5g_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd5g: // global
           if (R1 & 7 == 1) goto ccd5o; else goto ucd5y;
       ccd5o: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ucd5y: // global
           Sp = Sp + 8;
           call _sccj5() args: 0, res: 0, upd: 0;
     }
 },
 _sccj5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccj5: // global
           I64[Sp - 8] = block_ccd3U_info;
           R3 = 0;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccd3U() //  [R1]
         { info_tbl: [(ccd3U,
                       label: block_ccd3U_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd3U: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccd4J; else goto ccd4I;
       ccd4J: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccd4I: // global
           _sccj0::P64 = P64[Sp + 16];
           _sccj8::I64 = I64[Sp + 8] - R1;
           if (%MO_S_Ge_W64(0, _sccj8::I64)) goto ccd4L; else goto ccd4M;
       ccd4L: // global
           Hp = Hp - 40;
           R1 = _sccj0::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccd4M: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Text.Printf.$fPrintfArgDouble5_closure+1;
           P64[Hp - 16] = _sccj0::P64;
           I64[Hp - 8] = $wxs_sccjb_info;
           P64[Hp] = Hp - 30;
           R2 = _sccj8::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call $wxs_sccjb_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.915929814 UTC

[section ""cstring" . lvl19_rccci_bytes" {
     lvl19_rccci_bytes:
         I8[] [84,101,120,116,47,80,114,105,110,116,102,46,104,115,58,55,49,52,58,55,45,51,57,124,40,34,34,44,32,115,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.916637276 UTC

[section ""data" . lvl20_rcccj_closure" {
     lvl20_rcccj_closure:
         const lvl20_rcccj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_rcccj_entry() //  [R1]
         { info_tbl: [(ccd5O,
                       label: lvl20_rcccj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd5O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd5P; else goto ccd5Q;
       ccd5P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd5Q: // global
           (_ccd5L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccd5L::I64 == 0) goto ccd5N; else goto ccd5M;
       ccd5N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccd5M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccd5L::I64;
           R2 = lvl19_rccci_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.917702109 UTC

[section ""data" . Text.Printf.formatChar2_closure" {
     Text.Printf.formatChar2_closure:
         const Text.Printf.formatChar2_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.formatChar2_entry() //  [R1]
         { info_tbl: [(ccd5X,
                       label: Text.Printf.formatChar2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd5X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd5Y; else goto ccd5Z;
       ccd5Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd5Z: // global
           (_ccd5U::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccd5U::I64 == 0) goto ccd5W; else goto ccd5V;
       ccd5W: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccd5V: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccd5U::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.918588422 UTC

[section ""data" . sat_sccjq_closure" {
     sat_sccjq_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.919169398 UTC

[section ""data" . sat_sccjr_closure" {
     sat_sccjr_closure:
         const :_con_info;
         const sat_sccjq_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.919919545 UTC

[section ""data" . lvl21_rccck_closure" {
     lvl21_rccck_closure:
         const lvl21_rccck_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_rccck_entry() //  [R1]
         { info_tbl: [(ccd66,
                       label: lvl21_rccck_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd66: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd67; else goto ccd68;
       ccd67: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd68: // global
           (_ccd63::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccd63::I64 == 0) goto ccd65; else goto ccd64;
       ccd65: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccd64: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccd63::I64;
           R3 = sat_sccjr_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.92415665 UTC

[section ""data" . $wfmtu_rcccl_closure" {
     $wfmtu_rcccl_closure:
         const $wfmtu_rcccl_info;
         const 0;
 },
 sat_sccjG_entry() //  [R1]
         { info_tbl: [(ccd6G,
                       label: sat_sccjG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd6G: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccd6H; else goto ccd6I;
       ccd6H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd6I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 24];
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = P64[R1 + 16];
           R3 = GHC.Show.$fShowInteger_closure;
           R2 = GHC.Real.$fIntegralInteger_closure;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 32, res: 0, upd: 24;
     }
 },
 sat_sccjL_entry() //  [R1]
         { info_tbl: [(ccd6Z,
                       label: sat_sccjL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd6Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd70; else goto ccd71;
       ccd70: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd71: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 fmtu'_sccjy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccd79,
                       label: fmtu'_sccjy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd79: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccd7a; else goto ucd8e;
       ccd7a: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ucd8e: // global
           P64[Sp - 32] = R1;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call _ccd6k() args: 0, res: 0, upd: 0;
     }
 },
 _ccd6k() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd6k: // global
           _sccjs::P64 = P64[P64[Sp] + 5];
           I64[Sp - 8] = block_ccd72_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sccjs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucd8l; else goto ccd73;
       ucd8l: // global
           call _ccd72(R1) args: 0, res: 0, upd: 0;
       ccd73: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd72() //  [R1]
         { info_tbl: [(ccd72,
                       label: block_ccd72_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd72: // global
           if (R1 & 7 == 1) goto ucd8f; else goto ccd77;
       ucd8f: // global
           Sp = Sp + 8;
           call _sccjC() args: 0, res: 0, upd: 0;
       ccd77: // global
           I64[Sp - 8] = block_ccd7L_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = P64[Sp + 32];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccd7L() //  [R1]
         { info_tbl: [(ccd7L,
                       label: block_ccd7L_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd7L: // global
           if (R1 == 1) goto ccd85; else goto ucd8g;
       ccd85: // global
           _sccjN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccd7V_info;
           R3 = _sccjN::P64;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ucd8g: // global
           Sp = Sp + 16;
           call _sccjC() args: 0, res: 0, upd: 0;
     }
 },
 _ccd7V() //  [R1]
         { info_tbl: [(ccd7V,
                       label: block_ccd7V_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd7V: // global
           I64[Sp] = block_ccd7Z_info;
           R2 = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccd7Z() //  [R1]
         { info_tbl: [(ccd7Z,
                       label: block_ccd7Z_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd7Z: // global
           I64[Sp] = block_ccd83_info;
           R3 = P64[Sp + 32];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccd83() //  [R1]
         { info_tbl: [(ccd83,
                       label: block_ccd83_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd83: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = GHC.Base.Nothing_closure+1;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ccd6k() args: 0, res: 0, upd: 0;
     }
 },
 _sccjC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccjC: // global
           I64[Sp - 8] = block_ccd6s_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucd8t; else goto ccd6t;
       ucd8t: // global
           call _ccd6s(R1) args: 0, res: 0, upd: 0;
       ccd6t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd6s() //  [R1]
         { info_tbl: [(ccd6s,
                       label: block_ccd6s_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd6s: // global
           _sccjB::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccd7f; else goto ccd7q;
       ccd7f: // global
           I64[Sp + 16] = block_ccd6x_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sccjB::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ccd7q: // global
           I64[Sp] = block_ccd6L_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sccjB::P64;
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccd6x() //  [R1]
         { info_tbl: [(ccd6x,
                       label: block_ccd6x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd6x: // global
           if (R1 == 1) goto ccd7l; else goto ucd8k;
       ccd7l: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccd7o; else goto ccd7n;
       ccd7o: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccd7n: // global
           I64[Hp - 40] = sat_sccjG_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ucd8k: // global
           Sp = Sp + 24;
           call _ccd7A() args: 0, res: 0, upd: 0;
     }
 },
 _ccd6L() //  [R1]
         { info_tbl: [(ccd6L,
                       label: block_ccd6L_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd6L: // global
           if (R1 == 1) goto ccd7w; else goto ucd8i;
       ccd7w: // global
           I64[Sp + 16] = block_ccd6Q_info;
           R4 = P64[Sp + 32];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call fmtu'_sccjy_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ucd8i: // global
           Sp = Sp + 40;
           call _ccd7A() args: 0, res: 0, upd: 0;
     }
 },
 _ccd6Q() //  [R1]
         { info_tbl: [(ccd6Q,
                       label: block_ccd6Q_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd6Q: // global
           if (R1 & 7 == 1) goto ucd8j; else goto ccd7C;
       ucd8j: // global
           Sp = Sp + 24;
           call _ccd7A() args: 0, res: 0, upd: 0;
       ccd7C: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccd7F; else goto ccd7E;
       ccd7F: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccd7E: // global
           _sccjK::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sccjL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sccjK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccd7A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd7A: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 s_sccjW_entry() //  [R1]
         { info_tbl: [(ccd8J,
                       label: s_sccjW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd8J: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccd8K; else goto ccd8L;
       ccd8K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd8L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccd8A_info;
           R6 = P64[R1 + 40];
           R5 = P64[R1 + 32];
           R4 = P64[R1 + 24];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccd8A() //  [R1, R2]
         { info_tbl: [(ccd8A,
                       label: block_ccd8A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd8A: // global
           I64[Sp - 8] = block_ccd8C_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucd8T; else goto ccd8D;
       ucd8T: // global
           call _ccd8C(R1) args: 0, res: 0, upd: 0;
       ccd8D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccd8C() //  [R1]
         { info_tbl: [(ccd8C,
                       label: block_ccd8C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd8C: // global
           if (R1 & 7 == 1) goto ccd8G; else goto ccd8H;
       ccd8G: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccd8H: // global
           R1 = lvl20_rcccj_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wfmtu_rcccl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccd8Y,
                       label: $wfmtu_rcccl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd8Y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccd8Z; else goto ccd90;
       ccd8Z: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wfmtu_rcccl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccd90: // global
           I64[Sp - 40] = block_ccd6d_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucdal; else goto ccd6e;
       ucdal: // global
           call _ccd6d(R1) args: 0, res: 0, upd: 0;
       ccd6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd6d() //  [R1]
         { info_tbl: [(ccd6d,
                       label: block_ccd6d_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd6d: // global
           _sccjs::P64 = P64[Sp + 8];
           _sccju::P64 = P64[Sp + 16];
           _sccjv::P64 = P64[Sp + 24];
           _sccjw::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccd8V; else goto ccd8W;
       ccd8V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccd94; else goto ccd93;
       ccd94: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccd93: // global
           I64[Hp - 8] = fmtu'_sccjy_info;
           P64[Hp] = _sccjs::P64;
           I64[Sp + 32] = block_ccd91_info;
           R4 = _sccjw::P64;
           R3 = _sccjv::P64;
           R2 = _sccju::P64;
           R1 = Hp - 5;
           Sp = Sp + 32;
           call fmtu'_sccjy_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ccd8W: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccd9i; else goto ccd9h;
       ccd9i: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccd9h: // global
           _sccjV::P64 = P64[R1 + 6];
           I64[Hp - 40] = s_sccjW_info;
           P64[Hp - 24] = _sccjs::P64;
           P64[Hp - 16] = _sccju::P64;
           P64[Hp - 8] = _sccjv::P64;
           P64[Hp] = _sccjw::P64;
           I64[Sp + 24] = block_ccd9f_info;
           R1 = _sccjV::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ucdak; else goto ccd9j;
       ucdak: // global
           call _ccd9f(R1) args: 0, res: 0, upd: 0;
       ccd9j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd91() //  [R1]
         { info_tbl: [(ccd91,
                       label: block_ccd91_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd91: // global
           if (R1 & 7 == 1) goto ccd9a; else goto ccd9e;
       ccd9a: // global
           R1 = Text.Printf.errorBadArgument_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccd9e: // global
           R2 = P64[R1 + 6];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccd9f() //  [R1]
         { info_tbl: [(ccd9f,
                       label: block_ccd9f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd9f: // global
           if (R1 & 7 == 1) goto ccd9p; else goto ccd9u;
       ccd9p: // global
           R2 = P64[Sp + 8];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccd9u: // global
           I64[Sp - 16] = block_ccd9s_info;
           _scck4::P64 = R1;
           _scck6::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scck6::P64;
           P64[Sp] = _scck4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdam; else goto ccd9v;
       ucdam: // global
           call _ccd9s(R1) args: 0, res: 0, upd: 0;
       ccd9v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd9s() //  [R1]
         { info_tbl: [(ccd9s,
                       label: block_ccd9s_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd9s: // global
           if (I64[R1 + 7] == 48) goto ccd9G; else goto ucdai;
       ccd9G: // global
           _scck6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccd9F_info;
           R1 = _scck6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucdan; else goto ccd9H;
       ucdan: // global
           call _ccd9F(R1) args: 0, res: 0, upd: 0;
       ccd9H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucdai: // global
           Sp = Sp + 16;
           call _ccdad() args: 0, res: 0, upd: 0;
     }
 },
 _ccd9F() //  [R1]
         { info_tbl: [(ccd9F,
                       label: block_ccd9F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd9F: // global
           if (R1 & 7 == 1) goto ccd9O; else goto ucdaj;
       ccd9O: // global
           I64[Sp] = block_ccd9L_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ucdap; else goto ccd9P;
       ucdap: // global
           call _ccd9L(R1) args: 0, res: 0, upd: 0;
       ccd9P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucdaj: // global
           Sp = Sp + 8;
           call _ccdad() args: 0, res: 0, upd: 0;
     }
 },
 _ccd9L() //  [R1]
         { info_tbl: [(ccd9L,
                       label: block_ccd9L_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd9L: // global
           if (R1 & 7 == 1) goto ccd9V; else goto ccda0;
       ccd9V: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccda0: // global
           I64[Sp] = block_ccd9Y_info;
           _scckb::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _scckb::P64;
           if (R1 & 7 != 0) goto ucdar; else goto ccda1;
       ucdar: // global
           call _ccd9Y(R1) args: 0, res: 0, upd: 0;
       ccda1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccd9Y() //  [R1]
         { info_tbl: [(ccd9Y,
                       label: block_ccd9Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd9Y: // global
           _scckb::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 48) goto ccda9; else goto ccda8;
       ccda9: // global
           R2 = _scckb::P64;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccda8: // global
           R2 = _scckb::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccdad() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdad: // global
           R2 = P64[Sp + 8];
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.932168004 UTC

[section ""data" . $wfmti_rcccm_closure" {
     $wfmti_rcccm_closure:
         const $wfmti_rcccm_info;
         const 0;
 },
 sat_scckq_entry() //  [R1]
         { info_tbl: [(ccdaH,
                       label: sat_scckq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdaH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdaI; else goto ccdaJ;
       ccdaI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdaJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccdaE_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdaE() //  [R1, R2]
         { info_tbl: [(ccdaE,
                       label: block_ccdaE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdaE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdaM; else goto ccdaL;
       ccdaM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccdaL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 14;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scckw_entry() //  [R1]
         { info_tbl: [(ccdaV,
                       label: sat_scckw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdaV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdb1; else goto ccdb2;
       ccdb1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdb2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccdaT_info;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdaT() //  [R1]
         { info_tbl: [(ccdaT,
                       label: block_ccdaT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdaT: // global
           I64[Sp] = block_ccdaY_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdaY() //  [R1, R2]
         { info_tbl: [(ccdaY,
                       label: block_ccdaY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdaY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdb6; else goto ccdb5;
       ccdb6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccdb5: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 14;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdbj_srtd" {
     ucdbj_srtd:
         const SccKB_srt+104;
         const 33;
         const 6509559809;
 },
 $wfmti_rcccm_entry() //  [R2, R3]
         { info_tbl: [(ccdba,
                       label: $wfmti_rcccm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdba: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccdbb; else goto ccdbc;
       ccdbb: // global
           R3 = R3;
           R2 = R2;
           R1 = $wfmti_rcccm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdbc: // global
           I64[Sp - 24] = block_ccdaw_info;
           _scckk::P64 = R3;
           R3 = Text.Printf.formatChar2_closure;
           _scckj::P64 = R2;
           R2 = _scckk::P64;
           P64[Sp - 16] = _scckj::P64;
           P64[Sp - 8] = _scckk::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdaw() //  [R1]
         { info_tbl: [(ccdaw,
                       label: block_ccdaw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdaw: // global
           _scckj::P64 = P64[Sp + 8];
           _scckk::P64 = P64[Sp + 16];
           if (R1 == 1) goto ccdb9; else goto ccdb8;
       ccdb9: // global
           Hp = Hp + 32;
           _scckl::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccdbi; else goto ccdbh;
       ccdbh: // global
           I64[Hp - 24] = sat_scckw_info;
           P64[Hp - 8] = _scckj::P64;
           P64[Hp] = _scckk::P64;
           R2 = Hp - 24;
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccdb8: // global
           Hp = Hp + 32;
           _scckl::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccdbi; else goto ccdbe;
       ccdbi: // global
           HpAlloc = 32;
           R1 = _scckl::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccdbe: // global
           I64[Hp - 24] = sat_scckq_info;
           P64[Hp - 8] = _scckj::P64;
           P64[Hp] = _scckk::P64;
           R2 = Hp - 24;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.934883409 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble6_closure" {
     Text.Printf.$fPrintfArgDouble6_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.938351716 UTC

[section ""data" . Text.Printf.$wadjust_closure" {
     Text.Printf.$wadjust_closure:
         const Text.Printf.$wadjust_info;
 },
 x1_scckM_entry() //  [R1]
         { info_tbl: [(ccdca,
                       label: x1_scckM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdca: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccdcb; else goto ccdcc;
       ccdcb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdcc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccdc3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucdcA; else goto ccdc4;
       ucdcA: // global
           call _ccdc3(R1) args: 0, res: 0, upd: 0;
       ccdc4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdc3() //  [R1]
         { info_tbl: [(ccdc3,
                       label: block_ccdc3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdc3: // global
           if (R1 & 7 == 1) goto ucdcw; else goto ccdc8;
       ucdcw: // global
           Sp = Sp + 8;
           call _ccdcq() args: 0, res: 0, upd: 0;
       ccdc8: // global
           I64[Sp] = block_ccdci_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucdcy; else goto ccdck;
       ucdcy: // global
           call _ccdci(R1) args: 0, res: 0, upd: 0;
       ccdck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdci() //  [R1]
         { info_tbl: [(ccdci,
                       label: block_ccdci_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdci: // global
           if (R1 & 7 == 1) goto ucdcx; else goto ccdcu;
       ucdcx: // global
           Sp = Sp + 8;
           call _ccdcq() args: 0, res: 0, upd: 0;
       ccdcu: // global
           R1 = Text.Printf.$fPrintfArgDouble5_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccdcq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdcq: // global
           R1 = Text.Printf.$fPrintfArgDouble6_closure+1;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scckV_entry() //  [R1]
         { info_tbl: [(ccdcQ,
                       label: sat_scckV_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdcQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdcR; else goto ccdcS;
       ccdcR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdcS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_scckR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_scckR_entry() //  [R1, R2]
         { info_tbl: [(ccdcW,
                       label: $wxs_scckR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdcW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccdd0; else goto ccdcZ;
       ccdd0: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccdcZ: // global
           if (R2 == 1) goto ccdcV; else goto ccdcU;
       ccdcV: // global
           _scckQ::P64 = P64[R1 + 15];
           Hp = Hp - 56;
           R1 = _scckQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdcU: // global
           _scckM::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scckV_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _scckM::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 fill_scckB_entry() //  [R1]
         { info_tbl: [(ccdd6,
                       label: fill_scckB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdd6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdd7; else goto ccdd8;
       ccdd7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdd8: // global
           I64[Sp - 32] = block_ccdbs_info;
           _sccky::P64 = P64[R1 + 24];
           _scckz::P64 = P64[R1 + 32];
           _scckA::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccky::P64;
           P64[Sp - 16] = _scckz::P64;
           P64[Sp - 8] = _scckA::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucddo; else goto ccdbt;
       ucddo: // global
           call _ccdbs(R1) args: 0, res: 0, upd: 0;
       ccdbt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdbs() //  [R1]
         { info_tbl: [(ccdbs,
                       label: block_ccdbs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdbs: // global
           if (R1 & 7 == 1) goto ccdd3; else goto ccdd4;
       ccdd3: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdd4: // global
           I64[Sp] = block_ccdby_info;
           R3 = 0;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdby() //  [R1]
         { info_tbl: [(ccdby,
                       label: block_ccdby_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdby: // global
           I64[Sp] = block_ccdbC_info;
           R3 = 0;
           R2 = P64[Sp + 24];
           I64[Sp + 24] = R1;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdbC() //  [R1]
         { info_tbl: [(ccdbC,
                       label: block_ccdbC_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdbC: // global
           I64[Sp] = block_ccdbG_info;
           _scckF::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _scckF::I64;
           if (R1 & 7 != 0) goto ucddn; else goto ccdbH;
       ucddn: // global
           call _ccdbG(R1) args: 0, res: 0, upd: 0;
       ccdbH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdbG() //  [R1]
         { info_tbl: [(ccdbG,
                       label: block_ccdbG_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdbG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccddg; else goto ccddf;
       ccddg: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccddf: // global
           _scckH::I64 = I64[R1 + 7];
           _scckI::I64 = I64[Sp + 24] + I64[Sp + 16];
           if (%MO_S_Ge_W64(_scckI::I64,
                            _scckH::I64)) goto ccddk; else goto ccddm;
       ccddm: // global
           _scckK::I64 = _scckH::I64 - _scckI::I64;
           if (%MO_S_Ge_W64(0, _scckK::I64)) goto ccddk; else goto ccddl;
       ccddk: // global
           Hp = Hp - 72;
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccddl: // global
           I64[Hp - 64] = x1_scckM_info;
           P64[Hp - 48] = P64[Sp + 8];
           I64[Hp - 40] = :_con_info;
           _ccdbZ::P64 = Hp - 64;
           P64[Hp - 32] = _ccdbZ::P64;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = $wxs_scckR_info;
           P64[Hp - 8] = _ccdbZ::P64;
           P64[Hp] = Hp - 38;
           R2 = _scckK::I64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call $wxs_scckR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scckY_entry() //  [R1]
         { info_tbl: [(ccddD,
                       label: sat_scckY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccddD: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccl1_entry() //  [R1]
         { info_tbl: [(ccddR,
                       label: sat_sccl1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccddR: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccl2_entry() //  [R1]
         { info_tbl: [(ccde0,
                       label: sat_sccl2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccde0: // global
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccl6_entry() //  [R1]
         { info_tbl: [(ccdei,
                       label: sat_sccl6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdei: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wadjust_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccdep,
                       label: Text.Printf.$wadjust_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdep: // global
           _scckA::P64 = R5;
           _scckz::P64 = R4;
           _sccky::P64 = R3;
           _scckx::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto ccdeq; else goto ccder;
       ccder: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdet; else goto ccdes;
       ccdet: // global
           HpAlloc = 48;
           goto ccdeq;
       ccdeq: // global
           R5 = _scckA::P64;
           R4 = _scckz::P64;
           R3 = _sccky::P64;
           R2 = _scckx::P64;
           R1 = Text.Printf.$wadjust_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdes: // global
           I64[Hp - 40] = fill_scckB_info;
           P64[Hp - 24] = _scckx::P64;
           P64[Hp - 16] = _sccky::P64;
           P64[Hp - 8] = _scckz::P64;
           P64[Hp] = _scckA::P64;
           I64[Sp - 40] = block_ccde3_info;
           R1 = _sccky::P64;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = _sccky::P64;
           P64[Sp - 16] = _scckz::P64;
           P64[Sp - 8] = _scckA::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucdf6; else goto ccde4;
       ucdf6: // global
           call _ccde3(R1) args: 0, res: 0, upd: 0;
       ccde4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccde3() //  [R1]
         { info_tbl: [(ccde3,
                       label: block_ccde3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccde3: // global
           if (R1 & 7 == 1) goto ucdf0; else goto ccden;
       ucdf0: // global
           Sp = Sp + 8;
           call _scckW() args: 0, res: 0, upd: 0;
       ccden: // global
           I64[Sp] = block_ccde9_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucdf3; else goto ccdea;
       ucdf3: // global
           call _ccde9(R1) args: 0, res: 0, upd: 0;
       ccdea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccde9() //  [R1]
         { info_tbl: [(ccde9,
                       label: block_ccde9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccde9: // global
           if (R1 & 7 == 1) goto ccdeP; else goto ucdf1;
       ccdeP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccdeS; else goto ccdeR;
       ccdeS: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdeR: // global
           I64[Hp - 24] = sat_sccl6_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ucdf1: // global
           Sp = Sp + 8;
           call _scckW() args: 0, res: 0, upd: 0;
     }
 },
 _scckW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scckW: // global
           I64[Sp - 8] = block_ccddu_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdf7; else goto ccddv;
       ucdf7: // global
           call _ccddu(R1) args: 0, res: 0, upd: 0;
       ccddv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccddu() //  [R1]
         { info_tbl: [(ccddu,
                       label: block_ccddu_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccddu: // global
           if (R1 & 7 == 1) goto ccdew; else goto ccdeB;
       ccdew: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccdez; else goto ccdey;
       ccdez: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdey: // global
           I64[Hp - 24] = sat_scckY_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccdeB: // global
           I64[Sp] = block_ccddI_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucdf2; else goto ccddJ;
       ucdf2: // global
           call _ccddI(R1) args: 0, res: 0, upd: 0;
       ccddJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccddI() //  [R1]
         { info_tbl: [(ccddI,
                       label: block_ccddI_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccddI: // global
           _ccdbo::P64 = P64[Sp + 8];
           _scckz::P64 = P64[Sp + 24];
           _scckA::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccdeD; else goto ccdeH;
       ccdeD: // global
           Hp = Hp + 32;
           _sccl0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccdeK; else goto ccdeF;
       ccdeF: // global
           I64[Hp - 24] = sat_sccl1_info;
           P64[Hp - 8] = _scckz::P64;
           P64[Hp] = _scckA::P64;
           R3 = Hp - 24;
           R2 = _ccdbo::P64;
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccdeH: // global
           Hp = Hp + 32;
           _sccl0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccdeK; else goto ccdeJ;
       ccdeK: // global
           HpAlloc = 32;
           R1 = _sccl0::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdeJ: // global
           I64[Hp - 24] = sat_sccl2_info;
           P64[Hp - 8] = _scckA::P64;
           P64[Hp] = _ccdbo::P64;
           R3 = Hp - 24;
           R2 = _scckz::P64;
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.944092034 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble4_bytes" {
     Text.Printf.$fPrintfArgDouble4_bytes:
         I8[] [43]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.944853115 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble3_closure" {
     Text.Printf.$fPrintfArgDouble3_closure:
         const Text.Printf.$fPrintfArgDouble3_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble3_entry() //  [R1]
         { info_tbl: [(ccdfe,
                       label: Text.Printf.$fPrintfArgDouble3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdfe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdff; else goto ccdfg;
       ccdff: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdfg: // global
           (_ccdfb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdfb::I64 == 0) goto ccdfd; else goto ccdfc;
       ccdfd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdfc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdfb::I64;
           R2 = Text.Printf.$fPrintfArgDouble4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.945817119 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble2_bytes" {
     Text.Printf.$fPrintfArgDouble2_bytes:
         I8[] [32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.946542149 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble1_closure" {
     Text.Printf.$fPrintfArgDouble1_closure:
         const Text.Printf.$fPrintfArgDouble1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble1_entry() //  [R1]
         { info_tbl: [(ccdfn,
                       label: Text.Printf.$fPrintfArgDouble1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdfn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdfo; else goto ccdfp;
       ccdfo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdfp: // global
           (_ccdfk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdfk::I64 == 0) goto ccdfm; else goto ccdfl;
       ccdfm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdfl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdfk::I64;
           R2 = Text.Printf.$fPrintfArgDouble2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.948134503 UTC

[section ""data" . Text.Printf.$wadjustSigned_closure" {
     Text.Printf.$wadjustSigned_closure:
         const Text.Printf.$wadjustSigned_info;
         const 0;
 },
 Text.Printf.$wadjustSigned_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdfB,
                       label: Text.Printf.$wadjustSigned_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdfB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccdfC; else goto ccdfD;
       ccdfC: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$wadjustSigned_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdfD: // global
           I64[Sp - 40] = block_ccdfu_info;
           R1 = R4;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucdgo; else goto ccdfv;
       ucdgo: // global
           call _ccdfu(R1) args: 0, res: 0, upd: 0;
       ccdfv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdfu() //  [R1]
         { info_tbl: [(ccdfu,
                       label: block_ccdfu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdfu: // global
           if (R1 & 7 == 1) goto ccdfy; else goto ccdfz;
       ccdfy: // global
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       ccdfz: // global
           I64[Sp] = block_ccdfJ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucdgn; else goto ccdfL;
       ucdgn: // global
           call _ccdfJ(R1) args: 0, res: 0, upd: 0;
       ccdfL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdfJ() //  [R1]
         { info_tbl: [(ccdfJ,
                       label: block_ccdfJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdfJ: // global
           _sccla::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccdfS; else goto ccdg8;
       ccdfS: // global
           I64[Sp] = block_ccdfP_info;
           R1 = _sccla::P64;
           if (R1 & 7 != 0) goto ucdgp; else goto ccdfT;
       ucdgp: // global
           call _ccdfP(R1) args: 0, res: 0, upd: 0;
       ccdfT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccdg8: // global
           I64[Sp] = block_ccdg6_info;
           R1 = _sccla::P64;
           if (R1 & 7 != 0) goto ucdgq; else goto ccdg9;
       ucdgq: // global
           call _ccdg6(R1) args: 0, res: 0, upd: 0;
       ccdg9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdfP() //  [R1]
         { info_tbl: [(ccdfP,
                       label: block_ccdfP_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdfP: // global
           _sccl7::P64 = P64[Sp + 8];
           _sccl8::P64 = P64[Sp + 16];
           _scclb::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccdfZ; else goto ccdg3;
       ccdfZ: // global
           R5 = _scclb::P64;
           R4 = Text.Printf.$fPrintfArgDouble3_closure;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       ccdg3: // global
           R5 = _scclb::P64;
           R4 = R1;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccdg6() //  [R1]
         { info_tbl: [(ccdg6,
                       label: block_ccdg6_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdg6: // global
           _sccl7::P64 = P64[Sp + 8];
           _sccl8::P64 = P64[Sp + 16];
           _scclb::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccdgf; else goto ccdgj;
       ccdgf: // global
           R5 = _scclb::P64;
           R4 = Text.Printf.$fPrintfArgDouble1_closure;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       ccdgj: // global
           R5 = _scclb::P64;
           R4 = R1;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.952637033 UTC

[section ""data" . Text.Printf.$w$sformatRealFloat_closure" {
     Text.Printf.$w$sformatRealFloat_closure:
         const Text.Printf.$w$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$w$sformatRealFloat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdgs: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdi9_srtd" {
     ucdi9_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclw_entry() //  [R1]
         { info_tbl: [(ccdgF,
                       label: sat_scclw_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdgF: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdgG; else goto ccdgH;
       ccdgG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdgH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdgD_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 69;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdgD() //  [R1, R2]
         { info_tbl: [(ccdgD,
                       label: block_ccdgD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdgD: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdia_srtd" {
     ucdia_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclA_entry() //  [R1]
         { info_tbl: [(ccdgQ,
                       label: sat_scclA_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdgQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdgR; else goto ccdgS;
       ccdgR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdgS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdgO_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 70;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdgO() //  [R1, R2]
         { info_tbl: [(ccdgO,
                       label: block_ccdgO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdgO: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdib_srtd" {
     ucdib_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclE_entry() //  [R1]
         { info_tbl: [(ccdh1,
                       label: sat_scclE_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdh1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdh2; else goto ccdh3;
       ccdh2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdh3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdgZ_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 71;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdgZ() //  [R1, R2]
         { info_tbl: [(ccdgZ,
                       label: block_ccdgZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdgZ: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdic_srtd" {
     ucdic_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclI_entry() //  [R1]
         { info_tbl: [(ccdhc,
                       label: sat_scclI_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdhc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdhd; else goto ccdhe;
       ccdhd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdhe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdha_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 101;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdha() //  [R1, R2]
         { info_tbl: [(ccdha,
                       label: block_ccdha_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdha: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdid_srtd" {
     ucdid_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclM_entry() //  [R1]
         { info_tbl: [(ccdhn,
                       label: sat_scclM_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdhn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdho; else goto ccdhp;
       ccdho: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdhp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdhl_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 102;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdhl() //  [R1, R2]
         { info_tbl: [(ccdhl,
                       label: block_ccdhl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdhl: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdie_srtd" {
     ucdie_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclQ_entry() //  [R1]
         { info_tbl: [(ccdhy,
                       label: sat_scclQ_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdhy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdhz; else goto ccdhA;
       ccdhz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdhA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdhw_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdhw() //  [R1, R2]
         { info_tbl: [(ccdhw,
                       label: block_ccdhw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdhw: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdif_srtd" {
     ucdif_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclU_entry() //  [R1]
         { info_tbl: [(ccdhJ,
                       label: sat_scclU_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdhJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdhK; else goto ccdhL;
       ccdhK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdhL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdhH_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdhH() //  [R1, R2]
         { info_tbl: [(ccdhH,
                       label: block_ccdhH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdhH: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdig_srtd" {
     ucdig_srtd:
         const SccKB_srt+32;
         const 46;
         const 39582418600065;
 },
 Text.Printf.$w$sformatRealFloat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdhW,
                       label: Text.Printf.$w$sformatRealFloat_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdhW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccdi0; else goto ccdhZ;
       ccdi0: // global
           HpAlloc = 64;
           R1 = Text.Printf.$w$sformatRealFloat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ccdhZ: // global
           _scclq::P64 = P64[Sp];
           _sccls::I64 = I64[Sp + 8];
           if (_sccls::I64 < 101) goto ucdi1; else goto ucdi5;
       ucdi1: // global
           if (_sccls::I64 < 71) goto ucdi2; else goto ucdi4;
       ucdi2: // global
           if (_sccls::I64 < 70) goto ucdi3; else goto ccdhQ;
       ucdi3: // global
           if (_sccls::I64 < 69) goto ccdhO; else goto ccdhP;
       ccdhP: // global
           I64[Hp - 56] = sat_scclw_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdhQ: // global
           I64[Hp - 56] = sat_scclA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdi4: // global
           if (_sccls::I64 >= 72) goto ccdhO; else goto ccdhR;
       ccdhR: // global
           I64[Hp - 56] = sat_scclE_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdi5: // global
           if (_sccls::I64 < 103) goto ucdi6; else goto ucdi7;
       ucdi6: // global
           if (_sccls::I64 < 102) goto ccdhS; else goto ccdhT;
       ccdhS: // global
           I64[Hp - 56] = sat_scclI_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdhT: // global
           I64[Hp - 56] = sat_scclM_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdi7: // global
           if (_sccls::I64 < 104) goto ccdhU; else goto ucdi8;
       ccdhU: // global
           I64[Hp - 56] = sat_scclQ_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdi8: // global
           if (_sccls::I64 != 118) goto ccdhO; else goto ccdhV;
       ccdhO: // global
           Hp = Hp - 64;
           R2 = _sccls::I64;
           Sp = Sp + 16;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       ccdhV: // global
           I64[Hp - 56] = sat_scclU_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.959825145 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure" {
     Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure:
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble_$sformatRealFloat_entry() //  [R2,
                                                              R3]
         { info_tbl: [(ccdio,
                       label: Text.Printf.$fPrintfArgDouble_$sformatRealFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdio: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccdis; else goto ccdit;
       ccdis: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdit: // global
           I64[Sp - 16] = block_ccdil_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdiB; else goto ccdim;
       ucdiB: // global
           call _ccdil(R1) args: 0, res: 0, upd: 0;
       ccdim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdil() //  [R1]
         { info_tbl: [(ccdil,
                       label: block_ccdil_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdil: // global
           I64[Sp - 40] = block_ccdir_info;
           _scclY::P64 = P64[R1 + 7];
           _scclZ::P64 = P64[R1 + 15];
           _sccm0::P64 = P64[R1 + 23];
           _sccm1::P64 = P64[R1 + 31];
           _sccm2::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _scclZ::P64;
           P64[Sp - 24] = _sccm0::P64;
           P64[Sp - 16] = _sccm1::P64;
           P64[Sp - 8] = _sccm2::P64;
           P64[Sp] = _scclY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucdiA; else goto ccdiv;
       ucdiA: // global
           call _ccdir(R1) args: 0, res: 0, upd: 0;
       ccdiv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdir() //  [R1]
         { info_tbl: [(ccdir,
                       label: block_ccdir_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdir: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 32];
           I64[Sp + 48] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.963867409 UTC

[section ""data" . Text.Printf.$w$sformatRealFloat1_closure" {
     Text.Printf.$w$sformatRealFloat1_closure:
         const Text.Printf.$w$sformatRealFloat1_info;
         const 0;
 },
 Text.Printf.$w$sformatRealFloat1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdiD: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sccmi_entry() //  [R1]
         { info_tbl: [(ccdiQ,
                       label: sat_sccmi_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdiQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdiR; else goto ccdiS;
       ccdiR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdiS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdiO_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 69;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdiO() //  [R1, R2]
         { info_tbl: [(ccdiO,
                       label: block_ccdiO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdiO: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmm_entry() //  [R1]
         { info_tbl: [(ccdj1,
                       label: sat_sccmm_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdj1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdj2; else goto ccdj3;
       ccdj2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdj3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdiZ_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 70;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdiZ() //  [R1, R2]
         { info_tbl: [(ccdiZ,
                       label: block_ccdiZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdiZ: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmq_entry() //  [R1]
         { info_tbl: [(ccdjc,
                       label: sat_sccmq_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdjc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdjd; else goto ccdje;
       ccdjd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdje: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdja_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 71;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdja() //  [R1, R2]
         { info_tbl: [(ccdja,
                       label: block_ccdja_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdja: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmu_entry() //  [R1]
         { info_tbl: [(ccdjn,
                       label: sat_sccmu_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdjn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdjo; else goto ccdjp;
       ccdjo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdjp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdjl_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 101;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdjl() //  [R1, R2]
         { info_tbl: [(ccdjl,
                       label: block_ccdjl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdjl: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmy_entry() //  [R1]
         { info_tbl: [(ccdjy,
                       label: sat_sccmy_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdjy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdjz; else goto ccdjA;
       ccdjz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdjA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdjw_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 102;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdjw() //  [R1, R2]
         { info_tbl: [(ccdjw,
                       label: block_ccdjw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdjw: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmC_entry() //  [R1]
         { info_tbl: [(ccdjJ,
                       label: sat_sccmC_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdjJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdjK; else goto ccdjL;
       ccdjK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdjL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdjH_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdjH() //  [R1, R2]
         { info_tbl: [(ccdjH,
                       label: block_ccdjH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdjH: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmG_entry() //  [R1]
         { info_tbl: [(ccdjU,
                       label: sat_sccmG_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdjU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdjV; else goto ccdjW;
       ccdjV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdjW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdjS_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdjS() //  [R1, R2]
         { info_tbl: [(ccdjS,
                       label: block_ccdjS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdjS: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdkk_srtd" {
     ucdkk_srtd:
         const SccKB_srt+32;
         const 48;
         const 145135534868481;
 },
 Text.Printf.$w$sformatRealFloat1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdk7,
                       label: Text.Printf.$w$sformatRealFloat1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdk7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccdkb; else goto ccdka;
       ccdkb: // global
           HpAlloc = 64;
           R1 = Text.Printf.$w$sformatRealFloat1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ccdka: // global
           _sccmc::P64 = P64[Sp];
           _sccme::I64 = I64[Sp + 8];
           if (_sccme::I64 < 101) goto ucdkc; else goto ucdkg;
       ucdkc: // global
           if (_sccme::I64 < 71) goto ucdkd; else goto ucdkf;
       ucdkd: // global
           if (_sccme::I64 < 70) goto ucdke; else goto ccdk1;
       ucdke: // global
           if (_sccme::I64 < 69) goto ccdjZ; else goto ccdk0;
       ccdk0: // global
           I64[Hp - 56] = sat_sccmi_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdk1: // global
           I64[Hp - 56] = sat_sccmm_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdkf: // global
           if (_sccme::I64 >= 72) goto ccdjZ; else goto ccdk2;
       ccdk2: // global
           I64[Hp - 56] = sat_sccmq_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdkg: // global
           if (_sccme::I64 < 103) goto ucdkh; else goto ucdki;
       ucdkh: // global
           if (_sccme::I64 < 102) goto ccdk3; else goto ccdk4;
       ccdk3: // global
           I64[Hp - 56] = sat_sccmu_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdk4: // global
           I64[Hp - 56] = sat_sccmy_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdki: // global
           if (_sccme::I64 < 104) goto ccdk5; else goto ucdkj;
       ccdk5: // global
           I64[Hp - 56] = sat_sccmC_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdkj: // global
           if (_sccme::I64 != 118) goto ccdjZ; else goto ccdk6;
       ccdjZ: // global
           Hp = Hp - 64;
           R2 = _sccme::I64;
           Sp = Sp + 16;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       ccdk6: // global
           I64[Hp - 56] = sat_sccmG_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.969875217 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure" {
     Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure:
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat_$sformatRealFloat_entry() //  [R2, R3]
         { info_tbl: [(ccdks,
                       label: Text.Printf.$fPrintfArgFloat_$sformatRealFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdks: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccdkw; else goto ccdkx;
       ccdkw: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdkx: // global
           I64[Sp - 16] = block_ccdkp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdkF; else goto ccdkq;
       ucdkF: // global
           call _ccdkp(R1) args: 0, res: 0, upd: 0;
       ccdkq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdkp() //  [R1]
         { info_tbl: [(ccdkp,
                       label: block_ccdkp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdkp: // global
           I64[Sp - 40] = block_ccdkv_info;
           _sccmK::P64 = P64[R1 + 7];
           _sccmL::P64 = P64[R1 + 15];
           _sccmM::P64 = P64[R1 + 23];
           _sccmN::P64 = P64[R1 + 31];
           _sccmO::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _sccmL::P64;
           P64[Sp - 24] = _sccmM::P64;
           P64[Sp - 16] = _sccmN::P64;
           P64[Sp - 8] = _sccmO::P64;
           P64[Sp] = _sccmK::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucdkE; else goto ccdkz;
       ucdkE: // global
           call _ccdkv(R1) args: 0, res: 0, upd: 0;
       ccdkz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdkv() //  [R1]
         { info_tbl: [(ccdkv,
                       label: block_ccdkv_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdkv: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 32];
           I64[Sp + 48] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.973690931 UTC

[section ""data" . Text.Printf.$wformatRealFloat_closure" {
     Text.Printf.$wformatRealFloat_closure:
         const Text.Printf.$wformatRealFloat_info;
         const 0;
 },
 Text.Printf.$wformatRealFloat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdkH: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatRealFloat_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccn5_entry() //  [R1]
         { info_tbl: [(ccdkU,
                       label: sat_sccn5_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdkU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdkV; else goto ccdkW;
       ccdkV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdkW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdkS_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 69;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdkS() //  [R1, R2]
         { info_tbl: [(ccdkS,
                       label: block_ccdkS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdkS: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccn9_entry() //  [R1]
         { info_tbl: [(ccdl5,
                       label: sat_sccn9_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdl5: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdl6; else goto ccdl7;
       ccdl6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdl7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdl3_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 70;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdl3() //  [R1, R2]
         { info_tbl: [(ccdl3,
                       label: block_ccdl3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdl3: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnd_entry() //  [R1]
         { info_tbl: [(ccdlg,
                       label: sat_sccnd_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdlg: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdlh; else goto ccdli;
       ccdlh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdli: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdle_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 71;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdle() //  [R1, R2]
         { info_tbl: [(ccdle,
                       label: block_ccdle_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdle: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnh_entry() //  [R1]
         { info_tbl: [(ccdlr,
                       label: sat_sccnh_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdlr: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdls; else goto ccdlt;
       ccdls: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdlt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdlp_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 101;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdlp() //  [R1, R2]
         { info_tbl: [(ccdlp,
                       label: block_ccdlp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdlp: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnl_entry() //  [R1]
         { info_tbl: [(ccdlC,
                       label: sat_sccnl_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdlC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdlD; else goto ccdlE;
       ccdlD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdlE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdlA_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 102;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdlA() //  [R1, R2]
         { info_tbl: [(ccdlA,
                       label: block_ccdlA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdlA: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnp_entry() //  [R1]
         { info_tbl: [(ccdlN,
                       label: sat_sccnp_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdlN: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdlO; else goto ccdlP;
       ccdlO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdlP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdlL_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 103;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdlL() //  [R1, R2]
         { info_tbl: [(ccdlL,
                       label: block_ccdlL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdlL: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnt_entry() //  [R1]
         { info_tbl: [(ccdlY,
                       label: sat_sccnt_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdlY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdlZ; else goto ccdm0;
       ccdlZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdm0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdlW_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 103;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdlW() //  [R1, R2]
         { info_tbl: [(ccdlW,
                       label: block_ccdlW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdlW: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdmo_srtd" {
     ucdmo_srtd:
         const SccKB_srt+32;
         const 50;
         const 567347999948801;
 },
 Text.Printf.$wformatRealFloat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdmb,
                       label: Text.Printf.$wformatRealFloat_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdmb: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccdmf; else goto ccdme;
       ccdmf: // global
           HpAlloc = 72;
           R1 = Text.Printf.$wformatRealFloat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccdme: // global
           _sccmY::P64 = P64[Sp];
           _sccmZ::P64 = P64[Sp + 8];
           _sccn1::I64 = I64[Sp + 16];
           if (_sccn1::I64 < 101) goto ucdmg; else goto ucdmk;
       ucdmg: // global
           if (_sccn1::I64 < 71) goto ucdmh; else goto ucdmj;
       ucdmh: // global
           if (_sccn1::I64 < 70) goto ucdmi; else goto ccdm5;
       ucdmi: // global
           if (_sccn1::I64 < 69) goto ccdm3; else goto ccdm4;
       ccdm4: // global
           I64[Hp - 64] = sat_sccn5_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdm5: // global
           I64[Hp - 64] = sat_sccn9_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdmj: // global
           if (_sccn1::I64 >= 72) goto ccdm3; else goto ccdm6;
       ccdm6: // global
           I64[Hp - 64] = sat_sccnd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdmk: // global
           if (_sccn1::I64 < 103) goto ucdml; else goto ucdmm;
       ucdml: // global
           if (_sccn1::I64 < 102) goto ccdm7; else goto ccdm8;
       ccdm7: // global
           I64[Hp - 64] = sat_sccnh_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdm8: // global
           I64[Hp - 64] = sat_sccnl_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdmm: // global
           if (_sccn1::I64 < 104) goto ccdm9; else goto ucdmn;
       ccdm9: // global
           I64[Hp - 64] = sat_sccnp_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdmn: // global
           if (_sccn1::I64 != 118) goto ccdm3; else goto ccdma;
       ccdm3: // global
           Hp = Hp - 72;
           R2 = _sccn1::I64;
           Sp = Sp + 24;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       ccdma: // global
           I64[Hp - 64] = sat_sccnt_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.980105029 UTC

[section ""data" . Text.Printf.formatRealFloat_closure" {
     Text.Printf.formatRealFloat_closure:
         const Text.Printf.formatRealFloat_info;
         const 0;
 },
 Text.Printf.formatRealFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(ccdmw,
                       label: Text.Printf.formatRealFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdmw: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdmA; else goto ccdmB;
       ccdmA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatRealFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdmB: // global
           I64[Sp - 24] = block_ccdmt_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucdmJ; else goto ccdmu;
       ucdmJ: // global
           call _ccdmt(R1) args: 0, res: 0, upd: 0;
       ccdmu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdmt() //  [R1]
         { info_tbl: [(ccdmt,
                       label: block_ccdmt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdmt: // global
           I64[Sp - 40] = block_ccdmz_info;
           _sccny::P64 = P64[R1 + 7];
           _sccnz::P64 = P64[R1 + 15];
           _sccnA::P64 = P64[R1 + 23];
           _sccnB::P64 = P64[R1 + 31];
           _sccnC::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _sccnz::P64;
           P64[Sp - 24] = _sccnA::P64;
           P64[Sp - 16] = _sccnB::P64;
           P64[Sp - 8] = _sccnC::P64;
           P64[Sp] = _sccny::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucdmI; else goto ccdmD;
       ucdmI: // global
           call _ccdmz(R1) args: 0, res: 0, upd: 0;
       ccdmD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdmz() //  [R1]
         { info_tbl: [(ccdmz,
                       label: block_ccdmz_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdmz: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 56];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatRealFloat_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.981944134 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgDouble_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble_$cparseFormat_entry() //  [R2, R3]
         { info_tbl: [(ccdmV,
                       label: Text.Printf.$fPrintfArgDouble_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdmV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdmW; else goto ccdmX;
       ccdmW: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgDouble_$cparseFormat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdmX: // global
           I64[Sp - 8] = block_ccdmO_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdn7; else goto ccdmP;
       ucdn7: // global
           call _ccdmO(R1) args: 0, res: 0, upd: 0;
       ccdmP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdmO() //  [R1]
         { info_tbl: [(ccdmO,
                       label: block_ccdmO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdmO: // global
           if (R1 & 7 == 1) goto ccdmS; else goto ccdmT;
       ccdmS: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccdmT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccdn6; else goto ccdn5;
       ccdn6: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdn5: // global
           _sccnK::P64 = P64[R1 + 6];
           _sccnL::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccnK::P64;
           P64[Hp] = _sccnL::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.983202499 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_closure" {
     Text.Printf.$fPrintfArgDouble_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure+2;
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.984128452 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgFloat_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat_$cparseFormat_entry() //  [R2, R3]
         { info_tbl: [(ccdnj,
                       label: Text.Printf.$fPrintfArgFloat_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdnj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdnk; else goto ccdnl;
       ccdnk: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgFloat_$cparseFormat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdnl: // global
           I64[Sp - 8] = block_ccdnc_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdnv; else goto ccdnd;
       ucdnv: // global
           call _ccdnc(R1) args: 0, res: 0, upd: 0;
       ccdnd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdnc() //  [R1]
         { info_tbl: [(ccdnc,
                       label: block_ccdnc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdnc: // global
           if (R1 & 7 == 1) goto ccdng; else goto ccdnh;
       ccdng: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccdnh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccdnu; else goto ccdnt;
       ccdnu: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdnt: // global
           _sccnP::P64 = P64[R1 + 6];
           _sccnQ::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccnP::P64;
           P64[Hp] = _sccnQ::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.985393531 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_closure" {
     Text.Printf.$fPrintfArgFloat_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure+2;
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.98720821 UTC

[section ""data" . Text.Printf.$w$sformatString_closure" {
     Text.Printf.$w$sformatString_closure:
         const Text.Printf.$w$sformatString_info;
         const 0;
 },
 Text.Printf.$w$sformatString_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdnx: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatString_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scco5_entry() //  [R1]
         { info_tbl: [(ccdnY,
                       label: sat_scco5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdnY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdnZ; else goto ccdo0;
       ccdnZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdo0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccdnR_info;
           _sccnR::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sccnR::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucdoj; else goto ccdnS;
       ucdoj: // global
           call _ccdnR(R1) args: 0, res: 0, upd: 0;
       ccdnS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdnR() //  [R1]
         { info_tbl: [(ccdnR,
                       label: block_ccdnR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdnR: // global
           if (R1 & 7 == 1) goto ccdnV; else goto ccdnW;
       ccdnV: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccdnW: // global
           I64[Sp] = block_ccdo6_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucdoi; else goto ccdo8;
       ucdoi: // global
           call _ccdo6(R1) args: 0, res: 0, upd: 0;
       ccdo8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdo6() //  [R1]
         { info_tbl: [(ccdo6,
                       label: block_ccdo6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdo6: // global
           _scco3::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _scco3::I64)) goto ccdog; else goto ccdoh;
       ccdog: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccdoh: // global
           R3 = P64[Sp + 8];
           R2 = _scco3::I64;
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sccnZ_entry() //  [R1]
         { info_tbl: [(ccdok,
                       label: g_sccnZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdok: // global
           _sccnZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccdol; else goto ccdom;
       ccdom: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccdoo; else goto ccdon;
       ccdoo: // global
           HpAlloc = 32;
           goto ccdol;
       ccdol: // global
           R1 = _sccnZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdon: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccnZ::P64;
           _sccnR::P64 = P64[_sccnZ::P64 + 16];
           _sccnS::P64 = P64[_sccnZ::P64 + 24];
           _sccnT::P64 = P64[_sccnZ::P64 + 32];
           _sccnU::P64 = P64[_sccnZ::P64 + 40];
           I64[Hp - 24] = sat_scco5_info;
           P64[Hp - 8] = _sccnR::P64;
           P64[Hp] = _sccnT::P64;
           R5 = Hp - 24;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sccnU::P64;
           R2 = _sccnS::P64;
           Sp = Sp - 16;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$w$sformatString_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdot,
                       label: Text.Printf.$w$sformatString_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdot: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdou; else goto ccdov;
       ccdou: // global
           R1 = Text.Printf.$w$sformatString_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       ccdov: // global
           if (R6 == 118) goto ccdos; else goto ccdor;
       ccdos: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = 115;
           Sp = Sp - 40;
           goto ucdoH;
       ccdor: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           goto ucdoH;
       ucdoH: // global
           call _ccdnE() args: 0, res: 0, upd: 0;
     }
 },
 _ccdnE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdnE: // global
           Hp = Hp + 48;
           _sccnX::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto ccdoy; else goto ccdox;
       ccdoy: // global
           HpAlloc = 48;
           I64[Sp - 8] = block_ccdnD_info;
           R1 = _sccnX::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccdox: // global
           if (_sccnX::I64 == 115) goto ccdoB; else goto ccdoA;
       ccdoB: // global
           I64[Hp - 40] = g_sccnZ_info;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 40;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 40;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdoA: // global
           Hp = Hp - 48;
           R2 = _sccnX::I64;
           Sp = Sp + 40;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccdnD() //  [R1]
         { info_tbl: [(ccdnD,
                       label: block_ccdnD_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdnD: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _ccdnE() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:03.992560052 UTC

[section ""data" . Text.Printf.$wformatString_closure" {
     Text.Printf.$wformatString_closure:
         const Text.Printf.$wformatString_info;
         const 0;
 },
 Text.Printf.$wformatString_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdoJ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatString_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sccoj_entry() //  [R1]
         { info_tbl: [(ccdpc,
                       label: sat_sccoj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdpc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdpd; else goto ccdpe;
       ccdpd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdpe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.Printf.toChar_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccox_entry() //  [R1]
         { info_tbl: [(ccdpJ,
                       label: sat_sccox_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdpJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdpK; else goto ccdpL;
       ccdpK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdpL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 32] - 1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wgo_sccoo_entry(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccov_entry() //  [R1]
         { info_tbl: [(ccdpQ,
                       label: sat_sccov_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdpQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdpR; else goto ccdpS;
       ccdpR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdpS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.toChar_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sccoy_entry() //  [R1]
         { info_tbl: [(ccdpY,
                       label: sat_sccoy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdpY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdpZ; else goto ccdq0;
       ccdpZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdq0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.toChar_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $wgo_sccoo_entry() //  [R1, R2, R3]
         { info_tbl: [(ccdq5,
                       label: $wgo_sccoo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdq5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdq6; else goto ccdq7;
       ccdq6: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdq7: // global
           I64[Sp - 32] = block_ccdpv_info;
           _sccoo::P64 = R1;
           _scco8::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 24] = _scco8::P64;
           P64[Sp - 16] = _sccoo::P64;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucdqi; else goto ccdpw;
       ucdqi: // global
           call _ccdpv(R1) args: 0, res: 0, upd: 0;
       ccdpw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdpv() //  [R1]
         { info_tbl: [(ccdpv,
                       label: block_ccdpv_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdpv: // global
           if (R1 & 7 == 1) goto ccdq2; else goto ccdq3;
       ccdq2: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdq3: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccdqc; else goto ccdqb;
       ccdqc: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdqb: // global
           _scco8::P64 = P64[Sp + 8];
           _sccos::P64 = P64[R1 + 6];
           _sccou::I64 = I64[Sp + 24];
           if (_sccou::I64 != 1) goto ccdqf; else goto ccdqh;
       ccdqf: // global
           _sccot::P64 = P64[R1 + 14];
           I64[Hp - 88] = sat_sccox_info;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sccot::P64;
           I64[Hp - 56] = _sccou::I64;
           I64[Hp - 48] = sat_sccov_info;
           P64[Hp - 32] = _scco8::P64;
           P64[Hp - 24] = _sccos::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdqh: // global
           I64[Hp - 88] = sat_sccoy_info;
           P64[Hp - 72] = _scco8::P64;
           P64[Hp - 64] = _sccos::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 88;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccdqg::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccdqg::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccoz_entry() //  [R1]
         { info_tbl: [(ccdqn,
                       label: sat_sccoz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdqn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccdqo; else goto ccdqp;
       ccdqo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdqp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccdp3_info;
           _scco8::P64 = P64[R1 + 16];
           _scco9::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _scco8::P64;
           P64[Sp - 24] = _scco9::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucdqB; else goto ccdp4;
       ucdqB: // global
           call _ccdp3(R1) args: 0, res: 0, upd: 0;
       ccdp4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdp3() //  [R1]
         { info_tbl: [(ccdp3,
                       label: block_ccdp3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdp3: // global
           if (R1 & 7 == 1) goto ccdqk; else goto ccdql;
       ccdqk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdqs; else goto ccdqr;
       ccdqs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccdqr: // global
           I64[Hp - 16] = sat_sccoj_info;
           P64[Hp] = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
       ccdql: // global
           I64[Sp] = block_ccdph_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucdqA; else goto ccdpi;
       ucdqA: // global
           call _ccdph(R1) args: 0, res: 0, upd: 0;
       ccdpi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdph() //  [R1]
         { info_tbl: [(ccdph,
                       label: block_ccdph_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdph: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccdqw; else goto ccdqv;
       ccdqw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccdqv: // global
           _sccom::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _sccom::I64)) goto ccdqy; else goto ccdqz;
       ccdqy: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccdqz: // global
           I64[Hp - 8] = $wgo_sccoo_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _sccom::I64;
           R2 = P64[Sp + 16];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call $wgo_sccoo_entry(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sccoh_entry() //  [R1]
         { info_tbl: [(ccdqC,
                       label: g_sccoh_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdqC: // global
           _sccoh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccdqD; else goto ccdqE;
       ccdqE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccdqG; else goto ccdqF;
       ccdqG: // global
           HpAlloc = 40;
           goto ccdqD;
       ccdqD: // global
           R1 = _sccoh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdqF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccoh::P64;
           _scco8::P64 = P64[_sccoh::P64 + 16];
           _scco9::P64 = P64[_sccoh::P64 + 24];
           _sccoa::P64 = P64[_sccoh::P64 + 32];
           _sccob::P64 = P64[_sccoh::P64 + 40];
           _sccoc::P64 = P64[_sccoh::P64 + 48];
           I64[Hp - 32] = sat_sccoz_info;
           P64[Hp - 16] = _scco8::P64;
           P64[Hp - 8] = _scco9::P64;
           P64[Hp] = _sccob::P64;
           R5 = Hp - 32;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sccoc::P64;
           R2 = _sccoa::P64;
           Sp = Sp - 16;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$wformatString_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdqL,
                       label: Text.Printf.$wformatString_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdqL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdqM; else goto ccdqN;
       ccdqM: // global
           R1 = Text.Printf.$wformatString_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       ccdqN: // global
           _sccoB::I64 = I64[Sp];
           if (_sccoB::I64 == 118) goto ccdqK; else goto ccdqJ;
       ccdqK: // global
           P64[Sp] = R2;
           P64[Sp - 40] = R3;
           P64[Sp - 32] = R4;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           I64[Sp - 8] = 115;
           Sp = Sp - 40;
           goto ucdqZ;
       ccdqJ: // global
           P64[Sp - 40] = R3;
           P64[Sp - 32] = R4;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           I64[Sp - 8] = _sccoB::I64;
           P64[Sp] = R2;
           Sp = Sp - 40;
           goto ucdqZ;
       ucdqZ: // global
           call _ccdoQ() args: 0, res: 0, upd: 0;
     }
 },
 _ccdoQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdoQ: // global
           Hp = Hp + 56;
           _sccof::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto ccdqQ; else goto ccdqP;
       ccdqQ: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_ccdoP_info;
           R1 = _sccof::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccdqP: // global
           if (_sccof::I64 == 115) goto ccdqT; else goto ccdqS;
       ccdqT: // global
           I64[Hp - 48] = g_sccoh_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 48;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdqS: // global
           Hp = Hp - 56;
           R2 = _sccof::I64;
           Sp = Sp + 48;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccdoP() //  [R1]
         { info_tbl: [(ccdoP,
                       label: block_ccdoP_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdoP: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _ccdoQ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.000809753 UTC

[section ""data" . Text.Printf.formatString_closure" {
     Text.Printf.formatString_closure:
         const Text.Printf.formatString_info;
         const 0;
 },
 Text.Printf.formatString_entry() //  [R2, R3, R4]
         { info_tbl: [(ccdr7,
                       label: Text.Printf.formatString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdr7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdrb; else goto ccdrc;
       ccdrb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatString_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdrc: // global
           I64[Sp - 24] = block_ccdr4_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucdrk; else goto ccdr5;
       ucdrk: // global
           call _ccdr4(R1) args: 0, res: 0, upd: 0;
       ccdr5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdr4() //  [R1]
         { info_tbl: [(ccdr4,
                       label: block_ccdr4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdr4: // global
           I64[Sp - 24] = block_ccdra_info;
           _sccoG::P64 = P64[R1 + 7];
           _sccoH::P64 = P64[R1 + 15];
           _sccoI::P64 = P64[R1 + 23];
           R1 = P64[R1 + 55];
           P64[Sp - 16] = _sccoH::P64;
           P64[Sp - 8] = _sccoI::P64;
           P64[Sp] = _sccoG::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucdrj; else goto ccdre;
       ucdrj: // global
           call _ccdra(R1) args: 0, res: 0, upd: 0;
       ccdre: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdra() //  [R1]
         { info_tbl: [(ccdra,
                       label: block_ccdra_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdra: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatString_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.002526866 UTC

[section ""data" . lvl22_rcccn_closure" {
     lvl22_rcccn_closure:
         const lvl22_rcccn_info;
         const 0;
 },
 lvl22_rcccn_entry() //  [R2, R3]
         { info_tbl: [(ccdrw,
                       label: lvl22_rcccn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdrw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdrx; else goto ccdry;
       ccdrx: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl22_rcccn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdry: // global
           I64[Sp - 8] = block_ccdrp_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdrI; else goto ccdrq;
       ucdrI: // global
           call _ccdrp(R1) args: 0, res: 0, upd: 0;
       ccdrq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdrp() //  [R1]
         { info_tbl: [(ccdrp,
                       label: block_ccdrp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdrp: // global
           if (R1 & 7 == 1) goto ccdrt; else goto ccdru;
       ccdrt: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccdru: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccdrH; else goto ccdrG;
       ccdrH: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdrG: // global
           _sccoS::P64 = P64[R1 + 6];
           _sccoT::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccoS::P64;
           P64[Hp] = _sccoT::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.003958821 UTC

[section ""data" . Text.Printf.$fPrintfArg[]_closure" {
     Text.Printf.$fPrintfArg[]_closure:
         const Text.Printf.$fPrintfArg[]_info;
         const 0;
 },
 sat_sccoV_entry() //  [R1, R2, R3]
         { info_tbl: [(ccdrS,
                       label: sat_sccoV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdrS: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Text.Printf.formatString_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$fPrintfArg[]_entry() //  [R2]
         { info_tbl: [(ccdrW,
                       label: Text.Printf.$fPrintfArg[]_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdrW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccds0; else goto ccdrZ;
       ccds0: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArg[]_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccdrZ: // global
           I64[Hp - 32] = sat_sccoV_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Text.Printf.C:PrintfArg_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = lvl22_rcccn_closure+2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.005001429 UTC

[section ""data" . lvl23_rccco_closure" {
     lvl23_rccco_closure:
         const GHC.Types.C#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.005549715 UTC

[section ""data" . sat_sccoW_closure" {
     sat_sccoW_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.006112983 UTC

[section ""data" . sat_sccoX_closure" {
     sat_sccoX_closure:
         const :_con_info;
         const sat_sccoW_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.006846832 UTC

[section ""data" . lvl24_rcccp_closure" {
     lvl24_rcccp_closure:
         const lvl24_rcccp_info;
         const 0;
         const 0;
         const 0;
 },
 lvl24_rcccp_entry() //  [R1]
         { info_tbl: [(ccds7,
                       label: lvl24_rcccp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccds7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccds8; else goto ccds9;
       ccds8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccds9: // global
           (_ccds4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccds4::I64 == 0) goto ccds6; else goto ccds5;
       ccds6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccds5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccds4::I64;
           R3 = sat_sccoX_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.007707383 UTC

[section ""cstring" . lvl25_rcccq_bytes" {
     lvl25_rcccq_bytes:
         I8[] [48,88]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.0084353 UTC

[section ""data" . lvl26_rcccr_closure" {
     lvl26_rcccr_closure:
         const lvl26_rcccr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_rcccr_entry() //  [R1]
         { info_tbl: [(ccdsg,
                       label: lvl26_rcccr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdsg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdsh; else goto ccdsi;
       ccdsh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdsi: // global
           (_ccdsd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdsd::I64 == 0) goto ccdsf; else goto ccdse;
       ccdsf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdse: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdsd::I64;
           R2 = lvl25_rcccq_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.009306745 UTC

[section ""cstring" . lvl27_rcccs_bytes" {
     lvl27_rcccs_bytes:
         I8[] [48,98]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.010029467 UTC

[section ""data" . lvl28_rccct_closure" {
     lvl28_rccct_closure:
         const lvl28_rccct_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_rccct_entry() //  [R1]
         { info_tbl: [(ccdsp,
                       label: lvl28_rccct_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdsp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdsq; else goto ccdsr;
       ccdsq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdsr: // global
           (_ccdsm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdsm::I64 == 0) goto ccdso; else goto ccdsn;
       ccdso: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdsn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdsm::I64;
           R2 = lvl27_rcccs_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.010908244 UTC

[section ""cstring" . lvl29_rcccu_bytes" {
     lvl29_rcccu_bytes:
         I8[] [112,114,105,110,116,102,58,32,105,108,108,101,103,97,108,32,99,104,97,114,32,99,111,110,118,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.01166271 UTC

[section ""data" . lvl30_rcccv_closure" {
     lvl30_rcccv_closure:
         const lvl30_rcccv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_rcccv_entry() //  [R1]
         { info_tbl: [(ccdsA,
                       label: lvl30_rcccv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdsA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccdsB; else goto ccdsC;
       ccdsB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdsC: // global
           (_ccdsv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdsv::I64 == 0) goto ccdsx; else goto ccdsw;
       ccdsx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdsw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdsv::I64;
           I64[Sp - 24] = block_ccdsy_info;
           R2 = lvl29_rcccu_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdsy() //  [R1]
         { info_tbl: [(ccdsy,
                       label: block_ccdsy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdsy: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.012652382 UTC

[section ""data" . sat_sccoZ_closure" {
     sat_sccoZ_closure:
         const GHC.Types.I#_con_info;
         const 1114111;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.013208399 UTC

[section ""data" . sat_sccp0_closure" {
     sat_sccp0_closure:
         const :_con_info;
         const sat_sccoZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.013954461 UTC

[section ""data" . lvl31_rcccw_closure" {
     lvl31_rcccw_closure:
         const lvl31_rcccw_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_rcccw_entry() //  [R1]
         { info_tbl: [(ccdsM,
                       label: lvl31_rcccw_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdsM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdsN; else goto ccdsO;
       ccdsN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdsO: // global
           (_ccdsJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdsJ::I64 == 0) goto ccdsL; else goto ccdsK;
       ccdsL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdsK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdsJ::I64;
           R3 = sat_sccp0_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.014853761 UTC

[section ""data" . sat_sccp1_closure" {
     sat_sccp1_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.015399637 UTC

[section ""data" . sat_sccp2_closure" {
     sat_sccp2_closure:
         const :_con_info;
         const sat_sccp1_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.016144658 UTC

[section ""data" . lvl32_rcccx_closure" {
     lvl32_rcccx_closure:
         const lvl32_rcccx_info;
         const 0;
         const 0;
         const 0;
 },
 lvl32_rcccx_entry() //  [R1]
         { info_tbl: [(ccdsV,
                       label: lvl32_rcccx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdsV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdsW; else goto ccdsX;
       ccdsW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdsX: // global
           (_ccdsS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdsS::I64 == 0) goto ccdsU; else goto ccdsT;
       ccdsU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdsT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdsS::I64;
           R3 = sat_sccp2_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.017032118 UTC

[section ""cstring" . lvl33_rcccy_bytes" {
     lvl33_rcccy_bytes:
         I8[] [48]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.017757475 UTC

[section ""data" . lvl34_rcccz_closure" {
     lvl34_rcccz_closure:
         const lvl34_rcccz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl34_rcccz_entry() //  [R1]
         { info_tbl: [(ccdt4,
                       label: lvl34_rcccz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdt4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdt5; else goto ccdt6;
       ccdt5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdt6: // global
           (_ccdt1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdt1::I64 == 0) goto ccdt3; else goto ccdt2;
       ccdt3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdt2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdt1::I64;
           R2 = lvl33_rcccy_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.018603008 UTC

[section ""data" . sat_sccp3_closure" {
     sat_sccp3_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.01910082 UTC

[section ""data" . sat_sccp4_closure" {
     sat_sccp4_closure:
         const :_con_info;
         const sat_sccp3_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.019792796 UTC

[section ""data" . lvl35_rcccA_closure" {
     lvl35_rcccA_closure:
         const lvl35_rcccA_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_rcccA_entry() //  [R1]
         { info_tbl: [(ccdtd,
                       label: lvl35_rcccA_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdtd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdte; else goto ccdtf;
       ccdte: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdtf: // global
           (_ccdta::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdta::I64 == 0) goto ccdtc; else goto ccdtb;
       ccdtc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdtb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdta::I64;
           R3 = sat_sccp4_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.020678994 UTC

[section ""cstring" . lvl36_rcccB_bytes" {
     lvl36_rcccB_bytes:
         I8[] [48,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.021508102 UTC

[section ""data" . lvl37_rcccC_closure" {
     lvl37_rcccC_closure:
         const lvl37_rcccC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_rcccC_entry() //  [R1]
         { info_tbl: [(ccdtm,
                       label: lvl37_rcccC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdtm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdtn; else goto ccdto;
       ccdtn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdto: // global
           (_ccdtj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdtj::I64 == 0) goto ccdtl; else goto ccdtk;
       ccdtl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdtk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdtj::I64;
           R2 = lvl36_rcccB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.022376788 UTC

[section ""data" . lvl38_rcccD_closure" {
     lvl38_rcccD_closure:
         const GHC.Base.Just_con_info;
         const lvl26_rcccr_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.022945226 UTC

[section ""data" . lvl39_rcccE_closure" {
     lvl39_rcccE_closure:
         const GHC.Base.Just_con_info;
         const lvl28_rccct_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.023522453 UTC

[section ""data" . lvl40_rcccF_closure" {
     lvl40_rcccF_closure:
         const GHC.Base.Just_con_info;
         const lvl34_rcccz_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.02411596 UTC

[section ""data" . lvl41_rcccG_closure" {
     lvl41_rcccG_closure:
         const GHC.Base.Just_con_info;
         const lvl37_rcccC_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.031430161 UTC

[section ""data" . Text.Printf.$wformatIntegral_closure" {
     Text.Printf.$wformatIntegral_closure:
         const Text.Printf.$wformatIntegral_info;
         const 0;
 },
 Text.Printf.$wformatIntegral_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdtq: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sccpt_entry() //  [R1]
         { info_tbl: [(ccduE,
                       label: sat_sccpt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccduE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccduF; else goto ccduG;
       ccduF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccduG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccpx_entry() //  [R1]
         { info_tbl: [(ccduP,
                       label: sat_sccpx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccduP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccduQ; else goto ccduR;
       ccduQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccduR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccpB_entry() //  [R1]
         { info_tbl: [(ccdv0,
                       label: sat_sccpB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdv0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdv1; else goto ccdv2;
       ccdv1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdv2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdAE_srtd" {
     ucdAE_srtd:
         const SccKB_srt+312;
         const 33;
         const 7516192777;
 },
 sat_sccpC_entry() //  [R1]
         { info_tbl: [(ccdv6,
                       label: sat_sccpC_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdv6: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccdv7; else goto ccdv8;
       ccdv7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdv8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccdup_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdup() //  [R1]
         { info_tbl: [(ccdup,
                       label: block_ccdup_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdup: // global
           if (R1 == 1) goto ccdv5; else goto ccdv4;
       ccdv5: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccduU_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccdv4: // global
           I64[Sp] = block_ccdut_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ucdvq; else goto ccduu;
       ucdvq: // global
           call _ccdut(R1) args: 0, res: 0, upd: 0;
       ccduu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccduU() //  [R1, R2]
         { info_tbl: [(ccduU,
                       label: block_ccduU_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccduU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdvo; else goto ccdvn;
       ccdvo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccdvn: // global
           I64[Hp - 16] = sat_sccpB_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccdut() //  [R1]
         { info_tbl: [(ccdut,
                       label: block_ccdut_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdut: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccdvc; else goto ccdvh;
       ccdvc: // global
           I64[Sp + 24] = block_ccduy_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccdvh: // global
           I64[Sp + 24] = block_ccduJ_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl38_rcccD_closure+2;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccduy() //  [R1, R2]
         { info_tbl: [(ccduy,
                       label: block_ccduy_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccduy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdvf; else goto ccdve;
       ccdvf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccdve: // global
           I64[Hp - 16] = sat_sccpt_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccduJ() //  [R1, R2]
         { info_tbl: [(ccduJ,
                       label: block_ccduJ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccduJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdvk; else goto ccdvj;
       ccdvk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccdvj: // global
           I64[Hp - 16] = sat_sccpx_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdAF_srtd" {
     ucdAF_srtd:
         const SccKB_srt+312;
         const 34;
         const 8589934603;
 },
 sat_sccpO_entry() //  [R1]
         { info_tbl: [(ccdvB,
                       label: sat_sccpO_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdvB: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccdvC; else goto ccdvD;
       ccdvC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdvD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccdvw_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ucdAG_srtd" {
     ucdAG_srtd:
         const SccKB_srt+320;
         const 33;
         const 4294967301;
 },
 _ccdvw() //  [R1]
         { info_tbl: [(ccdvw,
                       label: block_ccdvw_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdvw: // global
           if (R1 == 1) goto ccdvA; else goto ccdvz;
       ccdvA: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccdw1_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccdvz: // global
           I64[Sp] = block_ccdvG_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ucdw6; else goto ccdvI;
       ucdw6: // global
           call _ccdvG(R1) args: 0, res: 0, upd: 0;
       ccdvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdw1() //  [R1, R2]
         { info_tbl: [(ccdw1,
                       label: block_ccdw1_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdw1: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdAH_srtd" {
     ucdAH_srtd:
         const SccKB_srt+320;
         const 33;
         const 4294967301;
 },
 _ccdvG() //  [R1]
         { info_tbl: [(ccdvG,
                       label: block_ccdvG_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdvG: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccdvP; else goto ccdvW;
       ccdvP: // global
           I64[Sp + 24] = block_ccdvM_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccdvW: // global
           I64[Sp + 24] = block_ccdvU_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl39_rcccE_closure+2;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdvM() //  [R1, R2]
         { info_tbl: [(ccdvM,
                       label: block_ccdvM_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdvM: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccdvU() //  [R1, R2]
         { info_tbl: [(ccdvU,
                       label: block_ccdvU_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdvU: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccpX_entry() //  [R1]
         { info_tbl: [(ccdwy,
                       label: sat_sccpX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdwy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccdwz; else goto ccdwA;
       ccdwz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdwA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccdww_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdww() //  [R1]
         { info_tbl: [(ccdww,
                       label: block_ccdww_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdww: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccdwF; else goto ccdwE;
       ccdwF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       ccdwE: // global
           if (R1 > 1114111) goto ccdwM; else goto ccdwT;
       ccdwM: // global
           Hp = Hp - 16;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccdwT: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccq3_entry() //  [R1]
         { info_tbl: [(ccdx1,
                       label: sat_sccq3_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdx1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdx2; else goto ccdx3;
       ccdx2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdx3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdwZ_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call $wfmti_rcccm_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdwZ() //  [R1, R2]
         { info_tbl: [(ccdwZ,
                       label: block_ccdwZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdwZ: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccq7_entry() //  [R1]
         { info_tbl: [(ccdxc,
                       label: sat_sccq7_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdxc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccdxd; else goto ccdxe;
       ccdxd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdxe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccdxa_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call $wfmti_rcccm_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdxa() //  [R1, R2]
         { info_tbl: [(ccdxa,
                       label: block_ccdxa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdxa: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccqj_entry() //  [R1]
         { info_tbl: [(ccdxq,
                       label: sat_sccqj_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdxq: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccdxr; else goto ccdxs;
       ccdxr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdxs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccdxl_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdxl() //  [R1]
         { info_tbl: [(ccdxl,
                       label: block_ccdxl_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdxl: // global
           if (R1 == 1) goto ccdxp; else goto ccdxo;
       ccdxp: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccdxQ_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccdxo: // global
           I64[Sp] = block_ccdxv_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ucdxV; else goto ccdxx;
       ucdxV: // global
           call _ccdxv(R1) args: 0, res: 0, upd: 0;
       ccdxx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdxQ() //  [R1, R2]
         { info_tbl: [(ccdxQ,
                       label: block_ccdxQ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdxQ: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccdxv() //  [R1]
         { info_tbl: [(ccdxv,
                       label: block_ccdxv_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdxv: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccdxE; else goto ccdxL;
       ccdxE: // global
           I64[Sp + 24] = block_ccdxB_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccdxL: // global
           I64[Sp + 24] = block_ccdxJ_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl40_rcccF_closure+2;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdxB() //  [R1, R2]
         { info_tbl: [(ccdxB,
                       label: block_ccdxB_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdxB: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccdxJ() //  [R1, R2]
         { info_tbl: [(ccdxJ,
                       label: block_ccdxJ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdxJ: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccqn_entry() //  [R1]
         { info_tbl: [(ccdy3,
                       label: sat_sccqn_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdy3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccdy4; else goto ccdy5;
       ccdy4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdy5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccdy1_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 32];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl35_rcccA_closure;
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 40;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdy1() //  [R1, R2]
         { info_tbl: [(ccdy1,
                       label: block_ccdy1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdy1: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccqz_entry() //  [R1]
         { info_tbl: [(ccdyh,
                       label: sat_sccqz_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdyh: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccdyi; else goto ccdyj;
       ccdyi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdyj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccdyc_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdyc() //  [R1]
         { info_tbl: [(ccdyc,
                       label: block_ccdyc_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdyc: // global
           if (R1 == 1) goto ccdyg; else goto ccdyf;
       ccdyg: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccdyH_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccdyf: // global
           I64[Sp] = block_ccdym_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ucdyM; else goto ccdyo;
       ucdyM: // global
           call _ccdym(R1) args: 0, res: 0, upd: 0;
       ccdyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdyH() //  [R1, R2]
         { info_tbl: [(ccdyH,
                       label: block_ccdyH_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdyH: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccdym() //  [R1]
         { info_tbl: [(ccdym,
                       label: block_ccdym_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdym: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccdyv; else goto ccdyC;
       ccdyv: // global
           I64[Sp + 24] = block_ccdys_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccdyC: // global
           I64[Sp + 24] = block_ccdyA_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl41_rcccG_closure+2;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdys() //  [R1, R2]
         { info_tbl: [(ccdys,
                       label: block_ccdys_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdys: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccdyA() //  [R1, R2]
         { info_tbl: [(ccdyA,
                       label: block_ccdyA_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdyA: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdAI_srtd" {
     ucdAI_srtd:
         const SccKB_srt+320;
         const 43;
         const 8795556937825;
 },
 Text.Printf.$wformatIntegral_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdyR,
                       label: Text.Printf.$wformatIntegral_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdyR: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccdyS; else goto ccdyT;
       ccdyS: // global
           R1 = Text.Printf.$wformatIntegral_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       ccdyT: // global
           I64[Sp - 48] = block_ccdtw_info;
           R1 = R5;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdAD; else goto ccdtx;
       ucdAD: // global
           call _ccdtw(R1) args: 0, res: 0, upd: 0;
       ccdtx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdAJ_srtd" {
     ucdAJ_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _ccdtw() //  [R1]
         { info_tbl: [(ccdtw,
                       label: block_ccdtw_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdtw: // global
           _sccp9::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto ccdyO; else goto ccdyP;
       ccdyO: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccdzB; else goto ccdzA;
       ccdzB: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdzA: // global
           _sccp7::P64 = P64[Sp + 24];
           _sccpa::P64 = P64[Sp + 48];
           _sccpb::P64 = P64[Sp + 56];
           _sccpc::P64 = P64[Sp + 64];
           _sccqB::I64 = I64[Sp + 72];
           if (_sccqB::I64 != 118) goto ccdzD; else goto ccdzE;
       ccdzD: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccqB::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = _sccp9::P64;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sccp9::P64;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = _sccqB::I64;
           Sp = Sp - 8;
           goto ucdAq;
       ccdzE: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = GHC.Base.Nothing_closure+1;
           P64[Hp - 48] = _sccp9::P64;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccdtG::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sccp9::P64;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = 100;
           Sp = Sp - 8;
           goto ucdAq;
       ucdAq: // global
           call _ccduf() args: 0, res: 0, upd: 0;
       ccdyP: // global
           I64[Sp] = block_ccdtJ_info;
           _sccqA::P64 = R1;
           R1 = _sccp9::P64;
           P64[Sp + 40] = _sccqA::P64;
           if (R1 & 7 != 0) goto ucdAo; else goto ccdtK;
       ucdAo: // global
           call _ccdtJ(R1) args: 0, res: 0, upd: 0;
       ccdtK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdAK_srtd" {
     ucdAK_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _ccdtJ() //  [R1]
         { info_tbl: [(ccdtJ,
                       label: block_ccdtJ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdtJ: // global
           if (R1 & 7 == 1) goto ccdzH; else goto ccdzP;
       ccdzH: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccdzK; else goto ccdzJ;
       ccdzK: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdzJ: // global
           _sccp7::P64 = P64[Sp + 24];
           _sccpa::P64 = P64[Sp + 48];
           _sccpb::P64 = P64[Sp + 56];
           _sccpc::P64 = P64[Sp + 64];
           _sccqA::P64 = P64[Sp + 40];
           _sccqH::I64 = I64[Sp + 72];
           if (_sccqH::I64 != 118) goto ccdzM; else goto ccdzN;
       ccdzM: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccqH::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = _sccqA::P64;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = _sccqA::P64;
           P64[Sp + 56] = GHC.Base.Nothing_closure+1;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = _sccqH::I64;
           Sp = Sp - 8;
           goto ucdAt;
       ccdzN: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = _sccqA::P64;
           P64[Hp - 48] = GHC.Base.Nothing_closure+1;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccdtT::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = _sccqA::P64;
           P64[Sp + 56] = GHC.Base.Nothing_closure+1;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = 100;
           Sp = Sp - 8;
           goto ucdAt;
       ucdAt: // global
           call _ccduf() args: 0, res: 0, upd: 0;
       ccdzP: // global
           I64[Sp - 8] = block_ccdtW_info;
           _sccqG::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _sccqG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdAr; else goto ccdtX;
       ucdAr: // global
           call _ccdtW(R1) args: 0, res: 0, upd: 0;
       ccdtX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdAL_srtd" {
     ucdAL_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _ccdtW() //  [R1]
         { info_tbl: [(ccdtW,
                       label: block_ccdtW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdtW: // global
           _sccp7::P64 = P64[Sp + 32];
           _sccpa::P64 = P64[Sp + 56];
           _sccpb::P64 = P64[Sp + 64];
           _sccpc::P64 = P64[Sp + 72];
           _sccpd::I64 = I64[Sp + 80];
           _sccqA::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto ccdzR; else goto ccdzY;
       ccdzR: // global
           Hp = Hp + 80;
           _sccqM::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccdA1; else goto ccdzT;
       ccdzT: // global
           _sccqG::P64 = P64[Sp + 8];
           if (_sccpd::I64 == 118) goto ccdzX; else goto ccdzW;
       ccdzX: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = _sccqA::P64;
           P64[Hp - 48] = _sccqG::P64;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccdu6::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 80] = _sccp7::P64;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 64] = _sccqG::P64;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 32] = _sccpc::P64;
           I64[Sp + 8] = 100;
           goto ucdAx;
       ccdzW: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccpd::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = _sccqA::P64;
           P64[Hp - 32] = _sccqG::P64;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 80] = _sccp7::P64;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 64] = _sccqG::P64;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 32] = _sccpc::P64;
           I64[Sp + 8] = _sccpd::I64;
           goto ucdAx;
       ccdzY: // global
           Hp = Hp + 80;
           _sccqM::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccdA1; else goto ccdA0;
       ccdA1: // global
           HpAlloc = 80;
           R1 = _sccqM::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdA0: // global
           if (_sccpd::I64 == 118) goto ccdA4; else goto ccdA3;
       ccdA4: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = _sccqA::P64;
           P64[Hp - 48] = GHC.Base.Nothing_closure+1;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccdue::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 80] = _sccp7::P64;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 32] = _sccpc::P64;
           I64[Sp + 8] = 100;
           goto ucdAx;
       ccdA3: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccpd::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = _sccqA::P64;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           I64[Sp + 8] = _sccpd::I64;
           P64[Sp + 32] = _sccpc::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 80] = _sccp7::P64;
           goto ucdAx;
       ucdAx: // global
           call _ccduf() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ucdAM_srtd" {
     ucdAM_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _ccduf() //  []
         { info_tbl: [(ccduf,
                       label: block_ccduf_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccduf: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccdyW; else goto ccdyV;
       ccdyW: // global
           HpAlloc = 64;
           I64[Sp] = block_ccduf_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccdyV: // global
           _sccpn::I64 = I64[Sp + 8];
           if (_sccpn::I64 >= 121) goto ccdyY; else goto ucdA9;
       ucdA9: // global
           _sccp5::P64 = P64[Sp + 16];
           _sccp6::P64 = P64[Sp + 24];
           _sccp8::P64 = P64[Sp + 40];
           _sccpf::P64 = P64[Sp + 80];
           _sccph::P64 = P64[Sp + 64];
           _sccpj::P64 = P64[Sp + 48];
           if (_sccpn::I64 < 98) goto ucdAa; else goto ucdAb;
       ucdAa: // global
           if (_sccpn::I64 != 88) goto ccdyY; else goto ccdyZ;
       ccdyZ: // global
           I64[Hp - 56] = sat_sccpC_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucdAb: // global
           _sccpi::P64 = P64[Sp + 56];
           switch [98 .. 120] _sccpn::I64 {
               case 98 : goto ccdz0;
               case 99 : goto ccdz1;
               case 100 : goto ccdzu;
               case 105 : goto ccdzv;
               case 111 : goto ccdzw;
               case 117 : goto ccdzx;
               case 120 : goto ccdzy;
               default: {goto ccdyY;}
           }
       ccdzy: // global
           I64[Hp - 56] = sat_sccqz_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdzx: // global
           I64[Hp - 56] = sat_sccqn_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           _ccdxX::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _ccdxX::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdzw: // global
           I64[Hp - 56] = sat_sccqj_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdzv: // global
           I64[Hp - 56] = sat_sccq7_info;
           P64[Hp - 40] = _sccp6::P64;
           P64[Hp - 32] = _sccp8::P64;
           P64[Hp - 24] = _sccpf::P64;
           P64[Hp - 16] = _sccph::P64;
           P64[Hp - 8] = _sccpi::P64;
           _ccdx6::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _ccdx6::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdzu: // global
           I64[Hp - 56] = sat_sccq3_info;
           P64[Hp - 40] = _sccp6::P64;
           P64[Hp - 32] = _sccp8::P64;
           P64[Hp - 24] = _sccpf::P64;
           P64[Hp - 16] = _sccph::P64;
           P64[Hp - 8] = _sccpi::P64;
           _ccdwV::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _ccdwV::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdz1: // global
           Hp = Hp - 64;
           I64[Sp + 16] = block_ccdw8_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sccp6::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ccdz0: // global
           I64[Hp - 56] = sat_sccpO_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccdyY: // global
           Hp = Hp - 64;
           R2 = _sccpn::I64;
           Sp = Sp + 88;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccdw8() //  [R1]
         { info_tbl: [(ccdw8,
                       label: block_ccdw8_info
                       rep:StackRep [False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdw8: // global
           if (R1 == 1) goto ccdz7; else goto ucdAk;
       ccdz7: // global
           I64[Sp] = block_ccdwd_info;
           R3 = lvl31_rcccw_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ucdAk: // global
           Sp = Sp + 72;
           call _ccdzt() args: 0, res: 0, upd: 0;
     }
 },
 _ccdwd() //  [R1]
         { info_tbl: [(ccdwd,
                       label: block_ccdwd_info
                       rep:StackRep [False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdwd: // global
           if (R1 == 1) goto ccdzd; else goto ucdAl;
       ccdzd: // global
           I64[Sp] = block_ccdwi_info;
           R1 = P64[Sp + 56];
           if (R1 & 7 != 0) goto ucdAz; else goto ccdwj;
       ucdAz: // global
           call _ccdwi(R1) args: 0, res: 0, upd: 0;
       ccdwj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucdAl: // global
           Sp = Sp + 72;
           call _ccdzt() args: 0, res: 0, upd: 0;
     }
 },
 _ccdwi() //  [R1]
         { info_tbl: [(ccdwi,
                       label: block_ccdwi_info
                       rep:StackRep [False, False, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdwi: // global
           if (R1 & 7 == 1) goto ccdzg; else goto ucdAm;
       ccdzg: // global
           I64[Sp] = block_ccdwn_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[Sp + 16];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       ucdAm: // global
           Sp = Sp + 72;
           call _ccdzt() args: 0, res: 0, upd: 0;
     }
 },
 _ccdwn() //  [R1]
         { info_tbl: [(ccdwn,
                       label: block_ccdwn_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdwn: // global
           if (R1 & 7 == 1) goto ucdAn; else goto ccdzm;
       ucdAn: // global
           Sp = Sp + 72;
           call _ccdzt() args: 0, res: 0, upd: 0;
       ccdzm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdzp; else goto ccdzo;
       ccdzp: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdzo: // global
           I64[Hp - 40] = sat_sccpX_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R6 = 115;
           R5 = P64[Sp + 48];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[Sp + 64];
           R2 = Hp - 14;
           Sp = Sp + 72;
           call Text.Printf.$w$sformatString_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccdzt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdzt: // global
           R1 = lvl30_rcccv_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.048882025 UTC

[section ""data" . Text.Printf.formatIntegral_closure" {
     Text.Printf.formatIntegral_closure:
         const Text.Printf.formatIntegral_info;
         const 0;
 },
 Text.Printf.formatIntegral_entry() //  [R2, R3, R4]
         { info_tbl: [(ccdAU,
                       label: Text.Printf.formatIntegral_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdAU: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccdAY; else goto ccdAZ;
       ccdAY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatIntegral_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdAZ: // global
           I64[Sp - 24] = block_ccdAR_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucdB7; else goto ccdAS;
       ucdB7: // global
           call _ccdAR(R1) args: 0, res: 0, upd: 0;
       ccdAS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdAR() //  [R1]
         { info_tbl: [(ccdAR,
                       label: block_ccdAR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdAR: // global
           I64[Sp - 48] = block_ccdAX_info;
           _sccqZ::P64 = P64[R1 + 7];
           _sccr0::P64 = P64[R1 + 15];
           _sccr1::P64 = P64[R1 + 23];
           _sccr2::P64 = P64[R1 + 31];
           _sccr3::P64 = P64[R1 + 39];
           _sccr4::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccr0::P64;
           P64[Sp - 32] = _sccr1::P64;
           P64[Sp - 24] = _sccr2::P64;
           P64[Sp - 16] = _sccr3::P64;
           P64[Sp - 8] = _sccr4::P64;
           P64[Sp] = _sccqZ::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdB6; else goto ccdB1;
       ucdB6: // global
           call _ccdAX(R1) args: 0, res: 0, upd: 0;
       ccdB1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdAX() //  [R1]
         { info_tbl: [(ccdAX,
                       label: block_ccdAX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdAX: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           _sccr4::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccr4::P64;
           I64[Sp + 64] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.050417664 UTC

[section ""data" . Text.Printf.formatChar1_closure" {
     Text.Printf.formatChar1_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.formatChar2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.051767743 UTC

[section ""data" . Text.Printf.$wformatChar_closure" {
     Text.Printf.$wformatChar_closure:
         const Text.Printf.$wformatChar_info;
         const 0;
 },
 Text.Printf.$wformatChar_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdB9: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatChar_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccrk_entry() //  [R1]
         { info_tbl: [(ccdBm,
                       label: sat_sccrk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdBm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccdBn; else goto ccdBo;
       ccdBn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdBo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccdBj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucdBt; else goto ccdBk;
       ucdBt: // global
           call _ccdBj(R1) args: 0, res: 0, upd: 0;
       ccdBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdBj() //  [R1]
         { info_tbl: [(ccdBj,
                       label: block_ccdBj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdBj: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccro_entry() //  [R1]
         { info_tbl: [(ccdBC,
                       label: sat_sccro_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdBC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccdBD; else goto ccdBE;
       ccdBD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdBE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccdBz_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucdBJ; else goto ccdBA;
       ucdBJ: // global
           call _ccdBz(R1) args: 0, res: 0, upd: 0;
       ccdBA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdBz() //  [R1]
         { info_tbl: [(ccdBz,
                       label: block_ccdBz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdBz: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$wformatChar_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdBN,
                       label: Text.Printf.$wformatChar_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdBN: // global
           _sccrc::P64 = R6;
           _sccrb::P64 = R5;
           _sccra::P64 = R4;
           _sccr9::P64 = R3;
           _sccr8::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccdBO; else goto ccdBP;
       ccdBP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdBR; else goto ccdBQ;
       ccdBR: // global
           HpAlloc = 24;
           goto ccdBO;
       ccdBO: // global
           R1 = Text.Printf.$wformatChar_closure;
           P64[Sp - 40] = _sccr8::P64;
           P64[Sp - 32] = _sccr9::P64;
           P64[Sp - 24] = _sccra::P64;
           P64[Sp - 16] = _sccrb::P64;
           P64[Sp - 8] = _sccrc::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccdBQ: // global
           _sccrg::I64 = I64[Sp + 16];
           if (_sccrg::I64 != 118) goto ccdBL; else goto ccdBM;
       ccdBL: // global
           I64[Hp - 16] = sat_sccrk_info;
           P64[Hp] = _sccr8::P64;
           R6 = _sccrb::P64;
           R5 = _sccra::P64;
           R4 = _sccr9::P64;
           R3 = Hp - 16;
           R2 = Text.Printf.formatChar1_closure+2;
           P64[Sp - 8] = _sccrc::P64;
           I64[Sp + 16] = _sccrg::I64;
           Sp = Sp - 8;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
       ccdBM: // global
           I64[Hp - 16] = sat_sccro_info;
           P64[Hp] = _sccr8::P64;
           R6 = _sccrb::P64;
           R5 = _sccra::P64;
           R4 = _sccr9::P64;
           R3 = Hp - 16;
           R2 = Text.Printf.formatChar1_closure+2;
           P64[Sp - 8] = _sccrc::P64;
           I64[Sp + 16] = 99;
           Sp = Sp - 8;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.054328193 UTC

[section ""data" . Text.Printf.formatChar_closure" {
     Text.Printf.formatChar_closure:
         const Text.Printf.formatChar_info;
         const 0;
 },
 Text.Printf.formatChar_entry() //  [R2, R3]
         { info_tbl: [(ccdBZ,
                       label: Text.Printf.formatChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdBZ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdC3; else goto ccdC4;
       ccdC3: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdC4: // global
           I64[Sp - 16] = block_ccdBW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdCc; else goto ccdBX;
       ucdCc: // global
           call _ccdBW(R1) args: 0, res: 0, upd: 0;
       ccdBX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdBW() //  [R1]
         { info_tbl: [(ccdBW,
                       label: block_ccdBW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdBW: // global
           I64[Sp - 48] = block_ccdC2_info;
           _sccrs::P64 = P64[R1 + 7];
           _sccrt::P64 = P64[R1 + 15];
           _sccru::P64 = P64[R1 + 23];
           _sccrv::P64 = P64[R1 + 31];
           _sccrw::P64 = P64[R1 + 39];
           _sccrx::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccrt::P64;
           P64[Sp - 32] = _sccru::P64;
           P64[Sp - 24] = _sccrv::P64;
           P64[Sp - 16] = _sccrw::P64;
           P64[Sp - 8] = _sccrx::P64;
           P64[Sp] = _sccrs::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdCb; else goto ccdC6;
       ucdCb: // global
           call _ccdC2(R1) args: 0, res: 0, upd: 0;
       ccdC6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdC2() //  [R1]
         { info_tbl: [(ccdC2,
                       label: block_ccdC2_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdC2: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccrx::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccrx::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatChar_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.055820346 UTC

[section ""data" . Text.Printf.$fPrintfArgChar_closure" {
     Text.Printf.$fPrintfArgChar_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.formatChar_closure+2;
         const Text.Printf.$fPrintfArgChar_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.056449635 UTC

[section ""data" . Text.Printf.$fPrintfArgWord1_closure" {
     Text.Printf.$fPrintfArgWord1_closure:
         const GHC.Types.C#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.058312057 UTC

[section ""data" . Text.Printf.$w$sformatInt3_closure" {
     Text.Printf.$w$sformatInt3_closure:
         const Text.Printf.$w$sformatInt3_info;
         const 0;
 },
 Text.Printf.$w$sformatInt3_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdCe: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt3_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccrZ_entry() //  [R1]
         { info_tbl: [(ccdCz,
                       label: sat_sccrZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdCz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdCA; else goto ccdCB;
       ccdCA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdCB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$fIntegralWord64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdDm_srtd" {
     ucdDm_srtd:
         const SccKB_srt+192;
         const 62;
         const 2305843009213693957;
 },
 sat_sccrY_entry() //  [R1]
         { info_tbl: [(ccdCN,
                       label: sat_sccrY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdCN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdCO; else goto ccdCP;
       ccdCO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdCP: // global
           I64[Sp - 8] = block_ccdCG_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdD8; else goto ccdCH;
       ucdD8: // global
           call _ccdCG(R1) args: 0, res: 0, upd: 0;
       ccdCH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdDn_srtd" {
     ucdDn_srtd:
         const SccKB_srt+192;
         const 62;
         const 2305843009213693957;
 },
 _ccdCG() //  [R1]
         { info_tbl: [(ccdCG,
                       label: block_ccdCG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdCG: // global
           if (R1 & 7 == 1) goto ccdCK; else goto ccdCL;
       ccdCK: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdCL: // global
           I64[Sp] = block_ccdCV_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdCV() //  [R1]
         { info_tbl: [(ccdCV,
                       label: block_ccdCV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdCV: // global
           if (R1 & 7 == 1) goto ccdD2; else goto ccdD6;
       ccdD2: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdD6: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdDo_srtd" {
     ucdDo_srtd:
         const SccKB_srt+192;
         const 65;
         const 11601272640106397697;
         const 1;
 },
 Text.Printf.$w$sformatInt3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdDc,
                       label: Text.Printf.$w$sformatInt3_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdDc: // global
           _sccrF::P64 = R6;
           _sccrE::P64 = R5;
           _sccrD::P64 = R4;
           _sccrC::P64 = R3;
           _sccrB::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto ccdDd; else goto ccdDe;
       ccdDe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccdDg; else goto ccdDf;
       ccdDg: // global
           HpAlloc = 16;
           goto ccdDd;
       ccdDd: // global
           R1 = Text.Printf.$w$sformatInt3_closure;
           P64[Sp - 40] = _sccrB::P64;
           P64[Sp - 32] = _sccrC::P64;
           P64[Sp - 24] = _sccrD::P64;
           P64[Sp - 16] = _sccrE::P64;
           P64[Sp - 8] = _sccrF::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccdDf: // global
           _sccrG::P64 = P64[Sp];
           _sccrH::P64 = P64[Sp + 8];
           _sccs0::I64 = I64[Sp + 16];
           if (_sccs0::I64 != 118) goto ccdDa; else goto ccdDb;
       ccdDa: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccs0::I64;
           _sccrQ::P64 = Hp - 7;
           _sccrP::P64 = _sccrH::P64;
           _sccrO::P64 = _sccrG::P64;
           _sccrN::P64 = _sccrF::P64;
           _sccrM::P64 = _sccrE::P64;
           _sccrL::P64 = _sccrD::P64;
           _sccrK::P64 = _sccrC::P64;
           goto sccrJ;
       ccdDb: // global
           Hp = Hp - 16;
           _sccrQ::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccrP::P64 = _sccrH::P64;
           _sccrO::P64 = _sccrG::P64;
           _sccrN::P64 = _sccrF::P64;
           _sccrM::P64 = _sccrE::P64;
           _sccrL::P64 = _sccrD::P64;
           _sccrK::P64 = _sccrC::P64;
           goto sccrJ;
       sccrJ: // global
           I64[Sp - 48] = block_ccdCq_info;
           R1 = _sccrQ::P64;
           P64[Sp - 40] = _sccrL::P64;
           P64[Sp - 32] = _sccrM::P64;
           P64[Sp - 24] = _sccrN::P64;
           P64[Sp - 16] = _sccrO::P64;
           P64[Sp - 8] = _sccrP::P64;
           P64[Sp] = _sccrK::P64;
           P64[Sp + 16] = _sccrB::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdDl; else goto ccdCr;
       ucdDl: // global
           call _ccdCq(R1) args: 0, res: 0, upd: 0;
       ccdCr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdDp_srtd" {
     ucdDp_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _ccdCq() //  [R1]
         { info_tbl: [(ccdCq,
                       label: block_ccdCq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdCq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdDk; else goto ccdDj;
       ccdDk: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdDj: // global
           _sccrS::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccrZ_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccrY_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccrP::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccrP::P64;
           I64[Sp + 64] = _sccrS::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.061735275 UTC

[section ""data" . Text.Printf.$fPrintfArgWord64_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord64_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord64_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord64_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccdDx,
                       label: Text.Printf.$fPrintfArgWord64_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdDx: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdDB; else goto ccdDC;
       ccdDB: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord64_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdDC: // global
           I64[Sp - 16] = block_ccdDu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdDK; else goto ccdDv;
       ucdDK: // global
           call _ccdDu(R1) args: 0, res: 0, upd: 0;
       ccdDv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdDu() //  [R1]
         { info_tbl: [(ccdDu,
                       label: block_ccdDu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdDu: // global
           I64[Sp - 48] = block_ccdDA_info;
           _sccs5::P64 = P64[R1 + 7];
           _sccs6::P64 = P64[R1 + 15];
           _sccs7::P64 = P64[R1 + 23];
           _sccs8::P64 = P64[R1 + 31];
           _sccs9::P64 = P64[R1 + 39];
           _sccsa::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccs6::P64;
           P64[Sp - 32] = _sccs7::P64;
           P64[Sp - 24] = _sccs8::P64;
           P64[Sp - 16] = _sccs9::P64;
           P64[Sp - 8] = _sccsa::P64;
           P64[Sp] = _sccs5::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdDJ; else goto ccdDE;
       ucdDJ: // global
           call _ccdDA(R1) args: 0, res: 0, upd: 0;
       ccdDE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdDA() //  [R1]
         { info_tbl: [(ccdDA,
                       label: block_ccdDA_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdDA: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccsa::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccsa::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt3_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.064323965 UTC

[section ""data" . Text.Printf.$w$sformatInt2_closure" {
     Text.Printf.$w$sformatInt2_closure:
         const Text.Printf.$w$sformatInt2_info;
         const 0;
 },
 Text.Printf.$w$sformatInt2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdDM: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt2_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccsC_entry() //  [R1]
         { info_tbl: [(ccdE7,
                       label: sat_sccsC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdE7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdE8; else goto ccdE9;
       ccdE8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdE9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdEU_srtd" {
     ucdEU_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sccsB_entry() //  [R1]
         { info_tbl: [(ccdEl,
                       label: sat_sccsB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdEl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdEm; else goto ccdEn;
       ccdEm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdEn: // global
           I64[Sp - 8] = block_ccdEe_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdEG; else goto ccdEf;
       ucdEG: // global
           call _ccdEe(R1) args: 0, res: 0, upd: 0;
       ccdEf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdEV_srtd" {
     ucdEV_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _ccdEe() //  [R1]
         { info_tbl: [(ccdEe,
                       label: block_ccdEe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdEe: // global
           if (R1 & 7 == 1) goto ccdEi; else goto ccdEj;
       ccdEi: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdEj: // global
           I64[Sp] = block_ccdEt_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdEt() //  [R1]
         { info_tbl: [(ccdEt,
                       label: block_ccdEt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdEt: // global
           if (R1 & 7 == 1) goto ccdEA; else goto ccdEE;
       ccdEA: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdEE: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdEW_srtd" {
     ucdEW_srtd:
         const SccKB_srt+192;
         const 67;
         const 11601272640106397697;
         const 4;
 },
 Text.Printf.$w$sformatInt2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdEK,
                       label: Text.Printf.$w$sformatInt2_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdEK: // global
           _sccsi::P64 = R6;
           _sccsh::P64 = R5;
           _sccsg::P64 = R4;
           _sccsf::P64 = R3;
           _sccse::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto ccdEL; else goto ccdEM;
       ccdEM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccdEO; else goto ccdEN;
       ccdEO: // global
           HpAlloc = 16;
           goto ccdEL;
       ccdEL: // global
           R1 = Text.Printf.$w$sformatInt2_closure;
           P64[Sp - 40] = _sccse::P64;
           P64[Sp - 32] = _sccsf::P64;
           P64[Sp - 24] = _sccsg::P64;
           P64[Sp - 16] = _sccsh::P64;
           P64[Sp - 8] = _sccsi::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccdEN: // global
           _sccsj::P64 = P64[Sp];
           _sccsk::P64 = P64[Sp + 8];
           _sccsD::I64 = I64[Sp + 16];
           if (_sccsD::I64 != 118) goto ccdEI; else goto ccdEJ;
       ccdEI: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccsD::I64;
           _sccst::P64 = Hp - 7;
           _sccss::P64 = _sccsk::P64;
           _sccsr::P64 = _sccsj::P64;
           _sccsq::P64 = _sccsi::P64;
           _sccsp::P64 = _sccsh::P64;
           _sccso::P64 = _sccsg::P64;
           _sccsn::P64 = _sccsf::P64;
           goto sccsm;
       ccdEJ: // global
           Hp = Hp - 16;
           _sccst::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccss::P64 = _sccsk::P64;
           _sccsr::P64 = _sccsj::P64;
           _sccsq::P64 = _sccsi::P64;
           _sccsp::P64 = _sccsh::P64;
           _sccso::P64 = _sccsg::P64;
           _sccsn::P64 = _sccsf::P64;
           goto sccsm;
       sccsm: // global
           I64[Sp - 48] = block_ccdDY_info;
           R1 = _sccst::P64;
           P64[Sp - 40] = _sccso::P64;
           P64[Sp - 32] = _sccsp::P64;
           P64[Sp - 24] = _sccsq::P64;
           P64[Sp - 16] = _sccsr::P64;
           P64[Sp - 8] = _sccss::P64;
           P64[Sp] = _sccsn::P64;
           P64[Sp + 16] = _sccse::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdET; else goto ccdDZ;
       ucdET: // global
           call _ccdDY(R1) args: 0, res: 0, upd: 0;
       ccdDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdEX_srtd" {
     ucdEX_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _ccdDY() //  [R1]
         { info_tbl: [(ccdDY,
                       label: block_ccdDY_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdDY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdES; else goto ccdER;
       ccdES: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdER: // global
           _sccsv::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccsC_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccsB_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccss::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccss::P64;
           I64[Sp + 64] = _sccsv::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.067800115 UTC

[section ""data" . Text.Printf.$fPrintfArgWord32_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord32_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord32_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord32_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccdF5,
                       label: Text.Printf.$fPrintfArgWord32_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdF5: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdF9; else goto ccdFa;
       ccdF9: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord32_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdFa: // global
           I64[Sp - 16] = block_ccdF2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdFi; else goto ccdF3;
       ucdFi: // global
           call _ccdF2(R1) args: 0, res: 0, upd: 0;
       ccdF3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdF2() //  [R1]
         { info_tbl: [(ccdF2,
                       label: block_ccdF2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdF2: // global
           I64[Sp - 48] = block_ccdF8_info;
           _sccsI::P64 = P64[R1 + 7];
           _sccsJ::P64 = P64[R1 + 15];
           _sccsK::P64 = P64[R1 + 23];
           _sccsL::P64 = P64[R1 + 31];
           _sccsM::P64 = P64[R1 + 39];
           _sccsN::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccsJ::P64;
           P64[Sp - 32] = _sccsK::P64;
           P64[Sp - 24] = _sccsL::P64;
           P64[Sp - 16] = _sccsM::P64;
           P64[Sp - 8] = _sccsN::P64;
           P64[Sp] = _sccsI::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdFh; else goto ccdFc;
       ucdFh: // global
           call _ccdF8(R1) args: 0, res: 0, upd: 0;
       ccdFc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdF8() //  [R1]
         { info_tbl: [(ccdF8,
                       label: block_ccdF8_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdF8: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccsN::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccsN::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt2_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.070419959 UTC

[section ""data" . Text.Printf.$w$sformatInt1_closure" {
     Text.Printf.$w$sformatInt1_closure:
         const Text.Printf.$w$sformatInt1_info;
         const 0;
 },
 Text.Printf.$w$sformatInt1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdFk: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt1_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_scctf_entry() //  [R1]
         { info_tbl: [(ccdFF,
                       label: sat_scctf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdFF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdFG; else goto ccdFH;
       ccdFG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdFH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdGs_srtd" {
     ucdGs_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sccte_entry() //  [R1]
         { info_tbl: [(ccdFT,
                       label: sat_sccte_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdFT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdFU; else goto ccdFV;
       ccdFU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdFV: // global
           I64[Sp - 8] = block_ccdFM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdGe; else goto ccdFN;
       ucdGe: // global
           call _ccdFM(R1) args: 0, res: 0, upd: 0;
       ccdFN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdGt_srtd" {
     ucdGt_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _ccdFM() //  [R1]
         { info_tbl: [(ccdFM,
                       label: block_ccdFM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdFM: // global
           if (R1 & 7 == 1) goto ccdFQ; else goto ccdFR;
       ccdFQ: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdFR: // global
           I64[Sp] = block_ccdG1_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdG1() //  [R1]
         { info_tbl: [(ccdG1,
                       label: block_ccdG1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdG1: // global
           if (R1 & 7 == 1) goto ccdG8; else goto ccdGc;
       ccdG8: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdGc: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdGu_srtd" {
     ucdGu_srtd:
         const SccKB_srt+192;
         const 69;
         const 11601272640106397697;
         const 16;
 },
 Text.Printf.$w$sformatInt1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdGi,
                       label: Text.Printf.$w$sformatInt1_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdGi: // global
           _sccsV::P64 = R6;
           _sccsU::P64 = R5;
           _sccsT::P64 = R4;
           _sccsS::P64 = R3;
           _sccsR::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto ccdGj; else goto ccdGk;
       ccdGk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccdGm; else goto ccdGl;
       ccdGm: // global
           HpAlloc = 16;
           goto ccdGj;
       ccdGj: // global
           R1 = Text.Printf.$w$sformatInt1_closure;
           P64[Sp - 40] = _sccsR::P64;
           P64[Sp - 32] = _sccsS::P64;
           P64[Sp - 24] = _sccsT::P64;
           P64[Sp - 16] = _sccsU::P64;
           P64[Sp - 8] = _sccsV::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccdGl: // global
           _sccsW::P64 = P64[Sp];
           _sccsX::P64 = P64[Sp + 8];
           _scctg::I64 = I64[Sp + 16];
           if (_scctg::I64 != 118) goto ccdGg; else goto ccdGh;
       ccdGg: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _scctg::I64;
           _scct6::P64 = Hp - 7;
           _scct5::P64 = _sccsX::P64;
           _scct4::P64 = _sccsW::P64;
           _scct3::P64 = _sccsV::P64;
           _scct2::P64 = _sccsU::P64;
           _scct1::P64 = _sccsT::P64;
           _scct0::P64 = _sccsS::P64;
           goto sccsZ;
       ccdGh: // global
           Hp = Hp - 16;
           _scct6::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _scct5::P64 = _sccsX::P64;
           _scct4::P64 = _sccsW::P64;
           _scct3::P64 = _sccsV::P64;
           _scct2::P64 = _sccsU::P64;
           _scct1::P64 = _sccsT::P64;
           _scct0::P64 = _sccsS::P64;
           goto sccsZ;
       sccsZ: // global
           I64[Sp - 48] = block_ccdFw_info;
           R1 = _scct6::P64;
           P64[Sp - 40] = _scct1::P64;
           P64[Sp - 32] = _scct2::P64;
           P64[Sp - 24] = _scct3::P64;
           P64[Sp - 16] = _scct4::P64;
           P64[Sp - 8] = _scct5::P64;
           P64[Sp] = _scct0::P64;
           P64[Sp + 16] = _sccsR::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdGr; else goto ccdFx;
       ucdGr: // global
           call _ccdFw(R1) args: 0, res: 0, upd: 0;
       ccdFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdGv_srtd" {
     ucdGv_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _ccdFw() //  [R1]
         { info_tbl: [(ccdFw,
                       label: block_ccdFw_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdFw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdGq; else goto ccdGp;
       ccdGq: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdGp: // global
           _scct8::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_scctf_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccte_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _scct5::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _scct5::P64;
           I64[Sp + 64] = _scct8::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.076970561 UTC

[section ""data" . Text.Printf.$fPrintfArgWord16_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord16_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord16_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord16_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccdGD,
                       label: Text.Printf.$fPrintfArgWord16_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdGD: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdGH; else goto ccdGI;
       ccdGH: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord16_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdGI: // global
           I64[Sp - 16] = block_ccdGA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdGQ; else goto ccdGB;
       ucdGQ: // global
           call _ccdGA(R1) args: 0, res: 0, upd: 0;
       ccdGB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdGA() //  [R1]
         { info_tbl: [(ccdGA,
                       label: block_ccdGA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdGA: // global
           I64[Sp - 48] = block_ccdGG_info;
           _scctl::P64 = P64[R1 + 7];
           _scctm::P64 = P64[R1 + 15];
           _scctn::P64 = P64[R1 + 23];
           _sccto::P64 = P64[R1 + 31];
           _scctp::P64 = P64[R1 + 39];
           _scctq::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _scctm::P64;
           P64[Sp - 32] = _scctn::P64;
           P64[Sp - 24] = _sccto::P64;
           P64[Sp - 16] = _scctp::P64;
           P64[Sp - 8] = _scctq::P64;
           P64[Sp] = _scctl::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdGP; else goto ccdGK;
       ucdGP: // global
           call _ccdGG(R1) args: 0, res: 0, upd: 0;
       ccdGK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdGG() //  [R1]
         { info_tbl: [(ccdGG,
                       label: block_ccdGG_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdGG: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _scctq::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _scctq::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt1_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.079580049 UTC

[section ""data" . Text.Printf.$w$sformatInt4_closure" {
     Text.Printf.$w$sformatInt4_closure:
         const Text.Printf.$w$sformatInt4_info;
         const 0;
 },
 Text.Printf.$w$sformatInt4_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdGS: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt4_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_scctS_entry() //  [R1]
         { info_tbl: [(ccdHd,
                       label: sat_scctS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdHd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdHe; else goto ccdHf;
       ccdHe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdHf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdI0_srtd" {
     ucdI0_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_scctR_entry() //  [R1]
         { info_tbl: [(ccdHr,
                       label: sat_scctR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdHr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdHs; else goto ccdHt;
       ccdHs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdHt: // global
           I64[Sp - 8] = block_ccdHk_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdHM; else goto ccdHl;
       ucdHM: // global
           call _ccdHk(R1) args: 0, res: 0, upd: 0;
       ccdHl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdI1_srtd" {
     ucdI1_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _ccdHk() //  [R1]
         { info_tbl: [(ccdHk,
                       label: block_ccdHk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdHk: // global
           if (R1 & 7 == 1) goto ccdHo; else goto ccdHp;
       ccdHo: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdHp: // global
           I64[Sp] = block_ccdHz_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdHz() //  [R1]
         { info_tbl: [(ccdHz,
                       label: block_ccdHz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdHz: // global
           if (R1 & 7 == 1) goto ccdHG; else goto ccdHK;
       ccdHG: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdHK: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdI2_srtd" {
     ucdI2_srtd:
         const SccKB_srt+192;
         const 71;
         const 11601272640106397697;
         const 64;
 },
 Text.Printf.$w$sformatInt4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdHQ,
                       label: Text.Printf.$w$sformatInt4_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdHQ: // global
           _sccty::P64 = R6;
           _scctx::P64 = R5;
           _scctw::P64 = R4;
           _scctv::P64 = R3;
           _scctu::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto ccdHR; else goto ccdHS;
       ccdHS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccdHU; else goto ccdHT;
       ccdHU: // global
           HpAlloc = 16;
           goto ccdHR;
       ccdHR: // global
           R1 = Text.Printf.$w$sformatInt4_closure;
           P64[Sp - 40] = _scctu::P64;
           P64[Sp - 32] = _scctv::P64;
           P64[Sp - 24] = _scctw::P64;
           P64[Sp - 16] = _scctx::P64;
           P64[Sp - 8] = _sccty::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccdHT: // global
           _scctz::P64 = P64[Sp];
           _scctA::P64 = P64[Sp + 8];
           _scctT::I64 = I64[Sp + 16];
           if (_scctT::I64 != 118) goto ccdHO; else goto ccdHP;
       ccdHO: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _scctT::I64;
           _scctJ::P64 = Hp - 7;
           _scctI::P64 = _scctA::P64;
           _scctH::P64 = _scctz::P64;
           _scctG::P64 = _sccty::P64;
           _scctF::P64 = _scctx::P64;
           _scctE::P64 = _scctw::P64;
           _scctD::P64 = _scctv::P64;
           goto scctC;
       ccdHP: // global
           Hp = Hp - 16;
           _scctJ::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _scctI::P64 = _scctA::P64;
           _scctH::P64 = _scctz::P64;
           _scctG::P64 = _sccty::P64;
           _scctF::P64 = _scctx::P64;
           _scctE::P64 = _scctw::P64;
           _scctD::P64 = _scctv::P64;
           goto scctC;
       scctC: // global
           I64[Sp - 48] = block_ccdH4_info;
           R1 = _scctJ::P64;
           P64[Sp - 40] = _scctE::P64;
           P64[Sp - 32] = _scctF::P64;
           P64[Sp - 24] = _scctG::P64;
           P64[Sp - 16] = _scctH::P64;
           P64[Sp - 8] = _scctI::P64;
           P64[Sp] = _scctD::P64;
           P64[Sp + 16] = _scctu::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdHZ; else goto ccdH5;
       ucdHZ: // global
           call _ccdH4(R1) args: 0, res: 0, upd: 0;
       ccdH5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdI3_srtd" {
     ucdI3_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _ccdH4() //  [R1]
         { info_tbl: [(ccdH4,
                       label: block_ccdH4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdH4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdHY; else goto ccdHX;
       ccdHY: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdHX: // global
           _scctL::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_scctS_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_scctR_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _scctI::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _scctI::P64;
           I64[Sp + 64] = _scctL::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.082955597 UTC

[section ""data" . Text.Printf.$fPrintfArgWord8_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord8_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord8_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord8_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccdIb,
                       label: Text.Printf.$fPrintfArgWord8_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdIb: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdIf; else goto ccdIg;
       ccdIf: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord8_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdIg: // global
           I64[Sp - 16] = block_ccdI8_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdIo; else goto ccdI9;
       ucdIo: // global
           call _ccdI8(R1) args: 0, res: 0, upd: 0;
       ccdI9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdI8() //  [R1]
         { info_tbl: [(ccdI8,
                       label: block_ccdI8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdI8: // global
           I64[Sp - 48] = block_ccdIe_info;
           _scctY::P64 = P64[R1 + 7];
           _scctZ::P64 = P64[R1 + 15];
           _sccu0::P64 = P64[R1 + 23];
           _sccu1::P64 = P64[R1 + 31];
           _sccu2::P64 = P64[R1 + 39];
           _sccu3::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _scctZ::P64;
           P64[Sp - 32] = _sccu0::P64;
           P64[Sp - 24] = _sccu1::P64;
           P64[Sp - 16] = _sccu2::P64;
           P64[Sp - 8] = _sccu3::P64;
           P64[Sp] = _scctY::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdIn; else goto ccdIi;
       ucdIn: // global
           call _ccdIe(R1) args: 0, res: 0, upd: 0;
       ccdIi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdIe() //  [R1]
         { info_tbl: [(ccdIe,
                       label: block_ccdIe_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdIe: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccu3::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccu3::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt4_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.085527001 UTC

[section ""data" . Text.Printf.$w$sformatInt_closure" {
     Text.Printf.$w$sformatInt_closure:
         const Text.Printf.$w$sformatInt_info;
         const 0;
 },
 Text.Printf.$w$sformatInt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdIq: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt_entry(R6,
                                                R5,
                                                R4,
                                                R3,
                                                R2,
                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccuv_entry() //  [R1]
         { info_tbl: [(ccdIL,
                       label: sat_sccuv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdIL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdIM; else goto ccdIN;
       ccdIM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdIN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fIntegralWord_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdJy_srtd" {
     ucdJy_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sccuu_entry() //  [R1]
         { info_tbl: [(ccdIZ,
                       label: sat_sccuu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdIZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdJ0; else goto ccdJ1;
       ccdJ0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdJ1: // global
           I64[Sp - 8] = block_ccdIS_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdJk; else goto ccdIT;
       ucdJk: // global
           call _ccdIS(R1) args: 0, res: 0, upd: 0;
       ccdIT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdJz_srtd" {
     ucdJz_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _ccdIS() //  [R1]
         { info_tbl: [(ccdIS,
                       label: block_ccdIS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdIS: // global
           if (R1 & 7 == 1) goto ccdIW; else goto ccdIX;
       ccdIW: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdIX: // global
           I64[Sp] = block_ccdJ7_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdJ7() //  [R1]
         { info_tbl: [(ccdJ7,
                       label: block_ccdJ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdJ7: // global
           if (R1 & 7 == 1) goto ccdJe; else goto ccdJi;
       ccdJe: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdJi: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdJA_srtd" {
     ucdJA_srtd:
         const SccKB_srt+192;
         const 73;
         const 11601272640106397697;
         const 256;
 },
 Text.Printf.$w$sformatInt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdJo,
                       label: Text.Printf.$w$sformatInt_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdJo: // global
           _sccub::P64 = R6;
           _sccua::P64 = R5;
           _sccu9::P64 = R4;
           _sccu8::P64 = R3;
           _sccu7::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto ccdJp; else goto ccdJq;
       ccdJq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccdJs; else goto ccdJr;
       ccdJs: // global
           HpAlloc = 16;
           goto ccdJp;
       ccdJp: // global
           R1 = Text.Printf.$w$sformatInt_closure;
           P64[Sp - 40] = _sccu7::P64;
           P64[Sp - 32] = _sccu8::P64;
           P64[Sp - 24] = _sccu9::P64;
           P64[Sp - 16] = _sccua::P64;
           P64[Sp - 8] = _sccub::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccdJr: // global
           _sccuc::P64 = P64[Sp];
           _sccud::P64 = P64[Sp + 8];
           _sccuw::I64 = I64[Sp + 16];
           if (_sccuw::I64 != 118) goto ccdJm; else goto ccdJn;
       ccdJm: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccuw::I64;
           _sccum::P64 = Hp - 7;
           _sccul::P64 = _sccud::P64;
           _sccuk::P64 = _sccuc::P64;
           _sccuj::P64 = _sccub::P64;
           _sccui::P64 = _sccua::P64;
           _sccuh::P64 = _sccu9::P64;
           _sccug::P64 = _sccu8::P64;
           goto sccuf;
       ccdJn: // global
           Hp = Hp - 16;
           _sccum::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccul::P64 = _sccud::P64;
           _sccuk::P64 = _sccuc::P64;
           _sccuj::P64 = _sccub::P64;
           _sccui::P64 = _sccua::P64;
           _sccuh::P64 = _sccu9::P64;
           _sccug::P64 = _sccu8::P64;
           goto sccuf;
       sccuf: // global
           I64[Sp - 48] = block_ccdIC_info;
           R1 = _sccum::P64;
           P64[Sp - 40] = _sccuh::P64;
           P64[Sp - 32] = _sccui::P64;
           P64[Sp - 24] = _sccuj::P64;
           P64[Sp - 16] = _sccuk::P64;
           P64[Sp - 8] = _sccul::P64;
           P64[Sp] = _sccug::P64;
           P64[Sp + 16] = _sccu7::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdJx; else goto ccdID;
       ucdJx: // global
           call _ccdIC(R1) args: 0, res: 0, upd: 0;
       ccdID: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdJB_srtd" {
     ucdJB_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _ccdIC() //  [R1]
         { info_tbl: [(ccdIC,
                       label: block_ccdIC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdIC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdJw; else goto ccdJv;
       ccdJw: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdJv: // global
           _sccuo::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccuv_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccuu_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccul::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccul::P64;
           I64[Sp + 64] = _sccuo::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.088869787 UTC

[section ""data" . Text.Printf.$fPrintfArgWord_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccdJJ,
                       label: Text.Printf.$fPrintfArgWord_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdJJ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdJN; else goto ccdJO;
       ccdJN: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdJO: // global
           I64[Sp - 16] = block_ccdJG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdJW; else goto ccdJH;
       ucdJW: // global
           call _ccdJG(R1) args: 0, res: 0, upd: 0;
       ccdJH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdJG() //  [R1]
         { info_tbl: [(ccdJG,
                       label: block_ccdJG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdJG: // global
           I64[Sp - 48] = block_ccdJM_info;
           _sccuB::P64 = P64[R1 + 7];
           _sccuC::P64 = P64[R1 + 15];
           _sccuD::P64 = P64[R1 + 23];
           _sccuE::P64 = P64[R1 + 31];
           _sccuF::P64 = P64[R1 + 39];
           _sccuG::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccuC::P64;
           P64[Sp - 32] = _sccuD::P64;
           P64[Sp - 24] = _sccuE::P64;
           P64[Sp - 16] = _sccuF::P64;
           P64[Sp - 8] = _sccuG::P64;
           P64[Sp] = _sccuB::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdJV; else goto ccdJQ;
       ucdJV: // global
           call _ccdJM(R1) args: 0, res: 0, upd: 0;
       ccdJQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdJM() //  [R1]
         { info_tbl: [(ccdJM,
                       label: block_ccdJM_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdJM: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccuG::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccuG::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt_entry(R6,
                                                R5,
                                                R4,
                                                R3,
                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.090326956 UTC

[section ""data" . Text.Printf.$fPrintfArgInt1_closure" {
     Text.Printf.$fPrintfArgInt1_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.091801792 UTC

[section ""data" . Text.Printf.$fPrintfArgInt64_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt64_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt64_$sformatInt_info;
         const 0;
 },
 sat_sccv2_entry() //  [R1]
         { info_tbl: [(ccdKf,
                       label: sat_sccv2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdKf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdKg; else goto ccdKh;
       ccdKg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdKh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdKY_srtd" {
     ucdKY_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 sat_sccv1_entry() //  [R1]
         { info_tbl: [(ccdKt,
                       label: sat_sccv1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdKt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdKu; else goto ccdKv;
       ccdKu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdKv: // global
           I64[Sp - 8] = block_ccdKm_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdKO; else goto ccdKn;
       ucdKO: // global
           call _ccdKm(R1) args: 0, res: 0, upd: 0;
       ccdKn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdKZ_srtd" {
     ucdKZ_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 _ccdKm() //  [R1]
         { info_tbl: [(ccdKm,
                       label: block_ccdKm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdKm: // global
           if (R1 & 7 == 1) goto ccdKq; else goto ccdKr;
       ccdKq: // global
           R1 = Text.Printf.$fPrintfArgInt1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdKr: // global
           I64[Sp] = block_ccdKB_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdKB() //  [R1]
         { info_tbl: [(ccdKB,
                       label: block_ccdKB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdKB: // global
           if (R1 & 7 == 1) goto ccdKI; else goto ccdKM;
       ccdKI: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdKM: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdL0_srtd" {
     ucdL0_srtd:
         const SccKB_srt+192;
         const 76;
         const 9295429630892703745;
         const 3072;
 },
 Text.Printf.$fPrintfArgInt64_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccdKP,
                       label: Text.Printf.$fPrintfArgInt64_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdKP: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdKQ; else goto ccdKR;
       ccdKQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt64_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdKR: // global
           I64[Sp - 16] = block_ccdK1_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdKX; else goto ccdK2;
       ucdKX: // global
           call _ccdK1(R1) args: 0, res: 0, upd: 0;
       ccdK2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdL1_srtd" {
     ucdL1_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _ccdK1() //  [R1]
         { info_tbl: [(ccdK1,
                       label: block_ccdK1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdK1: // global
           I64[Sp - 48] = block_ccdK6_info;
           _sccuN::P64 = P64[R1 + 7];
           _sccuO::P64 = P64[R1 + 15];
           _sccuP::P64 = P64[R1 + 23];
           _sccuQ::P64 = P64[R1 + 31];
           _sccuR::P64 = P64[R1 + 39];
           _sccuS::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccuO::P64;
           P64[Sp - 32] = _sccuP::P64;
           P64[Sp - 24] = _sccuQ::P64;
           P64[Sp - 16] = _sccuR::P64;
           P64[Sp - 8] = _sccuS::P64;
           P64[Sp] = _sccuN::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdKW; else goto ccdK7;
       ucdKW: // global
           call _ccdK6(R1) args: 0, res: 0, upd: 0;
       ccdK7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdL2_srtd" {
     ucdL2_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _ccdK6() //  [R1]
         { info_tbl: [(ccdK6,
                       label: block_ccdK6_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdK6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdKV; else goto ccdKU;
       ccdKV: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdKU: // global
           _sccuV::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccv2_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccv1_info;
           _sccuS::P64 = P64[Sp + 40];
           P64[Hp] = _sccuS::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccuR::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccuR::P64;
           P64[Sp + 48] = _sccuS::P64;
           I64[Sp + 56] = _sccuV::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.094572123 UTC

[section ""data" . Text.Printf.$fPrintfArgInt4_closure" {
     Text.Printf.$fPrintfArgInt4_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.096013474 UTC

[section ""data" . Text.Printf.$fPrintfArgInt32_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt32_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt32_$sformatInt_info;
         const 0;
 },
 sat_sccvl_entry() //  [R1]
         { info_tbl: [(ccdLl,
                       label: sat_sccvl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdLl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdLm; else goto ccdLn;
       ccdLm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdLn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt32_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdM4_srtd" {
     ucdM4_srtd:
         const SccKB_srt+192;
         const 77;
         const 9223372036854775809;
         const 4096;
 },
 sat_sccvk_entry() //  [R1]
         { info_tbl: [(ccdLz,
                       label: sat_sccvk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdLz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdLA; else goto ccdLB;
       ccdLA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdLB: // global
           I64[Sp - 8] = block_ccdLs_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdLU; else goto ccdLt;
       ucdLU: // global
           call _ccdLs(R1) args: 0, res: 0, upd: 0;
       ccdLt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdM5_srtd" {
     ucdM5_srtd:
         const SccKB_srt+192;
         const 77;
         const 9223372036854775809;
         const 4096;
 },
 _ccdLs() //  [R1]
         { info_tbl: [(ccdLs,
                       label: block_ccdLs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdLs: // global
           if (R1 & 7 == 1) goto ccdLw; else goto ccdLx;
       ccdLw: // global
           R1 = Text.Printf.$fPrintfArgInt4_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdLx: // global
           I64[Sp] = block_ccdLH_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdLH() //  [R1]
         { info_tbl: [(ccdLH,
                       label: block_ccdLH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdLH: // global
           if (R1 & 7 == 1) goto ccdLO; else goto ccdLS;
       ccdLO: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdLS: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdM6_srtd" {
     ucdM6_srtd:
         const SccKB_srt+192;
         const 78;
         const 9295429630892703745;
         const 12288;
 },
 Text.Printf.$fPrintfArgInt32_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccdLV,
                       label: Text.Printf.$fPrintfArgInt32_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdLV: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdLW; else goto ccdLX;
       ccdLW: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt32_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdLX: // global
           I64[Sp - 16] = block_ccdL7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdM3; else goto ccdL8;
       ucdM3: // global
           call _ccdL7(R1) args: 0, res: 0, upd: 0;
       ccdL8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdM7_srtd" {
     ucdM7_srtd:
         const SccKB_srt+192;
         const 77;
         const 9295429630892703745;
         const 4096;
 },
 _ccdL7() //  [R1]
         { info_tbl: [(ccdL7,
                       label: block_ccdL7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdL7: // global
           I64[Sp - 48] = block_ccdLc_info;
           _sccv6::P64 = P64[R1 + 7];
           _sccv7::P64 = P64[R1 + 15];
           _sccv8::P64 = P64[R1 + 23];
           _sccv9::P64 = P64[R1 + 31];
           _sccva::P64 = P64[R1 + 39];
           _sccvb::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccv7::P64;
           P64[Sp - 32] = _sccv8::P64;
           P64[Sp - 24] = _sccv9::P64;
           P64[Sp - 16] = _sccva::P64;
           P64[Sp - 8] = _sccvb::P64;
           P64[Sp] = _sccv6::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdM2; else goto ccdLd;
       ucdM2: // global
           call _ccdLc(R1) args: 0, res: 0, upd: 0;
       ccdLd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdM8_srtd" {
     ucdM8_srtd:
         const SccKB_srt+192;
         const 77;
         const 9295429630892703745;
         const 4096;
 },
 _ccdLc() //  [R1]
         { info_tbl: [(ccdLc,
                       label: block_ccdLc_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdLc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdM1; else goto ccdM0;
       ccdM1: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdM0: // global
           _sccve::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccvl_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccvk_info;
           _sccvb::P64 = P64[Sp + 40];
           P64[Hp] = _sccvb::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccva::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccva::P64;
           P64[Sp + 48] = _sccvb::P64;
           I64[Sp + 56] = _sccve::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.098752217 UTC

[section ""data" . Text.Printf.$fPrintfArgInt3_closure" {
     Text.Printf.$fPrintfArgInt3_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.100253419 UTC

[section ""data" . Text.Printf.$fPrintfArgInt16_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt16_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt16_$sformatInt_info;
         const 0;
 },
 sat_sccvE_entry() //  [R1]
         { info_tbl: [(ccdMr,
                       label: sat_sccvE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdMr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdMs; else goto ccdMt;
       ccdMs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdMt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt16_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdNa_srtd" {
     ucdNa_srtd:
         const SccKB_srt+192;
         const 79;
         const 9223372036854775809;
         const 16384;
 },
 sat_sccvD_entry() //  [R1]
         { info_tbl: [(ccdMF,
                       label: sat_sccvD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdMF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdMG; else goto ccdMH;
       ccdMG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdMH: // global
           I64[Sp - 8] = block_ccdMy_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdN0; else goto ccdMz;
       ucdN0: // global
           call _ccdMy(R1) args: 0, res: 0, upd: 0;
       ccdMz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdNb_srtd" {
     ucdNb_srtd:
         const SccKB_srt+192;
         const 79;
         const 9223372036854775809;
         const 16384;
 },
 _ccdMy() //  [R1]
         { info_tbl: [(ccdMy,
                       label: block_ccdMy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdMy: // global
           if (R1 & 7 == 1) goto ccdMC; else goto ccdMD;
       ccdMC: // global
           R1 = Text.Printf.$fPrintfArgInt3_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdMD: // global
           I64[Sp] = block_ccdMN_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdMN() //  [R1]
         { info_tbl: [(ccdMN,
                       label: block_ccdMN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdMN: // global
           if (R1 & 7 == 1) goto ccdMU; else goto ccdMY;
       ccdMU: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdMY: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdNc_srtd" {
     ucdNc_srtd:
         const SccKB_srt+192;
         const 80;
         const 9295429630892703745;
         const 49152;
 },
 Text.Printf.$fPrintfArgInt16_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccdN1,
                       label: Text.Printf.$fPrintfArgInt16_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdN1: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdN2; else goto ccdN3;
       ccdN2: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt16_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdN3: // global
           I64[Sp - 16] = block_ccdMd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdN9; else goto ccdMe;
       ucdN9: // global
           call _ccdMd(R1) args: 0, res: 0, upd: 0;
       ccdMe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdNd_srtd" {
     ucdNd_srtd:
         const SccKB_srt+192;
         const 79;
         const 9295429630892703745;
         const 16384;
 },
 _ccdMd() //  [R1]
         { info_tbl: [(ccdMd,
                       label: block_ccdMd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdMd: // global
           I64[Sp - 48] = block_ccdMi_info;
           _sccvp::P64 = P64[R1 + 7];
           _sccvq::P64 = P64[R1 + 15];
           _sccvr::P64 = P64[R1 + 23];
           _sccvs::P64 = P64[R1 + 31];
           _sccvt::P64 = P64[R1 + 39];
           _sccvu::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccvq::P64;
           P64[Sp - 32] = _sccvr::P64;
           P64[Sp - 24] = _sccvs::P64;
           P64[Sp - 16] = _sccvt::P64;
           P64[Sp - 8] = _sccvu::P64;
           P64[Sp] = _sccvp::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdN8; else goto ccdMj;
       ucdN8: // global
           call _ccdMi(R1) args: 0, res: 0, upd: 0;
       ccdMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdNe_srtd" {
     ucdNe_srtd:
         const SccKB_srt+192;
         const 79;
         const 9295429630892703745;
         const 16384;
 },
 _ccdMi() //  [R1]
         { info_tbl: [(ccdMi,
                       label: block_ccdMi_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdMi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdN7; else goto ccdN6;
       ccdN7: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdN6: // global
           _sccvx::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccvE_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccvD_info;
           _sccvu::P64 = P64[Sp + 40];
           P64[Hp] = _sccvu::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccvt::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccvt::P64;
           P64[Sp + 48] = _sccvu::P64;
           I64[Sp + 56] = _sccvx::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.103018324 UTC

[section ""data" . Text.Printf.$fPrintfArgInt5_closure" {
     Text.Printf.$fPrintfArgInt5_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar22_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.104527573 UTC

[section ""data" . Text.Printf.$fPrintfArgInt8_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt8_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt8_$sformatInt_info;
         const 0;
 },
 sat_sccvX_entry() //  [R1]
         { info_tbl: [(ccdNx,
                       label: sat_sccvX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdNx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdNy; else goto ccdNz;
       ccdNy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdNz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt8_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdOg_srtd" {
     ucdOg_srtd:
         const SccKB_srt+192;
         const 81;
         const 9223372036854775809;
         const 65536;
 },
 sat_sccvW_entry() //  [R1]
         { info_tbl: [(ccdNL,
                       label: sat_sccvW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdNL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdNM; else goto ccdNN;
       ccdNM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdNN: // global
           I64[Sp - 8] = block_ccdNE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdO6; else goto ccdNF;
       ucdO6: // global
           call _ccdNE(R1) args: 0, res: 0, upd: 0;
       ccdNF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdOh_srtd" {
     ucdOh_srtd:
         const SccKB_srt+192;
         const 81;
         const 9223372036854775809;
         const 65536;
 },
 _ccdNE() //  [R1]
         { info_tbl: [(ccdNE,
                       label: block_ccdNE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdNE: // global
           if (R1 & 7 == 1) goto ccdNI; else goto ccdNJ;
       ccdNI: // global
           R1 = Text.Printf.$fPrintfArgInt5_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdNJ: // global
           I64[Sp] = block_ccdNT_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdNT() //  [R1]
         { info_tbl: [(ccdNT,
                       label: block_ccdNT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdNT: // global
           if (R1 & 7 == 1) goto ccdO0; else goto ccdO4;
       ccdO0: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdO4: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdOi_srtd" {
     ucdOi_srtd:
         const SccKB_srt+192;
         const 82;
         const 9295429630892703745;
         const 196608;
 },
 Text.Printf.$fPrintfArgInt8_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccdO7,
                       label: Text.Printf.$fPrintfArgInt8_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdO7: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdO8; else goto ccdO9;
       ccdO8: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt8_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdO9: // global
           I64[Sp - 16] = block_ccdNj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdOf; else goto ccdNk;
       ucdOf: // global
           call _ccdNj(R1) args: 0, res: 0, upd: 0;
       ccdNk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdOj_srtd" {
     ucdOj_srtd:
         const SccKB_srt+192;
         const 81;
         const 9295429630892703745;
         const 65536;
 },
 _ccdNj() //  [R1]
         { info_tbl: [(ccdNj,
                       label: block_ccdNj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdNj: // global
           I64[Sp - 48] = block_ccdNo_info;
           _sccvI::P64 = P64[R1 + 7];
           _sccvJ::P64 = P64[R1 + 15];
           _sccvK::P64 = P64[R1 + 23];
           _sccvL::P64 = P64[R1 + 31];
           _sccvM::P64 = P64[R1 + 39];
           _sccvN::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccvJ::P64;
           P64[Sp - 32] = _sccvK::P64;
           P64[Sp - 24] = _sccvL::P64;
           P64[Sp - 16] = _sccvM::P64;
           P64[Sp - 8] = _sccvN::P64;
           P64[Sp] = _sccvI::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdOe; else goto ccdNp;
       ucdOe: // global
           call _ccdNo(R1) args: 0, res: 0, upd: 0;
       ccdNp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdOk_srtd" {
     ucdOk_srtd:
         const SccKB_srt+192;
         const 81;
         const 9295429630892703745;
         const 65536;
 },
 _ccdNo() //  [R1]
         { info_tbl: [(ccdNo,
                       label: block_ccdNo_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdNo: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdOd; else goto ccdOc;
       ccdOd: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdOc: // global
           _sccvQ::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccvX_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccvW_info;
           _sccvN::P64 = P64[Sp + 40];
           P64[Hp] = _sccvN::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccvM::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccvM::P64;
           P64[Sp + 48] = _sccvN::P64;
           I64[Sp + 56] = _sccvQ::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.108206648 UTC

[section ""data" . Text.Printf.$fPrintfArgInt_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt_$sformatInt_info;
         const 0;
 },
 sat_sccwg_entry() //  [R1]
         { info_tbl: [(ccdOD,
                       label: sat_sccwg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdOD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdOE; else goto ccdOF;
       ccdOE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdOF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fIntegralInt_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdPm_srtd" {
     ucdPm_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 sat_sccwf_entry() //  [R1]
         { info_tbl: [(ccdOR,
                       label: sat_sccwf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdOR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdOS; else goto ccdOT;
       ccdOS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdOT: // global
           I64[Sp - 8] = block_ccdOK_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdPc; else goto ccdOL;
       ucdPc: // global
           call _ccdOK(R1) args: 0, res: 0, upd: 0;
       ccdOL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdPn_srtd" {
     ucdPn_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 _ccdOK() //  [R1]
         { info_tbl: [(ccdOK,
                       label: block_ccdOK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdOK: // global
           if (R1 & 7 == 1) goto ccdOO; else goto ccdOP;
       ccdOO: // global
           R1 = Text.Printf.$fPrintfArgInt1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdOP: // global
           I64[Sp] = block_ccdOZ_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdOZ() //  [R1]
         { info_tbl: [(ccdOZ,
                       label: block_ccdOZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdOZ: // global
           if (R1 & 7 == 1) goto ccdP6; else goto ccdPa;
       ccdP6: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdPa: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdPo_srtd" {
     ucdPo_srtd:
         const SccKB_srt+192;
         const 83;
         const 9295429630892703745;
         const 263168;
 },
 Text.Printf.$fPrintfArgInt_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccdPd,
                       label: Text.Printf.$fPrintfArgInt_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdPd: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdPe; else goto ccdPf;
       ccdPe: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdPf: // global
           I64[Sp - 16] = block_ccdOp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdPl; else goto ccdOq;
       ucdPl: // global
           call _ccdOp(R1) args: 0, res: 0, upd: 0;
       ccdOq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdPp_srtd" {
     ucdPp_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _ccdOp() //  [R1]
         { info_tbl: [(ccdOp,
                       label: block_ccdOp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdOp: // global
           I64[Sp - 48] = block_ccdOu_info;
           _sccw1::P64 = P64[R1 + 7];
           _sccw2::P64 = P64[R1 + 15];
           _sccw3::P64 = P64[R1 + 23];
           _sccw4::P64 = P64[R1 + 31];
           _sccw5::P64 = P64[R1 + 39];
           _sccw6::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccw2::P64;
           P64[Sp - 32] = _sccw3::P64;
           P64[Sp - 24] = _sccw4::P64;
           P64[Sp - 16] = _sccw5::P64;
           P64[Sp - 8] = _sccw6::P64;
           P64[Sp] = _sccw1::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdPk; else goto ccdOv;
       ucdPk: // global
           call _ccdOu(R1) args: 0, res: 0, upd: 0;
       ccdOv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdPq_srtd" {
     ucdPq_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _ccdOu() //  [R1]
         { info_tbl: [(ccdOu,
                       label: block_ccdOu_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdOu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdPj; else goto ccdPi;
       ccdPj: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdPi: // global
           _sccw9::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccwg_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccwf_info;
           _sccw6::P64 = P64[Sp + 40];
           P64[Hp] = _sccw6::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccw5::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccw5::P64;
           P64[Sp + 48] = _sccw6::P64;
           I64[Sp + 56] = _sccw9::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.112797298 UTC

[section ""data" . Text.Printf.$wformatInt_closure" {
     Text.Printf.$wformatInt_closure:
         const Text.Printf.$wformatInt_info;
         const 0;
 },
 Text.Printf.$wformatInt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdPs: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatInt_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sccws_entry() //  [R1]
         { info_tbl: [(ccdPQ,
                       label: sat_sccws_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdPQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdPR; else goto ccdPS;
       ccdPR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdPS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccwJ_entry() //  [R1]
         { info_tbl: [(ccdQ5,
                       label: sat_sccwJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdQ5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdQ6; else goto ccdQ7;
       ccdQ6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdQ7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucdR5_srtd" {
     ucdR5_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sccwI_entry() //  [R1]
         { info_tbl: [(ccdQj,
                       label: sat_sccwI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdQj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdQk; else goto ccdQl;
       ccdQk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdQl: // global
           I64[Sp - 16] = block_ccdQc_info;
           _sccwr::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _sccwr::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdQH; else goto ccdQd;
       ucdQH: // global
           call _ccdQc(R1) args: 0, res: 0, upd: 0;
       ccdQd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdR6_srtd" {
     ucdR6_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _ccdQc() //  [R1]
         { info_tbl: [(ccdQc,
                       label: block_ccdQc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdQc: // global
           if (R1 & 7 == 1) goto ccdQg; else goto ccdQh;
       ccdQg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccdQr; else goto ccdQq;
       ccdQr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdQq: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdQh: // global
           I64[Sp + 8] = block_ccdQu_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           Sp = Sp + 8;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdQu() //  [R1]
         { info_tbl: [(ccdQu,
                       label: block_ccdQu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdQu: // global
           if (R1 & 7 == 1) goto ccdQB; else goto ccdQF;
       ccdQB: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdQF: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdR7_srtd" {
     ucdR7_srtd:
         const SccKB_srt+192;
         const 84;
         const 9304436830147444737;
         const 524288;
 },
 Text.Printf.$wformatInt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccdQI,
                       label: Text.Printf.$wformatInt_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdQI: // global
           _sccwl::P64 = R6;
           _sccwk::P64 = R5;
           _sccwj::P64 = R4;
           _sccwi::P64 = R3;
           _sccwh::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto ccdQJ; else goto ccdQK;
       ccdQK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdQM; else goto ccdQL;
       ccdQM: // global
           HpAlloc = 24;
           goto ccdQJ;
       ccdQJ: // global
           R1 = Text.Printf.$wformatInt_closure;
           P64[Sp - 40] = _sccwh::P64;
           P64[Sp - 32] = _sccwi::P64;
           P64[Sp - 24] = _sccwj::P64;
           P64[Sp - 16] = _sccwk::P64;
           P64[Sp - 8] = _sccwl::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       ccdQL: // global
           I64[Hp - 16] = sat_sccws_info;
           P64[Hp] = _sccwi::P64;
           I64[Sp - 40] = block_ccdPy_info;
           R2 = _sccwh::P64;
           I64[Sp - 56] = stg_ap_p_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 32] = _sccwh::P64;
           P64[Sp - 24] = _sccwj::P64;
           P64[Sp - 16] = _sccwk::P64;
           P64[Sp - 8] = _sccwl::P64;
           Sp = Sp - 56;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdR8_srtd" {
     ucdR8_srtd:
         const SccKB_srt+192;
         const 64;
         const 9304436830147444737;
 },
 _ccdPy() //  [R1]
         { info_tbl: [(ccdPy,
                       label: block_ccdPy_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdPy: // global
           I64[Sp - 8] = block_ccdPE_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdR9_srtd" {
     ucdR9_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccdPE() //  [R1]
         { info_tbl: [(ccdPE,
                       label: block_ccdPE_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdPE: // global
           _sccwk::P64 = P64[Sp + 32];
           _sccwl::P64 = P64[Sp + 40];
           _sccwm::P64 = P64[Sp + 48];
           _sccwn::P64 = P64[Sp + 56];
           _sccwo::P64 = P64[Sp + 64];
           _sccwp::P64 = P64[Sp + 72];
           _sccwq::I64 = I64[Sp + 80];
           if (R1 == 1) goto ccdQX; else goto ccdQT;
       ccdQX: // global
           Hp = Hp + 16;
           _sccwK::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccdR0; else goto ccdQZ;
       ccdQZ: // global
           if (_sccwq::I64 == 118) goto ccdR3; else goto ccdR2;
       ccdR3: // global
           Hp = Hp - 16;
           _sccwA::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccwz::P64 = _sccwp::P64;
           _sccwy::P64 = _sccwo::P64;
           _sccwx::P64 = _sccwn::P64;
           _sccww::P64 = _sccwm::P64;
           _sccwv::P64 = _sccwl::P64;
           _sccwu::P64 = _sccwk::P64;
           goto sccwt;
       ccdR2: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccwq::I64;
           _sccwA::P64 = Hp - 7;
           _sccwz::P64 = _sccwp::P64;
           _sccwy::P64 = _sccwo::P64;
           _sccwx::P64 = _sccwn::P64;
           _sccww::P64 = _sccwm::P64;
           _sccwv::P64 = _sccwl::P64;
           _sccwu::P64 = _sccwk::P64;
           goto sccwt;
       ccdQT: // global
           Hp = Hp + 16;
           _sccwK::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccdR0; else goto ccdQV;
       ccdR0: // global
           HpAlloc = 16;
           R1 = _sccwK::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccdQV: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccwq::I64;
           _sccwA::P64 = Hp - 7;
           _sccwz::P64 = _sccwp::P64;
           _sccwy::P64 = _sccwo::P64;
           _sccwx::P64 = _sccwn::P64;
           _sccww::P64 = _sccwm::P64;
           _sccwv::P64 = _sccwl::P64;
           _sccwu::P64 = _sccwk::P64;
           goto sccwt;
       sccwt: // global
           I64[Sp] = block_ccdPW_info;
           R1 = _sccwA::P64;
           P64[Sp + 32] = _sccwz::P64;
           P64[Sp + 40] = _sccwy::P64;
           P64[Sp + 48] = _sccwx::P64;
           P64[Sp + 56] = _sccww::P64;
           P64[Sp + 64] = _sccwv::P64;
           P64[Sp + 80] = _sccwu::P64;
           if (R1 & 7 != 0) goto ucdR4; else goto ccdPX;
       ucdR4: // global
           call _ccdPW(R1) args: 0, res: 0, upd: 0;
       ccdPX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdRa_srtd" {
     ucdRa_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccdPW() //  [R1]
         { info_tbl: [(ccdPW,
                       label: block_ccdPW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdPW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccdQR; else goto ccdQQ;
       ccdQR: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdQQ: // global
           _sccwC::I64 = I64[R1 + 7];
           I64[Hp - 56] = sat_sccwJ_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_sccwI_info;
           P64[Hp - 8] = P64[Sp + 72];
           P64[Hp] = P64[Sp + 8];
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 64];
           R4 = P64[Sp + 80];
           R3 = Hp - 56;
           R2 = Hp - 24;
           P64[Sp + 56] = P64[Sp + 48];
           P64[Sp + 64] = P64[Sp + 40];
           P64[Sp + 72] = P64[Sp + 32];
           I64[Sp + 80] = _sccwC::I64;
           Sp = Sp + 56;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.117465637 UTC

[section ""data" . Text.Printf.formatInt_closure" {
     Text.Printf.formatInt_closure:
         const Text.Printf.formatInt_info;
         const 0;
 },
 Text.Printf.formatInt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccdRi,
                       label: Text.Printf.formatInt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdRi: // global
           if ((Sp + -80) < SpLim) (likely: False) goto ccdRm; else goto ccdRn;
       ccdRm: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatInt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdRn: // global
           I64[Sp - 32] = block_ccdRf_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucdRv; else goto ccdRg;
       ucdRv: // global
           call _ccdRf(R1) args: 0, res: 0, upd: 0;
       ccdRg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdRf() //  [R1]
         { info_tbl: [(ccdRf,
                       label: block_ccdRf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdRf: // global
           I64[Sp - 48] = block_ccdRl_info;
           _sccwT::P64 = P64[R1 + 7];
           _sccwU::P64 = P64[R1 + 15];
           _sccwV::P64 = P64[R1 + 23];
           _sccwW::P64 = P64[R1 + 31];
           _sccwX::P64 = P64[R1 + 39];
           _sccwY::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccwU::P64;
           P64[Sp - 32] = _sccwV::P64;
           P64[Sp - 24] = _sccwW::P64;
           P64[Sp - 16] = _sccwX::P64;
           P64[Sp - 8] = _sccwY::P64;
           P64[Sp] = _sccwT::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdRu; else goto ccdRp;
       ucdRu: // global
           call _ccdRl(R1) args: 0, res: 0, upd: 0;
       ccdRp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdRl() //  [R1]
         { info_tbl: [(ccdRl,
                       label: block_ccdRl_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdRl: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           _sccwY::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 16];
           P64[Sp + 48] = P64[Sp + 24];
           P64[Sp + 56] = P64[Sp + 32];
           P64[Sp + 64] = _sccwY::P64;
           I64[Sp + 72] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatInt_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.118990639 UTC

[section ""data" . Text.Printf.$fPrintfArgWord64_closure" {
     Text.Printf.$fPrintfArgWord64_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord64_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.119591872 UTC

[section ""data" . Text.Printf.$fPrintfArgWord32_closure" {
     Text.Printf.$fPrintfArgWord32_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord32_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.120173724 UTC

[section ""data" . Text.Printf.$fPrintfArgWord16_closure" {
     Text.Printf.$fPrintfArgWord16_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord16_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.120724835 UTC

[section ""data" . Text.Printf.$fPrintfArgWord8_closure" {
     Text.Printf.$fPrintfArgWord8_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord8_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.121333055 UTC

[section ""data" . Text.Printf.$fPrintfArgWord_closure" {
     Text.Printf.$fPrintfArgWord_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.121896906 UTC

[section ""data" . Text.Printf.$fPrintfArgInt64_closure" {
     Text.Printf.$fPrintfArgInt64_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt64_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.122486363 UTC

[section ""data" . Text.Printf.$fPrintfArgInt32_closure" {
     Text.Printf.$fPrintfArgInt32_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt32_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.123017393 UTC

[section ""data" . Text.Printf.$fPrintfArgInt16_closure" {
     Text.Printf.$fPrintfArgInt16_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt16_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.123600334 UTC

[section ""data" . Text.Printf.$fPrintfArgInt8_closure" {
     Text.Printf.$fPrintfArgInt8_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt8_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.124158695 UTC

[section ""data" . Text.Printf.$fPrintfArgInt_closure" {
     Text.Printf.$fPrintfArgInt_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.125712048 UTC

[section ""data" . Text.Printf.formatInteger_closure" {
     Text.Printf.formatInteger_closure:
         const Text.Printf.formatInteger_info;
         const 0;
 },
 section ""relreadonly" . ucdSq_srtd" {
     ucdSq_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sccxj_entry() //  [R1]
         { info_tbl: [(ccdRV,
                       label: sat_sccxj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdRV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdRW; else goto ccdRX;
       ccdRW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdRX: // global
           I64[Sp - 8] = block_ccdRO_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdSg; else goto ccdRP;
       ucdSg: // global
           call _ccdRO(R1) args: 0, res: 0, upd: 0;
       ccdRP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdSr_srtd" {
     ucdSr_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _ccdRO() //  [R1]
         { info_tbl: [(ccdRO,
                       label: block_ccdRO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdRO: // global
           if (R1 & 7 == 1) goto ccdRS; else goto ccdRT;
       ccdRS: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdRT: // global
           I64[Sp] = block_ccdS3_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdS3() //  [R1]
         { info_tbl: [(ccdS3,
                       label: block_ccdS3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdS3: // global
           if (R1 & 7 == 1) goto ccdSa; else goto ccdSe;
       ccdSa: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdSe: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdSs_srtd" {
     ucdSs_srtd:
         const SccKB_srt+192;
         const 86;
         const 9295429630892703745;
         const 2097152;
 },
 Text.Printf.formatInteger_entry() //  [R2, R3]
         { info_tbl: [(ccdSh,
                       label: Text.Printf.formatInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdSh: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdSi; else goto ccdSj;
       ccdSi: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdSj: // global
           I64[Sp - 16] = block_ccdRA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdSp; else goto ccdRB;
       ucdSp: // global
           call _ccdRA(R1) args: 0, res: 0, upd: 0;
       ccdRB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdSt_srtd" {
     ucdSt_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccdRA() //  [R1]
         { info_tbl: [(ccdRA,
                       label: block_ccdRA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdRA: // global
           I64[Sp - 48] = block_ccdRF_info;
           _sccx5::P64 = P64[R1 + 7];
           _sccx6::P64 = P64[R1 + 15];
           _sccx7::P64 = P64[R1 + 23];
           _sccx8::P64 = P64[R1 + 31];
           _sccx9::P64 = P64[R1 + 39];
           _sccxa::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccx6::P64;
           P64[Sp - 32] = _sccx7::P64;
           P64[Sp - 24] = _sccx8::P64;
           P64[Sp - 16] = _sccx9::P64;
           P64[Sp - 8] = _sccxa::P64;
           P64[Sp] = _sccx5::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdSo; else goto ccdRG;
       ucdSo: // global
           call _ccdRF(R1) args: 0, res: 0, upd: 0;
       ccdRG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdSu_srtd" {
     ucdSu_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccdRF() //  [R1]
         { info_tbl: [(ccdRF,
                       label: block_ccdRF_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdRF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdSn; else goto ccdSm;
       ccdSn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdSm: // global
           _sccxd::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sccxj_info;
           _sccxa::P64 = P64[Sp + 40];
           P64[Hp] = _sccxa::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 56];
           R2 = Hp - 16;
           _sccx9::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccx9::P64;
           P64[Sp + 48] = _sccxa::P64;
           I64[Sp + 56] = _sccxd::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.128897561 UTC

[section ""data" . Text.Printf.$fPrintfArgNatural_$cformatArg_closure" {
     Text.Printf.$fPrintfArgNatural_$cformatArg_closure:
         const Text.Printf.$fPrintfArgNatural_$cformatArg_info;
         const 0;
 },
 section ""relreadonly" . ucdTp_srtd" {
     ucdTp_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sccxB_entry() //  [R1]
         { info_tbl: [(ccdSU,
                       label: sat_sccxB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdSU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccdSV; else goto ccdSW;
       ccdSV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdSW: // global
           I64[Sp - 8] = block_ccdSN_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdTf; else goto ccdSO;
       ucdTf: // global
           call _ccdSN(R1) args: 0, res: 0, upd: 0;
       ccdSO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdTq_srtd" {
     ucdTq_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _ccdSN() //  [R1]
         { info_tbl: [(ccdSN,
                       label: block_ccdSN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdSN: // global
           if (R1 & 7 == 1) goto ccdSR; else goto ccdSS;
       ccdSR: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccdSS: // global
           I64[Sp] = block_ccdT2_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccdT2() //  [R1]
         { info_tbl: [(ccdT2,
                       label: block_ccdT2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdT2: // global
           if (R1 & 7 == 1) goto ccdT9; else goto ccdTd;
       ccdT9: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccdTd: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucdTr_srtd" {
     ucdTr_srtd:
         const SccKB_srt+192;
         const 87;
         const 9295429630892703745;
         const 4194304;
 },
 Text.Printf.$fPrintfArgNatural_$cformatArg_entry() //  [R2, R3]
         { info_tbl: [(ccdTg,
                       label: Text.Printf.$fPrintfArgNatural_$cformatArg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdTg: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccdTh; else goto ccdTi;
       ccdTh: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgNatural_$cformatArg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdTi: // global
           I64[Sp - 16] = block_ccdSz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucdTo; else goto ccdSA;
       ucdTo: // global
           call _ccdSz(R1) args: 0, res: 0, upd: 0;
       ccdSA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdTs_srtd" {
     ucdTs_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccdSz() //  [R1]
         { info_tbl: [(ccdSz,
                       label: block_ccdSz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdSz: // global
           I64[Sp - 48] = block_ccdSE_info;
           _sccxn::P64 = P64[R1 + 7];
           _sccxo::P64 = P64[R1 + 15];
           _sccxp::P64 = P64[R1 + 23];
           _sccxq::P64 = P64[R1 + 31];
           _sccxr::P64 = P64[R1 + 39];
           _sccxs::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccxo::P64;
           P64[Sp - 32] = _sccxp::P64;
           P64[Sp - 24] = _sccxq::P64;
           P64[Sp - 16] = _sccxr::P64;
           P64[Sp - 8] = _sccxs::P64;
           P64[Sp] = _sccxn::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucdTn; else goto ccdSF;
       ucdTn: // global
           call _ccdSE(R1) args: 0, res: 0, upd: 0;
       ccdSF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucdTt_srtd" {
     ucdTt_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccdSE() //  [R1]
         { info_tbl: [(ccdSE,
                       label: block_ccdSE_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdSE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdTm; else goto ccdTl;
       ccdTm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdTl: // global
           _sccxv::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sccxB_info;
           _sccxs::P64 = P64[Sp + 40];
           P64[Hp] = _sccxs::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 56];
           R2 = Hp - 16;
           _sccxr::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccxr::P64;
           P64[Sp + 48] = _sccxs::P64;
           I64[Sp + 56] = _sccxv::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.131383935 UTC

[section ""data" . Text.Printf.$fPrintfArgNatural_closure" {
     Text.Printf.$fPrintfArgNatural_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgNatural_$cformatArg_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.131972198 UTC

[section ""data" . Text.Printf.$fPrintfArgInteger_closure" {
     Text.Printf.$fPrintfArgInteger_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.formatInteger_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.132759782 UTC

[section ""data" . lvl42_rcccH_closure" {
     lvl42_rcccH_closure:
         const lvl42_rcccH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rcccH_entry() //  [R1]
         { info_tbl: [(ccdTA,
                       label: lvl42_rcccH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdTA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdTB; else goto ccdTC;
       ccdTB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdTC: // global
           (_ccdTx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdTx::I64 == 0) goto ccdTz; else goto ccdTy;
       ccdTz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdTy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdTx::I64;
           R4 = Text.Read.readEither7_closure+1;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadInt2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.133777297 UTC

[section ""data" . lvl43_rcccI_closure" {
     lvl43_rcccI_closure:
         const Text.Printf.FieldFormat_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Types.False_closure+1;
         const GHC.Types.[]_closure+1;
         const lvl23_rccco_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.134595496 UTC

[section ""data" . lvl44_rcccJ_closure" {
     lvl44_rcccJ_closure:
         const lvl44_rcccJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rcccJ_entry() //  [R1]
         { info_tbl: [(ccdTJ,
                       label: lvl44_rcccJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdTJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdTK; else goto ccdTL;
       ccdTK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdTL: // global
           (_ccdTG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdTG::I64 == 0) goto ccdTI; else goto ccdTH;
       ccdTI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdTH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdTG::I64;
           R2 = Text.Read.readEither5_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.135641947 UTC

[section ""data" . lvl45_rcccK_closure" {
     lvl45_rcccK_closure:
         const lvl45_rcccK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl45_rcccK_entry() //  [R1]
         { info_tbl: [(ccdTS,
                       label: lvl45_rcccK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdTS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdTT; else goto ccdTU;
       ccdTT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdTU: // global
           (_ccdTP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdTP::I64 == 0) goto ccdTR; else goto ccdTQ;
       ccdTR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdTQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdTP::I64;
           R2 = Text.Read.readEither2_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.137519555 UTC

[section ""data" . $wgetStar_rcccL_closure" {
     $wgetStar_rcccL_closure:
         const $wgetStar_rcccL_info;
         const 0;
 },
 sat_sccxK_entry() //  [R1]
         { info_tbl: [(ccdUi,
                       label: sat_sccxK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdUi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdUj; else goto ccdUk;
       ccdUj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdUk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Types.[]_closure+1;
           R2 = lvl43_rcccI_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccxS_entry() //  [R1]
         { info_tbl: [(ccdUn,
                       label: sat_sccxS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdUn: // global
           _sccxS::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto ccdUo; else goto ccdUp;
       ccdUp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdUr; else goto ccdUq;
       ccdUr: // global
           HpAlloc = 24;
           goto ccdUo;
       ccdUo: // global
           R1 = _sccxS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdUq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccxS::P64;
           _sccxJ::P64 = P64[_sccxS::P64 + 16];
           I64[Hp - 16] = sat_sccxK_info;
           P64[Hp] = _sccxJ::P64;
           I64[Sp - 24] = block_ccdUl_info;
           R3 = Hp - 16;
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdUl() //  [R1]
         { info_tbl: [(ccdUl,
                       label: block_ccdUl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdUl: // global
           I64[Sp] = block_ccdUu_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdUu() //  [R1]
         { info_tbl: [(ccdUu,
                       label: block_ccdUu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdUu: // global
           if (R1 & 7 == 1) goto ccdUB; else goto ccdUG;
       ccdUB: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccdUG: // global
           I64[Sp - 8] = block_ccdUE_info;
           _sccxN::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccxN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdUU; else goto ccdUH;
       ucdUU: // global
           call _ccdUE(R1) args: 0, res: 0, upd: 0;
       ccdUH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdUE() //  [R1]
         { info_tbl: [(ccdUE,
                       label: block_ccdUE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdUE: // global
           if (R1 & 7 == 1) goto ccdUN; else goto ccdUR;
       ccdUN: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccdUR: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgetStar_rcccL_entry() //  [R2]
         { info_tbl: [(ccdUZ,
                       label: $wgetStar_rcccL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdUZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdV0; else goto ccdV1;
       ccdV0: // global
           R2 = R2;
           R1 = $wgetStar_rcccL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccdV1: // global
           I64[Sp - 8] = block_ccdTZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdV9; else goto ccdU0;
       ucdV9: // global
           call _ccdTZ(R1) args: 0, res: 0, upd: 0;
       ccdU0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdTZ() //  [R1]
         { info_tbl: [(ccdTZ,
                       label: block_ccdTZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdTZ: // global
           if (R1 & 7 == 1) goto ccdUW; else goto ccdUX;
       ccdUW: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccdUX: // global
           I64[Sp - 8] = block_ccdU5_info;
           _sccxG::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccxG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdV8; else goto ccdU6;
       ucdV8: // global
           call _ccdU5(R1) args: 0, res: 0, upd: 0;
       ccdU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccdU5() //  [R1]
         { info_tbl: [(ccdU5,
                       label: block_ccdU5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdU5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdV7; else goto ccdV6;
       ccdV7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccdV6: // global
           _sccxJ::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sccxS_info;
           P64[Hp] = _sccxJ::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.140052688 UTC

[section ""data" . lvl46_rcccM_closure" {
     lvl46_rcccM_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.140609492 UTC

[section ""data" . lvl47_rcccN_closure" {
     lvl47_rcccN_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.LeftAdjust_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.141169078 UTC

[section ""data" . lvl48_rcccO_closure" {
     lvl48_rcccO_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.ZeroPad_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.142646292 UTC

[section ""data" . lvl49_rcccP_closure" {
     lvl49_rcccP_closure:
         const lvl49_rcccP_info;
         const 0;
         const 0;
         const 0;
 },
 sat_sccy6_entry() //  [R1]
         { info_tbl: [(ccdVu,
                       label: sat_sccy6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdVu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdVv; else goto ccdVw;
       ccdVv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdVw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccdVs_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdVs() //  [R1]
         { info_tbl: [(ccdVs,
                       label: block_ccdVs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdVs: // global
           I64[Sp] = block_ccdVz_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdVz() //  [R1]
         { info_tbl: [(ccdVz,
                       label: block_ccdVz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdVz: // global
           if (R1 & 7 == 1) goto ccdVG; else goto ccdVL;
       ccdVG: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccdVL: // global
           I64[Sp - 8] = block_ccdVJ_info;
           _sccy1::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccy1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdVZ; else goto ccdVM;
       ucdVZ: // global
           call _ccdVJ(R1) args: 0, res: 0, upd: 0;
       ccdVM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdVJ() //  [R1]
         { info_tbl: [(ccdVJ,
                       label: block_ccdVJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdVJ: // global
           if (R1 & 7 == 1) goto ccdVS; else goto ccdVW;
       ccdVS: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccdVW: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl49_rcccP_entry() //  [R1]
         { info_tbl: [(ccdW4,
                       label: lvl49_rcccP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdW4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdW5; else goto ccdW6;
       ccdW5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdW6: // global
           (_ccdVd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdVd::I64 == 0) goto ccdVf; else goto ccdVe;
       ccdVf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdVe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdVd::I64;
           I64[Sp - 24] = block_ccdVg_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdVg() //  [R1, R2]
         { info_tbl: [(ccdVg,
                       label: block_ccdVg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdVg: // global
           I64[Sp - 8] = block_ccdVi_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdWh; else goto ccdVj;
       ucdWh: // global
           call _ccdVi(R1) args: 0, res: 0, upd: 0;
       ccdVj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdVi() //  [R1]
         { info_tbl: [(ccdVi,
                       label: block_ccdVi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdVi: // global
           _sccxV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccdW1; else goto ccdW2;
       ccdW1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdWc; else goto ccdWb;
       ccdWc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccdWb: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sccxV::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccdW2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdWg; else goto ccdWf;
       ccdWg: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccdWf: // global
           I64[Hp - 40] = sat_sccy6_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sccxV::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.145031471 UTC

[section ""data" . lvl50_rcccQ_closure" {
     lvl50_rcccQ_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.SignPlus_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.145898765 UTC

[section ""data" . lvl51_rcccR_closure" {
     lvl51_rcccR_closure:
         const lvl51_rcccR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl51_rcccR_entry() //  [R1]
         { info_tbl: [(ccdWr,
                       label: lvl51_rcccR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdWr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccdWs; else goto ccdWt;
       ccdWs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdWt: // global
           (_ccdWl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdWl::I64 == 0) goto ccdWn; else goto ccdWm;
       ccdWn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdWm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdWl::I64;
           I64[Sp - 24] = block_ccdWo_info;
           R1 = lvl49_rcccP_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucdWx; else goto ccdWp;
       ucdWx: // global
           call _ccdWo(R1) args: 0, res: 0, upd: 0;
       ccdWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdWo() //  [R1]
         { info_tbl: [(ccdWo,
                       label: block_ccdWo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdWo: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.147010026 UTC

[section ""data" . lvl52_rcccS_closure" {
     lvl52_rcccS_closure:
         const GHC.Base.Just_con_info;
         const lvl51_rcccR_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.147835776 UTC

[section ""data" . lvl53_rcccT_closure" {
     lvl53_rcccT_closure:
         const lvl53_rcccT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl53_rcccT_entry() //  [R1]
         { info_tbl: [(ccdWH,
                       label: lvl53_rcccT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdWH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccdWI; else goto ccdWJ;
       ccdWI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdWJ: // global
           (_ccdWB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccdWB::I64 == 0) goto ccdWD; else goto ccdWC;
       ccdWD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccdWC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccdWB::I64;
           I64[Sp - 24] = block_ccdWE_info;
           R1 = lvl49_rcccP_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucdWN; else goto ccdWF;
       ucdWN: // global
           call _ccdWE(R1) args: 0, res: 0, upd: 0;
       ccdWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdWE() //  [R1]
         { info_tbl: [(ccdWE,
                       label: block_ccdWE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdWE: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.15181146 UTC

[section ""data" . lvl54_rcccU_closure" {
     lvl54_rcccU_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.SignSpace_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.164862967 UTC

[section ""data" . $wgetSpecs_rcccV_closure" {
     $wgetSpecs_rcccV_closure:
         const $wgetSpecs_rcccV_info;
         const 0;
 },
 ds3_sccyu_entry() //  [R1]
         { info_tbl: [(ccdXu,
                       label: ds3_sccyu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdXu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdXv; else goto ccdXw;
       ccdXv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdXw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccdXn_info;
           _sccyj::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccyj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucdXK; else goto ccdXo;
       ucdXK: // global
           call _ccdXn(R1) args: 0, res: 0, upd: 0;
       ccdXo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdXn() //  [R1]
         { info_tbl: [(ccdXn,
                       label: block_ccdXn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdXn: // global
           if (R1 & 7 == 1) goto ccdXr; else goto ccdXs;
       ccdXr: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccdXs: // global
           I64[Sp] = block_ccdXC_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucdXJ; else goto ccdXE;
       ucdXJ: // global
           call _ccdXC(R1) args: 0, res: 0, upd: 0;
       ccdXE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdXC() //  [R1]
         { info_tbl: [(ccdXC,
                       label: block_ccdXC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdXC: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccyD_entry() //  [R1]
         { info_tbl: [(ccdXZ,
                       label: sat_sccyD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdXZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdY0; else goto ccdY1;
       ccdY0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdY1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccdXS_info;
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucdYm; else goto ccdXT;
       ucdYm: // global
           call _ccdXS(R1) args: 0, res: 0, upd: 0;
       ccdXT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdXS() //  [R1]
         { info_tbl: [(ccdXS,
                       label: block_ccdXS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdXS: // global
           if (R1 & 7 == 1) goto ccdXW; else goto ccdXX;
       ccdXW: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccdY4_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucdYl; else goto ccdY6;
       ucdYl: // global
           call _ccdY4(R1) args: 0, res: 0, upd: 0;
       ccdY6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccdXX: // global
           R1 = lvl47_rcccN_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccdY4() //  [R1]
         { info_tbl: [(ccdY4,
                       label: block_ccdY4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdY4: // global
           if (R1 & 7 == 1) goto ccdYc; else goto ccdYg;
       ccdYc: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccdYg: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccz8_entry() //  [R1]
         { info_tbl: [(ccdYG,
                       label: sat_sccz8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdYG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdYH; else goto ccdYI;
       ccdYH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdYI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccdYE_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdYE() //  [R1]
         { info_tbl: [(ccdYE,
                       label: block_ccdYE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdYE: // global
           I64[Sp] = block_ccdYL_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdYL() //  [R1]
         { info_tbl: [(ccdYL,
                       label: block_ccdYL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdYL: // global
           if (R1 & 7 == 1) goto ccdYS; else goto ccdYX;
       ccdYS: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccdYX: // global
           I64[Sp - 8] = block_ccdYV_info;
           _sccz3::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccz3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdZb; else goto ccdYY;
       ucdZb: // global
           call _ccdYV(R1) args: 0, res: 0, upd: 0;
       ccdYY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdYV() //  [R1]
         { info_tbl: [(ccdYV,
                       label: block_ccdYV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdYV: // global
           if (R1 & 7 == 1) goto ccdZ4; else goto ccdZ8;
       ccdZ4: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccdZ8: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sccyU_entry() //  [R1]
         { info_tbl: [(ccdZg,
                       label: ds3_sccyU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdZg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccdZh; else goto ccdZi;
       ccdZh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdZi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccdYs_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccdYs() //  [R1, R2]
         { info_tbl: [(ccdYs,
                       label: block_ccdYs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdYs: // global
           I64[Sp - 8] = block_ccdYu_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucdZt; else goto ccdYv;
       ucdZt: // global
           call _ccdYu(R1) args: 0, res: 0, upd: 0;
       ccdYv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdYu() //  [R1]
         { info_tbl: [(ccdYu,
                       label: block_ccdYu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdYu: // global
           _sccyX::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccdZd; else goto ccdZe;
       ccdZd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccdZo; else goto ccdZn;
       ccdZo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccdZn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sccyX::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccdZe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccdZs; else goto ccdZr;
       ccdZs: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccdZr: // global
           I64[Hp - 40] = sat_sccz8_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sccyX::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scczD_entry() //  [R1]
         { info_tbl: [(cce0m,
                       label: sat_scczD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce0m: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cce0n; else goto cce0o;
       cce0n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce0o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce0k_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cce0k() //  [R1]
         { info_tbl: [(cce0k,
                       label: block_cce0k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce0k: // global
           I64[Sp] = block_cce0r_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cce0r() //  [R1]
         { info_tbl: [(cce0r,
                       label: block_cce0r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce0r: // global
           if (R1 & 7 == 1) goto cce0y; else goto cce0D;
       cce0y: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cce0D: // global
           I64[Sp - 8] = block_cce0B_info;
           _scczy::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _scczy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uce0R; else goto cce0E;
       uce0R: // global
           call _cce0B(R1) args: 0, res: 0, upd: 0;
       cce0E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce0B() //  [R1]
         { info_tbl: [(cce0B,
                       label: block_cce0B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce0B: // global
           if (R1 & 7 == 1) goto cce0K; else goto cce0O;
       cce0K: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cce0O: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_scczp_entry() //  [R1]
         { info_tbl: [(cce0W,
                       label: ds12_scczp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce0W: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cce0X; else goto cce0Y;
       cce0X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce0Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce08_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cce08() //  [R1, R2]
         { info_tbl: [(cce08,
                       label: block_cce08_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce08: // global
           I64[Sp - 8] = block_cce0a_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uce19; else goto cce0b;
       uce19: // global
           call _cce0a(R1) args: 0, res: 0, upd: 0;
       cce0b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce0a() //  [R1]
         { info_tbl: [(cce0a,
                       label: block_cce0a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce0a: // global
           _scczs::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cce0T; else goto cce0U;
       cce0T: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cce14; else goto cce13;
       cce14: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce13: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _scczs::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce0U: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cce18; else goto cce17;
       cce18: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce17: // global
           I64[Hp - 40] = sat_scczD_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _scczs::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_scczN_entry() //  [R1]
         { info_tbl: [(cce1i,
                       label: ds12_scczN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce1i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cce1j; else goto cce1k;
       cce1j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce1k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce1f_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cce1f() //  [R1, R2]
         { info_tbl: [(cce1f,
                       label: block_cce1f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce1f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cce1n; else goto cce1m;
       cce1n: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cce1m: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sccz9_entry() //  [R1]
         { info_tbl: [(cce1o,
                       label: ds4_sccz9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce1o: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cce1p; else goto cce1q;
       cce1p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce1q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccdZy_info;
           _sccyi::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sccyi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uce2b; else goto ccdZz;
       uce2b: // global
           call _ccdZy(R1) args: 0, res: 0, upd: 0;
       ccdZz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdZy() //  [R1]
         { info_tbl: [(ccdZy,
                       label: block_ccdZy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdZy: // global
           I64[Sp] = block_ccdZD_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uce27; else goto ccdZE;
       uce27: // global
           call _ccdZD(R1) args: 0, res: 0, upd: 0;
       ccdZE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdZD() //  [R1]
         { info_tbl: [(ccdZD,
                       label: block_ccdZD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdZD: // global
           if (R1 & 7 == 1) goto cce1v; else goto cce1A;
       cce1v: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cce1y; else goto cce1x;
       cce1y: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce1x: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce1A: // global
           I64[Sp - 16] = block_ccdZJ_info;
           _scczd::P64 = R1;
           _scczf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scczf::P64;
           P64[Sp] = _scczd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uce28; else goto ccdZK;
       uce28: // global
           call _ccdZJ(R1) args: 0, res: 0, upd: 0;
       ccdZK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdZJ() //  [R1]
         { info_tbl: [(ccdZJ,
                       label: block_ccdZJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdZJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cce1D; else goto cce1C;
       cce1D: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce1C: // global
           if (I64[R1 + 7] == 46) goto cce1H; else goto cce1G;
       cce1H: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_ccdZR_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uce29; else goto ccdZS;
       uce29: // global
           call _ccdZR(R1) args: 0, res: 0, upd: 0;
       ccdZS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cce1G: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccdZR() //  [R1]
         { info_tbl: [(ccdZR,
                       label: block_ccdZR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdZR: // global
           if (R1 & 7 == 1) goto cce1L; else goto cce1Q;
       cce1L: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cce1O; else goto cce1N;
       cce1O: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce1N: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl52_rcccS_closure+2;
           P64[Hp - 8] = lvl53_rcccT_closure;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce1Q: // global
           I64[Sp - 16] = block_ccdZX_info;
           _scczj::P64 = R1;
           _scczl::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scczl::P64;
           P64[Sp] = _scczj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uce2a; else goto ccdZY;
       uce2a: // global
           call _ccdZX(R1) args: 0, res: 0, upd: 0;
       ccdZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccdZX() //  [R1]
         { info_tbl: [(ccdZX,
                       label: block_ccdZX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdZX: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cce1T; else goto cce1S;
       cce1T: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce1S: // global
           _sccyi::P64 = P64[Sp + 24];
           if (I64[R1 + 7] == 42) goto cce24; else goto cce1Z;
       cce24: // global
           I64[Hp - 112] = ds12_scczN_info;
           P64[Hp - 96] = _sccyi::P64;
           I64[Hp - 88] = stg_sel_0_upd_info;
           _cce1b::P64 = Hp - 112;
           P64[Hp - 72] = _cce1b::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cce1b::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 88;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce1Z: // global
           I64[Hp - 112] = ds12_scczp_info;
           P64[Hp - 96] = P64[Sp + 16];
           I64[Hp - 88] = stg_sel_1_upd_info;
           _cce04::P64 = Hp - 112;
           P64[Hp - 72] = _cce04::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cce04::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = _sccyi::P64;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds5_sccA0_entry() //  [R1]
         { info_tbl: [(cce2j,
                       label: ds5_sccA0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce2j: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cce2k; else goto cce2l;
       cce2k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce2l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce2g_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uce2J; else goto cce2h;
       uce2J: // global
           call _cce2g(R1) args: 0, res: 0, upd: 0;
       cce2h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce2g() //  [R1]
         { info_tbl: [(cce2g,
                       label: block_cce2g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce2g: // global
           I64[Sp - 8] = block_cce2o_info;
           _sccA3::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sccA3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uce2I; else goto cce2q;
       uce2I: // global
           call _cce2o(R1) args: 0, res: 0, upd: 0;
       cce2q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce2o() //  [R1]
         { info_tbl: [(cce2o,
                       label: block_cce2o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce2o: // global
           if (R1 & 7 == 1) goto cce2w; else goto cce2B;
       cce2w: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cce2B: // global
           I64[Sp] = block_cce2z_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uce2K; else goto cce2C;
       uce2K: // global
           call _cce2z(R1) args: 0, res: 0, upd: 0;
       cce2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce2z() //  [R1]
         { info_tbl: [(cce2z,
                       label: block_cce2z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce2z: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccAx_entry() //  [R1]
         { info_tbl: [(cce2W,
                       label: sat_sccAx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce2W: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cce30; else goto cce31;
       cce30: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce31: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cce2T_info;
           _sccyd::P64 = P64[R1 + 16];
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sccyd::P64;
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uce3H; else goto cce2U;
       uce3H: // global
           call _cce2T(R1) args: 0, res: 0, upd: 0;
       cce2U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce2T() //  [R1]
         { info_tbl: [(cce2T,
                       label: block_cce2T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce2T: // global
           I64[Sp] = block_cce2Z_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uce3G; else goto cce33;
       uce3G: // global
           call _cce2Z(R1) args: 0, res: 0, upd: 0;
       cce33: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce2Z() //  [R1]
         { info_tbl: [(cce2Z,
                       label: block_cce2Z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce2Z: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cce3d; else goto uce3E;
       cce3d: // global
           _sccyd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cce3b_info;
           R1 = _sccyd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uce3I; else goto cce3e;
       uce3I: // global
           call _cce3b(R1) args: 0, res: 0, upd: 0;
       cce3e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uce3E: // global
           Sp = Sp + 24;
           call _cce3B() args: 0, res: 0, upd: 0;
     }
 },
 _cce3b() //  [R1]
         { info_tbl: [(cce3b,
                       label: block_cce3b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce3b: // global
           if (R1 & 7 == 1) goto cce3l; else goto uce3F;
       cce3l: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cce3i_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uce3K; else goto cce3m;
       uce3K: // global
           call _cce3i(R1) args: 0, res: 0, upd: 0;
       cce3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uce3F: // global
           Sp = Sp + 16;
           call _cce3B() args: 0, res: 0, upd: 0;
     }
 },
 _cce3i() //  [R1]
         { info_tbl: [(cce3i,
                       label: block_cce3i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce3i: // global
           if (R1 & 7 == 1) goto cce3s; else goto cce3w;
       cce3s: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce3w: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cce3B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce3B: // global
           R1 = lvl47_rcccN_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccAi_entry() //  [R1]
         { info_tbl: [(cce3U,
                       label: sat_sccAi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce3U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cce3Y; else goto cce3Z;
       cce3Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce3Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce3R_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uce4j; else goto cce3S;
       uce4j: // global
           call _cce3R(R1) args: 0, res: 0, upd: 0;
       cce3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce3R() //  [R1]
         { info_tbl: [(cce3R,
                       label: block_cce3R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce3R: // global
           I64[Sp] = block_cce3X_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uce4i; else goto cce41;
       uce4i: // global
           call _cce3X(R1) args: 0, res: 0, upd: 0;
       cce41: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce3X() //  [R1]
         { info_tbl: [(cce3X,
                       label: block_cce3X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce3X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cce47; else goto cce46;
       cce47: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce46: // global
           _sccAf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sccAf::I64, 0)) goto cce4g; else goto cce4h;
       cce4g: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_sccAf::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce4h: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccAW_entry() //  [R1]
         { info_tbl: [(cce4u,
                       label: sat_sccAW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce4u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cce4v; else goto cce4w;
       cce4v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce4w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce4n_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uce4U; else goto cce4o;
       uce4U: // global
           call _cce4n(R1) args: 0, res: 0, upd: 0;
       cce4o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce4n() //  [R1]
         { info_tbl: [(cce4n,
                       label: block_cce4n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce4n: // global
           if (R1 & 7 == 1) goto uce4Q; else goto cce4s;
       uce4Q: // global
           Sp = Sp + 8;
           call _cce4O() args: 0, res: 0, upd: 0;
       cce4s: // global
           I64[Sp] = block_cce4C_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uce4S; else goto cce4E;
       uce4S: // global
           call _cce4C(R1) args: 0, res: 0, upd: 0;
       cce4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce4C() //  [R1]
         { info_tbl: [(cce4C,
                       label: block_cce4C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce4C: // global
           if (R1 & 7 == 1) goto cce4K; else goto uce4R;
       cce4K: // global
           R1 = lvl50_rcccQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uce4R: // global
           Sp = Sp + 8;
           call _cce4O() args: 0, res: 0, upd: 0;
     }
 },
 _cce4O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce4O: // global
           R1 = lvl54_rcccU_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sccAX_entry() //  [R1]
         { info_tbl: [(cce55,
                       label: ds3_sccAX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce55: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cce56; else goto cce57;
       cce56: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce57: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce52_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cce52() //  [R1, R2]
         { info_tbl: [(cce52,
                       label: block_cce52_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce52: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cce5a; else goto cce59;
       cce5a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cce59: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccBE_entry() //  [R1]
         { info_tbl: [(cce5Y,
                       label: sat_sccBE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce5Y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cce5Z; else goto cce60;
       cce5Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce60: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce5W_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cce5W() //  [R1]
         { info_tbl: [(cce5W,
                       label: block_cce5W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce5W: // global
           I64[Sp] = block_cce63_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cce63() //  [R1]
         { info_tbl: [(cce63,
                       label: block_cce63_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce63: // global
           if (R1 & 7 == 1) goto cce6a; else goto cce6f;
       cce6a: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cce6f: // global
           I64[Sp - 8] = block_cce6d_info;
           _sccBz::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccBz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uce6t; else goto cce6g;
       uce6t: // global
           call _cce6d(R1) args: 0, res: 0, upd: 0;
       cce6g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce6d() //  [R1]
         { info_tbl: [(cce6d,
                       label: block_cce6d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce6d: // global
           if (R1 & 7 == 1) goto cce6m; else goto cce6q;
       cce6m: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cce6q: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_sccBq_entry() //  [R1]
         { info_tbl: [(cce6y,
                       label: ds12_sccBq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce6y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cce6z; else goto cce6A;
       cce6z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce6A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce5K_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cce5K() //  [R1, R2]
         { info_tbl: [(cce5K,
                       label: block_cce5K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce5K: // global
           I64[Sp - 8] = block_cce5M_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uce6L; else goto cce5N;
       uce6L: // global
           call _cce5M(R1) args: 0, res: 0, upd: 0;
       cce5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce5M() //  [R1]
         { info_tbl: [(cce5M,
                       label: block_cce5M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce5M: // global
           _sccBt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cce6v; else goto cce6w;
       cce6v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cce6G; else goto cce6F;
       cce6G: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce6F: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sccBt::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce6w: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cce6K; else goto cce6J;
       cce6K: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce6J: // global
           I64[Hp - 40] = sat_sccBE_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sccBt::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_sccBS_entry() //  [R1]
         { info_tbl: [(cce6U,
                       label: ds12_sccBS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce6U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cce70; else goto cce71;
       cce70: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce71: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce6R_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uce76; else goto cce6S;
       uce76: // global
           call _cce6R(R1) args: 0, res: 0, upd: 0;
       cce6S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce6R() //  [R1]
         { info_tbl: [(cce6R,
                       label: block_cce6R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce6R: // global
           I64[Sp] = block_cce6X_info;
           R2 = P64[R1 + 7];
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cce6X() //  [R1, R2]
         { info_tbl: [(cce6X,
                       label: block_cce6X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce6X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cce75; else goto cce74;
       cce75: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cce74: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sccB1_entry() //  [R1]
         { info_tbl: [(cce7b,
                       label: ds4_sccB1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce7b: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cce7c; else goto cce7d;
       cce7c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce7d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cce5f_info;
           _sccAX::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccAX::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uce7W; else goto cce5g;
       uce7W: // global
           call _cce5f(R1) args: 0, res: 0, upd: 0;
       cce5g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce5f() //  [R1]
         { info_tbl: [(cce5f,
                       label: block_cce5f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce5f: // global
           if (R1 & 7 == 1) goto cce78; else goto cce79;
       cce78: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cce7j; else goto cce7i;
       cce7j: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce7i: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce79: // global
           I64[Sp - 16] = block_cce5l_info;
           _sccB2::P64 = R1;
           _sccB8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccB8::P64;
           P64[Sp] = _sccB2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uce7T; else goto cce5m;
       uce7T: // global
           call _cce5l(R1) args: 0, res: 0, upd: 0;
       cce5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce5l() //  [R1]
         { info_tbl: [(cce5l,
                       label: block_cce5l_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce5l: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cce7n; else goto cce7m;
       cce7n: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce7m: // global
           if (I64[R1 + 7] == 46) goto cce7s; else goto cce7r;
       cce7s: // global
           Hp = Hp - 56;
           I64[Sp + 16] = block_cce5t_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uce7U; else goto cce5u;
       uce7U: // global
           call _cce5t(R1) args: 0, res: 0, upd: 0;
       cce5u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cce7r: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cce5t() //  [R1]
         { info_tbl: [(cce5t,
                       label: block_cce5t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce5t: // global
           if (R1 & 7 == 1) goto cce7x; else goto cce7C;
       cce7x: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cce7A; else goto cce7z;
       cce7A: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce7z: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl52_rcccS_closure+2;
           P64[Hp - 8] = lvl53_rcccT_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce7C: // global
           I64[Sp - 16] = block_cce5z_info;
           _sccBg::P64 = R1;
           _sccBm::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccBm::P64;
           P64[Sp] = _sccBg::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uce7V; else goto cce5A;
       uce7V: // global
           call _cce5z(R1) args: 0, res: 0, upd: 0;
       cce5A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce5z() //  [R1]
         { info_tbl: [(cce5z,
                       label: block_cce5z_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce5z: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cce7F; else goto cce7E;
       cce7F: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce7E: // global
           _sccAX::P64 = P64[Sp + 24];
           if (I64[R1 + 7] == 42) goto cce7R; else goto cce7M;
       cce7R: // global
           I64[Hp - 136] = ds12_sccBS_info;
           P64[Hp - 120] = _sccAX::P64;
           I64[Hp - 112] = stg_sel_0_upd_info;
           _cce6N::P64 = Hp - 136;
           P64[Hp - 96] = _cce6N::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _cce6N::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = Hp - 88;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = Hp - 112;
           _cce7Q::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _cce7Q::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce7M: // global
           I64[Hp - 136] = ds12_sccBq_info;
           P64[Hp - 120] = P64[Sp + 16];
           I64[Hp - 112] = stg_sel_0_upd_info;
           P64[Hp - 96] = _sccAX::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           _cce5G::P64 = Hp - 136;
           P64[Hp - 72] = _cce5G::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cce5G::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 112;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds5_sccC8_entry() //  [R1]
         { info_tbl: [(cce84,
                       label: ds5_sccC8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce84: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cce85; else goto cce86;
       cce85: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce86: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce81_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uce8u; else goto cce82;
       uce8u: // global
           call _cce81(R1) args: 0, res: 0, upd: 0;
       cce82: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce81() //  [R1]
         { info_tbl: [(cce81,
                       label: block_cce81_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce81: // global
           I64[Sp - 8] = block_cce89_info;
           _sccCb::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sccCb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uce8t; else goto cce8b;
       uce8t: // global
           call _cce89(R1) args: 0, res: 0, upd: 0;
       cce8b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce89() //  [R1]
         { info_tbl: [(cce89,
                       label: block_cce89_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce89: // global
           if (R1 & 7 == 1) goto cce8h; else goto cce8m;
       cce8h: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cce8m: // global
           I64[Sp] = block_cce8k_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uce8v; else goto cce8n;
       uce8v: // global
           call _cce8k(R1) args: 0, res: 0, upd: 0;
       cce8n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce8k() //  [R1]
         { info_tbl: [(cce8k,
                       label: block_cce8k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce8k: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccCF_entry() //  [R1]
         { info_tbl: [(cce8H,
                       label: sat_sccCF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce8H: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cce8L; else goto cce8M;
       cce8L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce8M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cce8E_info;
           _sccyd::P64 = P64[R1 + 16];
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sccyd::P64;
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uce9s; else goto cce8F;
       uce9s: // global
           call _cce8E(R1) args: 0, res: 0, upd: 0;
       cce8F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce8E() //  [R1]
         { info_tbl: [(cce8E,
                       label: block_cce8E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce8E: // global
           I64[Sp] = block_cce8K_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uce9r; else goto cce8O;
       uce9r: // global
           call _cce8K(R1) args: 0, res: 0, upd: 0;
       cce8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce8K() //  [R1]
         { info_tbl: [(cce8K,
                       label: block_cce8K_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce8K: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cce8Y; else goto uce9p;
       cce8Y: // global
           _sccyd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cce8W_info;
           R1 = _sccyd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uce9t; else goto cce8Z;
       uce9t: // global
           call _cce8W(R1) args: 0, res: 0, upd: 0;
       cce8Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uce9p: // global
           Sp = Sp + 24;
           call _cce9m() args: 0, res: 0, upd: 0;
     }
 },
 _cce8W() //  [R1]
         { info_tbl: [(cce8W,
                       label: block_cce8W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce8W: // global
           if (R1 & 7 == 1) goto cce96; else goto uce9q;
       cce96: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cce93_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uce9v; else goto cce97;
       uce9v: // global
           call _cce93(R1) args: 0, res: 0, upd: 0;
       cce97: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uce9q: // global
           Sp = Sp + 16;
           call _cce9m() args: 0, res: 0, upd: 0;
     }
 },
 _cce93() //  [R1]
         { info_tbl: [(cce93,
                       label: block_cce93_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce93: // global
           if (R1 & 7 == 1) goto cce9d; else goto cce9h;
       cce9d: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cce9h: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cce9m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce9m: // global
           R1 = lvl47_rcccN_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccCq_entry() //  [R1]
         { info_tbl: [(cce9F,
                       label: sat_sccCq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce9F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cce9J; else goto cce9K;
       cce9J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce9K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cce9C_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucea4; else goto cce9D;
       ucea4: // global
           call _cce9C(R1) args: 0, res: 0, upd: 0;
       cce9D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce9C() //  [R1]
         { info_tbl: [(cce9C,
                       label: block_cce9C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce9C: // global
           I64[Sp] = block_cce9I_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ucea3; else goto cce9M;
       ucea3: // global
           call _cce9I(R1) args: 0, res: 0, upd: 0;
       cce9M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cce9I() //  [R1]
         { info_tbl: [(cce9I,
                       label: block_cce9I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce9I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cce9S; else goto cce9R;
       cce9S: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cce9R: // global
           _sccCn::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sccCn::I64, 0)) goto ccea1; else goto ccea2;
       ccea1: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_sccCn::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccea2: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccDo_entry() //  [R1]
         { info_tbl: [(cceaD,
                       label: sat_sccDo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceaD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cceaE; else goto cceaF;
       cceaE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceaF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cceaB_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceaB() //  [R1]
         { info_tbl: [(cceaB,
                       label: block_cceaB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceaB: // global
           I64[Sp] = block_cceaI_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceaI() //  [R1]
         { info_tbl: [(cceaI,
                       label: block_cceaI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceaI: // global
           if (R1 & 7 == 1) goto cceaP; else goto cceaU;
       cceaP: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cceaU: // global
           I64[Sp - 8] = block_cceaS_info;
           _sccDj::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccDj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uceb8; else goto cceaV;
       uceb8: // global
           call _cceaS(R1) args: 0, res: 0, upd: 0;
       cceaV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cceaS() //  [R1]
         { info_tbl: [(cceaS,
                       label: block_cceaS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceaS: // global
           if (R1 & 7 == 1) goto cceb1; else goto cceb5;
       cceb1: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cceb5: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds7_sccDp_entry() //  [R1]
         { info_tbl: [(ccebh,
                       label: ds7_sccDp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccebh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccebi; else goto ccebj;
       ccebi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccebj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccebe_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccebe() //  [R1, R2]
         { info_tbl: [(ccebe,
                       label: block_ccebe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccebe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccebm; else goto ccebl;
       ccebm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccebl: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sccD1_entry() //  [R1]
         { info_tbl: [(ccebr,
                       label: ds3_sccD1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccebr: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccebs; else goto ccebt;
       ccebs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccebt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cceac_info;
           _sccyi::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sccyi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucec6; else goto ccead;
       ucec6: // global
           call _cceac(R1) args: 0, res: 0, upd: 0;
       ccead: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cceac() //  [R1]
         { info_tbl: [(cceac,
                       label: block_cceac_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceac: // global
           if (R1 & 7 == 1) goto ccebo; else goto ccebp;
       ccebo: // global
           I64[Sp] = block_ccebv_info;
           R1 = lvl49_rcccP_closure;
           if (R1 & 7 != 0) goto ucec3; else goto ccebw;
       ucec3: // global
           call _ccebv(R1) args: 0, res: 0, upd: 0;
       ccebw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccebp: // global
           I64[Sp - 16] = block_cceai_info;
           _sccD2::P64 = R1;
           _sccD7::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccD7::P64;
           P64[Sp] = _sccD2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucec4; else goto cceaj;
       ucec4: // global
           call _cceai(R1) args: 0, res: 0, upd: 0;
       cceaj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccebv() //  [R1]
         { info_tbl: [(ccebv,
                       label: block_ccebv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccebv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccebE; else goto ccebD;
       ccebE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccebD: // global
           _sccD4::P64 = P64[R1 + 7];
           _sccD5::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = _sccD4::P64;
           P64[Hp - 8] = _sccD5::P64;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cceai() //  [R1]
         { info_tbl: [(cceai,
                       label: block_cceai_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceai: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccebI; else goto ccebH;
       ccebI: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccebH: // global
           if (I64[R1 + 7] == 42) goto ccec1; else goto ccebK;
       ccec1: // global
           I64[Hp - 96] = ds7_sccDp_info;
           P64[Hp - 80] = P64[Sp + 24];
           I64[Hp - 72] = stg_sel_0_upd_info;
           _cceba::P64 = Hp - 96;
           P64[Hp - 56] = _cceba::P64;
           I64[Hp - 48] = stg_sel_1_upd_info;
           P64[Hp - 32] = _cceba::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 72;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccebK: // global
           Hp = Hp - 104;
           _sccD2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cceap_info;
           R3 = _sccD2::P64;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 16;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceap() //  [R1, R2]
         { info_tbl: [(cceap,
                       label: block_cceap_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceap: // global
           I64[Sp - 8] = block_ccear_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucec5; else goto cceas;
       ucec5: // global
           call _ccear(R1) args: 0, res: 0, upd: 0;
       cceas: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccear() //  [R1]
         { info_tbl: [(ccear,
                       label: block_ccear_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccear: // global
           _sccyi::P64 = P64[Sp + 16];
           _sccDd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccebP; else goto ccebU;
       ccebP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccebS; else goto ccebR;
       ccebS: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccebR: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl46_rcccM_closure+1;
           P64[Hp - 8] = _sccDd::P64;
           P64[Hp] = _sccyi::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccebU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccebX; else goto ccebW;
       ccebX: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccebW: // global
           I64[Hp - 48] = sat_sccDo_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = _sccDd::P64;
           P64[Hp] = _sccyi::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sccDB_entry() //  [R1]
         { info_tbl: [(ccece,
                       label: ds4_sccDB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccece: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccecf; else goto ccecg;
       ccecf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccecg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccecb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucecE; else goto ccecc;
       ucecE: // global
           call _ccecb(R1) args: 0, res: 0, upd: 0;
       ccecc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccecb() //  [R1]
         { info_tbl: [(ccecb,
                       label: block_ccecb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccecb: // global
           I64[Sp - 8] = block_ccecj_info;
           _sccDE::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sccDE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucecD; else goto ccecl;
       ucecD: // global
           call _ccecj(R1) args: 0, res: 0, upd: 0;
       ccecl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccecj() //  [R1]
         { info_tbl: [(ccecj,
                       label: block_ccecj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccecj: // global
           if (R1 & 7 == 1) goto ccecr; else goto ccecw;
       ccecr: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccecw: // global
           I64[Sp] = block_ccecu_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucecF; else goto ccecx;
       ucecF: // global
           call _ccecu(R1) args: 0, res: 0, upd: 0;
       ccecx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccecu() //  [R1]
         { info_tbl: [(ccecu,
                       label: block_ccecu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccecu: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccDU_entry() //  [R1]
         { info_tbl: [(ccecV,
                       label: sat_sccDU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccecV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccecW; else goto ccecX;
       ccecW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccecX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccecO_info;
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucedi; else goto ccecP;
       ucedi: // global
           call _ccecO(R1) args: 0, res: 0, upd: 0;
       ccecP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccecO() //  [R1]
         { info_tbl: [(ccecO,
                       label: block_ccecO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccecO: // global
           if (R1 & 7 == 1) goto ccecS; else goto ccecT;
       ccecS: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cced0_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucedh; else goto cced2;
       ucedh: // global
           call _cced0(R1) args: 0, res: 0, upd: 0;
       cced2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccecT: // global
           R1 = lvl47_rcccN_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cced0() //  [R1]
         { info_tbl: [(cced0,
                       label: block_cced0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cced0: // global
           if (R1 & 7 == 1) goto cced8; else goto ccedc;
       cced8: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccedc: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucee6_srtd" {
     ucee6_srtd:
         const SccKB_srt+448;
         const 69;
         const 17293822569102704641;
         const 31;
 },
 $wgetSpecs_rcccV_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccedn,
                       label: $wgetSpecs_rcccV_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccedn: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccedo; else goto ucedS;
       ccedo: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wgetSpecs_rcccV_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ucedS: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _ccdWP() args: 0, res: 0, upd: 0;
     }
 },
 _ccdWP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdWP: // global
           I64[Sp - 8] = block_ccdWS_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucedY; else goto ccdWT;
       ucedY: // global
           call _ccdWS(R1) args: 0, res: 0, upd: 0;
       ccdWT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucee7_srtd" {
     ucee7_srtd:
         const SccKB_srt+448;
         const 68;
         const 17293822569102704641;
         const 15;
 },
 _ccdWS() //  [R1]
         { info_tbl: [(ccdWS,
                       label: block_ccdWS_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdWS: // global
           if (R1 & 7 == 1) goto ccedk; else goto ccedl;
       ccedk: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccedl: // global
           I64[Sp - 8] = block_ccdWY_info;
           _sccyj::P64 = R1;
           _sccym::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccym::P64;
           P64[Sp + 40] = _sccyj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucedZ; else goto ccdWZ;
       ucedZ: // global
           call _ccdWY(R1) args: 0, res: 0, upd: 0;
       ccdWZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucee8_srtd" {
     ucee8_srtd:
         const SccKB_srt+448;
         const 68;
         const 17293822569102704641;
         const 15;
 },
 _ccdWY() //  [R1]
         { info_tbl: [(ccdWY,
                       label: block_ccdWY_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdWY: // global
           Hp = Hp + 344;
           if (Hp > HpLim) (likely: False) goto ccedv; else goto ccedu;
       ccedv: // global
           HpAlloc = 344;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccedu: // global
           _sccyd::P64 = P64[Sp + 16];
           _sccye::P64 = P64[Sp + 24];
           _sccyf::P64 = P64[Sp + 32];
           _sccyg::P64 = P64[Sp + 40];
           _sccyi::P64 = P64[Sp + 56];
           _sccyj::P64 = P64[Sp + 48];
           _sccyp::I64 = I64[R1 + 7];
           if (_sccyp::I64 >= 49) goto ccedD; else goto ucedQ;
       ucedQ: // global
           if (_sccyp::I64 < 32) goto ccedD; else goto ucedR;
       ucedR: // global
           _sccym::P64 = P64[Sp + 8];
           switch [32 .. 48] _sccyp::I64 {
               case 32 : goto ccedE;
               case 35 : goto ccedF;
               case 42 : goto ccedI;
               case 43 : goto ccedJ;
               case 45 : goto ccedK;
               case 46 : goto ccedO;
               case 48 : goto ccedP;
               default: {goto ccedD;}
           }
       ccedP: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = GHC.Types.True_closure+2;
           P64[Sp + 32] = _sccyf::P64;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto ucee4;
       ccedO: // global
           I64[Hp - 336] = ds3_sccD1_info;
           P64[Hp - 320] = _sccyi::P64;
           P64[Hp - 312] = _sccym::P64;
           I64[Hp - 304] = ds4_sccDB_info;
           _ccea8::P64 = Hp - 336;
           P64[Hp - 288] = _ccea8::P64;
           I64[Hp - 280] = stg_sel_2_upd_info;
           P64[Hp - 264] = _ccea8::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           _ccec7::P64 = Hp - 304;
           P64[Hp - 240] = _ccec7::P64;
           I64[Hp - 232] = stg_sel_1_upd_info;
           P64[Hp - 216] = _ccec7::P64;
           I64[Hp - 208] = stg_sel_0_upd_info;
           P64[Hp - 192] = _ccec7::P64;
           I64[Hp - 184] = sat_sccDU_info;
           P64[Hp - 168] = _sccyd::P64;
           P64[Hp - 160] = _sccye::P64;
           I64[Hp - 152] = stg_sel_0_upd_info;
           P64[Hp - 136] = _ccea8::P64;
           I64[Hp - 128] = GHC.Base.Just_con_info;
           P64[Hp - 120] = Hp - 152;
           I64[Hp - 112] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 104] = GHC.Base.Nothing_closure+1;
           P64[Hp - 96] = Hp - 126;
           P64[Hp - 88] = Hp - 184;
           P64[Hp - 80] = _sccyf::P64;
           P64[Hp - 72] = _sccyg::P64;
           P64[Hp - 64] = Hp - 208;
           P64[Hp - 56] = Hp - 232;
           _ccecG::P64 = Hp - 280;
           _ccecH::P64 = Hp - 256;
           _ccedN::P64 = Hp - 111;
           Hp = Hp - 56;
           R3 = _ccecG::P64;
           R2 = _ccecH::P64;
           R1 = _ccedN::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccedK: // global
           Hp = Hp - 344;
           P64[Sp + 16] = GHC.Types.True_closure+2;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = _sccyf::P64;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto ucee4;
       ccedJ: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = lvl50_rcccQ_closure+2;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto ucee4;
       ccedI: // global
           I64[Hp - 336] = ds3_sccAX_info;
           P64[Hp - 320] = _sccyi::P64;
           I64[Hp - 312] = ds4_sccB1_info;
           P64[Hp - 296] = _sccym::P64;
           _cce4Y::P64 = Hp - 336;
           P64[Hp - 288] = _cce4Y::P64;
           I64[Hp - 280] = ds5_sccC8_info;
           _cce5b::P64 = Hp - 312;
           P64[Hp - 264] = _cce5b::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           P64[Hp - 240] = _cce5b::P64;
           I64[Hp - 232] = stg_sel_2_upd_info;
           _cce7X::P64 = Hp - 280;
           P64[Hp - 216] = _cce7X::P64;
           I64[Hp - 208] = stg_sel_1_upd_info;
           P64[Hp - 192] = _cce7X::P64;
           I64[Hp - 184] = stg_sel_0_upd_info;
           P64[Hp - 168] = _cce7X::P64;
           I64[Hp - 160] = sat_sccCF_info;
           P64[Hp - 144] = _sccyd::P64;
           P64[Hp - 136] = _sccye::P64;
           P64[Hp - 128] = _cce4Y::P64;
           I64[Hp - 120] = stg_sel_0_upd_info;
           P64[Hp - 104] = _cce5b::P64;
           I64[Hp - 96] = sat_sccCq_info;
           P64[Hp - 80] = _cce4Y::P64;
           I64[Hp - 72] = GHC.Base.Just_con_info;
           P64[Hp - 64] = Hp - 96;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 120;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = _sccyf::P64;
           P64[Hp - 16] = _sccyg::P64;
           P64[Hp - 8] = Hp - 184;
           P64[Hp] = Hp - 208;
           R3 = Hp - 256;
           R2 = Hp - 232;
           R1 = Hp - 55;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccedF: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = _sccyf::P64;
           P64[Sp + 40] = GHC.Types.True_closure+2;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto ucee4;
       ccedE: // global
           I64[Hp - 336] = sat_sccAW_info;
           P64[Hp - 320] = _sccyf::P64;
           _ccdX6::P64 = Hp - 336;
           Hp = Hp - 320;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = _ccdX6::P64;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto ucee4;
       ucee4: // global
           call _ccdWP() args: 0, res: 0, upd: 0;
       ccedD: // global
           if ((_sccyp::I64 + -48) > 9) goto ccedy; else goto ccedB;
       ccedy: // global
           I64[Hp - 336] = ds3_sccyu_info;
           P64[Hp - 320] = _sccyi::P64;
           P64[Hp - 312] = _sccyj::P64;
           I64[Hp - 304] = stg_sel_2_upd_info;
           _ccdXj::P64 = Hp - 336;
           P64[Hp - 288] = _ccdXj::P64;
           I64[Hp - 280] = stg_sel_1_upd_info;
           P64[Hp - 264] = _ccdXj::P64;
           I64[Hp - 256] = stg_sel_0_upd_info;
           P64[Hp - 240] = _ccdXj::P64;
           I64[Hp - 232] = sat_sccyD_info;
           P64[Hp - 216] = _sccyd::P64;
           P64[Hp - 208] = _sccye::P64;
           I64[Hp - 200] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 192] = GHC.Base.Nothing_closure+1;
           P64[Hp - 184] = GHC.Base.Nothing_closure+1;
           P64[Hp - 176] = Hp - 232;
           P64[Hp - 168] = _sccyf::P64;
           P64[Hp - 160] = _sccyg::P64;
           P64[Hp - 152] = Hp - 256;
           P64[Hp - 144] = Hp - 280;
           _ccdXL::P64 = Hp - 304;
           _ccedw::P64 = Hp - 199;
           Hp = Hp - 144;
           R3 = _sccyi::P64;
           R2 = _ccdXL::P64;
           R1 = _ccedw::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccedB: // global
           I64[Hp - 336] = ds3_sccyU_info;
           P64[Hp - 320] = _sccyj::P64;
           I64[Hp - 312] = ds4_sccz9_info;
           P64[Hp - 296] = _sccyi::P64;
           _ccdYo::P64 = Hp - 336;
           P64[Hp - 288] = _ccdYo::P64;
           I64[Hp - 280] = ds5_sccA0_info;
           _ccdZu::P64 = Hp - 312;
           P64[Hp - 264] = _ccdZu::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           P64[Hp - 240] = _ccdZu::P64;
           I64[Hp - 232] = stg_sel_2_upd_info;
           _cce2c::P64 = Hp - 280;
           P64[Hp - 216] = _cce2c::P64;
           I64[Hp - 208] = stg_sel_1_upd_info;
           P64[Hp - 192] = _cce2c::P64;
           I64[Hp - 184] = stg_sel_0_upd_info;
           P64[Hp - 168] = _cce2c::P64;
           I64[Hp - 160] = sat_sccAx_info;
           P64[Hp - 144] = _sccyd::P64;
           P64[Hp - 136] = _sccye::P64;
           P64[Hp - 128] = _ccdYo::P64;
           I64[Hp - 120] = stg_sel_0_upd_info;
           P64[Hp - 104] = _ccdZu::P64;
           I64[Hp - 96] = sat_sccAi_info;
           P64[Hp - 80] = _ccdYo::P64;
           I64[Hp - 72] = GHC.Base.Just_con_info;
           P64[Hp - 64] = Hp - 96;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 120;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = _sccyf::P64;
           P64[Hp - 16] = _sccyg::P64;
           P64[Hp - 8] = Hp - 184;
           P64[Hp] = Hp - 208;
           R3 = Hp - 256;
           R2 = Hp - 232;
           R1 = Hp - 55;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.192842233 UTC

[section ""data" . f_rcccW_closure" {
     f_rcccW_closure:
         const GHC.Types.C#_con_info;
         const 37;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.199109501 UTC

[section ""data" . Text.Printf.uprintfs_closure" {
     Text.Printf.uprintfs_closure:
         const Text.Printf.uprintfs_info;
         const 0;
 },
 sat_sccEt_entry() //  [R1]
         { info_tbl: [(cceeu,
                       label: sat_sccEt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceeu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceev; else goto cceew;
       cceev: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceew: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccEL_entry() //  [R1]
         { info_tbl: [(ccef0,
                       label: sat_sccEL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccef0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccef1; else goto ccef2;
       ccef1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccef2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 16];
           R3 = P64[R1 + 32];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccES_entry() //  [R1]
         { info_tbl: [(ccefl,
                       label: sat_sccES_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccefl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccefm; else goto ccefn;
       ccefm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccefn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucegF_srtd" {
     ucegF_srtd:
         const SccKB_srt+448;
         const 70;
         const 9223372036854775809;
         const 48;
 },
 Text.Printf.uprintfs_entry() //  [R2, R3, R4]
         { info_tbl: [(ccefs,
                       label: Text.Printf.uprintfs_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccefs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cceft; else goto ccefu;
       cceft: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.uprintfs_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccefu: // global
           I64[Sp - 24] = block_cceed_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucegD; else goto cceee;
       ucegD: // global
           call _cceed(R1) args: 0, res: 0, upd: 0;
       cceee: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucegG_srtd" {
     ucegG_srtd:
         const SccKB_srt+448;
         const 70;
         const 9223372036854775809;
         const 48;
 },
 _cceed() //  [R1]
         { info_tbl: [(cceed,
                       label: block_cceed_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceed: // global
           if (R1 & 7 == 1) goto ccefp; else goto ccefq;
       ccefp: // global
           _sccEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccefw_info;
           R1 = _sccEh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucegt; else goto ccefy;
       ucegt: // global
           call _ccefw(R1) args: 0, res: 0, upd: 0;
       ccefy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccefq: // global
           I64[Sp - 8] = block_cceej_info;
           _sccEp::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccEp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucegu; else goto cceek;
       ucegu: // global
           call _cceej(R1) args: 0, res: 0, upd: 0;
       cceek: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccefw() //  [R1]
         { info_tbl: [(ccefw,
                       label: block_ccefw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccefw: // global
           if (R1 & 7 == 1) goto ccefE; else goto ccefI;
       ccefE: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccefI: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cceej() //  [R1]
         { info_tbl: [(cceej,
                       label: block_cceej_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceej: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccefM; else goto ccefL;
       ccefM: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccefL: // global
           _sccEp::P64 = P64[Sp + 8];
           if (I64[R1 + 7] == 37) goto cceg7; else goto ccefP;
       cceg7: // global
           Hp = Hp - 64;
           I64[Sp] = block_ccef3_info;
           R1 = _sccEp::P64;
           if (R1 & 7 != 0) goto ucegv; else goto ccef4;
       ucegv: // global
           call _ccef3(R1) args: 0, res: 0, upd: 0;
       ccef4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccefP: // global
           I64[Hp - 56] = sat_sccEt_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sccEp::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccef3() //  [R1]
         { info_tbl: [(ccef3,
                       label: block_ccef3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccef3: // global
           if (R1 & 7 == 1) goto ucegp; else goto ccegd;
       ucegp: // global
           Sp = Sp + 8;
           call _sccEu() args: 0, res: 0, upd: 0;
       ccegd: // global
           I64[Sp - 8] = block_ccef9_info;
           _sccEO::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccEO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucegA; else goto ccefa;
       ucegA: // global
           call _ccef9(R1) args: 0, res: 0, upd: 0;
       ccefa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccef9() //  [R1]
         { info_tbl: [(ccef9,
                       label: block_ccef9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccef9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccegg; else goto ccegf;
       ccegg: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccegf: // global
           if (I64[R1 + 7] == 37) goto ccegk; else goto ccegi;
       ccegk: // global
           I64[Hp - 56] = sat_sccES_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = f_rcccW_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccegi: // global
           Hp = Hp - 64;
           Sp = Sp + 16;
           call _sccEu() args: 0, res: 0, upd: 0;
     }
 },
 _sccEu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccEu: // global
           I64[Sp - 8] = block_cceeD_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucegE; else goto cceeE;
       ucegE: // global
           call _cceeD(R1) args: 0, res: 0, upd: 0;
       cceeE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceeD() //  [R1]
         { info_tbl: [(cceeD,
                       label: block_cceeD_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceeD: // global
           if (R1 & 7 == 1) goto ucegr; else goto ccefW;
       ucegr: // global
           Sp = Sp + 32;
           call _cceg1() args: 0, res: 0, upd: 0;
       ccefW: // global
           I64[Sp + 16] = block_cceeJ_info;
           R6 = P64[Sp + 8];
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = GHC.Types.False_closure+1;
           R2 = GHC.Types.False_closure+1;
           P64[Sp + 8] = R1;
           Sp = Sp + 8;
           call $wgetSpecs_rcccV_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 16, res: 8, upd: 8;
     }
 },
 _cceeJ() //  [R1, R2, R3]
         { info_tbl: [(cceeJ,
                       label: block_cceeJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceeJ: // global
           I64[Sp - 16] = block_cceeL_info;
           _sccEB::P64 = R1;
           R1 = R3;
           P64[Sp - 8] = R2;
           P64[Sp] = _sccEB::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucegx; else goto cceeM;
       ucegx: // global
           call _cceeL(R1) args: 0, res: 0, upd: 0;
       cceeM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceeL() //  [R1]
         { info_tbl: [(cceeL,
                       label: block_cceeL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceeL: // global
           if (R1 & 7 == 1) goto ucegs; else goto cceg3;
       ucegs: // global
           Sp = Sp + 32;
           call _cceg1() args: 0, res: 0, upd: 0;
       cceg3: // global
           I64[Sp - 8] = block_cceeR_info;
           _sccEH::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccEH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucegy; else goto cceeS;
       ucegy: // global
           call _cceeR(R1) args: 0, res: 0, upd: 0;
       cceeS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceg1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceg1: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cceeR() //  [R1]
         { info_tbl: [(cceeR,
                       label: block_cceeR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceeR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cceg6; else goto cceg5;
       cceg6: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceg5: // global
           _sccEK::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sccEL_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 32;
           R2 = P64[Sp + 24];
           R1 = _sccEK::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.205410482 UTC

[section ""data" . Text.Printf.$fPrintfTypeIO_$cspr_closure" {
     Text.Printf.$fPrintfTypeIO_$cspr_closure:
         const Text.Printf.$fPrintfTypeIO_$cspr_info;
         const 0;
 },
 sat_sccEW_entry() //  [R1]
         { info_tbl: [(ccegV,
                       label: sat_sccEW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccegV: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccEX_entry() //  [R1]
         { info_tbl: [(ccegY,
                       label: sat_sccEX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccegY: // global
           _sccEX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccegZ; else goto cceh0;
       cceh0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cceh2; else goto cceh1;
       cceh2: // global
           HpAlloc = 24;
           goto ccegZ;
       ccegZ: // global
           R1 = _sccEX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceh1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccEX::P64;
           _sccEU::P64 = P64[_sccEX::P64 + 16];
           _sccEV::P64 = P64[_sccEX::P64 + 24];
           I64[Hp - 16] = sat_sccEW_info;
           P64[Hp] = _sccEV::P64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _sccEU::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfTypeIO_$cspr_entry() //  [R2, R3, R4]
         { info_tbl: [(cceh3,
                       label: Text.Printf.$fPrintfTypeIO_$cspr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceh3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cceh4; else goto cceh5;
       cceh4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfTypeIO_$cspr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cceh5: // global
           I64[Sp - 24] = block_ccegL_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccegL() //  []
         { info_tbl: [(ccegL,
                       label: block_ccegL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccegL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cceh8; else goto cceh7;
       cceh8: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cceh7: // global
           I64[Hp - 24] = sat_sccEX_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           Sp = Sp + 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.207671871 UTC

[section ""data" . Text.Printf.$fPrintfTypeIO_closure" {
     Text.Printf.$fPrintfTypeIO_closure:
         const Text.Printf.$fPrintfTypeIO_info;
         const 0;
 },
 Text.Printf.$fPrintfTypeIO_entry() //  [R2, R3, R4]
         { info_tbl: [(ccehd,
                       label: Text.Printf.$fPrintfTypeIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccehd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfTypeIO_$cspr_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.209236685 UTC

[section ""data" . Text.Printf.$fPrintfType[]_$cspr_closure" {
     Text.Printf.$fPrintfType[]_$cspr_closure:
         const Text.Printf.$fPrintfType[]_$cspr_info;
         const 0;
 },
 sat_sccF2_entry() //  [R1]
         { info_tbl: [(cceho,
                       label: sat_sccF2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceho: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccF1_entry() //  [R1]
         { info_tbl: [(ccehz,
                       label: sat_sccF1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccehz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccehA; else goto ccehB;
       ccehA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccehB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.Printf.fromChar_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfType[]_$cspr_entry() //  [R2, R3, R4]
         { info_tbl: [(ccehC,
                       label: Text.Printf.$fPrintfType[]_$cspr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccehC: // global
           _sccF0::P64 = R4;
           _sccEZ::P64 = R3;
           _sccEY::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccehD; else goto ccehE;
       ccehE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccehG; else goto ccehF;
       ccehG: // global
           HpAlloc = 24;
           goto ccehD;
       ccehD: // global
           R4 = _sccF0::P64;
           R3 = _sccEZ::P64;
           R2 = _sccEY::P64;
           R1 = Text.Printf.$fPrintfType[]_$cspr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccehF: // global
           I64[Hp - 16] = sat_sccF2_info;
           P64[Hp] = _sccF0::P64;
           I64[Sp - 16] = block_ccehr_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _sccEZ::P64;
           P64[Sp - 8] = _sccEY::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccehr() //  [R1]
         { info_tbl: [(ccehr,
                       label: block_ccehr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccehr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccehJ; else goto ccehI;
       ccehJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccehI: // global
           I64[Hp - 16] = sat_sccF1_info;
           P64[Hp] = P64[Sp + 8];
           R3 = R1;
           R2 = Hp - 16;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.211343391 UTC

[section ""data" . Text.Printf.$fPrintfType[]_closure" {
     Text.Printf.$fPrintfType[]_closure:
         const Text.Printf.$fPrintfType[]_info;
         const 0;
 },
 Text.Printf.$fPrintfType[]_entry() //  [R2, R3, R4]
         { info_tbl: [(ccehO,
                       label: Text.Printf.$fPrintfType[]_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccehO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfType[]_$cspr_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.212871669 UTC

[section ""data" . Text.Printf.$fHPrintfTypeIO_$chspr_closure" {
     Text.Printf.$fHPrintfTypeIO_$chspr_closure:
         const Text.Printf.$fHPrintfTypeIO_$chspr_info;
         const 0;
 },
 sat_sccF8_entry() //  [R1]
         { info_tbl: [(ccei5,
                       label: sat_sccF8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccei5: // global
           R2 = P64[R1 + 16];
           call GHC.List.reverse_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccF9_entry() //  [R1]
         { info_tbl: [(ccei8,
                       label: sat_sccF9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccei8: // global
           _sccF9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccei9; else goto cceia;
       cceia: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cceic; else goto cceib;
       cceic: // global
           HpAlloc = 24;
           goto ccei9;
       ccei9: // global
           R1 = _sccF9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceib: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccF9::P64;
           _sccF6::P64 = P64[_sccF9::P64 + 16];
           _sccF7::P64 = P64[_sccF9::P64 + 24];
           I64[Hp - 16] = sat_sccF8_info;
           P64[Hp] = _sccF7::P64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _sccF6::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fHPrintfTypeIO_$chspr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cceid,
                       label: Text.Printf.$fHPrintfTypeIO_$chspr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceid: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cceie; else goto cceif;
       cceie: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fHPrintfTypeIO_$chspr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cceif: // global
           I64[Sp - 32] = block_ccehV_info;
           R2 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccehV() //  []
         { info_tbl: [(ccehV,
                       label: block_ccehV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccehV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cceii; else goto cceih;
       cceii: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cceih: // global
           I64[Hp - 24] = sat_sccF9_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.215179087 UTC

[section ""data" . Text.Printf.$fHPrintfTypeIO_closure" {
     Text.Printf.$fHPrintfTypeIO_closure:
         const Text.Printf.$fHPrintfTypeIO_info;
         const 0;
 },
 Text.Printf.$fHPrintfTypeIO_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccein,
                       label: Text.Printf.$fHPrintfTypeIO_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccein: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fHPrintfTypeIO_$chspr_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.216406745 UTC

[section ""data" . Text.Printf.FormatParse_closure" {
     Text.Printf.FormatParse_closure:
         const Text.Printf.FormatParse_info;
 },
 Text.Printf.FormatParse_entry() //  [R2, R3, R4]
         { info_tbl: [(cceiv,
                       label: Text.Printf.FormatParse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceiv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cceiz; else goto cceiy;
       cceiz: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.FormatParse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cceiy: // global
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.217928134 UTC

[section ""data" . Text.Printf.FieldFormat_closure" {
     Text.Printf.FieldFormat_closure:
         const Text.Printf.FieldFormat_info;
 },
 Text.Printf.FieldFormat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceiB: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.FieldFormat_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 24, res: 0, upd: 8;
     }
 },
 Text.Printf.FieldFormat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cceiG,
                       label: Text.Printf.FieldFormat_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceiG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cceiK; else goto cceiJ;
       cceiK: // global
           HpAlloc = 64;
           R1 = Text.Printf.FieldFormat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cceiJ: // global
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.219351134 UTC

[section ""data" . Text.Printf.SignPlus_closure" {
     Text.Printf.SignPlus_closure:
         const Text.Printf.SignPlus_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.22002252 UTC

[section ""data" . Text.Printf.SignSpace_closure" {
     Text.Printf.SignSpace_closure:
         const Text.Printf.SignSpace_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.220729565 UTC

[section ""data" . Text.Printf.LeftAdjust_closure" {
     Text.Printf.LeftAdjust_closure:
         const Text.Printf.LeftAdjust_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.221507348 UTC

[section ""data" . Text.Printf.ZeroPad_closure" {
     Text.Printf.ZeroPad_closure:
         const Text.Printf.ZeroPad_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.222411742 UTC

[section ""data" . Text.Printf.C:IsChar_closure" {
     Text.Printf.C:IsChar_closure:
         const Text.Printf.C:IsChar_info;
 },
 Text.Printf.C:IsChar_entry() //  [R2, R3]
         { info_tbl: [(cceiQ,
                       label: Text.Printf.C:IsChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceiQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cceiU; else goto cceiT;
       cceiU: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.C:IsChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cceiT: // global
           I64[Hp - 16] = Text.Printf.C:IsChar_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.223745197 UTC

[section ""data" . Text.Printf.C:PrintfArg_closure" {
     Text.Printf.C:PrintfArg_closure:
         const Text.Printf.C:PrintfArg_info;
 },
 Text.Printf.C:PrintfArg_entry() //  [R2, R3]
         { info_tbl: [(ccej0,
                       label: Text.Printf.C:PrintfArg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccej0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccej4; else goto ccej3;
       ccej4: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.C:PrintfArg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccej3: // global
           I64[Hp - 16] = Text.Printf.C:PrintfArg_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.224899362 UTC

[Text.Printf.FormatParse_con_entry() //  [R1]
         { info_tbl: [(ccej5,
                       label: Text.Printf.FormatParse_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,70,111,114,109,97,116,80,97,114,115,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccej5: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.225882512 UTC

[Text.Printf.FieldFormat_con_entry() //  [R1]
         { info_tbl: [(ccej6,
                       label: Text.Printf.FieldFormat_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,70,105,101,108,100,70,111,114,109,97,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccej6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.226731768 UTC

[section ""relreadonly" . Text.Printf.FormatSign_closure_tbl" {
     Text.Printf.FormatSign_closure_tbl:
         const Text.Printf.SignPlus_closure+1;
         const Text.Printf.SignSpace_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.227523459 UTC

[Text.Printf.SignPlus_con_entry() //  [R1]
         { info_tbl: [(ccej7,
                       label: Text.Printf.SignPlus_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,83,105,103,110,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccej7: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.228489412 UTC

[Text.Printf.SignSpace_con_entry() //  [R1]
         { info_tbl: [(ccej8,
                       label: Text.Printf.SignSpace_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,83,105,103,110,83,112,97,99,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccej8: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.229403891 UTC

[section ""relreadonly" . Text.Printf.FormatAdjustment_closure_tbl" {
     Text.Printf.FormatAdjustment_closure_tbl:
         const Text.Printf.LeftAdjust_closure+1;
         const Text.Printf.ZeroPad_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.2302459 UTC

[Text.Printf.LeftAdjust_con_entry() //  [R1]
         { info_tbl: [(ccej9,
                       label: Text.Printf.LeftAdjust_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,76,101,102,116,65,100,106,117,115,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccej9: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.231186259 UTC

[Text.Printf.ZeroPad_con_entry() //  [R1]
         { info_tbl: [(cceja,
                       label: Text.Printf.ZeroPad_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,90,101,114,111,80,97,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceja: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.232202148 UTC

[Text.Printf.C:IsChar_con_entry() //  [R1]
         { info_tbl: [(ccejb,
                       label: Text.Printf.C:IsChar_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,67,58,73,115,67,104,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccejb: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.233177308 UTC

[Text.Printf.C:PrintfArg_con_entry() //  [R1]
         { info_tbl: [(ccejc,
                       label: Text.Printf.C:PrintfArg_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,67,58,80,114,105,110,116,102,65,114,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccejc: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.234256052 UTC

[section ""relreadonly" . SccKB_srt" {
     SccKB_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Printf.perror_closure;
         const GHC.Show.$wshowLitChar_closure;
         const GHC.Show.$fShowChar1_closure;
         const Text.Printf.$werrorBadFormat_closure;
         const Text.Printf.errorBadFormat_closure;
         const Text.Printf.errorShortFormat_closure;
         const Text.Printf.$dmparseFormat_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.Unicode.toUpper_closure;
         const GHC.Float.$w$sformatRealFloatAlt_closure;
         const Text.Printf.$w$sdfmt_closure;
         const Text.Printf.$fPrintfArgDouble7_closure;
         const Text.Printf.$fPrintfArgDouble8_closure;
         const GHC.Float.$w$sformatRealFloatAlt1_closure;
         const Text.Printf.$w$sdfmt1_closure;
         const Text.Printf.$fPrintfArgFloat1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Text.Printf.$wdfmt_closure;
         const Text.Printf.formatRealFloat1_closure;
         const sat_scchQ_closure;
         const sat_scchS_closure;
         const sat_scchW_closure;
         const sat_scci2_closure;
         const Text.Printf.intModifierMap_closure;
         const Text.Printf.$wfixupMods_closure;
         const Text.Printf.$fPrintfArgInt2_closure;
         const Text.Printf.fixupMods_closure;
         const Text.Printf.$wparseIntFormat_closure;
         const GHC.Err.undefined_closure;
         const lvl18_rccch_closure;
         const Control.Exception.Base.patError_closure;
         const sat_sccjr_closure;
         const GHC.Show.intToDigit_closure;
         const GHC.Show.$fShowInteger_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Numeric.showIntAtBase_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const Text.Printf.formatChar2_closure;
         const lvl21_rccck_closure;
         const lvl20_rcccj_closure;
         const $wfmtu_rcccl_closure;
         const Text.Printf.errorBadArgument_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const $wfmti_rcccm_closure;
         const Text.Printf.$wadjustSigned_closure;
         const Text.Printf.$fPrintfArgDouble1_closure;
         const Text.Printf.$fPrintfArgDouble3_closure;
         const Text.Printf.$w$sformatRealFloat_closure;
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure;
         const Text.Printf.$w$sformatRealFloat1_closure;
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure;
         const Text.Printf.$wformatRealFloat_closure;
         const Text.Printf.formatRealFloat_closure;
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_closure;
         const Text.Printf.errorShortFormat_closure;
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_closure;
         const Text.Printf.$w$sformatString_closure;
         const Text.Printf.$werrorBadFormat_closure;
         const Text.Printf.$wformatString_closure;
         const Text.Printf.formatString_closure;
         const lvl22_rcccn_closure;
         const Text.Printf.$fPrintfArg[]_closure;
         const sat_sccoX_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const sat_sccp0_closure;
         const sat_sccp2_closure;
         const sat_sccp4_closure;
         const GHC.Unicode.toUpper_closure;
         const lvl24_rcccp_closure;
         const lvl38_rcccD_closure;
         const lvl39_rcccE_closure;
         const GHC.Char.$wlvl_closure;
         const lvl32_rcccx_closure;
         const lvl40_rcccF_closure;
         const $wfmtu_rcccl_closure;
         const Text.Printf.formatChar2_closure;
         const lvl35_rcccA_closure;
         const lvl41_rcccG_closure;
         const Text.Printf.$wformatIntegral_closure;
         const lvl30_rcccv_closure;
         const lvl31_rcccw_closure;
         const Text.Printf.formatIntegral_closure;
         const Text.Printf.$wformatChar_closure;
         const Text.Printf.formatChar1_closure;
         const Text.Printf.formatChar_closure;
         const Text.Printf.$fPrintfArgInt2_closure;
         const Text.Printf.$w$sformatInt3_closure;
         const Text.Printf.$fPrintfArgWord64_$sformatInt_closure;
         const Text.Printf.$w$sformatInt2_closure;
         const Text.Printf.$fPrintfArgWord32_$sformatInt_closure;
         const Text.Printf.$w$sformatInt1_closure;
         const Text.Printf.$fPrintfArgWord16_$sformatInt_closure;
         const Text.Printf.$w$sformatInt4_closure;
         const Text.Printf.$fPrintfArgWord8_$sformatInt_closure;
         const Text.Printf.$w$sformatInt_closure;
         const Text.Printf.$fPrintfArgWord_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt1_closure;
         const Text.Printf.$fPrintfArgInt64_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt4_closure;
         const Text.Printf.$fPrintfArgInt32_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt3_closure;
         const Text.Printf.$fPrintfArgInt16_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt5_closure;
         const Text.Printf.$fPrintfArgInt8_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt_$sformatInt_closure;
         const Text.Printf.$wformatInt_closure;
         const Text.Printf.formatInt_closure;
         const Text.Printf.formatInteger_closure;
         const Text.Printf.$fPrintfArgNatural_$cformatArg_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Text.Read.readEither5_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Read.readEither2_closure;
         const lvl42_rcccH_closure;
         const lvl44_rcccJ_closure;
         const lvl45_rcccK_closure;
         const Text.Printf.errorMissingArgument_closure;
         const $wgetStar_rcccL_closure;
         const lvl49_rcccP_closure;
         const lvl52_rcccS_closure;
         const lvl53_rcccT_closure;
         const $wgetSpecs_rcccV_closure;
         const Text.Printf.uprintfs_closure;
         const Text.Printf.errorShortFormat_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const Text.Printf.$fPrintfTypeIO_$cspr_closure;
         const Text.Printf.$fPrintfType[]_$cspr_closure;
         const Text.Printf.$fHPrintfTypeIO_$chspr_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.236232681 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:04.237291167 UTC

[section ""data" . Text.Printf.toChar_closure" {
     Text.Printf.toChar_closure:
         const Text.Printf.toChar_info;
 },
 Text.Printf.toChar_entry() //  [R2]
         { info_tbl: [(ccejk,
                       label: Text.Printf.toChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccejk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccejl; else goto ccejm;
       ccejl: // global
           R2 = R2;
           R1 = Text.Printf.toChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccejm: // global
           I64[Sp - 8] = block_ccejh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucejq; else goto cceji;
       ucejq: // global
           call _ccejh(R1) args: 0, res: 0, upd: 0;
       cceji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccejh() //  [R1]
         { info_tbl: [(ccejh,
                       label: block_ccejh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccejh: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.238775222 UTC

[section ""data" . Text.Printf.fromChar_closure" {
     Text.Printf.fromChar_closure:
         const Text.Printf.fromChar_info;
 },
 Text.Printf.fromChar_entry() //  [R2]
         { info_tbl: [(ccejy,
                       label: Text.Printf.fromChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccejy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccejz; else goto ccejA;
       ccejz: // global
           R2 = R2;
           R1 = Text.Printf.fromChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccejA: // global
           I64[Sp - 8] = block_ccejv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucejE; else goto ccejw;
       ucejE: // global
           call _ccejv(R1) args: 0, res: 0, upd: 0;
       ccejw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccejv() //  [R1]
         { info_tbl: [(ccejv,
                       label: block_ccejv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccejv: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.240283089 UTC

[section ""data" . Text.Printf.formatArg_closure" {
     Text.Printf.formatArg_closure:
         const Text.Printf.formatArg_info;
 },
 Text.Printf.formatArg_entry() //  [R2]
         { info_tbl: [(ccejM,
                       label: Text.Printf.formatArg_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccejM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccejN; else goto ccejO;
       ccejN: // global
           R2 = R2;
           R1 = Text.Printf.formatArg_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccejO: // global
           I64[Sp - 8] = block_ccejJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucejS; else goto ccejK;
       ucejS: // global
           call _ccejJ(R1) args: 0, res: 0, upd: 0;
       ccejK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccejJ() //  [R1]
         { info_tbl: [(ccejJ,
                       label: block_ccejJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccejJ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.241882726 UTC

[section ""data" . Text.Printf.parseFormat_closure" {
     Text.Printf.parseFormat_closure:
         const Text.Printf.parseFormat_info;
 },
 Text.Printf.parseFormat_entry() //  [R2]
         { info_tbl: [(ccek0,
                       label: Text.Printf.parseFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccek0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccek1; else goto ccek2;
       ccek1: // global
           R2 = R2;
           R1 = Text.Printf.parseFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccek2: // global
           I64[Sp - 8] = block_ccejX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucek6; else goto ccejY;
       ucek6: // global
           call _ccejX(R1) args: 0, res: 0, upd: 0;
       ccejY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccejX() //  [R1]
         { info_tbl: [(ccejX,
                       label: block_ccejX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccejX: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.243410846 UTC

[section ""data" . Text.Printf.hspr_closure" {
     Text.Printf.hspr_closure:
         const Text.Printf.hspr_info;
 },
 Text.Printf.hspr_entry() //  [R2]
         { info_tbl: [(ccekb,
                       label: Text.Printf.hspr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccekb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.244512314 UTC

[section ""data" . Text.Printf.spr_closure" {
     Text.Printf.spr_closure:
         const Text.Printf.spr_info;
 },
 Text.Printf.spr_entry() //  [R2]
         { info_tbl: [(cceki,
                       label: Text.Printf.spr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceki: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.245862939 UTC

[section ""data" . Text.Printf.$fIsCharChar_$cfromChar_closure" {
     Text.Printf.$fIsCharChar_$cfromChar_closure:
         const Text.Printf.$fIsCharChar_$cfromChar_info;
 },
 Text.Printf.$fIsCharChar_$cfromChar_entry() //  [R2]
         { info_tbl: [(ccekp,
                       label: Text.Printf.$fIsCharChar_$cfromChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccekp: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.246894613 UTC

[section ""data" . Text.Printf.$fIsCharChar_closure" {
     Text.Printf.$fIsCharChar_closure:
         const Text.Printf.C:IsChar_con_info;
         const Text.Printf.$fIsCharChar_$cfromChar_closure+1;
         const Text.Printf.$fIsCharChar_$cfromChar_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.248478169 UTC

[section ""data" . Text.Printf.$fHPrintfType(->)_$chspr_closure" {
     Text.Printf.$fHPrintfType(->)_$chspr_closure:
         const Text.Printf.$fHPrintfType(->)_$chspr_info;
 },
 sat_sccdo_entry() //  [R1]
         { info_tbl: [(ccekA,
                       label: sat_sccdo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccekA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccekB; else goto ccekC;
       ccekB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccekC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.formatArg_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sccdn_entry() //  [R1]
         { info_tbl: [(ccekH,
                       label: sat_sccdn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccekH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccekI; else goto ccekJ;
       ccekI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccekJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.parseFormat_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Text.Printf.$fHPrintfType(->)_$chspr_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(ccekM,
                       label: Text.Printf.$fHPrintfType(->)_$chspr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccekM: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccekQ; else goto ccekP;
       ccekQ: // global
           HpAlloc = 112;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fHPrintfType(->)_$chspr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ccekP: // global
           I64[Hp - 104] = sat_sccdo_info;
           P64[Hp - 88] = R2;
           _sccdm::P64 = P64[Sp];
           P64[Hp - 80] = _sccdm::P64;
           I64[Hp - 72] = sat_sccdn_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = _sccdm::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = R6;
           _sccdj::P64 = R4;
           R4 = Hp - 14;
           _sccdi::P64 = R3;
           R3 = R5;
           R2 = _sccdj::P64;
           R1 = _sccdi::P64;
           Sp = Sp + 8;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.254382513 UTC

[section ""data" . Text.Printf.$fHPrintfType(->)_closure" {
     Text.Printf.$fHPrintfType(->)_closure:
         const Text.Printf.$fHPrintfType(->)_info;
 },
 Text.Printf.$fHPrintfType(->)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccekV,
                       label: Text.Printf.$fHPrintfType(->)_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccekV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fHPrintfType(->)_$chspr_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.25567286 UTC

[section ""data" . Text.Printf.$fPrintfType(->)_$cspr_closure" {
     Text.Printf.$fPrintfType(->)_$cspr_closure:
         const Text.Printf.$fPrintfType(->)_$cspr_info;
 },
 sat_sccdx_entry() //  [R1]
         { info_tbl: [(ccel6,
                       label: sat_sccdx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccel6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccel7; else goto ccel8;
       ccel7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccel8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.formatArg_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sccdw_entry() //  [R1]
         { info_tbl: [(cceld,
                       label: sat_sccdw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceld: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccele; else goto ccelf;
       ccele: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccelf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.parseFormat_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfType(->)_$cspr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cceli,
                       label: Text.Printf.$fPrintfType(->)_$cspr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceli: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccelm; else goto ccell;
       ccelm: // global
           HpAlloc = 112;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfType(->)_$cspr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccell: // global
           I64[Hp - 104] = sat_sccdx_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R6;
           I64[Hp - 72] = sat_sccdw_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R6;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = R5;
           _sccds::P64 = R3;
           R3 = Hp - 14;
           R2 = R4;
           R1 = _sccds::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.257365509 UTC

[section ""data" . Text.Printf.$fPrintfType(->)_closure" {
     Text.Printf.$fPrintfType(->)_closure:
         const Text.Printf.$fPrintfType(->)_info;
 },
 Text.Printf.$fPrintfType(->)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccelr,
                       label: Text.Printf.$fPrintfType(->)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccelr: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfType(->)_$cspr_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.258441078 UTC

[section ""data" . Text.Printf.fmtChar_closure" {
     Text.Printf.fmtChar_closure:
         const Text.Printf.fmtChar_info;
 },
 Text.Printf.fmtChar_entry() //  [R2]
         { info_tbl: [(ccelB,
                       label: Text.Printf.fmtChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccelB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccelC; else goto ccelD;
       ccelC: // global
           R2 = R2;
           R1 = Text.Printf.fmtChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccelD: // global
           I64[Sp - 8] = block_ccely_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucelH; else goto ccelz;
       ucelH: // global
           call _ccely(R1) args: 0, res: 0, upd: 0;
       ccelz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccely() //  [R1]
         { info_tbl: [(ccely,
                       label: block_ccely_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccely: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.259810486 UTC

[section ""data" . Text.Printf.fmtModifiers_closure" {
     Text.Printf.fmtModifiers_closure:
         const Text.Printf.fmtModifiers_info;
 },
 Text.Printf.fmtModifiers_entry() //  [R2]
         { info_tbl: [(ccelP,
                       label: Text.Printf.fmtModifiers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccelP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccelQ; else goto ccelR;
       ccelQ: // global
           R2 = R2;
           R1 = Text.Printf.fmtModifiers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccelR: // global
           I64[Sp - 8] = block_ccelM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucelV; else goto ccelN;
       ucelV: // global
           call _ccelM(R1) args: 0, res: 0, upd: 0;
       ccelN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccelM() //  [R1]
         { info_tbl: [(ccelM,
                       label: block_ccelM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccelM: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.261063114 UTC

[section ""data" . Text.Printf.fmtAlternate_closure" {
     Text.Printf.fmtAlternate_closure:
         const Text.Printf.fmtAlternate_info;
 },
 Text.Printf.fmtAlternate_entry() //  [R2]
         { info_tbl: [(ccem3,
                       label: Text.Printf.fmtAlternate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccem3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccem4; else goto ccem5;
       ccem4: // global
           R2 = R2;
           R1 = Text.Printf.fmtAlternate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccem5: // global
           I64[Sp - 8] = block_ccem0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucem9; else goto ccem1;
       ucem9: // global
           call _ccem0(R1) args: 0, res: 0, upd: 0;
       ccem1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccem0() //  [R1]
         { info_tbl: [(ccem0,
                       label: block_ccem0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccem0: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.262481818 UTC

[section ""data" . Text.Printf.fmtSign_closure" {
     Text.Printf.fmtSign_closure:
         const Text.Printf.fmtSign_info;
 },
 Text.Printf.fmtSign_entry() //  [R2]
         { info_tbl: [(ccemh,
                       label: Text.Printf.fmtSign_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccemh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccemi; else goto ccemj;
       ccemi: // global
           R2 = R2;
           R1 = Text.Printf.fmtSign_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccemj: // global
           I64[Sp - 8] = block_cceme_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucemn; else goto ccemf;
       ucemn: // global
           call _cceme(R1) args: 0, res: 0, upd: 0;
       ccemf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceme() //  [R1]
         { info_tbl: [(cceme,
                       label: block_cceme_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceme: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.263809575 UTC

[section ""data" . Text.Printf.fmtAdjust_closure" {
     Text.Printf.fmtAdjust_closure:
         const Text.Printf.fmtAdjust_info;
 },
 Text.Printf.fmtAdjust_entry() //  [R2]
         { info_tbl: [(ccemv,
                       label: Text.Printf.fmtAdjust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccemv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccemw; else goto ccemx;
       ccemw: // global
           R2 = R2;
           R1 = Text.Printf.fmtAdjust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccemx: // global
           I64[Sp - 8] = block_ccems_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucemB; else goto ccemt;
       ucemB: // global
           call _ccems(R1) args: 0, res: 0, upd: 0;
       ccemt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccems() //  [R1]
         { info_tbl: [(ccems,
                       label: block_ccems_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccems: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.265098374 UTC

[section ""data" . Text.Printf.fmtPrecision_closure" {
     Text.Printf.fmtPrecision_closure:
         const Text.Printf.fmtPrecision_info;
 },
 Text.Printf.fmtPrecision_entry() //  [R2]
         { info_tbl: [(ccemJ,
                       label: Text.Printf.fmtPrecision_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccemJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccemK; else goto ccemL;
       ccemK: // global
           R2 = R2;
           R1 = Text.Printf.fmtPrecision_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccemL: // global
           I64[Sp - 8] = block_ccemG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucemP; else goto ccemH;
       ucemP: // global
           call _ccemG(R1) args: 0, res: 0, upd: 0;
       ccemH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccemG() //  [R1]
         { info_tbl: [(ccemG,
                       label: block_ccemG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccemG: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.266507075 UTC

[section ""data" . Text.Printf.fmtWidth_closure" {
     Text.Printf.fmtWidth_closure:
         const Text.Printf.fmtWidth_info;
 },
 Text.Printf.fmtWidth_entry() //  [R2]
         { info_tbl: [(ccemX,
                       label: Text.Printf.fmtWidth_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccemX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccemY; else goto ccemZ;
       ccemY: // global
           R2 = R2;
           R1 = Text.Printf.fmtWidth_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccemZ: // global
           I64[Sp - 8] = block_ccemU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucen3; else goto ccemV;
       ucen3: // global
           call _ccemU(R1) args: 0, res: 0, upd: 0;
       ccemV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccemU() //  [R1]
         { info_tbl: [(ccemU,
                       label: block_ccemU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccemU: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.267826507 UTC

[section ""data" . Text.Printf.fpRest_closure" {
     Text.Printf.fpRest_closure:
         const Text.Printf.fpRest_info;
 },
 Text.Printf.fpRest_entry() //  [R2]
         { info_tbl: [(ccenb,
                       label: Text.Printf.fpRest_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccenb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccenc; else goto ccend;
       ccenc: // global
           R2 = R2;
           R1 = Text.Printf.fpRest_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccend: // global
           I64[Sp - 8] = block_ccen8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucenh; else goto ccen9;
       ucenh: // global
           call _ccen8(R1) args: 0, res: 0, upd: 0;
       ccen9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccen8() //  [R1]
         { info_tbl: [(ccen8,
                       label: block_ccen8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccen8: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.269166721 UTC

[section ""data" . Text.Printf.fpChar_closure" {
     Text.Printf.fpChar_closure:
         const Text.Printf.fpChar_info;
 },
 Text.Printf.fpChar_entry() //  [R2]
         { info_tbl: [(ccenp,
                       label: Text.Printf.fpChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccenp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccenq; else goto ccenr;
       ccenq: // global
           R2 = R2;
           R1 = Text.Printf.fpChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccenr: // global
           I64[Sp - 8] = block_ccenm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucenv; else goto ccenn;
       ucenv: // global
           call _ccenm(R1) args: 0, res: 0, upd: 0;
       ccenn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccenm() //  [R1]
         { info_tbl: [(ccenm,
                       label: block_ccenm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccenm: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.27047879 UTC

[section ""data" . Text.Printf.fpModifiers_closure" {
     Text.Printf.fpModifiers_closure:
         const Text.Printf.fpModifiers_info;
 },
 Text.Printf.fpModifiers_entry() //  [R2]
         { info_tbl: [(ccenD,
                       label: Text.Printf.fpModifiers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccenD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccenE; else goto ccenF;
       ccenE: // global
           R2 = R2;
           R1 = Text.Printf.fpModifiers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccenF: // global
           I64[Sp - 8] = block_ccenA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucenJ; else goto ccenB;
       ucenJ: // global
           call _ccenA(R1) args: 0, res: 0, upd: 0;
       ccenB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccenA() //  [R1]
         { info_tbl: [(ccenA,
                       label: block_ccenA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccenA: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.271712484 UTC

[section ""data" . Text.Printf.printf_closure" {
     Text.Printf.printf_closure:
         const Text.Printf.printf_info;
 },
 Text.Printf.printf_entry() //  [R2, R3]
         { info_tbl: [(ccenO,
                       label: Text.Printf.printf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccenO: // global
           _scceR::P64 = R3;
           R3 = GHC.Types.[]_closure+1;
           _scceQ::P64 = R2;
           R2 = _scceR::P64;
           R1 = _scceQ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.272669859 UTC

[section ""data" . Text.Printf.hPrintf_closure" {
     Text.Printf.hPrintf_closure:
         const Text.Printf.hPrintf_info;
 },
 Text.Printf.hPrintf_entry() //  [R2, R3, R4]
         { info_tbl: [(ccenV,
                       label: Text.Printf.hPrintf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccenV: // global
           _scceU::P64 = R4;
           R4 = GHC.Types.[]_closure+1;
           _scceT::P64 = R3;
           R3 = _scceU::P64;
           _scceS::P64 = R2;
           R2 = _scceT::P64;
           R1 = _scceS::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.274097414 UTC

[section ""data" . Text.Printf.vFmt_closure" {
     Text.Printf.vFmt_closure:
         const Text.Printf.vFmt_info;
 },
 Text.Printf.vFmt_entry() //  [R2, R3]
         { info_tbl: [(cceo5,
                       label: Text.Printf.vFmt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceo5: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cceo9; else goto cceoa;
       cceo9: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.vFmt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cceoa: // global
           I64[Sp - 16] = block_cceo2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceor; else goto cceo3;
       uceor: // global
           call _cceo2(R1) args: 0, res: 0, upd: 0;
       cceo3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceo2() //  [R1]
         { info_tbl: [(cceo2,
                       label: block_cceo2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceo2: // global
           I64[Sp - 56] = block_cceo8_info;
           _scceX::P64 = R1;
           _scceY::P64 = P64[R1 + 7];
           _scceZ::P64 = P64[R1 + 15];
           _sccf0::P64 = P64[R1 + 23];
           _sccf1::P64 = P64[R1 + 31];
           _sccf2::P64 = P64[R1 + 39];
           _sccf3::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 48] = _scceY::P64;
           P64[Sp - 40] = _scceZ::P64;
           P64[Sp - 32] = _sccf0::P64;
           P64[Sp - 24] = _sccf1::P64;
           P64[Sp - 16] = _sccf2::P64;
           P64[Sp - 8] = _sccf3::P64;
           P64[Sp] = _scceX::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uceoq; else goto cceoc;
       uceoq: // global
           call _cceo8(R1) args: 0, res: 0, upd: 0;
       cceoc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceo8() //  [R1]
         { info_tbl: [(cceo8,
                       label: block_cceo8_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceo8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cceoi; else goto cceoh;
       cceoi: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceoh: // global
           if (I64[R1 + 7] == 118) goto cceop; else goto cceol;
       cceop: // global
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 64];
           R1 = Hp - 55;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cceol: // global
           Hp = Hp - 64;
           R1 = P64[Sp + 56] & (-8);
           Sp = Sp + 72;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.275848098 UTC

[section ""cstring" . lvl_rccbg_bytes" {
     lvl_rccbg_bytes:
         I8[] [112,114,105,110,116,102,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.276708064 UTC

[section ""data" . Text.Printf.perror_closure" {
     Text.Printf.perror_closure:
         const Text.Printf.perror_info;
         const 0;
 },
 Text.Printf.perror_entry() //  [R2]
         { info_tbl: [(cceoy,
                       label: Text.Printf.perror_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceoy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cceoz; else goto cceoA;
       cceoz: // global
           R2 = R2;
           R1 = Text.Printf.perror_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cceoA: // global
           I64[Sp - 8] = block_cceow_info;
           R3 = R2;
           R2 = lvl_rccbg_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceow() //  [R1]
         { info_tbl: [(cceow,
                       label: block_cceow_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceow: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.277964044 UTC

[section ""data" . lvl1_rccbh_closure" {
     lvl1_rccbh_closure:
         const :_con_info;
         const GHC.Show.$fShowChar3_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.278597932 UTC

[section ""cstring" . lvl2_rccbi_bytes" {
     lvl2_rccbi_bytes:
         I8[] [98,97,100,32,102,111,114,109,97,116,116,105,110,103,32,99,104,97,114,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.280011837 UTC

[section ""data" . Text.Printf.$werrorBadFormat_closure" {
     Text.Printf.$werrorBadFormat_closure:
         const Text.Printf.$werrorBadFormat_info;
         const 0;
 },
 sat_sccfc_entry() //  [R1]
         { info_tbl: [(cceoW,
                       label: sat_sccfc_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceoW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceoX; else goto cceoY;
       cceoX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceoY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = lvl1_rccbh_closure+2;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$wshowLitChar_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccfd_entry() //  [R1]
         { info_tbl: [(ccep2,
                       label: sat_sccfd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccep2: // global
           _sccfd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccep3; else goto ccep4;
       ccep4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccep6; else goto ccep5;
       ccep6: // global
           HpAlloc = 48;
           goto ccep3;
       ccep3: // global
           R1 = _sccfd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccep5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccfd::P64;
           _sccfb::I64 = I64[_sccfd::P64 + 16];
           if (_sccfb::I64 != 39) goto ccep0; else goto ccep1;
       ccep0: // global
           I64[Hp - 40] = sat_sccfc_info;
           I64[Hp - 24] = _sccfb::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShowChar3_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccep1: // global
           Hp = Hp - 48;
           R1 = GHC.Show.$fShowChar1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccfe_entry() //  [R1]
         { info_tbl: [(ccep8,
                       label: sat_sccfe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccep8: // global
           _sccfe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccep9; else goto ccepa;
       ccepa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccepc; else goto ccepb;
       ccepc: // global
           HpAlloc = 24;
           goto ccep9;
       ccep9: // global
           R1 = _sccfe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccepb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccfe::P64;
           _sccfa::I64 = I64[_sccfe::P64 + 16];
           I64[Hp - 16] = sat_sccfd_info;
           I64[Hp] = _sccfa::I64;
           R3 = Hp - 16;
           R2 = lvl2_rccbi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$werrorBadFormat_entry() //  [R2]
         { info_tbl: [(ccepf,
                       label: Text.Printf.$werrorBadFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccepf: // global
           _sccfa::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccepg; else goto cceph;
       cceph: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccepj; else goto ccepi;
       ccepj: // global
           HpAlloc = 24;
           goto ccepg;
       ccepg: // global
           R2 = _sccfa::I64;
           R1 = Text.Printf.$werrorBadFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccepi: // global
           I64[Hp - 16] = sat_sccfe_info;
           I64[Hp] = _sccfa::I64;
           I64[Sp - 8] = block_ccepd_info;
           R3 = Hp - 16;
           R2 = lvl_rccbg_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccepd() //  [R1]
         { info_tbl: [(ccepd,
                       label: block_ccepd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccepd: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.282665452 UTC

[section ""data" . Text.Printf.errorBadFormat_closure" {
     Text.Printf.errorBadFormat_closure:
         const Text.Printf.errorBadFormat_info;
         const 0;
 },
 Text.Printf.errorBadFormat_entry() //  [R2]
         { info_tbl: [(ccepu,
                       label: Text.Printf.errorBadFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccepu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccepv; else goto ccepw;
       ccepv: // global
           R2 = R2;
           R1 = Text.Printf.errorBadFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccepw: // global
           I64[Sp - 8] = block_ccepr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucepA; else goto cceps;
       ucepA: // global
           call _ccepr(R1) args: 0, res: 0, upd: 0;
       cceps: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccepr() //  [R1]
         { info_tbl: [(ccepr,
                       label: block_ccepr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccepr: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.283748033 UTC

[section ""cstring" . lvl3_rccbj_bytes" {
     lvl3_rccbj_bytes:
         I8[] [112,114,105,110,116,102,58,32,102,111,114,109,97,116,116,105,110,103,32,115,116,114,105,110,103,32,101,110,100,101,100,32,112,114,101,109,97,116,117,114,101,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.284649842 UTC

[section ""data" . Text.Printf.errorShortFormat_closure" {
     Text.Printf.errorShortFormat_closure:
         const Text.Printf.errorShortFormat_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorShortFormat_entry() //  [R1]
         { info_tbl: [(ccepJ,
                       label: Text.Printf.errorShortFormat_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccepJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccepK; else goto ccepL;
       ccepK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccepL: // global
           (_ccepE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccepE::I64 == 0) goto ccepG; else goto ccepF;
       ccepG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccepF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccepE::I64;
           I64[Sp - 24] = block_ccepH_info;
           R2 = lvl3_rccbj_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccepH() //  [R1]
         { info_tbl: [(ccepH,
                       label: block_ccepH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccepH: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.286208049 UTC

[section ""data" . Text.Printf.$dmparseFormat_closure" {
     Text.Printf.$dmparseFormat_closure:
         const Text.Printf.$dmparseFormat_info;
         const 0;
 },
 Text.Printf.$dmparseFormat_entry() //  [R2, R3, R4]
         { info_tbl: [(cceq0,
                       label: Text.Printf.$dmparseFormat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceq0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cceq1; else goto cceq2;
       cceq1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$dmparseFormat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cceq2: // global
           I64[Sp - 8] = block_ccepT_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uceqc; else goto ccepU;
       uceqc: // global
           call _ccepT(R1) args: 0, res: 0, upd: 0;
       ccepU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccepT() //  [R1]
         { info_tbl: [(ccepT,
                       label: block_ccepT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccepT: // global
           if (R1 & 7 == 1) goto ccepX; else goto ccepY;
       ccepX: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccepY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cceqb; else goto cceqa;
       cceqb: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceqa: // global
           _sccfo::P64 = P64[R1 + 6];
           _sccfp::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccfo::P64;
           P64[Hp] = _sccfp::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.287577303 UTC

[section ""cstring" . lvl4_rccbk_bytes" {
     lvl4_rccbk_bytes:
         I8[] [112,114,105,110,116,102,58,32,97,114,103,117,109,101,110,116,32,108,105,115,116,32,101,110,100,101,100,32,112,114,101,109,97,116,117,114,101,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.288572324 UTC

[section ""data" . Text.Printf.errorMissingArgument_closure" {
     Text.Printf.errorMissingArgument_closure:
         const Text.Printf.errorMissingArgument_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorMissingArgument_entry() //  [R1]
         { info_tbl: [(cceql,
                       label: Text.Printf.errorMissingArgument_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceql: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cceqm; else goto cceqn;
       cceqm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceqn: // global
           (_cceqg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceqg::I64 == 0) goto cceqi; else goto cceqh;
       cceqi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceqh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceqg::I64;
           I64[Sp - 24] = block_cceqj_info;
           R2 = lvl4_rccbk_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceqj() //  [R1]
         { info_tbl: [(cceqj,
                       label: block_cceqj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceqj: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.2898453 UTC

[section ""cstring" . lvl5_rccbl_bytes" {
     lvl5_rccbl_bytes:
         I8[] [112,114,105,110,116,102,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.290723253 UTC

[section ""data" . Text.Printf.errorBadArgument_closure" {
     Text.Printf.errorBadArgument_closure:
         const Text.Printf.errorBadArgument_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorBadArgument_entry() //  [R1]
         { info_tbl: [(cceqz,
                       label: Text.Printf.errorBadArgument_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceqz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cceqA; else goto cceqB;
       cceqA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceqB: // global
           (_ccequ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccequ::I64 == 0) goto cceqw; else goto cceqv;
       cceqw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceqv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccequ::I64;
           I64[Sp - 24] = block_cceqx_info;
           R2 = lvl5_rccbl_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceqx() //  [R1]
         { info_tbl: [(cceqx,
                       label: block_cceqx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceqx: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.292035712 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble9_bytes" {
     Text.Printf.$fPrintfArgDouble9_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.29280978 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble8_closure" {
     Text.Printf.$fPrintfArgDouble8_closure:
         const Text.Printf.$fPrintfArgDouble8_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble8_entry() //  [R1]
         { info_tbl: [(cceqL,
                       label: Text.Printf.$fPrintfArgDouble8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceqL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceqM; else goto cceqN;
       cceqM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceqN: // global
           (_cceqI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceqI::I64 == 0) goto cceqK; else goto cceqJ;
       cceqK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceqJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceqI::I64;
           R2 = Text.Printf.$fPrintfArgDouble9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.294077012 UTC

[section ""cstring" . lvl6_rccbm_bytes" {
     lvl6_rccbm_bytes:
         I8[] [112,114,105,110,116,102,58,32,105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,105,109,112,111,115,115,105,98,108,101,32,100,102,109,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.295012152 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble7_closure" {
     Text.Printf.$fPrintfArgDouble7_closure:
         const Text.Printf.$fPrintfArgDouble7_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble7_entry() //  [R1]
         { info_tbl: [(cceqW,
                       label: Text.Printf.$fPrintfArgDouble7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceqW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cceqX; else goto cceqY;
       cceqX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceqY: // global
           (_cceqR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceqR::I64 == 0) goto cceqT; else goto cceqS;
       cceqT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceqS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceqR::I64;
           I64[Sp - 24] = block_cceqU_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceqU() //  [R1]
         { info_tbl: [(cceqU,
                       label: block_cceqU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceqU: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.298778312 UTC

[section ""data" . Text.Printf.$w$sdfmt_closure" {
     Text.Printf.$w$sdfmt_closure:
         const Text.Printf.$w$sdfmt_info;
         const 0;
 },
 Text.Printf.$w$sdfmt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccer3: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2,
                                           R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$w$sdfmt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccer9,
                       label: Text.Printf.$w$sdfmt_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccer9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccera; else goto ccerb;
       ccera: // global
           R1 = Text.Printf.$w$sdfmt_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ccerb: // global
           _sccfw::P64 = R5;
           _sccfv::P64 = R4;
           _sccfu::P64 = R3;
           (_sccfB::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(R2);
           (_sccfG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(R2);
           if (_sccfG::I64 > 1114111) goto ccerq; else goto cceu4;
       ccerq: // global
           R2 = _sccfG::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cceu4: // global
           if (_sccfG::I64 < 103) goto uceu9; else goto uceub;
       uceu9: // global
           if (_sccfG::I64 < 102) goto uceua; else goto ccesR;
       uceua: // global
           if (_sccfG::I64 < 101) goto ccesr; else goto ccesF;
       ccesF: // global
           I64[Sp - 24] = block_ccesz_info;
           R1 = _sccfw::P64;
           P64[Sp - 16] = _sccfu::P64;
           I64[Sp - 8] = _sccfB::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uceuj; else goto ccesA;
       uceuj: // global
           call _ccesz(R1) args: 0, res: 0, upd: 0;
       ccesA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccesR: // global
           I64[Sp - 32] = block_ccesQ_info;
           R1 = _sccfv::P64;
           P64[Sp - 24] = _sccfu::P64;
           P64[Sp - 16] = _sccfw::P64;
           I64[Sp - 8] = _sccfB::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uceuk; else goto ccesT;
       uceuk: // global
           call _ccesQ(R1) args: 0, res: 0, upd: 0;
       ccesT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uceub: // global
           if (_sccfG::I64 >= 104) goto ccesr; else goto ccetv;
       ccesr: // global
           R1 = Text.Printf.$fPrintfArgDouble7_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccetv: // global
           I64[Sp - 32] = block_ccetu_info;
           R1 = _sccfv::P64;
           P64[Sp - 24] = _sccfu::P64;
           P64[Sp - 16] = _sccfw::P64;
           I64[Sp - 8] = _sccfB::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uceul; else goto ccetx;
       uceul: // global
           call _ccetu(R1) args: 0, res: 0, upd: 0;
       ccetx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccesz() //  [R1]
         { info_tbl: [(ccesz,
                       label: block_ccesz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccesz: // global
           _sccfu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccesE_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = _sccfu::P64;
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 8;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccesE() //  [R1]
         { info_tbl: [(ccesE,
                       label: block_ccesE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccesE: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _ccesQ() //  [R1]
         { info_tbl: [(ccesQ,
                       label: block_ccesQ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccesQ: // global
           _sccfw::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccet5; else goto ccetk;
       ccet5: // global
           I64[Sp] = block_ccesX_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto uceur; else goto ccesY;
       uceur: // global
           call _ccesX(R1) args: 0, res: 0, upd: 0;
       ccesY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccetk: // global
           I64[Sp] = block_ccetd_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto uceus; else goto ccete;
       uceus: // global
           call _ccetd(R1) args: 0, res: 0, upd: 0;
       ccete: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccesX() //  [R1]
         { info_tbl: [(ccesX,
                       label: block_ccesX_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccesX: // global
           I64[Sp + 16] = block_ccet2_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccet2() //  [R1]
         { info_tbl: [(ccet2,
                       label: block_ccet2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccet2: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _ccetd() //  [R1]
         { info_tbl: [(ccetd,
                       label: block_ccetd_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccetd: // global
           I64[Sp + 16] = block_cceti_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceti() //  [R1]
         { info_tbl: [(cceti,
                       label: block_cceti_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceti: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _ccetu() //  [R1]
         { info_tbl: [(ccetu,
                       label: block_ccetu_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccetu: // global
           _sccfw::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccetJ; else goto ccetY;
       ccetJ: // global
           I64[Sp] = block_ccetB_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto uceuv; else goto ccetC;
       uceuv: // global
           call _ccetB(R1) args: 0, res: 0, upd: 0;
       ccetC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccetY: // global
           I64[Sp] = block_ccetR_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto uceuw; else goto ccetS;
       uceuw: // global
           call _ccetR(R1) args: 0, res: 0, upd: 0;
       ccetS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccetB() //  [R1]
         { info_tbl: [(ccetB,
                       label: block_ccetB_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccetB: // global
           I64[Sp + 16] = block_ccetG_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccetG() //  [R1]
         { info_tbl: [(ccetG,
                       label: block_ccetG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccetG: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _ccetR() //  [R1]
         { info_tbl: [(ccetR,
                       label: block_ccetR_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccetR: // global
           I64[Sp + 16] = block_ccetW_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccetW() //  [R1]
         { info_tbl: [(ccetW,
                       label: block_ccetW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccetW: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _sccfK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccfK: // global
           _sccfL::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto cces0; else goto ccerD;
       cces0: // global
           I64[Sp + 8] = block_ccerZ_info;
           R1 = _sccfL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uceuz; else goto cces1;
       uceuz: // global
           call _ccerZ(R1) args: 0, res: 0, upd: 0;
       cces1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccerD: // global
           I64[Sp + 8] = block_ccerB_info;
           R3 = _sccfL::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccerZ() //  [R1]
         { info_tbl: [(ccerZ,
                       label: block_ccerZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccerZ: // global
           if (R1 & 7 == 1) goto uceui; else goto ccesc;
       uceui: // global
           Sp = Sp + 8;
           call _cces7() args: 0, res: 0, upd: 0;
       ccesc: // global
           I64[Sp - 16] = block_ccesa_info;
           _sccfT::P64 = R1;
           _sccfV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccfV::P64;
           P64[Sp] = _sccfT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceuo; else goto ccesd;
       uceuo: // global
           call _ccesa(R1) args: 0, res: 0, upd: 0;
       ccesd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccesa() //  [R1]
         { info_tbl: [(ccesa,
                       label: block_ccesa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccesa: // global
           if (I64[R1 + 7] == 45) goto ccesl; else goto ccesk;
       ccesl: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccesk: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccerB() //  [R1]
         { info_tbl: [(ccerB,
                       label: block_ccerB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccerB: // global
           if (R1 & 7 == 1) goto uceuh; else goto ccerO;
       uceuh: // global
           Sp = Sp + 8;
           call _cces7() args: 0, res: 0, upd: 0;
       ccerO: // global
           I64[Sp - 16] = block_ccerM_info;
           _sccfN::P64 = R1;
           _sccfP::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccfP::P64;
           P64[Sp] = _sccfN::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceum; else goto ccerP;
       uceum: // global
           call _ccerM(R1) args: 0, res: 0, upd: 0;
       ccerP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cces7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cces7: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccerM() //  [R1]
         { info_tbl: [(ccerM,
                       label: block_ccerM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccerM: // global
           if (I64[R1 + 7] == 45) goto ccerX; else goto ccerW;
       ccerX: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccerW: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.304122524 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat1_closure" {
     Text.Printf.$fPrintfArgFloat1_closure:
         const Text.Printf.$fPrintfArgFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat1_entry() //  [R1]
         { info_tbl: [(cceuI,
                       label: Text.Printf.$fPrintfArgFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceuI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cceuJ; else goto cceuK;
       cceuJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceuK: // global
           (_cceuD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceuD::I64 == 0) goto cceuF; else goto cceuE;
       cceuF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceuE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceuD::I64;
           I64[Sp - 24] = block_cceuG_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceuG() //  [R1]
         { info_tbl: [(cceuG,
                       label: block_cceuG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceuG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.307262329 UTC

[section ""data" . Text.Printf.$w$sdfmt1_closure" {
     Text.Printf.$w$sdfmt1_closure:
         const Text.Printf.$w$sdfmt1_info;
         const 0;
 },
 Text.Printf.$w$sdfmt1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceuP: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$w$sdfmt1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cceuV,
                       label: Text.Printf.$w$sdfmt1_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceuV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cceuW; else goto cceuX;
       cceuW: // global
           R1 = Text.Printf.$w$sdfmt1_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cceuX: // global
           _sccgm::P64 = R5;
           _sccgl::P64 = R4;
           _sccgk::P64 = R3;
           (_sccgr::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(R2);
           (_sccgw::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(R2);
           if (_sccgw::I64 > 1114111) goto ccevc; else goto ccexQ;
       ccevc: // global
           R2 = _sccgw::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccexQ: // global
           if (_sccgw::I64 < 103) goto ucexV; else goto ucexX;
       ucexV: // global
           if (_sccgw::I64 < 102) goto ucexW; else goto ccewD;
       ucexW: // global
           if (_sccgw::I64 < 101) goto ccewd; else goto ccewr;
       ccewr: // global
           I64[Sp - 24] = block_ccewl_info;
           R1 = _sccgm::P64;
           P64[Sp - 16] = _sccgk::P64;
           I64[Sp - 8] = _sccgr::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucey5; else goto ccewm;
       ucey5: // global
           call _ccewl(R1) args: 0, res: 0, upd: 0;
       ccewm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccewD: // global
           I64[Sp - 32] = block_ccewC_info;
           R1 = _sccgl::P64;
           P64[Sp - 24] = _sccgk::P64;
           P64[Sp - 16] = _sccgm::P64;
           I64[Sp - 8] = _sccgr::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucey6; else goto ccewF;
       ucey6: // global
           call _ccewC(R1) args: 0, res: 0, upd: 0;
       ccewF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucexX: // global
           if (_sccgw::I64 >= 104) goto ccewd; else goto ccexh;
       ccewd: // global
           R1 = Text.Printf.$fPrintfArgFloat1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccexh: // global
           I64[Sp - 32] = block_ccexg_info;
           R1 = _sccgl::P64;
           P64[Sp - 24] = _sccgk::P64;
           P64[Sp - 16] = _sccgm::P64;
           I64[Sp - 8] = _sccgr::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucey7; else goto ccexj;
       ucey7: // global
           call _ccexg(R1) args: 0, res: 0, upd: 0;
       ccexj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccewl() //  [R1]
         { info_tbl: [(ccewl,
                       label: block_ccewl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccewl: // global
           _sccgk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccewq_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = _sccgk::P64;
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 8;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccewq() //  [R1]
         { info_tbl: [(ccewq,
                       label: block_ccewq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccewq: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _ccewC() //  [R1]
         { info_tbl: [(ccewC,
                       label: block_ccewC_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccewC: // global
           _sccgm::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccewR; else goto ccex6;
       ccewR: // global
           I64[Sp] = block_ccewJ_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto uceyd; else goto ccewK;
       uceyd: // global
           call _ccewJ(R1) args: 0, res: 0, upd: 0;
       ccewK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccex6: // global
           I64[Sp] = block_ccewZ_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto uceye; else goto ccex0;
       uceye: // global
           call _ccewZ(R1) args: 0, res: 0, upd: 0;
       ccex0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccewJ() //  [R1]
         { info_tbl: [(ccewJ,
                       label: block_ccewJ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccewJ: // global
           I64[Sp + 16] = block_ccewO_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccewO() //  [R1]
         { info_tbl: [(ccewO,
                       label: block_ccewO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccewO: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _ccewZ() //  [R1]
         { info_tbl: [(ccewZ,
                       label: block_ccewZ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccewZ: // global
           I64[Sp + 16] = block_ccex4_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccex4() //  [R1]
         { info_tbl: [(ccex4,
                       label: block_ccex4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccex4: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _ccexg() //  [R1]
         { info_tbl: [(ccexg,
                       label: block_ccexg_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccexg: // global
           _sccgm::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccexv; else goto ccexK;
       ccexv: // global
           I64[Sp] = block_ccexn_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto uceyh; else goto ccexo;
       uceyh: // global
           call _ccexn(R1) args: 0, res: 0, upd: 0;
       ccexo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccexK: // global
           I64[Sp] = block_ccexD_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto uceyi; else goto ccexE;
       uceyi: // global
           call _ccexD(R1) args: 0, res: 0, upd: 0;
       ccexE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccexn() //  [R1]
         { info_tbl: [(ccexn,
                       label: block_ccexn_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccexn: // global
           I64[Sp + 16] = block_ccexs_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccexs() //  [R1]
         { info_tbl: [(ccexs,
                       label: block_ccexs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccexs: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _ccexD() //  [R1]
         { info_tbl: [(ccexD,
                       label: block_ccexD_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccexD: // global
           I64[Sp + 16] = block_ccexI_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccexI() //  [R1]
         { info_tbl: [(ccexI,
                       label: block_ccexI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccexI: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _sccgA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccgA: // global
           _sccgB::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto ccevM; else goto ccevp;
       ccevM: // global
           I64[Sp + 8] = block_ccevL_info;
           R1 = _sccgB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uceyl; else goto ccevN;
       uceyl: // global
           call _ccevL(R1) args: 0, res: 0, upd: 0;
       ccevN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccevp: // global
           I64[Sp + 8] = block_ccevn_info;
           R3 = _sccgB::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccevL() //  [R1]
         { info_tbl: [(ccevL,
                       label: block_ccevL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccevL: // global
           if (R1 & 7 == 1) goto ucey4; else goto ccevY;
       ucey4: // global
           Sp = Sp + 8;
           call _ccevT() args: 0, res: 0, upd: 0;
       ccevY: // global
           I64[Sp - 16] = block_ccevW_info;
           _sccgJ::P64 = R1;
           _sccgL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccgL::P64;
           P64[Sp] = _sccgJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceya; else goto ccevZ;
       uceya: // global
           call _ccevW(R1) args: 0, res: 0, upd: 0;
       ccevZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccevW() //  [R1]
         { info_tbl: [(ccevW,
                       label: block_ccevW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccevW: // global
           if (I64[R1 + 7] == 45) goto ccew7; else goto ccew6;
       ccew7: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccew6: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccevn() //  [R1]
         { info_tbl: [(ccevn,
                       label: block_ccevn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccevn: // global
           if (R1 & 7 == 1) goto ucey3; else goto ccevA;
       ucey3: // global
           Sp = Sp + 8;
           call _ccevT() args: 0, res: 0, upd: 0;
       ccevA: // global
           I64[Sp - 16] = block_ccevy_info;
           _sccgD::P64 = R1;
           _sccgF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccgF::P64;
           P64[Sp] = _sccgD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucey8; else goto ccevB;
       ucey8: // global
           call _ccevy(R1) args: 0, res: 0, upd: 0;
       ccevB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccevT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccevT: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccevy() //  [R1]
         { info_tbl: [(ccevy,
                       label: block_ccevy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccevy: // global
           if (I64[R1 + 7] == 45) goto ccevJ; else goto ccevI;
       ccevJ: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccevI: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.312358311 UTC

[section ""data" . Text.Printf.formatRealFloat1_closure" {
     Text.Printf.formatRealFloat1_closure:
         const Text.Printf.formatRealFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.formatRealFloat1_entry() //  [R1]
         { info_tbl: [(cceyu,
                       label: Text.Printf.formatRealFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceyu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cceyv; else goto cceyw;
       cceyv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceyw: // global
           (_cceyp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceyp::I64 == 0) goto cceyr; else goto cceyq;
       cceyr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceyq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceyp::I64;
           I64[Sp - 24] = block_cceys_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceys() //  [R1]
         { info_tbl: [(cceys,
                       label: block_cceys_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceys: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.31546873 UTC

[section ""data" . Text.Printf.$wdfmt_closure" {
     Text.Printf.$wdfmt_closure:
         const Text.Printf.$wdfmt_info;
         const 0;
 },
 Text.Printf.$wdfmt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceyB: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2,
                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wdfmt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cceyH,
                       label: Text.Printf.$wdfmt_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceyH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cceyI; else goto cceyJ;
       cceyI: // global
           R1 = Text.Printf.$wdfmt_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cceyJ: // global
           _scchd::P64 = R6;
           _scchc::P64 = R5;
           _scchb::P64 = R4;
           _sccha::I64 = R3;
           _cceyM::I64 = R3;
           (_scchi::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(_cceyM::I64);
           (_scchn::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(_sccha::I64);
           if (_scchn::I64 > 1114111) goto cceyY; else goto cceB8;
       cceyY: // global
           R2 = _scchn::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cceB8: // global
           if (_scchn::I64 < 103) goto uceBd; else goto uceBf;
       uceBd: // global
           if (_scchn::I64 < 102) goto uceBe; else goto cceAj;
       uceBe: // global
           if (_scchn::I64 < 101) goto ccezZ; else goto cceA8;
       cceA8: // global
           I64[Sp - 16] = block_cceA7_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFExponent_closure+1;
           R2 = R2;
           I64[Sp - 8] = _scchi::I64;
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       cceAj: // global
           I64[Sp - 40] = block_cceAi_info;
           R1 = _scchc::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = _scchb::P64;
           P64[Sp - 16] = _scchd::P64;
           I64[Sp - 8] = _scchi::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uceBn; else goto cceAl;
       uceBn: // global
           call _cceAi(R1) args: 0, res: 0, upd: 0;
       cceAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uceBf: // global
           if (_scchn::I64 >= 104) goto ccezZ; else goto cceAL;
       ccezZ: // global
           R1 = Text.Printf.formatRealFloat1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cceAL: // global
           I64[Sp - 40] = block_cceAK_info;
           R1 = _scchc::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = _scchb::P64;
           P64[Sp - 16] = _scchd::P64;
           I64[Sp - 8] = _scchi::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uceBo; else goto cceAN;
       uceBo: // global
           call _cceAK(R1) args: 0, res: 0, upd: 0;
       cceAN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceA7() //  [R1]
         { info_tbl: [(cceA7,
                       label: block_cceA7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceA7: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _cceAi() //  [R1]
         { info_tbl: [(cceAi,
                       label: block_cceAi_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceAi: // global
           _scch9::P64 = P64[Sp + 8];
           _scchb::P64 = P64[Sp + 16];
           _scchd::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cceAs; else goto cceAB;
       cceAs: // global
           I64[Sp + 24] = block_cceAp_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       cceAB: // global
           I64[Sp + 24] = block_cceAz_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.True_closure+2;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceAp() //  [R1]
         { info_tbl: [(cceAp,
                       label: block_cceAp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceAp: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _cceAz() //  [R1]
         { info_tbl: [(cceAz,
                       label: block_cceAz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceAz: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _cceAK() //  [R1]
         { info_tbl: [(cceAK,
                       label: block_cceAK_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceAK: // global
           _scch9::P64 = P64[Sp + 8];
           _scchb::P64 = P64[Sp + 16];
           _scchd::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cceAU; else goto cceB3;
       cceAU: // global
           I64[Sp + 24] = block_cceAR_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       cceB3: // global
           I64[Sp + 24] = block_cceB1_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.True_closure+2;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceAR() //  [R1]
         { info_tbl: [(cceAR,
                       label: block_cceAR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceAR: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _cceB1() //  [R1]
         { info_tbl: [(cceB1,
                       label: block_cceB1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceB1: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _scchr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scchr: // global
           _scchs::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto ccezy; else goto ccezb;
       ccezy: // global
           I64[Sp + 8] = block_ccezx_info;
           R1 = _scchs::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uceBy; else goto ccezz;
       uceBy: // global
           call _ccezx(R1) args: 0, res: 0, upd: 0;
       ccezz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccezb: // global
           I64[Sp + 8] = block_ccez9_info;
           R3 = _scchs::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccezx() //  [R1]
         { info_tbl: [(ccezx,
                       label: block_ccezx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccezx: // global
           if (R1 & 7 == 1) goto uceBm; else goto ccezK;
       uceBm: // global
           Sp = Sp + 8;
           call _ccezF() args: 0, res: 0, upd: 0;
       ccezK: // global
           I64[Sp - 16] = block_ccezI_info;
           _scchA::P64 = R1;
           _scchC::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scchC::P64;
           P64[Sp] = _scchA::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceBr; else goto ccezL;
       uceBr: // global
           call _ccezI(R1) args: 0, res: 0, upd: 0;
       ccezL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccezI() //  [R1]
         { info_tbl: [(ccezI,
                       label: block_ccezI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccezI: // global
           if (I64[R1 + 7] == 45) goto ccezT; else goto ccezS;
       ccezT: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccezS: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccez9() //  [R1]
         { info_tbl: [(ccez9,
                       label: block_ccez9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccez9: // global
           if (R1 & 7 == 1) goto uceBl; else goto ccezm;
       uceBl: // global
           Sp = Sp + 8;
           call _ccezF() args: 0, res: 0, upd: 0;
       ccezm: // global
           I64[Sp - 16] = block_ccezk_info;
           _scchu::P64 = R1;
           _scchw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scchw::P64;
           P64[Sp] = _scchu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceBp; else goto ccezn;
       uceBp: // global
           call _ccezk(R1) args: 0, res: 0, upd: 0;
       ccezn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccezF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccezF: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccezk() //  [R1]
         { info_tbl: [(ccezk,
                       label: block_ccezk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccezk: // global
           if (I64[R1 + 7] == 45) goto ccezv; else goto ccezu;
       ccezv: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccezu: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.319700215 UTC

[section ""cstring" . Text.Printf.$trModule4_bytes" {
     Text.Printf.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.320271339 UTC

[section ""data" . Text.Printf.$trModule3_closure" {
     Text.Printf.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.320871099 UTC

[section ""cstring" . Text.Printf.$trModule2_bytes" {
     Text.Printf.$trModule2_bytes:
         I8[] [84,101,120,116,46,80,114,105,110,116,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.321466529 UTC

[section ""data" . Text.Printf.$trModule1_closure" {
     Text.Printf.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.32450139 UTC

[section ""data" . Text.Printf.$trModule_closure" {
     Text.Printf.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Text.Printf.$trModule3_closure+1;
         const Text.Printf.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.325188524 UTC

[section ""data" . $krep_rccbn_closure" {
     $krep_rccbn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.326042305 UTC

[section ""data" . $krep1_rccbo_closure" {
     $krep1_rccbo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.326612466 UTC

[section ""data" . $krep2_rccbp_closure" {
     $krep2_rccbp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.327182366 UTC

[section ""data" . $krep3_rccbq_closure" {
     $krep3_rccbq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.327774454 UTC

[section ""data" . $krep4_rccbr_closure" {
     $krep4_rccbr_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.328386373 UTC

[section ""data" . $krep5_rccbs_closure" {
     $krep5_rccbs_closure:
         const :_con_info;
         const $krep1_rccbo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.328925783 UTC

[section ""data" . $krep6_rccbt_closure" {
     $krep6_rccbt_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep5_rccbs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.3295946 UTC

[section ""data" . $krep7_rccbu_closure" {
     $krep7_rccbu_closure:
         const :_con_info;
         const $krep3_rccbq_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.330138067 UTC

[section ""data" . $krep8_rccbv_closure" {
     $krep8_rccbv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep7_rccbu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.330724211 UTC

[section ""data" . $krep9_rccbw_closure" {
     $krep9_rccbw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep8_rccbv_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.331279016 UTC

[section ""data" . Text.Printf.$tcHPrintfType1_closure" {
     Text.Printf.$tcHPrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep4_rccbr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.331846381 UTC

[section ""data" . $krep10_rccbx_closure" {
     $krep10_rccbx_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.332406387 UTC

[section ""data" . $krep11_rccby_closure" {
     $krep11_rccby_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep3_rccbq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.332988277 UTC

[section ""data" . $krep12_rccbz_closure" {
     $krep12_rccbz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep10_rccbx_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.33362082 UTC

[section ""cstring" . Text.Printf.$tcIsChar2_bytes" {
     Text.Printf.$tcIsChar2_bytes:
         I8[] [73,115,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.334155813 UTC

[section ""data" . Text.Printf.$tcIsChar1_closure" {
     Text.Printf.$tcIsChar1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcIsChar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.33475036 UTC

[section ""data" . Text.Printf.$tcIsChar_closure" {
     Text.Printf.$tcIsChar_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcIsChar1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 660225335504909605;
         const 5800397900948792736;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.335302341 UTC

[section ""data" . $krep13_rccbA_closure" {
     $krep13_rccbA_closure:
         const :_con_info;
         const $krep10_rccbx_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.335848698 UTC

[section ""data" . $krep14_rccbB_closure" {
     $krep14_rccbB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcIsChar_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.336429452 UTC

[section ""data" . $krep15_rccbC_closure" {
     $krep15_rccbC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_rccbz_closure+4;
         const $krep14_rccbB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.336991417 UTC

[section ""data" . Text.Printf.$tc'C:IsChar1_closure" {
     Text.Printf.$tc'C:IsChar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rccby_closure+4;
         const $krep15_rccbC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.337657765 UTC

[section ""cstring" . Text.Printf.$tc'C:IsChar3_bytes" {
     Text.Printf.$tc'C:IsChar3_bytes:
         I8[] [39,67,58,73,115,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.338186269 UTC

[section ""data" . Text.Printf.$tc'C:IsChar2_closure" {
     Text.Printf.$tc'C:IsChar2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:IsChar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.33879155 UTC

[section ""data" . Text.Printf.$tc'C:IsChar_closure" {
     Text.Printf.$tc'C:IsChar_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:IsChar2_closure+1;
         const Text.Printf.$tc'C:IsChar1_closure+4;
         const 15586488259906363003;
         const 17643381548147423706;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.339370933 UTC

[section ""cstring" . Text.Printf.$tcFormatAdjustment2_bytes" {
     Text.Printf.$tcFormatAdjustment2_bytes:
         I8[] [70,111,114,109,97,116,65,100,106,117,115,116,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.339933875 UTC

[section ""data" . Text.Printf.$tcFormatAdjustment1_closure" {
     Text.Printf.$tcFormatAdjustment1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatAdjustment2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.340450722 UTC

[section ""data" . Text.Printf.$tcFormatAdjustment_closure" {
     Text.Printf.$tcFormatAdjustment_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatAdjustment1_closure+1;
         const GHC.Types.krep$*_closure;
         const 7532892403054408380;
         const 17299592949916286280;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.341069143 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust1_closure" {
     Text.Printf.$tc'LeftAdjust1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatAdjustment_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.341751106 UTC

[section ""cstring" . Text.Printf.$tc'LeftAdjust3_bytes" {
     Text.Printf.$tc'LeftAdjust3_bytes:
         I8[] [39,76,101,102,116,65,100,106,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.342340712 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust2_closure" {
     Text.Printf.$tc'LeftAdjust2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'LeftAdjust3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.342879745 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust_closure" {
     Text.Printf.$tc'LeftAdjust_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'LeftAdjust2_closure+1;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const 3724221440131574524;
         const 12430068224974793646;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.343485111 UTC

[section ""cstring" . Text.Printf.$tc'ZeroPad2_bytes" {
     Text.Printf.$tc'ZeroPad2_bytes:
         I8[] [39,90,101,114,111,80,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.344047822 UTC

[section ""data" . Text.Printf.$tc'ZeroPad1_closure" {
     Text.Printf.$tc'ZeroPad1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'ZeroPad2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.344641974 UTC

[section ""data" . Text.Printf.$tc'ZeroPad_closure" {
     Text.Printf.$tc'ZeroPad_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'ZeroPad1_closure+1;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const 4688343247861108158;
         const 7307113320833774212;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.345236859 UTC

[section ""data" . $krep16_rccbD_closure" {
     $krep16_rccbD_closure:
         const :_con_info;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.346040498 UTC

[section ""data" . $krep17_rccbE_closure" {
     $krep17_rccbE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep16_rccbD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.346589875 UTC

[section ""cstring" . Text.Printf.$tcFormatSign2_bytes" {
     Text.Printf.$tcFormatSign2_bytes:
         I8[] [70,111,114,109,97,116,83,105,103,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.34711775 UTC

[section ""data" . Text.Printf.$tcFormatSign1_closure" {
     Text.Printf.$tcFormatSign1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatSign2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.347653184 UTC

[section ""data" . Text.Printf.$tcFormatSign_closure" {
     Text.Printf.$tcFormatSign_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatSign1_closure+1;
         const GHC.Types.krep$*_closure;
         const 35986971025498593;
         const 9833165860459639351;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.348193195 UTC

[section ""data" . Text.Printf.$tc'SignPlus1_closure" {
     Text.Printf.$tc'SignPlus1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatSign_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.348735944 UTC

[section ""cstring" . Text.Printf.$tc'SignPlus3_bytes" {
     Text.Printf.$tc'SignPlus3_bytes:
         I8[] [39,83,105,103,110,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.349334824 UTC

[section ""data" . Text.Printf.$tc'SignPlus2_closure" {
     Text.Printf.$tc'SignPlus2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'SignPlus3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.351080332 UTC

[section ""data" . Text.Printf.$tc'SignPlus_closure" {
     Text.Printf.$tc'SignPlus_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'SignPlus2_closure+1;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const 18302065795158432479;
         const 11830941225366619964;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.351686584 UTC

[section ""cstring" . Text.Printf.$tc'SignSpace2_bytes" {
     Text.Printf.$tc'SignSpace2_bytes:
         I8[] [39,83,105,103,110,83,112,97,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.352241986 UTC

[section ""data" . Text.Printf.$tc'SignSpace1_closure" {
     Text.Printf.$tc'SignSpace1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'SignSpace2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.352838738 UTC

[section ""data" . Text.Printf.$tc'SignSpace_closure" {
     Text.Printf.$tc'SignSpace_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'SignSpace1_closure+1;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const 111286303843533919;
         const 13624428119758319457;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.353537057 UTC

[section ""data" . $krep18_rccbF_closure" {
     $krep18_rccbF_closure:
         const :_con_info;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.354122355 UTC

[section ""data" . $krep19_rccbG_closure" {
     $krep19_rccbG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep18_rccbF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.354708371 UTC

[section ""cstring" . Text.Printf.$tcFieldFormat2_bytes" {
     Text.Printf.$tcFieldFormat2_bytes:
         I8[] [70,105,101,108,100,70,111,114,109,97,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.355300794 UTC

[section ""data" . Text.Printf.$tcFieldFormat1_closure" {
     Text.Printf.$tcFieldFormat1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFieldFormat2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.355867075 UTC

[section ""data" . Text.Printf.$tcFieldFormat_closure" {
     Text.Printf.$tcFieldFormat_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFieldFormat1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12330325036165183082;
         const 5846211506648458401;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.356517816 UTC

[section ""data" . $krep20_rccbH_closure" {
     $krep20_rccbH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFieldFormat_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.357089165 UTC

[section ""data" . $krep21_rccbI_closure" {
     $krep21_rccbI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep20_rccbH_closure+1;
         const $krep9_rccbw_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.357724266 UTC

[section ""data" . $krep22_rccbJ_closure" {
     $krep22_rccbJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep21_rccbI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.358290698 UTC

[section ""data" . $krep23_rccbK_closure" {
     $krep23_rccbK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep20_rccbH_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.358847025 UTC

[section ""data" . $krep24_rccbL_closure" {
     $krep24_rccbL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep23_rccbK_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.359395171 UTC

[section ""data" . $krep25_rccbM_closure" {
     $krep25_rccbM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rccbn_closure+1;
         const $krep24_rccbL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.360009321 UTC

[section ""data" . $krep26_rccbN_closure" {
     $krep26_rccbN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep19_rccbG_closure+1;
         const $krep25_rccbM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.360577791 UTC

[section ""data" . $krep27_rccbO_closure" {
     $krep27_rccbO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_rccbE_closure+1;
         const $krep26_rccbN_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.361114692 UTC

[section ""data" . $krep28_rccbP_closure" {
     $krep28_rccbP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rccbt_closure+1;
         const $krep27_rccbO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.36174762 UTC

[section ""data" . Text.Printf.$tc'FieldFormat1_closure" {
     Text.Printf.$tc'FieldFormat1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rccbt_closure+1;
         const $krep28_rccbP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.362309928 UTC

[section ""cstring" . Text.Printf.$tc'FieldFormat3_bytes" {
     Text.Printf.$tc'FieldFormat3_bytes:
         I8[] [39,70,105,101,108,100,70,111,114,109,97,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.362861676 UTC

[section ""data" . Text.Printf.$tc'FieldFormat2_closure" {
     Text.Printf.$tc'FieldFormat2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'FieldFormat3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.363420019 UTC

[section ""data" . Text.Printf.$tc'FieldFormat_closure" {
     Text.Printf.$tc'FieldFormat_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'FieldFormat2_closure+1;
         const Text.Printf.$tc'FieldFormat1_closure+4;
         const 11348432599023007686;
         const 6814357301696130957;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.364015595 UTC

[section ""cstring" . Text.Printf.$tcFormatParse2_bytes" {
     Text.Printf.$tcFormatParse2_bytes:
         I8[] [70,111,114,109,97,116,80,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.364539357 UTC

[section ""data" . Text.Printf.$tcFormatParse1_closure" {
     Text.Printf.$tcFormatParse1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatParse2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.365121761 UTC

[section ""data" . Text.Printf.$tcFormatParse_closure" {
     Text.Printf.$tcFormatParse_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatParse1_closure+1;
         const GHC.Types.krep$*_closure;
         const 5517048358589873764;
         const 8326725038359313810;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.366403385 UTC

[section ""data" . $krep29_rccbQ_closure" {
     $krep29_rccbQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatParse_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.367028973 UTC

[section ""data" . $krep30_rccbR_closure" {
     $krep30_rccbR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep29_rccbQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.367652241 UTC

[section ""data" . $krep31_rccbS_closure" {
     $krep31_rccbS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep30_rccbR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.368215868 UTC

[section ""data" . $krep32_rccbT_closure" {
     $krep32_rccbT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep30_rccbR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.368802315 UTC

[section ""data" . Text.Printf.$tc'FormatParse1_closure" {
     Text.Printf.$tc'FormatParse1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep32_rccbT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.369380172 UTC

[section ""cstring" . Text.Printf.$tc'FormatParse3_bytes" {
     Text.Printf.$tc'FormatParse3_bytes:
         I8[] [39,70,111,114,109,97,116,80,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.369963841 UTC

[section ""data" . Text.Printf.$tc'FormatParse2_closure" {
     Text.Printf.$tc'FormatParse2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'FormatParse3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.370539978 UTC

[section ""data" . Text.Printf.$tc'FormatParse_closure" {
     Text.Printf.$tc'FormatParse_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'FormatParse2_closure+1;
         const Text.Printf.$tc'FormatParse1_closure+4;
         const 549767054447046648;
         const 1116614444935710689;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.371152752 UTC

[section ""data" . $krep33_rccbU_closure" {
     $krep33_rccbU_closure:
         const :_con_info;
         const $krep21_rccbI_closure+4;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.371748675 UTC

[section ""data" . $krep34_rccbV_closure" {
     $krep34_rccbV_closure:
         const :_con_info;
         const $krep30_rccbR_closure+4;
         const $krep33_rccbU_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.372331145 UTC

[section ""data" . $krep35_rccbW_closure" {
     $krep35_rccbW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep34_rccbV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.372929034 UTC

[section ""data" . $krep36_rccbX_closure" {
     $krep36_rccbX_closure:
         const :_con_info;
         const $krep35_rccbW_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.373527368 UTC

[section ""data" . $krep37_rccbY_closure" {
     $krep37_rccbY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep36_rccbX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.374100251 UTC

[section ""data" . $krep38_rccbZ_closure" {
     $krep38_rccbZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep37_rccbY_closure+1;
         const $krep10_rccbx_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.374693797 UTC

[section ""data" . $krep39_rccc0_closure" {
     $krep39_rccc0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep38_rccbZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.375276237 UTC

[section ""data" . $krep40_rccc1_closure" {
     $krep40_rccc1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rccbp_closure+1;
         const $krep39_rccc0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.375825067 UTC

[section ""cstring" . Text.Printf.$tcPrintfArg2_bytes" {
     Text.Printf.$tcPrintfArg2_bytes:
         I8[] [80,114,105,110,116,102,65,114,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.376406928 UTC

[section ""data" . Text.Printf.$tcPrintfArg1_closure" {
     Text.Printf.$tcPrintfArg1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcPrintfArg2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.378147153 UTC

[section ""data" . Text.Printf.$tcPrintfArg_closure" {
     Text.Printf.$tcPrintfArg_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcPrintfArg1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 14684532792197610005;
         const 5760551473172190061;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.378776531 UTC

[section ""data" . $krep41_rccc2_closure" {
     $krep41_rccc2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcPrintfArg_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.379356884 UTC

[section ""data" . $krep42_rccc3_closure" {
     $krep42_rccc3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep31_rccbS_closure+4;
         const $krep41_rccc2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.379951753 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg1_closure" {
     Text.Printf.$tc'C:PrintfArg1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep22_rccbJ_closure+4;
         const $krep42_rccc3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.380551996 UTC

[section ""cstring" . Text.Printf.$tc'C:PrintfArg3_bytes" {
     Text.Printf.$tc'C:PrintfArg3_bytes:
         I8[] [39,67,58,80,114,105,110,116,102,65,114,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.381110831 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg2_closure" {
     Text.Printf.$tc'C:PrintfArg2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:PrintfArg3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.381718268 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg_closure" {
     Text.Printf.$tc'C:PrintfArg_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:PrintfArg2_closure+1;
         const Text.Printf.$tc'C:PrintfArg1_closure+4;
         const 11923342243699112506;
         const 8346787778082712340;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.382306026 UTC

[section ""cstring" . Text.Printf.$tcHPrintfType3_bytes" {
     Text.Printf.$tcHPrintfType3_bytes:
         I8[] [72,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.38288318 UTC

[section ""data" . Text.Printf.$tcHPrintfType2_closure" {
     Text.Printf.$tcHPrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcHPrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.383414608 UTC

[section ""data" . Text.Printf.$tcHPrintfType_closure" {
     Text.Printf.$tcHPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcHPrintfType2_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 13104883804062546050;
         const 15477829653093370802;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.38402075 UTC

[section ""data" . $krep43_rccc4_closure" {
     $krep43_rccc4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcHPrintfType_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.384532887 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType1_closure" {
     Text.Printf.$tc'C:HPrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep40_rccc1_closure+4;
         const $krep43_rccc4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.385138059 UTC

[section ""cstring" . Text.Printf.$tc'C:HPrintfType3_bytes" {
     Text.Printf.$tc'C:HPrintfType3_bytes:
         I8[] [39,67,58,72,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.385729467 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType2_closure" {
     Text.Printf.$tc'C:HPrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:HPrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.386307875 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType_closure" {
     Text.Printf.$tc'C:HPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:HPrintfType2_closure+1;
         const Text.Printf.$tc'C:HPrintfType1_closure+4;
         const 16716104921226462095;
         const 4043378586122981700;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.386862237 UTC

[section ""cstring" . Text.Printf.$tcPrintfType2_bytes" {
     Text.Printf.$tcPrintfType2_bytes:
         I8[] [80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.387421831 UTC

[section ""data" . Text.Printf.$tcPrintfType1_closure" {
     Text.Printf.$tcPrintfType1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcPrintfType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.388008308 UTC

[section ""data" . Text.Printf.$tcPrintfType_closure" {
     Text.Printf.$tcPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcPrintfType1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 16100185319445667829;
         const 10371264040433388740;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.388607322 UTC

[section ""data" . $krep44_rccc5_closure" {
     $krep44_rccc5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcPrintfType_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.389185645 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType1_closure" {
     Text.Printf.$tc'C:PrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep39_rccc0_closure+4;
         const $krep44_rccc5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.389791891 UTC

[section ""cstring" . Text.Printf.$tc'C:PrintfType3_bytes" {
     Text.Printf.$tc'C:PrintfType3_bytes:
         I8[] [39,67,58,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.390369082 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType2_closure" {
     Text.Printf.$tc'C:PrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:PrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.390932913 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType_closure" {
     Text.Printf.$tc'C:PrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:PrintfType2_closure+1;
         const Text.Printf.$tc'C:PrintfType1_closure+4;
         const 6199067271817529220;
         const 10070277982064886839;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.391535 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar24_bytes" {
     Text.Printf.$fPrintfArgChar24_bytes:
         I8[] [104,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.392335925 UTC

[section ""data" . Text.Printf.$fPrintfArgChar23_closure" {
     Text.Printf.$fPrintfArgChar23_closure:
         const Text.Printf.$fPrintfArgChar23_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar23_entry() //  [R1]
         { info_tbl: [(cceBF,
                       label: Text.Printf.$fPrintfArgChar23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceBF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceBG; else goto cceBH;
       cceBG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceBH: // global
           (_cceBC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceBC::I64 == 0) goto cceBE; else goto cceBD;
       cceBE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceBD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceBC::I64;
           R2 = Text.Printf.$fPrintfArgChar24_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.393614945 UTC

[section ""data" . sat_scchP_closure" {
     sat_scchP_closure:
         const GHC.Types.I#_con_info;
         const 128;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.394183107 UTC

[section ""data" . sat_scchQ_closure" {
     sat_scchQ_closure:
         const :_con_info;
         const sat_scchP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.394964614 UTC

[section ""data" . Text.Printf.$fPrintfArgChar22_closure" {
     Text.Printf.$fPrintfArgChar22_closure:
         const Text.Printf.$fPrintfArgChar22_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar22_entry() //  [R1]
         { info_tbl: [(cceBO,
                       label: Text.Printf.$fPrintfArgChar22_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceBO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceBP; else goto cceBQ;
       cceBP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceBQ: // global
           (_cceBL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceBL::I64 == 0) goto cceBN; else goto cceBM;
       cceBN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceBM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceBL::I64;
           R3 = sat_scchQ_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.395892475 UTC

[section ""data" . Text.Printf.$fPrintfArgChar21_closure" {
     Text.Printf.$fPrintfArgChar21_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar23_closure;
         const Text.Printf.$fPrintfArgChar22_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.396442021 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar20_bytes" {
     Text.Printf.$fPrintfArgChar20_bytes:
         I8[] [104]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.397163244 UTC

[section ""data" . Text.Printf.$fPrintfArgChar19_closure" {
     Text.Printf.$fPrintfArgChar19_closure:
         const Text.Printf.$fPrintfArgChar19_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar19_entry() //  [R1]
         { info_tbl: [(cceBX,
                       label: Text.Printf.$fPrintfArgChar19_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceBX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceBY; else goto cceBZ;
       cceBY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceBZ: // global
           (_cceBU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceBU::I64 == 0) goto cceBW; else goto cceBV;
       cceBW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceBV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceBU::I64;
           R2 = Text.Printf.$fPrintfArgChar20_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.398083782 UTC

[section ""data" . sat_scchR_closure" {
     sat_scchR_closure:
         const GHC.Types.I#_con_info;
         const 32768;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.398703052 UTC

[section ""data" . sat_scchS_closure" {
     sat_scchS_closure:
         const :_con_info;
         const sat_scchR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.399454459 UTC

[section ""data" . Text.Printf.$fPrintfArgChar18_closure" {
     Text.Printf.$fPrintfArgChar18_closure:
         const Text.Printf.$fPrintfArgChar18_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar18_entry() //  [R1]
         { info_tbl: [(cceC6,
                       label: Text.Printf.$fPrintfArgChar18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceC6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceC7; else goto cceC8;
       cceC7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceC8: // global
           (_cceC3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceC3::I64 == 0) goto cceC5; else goto cceC4;
       cceC5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceC4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceC3::I64;
           R3 = sat_scchS_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.400413776 UTC

[section ""data" . Text.Printf.$fPrintfArgChar17_closure" {
     Text.Printf.$fPrintfArgChar17_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar19_closure;
         const Text.Printf.$fPrintfArgChar18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.400972312 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar16_bytes" {
     Text.Printf.$fPrintfArgChar16_bytes:
         I8[] [108]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.401718795 UTC

[section ""data" . Text.Printf.$fPrintfArgChar15_closure" {
     Text.Printf.$fPrintfArgChar15_closure:
         const Text.Printf.$fPrintfArgChar15_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar15_entry() //  [R1]
         { info_tbl: [(cceCf,
                       label: Text.Printf.$fPrintfArgChar15_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceCf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceCg; else goto cceCh;
       cceCg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceCh: // global
           (_cceCc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceCc::I64 == 0) goto cceCe; else goto cceCd;
       cceCe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceCd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceCc::I64;
           R2 = Text.Printf.$fPrintfArgChar16_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.402617128 UTC

[section ""data" . sat_scchU_closure" {
     sat_scchU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.403188182 UTC

[section ""data" . sat_scchV_closure" {
     sat_scchV_closure:
         const :_con_info;
         const sat_scchU_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.403720523 UTC

[section ""data" . sat_scchT_closure" {
     sat_scchT_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.404315312 UTC

[section ""data" . sat_scchW_closure" {
     sat_scchW_closure:
         const :_con_info;
         const sat_scchT_closure+1;
         const sat_scchV_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.404996684 UTC

[section ""data" . Text.Printf.$fPrintfArgChar14_closure" {
     Text.Printf.$fPrintfArgChar14_closure:
         const Text.Printf.$fPrintfArgChar14_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar14_entry() //  [R1]
         { info_tbl: [(cceCo,
                       label: Text.Printf.$fPrintfArgChar14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceCo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceCp; else goto cceCq;
       cceCp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceCq: // global
           (_cceCl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceCl::I64 == 0) goto cceCn; else goto cceCm;
       cceCn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceCm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceCl::I64;
           R3 = sat_scchW_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.406576069 UTC

[section ""data" . Text.Printf.$fPrintfArgChar13_closure" {
     Text.Printf.$fPrintfArgChar13_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar15_closure;
         const Text.Printf.$fPrintfArgChar14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.407214825 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar12_bytes" {
     Text.Printf.$fPrintfArgChar12_bytes:
         I8[] [108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.407916348 UTC

[section ""data" . Text.Printf.$fPrintfArgChar11_closure" {
     Text.Printf.$fPrintfArgChar11_closure:
         const Text.Printf.$fPrintfArgChar11_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar11_entry() //  [R1]
         { info_tbl: [(cceCx,
                       label: Text.Printf.$fPrintfArgChar11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceCx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceCy; else goto cceCz;
       cceCy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceCz: // global
           (_cceCu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceCu::I64 == 0) goto cceCw; else goto cceCv;
       cceCw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceCv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceCu::I64;
           R2 = Text.Printf.$fPrintfArgChar12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.408816971 UTC

[section ""data" . sat_scchZ_closure" {
     sat_scchZ_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.409865839 UTC

[section ""data" . sat_scci0_closure" {
     sat_scci0_closure:
         const :_con_info;
         const sat_scchZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.41048609 UTC

[section ""data" . sat_scchY_closure" {
     sat_scchY_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.411050747 UTC

[section ""data" . sat_scci1_closure" {
     sat_scci1_closure:
         const :_con_info;
         const sat_scchY_closure+1;
         const sat_scci0_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.41166698 UTC

[section ""data" . sat_scchX_closure" {
     sat_scchX_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.412220268 UTC

[section ""data" . sat_scci2_closure" {
     sat_scci2_closure:
         const :_con_info;
         const sat_scchX_closure+1;
         const sat_scci1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.412971023 UTC

[section ""data" . Text.Printf.$fPrintfArgChar7_closure" {
     Text.Printf.$fPrintfArgChar7_closure:
         const Text.Printf.$fPrintfArgChar7_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar7_entry() //  [R1]
         { info_tbl: [(cceCG,
                       label: Text.Printf.$fPrintfArgChar7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceCG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceCH; else goto cceCI;
       cceCH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceCI: // global
           (_cceCD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceCD::I64 == 0) goto cceCF; else goto cceCE;
       cceCF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceCE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceCD::I64;
           R3 = sat_scci2_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.413915667 UTC

[section ""data" . Text.Printf.$fPrintfArgChar10_closure" {
     Text.Printf.$fPrintfArgChar10_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar11_closure;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.414515483 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar9_bytes" {
     Text.Printf.$fPrintfArgChar9_bytes:
         I8[] [76]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.415232165 UTC

[section ""data" . Text.Printf.$fPrintfArgChar8_closure" {
     Text.Printf.$fPrintfArgChar8_closure:
         const Text.Printf.$fPrintfArgChar8_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar8_entry() //  [R1]
         { info_tbl: [(cceCP,
                       label: Text.Printf.$fPrintfArgChar8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceCP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceCQ; else goto cceCR;
       cceCQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceCR: // global
           (_cceCM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceCM::I64 == 0) goto cceCO; else goto cceCN;
       cceCO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceCN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceCM::I64;
           R2 = Text.Printf.$fPrintfArgChar9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.416117325 UTC

[section ""data" . Text.Printf.$fPrintfArgChar6_closure" {
     Text.Printf.$fPrintfArgChar6_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar8_closure;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.416659203 UTC

[section ""data" . Text.Printf.$fPrintfArgChar5_closure" {
     Text.Printf.$fPrintfArgChar5_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.417203184 UTC

[section ""data" . Text.Printf.$fPrintfArgChar4_closure" {
     Text.Printf.$fPrintfArgChar4_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar10_closure+1;
         const Text.Printf.$fPrintfArgChar5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.417813246 UTC

[section ""data" . Text.Printf.$fPrintfArgChar3_closure" {
     Text.Printf.$fPrintfArgChar3_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar13_closure+1;
         const Text.Printf.$fPrintfArgChar4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.41842748 UTC

[section ""data" . Text.Printf.$fPrintfArgChar2_closure" {
     Text.Printf.$fPrintfArgChar2_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar17_closure+1;
         const Text.Printf.$fPrintfArgChar3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.419005198 UTC

[section ""data" . Text.Printf.intModifierMap_closure" {
     Text.Printf.intModifierMap_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar21_closure+1;
         const Text.Printf.$fPrintfArgChar2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.419619223 UTC

[section ""cstring" . lvl7_rccc6_bytes" {
     lvl7_rccc6_bytes:
         I8[] [112,114,105,110,116,102,58,32,117,110,107,110,111,119,110,32,102,111,114,109,97,116,32,109,111,100,105,102,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.420449329 UTC

[section ""data" . Text.Printf.$fPrintfArgInt2_closure" {
     Text.Printf.$fPrintfArgInt2_closure:
         const Text.Printf.$fPrintfArgInt2_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgInt2_entry() //  [R1]
         { info_tbl: [(cceD0,
                       label: Text.Printf.$fPrintfArgInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceD0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cceD1; else goto cceD2;
       cceD1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceD2: // global
           (_cceCV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceCV::I64 == 0) goto cceCX; else goto cceCW;
       cceCX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceCW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceCV::I64;
           I64[Sp - 24] = block_cceCY_info;
           R2 = lvl7_rccc6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceCY() //  [R1]
         { info_tbl: [(cceCY,
                       label: block_cceCY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceCY: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.42196518 UTC

[section ""data" . Text.Printf.$wfixupMods_closure" {
     Text.Printf.$wfixupMods_closure:
         const Text.Printf.$wfixupMods_info;
         const 0;
 },
 Text.Printf.$wfixupMods_entry() //  [R2, R3]
         { info_tbl: [(cceDh,
                       label: Text.Printf.$wfixupMods_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceDh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceDi; else goto cceDj;
       cceDi: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$wfixupMods_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cceDj: // global
           I64[Sp - 16] = block_cceDa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceDC; else goto cceDb;
       uceDC: // global
           call _cceDa(R1) args: 0, res: 0, upd: 0;
       cceDb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceDa() //  [R1]
         { info_tbl: [(cceDa,
                       label: block_cceDa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceDa: // global
           if (R1 & 7 == 1) goto cceDe; else goto cceDf;
       cceDe: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cceDf: // global
           I64[Sp + 8] = block_cceDp_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           Sp = Sp + 8;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceDp() //  [R1]
         { info_tbl: [(cceDp,
                       label: block_cceDp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceDp: // global
           if (R1 & 7 == 1) goto cceDw; else goto cceDA;
       cceDw: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cceDA: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.423452656 UTC

[section ""data" . Text.Printf.fixupMods_closure" {
     Text.Printf.fixupMods_closure:
         const Text.Printf.fixupMods_info;
         const 0;
 },
 Text.Printf.fixupMods_entry() //  [R2, R3]
         { info_tbl: [(cceDK,
                       label: Text.Printf.fixupMods_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceDK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceDL; else goto cceDM;
       cceDL: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.fixupMods_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cceDM: // global
           I64[Sp - 16] = block_cceDH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceDQ; else goto cceDI;
       uceDQ: // global
           call _cceDH(R1) args: 0, res: 0, upd: 0;
       cceDI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceDH() //  [R1]
         { info_tbl: [(cceDH,
                       label: block_cceDH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceDH: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 47];
           Sp = Sp + 16;
           call Text.Printf.$wfixupMods_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.42675139 UTC

[section ""data" . Text.Printf.$wparseIntFormat_closure" {
     Text.Printf.$wparseIntFormat_closure:
         const Text.Printf.$wparseIntFormat_info;
         const 0;
 },
 go_sccim_entry() //  [R1, R2]
         { info_tbl: [(cceE7,
                       label: go_sccim_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceE7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cceE8; else goto cceE9;
       cceE8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cceE9: // global
           I64[Sp - 24] = block_cceE0_info;
           _sccim::P64 = R1;
           _sccil::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sccil::P64;
           P64[Sp - 8] = _sccim::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uceFY; else goto cceE1;
       uceFY: // global
           call _cceE0(R1) args: 0, res: 0, upd: 0;
       cceE1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceE0() //  [R1]
         { info_tbl: [(cceE0,
                       label: block_cceE0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceE0: // global
           if (R1 & 7 == 1) goto uceFQ; else goto cceE5;
       uceFQ: // global
           Sp = Sp + 24;
           call _cceEz() args: 0, res: 0, upd: 0;
       cceE5: // global
           I64[Sp - 8] = block_cceEf_info;
           _scciq::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scciq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uceFW; else goto cceEh;
       uceFW: // global
           call _cceEf(R1) args: 0, res: 0, upd: 0;
       cceEh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceEf() //  [R1]
         { info_tbl: [(cceEf,
                       label: block_cceEf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceEf: // global
           _scciq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cceEl_info;
           R2 = _scciq::P64;
           _sccis::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sccis::P64;
           Sp = Sp + 8;
           call go_sccim_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceEl() //  [R1]
         { info_tbl: [(cceEl,
                       label: block_cceEl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceEl: // global
           if (R1 & 7 == 1) goto cceEt; else goto cceF7;
       cceEt: // global
           _sccil::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cceEq_info;
           R4 = _sccil::P64;
           R3 = P64[Sp + 16];
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp + 8;
           call Data.OldList.stripPrefix_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
       cceF7: // global
           I64[Sp - 8] = block_cceEW_info;
           _scciu::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _scciu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uceFZ; else goto cceEX;
       uceFZ: // global
           call _cceEW(R1) args: 0, res: 0, upd: 0;
       cceEX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceEq() //  [R1]
         { info_tbl: [(cceEq,
                       label: block_cceEq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceEq: // global
           if (R1 & 7 == 1) goto uceFU; else goto cceEE;
       uceFU: // global
           Sp = Sp + 16;
           call _cceEz() args: 0, res: 0, upd: 0;
       cceEE: // global
           I64[Sp] = block_cceEC_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uceG0; else goto cceEF;
       uceG0: // global
           call _cceEC(R1) args: 0, res: 0, upd: 0;
       cceEF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceEz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceEz: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cceEC() //  [R1]
         { info_tbl: [(cceEC,
                       label: block_cceEC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceEC: // global
           if (R1 & 7 == 1) goto uceFV; else goto cceEQ;
       uceFV: // global
           Sp = Sp + 16;
           call _cceFB() args: 0, res: 0, upd: 0;
       cceEQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cceET; else goto cceES;
       cceET: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceES: // global
           _scciy::P64 = P64[R1 + 6];
           _scciz::P64 = P64[R1 + 14];
           I64[Hp - 40] = Text.Printf.FormatParse_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _scciy::P64;
           P64[Hp - 16] = _scciz::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cceEW() //  [R1]
         { info_tbl: [(cceEW,
                       label: block_cceEW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceEW: // global
           I64[Sp] = block_cceF1_info;
           R3 = 0;
           R2 = P64[R1 + 7];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceF1() //  [R1]
         { info_tbl: [(cceF1,
                       label: block_cceF1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceF1: // global
           I64[Sp - 8] = block_cceF5_info;
           R3 = 0;
           R2 = P64[Sp + 24];
           I64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceF5() //  [R1]
         { info_tbl: [(cceF5,
                       label: block_cceF5_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceF5: // global
           if (%MO_S_Lt_W64(I64[Sp + 8], R1)) goto cceFj; else goto uceFR;
       cceFj: // global
           I64[Sp + 8] = block_cceFh_info;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp + 8;
           call Data.OldList.stripPrefix_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
       uceFR: // global
           Sp = Sp + 16;
           call _cceFK() args: 0, res: 0, upd: 0;
     }
 },
 _cceFh() //  [R1]
         { info_tbl: [(cceFh,
                       label: block_cceFh_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceFh: // global
           if (R1 & 7 == 1) goto uceFS; else goto cceFu;
       uceFS: // global
           Sp = Sp + 8;
           call _cceFK() args: 0, res: 0, upd: 0;
       cceFu: // global
           I64[Sp + 16] = block_cceFs_info;
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uceG4; else goto cceFv;
       uceG4: // global
           call _cceFs(R1) args: 0, res: 0, upd: 0;
       cceFv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceFs() //  [R1]
         { info_tbl: [(cceFs,
                       label: block_cceFs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceFs: // global
           if (R1 & 7 == 1) goto uceFT; else goto cceFG;
       uceFT: // global
           Sp = Sp + 16;
           call _cceFB() args: 0, res: 0, upd: 0;
       cceFG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cceFJ; else goto cceFI;
       cceFJ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceFI: // global
           _scciN::P64 = P64[R1 + 6];
           _scciO::P64 = P64[R1 + 14];
           I64[Hp - 40] = Text.Printf.FormatParse_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _scciN::P64;
           P64[Hp - 16] = _scciO::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cceFB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceFB: // global
           R1 = Text.Printf.errorShortFormat_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cceFK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceFK: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wparseIntFormat_entry() //  [R2]
         { info_tbl: [(cceGd,
                       label: Text.Printf.$wparseIntFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceGd: // global
           _sccil::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cceGe; else goto cceGf;
       cceGf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cceGh; else goto cceGg;
       cceGh: // global
           HpAlloc = 16;
           goto cceGe;
       cceGe: // global
           R2 = _sccil::P64;
           R1 = Text.Printf.$wparseIntFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cceGg: // global
           I64[Hp - 8] = go_sccim_info;
           P64[Hp] = _sccil::P64;
           I64[Sp - 16] = block_cceG7_info;
           R2 = Text.Printf.intModifierMap_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sccil::P64;
           Sp = Sp - 16;
           call go_sccim_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceG7() //  [R1]
         { info_tbl: [(cceG7,
                       label: block_cceG7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceG7: // global
           if (R1 & 7 == 1) goto cceGa; else goto cceGb;
       cceGa: // global
           _sccil::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cceGk_info;
           R1 = _sccil::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uceGE; else goto cceGm;
       uceGE: // global
           call _cceGk(R1) args: 0, res: 0, upd: 0;
       cceGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cceGb: // global
           R1 = P64[R1 + 6] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cceGk() //  [R1]
         { info_tbl: [(cceGk,
                       label: block_cceGk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceGk: // global
           if (R1 & 7 == 1) goto cceGs; else goto cceGw;
       cceGs: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cceGw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cceGz; else goto cceGy;
       cceGz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceGy: // global
           _scciS::P64 = P64[R1 + 6];
           _scciT::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _scciS::P64;
           P64[Hp] = _scciT::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.431260887 UTC

[section ""data" . Text.Printf.parseIntFormat_closure" {
     Text.Printf.parseIntFormat_closure:
         const Text.Printf.parseIntFormat_info;
         const 0;
 },
 Text.Printf.parseIntFormat_entry() //  [R3]
         { info_tbl: [(cceGJ,
                       label: Text.Printf.parseIntFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceGJ: // global
           R2 = R3;
           call Text.Printf.$wparseIntFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.431994098 UTC

[section ""cstring" . lvl8_rccc7_bytes" {
     lvl8_rccc7_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.432699933 UTC

[section ""data" . lvl9_rccc8_closure" {
     lvl9_rccc8_closure:
         const lvl9_rccc8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rccc8_entry() //  [R1]
         { info_tbl: [(cceGS,
                       label: lvl9_rccc8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceGS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceGT; else goto cceGU;
       cceGT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceGU: // global
           (_cceGP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceGP::I64 == 0) goto cceGR; else goto cceGQ;
       cceGR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceGQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceGP::I64;
           R2 = lvl8_rccc7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.433779828 UTC

[section ""data" . lvl10_rccc9_closure" {
     lvl10_rccc9_closure:
         const lvl10_rccc9_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_rccc9_entry() //  [R1]
         { info_tbl: [(cceH1,
                       label: lvl10_rccc9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceH1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceH2; else goto cceH3;
       cceH2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceH3: // global
           (_cceGY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceGY::I64 == 0) goto cceH0; else goto cceGZ;
       cceH0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceGZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceGY::I64;
           R2 = Text.Printf.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.434797645 UTC

[section ""data" . lvl11_rccca_closure" {
     lvl11_rccca_closure:
         const lvl11_rccca_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rccca_entry() //  [R1]
         { info_tbl: [(cceHa,
                       label: lvl11_rccca_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceHa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceHb; else goto cceHc;
       cceHb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceHc: // global
           (_cceH7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceH7::I64 == 0) goto cceH9; else goto cceH8;
       cceH9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceH8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceH7::I64;
           R2 = Text.Printf.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.435628759 UTC

[section ""cstring" . lvl12_rcccb_bytes" {
     lvl12_rcccb_bytes:
         I8[] [46,47,84,101,120,116,47,80,114,105,110,116,102,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.436348194 UTC

[section ""data" . lvl13_rcccc_closure" {
     lvl13_rcccc_closure:
         const lvl13_rcccc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rcccc_entry() //  [R1]
         { info_tbl: [(cceHj,
                       label: lvl13_rcccc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceHj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceHk; else goto cceHl;
       cceHk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceHl: // global
           (_cceHg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceHg::I64 == 0) goto cceHi; else goto cceHh;
       cceHi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceHh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceHg::I64;
           R2 = lvl12_rcccb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.437295698 UTC

[section ""data" . lvl14_rcccd_closure" {
     lvl14_rcccd_closure:
         const GHC.Types.I#_con_info;
         const 323;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.437870779 UTC

[section ""data" . lvl15_rccce_closure" {
     lvl15_rccce_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.438451895 UTC

[section ""data" . lvl16_rcccf_closure" {
     lvl16_rcccf_closure:
         const GHC.Types.I#_con_info;
         const 49;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.439038408 UTC

[section ""data" . lvl17_rcccg_closure" {
     lvl17_rcccg_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl10_rccc9_closure;
         const lvl11_rccca_closure;
         const lvl13_rcccc_closure;
         const lvl14_rcccd_closure+1;
         const lvl15_rccce_closure+1;
         const lvl14_rcccd_closure+1;
         const lvl16_rcccf_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.439685179 UTC

[section ""data" . lvl18_rccch_closure" {
     lvl18_rccch_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl9_rccc8_closure;
         const lvl17_rcccg_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.440442306 UTC

[section ""data" . Text.Printf.$fPrintfArgChar1_closure" {
     Text.Printf.$fPrintfArgChar1_closure:
         const Text.Printf.$fPrintfArgChar1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar1_entry() //  [R1]
         { info_tbl: [(cceHs,
                       label: Text.Printf.$fPrintfArgChar1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceHs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceHt; else goto cceHu;
       cceHt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceHu: // global
           (_cceHp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceHp::I64 == 0) goto cceHr; else goto cceHq;
       cceHr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceHq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceHp::I64;
           R2 = lvl18_rccch_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.441850709 UTC

[section ""data" . Text.Printf.$fPrintfArgChar_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgChar_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgChar_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgChar_$cparseFormat_entry() //  [R3]
         { info_tbl: [(cceHz,
                       label: Text.Printf.$fPrintfArgChar_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceHz: // global
           R2 = R3;
           call Text.Printf.$wparseIntFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.442605892 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble5_closure" {
     Text.Printf.$fPrintfArgDouble5_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.444630422 UTC

[section ""data" . integral_prec_rc8qj_closure" {
     integral_prec_rc8qj_closure:
         const integral_prec_rc8qj_info;
 },
 sat_sccjf_entry() //  [R1]
         { info_tbl: [(cceIl,
                       label: sat_sccjf_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceIl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceIm; else goto cceIn;
       cceIm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceIn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sccjb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_sccjb_entry() //  [R1, R2]
         { info_tbl: [(cceIr,
                       label: $wxs_sccjb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceIr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cceIv; else goto cceIu;
       cceIv: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cceIu: // global
           if (R2 == 1) goto cceIq; else goto cceIp;
       cceIq: // global
           _sccja::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _sccja::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cceIp: // global
           I64[Hp - 48] = sat_sccjf_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Text.Printf.$fPrintfArgDouble5_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 integral_prec_rc8qj_entry() //  [R2, R3]
         { info_tbl: [(cceIB,
                       label: integral_prec_rc8qj_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceIB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cceIC; else goto cceID;
       cceIC: // global
           R3 = R3;
           R2 = R2;
           R1 = integral_prec_rc8qj_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cceID: // global
           I64[Sp - 16] = block_cceHG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceJE; else goto cceHH;
       uceJE: // global
           call _cceHG(R1) args: 0, res: 0, upd: 0;
       cceHH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceHG() //  [R1]
         { info_tbl: [(cceHG,
                       label: block_cceHG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceHG: // global
           if (R1 & 7 == 1) goto cceIy; else goto cceIz;
       cceIy: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cceIz: // global
           I64[Sp] = block_cceHM_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uceJB; else goto cceHN;
       uceJB: // global
           call _cceHM(R1) args: 0, res: 0, upd: 0;
       cceHN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceHM() //  [R1]
         { info_tbl: [(cceHM,
                       label: block_cceHM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceHM: // global
           _sccj4::I64 = I64[R1 + 7];
           if (_sccj4::I64 == 0) goto cceIV; else goto uceJx;
       cceIV: // global
           I64[Sp - 8] = block_cceIU_info;
           R1 = P64[Sp + 8];
           I64[Sp] = _sccj4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uceJC; else goto cceIW;
       uceJC: // global
           call _cceIU(R1) args: 0, res: 0, upd: 0;
       cceIW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uceJx: // global
           I64[Sp] = _sccj4::I64;
           call _sccj5() args: 0, res: 0, upd: 0;
     }
 },
 _cceIU() //  [R1]
         { info_tbl: [(cceIU,
                       label: block_cceIU_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceIU: // global
           if (R1 & 7 == 1) goto uceJy; else goto cceJ7;
       uceJy: // global
           Sp = Sp + 8;
           call _sccj5() args: 0, res: 0, upd: 0;
       cceJ7: // global
           I64[Sp - 8] = block_cceJ5_info;
           _sccjj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccjj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uceJF; else goto cceJ8;
       uceJF: // global
           call _cceJ5(R1) args: 0, res: 0, upd: 0;
       cceJ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceJ5() //  [R1]
         { info_tbl: [(cceJ5,
                       label: block_cceJ5_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceJ5: // global
           if (I64[R1 + 7] == 48) goto cceJj; else goto uceJz;
       cceJj: // global
           _sccjj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cceJi_info;
           R1 = _sccjj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uceJH; else goto cceJk;
       uceJH: // global
           call _cceJi(R1) args: 0, res: 0, upd: 0;
       cceJk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uceJz: // global
           Sp = Sp + 16;
           call _sccj5() args: 0, res: 0, upd: 0;
     }
 },
 _cceJi() //  [R1]
         { info_tbl: [(cceJi,
                       label: block_cceJi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceJi: // global
           if (R1 & 7 == 1) goto cceJq; else goto uceJA;
       cceJq: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uceJA: // global
           Sp = Sp + 8;
           call _sccj5() args: 0, res: 0, upd: 0;
     }
 },
 _sccj5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccj5: // global
           I64[Sp - 8] = block_cceHW_info;
           R3 = 0;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceHW() //  [R1]
         { info_tbl: [(cceHW,
                       label: block_cceHW_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceHW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cceIL; else goto cceIK;
       cceIL: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cceIK: // global
           _sccj0::P64 = P64[Sp + 16];
           _sccj8::I64 = I64[Sp + 8] - R1;
           if (%MO_S_Ge_W64(0, _sccj8::I64)) goto cceIN; else goto cceIO;
       cceIN: // global
           Hp = Hp - 40;
           R1 = _sccj0::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cceIO: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Text.Printf.$fPrintfArgDouble5_closure+1;
           P64[Hp - 16] = _sccj0::P64;
           I64[Hp - 8] = $wxs_sccjb_info;
           P64[Hp] = Hp - 30;
           R2 = _sccj8::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call $wxs_sccjb_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.447756591 UTC

[section ""cstring" . lvl19_rccci_bytes" {
     lvl19_rccci_bytes:
         I8[] [84,101,120,116,47,80,114,105,110,116,102,46,104,115,58,55,49,52,58,55,45,51,57,124,40,34,34,44,32,115,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.448502566 UTC

[section ""data" . lvl20_rcccj_closure" {
     lvl20_rcccj_closure:
         const lvl20_rcccj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_rcccj_entry() //  [R1]
         { info_tbl: [(cceJQ,
                       label: lvl20_rcccj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceJQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceJR; else goto cceJS;
       cceJR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceJS: // global
           (_cceJN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceJN::I64 == 0) goto cceJP; else goto cceJO;
       cceJP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceJO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceJN::I64;
           R2 = lvl19_rccci_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.449596401 UTC

[section ""data" . Text.Printf.formatChar2_closure" {
     Text.Printf.formatChar2_closure:
         const Text.Printf.formatChar2_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.formatChar2_entry() //  [R1]
         { info_tbl: [(cceJZ,
                       label: Text.Printf.formatChar2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceJZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceK0; else goto cceK1;
       cceK0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceK1: // global
           (_cceJW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceJW::I64 == 0) goto cceJY; else goto cceJX;
       cceJY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceJX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceJW::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.451728119 UTC

[section ""data" . sat_sccjq_closure" {
     sat_sccjq_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.452324178 UTC

[section ""data" . sat_sccjr_closure" {
     sat_sccjr_closure:
         const :_con_info;
         const sat_sccjq_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.45306717 UTC

[section ""data" . lvl21_rccck_closure" {
     lvl21_rccck_closure:
         const lvl21_rccck_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_rccck_entry() //  [R1]
         { info_tbl: [(cceK8,
                       label: lvl21_rccck_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceK8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceK9; else goto cceKa;
       cceK9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceKa: // global
           (_cceK5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceK5::I64 == 0) goto cceK7; else goto cceK6;
       cceK7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceK6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceK5::I64;
           R3 = sat_sccjr_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.457199164 UTC

[section ""data" . $wfmtu_rcccl_closure" {
     $wfmtu_rcccl_closure:
         const $wfmtu_rcccl_info;
         const 0;
 },
 sat_sccjG_entry() //  [R1]
         { info_tbl: [(cceKI,
                       label: sat_sccjG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceKI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cceKJ; else goto cceKK;
       cceKJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceKK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 24];
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = P64[R1 + 16];
           R3 = GHC.Show.$fShowInteger_closure;
           R2 = GHC.Real.$fIntegralInteger_closure;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 32, res: 0, upd: 24;
     }
 },
 sat_sccjL_entry() //  [R1]
         { info_tbl: [(cceL1,
                       label: sat_sccjL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceL1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceL2; else goto cceL3;
       cceL2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceL3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 fmtu'_sccjy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cceLb,
                       label: fmtu'_sccjy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceLb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceLc; else goto uceMg;
       cceLc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uceMg: // global
           P64[Sp - 32] = R1;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call _cceKm() args: 0, res: 0, upd: 0;
     }
 },
 _cceKm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceKm: // global
           _sccjs::P64 = P64[P64[Sp] + 5];
           I64[Sp - 8] = block_cceL4_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sccjs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uceMn; else goto cceL5;
       uceMn: // global
           call _cceL4(R1) args: 0, res: 0, upd: 0;
       cceL5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceL4() //  [R1]
         { info_tbl: [(cceL4,
                       label: block_cceL4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceL4: // global
           if (R1 & 7 == 1) goto uceMh; else goto cceL9;
       uceMh: // global
           Sp = Sp + 8;
           call _sccjC() args: 0, res: 0, upd: 0;
       cceL9: // global
           I64[Sp - 8] = block_cceLN_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = P64[Sp + 32];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceLN() //  [R1]
         { info_tbl: [(cceLN,
                       label: block_cceLN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceLN: // global
           if (R1 == 1) goto cceM7; else goto uceMi;
       cceM7: // global
           _sccjN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cceLX_info;
           R3 = _sccjN::P64;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       uceMi: // global
           Sp = Sp + 16;
           call _sccjC() args: 0, res: 0, upd: 0;
     }
 },
 _cceLX() //  [R1]
         { info_tbl: [(cceLX,
                       label: block_cceLX_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceLX: // global
           I64[Sp] = block_cceM1_info;
           R2 = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceM1() //  [R1]
         { info_tbl: [(cceM1,
                       label: block_cceM1_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceM1: // global
           I64[Sp] = block_cceM5_info;
           R3 = P64[Sp + 32];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceM5() //  [R1]
         { info_tbl: [(cceM5,
                       label: block_cceM5_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceM5: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = GHC.Base.Nothing_closure+1;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _cceKm() args: 0, res: 0, upd: 0;
     }
 },
 _sccjC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccjC: // global
           I64[Sp - 8] = block_cceKu_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uceMv; else goto cceKv;
       uceMv: // global
           call _cceKu(R1) args: 0, res: 0, upd: 0;
       cceKv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceKu() //  [R1]
         { info_tbl: [(cceKu,
                       label: block_cceKu_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceKu: // global
           _sccjB::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cceLh; else goto cceLs;
       cceLh: // global
           I64[Sp + 16] = block_cceKz_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sccjB::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cceLs: // global
           I64[Sp] = block_cceKN_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sccjB::P64;
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceKz() //  [R1]
         { info_tbl: [(cceKz,
                       label: block_cceKz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceKz: // global
           if (R1 == 1) goto cceLn; else goto uceMm;
       cceLn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cceLq; else goto cceLp;
       cceLq: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cceLp: // global
           I64[Hp - 40] = sat_sccjG_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uceMm: // global
           Sp = Sp + 24;
           call _cceLC() args: 0, res: 0, upd: 0;
     }
 },
 _cceKN() //  [R1]
         { info_tbl: [(cceKN,
                       label: block_cceKN_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceKN: // global
           if (R1 == 1) goto cceLy; else goto uceMk;
       cceLy: // global
           I64[Sp + 16] = block_cceKS_info;
           R4 = P64[Sp + 32];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call fmtu'_sccjy_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       uceMk: // global
           Sp = Sp + 40;
           call _cceLC() args: 0, res: 0, upd: 0;
     }
 },
 _cceKS() //  [R1]
         { info_tbl: [(cceKS,
                       label: block_cceKS_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceKS: // global
           if (R1 & 7 == 1) goto uceMl; else goto cceLE;
       uceMl: // global
           Sp = Sp + 24;
           call _cceLC() args: 0, res: 0, upd: 0;
       cceLE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cceLH; else goto cceLG;
       cceLH: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceLG: // global
           _sccjK::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sccjL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sccjK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cceLC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceLC: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 s_sccjW_entry() //  [R1]
         { info_tbl: [(cceML,
                       label: s_sccjW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceML: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cceMM; else goto cceMN;
       cceMM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceMN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cceMC_info;
           R6 = P64[R1 + 40];
           R5 = P64[R1 + 32];
           R4 = P64[R1 + 24];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceMC() //  [R1, R2]
         { info_tbl: [(cceMC,
                       label: block_cceMC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceMC: // global
           I64[Sp - 8] = block_cceME_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uceMV; else goto cceMF;
       uceMV: // global
           call _cceME(R1) args: 0, res: 0, upd: 0;
       cceMF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cceME() //  [R1]
         { info_tbl: [(cceME,
                       label: block_cceME_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceME: // global
           if (R1 & 7 == 1) goto cceMI; else goto cceMJ;
       cceMI: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cceMJ: // global
           R1 = lvl20_rcccj_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wfmtu_rcccl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cceN0,
                       label: $wfmtu_rcccl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceN0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cceN1; else goto cceN2;
       cceN1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wfmtu_rcccl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cceN2: // global
           I64[Sp - 40] = block_cceKf_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uceOn; else goto cceKg;
       uceOn: // global
           call _cceKf(R1) args: 0, res: 0, upd: 0;
       cceKg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceKf() //  [R1]
         { info_tbl: [(cceKf,
                       label: block_cceKf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceKf: // global
           _sccjs::P64 = P64[Sp + 8];
           _sccju::P64 = P64[Sp + 16];
           _sccjv::P64 = P64[Sp + 24];
           _sccjw::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cceMX; else goto cceMY;
       cceMX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cceN6; else goto cceN5;
       cceN6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceN5: // global
           I64[Hp - 8] = fmtu'_sccjy_info;
           P64[Hp] = _sccjs::P64;
           I64[Sp + 32] = block_cceN3_info;
           R4 = _sccjw::P64;
           R3 = _sccjv::P64;
           R2 = _sccju::P64;
           R1 = Hp - 5;
           Sp = Sp + 32;
           call fmtu'_sccjy_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cceMY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cceNk; else goto cceNj;
       cceNk: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceNj: // global
           _sccjV::P64 = P64[R1 + 6];
           I64[Hp - 40] = s_sccjW_info;
           P64[Hp - 24] = _sccjs::P64;
           P64[Hp - 16] = _sccju::P64;
           P64[Hp - 8] = _sccjv::P64;
           P64[Hp] = _sccjw::P64;
           I64[Sp + 24] = block_cceNh_info;
           R1 = _sccjV::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto uceOm; else goto cceNl;
       uceOm: // global
           call _cceNh(R1) args: 0, res: 0, upd: 0;
       cceNl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceN3() //  [R1]
         { info_tbl: [(cceN3,
                       label: block_cceN3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceN3: // global
           if (R1 & 7 == 1) goto cceNc; else goto cceNg;
       cceNc: // global
           R1 = Text.Printf.errorBadArgument_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cceNg: // global
           R2 = P64[R1 + 6];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cceNh() //  [R1]
         { info_tbl: [(cceNh,
                       label: block_cceNh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceNh: // global
           if (R1 & 7 == 1) goto cceNr; else goto cceNw;
       cceNr: // global
           R2 = P64[Sp + 8];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cceNw: // global
           I64[Sp - 16] = block_cceNu_info;
           _scck4::P64 = R1;
           _scck6::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scck6::P64;
           P64[Sp] = _scck4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceOo; else goto cceNx;
       uceOo: // global
           call _cceNu(R1) args: 0, res: 0, upd: 0;
       cceNx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceNu() //  [R1]
         { info_tbl: [(cceNu,
                       label: block_cceNu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceNu: // global
           if (I64[R1 + 7] == 48) goto cceNI; else goto uceOk;
       cceNI: // global
           _scck6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cceNH_info;
           R1 = _scck6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uceOp; else goto cceNJ;
       uceOp: // global
           call _cceNH(R1) args: 0, res: 0, upd: 0;
       cceNJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uceOk: // global
           Sp = Sp + 16;
           call _cceOf() args: 0, res: 0, upd: 0;
     }
 },
 _cceNH() //  [R1]
         { info_tbl: [(cceNH,
                       label: block_cceNH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceNH: // global
           if (R1 & 7 == 1) goto cceNQ; else goto uceOl;
       cceNQ: // global
           I64[Sp] = block_cceNN_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto uceOr; else goto cceNR;
       uceOr: // global
           call _cceNN(R1) args: 0, res: 0, upd: 0;
       cceNR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uceOl: // global
           Sp = Sp + 8;
           call _cceOf() args: 0, res: 0, upd: 0;
     }
 },
 _cceNN() //  [R1]
         { info_tbl: [(cceNN,
                       label: block_cceNN_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceNN: // global
           if (R1 & 7 == 1) goto cceNX; else goto cceO2;
       cceNX: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cceO2: // global
           I64[Sp] = block_cceO0_info;
           _scckb::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _scckb::P64;
           if (R1 & 7 != 0) goto uceOt; else goto cceO3;
       uceOt: // global
           call _cceO0(R1) args: 0, res: 0, upd: 0;
       cceO3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceO0() //  [R1]
         { info_tbl: [(cceO0,
                       label: block_cceO0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceO0: // global
           _scckb::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 48) goto cceOb; else goto cceOa;
       cceOb: // global
           R2 = _scckb::P64;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cceOa: // global
           R2 = _scckb::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cceOf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceOf: // global
           R2 = P64[Sp + 8];
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.465561697 UTC

[section ""data" . $wfmti_rcccm_closure" {
     $wfmti_rcccm_closure:
         const $wfmti_rcccm_info;
         const 0;
 },
 sat_scckq_entry() //  [R1]
         { info_tbl: [(cceOJ,
                       label: sat_scckq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceOJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cceOK; else goto cceOL;
       cceOK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceOL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cceOG_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceOG() //  [R1, R2]
         { info_tbl: [(cceOG,
                       label: block_cceOG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceOG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cceOO; else goto cceON;
       cceOO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cceON: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 14;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scckw_entry() //  [R1]
         { info_tbl: [(cceOX,
                       label: sat_scckw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceOX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cceP3; else goto cceP4;
       cceP3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceP4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cceOV_info;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceOV() //  [R1]
         { info_tbl: [(cceOV,
                       label: block_cceOV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceOV: // global
           I64[Sp] = block_cceP0_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceP0() //  [R1, R2]
         { info_tbl: [(cceP0,
                       label: block_cceP0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceP0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cceP8; else goto cceP7;
       cceP8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cceP7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 14;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucePl_srtd" {
     ucePl_srtd:
         const SccKB_srt+104;
         const 33;
         const 6509559809;
 },
 $wfmti_rcccm_entry() //  [R2, R3]
         { info_tbl: [(ccePc,
                       label: $wfmti_rcccm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccePc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccePd; else goto ccePe;
       ccePd: // global
           R3 = R3;
           R2 = R2;
           R1 = $wfmti_rcccm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccePe: // global
           I64[Sp - 24] = block_cceOy_info;
           _scckk::P64 = R3;
           R3 = Text.Printf.formatChar2_closure;
           _scckj::P64 = R2;
           R2 = _scckk::P64;
           P64[Sp - 16] = _scckj::P64;
           P64[Sp - 8] = _scckk::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cceOy() //  [R1]
         { info_tbl: [(cceOy,
                       label: block_cceOy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceOy: // global
           _scckj::P64 = P64[Sp + 8];
           _scckk::P64 = P64[Sp + 16];
           if (R1 == 1) goto ccePb; else goto ccePa;
       ccePb: // global
           Hp = Hp + 32;
           _scckl::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccePk; else goto ccePj;
       ccePj: // global
           I64[Hp - 24] = sat_scckw_info;
           P64[Hp - 8] = _scckj::P64;
           P64[Hp] = _scckk::P64;
           R2 = Hp - 24;
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccePa: // global
           Hp = Hp + 32;
           _scckl::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccePk; else goto ccePg;
       ccePk: // global
           HpAlloc = 32;
           R1 = _scckl::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccePg: // global
           I64[Hp - 24] = sat_scckq_info;
           P64[Hp - 8] = _scckj::P64;
           P64[Hp] = _scckk::P64;
           R2 = Hp - 24;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.468086238 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble6_closure" {
     Text.Printf.$fPrintfArgDouble6_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.471740137 UTC

[section ""data" . Text.Printf.$wadjust_closure" {
     Text.Printf.$wadjust_closure:
         const Text.Printf.$wadjust_info;
 },
 x1_scckM_entry() //  [R1]
         { info_tbl: [(cceQc,
                       label: x1_scckM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceQc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cceQd; else goto cceQe;
       cceQd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceQe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cceQ5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uceQC; else goto cceQ6;
       uceQC: // global
           call _cceQ5(R1) args: 0, res: 0, upd: 0;
       cceQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cceQ5() //  [R1]
         { info_tbl: [(cceQ5,
                       label: block_cceQ5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceQ5: // global
           if (R1 & 7 == 1) goto uceQy; else goto cceQa;
       uceQy: // global
           Sp = Sp + 8;
           call _cceQs() args: 0, res: 0, upd: 0;
       cceQa: // global
           I64[Sp] = block_cceQk_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uceQA; else goto cceQm;
       uceQA: // global
           call _cceQk(R1) args: 0, res: 0, upd: 0;
       cceQm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cceQk() //  [R1]
         { info_tbl: [(cceQk,
                       label: block_cceQk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceQk: // global
           if (R1 & 7 == 1) goto uceQz; else goto cceQw;
       uceQz: // global
           Sp = Sp + 8;
           call _cceQs() args: 0, res: 0, upd: 0;
       cceQw: // global
           R1 = Text.Printf.$fPrintfArgDouble5_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cceQs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceQs: // global
           R1 = Text.Printf.$fPrintfArgDouble6_closure+1;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scckV_entry() //  [R1]
         { info_tbl: [(cceQS,
                       label: sat_scckV_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceQS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceQT; else goto cceQU;
       cceQT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceQU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_scckR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_scckR_entry() //  [R1, R2]
         { info_tbl: [(cceQY,
                       label: $wxs_scckR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceQY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cceR2; else goto cceR1;
       cceR2: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cceR1: // global
           if (R2 == 1) goto cceQX; else goto cceQW;
       cceQX: // global
           _scckQ::P64 = P64[R1 + 15];
           Hp = Hp - 56;
           R1 = _scckQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cceQW: // global
           _scckM::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scckV_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _scckM::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 fill_scckB_entry() //  [R1]
         { info_tbl: [(cceR8,
                       label: fill_scckB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceR8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cceR9; else goto cceRa;
       cceR9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceRa: // global
           I64[Sp - 32] = block_ccePu_info;
           _sccky::P64 = P64[R1 + 24];
           _scckz::P64 = P64[R1 + 32];
           _scckA::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccky::P64;
           P64[Sp - 16] = _scckz::P64;
           P64[Sp - 8] = _scckA::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uceRq; else goto ccePv;
       uceRq: // global
           call _ccePu(R1) args: 0, res: 0, upd: 0;
       ccePv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccePu() //  [R1]
         { info_tbl: [(ccePu,
                       label: block_ccePu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccePu: // global
           if (R1 & 7 == 1) goto cceR5; else goto cceR6;
       cceR5: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cceR6: // global
           I64[Sp] = block_ccePA_info;
           R3 = 0;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccePA() //  [R1]
         { info_tbl: [(ccePA,
                       label: block_ccePA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccePA: // global
           I64[Sp] = block_ccePE_info;
           R3 = 0;
           R2 = P64[Sp + 24];
           I64[Sp + 24] = R1;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccePE() //  [R1]
         { info_tbl: [(ccePE,
                       label: block_ccePE_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccePE: // global
           I64[Sp] = block_ccePI_info;
           _scckF::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _scckF::I64;
           if (R1 & 7 != 0) goto uceRp; else goto ccePJ;
       uceRp: // global
           call _ccePI(R1) args: 0, res: 0, upd: 0;
       ccePJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccePI() //  [R1]
         { info_tbl: [(ccePI,
                       label: block_ccePI_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccePI: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cceRi; else goto cceRh;
       cceRi: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceRh: // global
           _scckH::I64 = I64[R1 + 7];
           _scckI::I64 = I64[Sp + 24] + I64[Sp + 16];
           if (%MO_S_Ge_W64(_scckI::I64,
                            _scckH::I64)) goto cceRm; else goto cceRo;
       cceRo: // global
           _scckK::I64 = _scckH::I64 - _scckI::I64;
           if (%MO_S_Ge_W64(0, _scckK::I64)) goto cceRm; else goto cceRn;
       cceRm: // global
           Hp = Hp - 72;
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cceRn: // global
           I64[Hp - 64] = x1_scckM_info;
           P64[Hp - 48] = P64[Sp + 8];
           I64[Hp - 40] = :_con_info;
           _cceQ1::P64 = Hp - 64;
           P64[Hp - 32] = _cceQ1::P64;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = $wxs_scckR_info;
           P64[Hp - 8] = _cceQ1::P64;
           P64[Hp] = Hp - 38;
           R2 = _scckK::I64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call $wxs_scckR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scckY_entry() //  [R1]
         { info_tbl: [(cceRF,
                       label: sat_scckY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceRF: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccl1_entry() //  [R1]
         { info_tbl: [(cceRT,
                       label: sat_sccl1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceRT: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccl2_entry() //  [R1]
         { info_tbl: [(cceS2,
                       label: sat_sccl2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceS2: // global
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccl6_entry() //  [R1]
         { info_tbl: [(cceSk,
                       label: sat_sccl6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceSk: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wadjust_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cceSr,
                       label: Text.Printf.$wadjust_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceSr: // global
           _scckA::P64 = R5;
           _scckz::P64 = R4;
           _sccky::P64 = R3;
           _scckx::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cceSs; else goto cceSt;
       cceSt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cceSv; else goto cceSu;
       cceSv: // global
           HpAlloc = 48;
           goto cceSs;
       cceSs: // global
           R5 = _scckA::P64;
           R4 = _scckz::P64;
           R3 = _sccky::P64;
           R2 = _scckx::P64;
           R1 = Text.Printf.$wadjust_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cceSu: // global
           I64[Hp - 40] = fill_scckB_info;
           P64[Hp - 24] = _scckx::P64;
           P64[Hp - 16] = _sccky::P64;
           P64[Hp - 8] = _scckz::P64;
           P64[Hp] = _scckA::P64;
           I64[Sp - 40] = block_cceS5_info;
           R1 = _sccky::P64;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = _sccky::P64;
           P64[Sp - 16] = _scckz::P64;
           P64[Sp - 8] = _scckA::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uceT8; else goto cceS6;
       uceT8: // global
           call _cceS5(R1) args: 0, res: 0, upd: 0;
       cceS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceS5() //  [R1]
         { info_tbl: [(cceS5,
                       label: block_cceS5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceS5: // global
           if (R1 & 7 == 1) goto uceT2; else goto cceSp;
       uceT2: // global
           Sp = Sp + 8;
           call _scckW() args: 0, res: 0, upd: 0;
       cceSp: // global
           I64[Sp] = block_cceSb_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uceT5; else goto cceSc;
       uceT5: // global
           call _cceSb(R1) args: 0, res: 0, upd: 0;
       cceSc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceSb() //  [R1]
         { info_tbl: [(cceSb,
                       label: block_cceSb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceSb: // global
           if (R1 & 7 == 1) goto cceSR; else goto uceT3;
       cceSR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cceSU; else goto cceST;
       cceSU: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceST: // global
           I64[Hp - 24] = sat_sccl6_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       uceT3: // global
           Sp = Sp + 8;
           call _scckW() args: 0, res: 0, upd: 0;
     }
 },
 _scckW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scckW: // global
           I64[Sp - 8] = block_cceRw_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uceT9; else goto cceRx;
       uceT9: // global
           call _cceRw(R1) args: 0, res: 0, upd: 0;
       cceRx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceRw() //  [R1]
         { info_tbl: [(cceRw,
                       label: block_cceRw_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceRw: // global
           if (R1 & 7 == 1) goto cceSy; else goto cceSD;
       cceSy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cceSB; else goto cceSA;
       cceSB: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceSA: // global
           I64[Hp - 24] = sat_scckY_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cceSD: // global
           I64[Sp] = block_cceRK_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uceT4; else goto cceRL;
       uceT4: // global
           call _cceRK(R1) args: 0, res: 0, upd: 0;
       cceRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceRK() //  [R1]
         { info_tbl: [(cceRK,
                       label: block_cceRK_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceRK: // global
           _ccePq::P64 = P64[Sp + 8];
           _scckz::P64 = P64[Sp + 24];
           _scckA::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cceSF; else goto cceSJ;
       cceSF: // global
           Hp = Hp + 32;
           _sccl0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cceSM; else goto cceSH;
       cceSH: // global
           I64[Hp - 24] = sat_sccl1_info;
           P64[Hp - 8] = _scckz::P64;
           P64[Hp] = _scckA::P64;
           R3 = Hp - 24;
           R2 = _ccePq::P64;
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cceSJ: // global
           Hp = Hp + 32;
           _sccl0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cceSM; else goto cceSL;
       cceSM: // global
           HpAlloc = 32;
           R1 = _sccl0::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceSL: // global
           I64[Hp - 24] = sat_sccl2_info;
           P64[Hp - 8] = _scckA::P64;
           P64[Hp] = _ccePq::P64;
           R3 = Hp - 24;
           R2 = _scckz::P64;
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.47763977 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble4_bytes" {
     Text.Printf.$fPrintfArgDouble4_bytes:
         I8[] [43]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.4784471 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble3_closure" {
     Text.Printf.$fPrintfArgDouble3_closure:
         const Text.Printf.$fPrintfArgDouble3_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble3_entry() //  [R1]
         { info_tbl: [(cceTg,
                       label: Text.Printf.$fPrintfArgDouble3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceTg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceTh; else goto cceTi;
       cceTh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceTi: // global
           (_cceTd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceTd::I64 == 0) goto cceTf; else goto cceTe;
       cceTf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceTe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceTd::I64;
           R2 = Text.Printf.$fPrintfArgDouble4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.479303524 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble2_bytes" {
     Text.Printf.$fPrintfArgDouble2_bytes:
         I8[] [32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.480018044 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble1_closure" {
     Text.Printf.$fPrintfArgDouble1_closure:
         const Text.Printf.$fPrintfArgDouble1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble1_entry() //  [R1]
         { info_tbl: [(cceTp,
                       label: Text.Printf.$fPrintfArgDouble1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceTp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cceTq; else goto cceTr;
       cceTq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceTr: // global
           (_cceTm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cceTm::I64 == 0) goto cceTo; else goto cceTn;
       cceTo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cceTn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cceTm::I64;
           R2 = Text.Printf.$fPrintfArgDouble2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.481614218 UTC

[section ""data" . Text.Printf.$wadjustSigned_closure" {
     Text.Printf.$wadjustSigned_closure:
         const Text.Printf.$wadjustSigned_info;
         const 0;
 },
 Text.Printf.$wadjustSigned_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cceTD,
                       label: Text.Printf.$wadjustSigned_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceTD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cceTE; else goto cceTF;
       cceTE: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$wadjustSigned_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cceTF: // global
           I64[Sp - 40] = block_cceTw_info;
           R1 = R4;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uceUq; else goto cceTx;
       uceUq: // global
           call _cceTw(R1) args: 0, res: 0, upd: 0;
       cceTx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceTw() //  [R1]
         { info_tbl: [(cceTw,
                       label: block_cceTw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceTw: // global
           if (R1 & 7 == 1) goto cceTA; else goto cceTB;
       cceTA: // global
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       cceTB: // global
           I64[Sp] = block_cceTL_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uceUp; else goto cceTN;
       uceUp: // global
           call _cceTL(R1) args: 0, res: 0, upd: 0;
       cceTN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceTL() //  [R1]
         { info_tbl: [(cceTL,
                       label: block_cceTL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceTL: // global
           _sccla::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cceTU; else goto cceUa;
       cceTU: // global
           I64[Sp] = block_cceTR_info;
           R1 = _sccla::P64;
           if (R1 & 7 != 0) goto uceUr; else goto cceTV;
       uceUr: // global
           call _cceTR(R1) args: 0, res: 0, upd: 0;
       cceTV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cceUa: // global
           I64[Sp] = block_cceU8_info;
           R1 = _sccla::P64;
           if (R1 & 7 != 0) goto uceUs; else goto cceUb;
       uceUs: // global
           call _cceU8(R1) args: 0, res: 0, upd: 0;
       cceUb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceTR() //  [R1]
         { info_tbl: [(cceTR,
                       label: block_cceTR_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceTR: // global
           _sccl7::P64 = P64[Sp + 8];
           _sccl8::P64 = P64[Sp + 16];
           _scclb::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cceU1; else goto cceU5;
       cceU1: // global
           R5 = _scclb::P64;
           R4 = Text.Printf.$fPrintfArgDouble3_closure;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       cceU5: // global
           R5 = _scclb::P64;
           R4 = R1;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 _cceU8() //  [R1]
         { info_tbl: [(cceU8,
                       label: block_cceU8_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceU8: // global
           _sccl7::P64 = P64[Sp + 8];
           _sccl8::P64 = P64[Sp + 16];
           _scclb::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cceUh; else goto cceUl;
       cceUh: // global
           R5 = _scclb::P64;
           R4 = Text.Printf.$fPrintfArgDouble1_closure;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       cceUl: // global
           R5 = _scclb::P64;
           R4 = R1;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.486084016 UTC

[section ""data" . Text.Printf.$w$sformatRealFloat_closure" {
     Text.Printf.$w$sformatRealFloat_closure:
         const Text.Printf.$w$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$w$sformatRealFloat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceUu: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uceWb_srtd" {
     uceWb_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclw_entry() //  [R1]
         { info_tbl: [(cceUH,
                       label: sat_scclw_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceUH: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceUI; else goto cceUJ;
       cceUI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceUJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceUF_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 69;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceUF() //  [R1, R2]
         { info_tbl: [(cceUF,
                       label: block_cceUF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceUF: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uceWc_srtd" {
     uceWc_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclA_entry() //  [R1]
         { info_tbl: [(cceUS,
                       label: sat_scclA_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceUS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceUT; else goto cceUU;
       cceUT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceUU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceUQ_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 70;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceUQ() //  [R1, R2]
         { info_tbl: [(cceUQ,
                       label: block_cceUQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceUQ: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uceWd_srtd" {
     uceWd_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclE_entry() //  [R1]
         { info_tbl: [(cceV3,
                       label: sat_scclE_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceV3: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceV4; else goto cceV5;
       cceV4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceV5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceV1_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 71;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceV1() //  [R1, R2]
         { info_tbl: [(cceV1,
                       label: block_cceV1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceV1: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uceWe_srtd" {
     uceWe_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclI_entry() //  [R1]
         { info_tbl: [(cceVe,
                       label: sat_scclI_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceVe: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceVf; else goto cceVg;
       cceVf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceVg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceVc_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 101;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceVc() //  [R1, R2]
         { info_tbl: [(cceVc,
                       label: block_cceVc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceVc: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uceWf_srtd" {
     uceWf_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclM_entry() //  [R1]
         { info_tbl: [(cceVp,
                       label: sat_scclM_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceVp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceVq; else goto cceVr;
       cceVq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceVr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceVn_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 102;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceVn() //  [R1, R2]
         { info_tbl: [(cceVn,
                       label: block_cceVn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceVn: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uceWg_srtd" {
     uceWg_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclQ_entry() //  [R1]
         { info_tbl: [(cceVA,
                       label: sat_scclQ_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceVA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceVB; else goto cceVC;
       cceVB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceVC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceVy_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceVy() //  [R1, R2]
         { info_tbl: [(cceVy,
                       label: block_cceVy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceVy: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uceWh_srtd" {
     uceWh_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclU_entry() //  [R1]
         { info_tbl: [(cceVL,
                       label: sat_scclU_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceVL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceVM; else goto cceVN;
       cceVM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceVN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceVJ_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceVJ() //  [R1, R2]
         { info_tbl: [(cceVJ,
                       label: block_cceVJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceVJ: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uceWi_srtd" {
     uceWi_srtd:
         const SccKB_srt+32;
         const 46;
         const 39582418600065;
 },
 Text.Printf.$w$sformatRealFloat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cceVY,
                       label: Text.Printf.$w$sformatRealFloat_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceVY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cceW2; else goto cceW1;
       cceW2: // global
           HpAlloc = 64;
           R1 = Text.Printf.$w$sformatRealFloat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cceW1: // global
           _scclq::P64 = P64[Sp];
           _sccls::I64 = I64[Sp + 8];
           if (_sccls::I64 < 101) goto uceW3; else goto uceW7;
       uceW3: // global
           if (_sccls::I64 < 71) goto uceW4; else goto uceW6;
       uceW4: // global
           if (_sccls::I64 < 70) goto uceW5; else goto cceVS;
       uceW5: // global
           if (_sccls::I64 < 69) goto cceVQ; else goto cceVR;
       cceVR: // global
           I64[Hp - 56] = sat_scclw_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cceVS: // global
           I64[Hp - 56] = sat_scclA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uceW6: // global
           if (_sccls::I64 >= 72) goto cceVQ; else goto cceVT;
       cceVT: // global
           I64[Hp - 56] = sat_scclE_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uceW7: // global
           if (_sccls::I64 < 103) goto uceW8; else goto uceW9;
       uceW8: // global
           if (_sccls::I64 < 102) goto cceVU; else goto cceVV;
       cceVU: // global
           I64[Hp - 56] = sat_scclI_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cceVV: // global
           I64[Hp - 56] = sat_scclM_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uceW9: // global
           if (_sccls::I64 < 104) goto cceVW; else goto uceWa;
       cceVW: // global
           I64[Hp - 56] = sat_scclQ_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uceWa: // global
           if (_sccls::I64 != 118) goto cceVQ; else goto cceVX;
       cceVQ: // global
           Hp = Hp - 64;
           R2 = _sccls::I64;
           Sp = Sp + 16;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       cceVX: // global
           I64[Hp - 56] = sat_scclU_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.492379555 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure" {
     Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure:
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble_$sformatRealFloat_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cceWq,
                       label: Text.Printf.$fPrintfArgDouble_$sformatRealFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceWq: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cceWu; else goto cceWv;
       cceWu: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cceWv: // global
           I64[Sp - 16] = block_cceWn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceWD; else goto cceWo;
       uceWD: // global
           call _cceWn(R1) args: 0, res: 0, upd: 0;
       cceWo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceWn() //  [R1]
         { info_tbl: [(cceWn,
                       label: block_cceWn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceWn: // global
           I64[Sp - 40] = block_cceWt_info;
           _scclY::P64 = P64[R1 + 7];
           _scclZ::P64 = P64[R1 + 15];
           _sccm0::P64 = P64[R1 + 23];
           _sccm1::P64 = P64[R1 + 31];
           _sccm2::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _scclZ::P64;
           P64[Sp - 24] = _sccm0::P64;
           P64[Sp - 16] = _sccm1::P64;
           P64[Sp - 8] = _sccm2::P64;
           P64[Sp] = _scclY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uceWC; else goto cceWx;
       uceWC: // global
           call _cceWt(R1) args: 0, res: 0, upd: 0;
       cceWx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceWt() //  [R1]
         { info_tbl: [(cceWt,
                       label: block_cceWt_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceWt: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 32];
           I64[Sp + 48] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.496067753 UTC

[section ""data" . Text.Printf.$w$sformatRealFloat1_closure" {
     Text.Printf.$w$sformatRealFloat1_closure:
         const Text.Printf.$w$sformatRealFloat1_info;
         const 0;
 },
 Text.Printf.$w$sformatRealFloat1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceWF: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sccmi_entry() //  [R1]
         { info_tbl: [(cceWS,
                       label: sat_sccmi_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceWS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceWT; else goto cceWU;
       cceWT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceWU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceWQ_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 69;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceWQ() //  [R1, R2]
         { info_tbl: [(cceWQ,
                       label: block_cceWQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceWQ: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmm_entry() //  [R1]
         { info_tbl: [(cceX3,
                       label: sat_sccmm_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceX3: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceX4; else goto cceX5;
       cceX4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceX5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceX1_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 70;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceX1() //  [R1, R2]
         { info_tbl: [(cceX1,
                       label: block_cceX1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceX1: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmq_entry() //  [R1]
         { info_tbl: [(cceXe,
                       label: sat_sccmq_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceXe: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceXf; else goto cceXg;
       cceXf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceXg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceXc_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 71;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceXc() //  [R1, R2]
         { info_tbl: [(cceXc,
                       label: block_cceXc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceXc: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmu_entry() //  [R1]
         { info_tbl: [(cceXp,
                       label: sat_sccmu_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceXp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceXq; else goto cceXr;
       cceXq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceXr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceXn_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 101;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceXn() //  [R1, R2]
         { info_tbl: [(cceXn,
                       label: block_cceXn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceXn: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmy_entry() //  [R1]
         { info_tbl: [(cceXA,
                       label: sat_sccmy_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceXA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceXB; else goto cceXC;
       cceXB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceXC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceXy_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 102;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceXy() //  [R1, R2]
         { info_tbl: [(cceXy,
                       label: block_cceXy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceXy: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmC_entry() //  [R1]
         { info_tbl: [(cceXL,
                       label: sat_sccmC_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceXL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceXM; else goto cceXN;
       cceXM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceXN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceXJ_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceXJ() //  [R1, R2]
         { info_tbl: [(cceXJ,
                       label: block_cceXJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceXJ: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmG_entry() //  [R1]
         { info_tbl: [(cceXW,
                       label: sat_sccmG_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceXW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceXX; else goto cceXY;
       cceXX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceXY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceXU_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceXU() //  [R1, R2]
         { info_tbl: [(cceXU,
                       label: block_cceXU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceXU: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uceYm_srtd" {
     uceYm_srtd:
         const SccKB_srt+32;
         const 48;
         const 145135534868481;
 },
 Text.Printf.$w$sformatRealFloat1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cceY9,
                       label: Text.Printf.$w$sformatRealFloat1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceY9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cceYd; else goto cceYc;
       cceYd: // global
           HpAlloc = 64;
           R1 = Text.Printf.$w$sformatRealFloat1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cceYc: // global
           _sccmc::P64 = P64[Sp];
           _sccme::I64 = I64[Sp + 8];
           if (_sccme::I64 < 101) goto uceYe; else goto uceYi;
       uceYe: // global
           if (_sccme::I64 < 71) goto uceYf; else goto uceYh;
       uceYf: // global
           if (_sccme::I64 < 70) goto uceYg; else goto cceY3;
       uceYg: // global
           if (_sccme::I64 < 69) goto cceY1; else goto cceY2;
       cceY2: // global
           I64[Hp - 56] = sat_sccmi_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cceY3: // global
           I64[Hp - 56] = sat_sccmm_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uceYh: // global
           if (_sccme::I64 >= 72) goto cceY1; else goto cceY4;
       cceY4: // global
           I64[Hp - 56] = sat_sccmq_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uceYi: // global
           if (_sccme::I64 < 103) goto uceYj; else goto uceYk;
       uceYj: // global
           if (_sccme::I64 < 102) goto cceY5; else goto cceY6;
       cceY5: // global
           I64[Hp - 56] = sat_sccmu_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cceY6: // global
           I64[Hp - 56] = sat_sccmy_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uceYk: // global
           if (_sccme::I64 < 104) goto cceY7; else goto uceYl;
       cceY7: // global
           I64[Hp - 56] = sat_sccmC_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uceYl: // global
           if (_sccme::I64 != 118) goto cceY1; else goto cceY8;
       cceY1: // global
           Hp = Hp - 64;
           R2 = _sccme::I64;
           Sp = Sp + 16;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       cceY8: // global
           I64[Hp - 56] = sat_sccmG_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.50220209 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure" {
     Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure:
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat_$sformatRealFloat_entry() //  [R2, R3]
         { info_tbl: [(cceYu,
                       label: Text.Printf.$fPrintfArgFloat_$sformatRealFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceYu: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cceYy; else goto cceYz;
       cceYy: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cceYz: // global
           I64[Sp - 16] = block_cceYr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uceYH; else goto cceYs;
       uceYH: // global
           call _cceYr(R1) args: 0, res: 0, upd: 0;
       cceYs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceYr() //  [R1]
         { info_tbl: [(cceYr,
                       label: block_cceYr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceYr: // global
           I64[Sp - 40] = block_cceYx_info;
           _sccmK::P64 = P64[R1 + 7];
           _sccmL::P64 = P64[R1 + 15];
           _sccmM::P64 = P64[R1 + 23];
           _sccmN::P64 = P64[R1 + 31];
           _sccmO::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _sccmL::P64;
           P64[Sp - 24] = _sccmM::P64;
           P64[Sp - 16] = _sccmN::P64;
           P64[Sp - 8] = _sccmO::P64;
           P64[Sp] = _sccmK::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uceYG; else goto cceYB;
       uceYG: // global
           call _cceYx(R1) args: 0, res: 0, upd: 0;
       cceYB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cceYx() //  [R1]
         { info_tbl: [(cceYx,
                       label: block_cceYx_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceYx: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 32];
           I64[Sp + 48] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.505988279 UTC

[section ""data" . Text.Printf.$wformatRealFloat_closure" {
     Text.Printf.$wformatRealFloat_closure:
         const Text.Printf.$wformatRealFloat_info;
         const 0;
 },
 Text.Printf.$wformatRealFloat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceYJ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatRealFloat_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccn5_entry() //  [R1]
         { info_tbl: [(cceYW,
                       label: sat_sccn5_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceYW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceYX; else goto cceYY;
       cceYX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceYY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceYU_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 69;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceYU() //  [R1, R2]
         { info_tbl: [(cceYU,
                       label: block_cceYU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceYU: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccn9_entry() //  [R1]
         { info_tbl: [(cceZ7,
                       label: sat_sccn9_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZ7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceZ8; else goto cceZ9;
       cceZ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceZ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceZ5_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 70;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceZ5() //  [R1, R2]
         { info_tbl: [(cceZ5,
                       label: block_cceZ5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZ5: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnd_entry() //  [R1]
         { info_tbl: [(cceZi,
                       label: sat_sccnd_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZi: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceZj; else goto cceZk;
       cceZj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceZk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceZg_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 71;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceZg() //  [R1, R2]
         { info_tbl: [(cceZg,
                       label: block_cceZg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZg: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnh_entry() //  [R1]
         { info_tbl: [(cceZt,
                       label: sat_sccnh_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceZu; else goto cceZv;
       cceZu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceZv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceZr_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 101;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceZr() //  [R1, R2]
         { info_tbl: [(cceZr,
                       label: block_cceZr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZr: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnl_entry() //  [R1]
         { info_tbl: [(cceZE,
                       label: sat_sccnl_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZE: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceZF; else goto cceZG;
       cceZF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceZG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceZC_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 102;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceZC() //  [R1, R2]
         { info_tbl: [(cceZC,
                       label: block_cceZC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZC: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnp_entry() //  [R1]
         { info_tbl: [(cceZP,
                       label: sat_sccnp_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZP: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cceZQ; else goto cceZR;
       cceZQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceZR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceZN_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 103;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceZN() //  [R1, R2]
         { info_tbl: [(cceZN,
                       label: block_cceZN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZN: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnt_entry() //  [R1]
         { info_tbl: [(ccf00,
                       label: sat_sccnt_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf00: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccf01; else goto ccf02;
       ccf01: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf02: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cceZY_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 103;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cceZY() //  [R1, R2]
         { info_tbl: [(cceZY,
                       label: block_cceZY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceZY: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucf0q_srtd" {
     ucf0q_srtd:
         const SccKB_srt+32;
         const 50;
         const 567347999948801;
 },
 Text.Printf.$wformatRealFloat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccf0d,
                       label: Text.Printf.$wformatRealFloat_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf0d: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccf0h; else goto ccf0g;
       ccf0h: // global
           HpAlloc = 72;
           R1 = Text.Printf.$wformatRealFloat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccf0g: // global
           _sccmY::P64 = P64[Sp];
           _sccmZ::P64 = P64[Sp + 8];
           _sccn1::I64 = I64[Sp + 16];
           if (_sccn1::I64 < 101) goto ucf0i; else goto ucf0m;
       ucf0i: // global
           if (_sccn1::I64 < 71) goto ucf0j; else goto ucf0l;
       ucf0j: // global
           if (_sccn1::I64 < 70) goto ucf0k; else goto ccf07;
       ucf0k: // global
           if (_sccn1::I64 < 69) goto ccf05; else goto ccf06;
       ccf06: // global
           I64[Hp - 64] = sat_sccn5_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccf07: // global
           I64[Hp - 64] = sat_sccn9_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucf0l: // global
           if (_sccn1::I64 >= 72) goto ccf05; else goto ccf08;
       ccf08: // global
           I64[Hp - 64] = sat_sccnd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucf0m: // global
           if (_sccn1::I64 < 103) goto ucf0n; else goto ucf0o;
       ucf0n: // global
           if (_sccn1::I64 < 102) goto ccf09; else goto ccf0a;
       ccf09: // global
           I64[Hp - 64] = sat_sccnh_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccf0a: // global
           I64[Hp - 64] = sat_sccnl_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucf0o: // global
           if (_sccn1::I64 < 104) goto ccf0b; else goto ucf0p;
       ccf0b: // global
           I64[Hp - 64] = sat_sccnp_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucf0p: // global
           if (_sccn1::I64 != 118) goto ccf05; else goto ccf0c;
       ccf05: // global
           Hp = Hp - 72;
           R2 = _sccn1::I64;
           Sp = Sp + 24;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       ccf0c: // global
           I64[Hp - 64] = sat_sccnt_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.512495722 UTC

[section ""data" . Text.Printf.formatRealFloat_closure" {
     Text.Printf.formatRealFloat_closure:
         const Text.Printf.formatRealFloat_info;
         const 0;
 },
 Text.Printf.formatRealFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(ccf0y,
                       label: Text.Printf.formatRealFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf0y: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccf0C; else goto ccf0D;
       ccf0C: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatRealFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccf0D: // global
           I64[Sp - 24] = block_ccf0v_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucf0L; else goto ccf0w;
       ucf0L: // global
           call _ccf0v(R1) args: 0, res: 0, upd: 0;
       ccf0w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccf0v() //  [R1]
         { info_tbl: [(ccf0v,
                       label: block_ccf0v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf0v: // global
           I64[Sp - 40] = block_ccf0B_info;
           _sccny::P64 = P64[R1 + 7];
           _sccnz::P64 = P64[R1 + 15];
           _sccnA::P64 = P64[R1 + 23];
           _sccnB::P64 = P64[R1 + 31];
           _sccnC::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _sccnz::P64;
           P64[Sp - 24] = _sccnA::P64;
           P64[Sp - 16] = _sccnB::P64;
           P64[Sp - 8] = _sccnC::P64;
           P64[Sp] = _sccny::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucf0K; else goto ccf0F;
       ucf0K: // global
           call _ccf0B(R1) args: 0, res: 0, upd: 0;
       ccf0F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccf0B() //  [R1]
         { info_tbl: [(ccf0B,
                       label: block_ccf0B_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf0B: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 56];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatRealFloat_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.514346236 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgDouble_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble_$cparseFormat_entry() //  [R2, R3]
         { info_tbl: [(ccf0X,
                       label: Text.Printf.$fPrintfArgDouble_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf0X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccf0Y; else goto ccf0Z;
       ccf0Y: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgDouble_$cparseFormat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccf0Z: // global
           I64[Sp - 8] = block_ccf0Q_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucf19; else goto ccf0R;
       ucf19: // global
           call _ccf0Q(R1) args: 0, res: 0, upd: 0;
       ccf0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccf0Q() //  [R1]
         { info_tbl: [(ccf0Q,
                       label: block_ccf0Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf0Q: // global
           if (R1 & 7 == 1) goto ccf0U; else goto ccf0V;
       ccf0U: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccf0V: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccf18; else goto ccf17;
       ccf18: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccf17: // global
           _sccnK::P64 = P64[R1 + 6];
           _sccnL::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccnK::P64;
           P64[Hp] = _sccnL::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.515579865 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_closure" {
     Text.Printf.$fPrintfArgDouble_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure+2;
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.516505273 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgFloat_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat_$cparseFormat_entry() //  [R2, R3]
         { info_tbl: [(ccf1l,
                       label: Text.Printf.$fPrintfArgFloat_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf1l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccf1m; else goto ccf1n;
       ccf1m: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgFloat_$cparseFormat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccf1n: // global
           I64[Sp - 8] = block_ccf1e_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucf1x; else goto ccf1f;
       ucf1x: // global
           call _ccf1e(R1) args: 0, res: 0, upd: 0;
       ccf1f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccf1e() //  [R1]
         { info_tbl: [(ccf1e,
                       label: block_ccf1e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf1e: // global
           if (R1 & 7 == 1) goto ccf1i; else goto ccf1j;
       ccf1i: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccf1j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccf1w; else goto ccf1v;
       ccf1w: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccf1v: // global
           _sccnP::P64 = P64[R1 + 6];
           _sccnQ::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccnP::P64;
           P64[Hp] = _sccnQ::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.517797686 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_closure" {
     Text.Printf.$fPrintfArgFloat_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure+2;
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.519633159 UTC

[section ""data" . Text.Printf.$w$sformatString_closure" {
     Text.Printf.$w$sformatString_closure:
         const Text.Printf.$w$sformatString_info;
         const 0;
 },
 Text.Printf.$w$sformatString_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf1z: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatString_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scco5_entry() //  [R1]
         { info_tbl: [(ccf20,
                       label: sat_scco5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf20: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccf21; else goto ccf22;
       ccf21: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf22: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccf1T_info;
           _sccnR::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sccnR::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucf2l; else goto ccf1U;
       ucf2l: // global
           call _ccf1T(R1) args: 0, res: 0, upd: 0;
       ccf1U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccf1T() //  [R1]
         { info_tbl: [(ccf1T,
                       label: block_ccf1T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf1T: // global
           if (R1 & 7 == 1) goto ccf1X; else goto ccf1Y;
       ccf1X: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccf1Y: // global
           I64[Sp] = block_ccf28_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucf2k; else goto ccf2a;
       ucf2k: // global
           call _ccf28(R1) args: 0, res: 0, upd: 0;
       ccf2a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccf28() //  [R1]
         { info_tbl: [(ccf28,
                       label: block_ccf28_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf28: // global
           _scco3::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _scco3::I64)) goto ccf2i; else goto ccf2j;
       ccf2i: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccf2j: // global
           R3 = P64[Sp + 8];
           R2 = _scco3::I64;
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sccnZ_entry() //  [R1]
         { info_tbl: [(ccf2m,
                       label: g_sccnZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf2m: // global
           _sccnZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccf2n; else goto ccf2o;
       ccf2o: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccf2q; else goto ccf2p;
       ccf2q: // global
           HpAlloc = 32;
           goto ccf2n;
       ccf2n: // global
           R1 = _sccnZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf2p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccnZ::P64;
           _sccnR::P64 = P64[_sccnZ::P64 + 16];
           _sccnS::P64 = P64[_sccnZ::P64 + 24];
           _sccnT::P64 = P64[_sccnZ::P64 + 32];
           _sccnU::P64 = P64[_sccnZ::P64 + 40];
           I64[Hp - 24] = sat_scco5_info;
           P64[Hp - 8] = _sccnR::P64;
           P64[Hp] = _sccnT::P64;
           R5 = Hp - 24;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sccnU::P64;
           R2 = _sccnS::P64;
           Sp = Sp - 16;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$w$sformatString_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccf2v,
                       label: Text.Printf.$w$sformatString_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf2v: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccf2w; else goto ccf2x;
       ccf2w: // global
           R1 = Text.Printf.$w$sformatString_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       ccf2x: // global
           if (R6 == 118) goto ccf2u; else goto ccf2t;
       ccf2u: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = 115;
           Sp = Sp - 40;
           goto ucf2J;
       ccf2t: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           goto ucf2J;
       ucf2J: // global
           call _ccf1G() args: 0, res: 0, upd: 0;
     }
 },
 _ccf1G() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf1G: // global
           Hp = Hp + 48;
           _sccnX::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto ccf2A; else goto ccf2z;
       ccf2A: // global
           HpAlloc = 48;
           I64[Sp - 8] = block_ccf1F_info;
           R1 = _sccnX::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccf2z: // global
           if (_sccnX::I64 == 115) goto ccf2D; else goto ccf2C;
       ccf2D: // global
           I64[Hp - 40] = g_sccnZ_info;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 40;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 40;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccf2C: // global
           Hp = Hp - 48;
           R2 = _sccnX::I64;
           Sp = Sp + 40;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccf1F() //  [R1]
         { info_tbl: [(ccf1F,
                       label: block_ccf1F_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf1F: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _ccf1G() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.524955699 UTC

[section ""data" . Text.Printf.$wformatString_closure" {
     Text.Printf.$wformatString_closure:
         const Text.Printf.$wformatString_info;
         const 0;
 },
 Text.Printf.$wformatString_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf2L: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatString_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sccoj_entry() //  [R1]
         { info_tbl: [(ccf3e,
                       label: sat_sccoj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf3e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf3f; else goto ccf3g;
       ccf3f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf3g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.Printf.toChar_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccox_entry() //  [R1]
         { info_tbl: [(ccf3L,
                       label: sat_sccox_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf3L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf3M; else goto ccf3N;
       ccf3M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf3N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 32] - 1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wgo_sccoo_entry(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccov_entry() //  [R1]
         { info_tbl: [(ccf3S,
                       label: sat_sccov_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf3S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccf3T; else goto ccf3U;
       ccf3T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf3U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.toChar_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sccoy_entry() //  [R1]
         { info_tbl: [(ccf40,
                       label: sat_sccoy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf40: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccf41; else goto ccf42;
       ccf41: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf42: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.toChar_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $wgo_sccoo_entry() //  [R1, R2, R3]
         { info_tbl: [(ccf47,
                       label: $wgo_sccoo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf47: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccf48; else goto ccf49;
       ccf48: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccf49: // global
           I64[Sp - 32] = block_ccf3x_info;
           _sccoo::P64 = R1;
           _scco8::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 24] = _scco8::P64;
           P64[Sp - 16] = _sccoo::P64;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucf4k; else goto ccf3y;
       ucf4k: // global
           call _ccf3x(R1) args: 0, res: 0, upd: 0;
       ccf3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccf3x() //  [R1]
         { info_tbl: [(ccf3x,
                       label: block_ccf3x_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf3x: // global
           if (R1 & 7 == 1) goto ccf44; else goto ccf45;
       ccf44: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccf45: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccf4e; else goto ccf4d;
       ccf4e: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccf4d: // global
           _scco8::P64 = P64[Sp + 8];
           _sccos::P64 = P64[R1 + 6];
           _sccou::I64 = I64[Sp + 24];
           if (_sccou::I64 != 1) goto ccf4h; else goto ccf4j;
       ccf4h: // global
           _sccot::P64 = P64[R1 + 14];
           I64[Hp - 88] = sat_sccox_info;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sccot::P64;
           I64[Hp - 56] = _sccou::I64;
           I64[Hp - 48] = sat_sccov_info;
           P64[Hp - 32] = _scco8::P64;
           P64[Hp - 24] = _sccos::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccf4j: // global
           I64[Hp - 88] = sat_sccoy_info;
           P64[Hp - 72] = _scco8::P64;
           P64[Hp - 64] = _sccos::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 88;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccf4i::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccf4i::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccoz_entry() //  [R1]
         { info_tbl: [(ccf4p,
                       label: sat_sccoz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf4p: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccf4q; else goto ccf4r;
       ccf4q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf4r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccf35_info;
           _scco8::P64 = P64[R1 + 16];
           _scco9::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _scco8::P64;
           P64[Sp - 24] = _scco9::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucf4D; else goto ccf36;
       ucf4D: // global
           call _ccf35(R1) args: 0, res: 0, upd: 0;
       ccf36: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccf35() //  [R1]
         { info_tbl: [(ccf35,
                       label: block_ccf35_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf35: // global
           if (R1 & 7 == 1) goto ccf4m; else goto ccf4n;
       ccf4m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccf4u; else goto ccf4t;
       ccf4u: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccf4t: // global
           I64[Hp - 16] = sat_sccoj_info;
           P64[Hp] = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
       ccf4n: // global
           I64[Sp] = block_ccf3j_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucf4C; else goto ccf3k;
       ucf4C: // global
           call _ccf3j(R1) args: 0, res: 0, upd: 0;
       ccf3k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccf3j() //  [R1]
         { info_tbl: [(ccf3j,
                       label: block_ccf3j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf3j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccf4y; else goto ccf4x;
       ccf4y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccf4x: // global
           _sccom::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _sccom::I64)) goto ccf4A; else goto ccf4B;
       ccf4A: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccf4B: // global
           I64[Hp - 8] = $wgo_sccoo_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _sccom::I64;
           R2 = P64[Sp + 16];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call $wgo_sccoo_entry(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sccoh_entry() //  [R1]
         { info_tbl: [(ccf4E,
                       label: g_sccoh_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf4E: // global
           _sccoh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccf4F; else goto ccf4G;
       ccf4G: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccf4I; else goto ccf4H;
       ccf4I: // global
           HpAlloc = 40;
           goto ccf4F;
       ccf4F: // global
           R1 = _sccoh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf4H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccoh::P64;
           _scco8::P64 = P64[_sccoh::P64 + 16];
           _scco9::P64 = P64[_sccoh::P64 + 24];
           _sccoa::P64 = P64[_sccoh::P64 + 32];
           _sccob::P64 = P64[_sccoh::P64 + 40];
           _sccoc::P64 = P64[_sccoh::P64 + 48];
           I64[Hp - 32] = sat_sccoz_info;
           P64[Hp - 16] = _scco8::P64;
           P64[Hp - 8] = _scco9::P64;
           P64[Hp] = _sccob::P64;
           R5 = Hp - 32;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sccoc::P64;
           R2 = _sccoa::P64;
           Sp = Sp - 16;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$wformatString_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccf4N,
                       label: Text.Printf.$wformatString_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf4N: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccf4O; else goto ccf4P;
       ccf4O: // global
           R1 = Text.Printf.$wformatString_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       ccf4P: // global
           _sccoB::I64 = I64[Sp];
           if (_sccoB::I64 == 118) goto ccf4M; else goto ccf4L;
       ccf4M: // global
           P64[Sp] = R2;
           P64[Sp - 40] = R3;
           P64[Sp - 32] = R4;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           I64[Sp - 8] = 115;
           Sp = Sp - 40;
           goto ucf51;
       ccf4L: // global
           P64[Sp - 40] = R3;
           P64[Sp - 32] = R4;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           I64[Sp - 8] = _sccoB::I64;
           P64[Sp] = R2;
           Sp = Sp - 40;
           goto ucf51;
       ucf51: // global
           call _ccf2S() args: 0, res: 0, upd: 0;
     }
 },
 _ccf2S() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf2S: // global
           Hp = Hp + 56;
           _sccof::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto ccf4S; else goto ccf4R;
       ccf4S: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_ccf2R_info;
           R1 = _sccof::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccf4R: // global
           if (_sccof::I64 == 115) goto ccf4V; else goto ccf4U;
       ccf4V: // global
           I64[Hp - 48] = g_sccoh_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 48;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccf4U: // global
           Hp = Hp - 56;
           R2 = _sccof::I64;
           Sp = Sp + 48;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccf2R() //  [R1]
         { info_tbl: [(ccf2R,
                       label: block_ccf2R_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf2R: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _ccf2S() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.530572605 UTC

[section ""data" . Text.Printf.formatString_closure" {
     Text.Printf.formatString_closure:
         const Text.Printf.formatString_info;
         const 0;
 },
 Text.Printf.formatString_entry() //  [R2, R3, R4]
         { info_tbl: [(ccf59,
                       label: Text.Printf.formatString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf59: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccf5d; else goto ccf5e;
       ccf5d: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatString_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccf5e: // global
           I64[Sp - 24] = block_ccf56_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucf5m; else goto ccf57;
       ucf5m: // global
           call _ccf56(R1) args: 0, res: 0, upd: 0;
       ccf57: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccf56() //  [R1]
         { info_tbl: [(ccf56,
                       label: block_ccf56_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf56: // global
           I64[Sp - 24] = block_ccf5c_info;
           _sccoG::P64 = P64[R1 + 7];
           _sccoH::P64 = P64[R1 + 15];
           _sccoI::P64 = P64[R1 + 23];
           R1 = P64[R1 + 55];
           P64[Sp - 16] = _sccoH::P64;
           P64[Sp - 8] = _sccoI::P64;
           P64[Sp] = _sccoG::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucf5l; else goto ccf5g;
       ucf5l: // global
           call _ccf5c(R1) args: 0, res: 0, upd: 0;
       ccf5g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccf5c() //  [R1]
         { info_tbl: [(ccf5c,
                       label: block_ccf5c_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf5c: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatString_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.532378101 UTC

[section ""data" . lvl22_rcccn_closure" {
     lvl22_rcccn_closure:
         const lvl22_rcccn_info;
         const 0;
 },
 lvl22_rcccn_entry() //  [R2, R3]
         { info_tbl: [(ccf5y,
                       label: lvl22_rcccn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf5y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccf5z; else goto ccf5A;
       ccf5z: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl22_rcccn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccf5A: // global
           I64[Sp - 8] = block_ccf5r_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucf5K; else goto ccf5s;
       ucf5K: // global
           call _ccf5r(R1) args: 0, res: 0, upd: 0;
       ccf5s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccf5r() //  [R1]
         { info_tbl: [(ccf5r,
                       label: block_ccf5r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf5r: // global
           if (R1 & 7 == 1) goto ccf5v; else goto ccf5w;
       ccf5v: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccf5w: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccf5J; else goto ccf5I;
       ccf5J: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccf5I: // global
           _sccoS::P64 = P64[R1 + 6];
           _sccoT::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccoS::P64;
           P64[Hp] = _sccoT::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.534027713 UTC

[section ""data" . Text.Printf.$fPrintfArg[]_closure" {
     Text.Printf.$fPrintfArg[]_closure:
         const Text.Printf.$fPrintfArg[]_info;
         const 0;
 },
 sat_sccoV_entry() //  [R1, R2, R3]
         { info_tbl: [(ccf5U,
                       label: sat_sccoV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf5U: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Text.Printf.formatString_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$fPrintfArg[]_entry() //  [R2]
         { info_tbl: [(ccf5Y,
                       label: Text.Printf.$fPrintfArg[]_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf5Y: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccf62; else goto ccf61;
       ccf62: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArg[]_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccf61: // global
           I64[Hp - 32] = sat_sccoV_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Text.Printf.C:PrintfArg_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = lvl22_rcccn_closure+2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.535187044 UTC

[section ""data" . lvl23_rccco_closure" {
     lvl23_rccco_closure:
         const GHC.Types.C#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.535782912 UTC

[section ""data" . sat_sccoW_closure" {
     sat_sccoW_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.539437198 UTC

[section ""data" . sat_sccoX_closure" {
     sat_sccoX_closure:
         const :_con_info;
         const sat_sccoW_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.54021181 UTC

[section ""data" . lvl24_rcccp_closure" {
     lvl24_rcccp_closure:
         const lvl24_rcccp_info;
         const 0;
         const 0;
         const 0;
 },
 lvl24_rcccp_entry() //  [R1]
         { info_tbl: [(ccf69,
                       label: lvl24_rcccp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf69: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf6a; else goto ccf6b;
       ccf6a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf6b: // global
           (_ccf66::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccf66::I64 == 0) goto ccf68; else goto ccf67;
       ccf68: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccf67: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccf66::I64;
           R3 = sat_sccoX_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.54110651 UTC

[section ""cstring" . lvl25_rcccq_bytes" {
     lvl25_rcccq_bytes:
         I8[] [48,88]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.54184777 UTC

[section ""data" . lvl26_rcccr_closure" {
     lvl26_rcccr_closure:
         const lvl26_rcccr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_rcccr_entry() //  [R1]
         { info_tbl: [(ccf6i,
                       label: lvl26_rcccr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf6i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf6j; else goto ccf6k;
       ccf6j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf6k: // global
           (_ccf6f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccf6f::I64 == 0) goto ccf6h; else goto ccf6g;
       ccf6h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccf6g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccf6f::I64;
           R2 = lvl25_rcccq_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.54270329 UTC

[section ""cstring" . lvl27_rcccs_bytes" {
     lvl27_rcccs_bytes:
         I8[] [48,98]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.543451473 UTC

[section ""data" . lvl28_rccct_closure" {
     lvl28_rccct_closure:
         const lvl28_rccct_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_rccct_entry() //  [R1]
         { info_tbl: [(ccf6r,
                       label: lvl28_rccct_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf6r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf6s; else goto ccf6t;
       ccf6s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf6t: // global
           (_ccf6o::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccf6o::I64 == 0) goto ccf6q; else goto ccf6p;
       ccf6q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccf6p: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccf6o::I64;
           R2 = lvl27_rcccs_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.544385581 UTC

[section ""cstring" . lvl29_rcccu_bytes" {
     lvl29_rcccu_bytes:
         I8[] [112,114,105,110,116,102,58,32,105,108,108,101,103,97,108,32,99,104,97,114,32,99,111,110,118,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.545184175 UTC

[section ""data" . lvl30_rcccv_closure" {
     lvl30_rcccv_closure:
         const lvl30_rcccv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_rcccv_entry() //  [R1]
         { info_tbl: [(ccf6C,
                       label: lvl30_rcccv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf6C: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccf6D; else goto ccf6E;
       ccf6D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf6E: // global
           (_ccf6x::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccf6x::I64 == 0) goto ccf6z; else goto ccf6y;
       ccf6z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccf6y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccf6x::I64;
           I64[Sp - 24] = block_ccf6A_info;
           R2 = lvl29_rcccu_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccf6A() //  [R1]
         { info_tbl: [(ccf6A,
                       label: block_ccf6A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf6A: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.546208153 UTC

[section ""data" . sat_sccoZ_closure" {
     sat_sccoZ_closure:
         const GHC.Types.I#_con_info;
         const 1114111;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.546768952 UTC

[section ""data" . sat_sccp0_closure" {
     sat_sccp0_closure:
         const :_con_info;
         const sat_sccoZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.547523528 UTC

[section ""data" . lvl31_rcccw_closure" {
     lvl31_rcccw_closure:
         const lvl31_rcccw_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_rcccw_entry() //  [R1]
         { info_tbl: [(ccf6O,
                       label: lvl31_rcccw_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf6O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf6P; else goto ccf6Q;
       ccf6P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf6Q: // global
           (_ccf6L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccf6L::I64 == 0) goto ccf6N; else goto ccf6M;
       ccf6N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccf6M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccf6L::I64;
           R3 = sat_sccp0_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.548417838 UTC

[section ""data" . sat_sccp1_closure" {
     sat_sccp1_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.549028032 UTC

[section ""data" . sat_sccp2_closure" {
     sat_sccp2_closure:
         const :_con_info;
         const sat_sccp1_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.549798637 UTC

[section ""data" . lvl32_rcccx_closure" {
     lvl32_rcccx_closure:
         const lvl32_rcccx_info;
         const 0;
         const 0;
         const 0;
 },
 lvl32_rcccx_entry() //  [R1]
         { info_tbl: [(ccf6X,
                       label: lvl32_rcccx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf6X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf6Y; else goto ccf6Z;
       ccf6Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf6Z: // global
           (_ccf6U::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccf6U::I64 == 0) goto ccf6W; else goto ccf6V;
       ccf6W: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccf6V: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccf6U::I64;
           R3 = sat_sccp2_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.55068794 UTC

[section ""cstring" . lvl33_rcccy_bytes" {
     lvl33_rcccy_bytes:
         I8[] [48]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.551400171 UTC

[section ""data" . lvl34_rcccz_closure" {
     lvl34_rcccz_closure:
         const lvl34_rcccz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl34_rcccz_entry() //  [R1]
         { info_tbl: [(ccf76,
                       label: lvl34_rcccz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf76: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf77; else goto ccf78;
       ccf77: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf78: // global
           (_ccf73::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccf73::I64 == 0) goto ccf75; else goto ccf74;
       ccf75: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccf74: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccf73::I64;
           R2 = lvl33_rcccy_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.552306592 UTC

[section ""data" . sat_sccp3_closure" {
     sat_sccp3_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.552921551 UTC

[section ""data" . sat_sccp4_closure" {
     sat_sccp4_closure:
         const :_con_info;
         const sat_sccp3_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.553810485 UTC

[section ""data" . lvl35_rcccA_closure" {
     lvl35_rcccA_closure:
         const lvl35_rcccA_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_rcccA_entry() //  [R1]
         { info_tbl: [(ccf7f,
                       label: lvl35_rcccA_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf7f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf7g; else goto ccf7h;
       ccf7g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf7h: // global
           (_ccf7c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccf7c::I64 == 0) goto ccf7e; else goto ccf7d;
       ccf7e: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccf7d: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccf7c::I64;
           R3 = sat_sccp4_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.554723159 UTC

[section ""cstring" . lvl36_rcccB_bytes" {
     lvl36_rcccB_bytes:
         I8[] [48,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.555489726 UTC

[section ""data" . lvl37_rcccC_closure" {
     lvl37_rcccC_closure:
         const lvl37_rcccC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_rcccC_entry() //  [R1]
         { info_tbl: [(ccf7o,
                       label: lvl37_rcccC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf7o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf7p; else goto ccf7q;
       ccf7p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf7q: // global
           (_ccf7l::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccf7l::I64 == 0) goto ccf7n; else goto ccf7m;
       ccf7n: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccf7m: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccf7l::I64;
           R2 = lvl36_rcccB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.556355973 UTC

[section ""data" . lvl38_rcccD_closure" {
     lvl38_rcccD_closure:
         const GHC.Base.Just_con_info;
         const lvl26_rcccr_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.556946779 UTC

[section ""data" . lvl39_rcccE_closure" {
     lvl39_rcccE_closure:
         const GHC.Base.Just_con_info;
         const lvl28_rccct_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.557564057 UTC

[section ""data" . lvl40_rcccF_closure" {
     lvl40_rcccF_closure:
         const GHC.Base.Just_con_info;
         const lvl34_rcccz_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.558128875 UTC

[section ""data" . lvl41_rcccG_closure" {
     lvl41_rcccG_closure:
         const GHC.Base.Just_con_info;
         const lvl37_rcccC_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.565503834 UTC

[section ""data" . Text.Printf.$wformatIntegral_closure" {
     Text.Printf.$wformatIntegral_closure:
         const Text.Printf.$wformatIntegral_info;
         const 0;
 },
 Text.Printf.$wformatIntegral_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf7s: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sccpt_entry() //  [R1]
         { info_tbl: [(ccf8G,
                       label: sat_sccpt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf8G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf8H; else goto ccf8I;
       ccf8H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf8I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccpx_entry() //  [R1]
         { info_tbl: [(ccf8R,
                       label: sat_sccpx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf8R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf8S; else goto ccf8T;
       ccf8S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf8T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccpB_entry() //  [R1]
         { info_tbl: [(ccf92,
                       label: sat_sccpB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf92: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccf93; else goto ccf94;
       ccf93: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf94: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfeG_srtd" {
     ucfeG_srtd:
         const SccKB_srt+312;
         const 33;
         const 7516192777;
 },
 sat_sccpC_entry() //  [R1]
         { info_tbl: [(ccf98,
                       label: sat_sccpC_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf98: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccf99; else goto ccf9a;
       ccf99: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf9a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccf8r_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccf8r() //  [R1]
         { info_tbl: [(ccf8r,
                       label: block_ccf8r_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf8r: // global
           if (R1 == 1) goto ccf97; else goto ccf96;
       ccf97: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccf8W_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccf96: // global
           I64[Sp] = block_ccf8v_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ucf9s; else goto ccf8w;
       ucf9s: // global
           call _ccf8v(R1) args: 0, res: 0, upd: 0;
       ccf8w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccf8W() //  [R1, R2]
         { info_tbl: [(ccf8W,
                       label: block_ccf8W_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf8W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccf9q; else goto ccf9p;
       ccf9q: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccf9p: // global
           I64[Hp - 16] = sat_sccpB_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccf8v() //  [R1]
         { info_tbl: [(ccf8v,
                       label: block_ccf8v_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf8v: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccf9e; else goto ccf9j;
       ccf9e: // global
           I64[Sp + 24] = block_ccf8A_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccf9j: // global
           I64[Sp + 24] = block_ccf8L_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl38_rcccD_closure+2;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccf8A() //  [R1, R2]
         { info_tbl: [(ccf8A,
                       label: block_ccf8A_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf8A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccf9h; else goto ccf9g;
       ccf9h: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccf9g: // global
           I64[Hp - 16] = sat_sccpt_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccf8L() //  [R1, R2]
         { info_tbl: [(ccf8L,
                       label: block_ccf8L_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf8L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccf9m; else goto ccf9l;
       ccf9m: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccf9l: // global
           I64[Hp - 16] = sat_sccpx_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfeH_srtd" {
     ucfeH_srtd:
         const SccKB_srt+312;
         const 34;
         const 8589934603;
 },
 sat_sccpO_entry() //  [R1]
         { info_tbl: [(ccf9D,
                       label: sat_sccpO_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf9D: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccf9E; else goto ccf9F;
       ccf9E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccf9F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccf9y_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ucfeI_srtd" {
     ucfeI_srtd:
         const SccKB_srt+320;
         const 33;
         const 4294967301;
 },
 _ccf9y() //  [R1]
         { info_tbl: [(ccf9y,
                       label: block_ccf9y_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf9y: // global
           if (R1 == 1) goto ccf9C; else goto ccf9B;
       ccf9C: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccfa3_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccf9B: // global
           I64[Sp] = block_ccf9I_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ucfa8; else goto ccf9K;
       ucfa8: // global
           call _ccf9I(R1) args: 0, res: 0, upd: 0;
       ccf9K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfa3() //  [R1, R2]
         { info_tbl: [(ccfa3,
                       label: block_ccfa3_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfa3: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfeJ_srtd" {
     ucfeJ_srtd:
         const SccKB_srt+320;
         const 33;
         const 4294967301;
 },
 _ccf9I() //  [R1]
         { info_tbl: [(ccf9I,
                       label: block_ccf9I_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf9I: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccf9R; else goto ccf9Y;
       ccf9R: // global
           I64[Sp + 24] = block_ccf9O_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccf9Y: // global
           I64[Sp + 24] = block_ccf9W_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl39_rcccE_closure+2;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccf9O() //  [R1, R2]
         { info_tbl: [(ccf9O,
                       label: block_ccf9O_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf9O: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccf9W() //  [R1, R2]
         { info_tbl: [(ccf9W,
                       label: block_ccf9W_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf9W: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccpX_entry() //  [R1]
         { info_tbl: [(ccfaA,
                       label: sat_sccpX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfaA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfaB; else goto ccfaC;
       ccfaB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfaC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfay_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfay() //  [R1]
         { info_tbl: [(ccfay,
                       label: block_ccfay_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfay: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccfaH; else goto ccfaG;
       ccfaH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       ccfaG: // global
           if (R1 > 1114111) goto ccfaO; else goto ccfaV;
       ccfaO: // global
           Hp = Hp - 16;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccfaV: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccq3_entry() //  [R1]
         { info_tbl: [(ccfb3,
                       label: sat_sccq3_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfb3: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccfb4; else goto ccfb5;
       ccfb4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfb5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccfb1_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call $wfmti_rcccm_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfb1() //  [R1, R2]
         { info_tbl: [(ccfb1,
                       label: block_ccfb1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfb1: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccq7_entry() //  [R1]
         { info_tbl: [(ccfbe,
                       label: sat_sccq7_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfbe: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccfbf; else goto ccfbg;
       ccfbf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfbg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccfbc_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call $wfmti_rcccm_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfbc() //  [R1, R2]
         { info_tbl: [(ccfbc,
                       label: block_ccfbc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfbc: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccqj_entry() //  [R1]
         { info_tbl: [(ccfbs,
                       label: sat_sccqj_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfbs: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccfbt; else goto ccfbu;
       ccfbt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfbu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccfbn_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfbn() //  [R1]
         { info_tbl: [(ccfbn,
                       label: block_ccfbn_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfbn: // global
           if (R1 == 1) goto ccfbr; else goto ccfbq;
       ccfbr: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccfbS_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccfbq: // global
           I64[Sp] = block_ccfbx_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ucfbX; else goto ccfbz;
       ucfbX: // global
           call _ccfbx(R1) args: 0, res: 0, upd: 0;
       ccfbz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfbS() //  [R1, R2]
         { info_tbl: [(ccfbS,
                       label: block_ccfbS_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfbS: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccfbx() //  [R1]
         { info_tbl: [(ccfbx,
                       label: block_ccfbx_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfbx: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccfbG; else goto ccfbN;
       ccfbG: // global
           I64[Sp + 24] = block_ccfbD_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccfbN: // global
           I64[Sp + 24] = block_ccfbL_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl40_rcccF_closure+2;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfbD() //  [R1, R2]
         { info_tbl: [(ccfbD,
                       label: block_ccfbD_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfbD: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccfbL() //  [R1, R2]
         { info_tbl: [(ccfbL,
                       label: block_ccfbL_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfbL: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccqn_entry() //  [R1]
         { info_tbl: [(ccfc5,
                       label: sat_sccqn_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfc5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccfc6; else goto ccfc7;
       ccfc6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfc7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccfc3_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 32];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl35_rcccA_closure;
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 40;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfc3() //  [R1, R2]
         { info_tbl: [(ccfc3,
                       label: block_ccfc3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfc3: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccqz_entry() //  [R1]
         { info_tbl: [(ccfcj,
                       label: sat_sccqz_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfcj: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccfck; else goto ccfcl;
       ccfck: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfcl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccfce_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfce() //  [R1]
         { info_tbl: [(ccfce,
                       label: block_ccfce_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfce: // global
           if (R1 == 1) goto ccfci; else goto ccfch;
       ccfci: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccfcJ_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccfch: // global
           I64[Sp] = block_ccfco_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ucfcO; else goto ccfcq;
       ucfcO: // global
           call _ccfco(R1) args: 0, res: 0, upd: 0;
       ccfcq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfcJ() //  [R1, R2]
         { info_tbl: [(ccfcJ,
                       label: block_ccfcJ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfcJ: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccfco() //  [R1]
         { info_tbl: [(ccfco,
                       label: block_ccfco_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfco: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccfcx; else goto ccfcE;
       ccfcx: // global
           I64[Sp + 24] = block_ccfcu_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       ccfcE: // global
           I64[Sp + 24] = block_ccfcC_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl41_rcccG_closure+2;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfcu() //  [R1, R2]
         { info_tbl: [(ccfcu,
                       label: block_ccfcu_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfcu: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccfcC() //  [R1, R2]
         { info_tbl: [(ccfcC,
                       label: block_ccfcC_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfcC: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfeK_srtd" {
     ucfeK_srtd:
         const SccKB_srt+320;
         const 43;
         const 8795556937825;
 },
 Text.Printf.$wformatIntegral_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccfcT,
                       label: Text.Printf.$wformatIntegral_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfcT: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccfcU; else goto ccfcV;
       ccfcU: // global
           R1 = Text.Printf.$wformatIntegral_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       ccfcV: // global
           I64[Sp - 48] = block_ccf7y_info;
           R1 = R5;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfeF; else goto ccf7z;
       ucfeF: // global
           call _ccf7y(R1) args: 0, res: 0, upd: 0;
       ccf7z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfeL_srtd" {
     ucfeL_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _ccf7y() //  [R1]
         { info_tbl: [(ccf7y,
                       label: block_ccf7y_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf7y: // global
           _sccp9::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto ccfcQ; else goto ccfcR;
       ccfcQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccfdD; else goto ccfdC;
       ccfdD: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfdC: // global
           _sccp7::P64 = P64[Sp + 24];
           _sccpa::P64 = P64[Sp + 48];
           _sccpb::P64 = P64[Sp + 56];
           _sccpc::P64 = P64[Sp + 64];
           _sccqB::I64 = I64[Sp + 72];
           if (_sccqB::I64 != 118) goto ccfdF; else goto ccfdG;
       ccfdF: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccqB::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = _sccp9::P64;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sccp9::P64;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = _sccqB::I64;
           Sp = Sp - 8;
           goto ucfes;
       ccfdG: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = GHC.Base.Nothing_closure+1;
           P64[Hp - 48] = _sccp9::P64;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccf7I::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sccp9::P64;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = 100;
           Sp = Sp - 8;
           goto ucfes;
       ucfes: // global
           call _ccf8h() args: 0, res: 0, upd: 0;
       ccfcR: // global
           I64[Sp] = block_ccf7L_info;
           _sccqA::P64 = R1;
           R1 = _sccp9::P64;
           P64[Sp + 40] = _sccqA::P64;
           if (R1 & 7 != 0) goto ucfeq; else goto ccf7M;
       ucfeq: // global
           call _ccf7L(R1) args: 0, res: 0, upd: 0;
       ccf7M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfeM_srtd" {
     ucfeM_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _ccf7L() //  [R1]
         { info_tbl: [(ccf7L,
                       label: block_ccf7L_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf7L: // global
           if (R1 & 7 == 1) goto ccfdJ; else goto ccfdR;
       ccfdJ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccfdM; else goto ccfdL;
       ccfdM: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfdL: // global
           _sccp7::P64 = P64[Sp + 24];
           _sccpa::P64 = P64[Sp + 48];
           _sccpb::P64 = P64[Sp + 56];
           _sccpc::P64 = P64[Sp + 64];
           _sccqA::P64 = P64[Sp + 40];
           _sccqH::I64 = I64[Sp + 72];
           if (_sccqH::I64 != 118) goto ccfdO; else goto ccfdP;
       ccfdO: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccqH::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = _sccqA::P64;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = _sccqA::P64;
           P64[Sp + 56] = GHC.Base.Nothing_closure+1;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = _sccqH::I64;
           Sp = Sp - 8;
           goto ucfev;
       ccfdP: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = _sccqA::P64;
           P64[Hp - 48] = GHC.Base.Nothing_closure+1;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccf7V::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = _sccqA::P64;
           P64[Sp + 56] = GHC.Base.Nothing_closure+1;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = 100;
           Sp = Sp - 8;
           goto ucfev;
       ucfev: // global
           call _ccf8h() args: 0, res: 0, upd: 0;
       ccfdR: // global
           I64[Sp - 8] = block_ccf7Y_info;
           _sccqG::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _sccqG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfet; else goto ccf7Z;
       ucfet: // global
           call _ccf7Y(R1) args: 0, res: 0, upd: 0;
       ccf7Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfeN_srtd" {
     ucfeN_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _ccf7Y() //  [R1]
         { info_tbl: [(ccf7Y,
                       label: block_ccf7Y_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf7Y: // global
           _sccp7::P64 = P64[Sp + 32];
           _sccpa::P64 = P64[Sp + 56];
           _sccpb::P64 = P64[Sp + 64];
           _sccpc::P64 = P64[Sp + 72];
           _sccpd::I64 = I64[Sp + 80];
           _sccqA::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto ccfdT; else goto ccfe0;
       ccfdT: // global
           Hp = Hp + 80;
           _sccqM::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccfe3; else goto ccfdV;
       ccfdV: // global
           _sccqG::P64 = P64[Sp + 8];
           if (_sccpd::I64 == 118) goto ccfdZ; else goto ccfdY;
       ccfdZ: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = _sccqA::P64;
           P64[Hp - 48] = _sccqG::P64;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccf88::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 80] = _sccp7::P64;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 64] = _sccqG::P64;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 32] = _sccpc::P64;
           I64[Sp + 8] = 100;
           goto ucfez;
       ccfdY: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccpd::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = _sccqA::P64;
           P64[Hp - 32] = _sccqG::P64;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 80] = _sccp7::P64;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 64] = _sccqG::P64;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 32] = _sccpc::P64;
           I64[Sp + 8] = _sccpd::I64;
           goto ucfez;
       ccfe0: // global
           Hp = Hp + 80;
           _sccqM::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccfe3; else goto ccfe2;
       ccfe3: // global
           HpAlloc = 80;
           R1 = _sccqM::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfe2: // global
           if (_sccpd::I64 == 118) goto ccfe6; else goto ccfe5;
       ccfe6: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = _sccqA::P64;
           P64[Hp - 48] = GHC.Base.Nothing_closure+1;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccf8g::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 80] = _sccp7::P64;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 32] = _sccpc::P64;
           I64[Sp + 8] = 100;
           goto ucfez;
       ccfe5: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccpd::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = _sccqA::P64;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           I64[Sp + 8] = _sccpd::I64;
           P64[Sp + 32] = _sccpc::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 80] = _sccp7::P64;
           goto ucfez;
       ucfez: // global
           call _ccf8h() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ucfeO_srtd" {
     ucfeO_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _ccf8h() //  []
         { info_tbl: [(ccf8h,
                       label: block_ccf8h_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf8h: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccfcY; else goto ccfcX;
       ccfcY: // global
           HpAlloc = 64;
           I64[Sp] = block_ccf8h_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccfcX: // global
           _sccpn::I64 = I64[Sp + 8];
           if (_sccpn::I64 >= 121) goto ccfd0; else goto ucfeb;
       ucfeb: // global
           _sccp5::P64 = P64[Sp + 16];
           _sccp6::P64 = P64[Sp + 24];
           _sccp8::P64 = P64[Sp + 40];
           _sccpf::P64 = P64[Sp + 80];
           _sccph::P64 = P64[Sp + 64];
           _sccpj::P64 = P64[Sp + 48];
           if (_sccpn::I64 < 98) goto ucfec; else goto ucfed;
       ucfec: // global
           if (_sccpn::I64 != 88) goto ccfd0; else goto ccfd1;
       ccfd1: // global
           I64[Hp - 56] = sat_sccpC_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucfed: // global
           _sccpi::P64 = P64[Sp + 56];
           switch [98 .. 120] _sccpn::I64 {
               case 98 : goto ccfd2;
               case 99 : goto ccfd3;
               case 100 : goto ccfdw;
               case 105 : goto ccfdx;
               case 111 : goto ccfdy;
               case 117 : goto ccfdz;
               case 120 : goto ccfdA;
               default: {goto ccfd0;}
           }
       ccfdA: // global
           I64[Hp - 56] = sat_sccqz_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccfdz: // global
           I64[Hp - 56] = sat_sccqn_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           _ccfbZ::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _ccfbZ::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccfdy: // global
           I64[Hp - 56] = sat_sccqj_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccfdx: // global
           I64[Hp - 56] = sat_sccq7_info;
           P64[Hp - 40] = _sccp6::P64;
           P64[Hp - 32] = _sccp8::P64;
           P64[Hp - 24] = _sccpf::P64;
           P64[Hp - 16] = _sccph::P64;
           P64[Hp - 8] = _sccpi::P64;
           _ccfb8::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _ccfb8::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccfdw: // global
           I64[Hp - 56] = sat_sccq3_info;
           P64[Hp - 40] = _sccp6::P64;
           P64[Hp - 32] = _sccp8::P64;
           P64[Hp - 24] = _sccpf::P64;
           P64[Hp - 16] = _sccph::P64;
           P64[Hp - 8] = _sccpi::P64;
           _ccfaX::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _ccfaX::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccfd3: // global
           Hp = Hp - 64;
           I64[Sp + 16] = block_ccfaa_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sccp6::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ccfd2: // global
           I64[Hp - 56] = sat_sccpO_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccfd0: // global
           Hp = Hp - 64;
           R2 = _sccpn::I64;
           Sp = Sp + 88;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccfaa() //  [R1]
         { info_tbl: [(ccfaa,
                       label: block_ccfaa_info
                       rep:StackRep [False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfaa: // global
           if (R1 == 1) goto ccfd9; else goto ucfem;
       ccfd9: // global
           I64[Sp] = block_ccfaf_info;
           R3 = lvl31_rcccw_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ucfem: // global
           Sp = Sp + 72;
           call _ccfdv() args: 0, res: 0, upd: 0;
     }
 },
 _ccfaf() //  [R1]
         { info_tbl: [(ccfaf,
                       label: block_ccfaf_info
                       rep:StackRep [False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfaf: // global
           if (R1 == 1) goto ccfdf; else goto ucfen;
       ccfdf: // global
           I64[Sp] = block_ccfak_info;
           R1 = P64[Sp + 56];
           if (R1 & 7 != 0) goto ucfeB; else goto ccfal;
       ucfeB: // global
           call _ccfak(R1) args: 0, res: 0, upd: 0;
       ccfal: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucfen: // global
           Sp = Sp + 72;
           call _ccfdv() args: 0, res: 0, upd: 0;
     }
 },
 _ccfak() //  [R1]
         { info_tbl: [(ccfak,
                       label: block_ccfak_info
                       rep:StackRep [False, False, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfak: // global
           if (R1 & 7 == 1) goto ccfdi; else goto ucfeo;
       ccfdi: // global
           I64[Sp] = block_ccfap_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[Sp + 16];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       ucfeo: // global
           Sp = Sp + 72;
           call _ccfdv() args: 0, res: 0, upd: 0;
     }
 },
 _ccfap() //  [R1]
         { info_tbl: [(ccfap,
                       label: block_ccfap_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfap: // global
           if (R1 & 7 == 1) goto ucfep; else goto ccfdo;
       ucfep: // global
           Sp = Sp + 72;
           call _ccfdv() args: 0, res: 0, upd: 0;
       ccfdo: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfdr; else goto ccfdq;
       ccfdr: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfdq: // global
           I64[Hp - 40] = sat_sccpX_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R6 = 115;
           R5 = P64[Sp + 48];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[Sp + 64];
           R2 = Hp - 14;
           Sp = Sp + 72;
           call Text.Printf.$w$sformatString_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccfdv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfdv: // global
           R1 = lvl30_rcccv_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.583005821 UTC

[section ""data" . Text.Printf.formatIntegral_closure" {
     Text.Printf.formatIntegral_closure:
         const Text.Printf.formatIntegral_info;
         const 0;
 },
 Text.Printf.formatIntegral_entry() //  [R2, R3, R4]
         { info_tbl: [(ccfeW,
                       label: Text.Printf.formatIntegral_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfeW: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccff0; else goto ccff1;
       ccff0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatIntegral_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccff1: // global
           I64[Sp - 24] = block_ccfeT_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucff9; else goto ccfeU;
       ucff9: // global
           call _ccfeT(R1) args: 0, res: 0, upd: 0;
       ccfeU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfeT() //  [R1]
         { info_tbl: [(ccfeT,
                       label: block_ccfeT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfeT: // global
           I64[Sp - 48] = block_ccfeZ_info;
           _sccqZ::P64 = P64[R1 + 7];
           _sccr0::P64 = P64[R1 + 15];
           _sccr1::P64 = P64[R1 + 23];
           _sccr2::P64 = P64[R1 + 31];
           _sccr3::P64 = P64[R1 + 39];
           _sccr4::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccr0::P64;
           P64[Sp - 32] = _sccr1::P64;
           P64[Sp - 24] = _sccr2::P64;
           P64[Sp - 16] = _sccr3::P64;
           P64[Sp - 8] = _sccr4::P64;
           P64[Sp] = _sccqZ::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucff8; else goto ccff3;
       ucff8: // global
           call _ccfeZ(R1) args: 0, res: 0, upd: 0;
       ccff3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfeZ() //  [R1]
         { info_tbl: [(ccfeZ,
                       label: block_ccfeZ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfeZ: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           _sccr4::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccr4::P64;
           I64[Sp + 64] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.584620075 UTC

[section ""data" . Text.Printf.formatChar1_closure" {
     Text.Printf.formatChar1_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.formatChar2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.586034576 UTC

[section ""data" . Text.Printf.$wformatChar_closure" {
     Text.Printf.$wformatChar_closure:
         const Text.Printf.$wformatChar_info;
         const 0;
 },
 Text.Printf.$wformatChar_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccffb: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatChar_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccrk_entry() //  [R1]
         { info_tbl: [(ccffo,
                       label: sat_sccrk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccffo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccffp; else goto ccffq;
       ccffp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccffq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccffl_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucffv; else goto ccffm;
       ucffv: // global
           call _ccffl(R1) args: 0, res: 0, upd: 0;
       ccffm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccffl() //  [R1]
         { info_tbl: [(ccffl,
                       label: block_ccffl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccffl: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccro_entry() //  [R1]
         { info_tbl: [(ccffE,
                       label: sat_sccro_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccffE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccffF; else goto ccffG;
       ccffF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccffG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccffB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucffL; else goto ccffC;
       ucffL: // global
           call _ccffB(R1) args: 0, res: 0, upd: 0;
       ccffC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccffB() //  [R1]
         { info_tbl: [(ccffB,
                       label: block_ccffB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccffB: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$wformatChar_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccffP,
                       label: Text.Printf.$wformatChar_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccffP: // global
           _sccrc::P64 = R6;
           _sccrb::P64 = R5;
           _sccra::P64 = R4;
           _sccr9::P64 = R3;
           _sccr8::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccffQ; else goto ccffR;
       ccffR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccffT; else goto ccffS;
       ccffT: // global
           HpAlloc = 24;
           goto ccffQ;
       ccffQ: // global
           R1 = Text.Printf.$wformatChar_closure;
           P64[Sp - 40] = _sccr8::P64;
           P64[Sp - 32] = _sccr9::P64;
           P64[Sp - 24] = _sccra::P64;
           P64[Sp - 16] = _sccrb::P64;
           P64[Sp - 8] = _sccrc::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccffS: // global
           _sccrg::I64 = I64[Sp + 16];
           if (_sccrg::I64 != 118) goto ccffN; else goto ccffO;
       ccffN: // global
           I64[Hp - 16] = sat_sccrk_info;
           P64[Hp] = _sccr8::P64;
           R6 = _sccrb::P64;
           R5 = _sccra::P64;
           R4 = _sccr9::P64;
           R3 = Hp - 16;
           R2 = Text.Printf.formatChar1_closure+2;
           P64[Sp - 8] = _sccrc::P64;
           I64[Sp + 16] = _sccrg::I64;
           Sp = Sp - 8;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
       ccffO: // global
           I64[Hp - 16] = sat_sccro_info;
           P64[Hp] = _sccr8::P64;
           R6 = _sccrb::P64;
           R5 = _sccra::P64;
           R4 = _sccr9::P64;
           R3 = Hp - 16;
           R2 = Text.Printf.formatChar1_closure+2;
           P64[Sp - 8] = _sccrc::P64;
           I64[Sp + 16] = 99;
           Sp = Sp - 8;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.588563299 UTC

[section ""data" . Text.Printf.formatChar_closure" {
     Text.Printf.formatChar_closure:
         const Text.Printf.formatChar_info;
         const 0;
 },
 Text.Printf.formatChar_entry() //  [R2, R3]
         { info_tbl: [(ccfg1,
                       label: Text.Printf.formatChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfg1: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfg5; else goto ccfg6;
       ccfg5: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfg6: // global
           I64[Sp - 16] = block_ccffY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfge; else goto ccffZ;
       ucfge: // global
           call _ccffY(R1) args: 0, res: 0, upd: 0;
       ccffZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccffY() //  [R1]
         { info_tbl: [(ccffY,
                       label: block_ccffY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccffY: // global
           I64[Sp - 48] = block_ccfg4_info;
           _sccrs::P64 = P64[R1 + 7];
           _sccrt::P64 = P64[R1 + 15];
           _sccru::P64 = P64[R1 + 23];
           _sccrv::P64 = P64[R1 + 31];
           _sccrw::P64 = P64[R1 + 39];
           _sccrx::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccrt::P64;
           P64[Sp - 32] = _sccru::P64;
           P64[Sp - 24] = _sccrv::P64;
           P64[Sp - 16] = _sccrw::P64;
           P64[Sp - 8] = _sccrx::P64;
           P64[Sp] = _sccrs::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfgd; else goto ccfg8;
       ucfgd: // global
           call _ccfg4(R1) args: 0, res: 0, upd: 0;
       ccfg8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfg4() //  [R1]
         { info_tbl: [(ccfg4,
                       label: block_ccfg4_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfg4: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccrx::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccrx::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatChar_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.590198195 UTC

[section ""data" . Text.Printf.$fPrintfArgChar_closure" {
     Text.Printf.$fPrintfArgChar_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.formatChar_closure+2;
         const Text.Printf.$fPrintfArgChar_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.590757476 UTC

[section ""data" . Text.Printf.$fPrintfArgWord1_closure" {
     Text.Printf.$fPrintfArgWord1_closure:
         const GHC.Types.C#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.592476149 UTC

[section ""data" . Text.Printf.$w$sformatInt3_closure" {
     Text.Printf.$w$sformatInt3_closure:
         const Text.Printf.$w$sformatInt3_info;
         const 0;
 },
 Text.Printf.$w$sformatInt3_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfgg: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt3_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccrZ_entry() //  [R1]
         { info_tbl: [(ccfgB,
                       label: sat_sccrZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfgB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfgC; else goto ccfgD;
       ccfgC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfgD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$fIntegralWord64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfho_srtd" {
     ucfho_srtd:
         const SccKB_srt+192;
         const 62;
         const 2305843009213693957;
 },
 sat_sccrY_entry() //  [R1]
         { info_tbl: [(ccfgP,
                       label: sat_sccrY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfgP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfgQ; else goto ccfgR;
       ccfgQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfgR: // global
           I64[Sp - 8] = block_ccfgI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfha; else goto ccfgJ;
       ucfha: // global
           call _ccfgI(R1) args: 0, res: 0, upd: 0;
       ccfgJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfhp_srtd" {
     ucfhp_srtd:
         const SccKB_srt+192;
         const 62;
         const 2305843009213693957;
 },
 _ccfgI() //  [R1]
         { info_tbl: [(ccfgI,
                       label: block_ccfgI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfgI: // global
           if (R1 & 7 == 1) goto ccfgM; else goto ccfgN;
       ccfgM: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfgN: // global
           I64[Sp] = block_ccfgX_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfgX() //  [R1]
         { info_tbl: [(ccfgX,
                       label: block_ccfgX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfgX: // global
           if (R1 & 7 == 1) goto ccfh4; else goto ccfh8;
       ccfh4: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfh8: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfhq_srtd" {
     ucfhq_srtd:
         const SccKB_srt+192;
         const 65;
         const 11601272640106397697;
         const 1;
 },
 Text.Printf.$w$sformatInt3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccfhe,
                       label: Text.Printf.$w$sformatInt3_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfhe: // global
           _sccrF::P64 = R6;
           _sccrE::P64 = R5;
           _sccrD::P64 = R4;
           _sccrC::P64 = R3;
           _sccrB::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto ccfhf; else goto ccfhg;
       ccfhg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccfhi; else goto ccfhh;
       ccfhi: // global
           HpAlloc = 16;
           goto ccfhf;
       ccfhf: // global
           R1 = Text.Printf.$w$sformatInt3_closure;
           P64[Sp - 40] = _sccrB::P64;
           P64[Sp - 32] = _sccrC::P64;
           P64[Sp - 24] = _sccrD::P64;
           P64[Sp - 16] = _sccrE::P64;
           P64[Sp - 8] = _sccrF::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccfhh: // global
           _sccrG::P64 = P64[Sp];
           _sccrH::P64 = P64[Sp + 8];
           _sccs0::I64 = I64[Sp + 16];
           if (_sccs0::I64 != 118) goto ccfhc; else goto ccfhd;
       ccfhc: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccs0::I64;
           _sccrQ::P64 = Hp - 7;
           _sccrP::P64 = _sccrH::P64;
           _sccrO::P64 = _sccrG::P64;
           _sccrN::P64 = _sccrF::P64;
           _sccrM::P64 = _sccrE::P64;
           _sccrL::P64 = _sccrD::P64;
           _sccrK::P64 = _sccrC::P64;
           goto sccrJ;
       ccfhd: // global
           Hp = Hp - 16;
           _sccrQ::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccrP::P64 = _sccrH::P64;
           _sccrO::P64 = _sccrG::P64;
           _sccrN::P64 = _sccrF::P64;
           _sccrM::P64 = _sccrE::P64;
           _sccrL::P64 = _sccrD::P64;
           _sccrK::P64 = _sccrC::P64;
           goto sccrJ;
       sccrJ: // global
           I64[Sp - 48] = block_ccfgs_info;
           R1 = _sccrQ::P64;
           P64[Sp - 40] = _sccrL::P64;
           P64[Sp - 32] = _sccrM::P64;
           P64[Sp - 24] = _sccrN::P64;
           P64[Sp - 16] = _sccrO::P64;
           P64[Sp - 8] = _sccrP::P64;
           P64[Sp] = _sccrK::P64;
           P64[Sp + 16] = _sccrB::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfhn; else goto ccfgt;
       ucfhn: // global
           call _ccfgs(R1) args: 0, res: 0, upd: 0;
       ccfgt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfhr_srtd" {
     ucfhr_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _ccfgs() //  [R1]
         { info_tbl: [(ccfgs,
                       label: block_ccfgs_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfgs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfhm; else goto ccfhl;
       ccfhm: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfhl: // global
           _sccrS::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccrZ_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccrY_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccrP::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccrP::P64;
           I64[Sp + 64] = _sccrS::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.595916493 UTC

[section ""data" . Text.Printf.$fPrintfArgWord64_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord64_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord64_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord64_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccfhz,
                       label: Text.Printf.$fPrintfArgWord64_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfhz: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfhD; else goto ccfhE;
       ccfhD: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord64_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfhE: // global
           I64[Sp - 16] = block_ccfhw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfhM; else goto ccfhx;
       ucfhM: // global
           call _ccfhw(R1) args: 0, res: 0, upd: 0;
       ccfhx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfhw() //  [R1]
         { info_tbl: [(ccfhw,
                       label: block_ccfhw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfhw: // global
           I64[Sp - 48] = block_ccfhC_info;
           _sccs5::P64 = P64[R1 + 7];
           _sccs6::P64 = P64[R1 + 15];
           _sccs7::P64 = P64[R1 + 23];
           _sccs8::P64 = P64[R1 + 31];
           _sccs9::P64 = P64[R1 + 39];
           _sccsa::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccs6::P64;
           P64[Sp - 32] = _sccs7::P64;
           P64[Sp - 24] = _sccs8::P64;
           P64[Sp - 16] = _sccs9::P64;
           P64[Sp - 8] = _sccsa::P64;
           P64[Sp] = _sccs5::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfhL; else goto ccfhG;
       ucfhL: // global
           call _ccfhC(R1) args: 0, res: 0, upd: 0;
       ccfhG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfhC() //  [R1]
         { info_tbl: [(ccfhC,
                       label: block_ccfhC_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfhC: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccsa::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccsa::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt3_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.598564428 UTC

[section ""data" . Text.Printf.$w$sformatInt2_closure" {
     Text.Printf.$w$sformatInt2_closure:
         const Text.Printf.$w$sformatInt2_info;
         const 0;
 },
 Text.Printf.$w$sformatInt2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfhO: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt2_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccsC_entry() //  [R1]
         { info_tbl: [(ccfi9,
                       label: sat_sccsC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfi9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfia; else goto ccfib;
       ccfia: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfib: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfiW_srtd" {
     ucfiW_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sccsB_entry() //  [R1]
         { info_tbl: [(ccfin,
                       label: sat_sccsB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfin: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfio; else goto ccfip;
       ccfio: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfip: // global
           I64[Sp - 8] = block_ccfig_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfiI; else goto ccfih;
       ucfiI: // global
           call _ccfig(R1) args: 0, res: 0, upd: 0;
       ccfih: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfiX_srtd" {
     ucfiX_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _ccfig() //  [R1]
         { info_tbl: [(ccfig,
                       label: block_ccfig_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfig: // global
           if (R1 & 7 == 1) goto ccfik; else goto ccfil;
       ccfik: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfil: // global
           I64[Sp] = block_ccfiv_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfiv() //  [R1]
         { info_tbl: [(ccfiv,
                       label: block_ccfiv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfiv: // global
           if (R1 & 7 == 1) goto ccfiC; else goto ccfiG;
       ccfiC: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfiG: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfiY_srtd" {
     ucfiY_srtd:
         const SccKB_srt+192;
         const 67;
         const 11601272640106397697;
         const 4;
 },
 Text.Printf.$w$sformatInt2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccfiM,
                       label: Text.Printf.$w$sformatInt2_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfiM: // global
           _sccsi::P64 = R6;
           _sccsh::P64 = R5;
           _sccsg::P64 = R4;
           _sccsf::P64 = R3;
           _sccse::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto ccfiN; else goto ccfiO;
       ccfiO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccfiQ; else goto ccfiP;
       ccfiQ: // global
           HpAlloc = 16;
           goto ccfiN;
       ccfiN: // global
           R1 = Text.Printf.$w$sformatInt2_closure;
           P64[Sp - 40] = _sccse::P64;
           P64[Sp - 32] = _sccsf::P64;
           P64[Sp - 24] = _sccsg::P64;
           P64[Sp - 16] = _sccsh::P64;
           P64[Sp - 8] = _sccsi::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccfiP: // global
           _sccsj::P64 = P64[Sp];
           _sccsk::P64 = P64[Sp + 8];
           _sccsD::I64 = I64[Sp + 16];
           if (_sccsD::I64 != 118) goto ccfiK; else goto ccfiL;
       ccfiK: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccsD::I64;
           _sccst::P64 = Hp - 7;
           _sccss::P64 = _sccsk::P64;
           _sccsr::P64 = _sccsj::P64;
           _sccsq::P64 = _sccsi::P64;
           _sccsp::P64 = _sccsh::P64;
           _sccso::P64 = _sccsg::P64;
           _sccsn::P64 = _sccsf::P64;
           goto sccsm;
       ccfiL: // global
           Hp = Hp - 16;
           _sccst::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccss::P64 = _sccsk::P64;
           _sccsr::P64 = _sccsj::P64;
           _sccsq::P64 = _sccsi::P64;
           _sccsp::P64 = _sccsh::P64;
           _sccso::P64 = _sccsg::P64;
           _sccsn::P64 = _sccsf::P64;
           goto sccsm;
       sccsm: // global
           I64[Sp - 48] = block_ccfi0_info;
           R1 = _sccst::P64;
           P64[Sp - 40] = _sccso::P64;
           P64[Sp - 32] = _sccsp::P64;
           P64[Sp - 24] = _sccsq::P64;
           P64[Sp - 16] = _sccsr::P64;
           P64[Sp - 8] = _sccss::P64;
           P64[Sp] = _sccsn::P64;
           P64[Sp + 16] = _sccse::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfiV; else goto ccfi1;
       ucfiV: // global
           call _ccfi0(R1) args: 0, res: 0, upd: 0;
       ccfi1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfiZ_srtd" {
     ucfiZ_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _ccfi0() //  [R1]
         { info_tbl: [(ccfi0,
                       label: block_ccfi0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfi0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfiU; else goto ccfiT;
       ccfiU: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfiT: // global
           _sccsv::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccsC_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccsB_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccss::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccss::P64;
           I64[Sp + 64] = _sccsv::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.602008133 UTC

[section ""data" . Text.Printf.$fPrintfArgWord32_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord32_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord32_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord32_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccfj7,
                       label: Text.Printf.$fPrintfArgWord32_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfj7: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfjb; else goto ccfjc;
       ccfjb: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord32_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfjc: // global
           I64[Sp - 16] = block_ccfj4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfjk; else goto ccfj5;
       ucfjk: // global
           call _ccfj4(R1) args: 0, res: 0, upd: 0;
       ccfj5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfj4() //  [R1]
         { info_tbl: [(ccfj4,
                       label: block_ccfj4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfj4: // global
           I64[Sp - 48] = block_ccfja_info;
           _sccsI::P64 = P64[R1 + 7];
           _sccsJ::P64 = P64[R1 + 15];
           _sccsK::P64 = P64[R1 + 23];
           _sccsL::P64 = P64[R1 + 31];
           _sccsM::P64 = P64[R1 + 39];
           _sccsN::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccsJ::P64;
           P64[Sp - 32] = _sccsK::P64;
           P64[Sp - 24] = _sccsL::P64;
           P64[Sp - 16] = _sccsM::P64;
           P64[Sp - 8] = _sccsN::P64;
           P64[Sp] = _sccsI::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfjj; else goto ccfje;
       ucfjj: // global
           call _ccfja(R1) args: 0, res: 0, upd: 0;
       ccfje: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfja() //  [R1]
         { info_tbl: [(ccfja,
                       label: block_ccfja_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfja: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccsN::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccsN::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt2_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.604665334 UTC

[section ""data" . Text.Printf.$w$sformatInt1_closure" {
     Text.Printf.$w$sformatInt1_closure:
         const Text.Printf.$w$sformatInt1_info;
         const 0;
 },
 Text.Printf.$w$sformatInt1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfjm: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt1_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_scctf_entry() //  [R1]
         { info_tbl: [(ccfjH,
                       label: sat_scctf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfjH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfjI; else goto ccfjJ;
       ccfjI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfjJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfku_srtd" {
     ucfku_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sccte_entry() //  [R1]
         { info_tbl: [(ccfjV,
                       label: sat_sccte_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfjV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfjW; else goto ccfjX;
       ccfjW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfjX: // global
           I64[Sp - 8] = block_ccfjO_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfkg; else goto ccfjP;
       ucfkg: // global
           call _ccfjO(R1) args: 0, res: 0, upd: 0;
       ccfjP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfkv_srtd" {
     ucfkv_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _ccfjO() //  [R1]
         { info_tbl: [(ccfjO,
                       label: block_ccfjO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfjO: // global
           if (R1 & 7 == 1) goto ccfjS; else goto ccfjT;
       ccfjS: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfjT: // global
           I64[Sp] = block_ccfk3_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfk3() //  [R1]
         { info_tbl: [(ccfk3,
                       label: block_ccfk3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfk3: // global
           if (R1 & 7 == 1) goto ccfka; else goto ccfke;
       ccfka: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfke: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfkw_srtd" {
     ucfkw_srtd:
         const SccKB_srt+192;
         const 69;
         const 11601272640106397697;
         const 16;
 },
 Text.Printf.$w$sformatInt1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccfkk,
                       label: Text.Printf.$w$sformatInt1_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfkk: // global
           _sccsV::P64 = R6;
           _sccsU::P64 = R5;
           _sccsT::P64 = R4;
           _sccsS::P64 = R3;
           _sccsR::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto ccfkl; else goto ccfkm;
       ccfkm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccfko; else goto ccfkn;
       ccfko: // global
           HpAlloc = 16;
           goto ccfkl;
       ccfkl: // global
           R1 = Text.Printf.$w$sformatInt1_closure;
           P64[Sp - 40] = _sccsR::P64;
           P64[Sp - 32] = _sccsS::P64;
           P64[Sp - 24] = _sccsT::P64;
           P64[Sp - 16] = _sccsU::P64;
           P64[Sp - 8] = _sccsV::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccfkn: // global
           _sccsW::P64 = P64[Sp];
           _sccsX::P64 = P64[Sp + 8];
           _scctg::I64 = I64[Sp + 16];
           if (_scctg::I64 != 118) goto ccfki; else goto ccfkj;
       ccfki: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _scctg::I64;
           _scct6::P64 = Hp - 7;
           _scct5::P64 = _sccsX::P64;
           _scct4::P64 = _sccsW::P64;
           _scct3::P64 = _sccsV::P64;
           _scct2::P64 = _sccsU::P64;
           _scct1::P64 = _sccsT::P64;
           _scct0::P64 = _sccsS::P64;
           goto sccsZ;
       ccfkj: // global
           Hp = Hp - 16;
           _scct6::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _scct5::P64 = _sccsX::P64;
           _scct4::P64 = _sccsW::P64;
           _scct3::P64 = _sccsV::P64;
           _scct2::P64 = _sccsU::P64;
           _scct1::P64 = _sccsT::P64;
           _scct0::P64 = _sccsS::P64;
           goto sccsZ;
       sccsZ: // global
           I64[Sp - 48] = block_ccfjy_info;
           R1 = _scct6::P64;
           P64[Sp - 40] = _scct1::P64;
           P64[Sp - 32] = _scct2::P64;
           P64[Sp - 24] = _scct3::P64;
           P64[Sp - 16] = _scct4::P64;
           P64[Sp - 8] = _scct5::P64;
           P64[Sp] = _scct0::P64;
           P64[Sp + 16] = _sccsR::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfkt; else goto ccfjz;
       ucfkt: // global
           call _ccfjy(R1) args: 0, res: 0, upd: 0;
       ccfjz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfkx_srtd" {
     ucfkx_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _ccfjy() //  [R1]
         { info_tbl: [(ccfjy,
                       label: block_ccfjy_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfjy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfks; else goto ccfkr;
       ccfks: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfkr: // global
           _scct8::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_scctf_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccte_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _scct5::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _scct5::P64;
           I64[Sp + 64] = _scct8::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.608165049 UTC

[section ""data" . Text.Printf.$fPrintfArgWord16_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord16_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord16_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord16_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccfkF,
                       label: Text.Printf.$fPrintfArgWord16_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfkF: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfkJ; else goto ccfkK;
       ccfkJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord16_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfkK: // global
           I64[Sp - 16] = block_ccfkC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfkS; else goto ccfkD;
       ucfkS: // global
           call _ccfkC(R1) args: 0, res: 0, upd: 0;
       ccfkD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfkC() //  [R1]
         { info_tbl: [(ccfkC,
                       label: block_ccfkC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfkC: // global
           I64[Sp - 48] = block_ccfkI_info;
           _scctl::P64 = P64[R1 + 7];
           _scctm::P64 = P64[R1 + 15];
           _scctn::P64 = P64[R1 + 23];
           _sccto::P64 = P64[R1 + 31];
           _scctp::P64 = P64[R1 + 39];
           _scctq::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _scctm::P64;
           P64[Sp - 32] = _scctn::P64;
           P64[Sp - 24] = _sccto::P64;
           P64[Sp - 16] = _scctp::P64;
           P64[Sp - 8] = _scctq::P64;
           P64[Sp] = _scctl::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfkR; else goto ccfkM;
       ucfkR: // global
           call _ccfkI(R1) args: 0, res: 0, upd: 0;
       ccfkM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfkI() //  [R1]
         { info_tbl: [(ccfkI,
                       label: block_ccfkI_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfkI: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _scctq::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _scctq::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt1_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.610810996 UTC

[section ""data" . Text.Printf.$w$sformatInt4_closure" {
     Text.Printf.$w$sformatInt4_closure:
         const Text.Printf.$w$sformatInt4_info;
         const 0;
 },
 Text.Printf.$w$sformatInt4_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfkU: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt4_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_scctS_entry() //  [R1]
         { info_tbl: [(ccflf,
                       label: sat_scctS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccflf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccflg; else goto ccflh;
       ccflg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccflh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfm2_srtd" {
     ucfm2_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_scctR_entry() //  [R1]
         { info_tbl: [(ccflt,
                       label: sat_scctR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccflt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccflu; else goto ccflv;
       ccflu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccflv: // global
           I64[Sp - 8] = block_ccflm_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucflO; else goto ccfln;
       ucflO: // global
           call _ccflm(R1) args: 0, res: 0, upd: 0;
       ccfln: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfm3_srtd" {
     ucfm3_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _ccflm() //  [R1]
         { info_tbl: [(ccflm,
                       label: block_ccflm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccflm: // global
           if (R1 & 7 == 1) goto ccflq; else goto ccflr;
       ccflq: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccflr: // global
           I64[Sp] = block_ccflB_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccflB() //  [R1]
         { info_tbl: [(ccflB,
                       label: block_ccflB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccflB: // global
           if (R1 & 7 == 1) goto ccflI; else goto ccflM;
       ccflI: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccflM: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfm4_srtd" {
     ucfm4_srtd:
         const SccKB_srt+192;
         const 71;
         const 11601272640106397697;
         const 64;
 },
 Text.Printf.$w$sformatInt4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccflS,
                       label: Text.Printf.$w$sformatInt4_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccflS: // global
           _sccty::P64 = R6;
           _scctx::P64 = R5;
           _scctw::P64 = R4;
           _scctv::P64 = R3;
           _scctu::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto ccflT; else goto ccflU;
       ccflU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccflW; else goto ccflV;
       ccflW: // global
           HpAlloc = 16;
           goto ccflT;
       ccflT: // global
           R1 = Text.Printf.$w$sformatInt4_closure;
           P64[Sp - 40] = _scctu::P64;
           P64[Sp - 32] = _scctv::P64;
           P64[Sp - 24] = _scctw::P64;
           P64[Sp - 16] = _scctx::P64;
           P64[Sp - 8] = _sccty::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccflV: // global
           _scctz::P64 = P64[Sp];
           _scctA::P64 = P64[Sp + 8];
           _scctT::I64 = I64[Sp + 16];
           if (_scctT::I64 != 118) goto ccflQ; else goto ccflR;
       ccflQ: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _scctT::I64;
           _scctJ::P64 = Hp - 7;
           _scctI::P64 = _scctA::P64;
           _scctH::P64 = _scctz::P64;
           _scctG::P64 = _sccty::P64;
           _scctF::P64 = _scctx::P64;
           _scctE::P64 = _scctw::P64;
           _scctD::P64 = _scctv::P64;
           goto scctC;
       ccflR: // global
           Hp = Hp - 16;
           _scctJ::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _scctI::P64 = _scctA::P64;
           _scctH::P64 = _scctz::P64;
           _scctG::P64 = _sccty::P64;
           _scctF::P64 = _scctx::P64;
           _scctE::P64 = _scctw::P64;
           _scctD::P64 = _scctv::P64;
           goto scctC;
       scctC: // global
           I64[Sp - 48] = block_ccfl6_info;
           R1 = _scctJ::P64;
           P64[Sp - 40] = _scctE::P64;
           P64[Sp - 32] = _scctF::P64;
           P64[Sp - 24] = _scctG::P64;
           P64[Sp - 16] = _scctH::P64;
           P64[Sp - 8] = _scctI::P64;
           P64[Sp] = _scctD::P64;
           P64[Sp + 16] = _scctu::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfm1; else goto ccfl7;
       ucfm1: // global
           call _ccfl6(R1) args: 0, res: 0, upd: 0;
       ccfl7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfm5_srtd" {
     ucfm5_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _ccfl6() //  [R1]
         { info_tbl: [(ccfl6,
                       label: block_ccfl6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfl6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfm0; else goto ccflZ;
       ccfm0: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccflZ: // global
           _scctL::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_scctS_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_scctR_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _scctI::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _scctI::P64;
           I64[Sp + 64] = _scctL::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.614305726 UTC

[section ""data" . Text.Printf.$fPrintfArgWord8_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord8_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord8_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord8_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccfmd,
                       label: Text.Printf.$fPrintfArgWord8_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfmd: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfmh; else goto ccfmi;
       ccfmh: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord8_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfmi: // global
           I64[Sp - 16] = block_ccfma_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfmq; else goto ccfmb;
       ucfmq: // global
           call _ccfma(R1) args: 0, res: 0, upd: 0;
       ccfmb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfma() //  [R1]
         { info_tbl: [(ccfma,
                       label: block_ccfma_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfma: // global
           I64[Sp - 48] = block_ccfmg_info;
           _scctY::P64 = P64[R1 + 7];
           _scctZ::P64 = P64[R1 + 15];
           _sccu0::P64 = P64[R1 + 23];
           _sccu1::P64 = P64[R1 + 31];
           _sccu2::P64 = P64[R1 + 39];
           _sccu3::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _scctZ::P64;
           P64[Sp - 32] = _sccu0::P64;
           P64[Sp - 24] = _sccu1::P64;
           P64[Sp - 16] = _sccu2::P64;
           P64[Sp - 8] = _sccu3::P64;
           P64[Sp] = _scctY::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfmp; else goto ccfmk;
       ucfmp: // global
           call _ccfmg(R1) args: 0, res: 0, upd: 0;
       ccfmk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfmg() //  [R1]
         { info_tbl: [(ccfmg,
                       label: block_ccfmg_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfmg: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccu3::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccu3::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt4_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.617006117 UTC

[section ""data" . Text.Printf.$w$sformatInt_closure" {
     Text.Printf.$w$sformatInt_closure:
         const Text.Printf.$w$sformatInt_info;
         const 0;
 },
 Text.Printf.$w$sformatInt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfms: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt_entry(R6,
                                                R5,
                                                R4,
                                                R3,
                                                R2,
                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccuv_entry() //  [R1]
         { info_tbl: [(ccfmN,
                       label: sat_sccuv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfmN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfmO; else goto ccfmP;
       ccfmO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfmP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fIntegralWord_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfnA_srtd" {
     ucfnA_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sccuu_entry() //  [R1]
         { info_tbl: [(ccfn1,
                       label: sat_sccuu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfn1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfn2; else goto ccfn3;
       ccfn2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfn3: // global
           I64[Sp - 8] = block_ccfmU_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfnm; else goto ccfmV;
       ucfnm: // global
           call _ccfmU(R1) args: 0, res: 0, upd: 0;
       ccfmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfnB_srtd" {
     ucfnB_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _ccfmU() //  [R1]
         { info_tbl: [(ccfmU,
                       label: block_ccfmU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfmU: // global
           if (R1 & 7 == 1) goto ccfmY; else goto ccfmZ;
       ccfmY: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfmZ: // global
           I64[Sp] = block_ccfn9_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfn9() //  [R1]
         { info_tbl: [(ccfn9,
                       label: block_ccfn9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfn9: // global
           if (R1 & 7 == 1) goto ccfng; else goto ccfnk;
       ccfng: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfnk: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfnC_srtd" {
     ucfnC_srtd:
         const SccKB_srt+192;
         const 73;
         const 11601272640106397697;
         const 256;
 },
 Text.Printf.$w$sformatInt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccfnq,
                       label: Text.Printf.$w$sformatInt_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfnq: // global
           _sccub::P64 = R6;
           _sccua::P64 = R5;
           _sccu9::P64 = R4;
           _sccu8::P64 = R3;
           _sccu7::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto ccfnr; else goto ccfns;
       ccfns: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccfnu; else goto ccfnt;
       ccfnu: // global
           HpAlloc = 16;
           goto ccfnr;
       ccfnr: // global
           R1 = Text.Printf.$w$sformatInt_closure;
           P64[Sp - 40] = _sccu7::P64;
           P64[Sp - 32] = _sccu8::P64;
           P64[Sp - 24] = _sccu9::P64;
           P64[Sp - 16] = _sccua::P64;
           P64[Sp - 8] = _sccub::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ccfnt: // global
           _sccuc::P64 = P64[Sp];
           _sccud::P64 = P64[Sp + 8];
           _sccuw::I64 = I64[Sp + 16];
           if (_sccuw::I64 != 118) goto ccfno; else goto ccfnp;
       ccfno: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccuw::I64;
           _sccum::P64 = Hp - 7;
           _sccul::P64 = _sccud::P64;
           _sccuk::P64 = _sccuc::P64;
           _sccuj::P64 = _sccub::P64;
           _sccui::P64 = _sccua::P64;
           _sccuh::P64 = _sccu9::P64;
           _sccug::P64 = _sccu8::P64;
           goto sccuf;
       ccfnp: // global
           Hp = Hp - 16;
           _sccum::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccul::P64 = _sccud::P64;
           _sccuk::P64 = _sccuc::P64;
           _sccuj::P64 = _sccub::P64;
           _sccui::P64 = _sccua::P64;
           _sccuh::P64 = _sccu9::P64;
           _sccug::P64 = _sccu8::P64;
           goto sccuf;
       sccuf: // global
           I64[Sp - 48] = block_ccfmE_info;
           R1 = _sccum::P64;
           P64[Sp - 40] = _sccuh::P64;
           P64[Sp - 32] = _sccui::P64;
           P64[Sp - 24] = _sccuj::P64;
           P64[Sp - 16] = _sccuk::P64;
           P64[Sp - 8] = _sccul::P64;
           P64[Sp] = _sccug::P64;
           P64[Sp + 16] = _sccu7::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfnz; else goto ccfmF;
       ucfnz: // global
           call _ccfmE(R1) args: 0, res: 0, upd: 0;
       ccfmF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfnD_srtd" {
     ucfnD_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _ccfmE() //  [R1]
         { info_tbl: [(ccfmE,
                       label: block_ccfmE_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfmE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfny; else goto ccfnx;
       ccfny: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfnx: // global
           _sccuo::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccuv_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccuu_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccul::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccul::P64;
           I64[Sp + 64] = _sccuo::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.623941443 UTC

[section ""data" . Text.Printf.$fPrintfArgWord_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccfnL,
                       label: Text.Printf.$fPrintfArgWord_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfnL: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfnP; else goto ccfnQ;
       ccfnP: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfnQ: // global
           I64[Sp - 16] = block_ccfnI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfnY; else goto ccfnJ;
       ucfnY: // global
           call _ccfnI(R1) args: 0, res: 0, upd: 0;
       ccfnJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfnI() //  [R1]
         { info_tbl: [(ccfnI,
                       label: block_ccfnI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfnI: // global
           I64[Sp - 48] = block_ccfnO_info;
           _sccuB::P64 = P64[R1 + 7];
           _sccuC::P64 = P64[R1 + 15];
           _sccuD::P64 = P64[R1 + 23];
           _sccuE::P64 = P64[R1 + 31];
           _sccuF::P64 = P64[R1 + 39];
           _sccuG::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccuC::P64;
           P64[Sp - 32] = _sccuD::P64;
           P64[Sp - 24] = _sccuE::P64;
           P64[Sp - 16] = _sccuF::P64;
           P64[Sp - 8] = _sccuG::P64;
           P64[Sp] = _sccuB::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfnX; else goto ccfnS;
       ucfnX: // global
           call _ccfnO(R1) args: 0, res: 0, upd: 0;
       ccfnS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfnO() //  [R1]
         { info_tbl: [(ccfnO,
                       label: block_ccfnO_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfnO: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccuG::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccuG::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt_entry(R6,
                                                R5,
                                                R4,
                                                R3,
                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.625383246 UTC

[section ""data" . Text.Printf.$fPrintfArgInt1_closure" {
     Text.Printf.$fPrintfArgInt1_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.62687037 UTC

[section ""data" . Text.Printf.$fPrintfArgInt64_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt64_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt64_$sformatInt_info;
         const 0;
 },
 sat_sccv2_entry() //  [R1]
         { info_tbl: [(ccfoh,
                       label: sat_sccv2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfoh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfoi; else goto ccfoj;
       ccfoi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfoj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfp0_srtd" {
     ucfp0_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 sat_sccv1_entry() //  [R1]
         { info_tbl: [(ccfov,
                       label: sat_sccv1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfov: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfow; else goto ccfox;
       ccfow: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfox: // global
           I64[Sp - 8] = block_ccfoo_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfoQ; else goto ccfop;
       ucfoQ: // global
           call _ccfoo(R1) args: 0, res: 0, upd: 0;
       ccfop: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfp1_srtd" {
     ucfp1_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 _ccfoo() //  [R1]
         { info_tbl: [(ccfoo,
                       label: block_ccfoo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfoo: // global
           if (R1 & 7 == 1) goto ccfos; else goto ccfot;
       ccfos: // global
           R1 = Text.Printf.$fPrintfArgInt1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfot: // global
           I64[Sp] = block_ccfoD_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfoD() //  [R1]
         { info_tbl: [(ccfoD,
                       label: block_ccfoD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfoD: // global
           if (R1 & 7 == 1) goto ccfoK; else goto ccfoO;
       ccfoK: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfoO: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfp2_srtd" {
     ucfp2_srtd:
         const SccKB_srt+192;
         const 76;
         const 9295429630892703745;
         const 3072;
 },
 Text.Printf.$fPrintfArgInt64_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccfoR,
                       label: Text.Printf.$fPrintfArgInt64_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfoR: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfoS; else goto ccfoT;
       ccfoS: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt64_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfoT: // global
           I64[Sp - 16] = block_ccfo3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfoZ; else goto ccfo4;
       ucfoZ: // global
           call _ccfo3(R1) args: 0, res: 0, upd: 0;
       ccfo4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfp3_srtd" {
     ucfp3_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _ccfo3() //  [R1]
         { info_tbl: [(ccfo3,
                       label: block_ccfo3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfo3: // global
           I64[Sp - 48] = block_ccfo8_info;
           _sccuN::P64 = P64[R1 + 7];
           _sccuO::P64 = P64[R1 + 15];
           _sccuP::P64 = P64[R1 + 23];
           _sccuQ::P64 = P64[R1 + 31];
           _sccuR::P64 = P64[R1 + 39];
           _sccuS::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccuO::P64;
           P64[Sp - 32] = _sccuP::P64;
           P64[Sp - 24] = _sccuQ::P64;
           P64[Sp - 16] = _sccuR::P64;
           P64[Sp - 8] = _sccuS::P64;
           P64[Sp] = _sccuN::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfoY; else goto ccfo9;
       ucfoY: // global
           call _ccfo8(R1) args: 0, res: 0, upd: 0;
       ccfo9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfp4_srtd" {
     ucfp4_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _ccfo8() //  [R1]
         { info_tbl: [(ccfo8,
                       label: block_ccfo8_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfo8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfoX; else goto ccfoW;
       ccfoX: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfoW: // global
           _sccuV::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccv2_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccv1_info;
           _sccuS::P64 = P64[Sp + 40];
           P64[Hp] = _sccuS::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccuR::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccuR::P64;
           P64[Sp + 48] = _sccuS::P64;
           I64[Sp + 56] = _sccuV::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.629639173 UTC

[section ""data" . Text.Printf.$fPrintfArgInt4_closure" {
     Text.Printf.$fPrintfArgInt4_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.631108783 UTC

[section ""data" . Text.Printf.$fPrintfArgInt32_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt32_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt32_$sformatInt_info;
         const 0;
 },
 sat_sccvl_entry() //  [R1]
         { info_tbl: [(ccfpn,
                       label: sat_sccvl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfpn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfpo; else goto ccfpp;
       ccfpo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfpp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt32_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfq6_srtd" {
     ucfq6_srtd:
         const SccKB_srt+192;
         const 77;
         const 9223372036854775809;
         const 4096;
 },
 sat_sccvk_entry() //  [R1]
         { info_tbl: [(ccfpB,
                       label: sat_sccvk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfpB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfpC; else goto ccfpD;
       ccfpC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfpD: // global
           I64[Sp - 8] = block_ccfpu_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfpW; else goto ccfpv;
       ucfpW: // global
           call _ccfpu(R1) args: 0, res: 0, upd: 0;
       ccfpv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfq7_srtd" {
     ucfq7_srtd:
         const SccKB_srt+192;
         const 77;
         const 9223372036854775809;
         const 4096;
 },
 _ccfpu() //  [R1]
         { info_tbl: [(ccfpu,
                       label: block_ccfpu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfpu: // global
           if (R1 & 7 == 1) goto ccfpy; else goto ccfpz;
       ccfpy: // global
           R1 = Text.Printf.$fPrintfArgInt4_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfpz: // global
           I64[Sp] = block_ccfpJ_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfpJ() //  [R1]
         { info_tbl: [(ccfpJ,
                       label: block_ccfpJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfpJ: // global
           if (R1 & 7 == 1) goto ccfpQ; else goto ccfpU;
       ccfpQ: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfpU: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfq8_srtd" {
     ucfq8_srtd:
         const SccKB_srt+192;
         const 78;
         const 9295429630892703745;
         const 12288;
 },
 Text.Printf.$fPrintfArgInt32_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccfpX,
                       label: Text.Printf.$fPrintfArgInt32_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfpX: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfpY; else goto ccfpZ;
       ccfpY: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt32_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfpZ: // global
           I64[Sp - 16] = block_ccfp9_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfq5; else goto ccfpa;
       ucfq5: // global
           call _ccfp9(R1) args: 0, res: 0, upd: 0;
       ccfpa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfq9_srtd" {
     ucfq9_srtd:
         const SccKB_srt+192;
         const 77;
         const 9295429630892703745;
         const 4096;
 },
 _ccfp9() //  [R1]
         { info_tbl: [(ccfp9,
                       label: block_ccfp9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfp9: // global
           I64[Sp - 48] = block_ccfpe_info;
           _sccv6::P64 = P64[R1 + 7];
           _sccv7::P64 = P64[R1 + 15];
           _sccv8::P64 = P64[R1 + 23];
           _sccv9::P64 = P64[R1 + 31];
           _sccva::P64 = P64[R1 + 39];
           _sccvb::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccv7::P64;
           P64[Sp - 32] = _sccv8::P64;
           P64[Sp - 24] = _sccv9::P64;
           P64[Sp - 16] = _sccva::P64;
           P64[Sp - 8] = _sccvb::P64;
           P64[Sp] = _sccv6::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfq4; else goto ccfpf;
       ucfq4: // global
           call _ccfpe(R1) args: 0, res: 0, upd: 0;
       ccfpf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfqa_srtd" {
     ucfqa_srtd:
         const SccKB_srt+192;
         const 77;
         const 9295429630892703745;
         const 4096;
 },
 _ccfpe() //  [R1]
         { info_tbl: [(ccfpe,
                       label: block_ccfpe_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfpe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfq3; else goto ccfq2;
       ccfq3: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfq2: // global
           _sccve::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccvl_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccvk_info;
           _sccvb::P64 = P64[Sp + 40];
           P64[Hp] = _sccvb::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccva::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccva::P64;
           P64[Sp + 48] = _sccvb::P64;
           I64[Sp + 56] = _sccve::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.633826208 UTC

[section ""data" . Text.Printf.$fPrintfArgInt3_closure" {
     Text.Printf.$fPrintfArgInt3_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.635317134 UTC

[section ""data" . Text.Printf.$fPrintfArgInt16_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt16_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt16_$sformatInt_info;
         const 0;
 },
 sat_sccvE_entry() //  [R1]
         { info_tbl: [(ccfqt,
                       label: sat_sccvE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfqt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfqu; else goto ccfqv;
       ccfqu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfqv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt16_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfrc_srtd" {
     ucfrc_srtd:
         const SccKB_srt+192;
         const 79;
         const 9223372036854775809;
         const 16384;
 },
 sat_sccvD_entry() //  [R1]
         { info_tbl: [(ccfqH,
                       label: sat_sccvD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfqH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfqI; else goto ccfqJ;
       ccfqI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfqJ: // global
           I64[Sp - 8] = block_ccfqA_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfr2; else goto ccfqB;
       ucfr2: // global
           call _ccfqA(R1) args: 0, res: 0, upd: 0;
       ccfqB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfrd_srtd" {
     ucfrd_srtd:
         const SccKB_srt+192;
         const 79;
         const 9223372036854775809;
         const 16384;
 },
 _ccfqA() //  [R1]
         { info_tbl: [(ccfqA,
                       label: block_ccfqA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfqA: // global
           if (R1 & 7 == 1) goto ccfqE; else goto ccfqF;
       ccfqE: // global
           R1 = Text.Printf.$fPrintfArgInt3_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfqF: // global
           I64[Sp] = block_ccfqP_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfqP() //  [R1]
         { info_tbl: [(ccfqP,
                       label: block_ccfqP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfqP: // global
           if (R1 & 7 == 1) goto ccfqW; else goto ccfr0;
       ccfqW: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfr0: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfre_srtd" {
     ucfre_srtd:
         const SccKB_srt+192;
         const 80;
         const 9295429630892703745;
         const 49152;
 },
 Text.Printf.$fPrintfArgInt16_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccfr3,
                       label: Text.Printf.$fPrintfArgInt16_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfr3: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfr4; else goto ccfr5;
       ccfr4: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt16_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfr5: // global
           I64[Sp - 16] = block_ccfqf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfrb; else goto ccfqg;
       ucfrb: // global
           call _ccfqf(R1) args: 0, res: 0, upd: 0;
       ccfqg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfrf_srtd" {
     ucfrf_srtd:
         const SccKB_srt+192;
         const 79;
         const 9295429630892703745;
         const 16384;
 },
 _ccfqf() //  [R1]
         { info_tbl: [(ccfqf,
                       label: block_ccfqf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfqf: // global
           I64[Sp - 48] = block_ccfqk_info;
           _sccvp::P64 = P64[R1 + 7];
           _sccvq::P64 = P64[R1 + 15];
           _sccvr::P64 = P64[R1 + 23];
           _sccvs::P64 = P64[R1 + 31];
           _sccvt::P64 = P64[R1 + 39];
           _sccvu::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccvq::P64;
           P64[Sp - 32] = _sccvr::P64;
           P64[Sp - 24] = _sccvs::P64;
           P64[Sp - 16] = _sccvt::P64;
           P64[Sp - 8] = _sccvu::P64;
           P64[Sp] = _sccvp::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfra; else goto ccfql;
       ucfra: // global
           call _ccfqk(R1) args: 0, res: 0, upd: 0;
       ccfql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfrg_srtd" {
     ucfrg_srtd:
         const SccKB_srt+192;
         const 79;
         const 9295429630892703745;
         const 16384;
 },
 _ccfqk() //  [R1]
         { info_tbl: [(ccfqk,
                       label: block_ccfqk_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfqk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfr9; else goto ccfr8;
       ccfr9: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfr8: // global
           _sccvx::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccvE_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccvD_info;
           _sccvu::P64 = P64[Sp + 40];
           P64[Hp] = _sccvu::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccvt::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccvt::P64;
           P64[Sp + 48] = _sccvu::P64;
           I64[Sp + 56] = _sccvx::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.638066298 UTC

[section ""data" . Text.Printf.$fPrintfArgInt5_closure" {
     Text.Printf.$fPrintfArgInt5_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar22_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.639591727 UTC

[section ""data" . Text.Printf.$fPrintfArgInt8_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt8_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt8_$sformatInt_info;
         const 0;
 },
 sat_sccvX_entry() //  [R1]
         { info_tbl: [(ccfrz,
                       label: sat_sccvX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfrz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfrA; else goto ccfrB;
       ccfrA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfrB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt8_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfsi_srtd" {
     ucfsi_srtd:
         const SccKB_srt+192;
         const 81;
         const 9223372036854775809;
         const 65536;
 },
 sat_sccvW_entry() //  [R1]
         { info_tbl: [(ccfrN,
                       label: sat_sccvW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfrN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfrO; else goto ccfrP;
       ccfrO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfrP: // global
           I64[Sp - 8] = block_ccfrG_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfs8; else goto ccfrH;
       ucfs8: // global
           call _ccfrG(R1) args: 0, res: 0, upd: 0;
       ccfrH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfsj_srtd" {
     ucfsj_srtd:
         const SccKB_srt+192;
         const 81;
         const 9223372036854775809;
         const 65536;
 },
 _ccfrG() //  [R1]
         { info_tbl: [(ccfrG,
                       label: block_ccfrG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfrG: // global
           if (R1 & 7 == 1) goto ccfrK; else goto ccfrL;
       ccfrK: // global
           R1 = Text.Printf.$fPrintfArgInt5_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfrL: // global
           I64[Sp] = block_ccfrV_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfrV() //  [R1]
         { info_tbl: [(ccfrV,
                       label: block_ccfrV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfrV: // global
           if (R1 & 7 == 1) goto ccfs2; else goto ccfs6;
       ccfs2: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfs6: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfsk_srtd" {
     ucfsk_srtd:
         const SccKB_srt+192;
         const 82;
         const 9295429630892703745;
         const 196608;
 },
 Text.Printf.$fPrintfArgInt8_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccfs9,
                       label: Text.Printf.$fPrintfArgInt8_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfs9: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfsa; else goto ccfsb;
       ccfsa: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt8_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfsb: // global
           I64[Sp - 16] = block_ccfrl_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfsh; else goto ccfrm;
       ucfsh: // global
           call _ccfrl(R1) args: 0, res: 0, upd: 0;
       ccfrm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfsl_srtd" {
     ucfsl_srtd:
         const SccKB_srt+192;
         const 81;
         const 9295429630892703745;
         const 65536;
 },
 _ccfrl() //  [R1]
         { info_tbl: [(ccfrl,
                       label: block_ccfrl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfrl: // global
           I64[Sp - 48] = block_ccfrq_info;
           _sccvI::P64 = P64[R1 + 7];
           _sccvJ::P64 = P64[R1 + 15];
           _sccvK::P64 = P64[R1 + 23];
           _sccvL::P64 = P64[R1 + 31];
           _sccvM::P64 = P64[R1 + 39];
           _sccvN::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccvJ::P64;
           P64[Sp - 32] = _sccvK::P64;
           P64[Sp - 24] = _sccvL::P64;
           P64[Sp - 16] = _sccvM::P64;
           P64[Sp - 8] = _sccvN::P64;
           P64[Sp] = _sccvI::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfsg; else goto ccfrr;
       ucfsg: // global
           call _ccfrq(R1) args: 0, res: 0, upd: 0;
       ccfrr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfsm_srtd" {
     ucfsm_srtd:
         const SccKB_srt+192;
         const 81;
         const 9295429630892703745;
         const 65536;
 },
 _ccfrq() //  [R1]
         { info_tbl: [(ccfrq,
                       label: block_ccfrq_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfrq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfsf; else goto ccfse;
       ccfsf: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfse: // global
           _sccvQ::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccvX_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccvW_info;
           _sccvN::P64 = P64[Sp + 40];
           P64[Hp] = _sccvN::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccvM::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccvM::P64;
           P64[Sp + 48] = _sccvN::P64;
           I64[Sp + 56] = _sccvQ::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.643284245 UTC

[section ""data" . Text.Printf.$fPrintfArgInt_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt_$sformatInt_info;
         const 0;
 },
 sat_sccwg_entry() //  [R1]
         { info_tbl: [(ccfsF,
                       label: sat_sccwg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfsF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfsG; else goto ccfsH;
       ccfsG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfsH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fIntegralInt_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfto_srtd" {
     ucfto_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 sat_sccwf_entry() //  [R1]
         { info_tbl: [(ccfsT,
                       label: sat_sccwf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfsT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfsU; else goto ccfsV;
       ccfsU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfsV: // global
           I64[Sp - 8] = block_ccfsM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfte; else goto ccfsN;
       ucfte: // global
           call _ccfsM(R1) args: 0, res: 0, upd: 0;
       ccfsN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucftp_srtd" {
     ucftp_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 _ccfsM() //  [R1]
         { info_tbl: [(ccfsM,
                       label: block_ccfsM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfsM: // global
           if (R1 & 7 == 1) goto ccfsQ; else goto ccfsR;
       ccfsQ: // global
           R1 = Text.Printf.$fPrintfArgInt1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfsR: // global
           I64[Sp] = block_ccft1_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccft1() //  [R1]
         { info_tbl: [(ccft1,
                       label: block_ccft1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccft1: // global
           if (R1 & 7 == 1) goto ccft8; else goto ccftc;
       ccft8: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccftc: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucftq_srtd" {
     ucftq_srtd:
         const SccKB_srt+192;
         const 83;
         const 9295429630892703745;
         const 263168;
 },
 Text.Printf.$fPrintfArgInt_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccftf,
                       label: Text.Printf.$fPrintfArgInt_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccftf: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccftg; else goto ccfth;
       ccftg: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfth: // global
           I64[Sp - 16] = block_ccfsr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucftn; else goto ccfss;
       ucftn: // global
           call _ccfsr(R1) args: 0, res: 0, upd: 0;
       ccfss: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucftr_srtd" {
     ucftr_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _ccfsr() //  [R1]
         { info_tbl: [(ccfsr,
                       label: block_ccfsr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfsr: // global
           I64[Sp - 48] = block_ccfsw_info;
           _sccw1::P64 = P64[R1 + 7];
           _sccw2::P64 = P64[R1 + 15];
           _sccw3::P64 = P64[R1 + 23];
           _sccw4::P64 = P64[R1 + 31];
           _sccw5::P64 = P64[R1 + 39];
           _sccw6::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccw2::P64;
           P64[Sp - 32] = _sccw3::P64;
           P64[Sp - 24] = _sccw4::P64;
           P64[Sp - 16] = _sccw5::P64;
           P64[Sp - 8] = _sccw6::P64;
           P64[Sp] = _sccw1::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucftm; else goto ccfsx;
       ucftm: // global
           call _ccfsw(R1) args: 0, res: 0, upd: 0;
       ccfsx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfts_srtd" {
     ucfts_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _ccfsw() //  [R1]
         { info_tbl: [(ccfsw,
                       label: block_ccfsw_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfsw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccftl; else goto ccftk;
       ccftl: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccftk: // global
           _sccw9::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccwg_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccwf_info;
           _sccw6::P64 = P64[Sp + 40];
           P64[Hp] = _sccw6::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccw5::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccw5::P64;
           P64[Sp + 48] = _sccw6::P64;
           I64[Sp + 56] = _sccw9::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.647708541 UTC

[section ""data" . Text.Printf.$wformatInt_closure" {
     Text.Printf.$wformatInt_closure:
         const Text.Printf.$wformatInt_info;
         const 0;
 },
 Text.Printf.$wformatInt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccftu: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatInt_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sccws_entry() //  [R1]
         { info_tbl: [(ccftS,
                       label: sat_sccws_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccftS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccftT; else goto ccftU;
       ccftT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccftU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccwJ_entry() //  [R1]
         { info_tbl: [(ccfu7,
                       label: sat_sccwJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfu7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfu8; else goto ccfu9;
       ccfu8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfu9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfv7_srtd" {
     ucfv7_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sccwI_entry() //  [R1]
         { info_tbl: [(ccful,
                       label: sat_sccwI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccful: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfum; else goto ccfun;
       ccfum: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfun: // global
           I64[Sp - 16] = block_ccfue_info;
           _sccwr::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _sccwr::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfuJ; else goto ccfuf;
       ucfuJ: // global
           call _ccfue(R1) args: 0, res: 0, upd: 0;
       ccfuf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfv8_srtd" {
     ucfv8_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _ccfue() //  [R1]
         { info_tbl: [(ccfue,
                       label: block_ccfue_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfue: // global
           if (R1 & 7 == 1) goto ccfui; else goto ccfuj;
       ccfui: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccfut; else goto ccfus;
       ccfut: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfus: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfuj: // global
           I64[Sp + 8] = block_ccfuw_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           Sp = Sp + 8;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfuw() //  [R1]
         { info_tbl: [(ccfuw,
                       label: block_ccfuw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfuw: // global
           if (R1 & 7 == 1) goto ccfuD; else goto ccfuH;
       ccfuD: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfuH: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfv9_srtd" {
     ucfv9_srtd:
         const SccKB_srt+192;
         const 84;
         const 9304436830147444737;
         const 524288;
 },
 Text.Printf.$wformatInt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccfuK,
                       label: Text.Printf.$wformatInt_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfuK: // global
           _sccwl::P64 = R6;
           _sccwk::P64 = R5;
           _sccwj::P64 = R4;
           _sccwi::P64 = R3;
           _sccwh::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto ccfuL; else goto ccfuM;
       ccfuM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfuO; else goto ccfuN;
       ccfuO: // global
           HpAlloc = 24;
           goto ccfuL;
       ccfuL: // global
           R1 = Text.Printf.$wformatInt_closure;
           P64[Sp - 40] = _sccwh::P64;
           P64[Sp - 32] = _sccwi::P64;
           P64[Sp - 24] = _sccwj::P64;
           P64[Sp - 16] = _sccwk::P64;
           P64[Sp - 8] = _sccwl::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       ccfuN: // global
           I64[Hp - 16] = sat_sccws_info;
           P64[Hp] = _sccwi::P64;
           I64[Sp - 40] = block_ccftA_info;
           R2 = _sccwh::P64;
           I64[Sp - 56] = stg_ap_p_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 32] = _sccwh::P64;
           P64[Sp - 24] = _sccwj::P64;
           P64[Sp - 16] = _sccwk::P64;
           P64[Sp - 8] = _sccwl::P64;
           Sp = Sp - 56;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfva_srtd" {
     ucfva_srtd:
         const SccKB_srt+192;
         const 64;
         const 9304436830147444737;
 },
 _ccftA() //  [R1]
         { info_tbl: [(ccftA,
                       label: block_ccftA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccftA: // global
           I64[Sp - 8] = block_ccftG_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfvb_srtd" {
     ucfvb_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccftG() //  [R1]
         { info_tbl: [(ccftG,
                       label: block_ccftG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccftG: // global
           _sccwk::P64 = P64[Sp + 32];
           _sccwl::P64 = P64[Sp + 40];
           _sccwm::P64 = P64[Sp + 48];
           _sccwn::P64 = P64[Sp + 56];
           _sccwo::P64 = P64[Sp + 64];
           _sccwp::P64 = P64[Sp + 72];
           _sccwq::I64 = I64[Sp + 80];
           if (R1 == 1) goto ccfuZ; else goto ccfuV;
       ccfuZ: // global
           Hp = Hp + 16;
           _sccwK::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccfv2; else goto ccfv1;
       ccfv1: // global
           if (_sccwq::I64 == 118) goto ccfv5; else goto ccfv4;
       ccfv5: // global
           Hp = Hp - 16;
           _sccwA::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccwz::P64 = _sccwp::P64;
           _sccwy::P64 = _sccwo::P64;
           _sccwx::P64 = _sccwn::P64;
           _sccww::P64 = _sccwm::P64;
           _sccwv::P64 = _sccwl::P64;
           _sccwu::P64 = _sccwk::P64;
           goto sccwt;
       ccfv4: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccwq::I64;
           _sccwA::P64 = Hp - 7;
           _sccwz::P64 = _sccwp::P64;
           _sccwy::P64 = _sccwo::P64;
           _sccwx::P64 = _sccwn::P64;
           _sccww::P64 = _sccwm::P64;
           _sccwv::P64 = _sccwl::P64;
           _sccwu::P64 = _sccwk::P64;
           goto sccwt;
       ccfuV: // global
           Hp = Hp + 16;
           _sccwK::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccfv2; else goto ccfuX;
       ccfv2: // global
           HpAlloc = 16;
           R1 = _sccwK::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccfuX: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccwq::I64;
           _sccwA::P64 = Hp - 7;
           _sccwz::P64 = _sccwp::P64;
           _sccwy::P64 = _sccwo::P64;
           _sccwx::P64 = _sccwn::P64;
           _sccww::P64 = _sccwm::P64;
           _sccwv::P64 = _sccwl::P64;
           _sccwu::P64 = _sccwk::P64;
           goto sccwt;
       sccwt: // global
           I64[Sp] = block_ccftY_info;
           R1 = _sccwA::P64;
           P64[Sp + 32] = _sccwz::P64;
           P64[Sp + 40] = _sccwy::P64;
           P64[Sp + 48] = _sccwx::P64;
           P64[Sp + 56] = _sccww::P64;
           P64[Sp + 64] = _sccwv::P64;
           P64[Sp + 80] = _sccwu::P64;
           if (R1 & 7 != 0) goto ucfv6; else goto ccftZ;
       ucfv6: // global
           call _ccftY(R1) args: 0, res: 0, upd: 0;
       ccftZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfvc_srtd" {
     ucfvc_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccftY() //  [R1]
         { info_tbl: [(ccftY,
                       label: block_ccftY_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccftY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccfuT; else goto ccfuS;
       ccfuT: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfuS: // global
           _sccwC::I64 = I64[R1 + 7];
           I64[Hp - 56] = sat_sccwJ_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_sccwI_info;
           P64[Hp - 8] = P64[Sp + 72];
           P64[Hp] = P64[Sp + 8];
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 64];
           R4 = P64[Sp + 80];
           R3 = Hp - 56;
           R2 = Hp - 24;
           P64[Sp + 56] = P64[Sp + 48];
           P64[Sp + 64] = P64[Sp + 40];
           P64[Sp + 72] = P64[Sp + 32];
           I64[Sp + 80] = _sccwC::I64;
           Sp = Sp + 56;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.652442923 UTC

[section ""data" . Text.Printf.formatInt_closure" {
     Text.Printf.formatInt_closure:
         const Text.Printf.formatInt_info;
         const 0;
 },
 Text.Printf.formatInt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccfvk,
                       label: Text.Printf.formatInt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfvk: // global
           if ((Sp + -80) < SpLim) (likely: False) goto ccfvo; else goto ccfvp;
       ccfvo: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatInt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfvp: // global
           I64[Sp - 32] = block_ccfvh_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucfvx; else goto ccfvi;
       ucfvx: // global
           call _ccfvh(R1) args: 0, res: 0, upd: 0;
       ccfvi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfvh() //  [R1]
         { info_tbl: [(ccfvh,
                       label: block_ccfvh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfvh: // global
           I64[Sp - 48] = block_ccfvn_info;
           _sccwT::P64 = P64[R1 + 7];
           _sccwU::P64 = P64[R1 + 15];
           _sccwV::P64 = P64[R1 + 23];
           _sccwW::P64 = P64[R1 + 31];
           _sccwX::P64 = P64[R1 + 39];
           _sccwY::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccwU::P64;
           P64[Sp - 32] = _sccwV::P64;
           P64[Sp - 24] = _sccwW::P64;
           P64[Sp - 16] = _sccwX::P64;
           P64[Sp - 8] = _sccwY::P64;
           P64[Sp] = _sccwT::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfvw; else goto ccfvr;
       ucfvw: // global
           call _ccfvn(R1) args: 0, res: 0, upd: 0;
       ccfvr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfvn() //  [R1]
         { info_tbl: [(ccfvn,
                       label: block_ccfvn_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfvn: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           _sccwY::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 16];
           P64[Sp + 48] = P64[Sp + 24];
           P64[Sp + 56] = P64[Sp + 32];
           P64[Sp + 64] = _sccwY::P64;
           I64[Sp + 72] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatInt_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.654054945 UTC

[section ""data" . Text.Printf.$fPrintfArgWord64_closure" {
     Text.Printf.$fPrintfArgWord64_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord64_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.654650818 UTC

[section ""data" . Text.Printf.$fPrintfArgWord32_closure" {
     Text.Printf.$fPrintfArgWord32_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord32_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.6552459 UTC

[section ""data" . Text.Printf.$fPrintfArgWord16_closure" {
     Text.Printf.$fPrintfArgWord16_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord16_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.65580248 UTC

[section ""data" . Text.Printf.$fPrintfArgWord8_closure" {
     Text.Printf.$fPrintfArgWord8_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord8_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.656395145 UTC

[section ""data" . Text.Printf.$fPrintfArgWord_closure" {
     Text.Printf.$fPrintfArgWord_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.657013774 UTC

[section ""data" . Text.Printf.$fPrintfArgInt64_closure" {
     Text.Printf.$fPrintfArgInt64_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt64_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.657669902 UTC

[section ""data" . Text.Printf.$fPrintfArgInt32_closure" {
     Text.Printf.$fPrintfArgInt32_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt32_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.658250232 UTC

[section ""data" . Text.Printf.$fPrintfArgInt16_closure" {
     Text.Printf.$fPrintfArgInt16_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt16_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.658876042 UTC

[section ""data" . Text.Printf.$fPrintfArgInt8_closure" {
     Text.Printf.$fPrintfArgInt8_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt8_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.65947714 UTC

[section ""data" . Text.Printf.$fPrintfArgInt_closure" {
     Text.Printf.$fPrintfArgInt_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.660982775 UTC

[section ""data" . Text.Printf.formatInteger_closure" {
     Text.Printf.formatInteger_closure:
         const Text.Printf.formatInteger_info;
         const 0;
 },
 section ""relreadonly" . ucfws_srtd" {
     ucfws_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sccxj_entry() //  [R1]
         { info_tbl: [(ccfvX,
                       label: sat_sccxj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfvX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfvY; else goto ccfvZ;
       ccfvY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfvZ: // global
           I64[Sp - 8] = block_ccfvQ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfwi; else goto ccfvR;
       ucfwi: // global
           call _ccfvQ(R1) args: 0, res: 0, upd: 0;
       ccfvR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfwt_srtd" {
     ucfwt_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _ccfvQ() //  [R1]
         { info_tbl: [(ccfvQ,
                       label: block_ccfvQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfvQ: // global
           if (R1 & 7 == 1) goto ccfvU; else goto ccfvV;
       ccfvU: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfvV: // global
           I64[Sp] = block_ccfw5_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfw5() //  [R1]
         { info_tbl: [(ccfw5,
                       label: block_ccfw5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfw5: // global
           if (R1 & 7 == 1) goto ccfwc; else goto ccfwg;
       ccfwc: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfwg: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfwu_srtd" {
     ucfwu_srtd:
         const SccKB_srt+192;
         const 86;
         const 9295429630892703745;
         const 2097152;
 },
 Text.Printf.formatInteger_entry() //  [R2, R3]
         { info_tbl: [(ccfwj,
                       label: Text.Printf.formatInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfwj: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfwk; else goto ccfwl;
       ccfwk: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfwl: // global
           I64[Sp - 16] = block_ccfvC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfwr; else goto ccfvD;
       ucfwr: // global
           call _ccfvC(R1) args: 0, res: 0, upd: 0;
       ccfvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfwv_srtd" {
     ucfwv_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccfvC() //  [R1]
         { info_tbl: [(ccfvC,
                       label: block_ccfvC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfvC: // global
           I64[Sp - 48] = block_ccfvH_info;
           _sccx5::P64 = P64[R1 + 7];
           _sccx6::P64 = P64[R1 + 15];
           _sccx7::P64 = P64[R1 + 23];
           _sccx8::P64 = P64[R1 + 31];
           _sccx9::P64 = P64[R1 + 39];
           _sccxa::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccx6::P64;
           P64[Sp - 32] = _sccx7::P64;
           P64[Sp - 24] = _sccx8::P64;
           P64[Sp - 16] = _sccx9::P64;
           P64[Sp - 8] = _sccxa::P64;
           P64[Sp] = _sccx5::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfwq; else goto ccfvI;
       ucfwq: // global
           call _ccfvH(R1) args: 0, res: 0, upd: 0;
       ccfvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfww_srtd" {
     ucfww_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccfvH() //  [R1]
         { info_tbl: [(ccfvH,
                       label: block_ccfvH_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfvH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfwp; else goto ccfwo;
       ccfwp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfwo: // global
           _sccxd::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sccxj_info;
           _sccxa::P64 = P64[Sp + 40];
           P64[Hp] = _sccxa::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 56];
           R2 = Hp - 16;
           _sccx9::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccx9::P64;
           P64[Sp + 48] = _sccxa::P64;
           I64[Sp + 56] = _sccxd::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.664387109 UTC

[section ""data" . Text.Printf.$fPrintfArgNatural_$cformatArg_closure" {
     Text.Printf.$fPrintfArgNatural_$cformatArg_closure:
         const Text.Printf.$fPrintfArgNatural_$cformatArg_info;
         const 0;
 },
 section ""relreadonly" . ucfxr_srtd" {
     ucfxr_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sccxB_entry() //  [R1]
         { info_tbl: [(ccfwW,
                       label: sat_sccxB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfwW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfwX; else goto ccfwY;
       ccfwX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfwY: // global
           I64[Sp - 8] = block_ccfwP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfxh; else goto ccfwQ;
       ucfxh: // global
           call _ccfwP(R1) args: 0, res: 0, upd: 0;
       ccfwQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfxs_srtd" {
     ucfxs_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _ccfwP() //  [R1]
         { info_tbl: [(ccfwP,
                       label: block_ccfwP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfwP: // global
           if (R1 & 7 == 1) goto ccfwT; else goto ccfwU;
       ccfwT: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfwU: // global
           I64[Sp] = block_ccfx4_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfx4() //  [R1]
         { info_tbl: [(ccfx4,
                       label: block_ccfx4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfx4: // global
           if (R1 & 7 == 1) goto ccfxb; else goto ccfxf;
       ccfxb: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfxf: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucfxt_srtd" {
     ucfxt_srtd:
         const SccKB_srt+192;
         const 87;
         const 9295429630892703745;
         const 4194304;
 },
 Text.Printf.$fPrintfArgNatural_$cformatArg_entry() //  [R2, R3]
         { info_tbl: [(ccfxi,
                       label: Text.Printf.$fPrintfArgNatural_$cformatArg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfxi: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccfxj; else goto ccfxk;
       ccfxj: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgNatural_$cformatArg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfxk: // global
           I64[Sp - 16] = block_ccfwB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfxq; else goto ccfwC;
       ucfxq: // global
           call _ccfwB(R1) args: 0, res: 0, upd: 0;
       ccfwC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfxu_srtd" {
     ucfxu_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccfwB() //  [R1]
         { info_tbl: [(ccfwB,
                       label: block_ccfwB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfwB: // global
           I64[Sp - 48] = block_ccfwG_info;
           _sccxn::P64 = P64[R1 + 7];
           _sccxo::P64 = P64[R1 + 15];
           _sccxp::P64 = P64[R1 + 23];
           _sccxq::P64 = P64[R1 + 31];
           _sccxr::P64 = P64[R1 + 39];
           _sccxs::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccxo::P64;
           P64[Sp - 32] = _sccxp::P64;
           P64[Sp - 24] = _sccxq::P64;
           P64[Sp - 16] = _sccxr::P64;
           P64[Sp - 8] = _sccxs::P64;
           P64[Sp] = _sccxn::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucfxp; else goto ccfwH;
       ucfxp: // global
           call _ccfwG(R1) args: 0, res: 0, upd: 0;
       ccfwH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfxv_srtd" {
     ucfxv_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccfwG() //  [R1]
         { info_tbl: [(ccfwG,
                       label: block_ccfwG_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfwG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfxo; else goto ccfxn;
       ccfxo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfxn: // global
           _sccxv::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sccxB_info;
           _sccxs::P64 = P64[Sp + 40];
           P64[Hp] = _sccxs::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 56];
           R2 = Hp - 16;
           _sccxr::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccxr::P64;
           P64[Sp + 48] = _sccxs::P64;
           I64[Sp + 56] = _sccxv::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.667000875 UTC

[section ""data" . Text.Printf.$fPrintfArgNatural_closure" {
     Text.Printf.$fPrintfArgNatural_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgNatural_$cformatArg_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.667547287 UTC

[section ""data" . Text.Printf.$fPrintfArgInteger_closure" {
     Text.Printf.$fPrintfArgInteger_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.formatInteger_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.668395298 UTC

[section ""data" . lvl42_rcccH_closure" {
     lvl42_rcccH_closure:
         const lvl42_rcccH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rcccH_entry() //  [R1]
         { info_tbl: [(ccfxC,
                       label: lvl42_rcccH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfxC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfxD; else goto ccfxE;
       ccfxD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfxE: // global
           (_ccfxz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccfxz::I64 == 0) goto ccfxB; else goto ccfxA;
       ccfxB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccfxA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccfxz::I64;
           R4 = Text.Read.readEither7_closure+1;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadInt2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.669406909 UTC

[section ""data" . lvl43_rcccI_closure" {
     lvl43_rcccI_closure:
         const Text.Printf.FieldFormat_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Types.False_closure+1;
         const GHC.Types.[]_closure+1;
         const lvl23_rccco_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.670227643 UTC

[section ""data" . lvl44_rcccJ_closure" {
     lvl44_rcccJ_closure:
         const lvl44_rcccJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rcccJ_entry() //  [R1]
         { info_tbl: [(ccfxL,
                       label: lvl44_rcccJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfxL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfxM; else goto ccfxN;
       ccfxM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfxN: // global
           (_ccfxI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccfxI::I64 == 0) goto ccfxK; else goto ccfxJ;
       ccfxK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccfxJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccfxI::I64;
           R2 = Text.Read.readEither5_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.671331126 UTC

[section ""data" . lvl45_rcccK_closure" {
     lvl45_rcccK_closure:
         const lvl45_rcccK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl45_rcccK_entry() //  [R1]
         { info_tbl: [(ccfxU,
                       label: lvl45_rcccK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfxU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfxV; else goto ccfxW;
       ccfxV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfxW: // global
           (_ccfxR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccfxR::I64 == 0) goto ccfxT; else goto ccfxS;
       ccfxT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccfxS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccfxR::I64;
           R2 = Text.Read.readEither2_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.673527225 UTC

[section ""data" . $wgetStar_rcccL_closure" {
     $wgetStar_rcccL_closure:
         const $wgetStar_rcccL_info;
         const 0;
 },
 sat_sccxK_entry() //  [R1]
         { info_tbl: [(ccfyk,
                       label: sat_sccxK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfyk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfyl; else goto ccfym;
       ccfyl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfym: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Types.[]_closure+1;
           R2 = lvl43_rcccI_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccxS_entry() //  [R1]
         { info_tbl: [(ccfyp,
                       label: sat_sccxS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfyp: // global
           _sccxS::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto ccfyq; else goto ccfyr;
       ccfyr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfyt; else goto ccfys;
       ccfyt: // global
           HpAlloc = 24;
           goto ccfyq;
       ccfyq: // global
           R1 = _sccxS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfys: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccxS::P64;
           _sccxJ::P64 = P64[_sccxS::P64 + 16];
           I64[Hp - 16] = sat_sccxK_info;
           P64[Hp] = _sccxJ::P64;
           I64[Sp - 24] = block_ccfyn_info;
           R3 = Hp - 16;
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfyn() //  [R1]
         { info_tbl: [(ccfyn,
                       label: block_ccfyn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfyn: // global
           I64[Sp] = block_ccfyw_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfyw() //  [R1]
         { info_tbl: [(ccfyw,
                       label: block_ccfyw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfyw: // global
           if (R1 & 7 == 1) goto ccfyD; else goto ccfyI;
       ccfyD: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfyI: // global
           I64[Sp - 8] = block_ccfyG_info;
           _sccxN::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccxN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfyW; else goto ccfyJ;
       ucfyW: // global
           call _ccfyG(R1) args: 0, res: 0, upd: 0;
       ccfyJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfyG() //  [R1]
         { info_tbl: [(ccfyG,
                       label: block_ccfyG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfyG: // global
           if (R1 & 7 == 1) goto ccfyP; else goto ccfyT;
       ccfyP: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfyT: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgetStar_rcccL_entry() //  [R2]
         { info_tbl: [(ccfz1,
                       label: $wgetStar_rcccL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfz1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfz2; else goto ccfz3;
       ccfz2: // global
           R2 = R2;
           R1 = $wgetStar_rcccL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccfz3: // global
           I64[Sp - 8] = block_ccfy1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfzb; else goto ccfy2;
       ucfzb: // global
           call _ccfy1(R1) args: 0, res: 0, upd: 0;
       ccfy2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfy1() //  [R1]
         { info_tbl: [(ccfy1,
                       label: block_ccfy1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfy1: // global
           if (R1 & 7 == 1) goto ccfyY; else goto ccfyZ;
       ccfyY: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccfyZ: // global
           I64[Sp - 8] = block_ccfy7_info;
           _sccxG::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccxG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfza; else goto ccfy8;
       ucfza: // global
           call _ccfy7(R1) args: 0, res: 0, upd: 0;
       ccfy8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfy7() //  [R1]
         { info_tbl: [(ccfy7,
                       label: block_ccfy7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfy7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfz9; else goto ccfz8;
       ccfz9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfz8: // global
           _sccxJ::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sccxS_info;
           P64[Hp] = _sccxJ::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.676083763 UTC

[section ""data" . lvl46_rcccM_closure" {
     lvl46_rcccM_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.676651316 UTC

[section ""data" . lvl47_rcccN_closure" {
     lvl47_rcccN_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.LeftAdjust_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.67722107 UTC

[section ""data" . lvl48_rcccO_closure" {
     lvl48_rcccO_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.ZeroPad_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.678742093 UTC

[section ""data" . lvl49_rcccP_closure" {
     lvl49_rcccP_closure:
         const lvl49_rcccP_info;
         const 0;
         const 0;
         const 0;
 },
 sat_sccy6_entry() //  [R1]
         { info_tbl: [(ccfzw,
                       label: sat_sccy6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfzw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfzx; else goto ccfzy;
       ccfzx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfzy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfzu_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfzu() //  [R1]
         { info_tbl: [(ccfzu,
                       label: block_ccfzu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfzu: // global
           I64[Sp] = block_ccfzB_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfzB() //  [R1]
         { info_tbl: [(ccfzB,
                       label: block_ccfzB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfzB: // global
           if (R1 & 7 == 1) goto ccfzI; else goto ccfzN;
       ccfzI: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfzN: // global
           I64[Sp - 8] = block_ccfzL_info;
           _sccy1::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccy1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfA1; else goto ccfzO;
       ucfA1: // global
           call _ccfzL(R1) args: 0, res: 0, upd: 0;
       ccfzO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfzL() //  [R1]
         { info_tbl: [(ccfzL,
                       label: block_ccfzL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfzL: // global
           if (R1 & 7 == 1) goto ccfzU; else goto ccfzY;
       ccfzU: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfzY: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl49_rcccP_entry() //  [R1]
         { info_tbl: [(ccfA6,
                       label: lvl49_rcccP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfA6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfA7; else goto ccfA8;
       ccfA7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfA8: // global
           (_ccfzf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccfzf::I64 == 0) goto ccfzh; else goto ccfzg;
       ccfzh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccfzg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccfzf::I64;
           I64[Sp - 24] = block_ccfzi_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfzi() //  [R1, R2]
         { info_tbl: [(ccfzi,
                       label: block_ccfzi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfzi: // global
           I64[Sp - 8] = block_ccfzk_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfAj; else goto ccfzl;
       ucfAj: // global
           call _ccfzk(R1) args: 0, res: 0, upd: 0;
       ccfzl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfzk() //  [R1]
         { info_tbl: [(ccfzk,
                       label: block_ccfzk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfzk: // global
           _sccxV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccfA3; else goto ccfA4;
       ccfA3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfAe; else goto ccfAd;
       ccfAe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfAd: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sccxV::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfA4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfAi; else goto ccfAh;
       ccfAi: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfAh: // global
           I64[Hp - 40] = sat_sccy6_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sccxV::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.681153195 UTC

[section ""data" . lvl50_rcccQ_closure" {
     lvl50_rcccQ_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.SignPlus_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.682110199 UTC

[section ""data" . lvl51_rcccR_closure" {
     lvl51_rcccR_closure:
         const lvl51_rcccR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl51_rcccR_entry() //  [R1]
         { info_tbl: [(ccfAt,
                       label: lvl51_rcccR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfAt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfAu; else goto ccfAv;
       ccfAu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfAv: // global
           (_ccfAn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccfAn::I64 == 0) goto ccfAp; else goto ccfAo;
       ccfAp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccfAo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccfAn::I64;
           I64[Sp - 24] = block_ccfAq_info;
           R1 = lvl49_rcccP_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfAz; else goto ccfAr;
       ucfAz: // global
           call _ccfAq(R1) args: 0, res: 0, upd: 0;
       ccfAr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfAq() //  [R1]
         { info_tbl: [(ccfAq,
                       label: block_ccfAq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfAq: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.683276204 UTC

[section ""data" . lvl52_rcccS_closure" {
     lvl52_rcccS_closure:
         const GHC.Base.Just_con_info;
         const lvl51_rcccR_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.684150698 UTC

[section ""data" . lvl53_rcccT_closure" {
     lvl53_rcccT_closure:
         const lvl53_rcccT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl53_rcccT_entry() //  [R1]
         { info_tbl: [(ccfAJ,
                       label: lvl53_rcccT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfAJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfAK; else goto ccfAL;
       ccfAK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfAL: // global
           (_ccfAD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccfAD::I64 == 0) goto ccfAF; else goto ccfAE;
       ccfAF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccfAE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccfAD::I64;
           I64[Sp - 24] = block_ccfAG_info;
           R1 = lvl49_rcccP_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfAP; else goto ccfAH;
       ucfAP: // global
           call _ccfAG(R1) args: 0, res: 0, upd: 0;
       ccfAH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfAG() //  [R1]
         { info_tbl: [(ccfAG,
                       label: block_ccfAG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfAG: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.685215518 UTC

[section ""data" . lvl54_rcccU_closure" {
     lvl54_rcccU_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.SignSpace_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.698731452 UTC

[section ""data" . $wgetSpecs_rcccV_closure" {
     $wgetSpecs_rcccV_closure:
         const $wgetSpecs_rcccV_info;
         const 0;
 },
 ds3_sccyu_entry() //  [R1]
         { info_tbl: [(ccfBw,
                       label: ds3_sccyu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfBw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfBx; else goto ccfBy;
       ccfBx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfBy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccfBp_info;
           _sccyj::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccyj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucfBM; else goto ccfBq;
       ucfBM: // global
           call _ccfBp(R1) args: 0, res: 0, upd: 0;
       ccfBq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfBp() //  [R1]
         { info_tbl: [(ccfBp,
                       label: block_ccfBp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfBp: // global
           if (R1 & 7 == 1) goto ccfBt; else goto ccfBu;
       ccfBt: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccfBu: // global
           I64[Sp] = block_ccfBE_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucfBL; else goto ccfBG;
       ucfBL: // global
           call _ccfBE(R1) args: 0, res: 0, upd: 0;
       ccfBG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfBE() //  [R1]
         { info_tbl: [(ccfBE,
                       label: block_ccfBE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfBE: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccyD_entry() //  [R1]
         { info_tbl: [(ccfC1,
                       label: sat_sccyD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfC1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfC2; else goto ccfC3;
       ccfC2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfC3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccfBU_info;
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucfCo; else goto ccfBV;
       ucfCo: // global
           call _ccfBU(R1) args: 0, res: 0, upd: 0;
       ccfBV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfBU() //  [R1]
         { info_tbl: [(ccfBU,
                       label: block_ccfBU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfBU: // global
           if (R1 & 7 == 1) goto ccfBY; else goto ccfBZ;
       ccfBY: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccfC6_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucfCn; else goto ccfC8;
       ucfCn: // global
           call _ccfC6(R1) args: 0, res: 0, upd: 0;
       ccfC8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccfBZ: // global
           R1 = lvl47_rcccN_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccfC6() //  [R1]
         { info_tbl: [(ccfC6,
                       label: block_ccfC6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfC6: // global
           if (R1 & 7 == 1) goto ccfCe; else goto ccfCi;
       ccfCe: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfCi: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccz8_entry() //  [R1]
         { info_tbl: [(ccfCI,
                       label: sat_sccz8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfCI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfCJ; else goto ccfCK;
       ccfCJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfCK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfCG_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfCG() //  [R1]
         { info_tbl: [(ccfCG,
                       label: block_ccfCG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfCG: // global
           I64[Sp] = block_ccfCN_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfCN() //  [R1]
         { info_tbl: [(ccfCN,
                       label: block_ccfCN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfCN: // global
           if (R1 & 7 == 1) goto ccfCU; else goto ccfCZ;
       ccfCU: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfCZ: // global
           I64[Sp - 8] = block_ccfCX_info;
           _sccz3::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccz3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfDd; else goto ccfD0;
       ucfDd: // global
           call _ccfCX(R1) args: 0, res: 0, upd: 0;
       ccfD0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfCX() //  [R1]
         { info_tbl: [(ccfCX,
                       label: block_ccfCX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfCX: // global
           if (R1 & 7 == 1) goto ccfD6; else goto ccfDa;
       ccfD6: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfDa: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sccyU_entry() //  [R1]
         { info_tbl: [(ccfDi,
                       label: ds3_sccyU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfDi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfDj; else goto ccfDk;
       ccfDj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfDk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfCu_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfCu() //  [R1, R2]
         { info_tbl: [(ccfCu,
                       label: block_ccfCu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfCu: // global
           I64[Sp - 8] = block_ccfCw_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfDv; else goto ccfCx;
       ucfDv: // global
           call _ccfCw(R1) args: 0, res: 0, upd: 0;
       ccfCx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfCw() //  [R1]
         { info_tbl: [(ccfCw,
                       label: block_ccfCw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfCw: // global
           _sccyX::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccfDf; else goto ccfDg;
       ccfDf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfDq; else goto ccfDp;
       ccfDq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfDp: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sccyX::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfDg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfDu; else goto ccfDt;
       ccfDu: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfDt: // global
           I64[Hp - 40] = sat_sccz8_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sccyX::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scczD_entry() //  [R1]
         { info_tbl: [(ccfEo,
                       label: sat_scczD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfEo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfEp; else goto ccfEq;
       ccfEp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfEq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfEm_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfEm() //  [R1]
         { info_tbl: [(ccfEm,
                       label: block_ccfEm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfEm: // global
           I64[Sp] = block_ccfEt_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfEt() //  [R1]
         { info_tbl: [(ccfEt,
                       label: block_ccfEt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfEt: // global
           if (R1 & 7 == 1) goto ccfEA; else goto ccfEF;
       ccfEA: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfEF: // global
           I64[Sp - 8] = block_ccfED_info;
           _scczy::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _scczy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfET; else goto ccfEG;
       ucfET: // global
           call _ccfED(R1) args: 0, res: 0, upd: 0;
       ccfEG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfED() //  [R1]
         { info_tbl: [(ccfED,
                       label: block_ccfED_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfED: // global
           if (R1 & 7 == 1) goto ccfEM; else goto ccfEQ;
       ccfEM: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfEQ: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_scczp_entry() //  [R1]
         { info_tbl: [(ccfEY,
                       label: ds12_scczp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfEY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfEZ; else goto ccfF0;
       ccfEZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfF0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfEa_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfEa() //  [R1, R2]
         { info_tbl: [(ccfEa,
                       label: block_ccfEa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfEa: // global
           I64[Sp - 8] = block_ccfEc_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfFb; else goto ccfEd;
       ucfFb: // global
           call _ccfEc(R1) args: 0, res: 0, upd: 0;
       ccfEd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfEc() //  [R1]
         { info_tbl: [(ccfEc,
                       label: block_ccfEc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfEc: // global
           _scczs::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccfEV; else goto ccfEW;
       ccfEV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfF6; else goto ccfF5;
       ccfF6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfF5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _scczs::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfEW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfFa; else goto ccfF9;
       ccfFa: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfF9: // global
           I64[Hp - 40] = sat_scczD_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _scczs::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_scczN_entry() //  [R1]
         { info_tbl: [(ccfFk,
                       label: ds12_scczN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfFk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfFl; else goto ccfFm;
       ccfFl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfFm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfFh_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfFh() //  [R1, R2]
         { info_tbl: [(ccfFh,
                       label: block_ccfFh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfFh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfFp; else goto ccfFo;
       ccfFp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccfFo: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sccz9_entry() //  [R1]
         { info_tbl: [(ccfFq,
                       label: ds4_sccz9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfFq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccfFr; else goto ccfFs;
       ccfFr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfFs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccfDA_info;
           _sccyi::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sccyi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucfGd; else goto ccfDB;
       ucfGd: // global
           call _ccfDA(R1) args: 0, res: 0, upd: 0;
       ccfDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfDA() //  [R1]
         { info_tbl: [(ccfDA,
                       label: block_ccfDA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfDA: // global
           I64[Sp] = block_ccfDF_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ucfG9; else goto ccfDG;
       ucfG9: // global
           call _ccfDF(R1) args: 0, res: 0, upd: 0;
       ccfDG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfDF() //  [R1]
         { info_tbl: [(ccfDF,
                       label: block_ccfDF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfDF: // global
           if (R1 & 7 == 1) goto ccfFx; else goto ccfFC;
       ccfFx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccfFA; else goto ccfFz;
       ccfFA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfFz: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfFC: // global
           I64[Sp - 16] = block_ccfDL_info;
           _scczd::P64 = R1;
           _scczf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scczf::P64;
           P64[Sp] = _scczd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfGa; else goto ccfDM;
       ucfGa: // global
           call _ccfDL(R1) args: 0, res: 0, upd: 0;
       ccfDM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfDL() //  [R1]
         { info_tbl: [(ccfDL,
                       label: block_ccfDL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfDL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccfFF; else goto ccfFE;
       ccfFF: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfFE: // global
           if (I64[R1 + 7] == 46) goto ccfFJ; else goto ccfFI;
       ccfFJ: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_ccfDT_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ucfGb; else goto ccfDU;
       ucfGb: // global
           call _ccfDT(R1) args: 0, res: 0, upd: 0;
       ccfDU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccfFI: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccfDT() //  [R1]
         { info_tbl: [(ccfDT,
                       label: block_ccfDT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfDT: // global
           if (R1 & 7 == 1) goto ccfFN; else goto ccfFS;
       ccfFN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccfFQ; else goto ccfFP;
       ccfFQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfFP: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl52_rcccS_closure+2;
           P64[Hp - 8] = lvl53_rcccT_closure;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfFS: // global
           I64[Sp - 16] = block_ccfDZ_info;
           _scczj::P64 = R1;
           _scczl::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scczl::P64;
           P64[Sp] = _scczj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfGc; else goto ccfE0;
       ucfGc: // global
           call _ccfDZ(R1) args: 0, res: 0, upd: 0;
       ccfE0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfDZ() //  [R1]
         { info_tbl: [(ccfDZ,
                       label: block_ccfDZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfDZ: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccfFV; else goto ccfFU;
       ccfFV: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfFU: // global
           _sccyi::P64 = P64[Sp + 24];
           if (I64[R1 + 7] == 42) goto ccfG6; else goto ccfG1;
       ccfG6: // global
           I64[Hp - 112] = ds12_scczN_info;
           P64[Hp - 96] = _sccyi::P64;
           I64[Hp - 88] = stg_sel_0_upd_info;
           _ccfFd::P64 = Hp - 112;
           P64[Hp - 72] = _ccfFd::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _ccfFd::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 88;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfG1: // global
           I64[Hp - 112] = ds12_scczp_info;
           P64[Hp - 96] = P64[Sp + 16];
           I64[Hp - 88] = stg_sel_1_upd_info;
           _ccfE6::P64 = Hp - 112;
           P64[Hp - 72] = _ccfE6::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _ccfE6::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = _sccyi::P64;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds5_sccA0_entry() //  [R1]
         { info_tbl: [(ccfGl,
                       label: ds5_sccA0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfGl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfGm; else goto ccfGn;
       ccfGm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfGn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfGi_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfGL; else goto ccfGj;
       ucfGL: // global
           call _ccfGi(R1) args: 0, res: 0, upd: 0;
       ccfGj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfGi() //  [R1]
         { info_tbl: [(ccfGi,
                       label: block_ccfGi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfGi: // global
           I64[Sp - 8] = block_ccfGq_info;
           _sccA3::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sccA3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfGK; else goto ccfGs;
       ucfGK: // global
           call _ccfGq(R1) args: 0, res: 0, upd: 0;
       ccfGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfGq() //  [R1]
         { info_tbl: [(ccfGq,
                       label: block_ccfGq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfGq: // global
           if (R1 & 7 == 1) goto ccfGy; else goto ccfGD;
       ccfGy: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccfGD: // global
           I64[Sp] = block_ccfGB_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucfGM; else goto ccfGE;
       ucfGM: // global
           call _ccfGB(R1) args: 0, res: 0, upd: 0;
       ccfGE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfGB() //  [R1]
         { info_tbl: [(ccfGB,
                       label: block_ccfGB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfGB: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccAx_entry() //  [R1]
         { info_tbl: [(ccfGY,
                       label: sat_sccAx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfGY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccfH2; else goto ccfH3;
       ccfH2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfH3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccfGV_info;
           _sccyd::P64 = P64[R1 + 16];
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sccyd::P64;
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucfHJ; else goto ccfGW;
       ucfHJ: // global
           call _ccfGV(R1) args: 0, res: 0, upd: 0;
       ccfGW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfGV() //  [R1]
         { info_tbl: [(ccfGV,
                       label: block_ccfGV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfGV: // global
           I64[Sp] = block_ccfH1_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto ucfHI; else goto ccfH5;
       ucfHI: // global
           call _ccfH1(R1) args: 0, res: 0, upd: 0;
       ccfH5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfH1() //  [R1]
         { info_tbl: [(ccfH1,
                       label: block_ccfH1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfH1: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto ccfHf; else goto ucfHG;
       ccfHf: // global
           _sccyd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccfHd_info;
           R1 = _sccyd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucfHK; else goto ccfHg;
       ucfHK: // global
           call _ccfHd(R1) args: 0, res: 0, upd: 0;
       ccfHg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ucfHG: // global
           Sp = Sp + 24;
           call _ccfHD() args: 0, res: 0, upd: 0;
     }
 },
 _ccfHd() //  [R1]
         { info_tbl: [(ccfHd,
                       label: block_ccfHd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfHd: // global
           if (R1 & 7 == 1) goto ccfHn; else goto ucfHH;
       ccfHn: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccfHk_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucfHM; else goto ccfHo;
       ucfHM: // global
           call _ccfHk(R1) args: 0, res: 0, upd: 0;
       ccfHo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ucfHH: // global
           Sp = Sp + 16;
           call _ccfHD() args: 0, res: 0, upd: 0;
     }
 },
 _ccfHk() //  [R1]
         { info_tbl: [(ccfHk,
                       label: block_ccfHk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfHk: // global
           if (R1 & 7 == 1) goto ccfHu; else goto ccfHy;
       ccfHu: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfHy: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccfHD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfHD: // global
           R1 = lvl47_rcccN_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccAi_entry() //  [R1]
         { info_tbl: [(ccfHW,
                       label: sat_sccAi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfHW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfI0; else goto ccfI1;
       ccfI0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfI1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfHT_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfIl; else goto ccfHU;
       ucfIl: // global
           call _ccfHT(R1) args: 0, res: 0, upd: 0;
       ccfHU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfHT() //  [R1]
         { info_tbl: [(ccfHT,
                       label: block_ccfHT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfHT: // global
           I64[Sp] = block_ccfHZ_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto ucfIk; else goto ccfI3;
       ucfIk: // global
           call _ccfHZ(R1) args: 0, res: 0, upd: 0;
       ccfI3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfHZ() //  [R1]
         { info_tbl: [(ccfHZ,
                       label: block_ccfHZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfHZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccfI9; else goto ccfI8;
       ccfI9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfI8: // global
           _sccAf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sccAf::I64, 0)) goto ccfIi; else goto ccfIj;
       ccfIi: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_sccAf::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfIj: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccAW_entry() //  [R1]
         { info_tbl: [(ccfIw,
                       label: sat_sccAW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfIw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfIx; else goto ccfIy;
       ccfIx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfIy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfIp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfIW; else goto ccfIq;
       ucfIW: // global
           call _ccfIp(R1) args: 0, res: 0, upd: 0;
       ccfIq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfIp() //  [R1]
         { info_tbl: [(ccfIp,
                       label: block_ccfIp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfIp: // global
           if (R1 & 7 == 1) goto ucfIS; else goto ccfIu;
       ucfIS: // global
           Sp = Sp + 8;
           call _ccfIQ() args: 0, res: 0, upd: 0;
       ccfIu: // global
           I64[Sp] = block_ccfIE_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucfIU; else goto ccfIG;
       ucfIU: // global
           call _ccfIE(R1) args: 0, res: 0, upd: 0;
       ccfIG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfIE() //  [R1]
         { info_tbl: [(ccfIE,
                       label: block_ccfIE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfIE: // global
           if (R1 & 7 == 1) goto ccfIM; else goto ucfIT;
       ccfIM: // global
           R1 = lvl50_rcccQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ucfIT: // global
           Sp = Sp + 8;
           call _ccfIQ() args: 0, res: 0, upd: 0;
     }
 },
 _ccfIQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfIQ: // global
           R1 = lvl54_rcccU_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sccAX_entry() //  [R1]
         { info_tbl: [(ccfJ7,
                       label: ds3_sccAX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfJ7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfJ8; else goto ccfJ9;
       ccfJ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfJ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfJ4_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfJ4() //  [R1, R2]
         { info_tbl: [(ccfJ4,
                       label: block_ccfJ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfJ4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfJc; else goto ccfJb;
       ccfJc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccfJb: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccBE_entry() //  [R1]
         { info_tbl: [(ccfK0,
                       label: sat_sccBE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfK0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfK1; else goto ccfK2;
       ccfK1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfK2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfJY_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfJY() //  [R1]
         { info_tbl: [(ccfJY,
                       label: block_ccfJY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfJY: // global
           I64[Sp] = block_ccfK5_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfK5() //  [R1]
         { info_tbl: [(ccfK5,
                       label: block_ccfK5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfK5: // global
           if (R1 & 7 == 1) goto ccfKc; else goto ccfKh;
       ccfKc: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfKh: // global
           I64[Sp - 8] = block_ccfKf_info;
           _sccBz::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccBz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfKv; else goto ccfKi;
       ucfKv: // global
           call _ccfKf(R1) args: 0, res: 0, upd: 0;
       ccfKi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfKf() //  [R1]
         { info_tbl: [(ccfKf,
                       label: block_ccfKf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfKf: // global
           if (R1 & 7 == 1) goto ccfKo; else goto ccfKs;
       ccfKo: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfKs: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_sccBq_entry() //  [R1]
         { info_tbl: [(ccfKA,
                       label: ds12_sccBq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfKA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfKB; else goto ccfKC;
       ccfKB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfKC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfJM_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfJM() //  [R1, R2]
         { info_tbl: [(ccfJM,
                       label: block_ccfJM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfJM: // global
           I64[Sp - 8] = block_ccfJO_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfKN; else goto ccfJP;
       ucfKN: // global
           call _ccfJO(R1) args: 0, res: 0, upd: 0;
       ccfJP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfJO() //  [R1]
         { info_tbl: [(ccfJO,
                       label: block_ccfJO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfJO: // global
           _sccBt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccfKx; else goto ccfKy;
       ccfKx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfKI; else goto ccfKH;
       ccfKI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfKH: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sccBt::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfKy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccfKM; else goto ccfKL;
       ccfKM: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfKL: // global
           I64[Hp - 40] = sat_sccBE_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sccBt::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_sccBS_entry() //  [R1]
         { info_tbl: [(ccfKW,
                       label: ds12_sccBS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfKW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfL2; else goto ccfL3;
       ccfL2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfL3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfKT_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfL8; else goto ccfKU;
       ucfL8: // global
           call _ccfKT(R1) args: 0, res: 0, upd: 0;
       ccfKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfKT() //  [R1]
         { info_tbl: [(ccfKT,
                       label: block_ccfKT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfKT: // global
           I64[Sp] = block_ccfKZ_info;
           R2 = P64[R1 + 7];
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfKZ() //  [R1, R2]
         { info_tbl: [(ccfKZ,
                       label: block_ccfKZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfKZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfL7; else goto ccfL6;
       ccfL7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccfL6: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sccB1_entry() //  [R1]
         { info_tbl: [(ccfLd,
                       label: ds4_sccB1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfLd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccfLe; else goto ccfLf;
       ccfLe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfLf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccfJh_info;
           _sccAX::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccAX::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucfLY; else goto ccfJi;
       ucfLY: // global
           call _ccfJh(R1) args: 0, res: 0, upd: 0;
       ccfJi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfJh() //  [R1]
         { info_tbl: [(ccfJh,
                       label: block_ccfJh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfJh: // global
           if (R1 & 7 == 1) goto ccfLa; else goto ccfLb;
       ccfLa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccfLl; else goto ccfLk;
       ccfLl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfLk: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfLb: // global
           I64[Sp - 16] = block_ccfJn_info;
           _sccB2::P64 = R1;
           _sccB8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccB8::P64;
           P64[Sp] = _sccB2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfLV; else goto ccfJo;
       ucfLV: // global
           call _ccfJn(R1) args: 0, res: 0, upd: 0;
       ccfJo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfJn() //  [R1]
         { info_tbl: [(ccfJn,
                       label: block_ccfJn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfJn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccfLp; else goto ccfLo;
       ccfLp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfLo: // global
           if (I64[R1 + 7] == 46) goto ccfLu; else goto ccfLt;
       ccfLu: // global
           Hp = Hp - 56;
           I64[Sp + 16] = block_ccfJv_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ucfLW; else goto ccfJw;
       ucfLW: // global
           call _ccfJv(R1) args: 0, res: 0, upd: 0;
       ccfJw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccfLt: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccfJv() //  [R1]
         { info_tbl: [(ccfJv,
                       label: block_ccfJv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfJv: // global
           if (R1 & 7 == 1) goto ccfLz; else goto ccfLE;
       ccfLz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccfLC; else goto ccfLB;
       ccfLC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfLB: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl52_rcccS_closure+2;
           P64[Hp - 8] = lvl53_rcccT_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfLE: // global
           I64[Sp - 16] = block_ccfJB_info;
           _sccBg::P64 = R1;
           _sccBm::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccBm::P64;
           P64[Sp] = _sccBg::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfLX; else goto ccfJC;
       ucfLX: // global
           call _ccfJB(R1) args: 0, res: 0, upd: 0;
       ccfJC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfJB() //  [R1]
         { info_tbl: [(ccfJB,
                       label: block_ccfJB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfJB: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccfLH; else goto ccfLG;
       ccfLH: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfLG: // global
           _sccAX::P64 = P64[Sp + 24];
           if (I64[R1 + 7] == 42) goto ccfLT; else goto ccfLO;
       ccfLT: // global
           I64[Hp - 136] = ds12_sccBS_info;
           P64[Hp - 120] = _sccAX::P64;
           I64[Hp - 112] = stg_sel_0_upd_info;
           _ccfKP::P64 = Hp - 136;
           P64[Hp - 96] = _ccfKP::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _ccfKP::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = Hp - 88;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = Hp - 112;
           _ccfLS::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _ccfLS::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfLO: // global
           I64[Hp - 136] = ds12_sccBq_info;
           P64[Hp - 120] = P64[Sp + 16];
           I64[Hp - 112] = stg_sel_0_upd_info;
           P64[Hp - 96] = _sccAX::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           _ccfJI::P64 = Hp - 136;
           P64[Hp - 72] = _ccfJI::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _ccfJI::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 112;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds5_sccC8_entry() //  [R1]
         { info_tbl: [(ccfM6,
                       label: ds5_sccC8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfM6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfM7; else goto ccfM8;
       ccfM7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfM8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfM3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfMw; else goto ccfM4;
       ucfMw: // global
           call _ccfM3(R1) args: 0, res: 0, upd: 0;
       ccfM4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfM3() //  [R1]
         { info_tbl: [(ccfM3,
                       label: block_ccfM3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfM3: // global
           I64[Sp - 8] = block_ccfMb_info;
           _sccCb::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sccCb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfMv; else goto ccfMd;
       ucfMv: // global
           call _ccfMb(R1) args: 0, res: 0, upd: 0;
       ccfMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfMb() //  [R1]
         { info_tbl: [(ccfMb,
                       label: block_ccfMb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfMb: // global
           if (R1 & 7 == 1) goto ccfMj; else goto ccfMo;
       ccfMj: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccfMo: // global
           I64[Sp] = block_ccfMm_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucfMx; else goto ccfMp;
       ucfMx: // global
           call _ccfMm(R1) args: 0, res: 0, upd: 0;
       ccfMp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfMm() //  [R1]
         { info_tbl: [(ccfMm,
                       label: block_ccfMm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfMm: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccCF_entry() //  [R1]
         { info_tbl: [(ccfMJ,
                       label: sat_sccCF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfMJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccfMN; else goto ccfMO;
       ccfMN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfMO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccfMG_info;
           _sccyd::P64 = P64[R1 + 16];
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sccyd::P64;
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucfNu; else goto ccfMH;
       ucfNu: // global
           call _ccfMG(R1) args: 0, res: 0, upd: 0;
       ccfMH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfMG() //  [R1]
         { info_tbl: [(ccfMG,
                       label: block_ccfMG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfMG: // global
           I64[Sp] = block_ccfMM_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ucfNt; else goto ccfMQ;
       ucfNt: // global
           call _ccfMM(R1) args: 0, res: 0, upd: 0;
       ccfMQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfMM() //  [R1]
         { info_tbl: [(ccfMM,
                       label: block_ccfMM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfMM: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto ccfN0; else goto ucfNr;
       ccfN0: // global
           _sccyd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccfMY_info;
           R1 = _sccyd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucfNv; else goto ccfN1;
       ucfNv: // global
           call _ccfMY(R1) args: 0, res: 0, upd: 0;
       ccfN1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ucfNr: // global
           Sp = Sp + 24;
           call _ccfNo() args: 0, res: 0, upd: 0;
     }
 },
 _ccfMY() //  [R1]
         { info_tbl: [(ccfMY,
                       label: block_ccfMY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfMY: // global
           if (R1 & 7 == 1) goto ccfN8; else goto ucfNs;
       ccfN8: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccfN5_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucfNx; else goto ccfN9;
       ucfNx: // global
           call _ccfN5(R1) args: 0, res: 0, upd: 0;
       ccfN9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ucfNs: // global
           Sp = Sp + 16;
           call _ccfNo() args: 0, res: 0, upd: 0;
     }
 },
 _ccfN5() //  [R1]
         { info_tbl: [(ccfN5,
                       label: block_ccfN5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfN5: // global
           if (R1 & 7 == 1) goto ccfNf; else goto ccfNj;
       ccfNf: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfNj: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccfNo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfNo: // global
           R1 = lvl47_rcccN_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccCq_entry() //  [R1]
         { info_tbl: [(ccfNH,
                       label: sat_sccCq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfNH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfNL; else goto ccfNM;
       ccfNL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfNM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfNE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfO6; else goto ccfNF;
       ucfO6: // global
           call _ccfNE(R1) args: 0, res: 0, upd: 0;
       ccfNF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfNE() //  [R1]
         { info_tbl: [(ccfNE,
                       label: block_ccfNE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfNE: // global
           I64[Sp] = block_ccfNK_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ucfO5; else goto ccfNO;
       ucfO5: // global
           call _ccfNK(R1) args: 0, res: 0, upd: 0;
       ccfNO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfNK() //  [R1]
         { info_tbl: [(ccfNK,
                       label: block_ccfNK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfNK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccfNU; else goto ccfNT;
       ccfNU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfNT: // global
           _sccCn::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sccCn::I64, 0)) goto ccfO3; else goto ccfO4;
       ccfO3: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_sccCn::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfO4: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccDo_entry() //  [R1]
         { info_tbl: [(ccfOF,
                       label: sat_sccDo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfOF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfOG; else goto ccfOH;
       ccfOG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfOH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfOD_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfOD() //  [R1]
         { info_tbl: [(ccfOD,
                       label: block_ccfOD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfOD: // global
           I64[Sp] = block_ccfOK_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfOK() //  [R1]
         { info_tbl: [(ccfOK,
                       label: block_ccfOK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfOK: // global
           if (R1 & 7 == 1) goto ccfOR; else goto ccfOW;
       ccfOR: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfOW: // global
           I64[Sp - 8] = block_ccfOU_info;
           _sccDj::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccDj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfPa; else goto ccfOX;
       ucfPa: // global
           call _ccfOU(R1) args: 0, res: 0, upd: 0;
       ccfOX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfOU() //  [R1]
         { info_tbl: [(ccfOU,
                       label: block_ccfOU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfOU: // global
           if (R1 & 7 == 1) goto ccfP3; else goto ccfP7;
       ccfP3: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccfP7: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds7_sccDp_entry() //  [R1]
         { info_tbl: [(ccfPj,
                       label: ds7_sccDp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfPj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfPk; else goto ccfPl;
       ccfPk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfPl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfPg_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfPg() //  [R1, R2]
         { info_tbl: [(ccfPg,
                       label: block_ccfPg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfPg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfPo; else goto ccfPn;
       ccfPo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccfPn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sccD1_entry() //  [R1]
         { info_tbl: [(ccfPt,
                       label: ds3_sccD1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfPt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccfPu; else goto ccfPv;
       ccfPu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfPv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccfOe_info;
           _sccyi::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sccyi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucfQ8; else goto ccfOf;
       ucfQ8: // global
           call _ccfOe(R1) args: 0, res: 0, upd: 0;
       ccfOf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfOe() //  [R1]
         { info_tbl: [(ccfOe,
                       label: block_ccfOe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfOe: // global
           if (R1 & 7 == 1) goto ccfPq; else goto ccfPr;
       ccfPq: // global
           I64[Sp] = block_ccfPx_info;
           R1 = lvl49_rcccP_closure;
           if (R1 & 7 != 0) goto ucfQ5; else goto ccfPy;
       ucfQ5: // global
           call _ccfPx(R1) args: 0, res: 0, upd: 0;
       ccfPy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccfPr: // global
           I64[Sp - 16] = block_ccfOk_info;
           _sccD2::P64 = R1;
           _sccD7::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccD7::P64;
           P64[Sp] = _sccD2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfQ6; else goto ccfOl;
       ucfQ6: // global
           call _ccfOk(R1) args: 0, res: 0, upd: 0;
       ccfOl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfPx() //  [R1]
         { info_tbl: [(ccfPx,
                       label: block_ccfPx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfPx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccfPG; else goto ccfPF;
       ccfPG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfPF: // global
           _sccD4::P64 = P64[R1 + 7];
           _sccD5::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = _sccD4::P64;
           P64[Hp - 8] = _sccD5::P64;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccfOk() //  [R1]
         { info_tbl: [(ccfOk,
                       label: block_ccfOk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfOk: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccfPK; else goto ccfPJ;
       ccfPK: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfPJ: // global
           if (I64[R1 + 7] == 42) goto ccfQ3; else goto ccfPM;
       ccfQ3: // global
           I64[Hp - 96] = ds7_sccDp_info;
           P64[Hp - 80] = P64[Sp + 24];
           I64[Hp - 72] = stg_sel_0_upd_info;
           _ccfPc::P64 = Hp - 96;
           P64[Hp - 56] = _ccfPc::P64;
           I64[Hp - 48] = stg_sel_1_upd_info;
           P64[Hp - 32] = _ccfPc::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 72;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfPM: // global
           Hp = Hp - 104;
           _sccD2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccfOr_info;
           R3 = _sccD2::P64;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 16;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccfOr() //  [R1, R2]
         { info_tbl: [(ccfOr,
                       label: block_ccfOr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfOr: // global
           I64[Sp - 8] = block_ccfOt_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfQ7; else goto ccfOu;
       ucfQ7: // global
           call _ccfOt(R1) args: 0, res: 0, upd: 0;
       ccfOu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfOt() //  [R1]
         { info_tbl: [(ccfOt,
                       label: block_ccfOt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfOt: // global
           _sccyi::P64 = P64[Sp + 16];
           _sccDd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccfPR; else goto ccfPW;
       ccfPR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccfPU; else goto ccfPT;
       ccfPU: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfPT: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl46_rcccM_closure+1;
           P64[Hp - 8] = _sccDd::P64;
           P64[Hp] = _sccyi::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfPW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccfPZ; else goto ccfPY;
       ccfPZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccfPY: // global
           I64[Hp - 48] = sat_sccDo_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = _sccDd::P64;
           P64[Hp] = _sccyi::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sccDB_entry() //  [R1]
         { info_tbl: [(ccfQg,
                       label: ds4_sccDB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfQg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfQh; else goto ccfQi;
       ccfQh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfQi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccfQd_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfQG; else goto ccfQe;
       ucfQG: // global
           call _ccfQd(R1) args: 0, res: 0, upd: 0;
       ccfQe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfQd() //  [R1]
         { info_tbl: [(ccfQd,
                       label: block_ccfQd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfQd: // global
           I64[Sp - 8] = block_ccfQl_info;
           _sccDE::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sccDE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfQF; else goto ccfQn;
       ucfQF: // global
           call _ccfQl(R1) args: 0, res: 0, upd: 0;
       ccfQn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfQl() //  [R1]
         { info_tbl: [(ccfQl,
                       label: block_ccfQl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfQl: // global
           if (R1 & 7 == 1) goto ccfQt; else goto ccfQy;
       ccfQt: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccfQy: // global
           I64[Sp] = block_ccfQw_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucfQH; else goto ccfQz;
       ucfQH: // global
           call _ccfQw(R1) args: 0, res: 0, upd: 0;
       ccfQz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfQw() //  [R1]
         { info_tbl: [(ccfQw,
                       label: block_ccfQw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfQw: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccDU_entry() //  [R1]
         { info_tbl: [(ccfQX,
                       label: sat_sccDU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfQX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfQY; else goto ccfQZ;
       ccfQY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfQZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccfQQ_info;
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucfRk; else goto ccfQR;
       ucfRk: // global
           call _ccfQQ(R1) args: 0, res: 0, upd: 0;
       ccfQR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccfQQ() //  [R1]
         { info_tbl: [(ccfQQ,
                       label: block_ccfQQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfQQ: // global
           if (R1 & 7 == 1) goto ccfQU; else goto ccfQV;
       ccfQU: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccfR2_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucfRj; else goto ccfR4;
       ucfRj: // global
           call _ccfR2(R1) args: 0, res: 0, upd: 0;
       ccfR4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccfQV: // global
           R1 = lvl47_rcccN_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccfR2() //  [R1]
         { info_tbl: [(ccfR2,
                       label: block_ccfR2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfR2: // global
           if (R1 & 7 == 1) goto ccfRa; else goto ccfRe;
       ccfRa: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccfRe: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfS8_srtd" {
     ucfS8_srtd:
         const SccKB_srt+448;
         const 69;
         const 17293822569102704641;
         const 31;
 },
 $wgetSpecs_rcccV_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccfRp,
                       label: $wgetSpecs_rcccV_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfRp: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccfRq; else goto ucfRU;
       ccfRq: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wgetSpecs_rcccV_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ucfRU: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _ccfAR() args: 0, res: 0, upd: 0;
     }
 },
 _ccfAR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfAR: // global
           I64[Sp - 8] = block_ccfAU_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfS0; else goto ccfAV;
       ucfS0: // global
           call _ccfAU(R1) args: 0, res: 0, upd: 0;
       ccfAV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfS9_srtd" {
     ucfS9_srtd:
         const SccKB_srt+448;
         const 68;
         const 17293822569102704641;
         const 15;
 },
 _ccfAU() //  [R1]
         { info_tbl: [(ccfAU,
                       label: block_ccfAU_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfAU: // global
           if (R1 & 7 == 1) goto ccfRm; else goto ccfRn;
       ccfRm: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccfRn: // global
           I64[Sp - 8] = block_ccfB0_info;
           _sccyj::P64 = R1;
           _sccym::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccym::P64;
           P64[Sp + 40] = _sccyj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfS1; else goto ccfB1;
       ucfS1: // global
           call _ccfB0(R1) args: 0, res: 0, upd: 0;
       ccfB1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfSa_srtd" {
     ucfSa_srtd:
         const SccKB_srt+448;
         const 68;
         const 17293822569102704641;
         const 15;
 },
 _ccfB0() //  [R1]
         { info_tbl: [(ccfB0,
                       label: block_ccfB0_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfB0: // global
           Hp = Hp + 344;
           if (Hp > HpLim) (likely: False) goto ccfRx; else goto ccfRw;
       ccfRx: // global
           HpAlloc = 344;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfRw: // global
           _sccyd::P64 = P64[Sp + 16];
           _sccye::P64 = P64[Sp + 24];
           _sccyf::P64 = P64[Sp + 32];
           _sccyg::P64 = P64[Sp + 40];
           _sccyi::P64 = P64[Sp + 56];
           _sccyj::P64 = P64[Sp + 48];
           _sccyp::I64 = I64[R1 + 7];
           if (_sccyp::I64 >= 49) goto ccfRF; else goto ucfRS;
       ucfRS: // global
           if (_sccyp::I64 < 32) goto ccfRF; else goto ucfRT;
       ucfRT: // global
           _sccym::P64 = P64[Sp + 8];
           switch [32 .. 48] _sccyp::I64 {
               case 32 : goto ccfRG;
               case 35 : goto ccfRH;
               case 42 : goto ccfRK;
               case 43 : goto ccfRL;
               case 45 : goto ccfRM;
               case 46 : goto ccfRQ;
               case 48 : goto ccfRR;
               default: {goto ccfRF;}
           }
       ccfRR: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = GHC.Types.True_closure+2;
           P64[Sp + 32] = _sccyf::P64;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto ucfS6;
       ccfRQ: // global
           I64[Hp - 336] = ds3_sccD1_info;
           P64[Hp - 320] = _sccyi::P64;
           P64[Hp - 312] = _sccym::P64;
           I64[Hp - 304] = ds4_sccDB_info;
           _ccfOa::P64 = Hp - 336;
           P64[Hp - 288] = _ccfOa::P64;
           I64[Hp - 280] = stg_sel_2_upd_info;
           P64[Hp - 264] = _ccfOa::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           _ccfQ9::P64 = Hp - 304;
           P64[Hp - 240] = _ccfQ9::P64;
           I64[Hp - 232] = stg_sel_1_upd_info;
           P64[Hp - 216] = _ccfQ9::P64;
           I64[Hp - 208] = stg_sel_0_upd_info;
           P64[Hp - 192] = _ccfQ9::P64;
           I64[Hp - 184] = sat_sccDU_info;
           P64[Hp - 168] = _sccyd::P64;
           P64[Hp - 160] = _sccye::P64;
           I64[Hp - 152] = stg_sel_0_upd_info;
           P64[Hp - 136] = _ccfOa::P64;
           I64[Hp - 128] = GHC.Base.Just_con_info;
           P64[Hp - 120] = Hp - 152;
           I64[Hp - 112] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 104] = GHC.Base.Nothing_closure+1;
           P64[Hp - 96] = Hp - 126;
           P64[Hp - 88] = Hp - 184;
           P64[Hp - 80] = _sccyf::P64;
           P64[Hp - 72] = _sccyg::P64;
           P64[Hp - 64] = Hp - 208;
           P64[Hp - 56] = Hp - 232;
           _ccfQI::P64 = Hp - 280;
           _ccfQJ::P64 = Hp - 256;
           _ccfRP::P64 = Hp - 111;
           Hp = Hp - 56;
           R3 = _ccfQI::P64;
           R2 = _ccfQJ::P64;
           R1 = _ccfRP::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfRM: // global
           Hp = Hp - 344;
           P64[Sp + 16] = GHC.Types.True_closure+2;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = _sccyf::P64;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto ucfS6;
       ccfRL: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = lvl50_rcccQ_closure+2;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto ucfS6;
       ccfRK: // global
           I64[Hp - 336] = ds3_sccAX_info;
           P64[Hp - 320] = _sccyi::P64;
           I64[Hp - 312] = ds4_sccB1_info;
           P64[Hp - 296] = _sccym::P64;
           _ccfJ0::P64 = Hp - 336;
           P64[Hp - 288] = _ccfJ0::P64;
           I64[Hp - 280] = ds5_sccC8_info;
           _ccfJd::P64 = Hp - 312;
           P64[Hp - 264] = _ccfJd::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           P64[Hp - 240] = _ccfJd::P64;
           I64[Hp - 232] = stg_sel_2_upd_info;
           _ccfLZ::P64 = Hp - 280;
           P64[Hp - 216] = _ccfLZ::P64;
           I64[Hp - 208] = stg_sel_1_upd_info;
           P64[Hp - 192] = _ccfLZ::P64;
           I64[Hp - 184] = stg_sel_0_upd_info;
           P64[Hp - 168] = _ccfLZ::P64;
           I64[Hp - 160] = sat_sccCF_info;
           P64[Hp - 144] = _sccyd::P64;
           P64[Hp - 136] = _sccye::P64;
           P64[Hp - 128] = _ccfJ0::P64;
           I64[Hp - 120] = stg_sel_0_upd_info;
           P64[Hp - 104] = _ccfJd::P64;
           I64[Hp - 96] = sat_sccCq_info;
           P64[Hp - 80] = _ccfJ0::P64;
           I64[Hp - 72] = GHC.Base.Just_con_info;
           P64[Hp - 64] = Hp - 96;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 120;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = _sccyf::P64;
           P64[Hp - 16] = _sccyg::P64;
           P64[Hp - 8] = Hp - 184;
           P64[Hp] = Hp - 208;
           R3 = Hp - 256;
           R2 = Hp - 232;
           R1 = Hp - 55;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfRH: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = _sccyf::P64;
           P64[Sp + 40] = GHC.Types.True_closure+2;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto ucfS6;
       ccfRG: // global
           I64[Hp - 336] = sat_sccAW_info;
           P64[Hp - 320] = _sccyf::P64;
           _ccfB8::P64 = Hp - 336;
           Hp = Hp - 320;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = _ccfB8::P64;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto ucfS6;
       ucfS6: // global
           call _ccfAR() args: 0, res: 0, upd: 0;
       ccfRF: // global
           if ((_sccyp::I64 + -48) > 9) goto ccfRA; else goto ccfRD;
       ccfRA: // global
           I64[Hp - 336] = ds3_sccyu_info;
           P64[Hp - 320] = _sccyi::P64;
           P64[Hp - 312] = _sccyj::P64;
           I64[Hp - 304] = stg_sel_2_upd_info;
           _ccfBl::P64 = Hp - 336;
           P64[Hp - 288] = _ccfBl::P64;
           I64[Hp - 280] = stg_sel_1_upd_info;
           P64[Hp - 264] = _ccfBl::P64;
           I64[Hp - 256] = stg_sel_0_upd_info;
           P64[Hp - 240] = _ccfBl::P64;
           I64[Hp - 232] = sat_sccyD_info;
           P64[Hp - 216] = _sccyd::P64;
           P64[Hp - 208] = _sccye::P64;
           I64[Hp - 200] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 192] = GHC.Base.Nothing_closure+1;
           P64[Hp - 184] = GHC.Base.Nothing_closure+1;
           P64[Hp - 176] = Hp - 232;
           P64[Hp - 168] = _sccyf::P64;
           P64[Hp - 160] = _sccyg::P64;
           P64[Hp - 152] = Hp - 256;
           P64[Hp - 144] = Hp - 280;
           _ccfBN::P64 = Hp - 304;
           _ccfRy::P64 = Hp - 199;
           Hp = Hp - 144;
           R3 = _sccyi::P64;
           R2 = _ccfBN::P64;
           R1 = _ccfRy::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfRD: // global
           I64[Hp - 336] = ds3_sccyU_info;
           P64[Hp - 320] = _sccyj::P64;
           I64[Hp - 312] = ds4_sccz9_info;
           P64[Hp - 296] = _sccyi::P64;
           _ccfCq::P64 = Hp - 336;
           P64[Hp - 288] = _ccfCq::P64;
           I64[Hp - 280] = ds5_sccA0_info;
           _ccfDw::P64 = Hp - 312;
           P64[Hp - 264] = _ccfDw::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           P64[Hp - 240] = _ccfDw::P64;
           I64[Hp - 232] = stg_sel_2_upd_info;
           _ccfGe::P64 = Hp - 280;
           P64[Hp - 216] = _ccfGe::P64;
           I64[Hp - 208] = stg_sel_1_upd_info;
           P64[Hp - 192] = _ccfGe::P64;
           I64[Hp - 184] = stg_sel_0_upd_info;
           P64[Hp - 168] = _ccfGe::P64;
           I64[Hp - 160] = sat_sccAx_info;
           P64[Hp - 144] = _sccyd::P64;
           P64[Hp - 136] = _sccye::P64;
           P64[Hp - 128] = _ccfCq::P64;
           I64[Hp - 120] = stg_sel_0_upd_info;
           P64[Hp - 104] = _ccfDw::P64;
           I64[Hp - 96] = sat_sccAi_info;
           P64[Hp - 80] = _ccfCq::P64;
           I64[Hp - 72] = GHC.Base.Just_con_info;
           P64[Hp - 64] = Hp - 96;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 120;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = _sccyf::P64;
           P64[Hp - 16] = _sccyg::P64;
           P64[Hp - 8] = Hp - 184;
           P64[Hp] = Hp - 208;
           R3 = Hp - 256;
           R2 = Hp - 232;
           R1 = Hp - 55;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.730901899 UTC

[section ""data" . f_rcccW_closure" {
     f_rcccW_closure:
         const GHC.Types.C#_con_info;
         const 37;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.73379764 UTC

[section ""data" . Text.Printf.uprintfs_closure" {
     Text.Printf.uprintfs_closure:
         const Text.Printf.uprintfs_info;
         const 0;
 },
 sat_sccEt_entry() //  [R1]
         { info_tbl: [(ccfSw,
                       label: sat_sccEt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfSw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfSx; else goto ccfSy;
       ccfSx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfSy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccEL_entry() //  [R1]
         { info_tbl: [(ccfT2,
                       label: sat_sccEL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfT2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfT3; else goto ccfT4;
       ccfT3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfT4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 16];
           R3 = P64[R1 + 32];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccES_entry() //  [R1]
         { info_tbl: [(ccfTn,
                       label: sat_sccES_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfTn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfTo; else goto ccfTp;
       ccfTo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfTp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucfUH_srtd" {
     ucfUH_srtd:
         const SccKB_srt+448;
         const 70;
         const 9223372036854775809;
         const 48;
 },
 Text.Printf.uprintfs_entry() //  [R2, R3, R4]
         { info_tbl: [(ccfTu,
                       label: Text.Printf.uprintfs_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfTu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccfTv; else goto ccfTw;
       ccfTv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.uprintfs_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfTw: // global
           I64[Sp - 24] = block_ccfSf_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfUF; else goto ccfSg;
       ucfUF: // global
           call _ccfSf(R1) args: 0, res: 0, upd: 0;
       ccfSg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucfUI_srtd" {
     ucfUI_srtd:
         const SccKB_srt+448;
         const 70;
         const 9223372036854775809;
         const 48;
 },
 _ccfSf() //  [R1]
         { info_tbl: [(ccfSf,
                       label: block_ccfSf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfSf: // global
           if (R1 & 7 == 1) goto ccfTr; else goto ccfTs;
       ccfTr: // global
           _sccEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccfTy_info;
           R1 = _sccEh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucfUv; else goto ccfTA;
       ucfUv: // global
           call _ccfTy(R1) args: 0, res: 0, upd: 0;
       ccfTA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccfTs: // global
           I64[Sp - 8] = block_ccfSl_info;
           _sccEp::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccEp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfUw; else goto ccfSm;
       ucfUw: // global
           call _ccfSl(R1) args: 0, res: 0, upd: 0;
       ccfSm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfTy() //  [R1]
         { info_tbl: [(ccfTy,
                       label: block_ccfTy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfTy: // global
           if (R1 & 7 == 1) goto ccfTG; else goto ccfTK;
       ccfTG: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfTK: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccfSl() //  [R1]
         { info_tbl: [(ccfSl,
                       label: block_ccfSl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfSl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccfTO; else goto ccfTN;
       ccfTO: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfTN: // global
           _sccEp::P64 = P64[Sp + 8];
           if (I64[R1 + 7] == 37) goto ccfU9; else goto ccfTR;
       ccfU9: // global
           Hp = Hp - 64;
           I64[Sp] = block_ccfT5_info;
           R1 = _sccEp::P64;
           if (R1 & 7 != 0) goto ucfUx; else goto ccfT6;
       ucfUx: // global
           call _ccfT5(R1) args: 0, res: 0, upd: 0;
       ccfT6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccfTR: // global
           I64[Hp - 56] = sat_sccEt_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sccEp::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccfT5() //  [R1]
         { info_tbl: [(ccfT5,
                       label: block_ccfT5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfT5: // global
           if (R1 & 7 == 1) goto ucfUr; else goto ccfUf;
       ucfUr: // global
           Sp = Sp + 8;
           call _sccEu() args: 0, res: 0, upd: 0;
       ccfUf: // global
           I64[Sp - 8] = block_ccfTb_info;
           _sccEO::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccEO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfUC; else goto ccfTc;
       ucfUC: // global
           call _ccfTb(R1) args: 0, res: 0, upd: 0;
       ccfTc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfTb() //  [R1]
         { info_tbl: [(ccfTb,
                       label: block_ccfTb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfTb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccfUi; else goto ccfUh;
       ccfUi: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfUh: // global
           if (I64[R1 + 7] == 37) goto ccfUm; else goto ccfUk;
       ccfUm: // global
           I64[Hp - 56] = sat_sccES_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = f_rcccW_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccfUk: // global
           Hp = Hp - 64;
           Sp = Sp + 16;
           call _sccEu() args: 0, res: 0, upd: 0;
     }
 },
 _sccEu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccEu: // global
           I64[Sp - 8] = block_ccfSF_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfUG; else goto ccfSG;
       ucfUG: // global
           call _ccfSF(R1) args: 0, res: 0, upd: 0;
       ccfSG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfSF() //  [R1]
         { info_tbl: [(ccfSF,
                       label: block_ccfSF_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfSF: // global
           if (R1 & 7 == 1) goto ucfUt; else goto ccfTY;
       ucfUt: // global
           Sp = Sp + 32;
           call _ccfU3() args: 0, res: 0, upd: 0;
       ccfTY: // global
           I64[Sp + 16] = block_ccfSL_info;
           R6 = P64[Sp + 8];
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = GHC.Types.False_closure+1;
           R2 = GHC.Types.False_closure+1;
           P64[Sp + 8] = R1;
           Sp = Sp + 8;
           call $wgetSpecs_rcccV_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 16, res: 8, upd: 8;
     }
 },
 _ccfSL() //  [R1, R2, R3]
         { info_tbl: [(ccfSL,
                       label: block_ccfSL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfSL: // global
           I64[Sp - 16] = block_ccfSN_info;
           _sccEB::P64 = R1;
           R1 = R3;
           P64[Sp - 8] = R2;
           P64[Sp] = _sccEB::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucfUz; else goto ccfSO;
       ucfUz: // global
           call _ccfSN(R1) args: 0, res: 0, upd: 0;
       ccfSO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfSN() //  [R1]
         { info_tbl: [(ccfSN,
                       label: block_ccfSN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfSN: // global
           if (R1 & 7 == 1) goto ucfUu; else goto ccfU5;
       ucfUu: // global
           Sp = Sp + 32;
           call _ccfU3() args: 0, res: 0, upd: 0;
       ccfU5: // global
           I64[Sp - 8] = block_ccfST_info;
           _sccEH::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccEH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfUA; else goto ccfSU;
       ucfUA: // global
           call _ccfST(R1) args: 0, res: 0, upd: 0;
       ccfSU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfU3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfU3: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccfST() //  [R1]
         { info_tbl: [(ccfST,
                       label: block_ccfST_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfST: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccfU8; else goto ccfU7;
       ccfU8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfU7: // global
           _sccEK::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sccEL_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 32;
           R2 = P64[Sp + 24];
           R1 = _sccEK::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.73887035 UTC

[section ""data" . Text.Printf.$fPrintfTypeIO_$cspr_closure" {
     Text.Printf.$fPrintfTypeIO_$cspr_closure:
         const Text.Printf.$fPrintfTypeIO_$cspr_info;
         const 0;
 },
 sat_sccEW_entry() //  [R1]
         { info_tbl: [(ccfUX,
                       label: sat_sccEW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfUX: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccEX_entry() //  [R1]
         { info_tbl: [(ccfV0,
                       label: sat_sccEX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfV0: // global
           _sccEX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccfV1; else goto ccfV2;
       ccfV2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfV4; else goto ccfV3;
       ccfV4: // global
           HpAlloc = 24;
           goto ccfV1;
       ccfV1: // global
           R1 = _sccEX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfV3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccEX::P64;
           _sccEU::P64 = P64[_sccEX::P64 + 16];
           _sccEV::P64 = P64[_sccEX::P64 + 24];
           I64[Hp - 16] = sat_sccEW_info;
           P64[Hp] = _sccEV::P64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _sccEU::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfTypeIO_$cspr_entry() //  [R2, R3, R4]
         { info_tbl: [(ccfV5,
                       label: Text.Printf.$fPrintfTypeIO_$cspr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfV5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccfV6; else goto ccfV7;
       ccfV6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfTypeIO_$cspr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfV7: // global
           I64[Sp - 24] = block_ccfUN_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfUN() //  []
         { info_tbl: [(ccfUN,
                       label: block_ccfUN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfUN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccfVa; else goto ccfV9;
       ccfVa: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccfV9: // global
           I64[Hp - 24] = sat_sccEX_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           Sp = Sp + 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.740633381 UTC

[section ""data" . Text.Printf.$fPrintfTypeIO_closure" {
     Text.Printf.$fPrintfTypeIO_closure:
         const Text.Printf.$fPrintfTypeIO_info;
         const 0;
 },
 Text.Printf.$fPrintfTypeIO_entry() //  [R2, R3, R4]
         { info_tbl: [(ccfVf,
                       label: Text.Printf.$fPrintfTypeIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfVf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfTypeIO_$cspr_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.741908887 UTC

[section ""data" . Text.Printf.$fPrintfType[]_$cspr_closure" {
     Text.Printf.$fPrintfType[]_$cspr_closure:
         const Text.Printf.$fPrintfType[]_$cspr_info;
         const 0;
 },
 sat_sccF2_entry() //  [R1]
         { info_tbl: [(ccfVq,
                       label: sat_sccF2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfVq: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccF1_entry() //  [R1]
         { info_tbl: [(ccfVB,
                       label: sat_sccF1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfVB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccfVC; else goto ccfVD;
       ccfVC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfVD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.Printf.fromChar_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfType[]_$cspr_entry() //  [R2, R3, R4]
         { info_tbl: [(ccfVE,
                       label: Text.Printf.$fPrintfType[]_$cspr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfVE: // global
           _sccF0::P64 = R4;
           _sccEZ::P64 = R3;
           _sccEY::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccfVF; else goto ccfVG;
       ccfVG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfVI; else goto ccfVH;
       ccfVI: // global
           HpAlloc = 24;
           goto ccfVF;
       ccfVF: // global
           R4 = _sccF0::P64;
           R3 = _sccEZ::P64;
           R2 = _sccEY::P64;
           R1 = Text.Printf.$fPrintfType[]_$cspr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfVH: // global
           I64[Hp - 16] = sat_sccF2_info;
           P64[Hp] = _sccF0::P64;
           I64[Sp - 16] = block_ccfVt_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _sccEZ::P64;
           P64[Sp - 8] = _sccEY::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfVt() //  [R1]
         { info_tbl: [(ccfVt,
                       label: block_ccfVt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfVt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfVL; else goto ccfVK;
       ccfVL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfVK: // global
           I64[Hp - 16] = sat_sccF1_info;
           P64[Hp] = P64[Sp + 8];
           R3 = R1;
           R2 = Hp - 16;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.743608839 UTC

[section ""data" . Text.Printf.$fPrintfType[]_closure" {
     Text.Printf.$fPrintfType[]_closure:
         const Text.Printf.$fPrintfType[]_info;
         const 0;
 },
 Text.Printf.$fPrintfType[]_entry() //  [R2, R3, R4]
         { info_tbl: [(ccfVQ,
                       label: Text.Printf.$fPrintfType[]_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfVQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfType[]_$cspr_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.744887932 UTC

[section ""data" . Text.Printf.$fHPrintfTypeIO_$chspr_closure" {
     Text.Printf.$fHPrintfTypeIO_$chspr_closure:
         const Text.Printf.$fHPrintfTypeIO_$chspr_info;
         const 0;
 },
 sat_sccF8_entry() //  [R1]
         { info_tbl: [(ccfW7,
                       label: sat_sccF8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfW7: // global
           R2 = P64[R1 + 16];
           call GHC.List.reverse_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccF9_entry() //  [R1]
         { info_tbl: [(ccfWa,
                       label: sat_sccF9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfWa: // global
           _sccF9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccfWb; else goto ccfWc;
       ccfWc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfWe; else goto ccfWd;
       ccfWe: // global
           HpAlloc = 24;
           goto ccfWb;
       ccfWb: // global
           R1 = _sccF9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfWd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccF9::P64;
           _sccF6::P64 = P64[_sccF9::P64 + 16];
           _sccF7::P64 = P64[_sccF9::P64 + 24];
           I64[Hp - 16] = sat_sccF8_info;
           P64[Hp] = _sccF7::P64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _sccF6::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fHPrintfTypeIO_$chspr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccfWf,
                       label: Text.Printf.$fHPrintfTypeIO_$chspr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfWf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfWg; else goto ccfWh;
       ccfWg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fHPrintfTypeIO_$chspr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfWh: // global
           I64[Sp - 32] = block_ccfVX_info;
           R2 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccfVX() //  []
         { info_tbl: [(ccfVX,
                       label: block_ccfVX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfVX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccfWk; else goto ccfWj;
       ccfWk: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccfWj: // global
           I64[Hp - 24] = sat_sccF9_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.746682819 UTC

[section ""data" . Text.Printf.$fHPrintfTypeIO_closure" {
     Text.Printf.$fHPrintfTypeIO_closure:
         const Text.Printf.$fHPrintfTypeIO_info;
         const 0;
 },
 Text.Printf.$fHPrintfTypeIO_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccfWp,
                       label: Text.Printf.$fHPrintfTypeIO_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfWp: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fHPrintfTypeIO_$chspr_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.747658073 UTC

[section ""data" . Text.Printf.FormatParse_closure" {
     Text.Printf.FormatParse_closure:
         const Text.Printf.FormatParse_info;
 },
 Text.Printf.FormatParse_entry() //  [R2, R3, R4]
         { info_tbl: [(ccfWx,
                       label: Text.Printf.FormatParse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfWx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccfWB; else goto ccfWA;
       ccfWB: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.FormatParse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfWA: // global
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.748861783 UTC

[section ""data" . Text.Printf.FieldFormat_closure" {
     Text.Printf.FieldFormat_closure:
         const Text.Printf.FieldFormat_info;
 },
 Text.Printf.FieldFormat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfWD: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.FieldFormat_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 24, res: 0, upd: 8;
     }
 },
 Text.Printf.FieldFormat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccfWI,
                       label: Text.Printf.FieldFormat_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfWI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccfWM; else goto ccfWL;
       ccfWM: // global
           HpAlloc = 64;
           R1 = Text.Printf.FieldFormat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ccfWL: // global
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.750064873 UTC

[section ""data" . Text.Printf.SignPlus_closure" {
     Text.Printf.SignPlus_closure:
         const Text.Printf.SignPlus_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.750642731 UTC

[section ""data" . Text.Printf.SignSpace_closure" {
     Text.Printf.SignSpace_closure:
         const Text.Printf.SignSpace_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.751175107 UTC

[section ""data" . Text.Printf.LeftAdjust_closure" {
     Text.Printf.LeftAdjust_closure:
         const Text.Printf.LeftAdjust_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.75171612 UTC

[section ""data" . Text.Printf.ZeroPad_closure" {
     Text.Printf.ZeroPad_closure:
         const Text.Printf.ZeroPad_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.752461314 UTC

[section ""data" . Text.Printf.C:IsChar_closure" {
     Text.Printf.C:IsChar_closure:
         const Text.Printf.C:IsChar_info;
 },
 Text.Printf.C:IsChar_entry() //  [R2, R3]
         { info_tbl: [(ccfWS,
                       label: Text.Printf.C:IsChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfWS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfWW; else goto ccfWV;
       ccfWW: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.C:IsChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfWV: // global
           I64[Hp - 16] = Text.Printf.C:IsChar_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.753470938 UTC

[section ""data" . Text.Printf.C:PrintfArg_closure" {
     Text.Printf.C:PrintfArg_closure:
         const Text.Printf.C:PrintfArg_info;
 },
 Text.Printf.C:PrintfArg_entry() //  [R2, R3]
         { info_tbl: [(ccfX2,
                       label: Text.Printf.C:PrintfArg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfX2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccfX6; else goto ccfX5;
       ccfX6: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.C:PrintfArg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfX5: // global
           I64[Hp - 16] = Text.Printf.C:PrintfArg_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.754373371 UTC

[Text.Printf.FormatParse_con_entry() //  [R1]
         { info_tbl: [(ccfX7,
                       label: Text.Printf.FormatParse_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,70,111,114,109,97,116,80,97,114,115,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfX7: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.755132552 UTC

[Text.Printf.FieldFormat_con_entry() //  [R1]
         { info_tbl: [(ccfX9,
                       label: Text.Printf.FieldFormat_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,70,105,101,108,100,70,111,114,109,97,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfX9: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.755807306 UTC

[section ""relreadonly" . Text.Printf.FormatSign_closure_tbl" {
     Text.Printf.FormatSign_closure_tbl:
         const Text.Printf.SignPlus_closure+1;
         const Text.Printf.SignSpace_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.756418316 UTC

[Text.Printf.SignPlus_con_entry() //  [R1]
         { info_tbl: [(ccfXb,
                       label: Text.Printf.SignPlus_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,83,105,103,110,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfXb: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.75712916 UTC

[Text.Printf.SignSpace_con_entry() //  [R1]
         { info_tbl: [(ccfXd,
                       label: Text.Printf.SignSpace_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,83,105,103,110,83,112,97,99,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfXd: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.757945974 UTC

[section ""relreadonly" . Text.Printf.FormatAdjustment_closure_tbl" {
     Text.Printf.FormatAdjustment_closure_tbl:
         const Text.Printf.LeftAdjust_closure+1;
         const Text.Printf.ZeroPad_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.758588771 UTC

[Text.Printf.LeftAdjust_con_entry() //  [R1]
         { info_tbl: [(ccfXf,
                       label: Text.Printf.LeftAdjust_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,76,101,102,116,65,100,106,117,115,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfXf: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.75930792 UTC

[Text.Printf.ZeroPad_con_entry() //  [R1]
         { info_tbl: [(ccfXh,
                       label: Text.Printf.ZeroPad_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,90,101,114,111,80,97,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfXh: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.760030969 UTC

[Text.Printf.C:IsChar_con_entry() //  [R1]
         { info_tbl: [(ccfXj,
                       label: Text.Printf.C:IsChar_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,67,58,73,115,67,104,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfXj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.76077456 UTC

[Text.Printf.C:PrintfArg_con_entry() //  [R1]
         { info_tbl: [(ccfXl,
                       label: Text.Printf.C:PrintfArg_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,67,58,80,114,105,110,116,102,65,114,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfXl: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.761483197 UTC

[section ""relreadonly" . SccKB_srt" {
     SccKB_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Printf.perror_closure;
         const GHC.Show.$wshowLitChar_closure;
         const GHC.Show.$fShowChar1_closure;
         const Text.Printf.$werrorBadFormat_closure;
         const Text.Printf.errorBadFormat_closure;
         const Text.Printf.errorShortFormat_closure;
         const Text.Printf.$dmparseFormat_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.Unicode.toUpper_closure;
         const GHC.Float.$w$sformatRealFloatAlt_closure;
         const Text.Printf.$w$sdfmt_closure;
         const Text.Printf.$fPrintfArgDouble7_closure;
         const Text.Printf.$fPrintfArgDouble8_closure;
         const GHC.Float.$w$sformatRealFloatAlt1_closure;
         const Text.Printf.$w$sdfmt1_closure;
         const Text.Printf.$fPrintfArgFloat1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Text.Printf.$wdfmt_closure;
         const Text.Printf.formatRealFloat1_closure;
         const sat_scchQ_closure;
         const sat_scchS_closure;
         const sat_scchW_closure;
         const sat_scci2_closure;
         const Text.Printf.intModifierMap_closure;
         const Text.Printf.$wfixupMods_closure;
         const Text.Printf.$fPrintfArgInt2_closure;
         const Text.Printf.fixupMods_closure;
         const Text.Printf.$wparseIntFormat_closure;
         const GHC.Err.undefined_closure;
         const lvl18_rccch_closure;
         const Control.Exception.Base.patError_closure;
         const sat_sccjr_closure;
         const GHC.Show.intToDigit_closure;
         const GHC.Show.$fShowInteger_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Numeric.showIntAtBase_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const Text.Printf.formatChar2_closure;
         const lvl21_rccck_closure;
         const lvl20_rcccj_closure;
         const $wfmtu_rcccl_closure;
         const Text.Printf.errorBadArgument_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const $wfmti_rcccm_closure;
         const Text.Printf.$wadjustSigned_closure;
         const Text.Printf.$fPrintfArgDouble1_closure;
         const Text.Printf.$fPrintfArgDouble3_closure;
         const Text.Printf.$w$sformatRealFloat_closure;
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure;
         const Text.Printf.$w$sformatRealFloat1_closure;
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure;
         const Text.Printf.$wformatRealFloat_closure;
         const Text.Printf.formatRealFloat_closure;
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_closure;
         const Text.Printf.errorShortFormat_closure;
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_closure;
         const Text.Printf.$w$sformatString_closure;
         const Text.Printf.$werrorBadFormat_closure;
         const Text.Printf.$wformatString_closure;
         const Text.Printf.formatString_closure;
         const lvl22_rcccn_closure;
         const Text.Printf.$fPrintfArg[]_closure;
         const sat_sccoX_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const sat_sccp0_closure;
         const sat_sccp2_closure;
         const sat_sccp4_closure;
         const GHC.Unicode.toUpper_closure;
         const lvl24_rcccp_closure;
         const lvl38_rcccD_closure;
         const lvl39_rcccE_closure;
         const GHC.Char.$wlvl_closure;
         const lvl32_rcccx_closure;
         const lvl40_rcccF_closure;
         const $wfmtu_rcccl_closure;
         const Text.Printf.formatChar2_closure;
         const lvl35_rcccA_closure;
         const lvl41_rcccG_closure;
         const Text.Printf.$wformatIntegral_closure;
         const lvl30_rcccv_closure;
         const lvl31_rcccw_closure;
         const Text.Printf.formatIntegral_closure;
         const Text.Printf.$wformatChar_closure;
         const Text.Printf.formatChar1_closure;
         const Text.Printf.formatChar_closure;
         const Text.Printf.$fPrintfArgInt2_closure;
         const Text.Printf.$w$sformatInt3_closure;
         const Text.Printf.$fPrintfArgWord64_$sformatInt_closure;
         const Text.Printf.$w$sformatInt2_closure;
         const Text.Printf.$fPrintfArgWord32_$sformatInt_closure;
         const Text.Printf.$w$sformatInt1_closure;
         const Text.Printf.$fPrintfArgWord16_$sformatInt_closure;
         const Text.Printf.$w$sformatInt4_closure;
         const Text.Printf.$fPrintfArgWord8_$sformatInt_closure;
         const Text.Printf.$w$sformatInt_closure;
         const Text.Printf.$fPrintfArgWord_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt1_closure;
         const Text.Printf.$fPrintfArgInt64_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt4_closure;
         const Text.Printf.$fPrintfArgInt32_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt3_closure;
         const Text.Printf.$fPrintfArgInt16_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt5_closure;
         const Text.Printf.$fPrintfArgInt8_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt_$sformatInt_closure;
         const Text.Printf.$wformatInt_closure;
         const Text.Printf.formatInt_closure;
         const Text.Printf.formatInteger_closure;
         const Text.Printf.$fPrintfArgNatural_$cformatArg_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Text.Read.readEither5_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Read.readEither2_closure;
         const lvl42_rcccH_closure;
         const lvl44_rcccJ_closure;
         const lvl45_rcccK_closure;
         const Text.Printf.errorMissingArgument_closure;
         const $wgetStar_rcccL_closure;
         const lvl49_rcccP_closure;
         const lvl52_rcccS_closure;
         const lvl53_rcccT_closure;
         const $wgetSpecs_rcccV_closure;
         const Text.Printf.uprintfs_closure;
         const Text.Printf.errorShortFormat_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const Text.Printf.$fPrintfTypeIO_$cspr_closure;
         const Text.Printf.$fPrintfType[]_$cspr_closure;
         const Text.Printf.$fHPrintfTypeIO_$chspr_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.763070372 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:04.764441866 UTC

[section ""data" . Text.Printf.toChar_closure" {
     Text.Printf.toChar_closure:
         const Text.Printf.toChar_info;
 },
 Text.Printf.toChar_entry() //  [R2]
         { info_tbl: [(ccfXu,
                       label: Text.Printf.toChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfXu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfXv; else goto ccfXw;
       ccfXv: // global
           R2 = R2;
           R1 = Text.Printf.toChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccfXw: // global
           I64[Sp - 8] = block_ccfXr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfXA; else goto ccfXs;
       ucfXA: // global
           call _ccfXr(R1) args: 0, res: 0, upd: 0;
       ccfXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfXr() //  [R1]
         { info_tbl: [(ccfXr,
                       label: block_ccfXr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfXr: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.770165635 UTC

[section ""data" . Text.Printf.fromChar_closure" {
     Text.Printf.fromChar_closure:
         const Text.Printf.fromChar_info;
 },
 Text.Printf.fromChar_entry() //  [R2]
         { info_tbl: [(ccfXR,
                       label: Text.Printf.fromChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfXR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfXS; else goto ccfXT;
       ccfXS: // global
           R2 = R2;
           R1 = Text.Printf.fromChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccfXT: // global
           I64[Sp - 8] = block_ccfXO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfXX; else goto ccfXP;
       ucfXX: // global
           call _ccfXO(R1) args: 0, res: 0, upd: 0;
       ccfXP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfXO() //  [R1]
         { info_tbl: [(ccfXO,
                       label: block_ccfXO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfXO: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.77829968 UTC

[section ""data" . Text.Printf.formatArg_closure" {
     Text.Printf.formatArg_closure:
         const Text.Printf.formatArg_info;
 },
 Text.Printf.formatArg_entry() //  [R2]
         { info_tbl: [(ccfYe,
                       label: Text.Printf.formatArg_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfYe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfYf; else goto ccfYg;
       ccfYf: // global
           R2 = R2;
           R1 = Text.Printf.formatArg_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccfYg: // global
           I64[Sp - 8] = block_ccfYb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfYk; else goto ccfYc;
       ucfYk: // global
           call _ccfYb(R1) args: 0, res: 0, upd: 0;
       ccfYc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfYb() //  [R1]
         { info_tbl: [(ccfYb,
                       label: block_ccfYb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfYb: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.78364298 UTC

[section ""data" . Text.Printf.parseFormat_closure" {
     Text.Printf.parseFormat_closure:
         const Text.Printf.parseFormat_info;
 },
 Text.Printf.parseFormat_entry() //  [R2]
         { info_tbl: [(ccfYB,
                       label: Text.Printf.parseFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfYB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccfYC; else goto ccfYD;
       ccfYC: // global
           R2 = R2;
           R1 = Text.Printf.parseFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccfYD: // global
           I64[Sp - 8] = block_ccfYy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfYH; else goto ccfYz;
       ucfYH: // global
           call _ccfYy(R1) args: 0, res: 0, upd: 0;
       ccfYz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfYy() //  [R1]
         { info_tbl: [(ccfYy,
                       label: block_ccfYy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfYy: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.788858716 UTC

[section ""data" . Text.Printf.hspr_closure" {
     Text.Printf.hspr_closure:
         const Text.Printf.hspr_info;
 },
 Text.Printf.hspr_entry() //  [R2]
         { info_tbl: [(ccfYV,
                       label: Text.Printf.hspr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfYV: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.792086624 UTC

[section ""data" . Text.Printf.spr_closure" {
     Text.Printf.spr_closure:
         const Text.Printf.spr_info;
 },
 Text.Printf.spr_entry() //  [R2]
         { info_tbl: [(ccfZ6,
                       label: Text.Printf.spr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfZ6: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.795691195 UTC

[section ""data" . Text.Printf.$fIsCharChar_$cfromChar_closure" {
     Text.Printf.$fIsCharChar_$cfromChar_closure:
         const Text.Printf.$fIsCharChar_$cfromChar_info;
 },
 Text.Printf.$fIsCharChar_$cfromChar_entry() //  [R2]
         { info_tbl: [(ccfZh,
                       label: Text.Printf.$fIsCharChar_$cfromChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfZh: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.798926807 UTC

[section ""data" . Text.Printf.$fIsCharChar_closure" {
     Text.Printf.$fIsCharChar_closure:
         const Text.Printf.C:IsChar_con_info;
         const Text.Printf.$fIsCharChar_$cfromChar_closure+1;
         const Text.Printf.$fIsCharChar_$cfromChar_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.801139606 UTC

[section ""data" . Text.Printf.$fHPrintfType(->)_$chspr_closure" {
     Text.Printf.$fHPrintfType(->)_$chspr_closure:
         const Text.Printf.$fHPrintfType(->)_$chspr_info;
 },
 sat_sccdo_entry() //  [R1]
         { info_tbl: [(ccfZz,
                       label: sat_sccdo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfZz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfZA; else goto ccfZB;
       ccfZA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfZB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.formatArg_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sccdn_entry() //  [R1]
         { info_tbl: [(ccfZG,
                       label: sat_sccdn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfZG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfZH; else goto ccfZI;
       ccfZH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfZI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.parseFormat_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Text.Printf.$fHPrintfType(->)_$chspr_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(ccfZL,
                       label: Text.Printf.$fHPrintfType(->)_$chspr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfZL: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccfZP; else goto ccfZO;
       ccfZP: // global
           HpAlloc = 112;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fHPrintfType(->)_$chspr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ccfZO: // global
           I64[Hp - 104] = sat_sccdo_info;
           P64[Hp - 88] = R2;
           _sccdm::P64 = P64[Sp];
           P64[Hp - 80] = _sccdm::P64;
           I64[Hp - 72] = sat_sccdn_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = _sccdm::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = R6;
           _sccdj::P64 = R4;
           R4 = Hp - 14;
           _sccdi::P64 = R3;
           R3 = R5;
           R2 = _sccdj::P64;
           R1 = _sccdi::P64;
           Sp = Sp + 8;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.810324355 UTC

[section ""data" . Text.Printf.$fHPrintfType(->)_closure" {
     Text.Printf.$fHPrintfType(->)_closure:
         const Text.Printf.$fHPrintfType(->)_info;
 },
 Text.Printf.$fHPrintfType(->)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccg0b,
                       label: Text.Printf.$fHPrintfType(->)_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg0b: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fHPrintfType(->)_$chspr_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.814111866 UTC

[section ""data" . Text.Printf.$fPrintfType(->)_$cspr_closure" {
     Text.Printf.$fPrintfType(->)_$cspr_closure:
         const Text.Printf.$fPrintfType(->)_$cspr_info;
 },
 sat_sccdx_entry() //  [R1]
         { info_tbl: [(ccg0q,
                       label: sat_sccdx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg0q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccg0r; else goto ccg0s;
       ccg0r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccg0s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.formatArg_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sccdw_entry() //  [R1]
         { info_tbl: [(ccg0x,
                       label: sat_sccdw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg0x: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccg0y; else goto ccg0z;
       ccg0y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccg0z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.parseFormat_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfType(->)_$cspr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccg0C,
                       label: Text.Printf.$fPrintfType(->)_$cspr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg0C: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccg0G; else goto ccg0F;
       ccg0G: // global
           HpAlloc = 112;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfType(->)_$cspr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccg0F: // global
           I64[Hp - 104] = sat_sccdx_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R6;
           I64[Hp - 72] = sat_sccdw_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R6;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = R5;
           _sccds::P64 = R3;
           R3 = Hp - 14;
           R2 = R4;
           R1 = _sccds::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.821968384 UTC

[section ""data" . Text.Printf.$fPrintfType(->)_closure" {
     Text.Printf.$fPrintfType(->)_closure:
         const Text.Printf.$fPrintfType(->)_info;
 },
 Text.Printf.$fPrintfType(->)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccg12,
                       label: Text.Printf.$fPrintfType(->)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg12: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfType(->)_$cspr_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.82583976 UTC

[section ""data" . Text.Printf.fmtChar_closure" {
     Text.Printf.fmtChar_closure:
         const Text.Printf.fmtChar_info;
 },
 Text.Printf.fmtChar_entry() //  [R2]
         { info_tbl: [(ccg1g,
                       label: Text.Printf.fmtChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg1g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg1h; else goto ccg1i;
       ccg1h: // global
           R2 = R2;
           R1 = Text.Printf.fmtChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg1i: // global
           I64[Sp - 8] = block_ccg1d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg1m; else goto ccg1e;
       ucg1m: // global
           call _ccg1d(R1) args: 0, res: 0, upd: 0;
       ccg1e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg1d() //  [R1]
         { info_tbl: [(ccg1d,
                       label: block_ccg1d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg1d: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.831152759 UTC

[section ""data" . Text.Printf.fmtModifiers_closure" {
     Text.Printf.fmtModifiers_closure:
         const Text.Printf.fmtModifiers_info;
 },
 Text.Printf.fmtModifiers_entry() //  [R2]
         { info_tbl: [(ccg1F,
                       label: Text.Printf.fmtModifiers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg1F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg1G; else goto ccg1H;
       ccg1G: // global
           R2 = R2;
           R1 = Text.Printf.fmtModifiers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg1H: // global
           I64[Sp - 8] = block_ccg1C_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg1L; else goto ccg1D;
       ucg1L: // global
           call _ccg1C(R1) args: 0, res: 0, upd: 0;
       ccg1D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg1C() //  [R1]
         { info_tbl: [(ccg1C,
                       label: block_ccg1C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg1C: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.836467413 UTC

[section ""data" . Text.Printf.fmtAlternate_closure" {
     Text.Printf.fmtAlternate_closure:
         const Text.Printf.fmtAlternate_info;
 },
 Text.Printf.fmtAlternate_entry() //  [R2]
         { info_tbl: [(ccg24,
                       label: Text.Printf.fmtAlternate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg24: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg25; else goto ccg26;
       ccg25: // global
           R2 = R2;
           R1 = Text.Printf.fmtAlternate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg26: // global
           I64[Sp - 8] = block_ccg21_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg2a; else goto ccg22;
       ucg2a: // global
           call _ccg21(R1) args: 0, res: 0, upd: 0;
       ccg22: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg21() //  [R1]
         { info_tbl: [(ccg21,
                       label: block_ccg21_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg21: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.841862005 UTC

[section ""data" . Text.Printf.fmtSign_closure" {
     Text.Printf.fmtSign_closure:
         const Text.Printf.fmtSign_info;
 },
 Text.Printf.fmtSign_entry() //  [R2]
         { info_tbl: [(ccg2t,
                       label: Text.Printf.fmtSign_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg2t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg2u; else goto ccg2v;
       ccg2u: // global
           R2 = R2;
           R1 = Text.Printf.fmtSign_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg2v: // global
           I64[Sp - 8] = block_ccg2q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg2z; else goto ccg2r;
       ucg2z: // global
           call _ccg2q(R1) args: 0, res: 0, upd: 0;
       ccg2r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg2q() //  [R1]
         { info_tbl: [(ccg2q,
                       label: block_ccg2q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg2q: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.847727717 UTC

[section ""data" . Text.Printf.fmtAdjust_closure" {
     Text.Printf.fmtAdjust_closure:
         const Text.Printf.fmtAdjust_info;
 },
 Text.Printf.fmtAdjust_entry() //  [R2]
         { info_tbl: [(ccg2S,
                       label: Text.Printf.fmtAdjust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg2S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg2T; else goto ccg2U;
       ccg2T: // global
           R2 = R2;
           R1 = Text.Printf.fmtAdjust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg2U: // global
           I64[Sp - 8] = block_ccg2P_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg2Y; else goto ccg2Q;
       ucg2Y: // global
           call _ccg2P(R1) args: 0, res: 0, upd: 0;
       ccg2Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg2P() //  [R1]
         { info_tbl: [(ccg2P,
                       label: block_ccg2P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg2P: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.853507681 UTC

[section ""data" . Text.Printf.fmtPrecision_closure" {
     Text.Printf.fmtPrecision_closure:
         const Text.Printf.fmtPrecision_info;
 },
 Text.Printf.fmtPrecision_entry() //  [R2]
         { info_tbl: [(ccg3h,
                       label: Text.Printf.fmtPrecision_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg3h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg3i; else goto ccg3j;
       ccg3i: // global
           R2 = R2;
           R1 = Text.Printf.fmtPrecision_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg3j: // global
           I64[Sp - 8] = block_ccg3e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg3n; else goto ccg3f;
       ucg3n: // global
           call _ccg3e(R1) args: 0, res: 0, upd: 0;
       ccg3f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg3e() //  [R1]
         { info_tbl: [(ccg3e,
                       label: block_ccg3e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg3e: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.858849041 UTC

[section ""data" . Text.Printf.fmtWidth_closure" {
     Text.Printf.fmtWidth_closure:
         const Text.Printf.fmtWidth_info;
 },
 Text.Printf.fmtWidth_entry() //  [R2]
         { info_tbl: [(ccg3G,
                       label: Text.Printf.fmtWidth_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg3G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg3H; else goto ccg3I;
       ccg3H: // global
           R2 = R2;
           R1 = Text.Printf.fmtWidth_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg3I: // global
           I64[Sp - 8] = block_ccg3D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg3M; else goto ccg3E;
       ucg3M: // global
           call _ccg3D(R1) args: 0, res: 0, upd: 0;
       ccg3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg3D() //  [R1]
         { info_tbl: [(ccg3D,
                       label: block_ccg3D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg3D: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.864112611 UTC

[section ""data" . Text.Printf.fpRest_closure" {
     Text.Printf.fpRest_closure:
         const Text.Printf.fpRest_info;
 },
 Text.Printf.fpRest_entry() //  [R2]
         { info_tbl: [(ccg45,
                       label: Text.Printf.fpRest_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg45: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg46; else goto ccg47;
       ccg46: // global
           R2 = R2;
           R1 = Text.Printf.fpRest_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg47: // global
           I64[Sp - 8] = block_ccg42_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg4b; else goto ccg43;
       ucg4b: // global
           call _ccg42(R1) args: 0, res: 0, upd: 0;
       ccg43: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg42() //  [R1]
         { info_tbl: [(ccg42,
                       label: block_ccg42_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg42: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.869472279 UTC

[section ""data" . Text.Printf.fpChar_closure" {
     Text.Printf.fpChar_closure:
         const Text.Printf.fpChar_info;
 },
 Text.Printf.fpChar_entry() //  [R2]
         { info_tbl: [(ccg4u,
                       label: Text.Printf.fpChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg4u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg4v; else goto ccg4w;
       ccg4v: // global
           R2 = R2;
           R1 = Text.Printf.fpChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg4w: // global
           I64[Sp - 8] = block_ccg4r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg4A; else goto ccg4s;
       ucg4A: // global
           call _ccg4r(R1) args: 0, res: 0, upd: 0;
       ccg4s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg4r() //  [R1]
         { info_tbl: [(ccg4r,
                       label: block_ccg4r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg4r: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.875260598 UTC

[section ""data" . Text.Printf.fpModifiers_closure" {
     Text.Printf.fpModifiers_closure:
         const Text.Printf.fpModifiers_info;
 },
 Text.Printf.fpModifiers_entry() //  [R2]
         { info_tbl: [(ccg4T,
                       label: Text.Printf.fpModifiers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg4T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg4U; else goto ccg4V;
       ccg4U: // global
           R2 = R2;
           R1 = Text.Printf.fpModifiers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg4V: // global
           I64[Sp - 8] = block_ccg4Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg4Z; else goto ccg4R;
       ucg4Z: // global
           call _ccg4Q(R1) args: 0, res: 0, upd: 0;
       ccg4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg4Q() //  [R1]
         { info_tbl: [(ccg4Q,
                       label: block_ccg4Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg4Q: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.880980794 UTC

[section ""data" . Text.Printf.printf_closure" {
     Text.Printf.printf_closure:
         const Text.Printf.printf_info;
 },
 Text.Printf.printf_entry() //  [R2, R3]
         { info_tbl: [(ccg5f,
                       label: Text.Printf.printf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg5f: // global
           _scceR::P64 = R3;
           R3 = GHC.Types.[]_closure+1;
           _scceQ::P64 = R2;
           R2 = _scceR::P64;
           R1 = _scceQ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.884453052 UTC

[section ""data" . Text.Printf.hPrintf_closure" {
     Text.Printf.hPrintf_closure:
         const Text.Printf.hPrintf_info;
 },
 Text.Printf.hPrintf_entry() //  [R2, R3, R4]
         { info_tbl: [(ccg5q,
                       label: Text.Printf.hPrintf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg5q: // global
           _scceU::P64 = R4;
           R4 = GHC.Types.[]_closure+1;
           _scceT::P64 = R3;
           R3 = _scceU::P64;
           _scceS::P64 = R2;
           R2 = _scceT::P64;
           R1 = _scceS::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.888331259 UTC

[section ""data" . Text.Printf.vFmt_closure" {
     Text.Printf.vFmt_closure:
         const Text.Printf.vFmt_info;
 },
 Text.Printf.vFmt_entry() //  [R2, R3]
         { info_tbl: [(ccg5E,
                       label: Text.Printf.vFmt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg5E: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccg5I; else goto ccg5J;
       ccg5I: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.vFmt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccg5J: // global
           I64[Sp - 16] = block_ccg5B_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucg60; else goto ccg5C;
       ucg60: // global
           call _ccg5B(R1) args: 0, res: 0, upd: 0;
       ccg5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg5B() //  [R1]
         { info_tbl: [(ccg5B,
                       label: block_ccg5B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg5B: // global
           I64[Sp - 56] = block_ccg5H_info;
           _scceX::P64 = R1;
           _scceY::P64 = P64[R1 + 7];
           _scceZ::P64 = P64[R1 + 15];
           _sccf0::P64 = P64[R1 + 23];
           _sccf1::P64 = P64[R1 + 31];
           _sccf2::P64 = P64[R1 + 39];
           _sccf3::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 48] = _scceY::P64;
           P64[Sp - 40] = _scceZ::P64;
           P64[Sp - 32] = _sccf0::P64;
           P64[Sp - 24] = _sccf1::P64;
           P64[Sp - 16] = _sccf2::P64;
           P64[Sp - 8] = _sccf3::P64;
           P64[Sp] = _scceX::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ucg5Z; else goto ccg5L;
       ucg5Z: // global
           call _ccg5H(R1) args: 0, res: 0, upd: 0;
       ccg5L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg5H() //  [R1]
         { info_tbl: [(ccg5H,
                       label: block_ccg5H_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg5H: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccg5R; else goto ccg5Q;
       ccg5R: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccg5Q: // global
           if (I64[R1 + 7] == 118) goto ccg5Y; else goto ccg5U;
       ccg5Y: // global
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 64];
           R1 = Hp - 55;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccg5U: // global
           Hp = Hp - 64;
           R1 = P64[Sp + 56] & (-8);
           Sp = Sp + 72;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.89699363 UTC

[section ""cstring" . lvl_rccbg_bytes" {
     lvl_rccbg_bytes:
         I8[] [112,114,105,110,116,102,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.898914413 UTC

[section ""data" . Text.Printf.perror_closure" {
     Text.Printf.perror_closure:
         const Text.Printf.perror_info;
         const 0;
 },
 Text.Printf.perror_entry() //  [R2]
         { info_tbl: [(ccg6v,
                       label: Text.Printf.perror_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg6v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg6w; else goto ccg6x;
       ccg6w: // global
           R2 = R2;
           R1 = Text.Printf.perror_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg6x: // global
           I64[Sp - 8] = block_ccg6t_info;
           R3 = R2;
           R2 = lvl_rccbg_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccg6t() //  [R1]
         { info_tbl: [(ccg6t,
                       label: block_ccg6t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg6t: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.903846401 UTC

[section ""data" . lvl1_rccbh_closure" {
     lvl1_rccbh_closure:
         const :_con_info;
         const GHC.Show.$fShowChar3_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.905500074 UTC

[section ""cstring" . lvl2_rccbi_bytes" {
     lvl2_rccbi_bytes:
         I8[] [98,97,100,32,102,111,114,109,97,116,116,105,110,103,32,99,104,97,114,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.907919071 UTC

[section ""data" . Text.Printf.$werrorBadFormat_closure" {
     Text.Printf.$werrorBadFormat_closure:
         const Text.Printf.$werrorBadFormat_info;
         const 0;
 },
 sat_sccfc_entry() //  [R1]
         { info_tbl: [(ccg73,
                       label: sat_sccfc_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg73: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccg74; else goto ccg75;
       ccg74: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccg75: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = lvl1_rccbh_closure+2;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$wshowLitChar_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccfd_entry() //  [R1]
         { info_tbl: [(ccg79,
                       label: sat_sccfd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg79: // global
           _sccfd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccg7a; else goto ccg7b;
       ccg7b: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccg7d; else goto ccg7c;
       ccg7d: // global
           HpAlloc = 48;
           goto ccg7a;
       ccg7a: // global
           R1 = _sccfd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccg7c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccfd::P64;
           _sccfb::I64 = I64[_sccfd::P64 + 16];
           if (_sccfb::I64 != 39) goto ccg77; else goto ccg78;
       ccg77: // global
           I64[Hp - 40] = sat_sccfc_info;
           I64[Hp - 24] = _sccfb::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShowChar3_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccg78: // global
           Hp = Hp - 48;
           R1 = GHC.Show.$fShowChar1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccfe_entry() //  [R1]
         { info_tbl: [(ccg7f,
                       label: sat_sccfe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg7f: // global
           _sccfe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccg7g; else goto ccg7h;
       ccg7h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccg7j; else goto ccg7i;
       ccg7j: // global
           HpAlloc = 24;
           goto ccg7g;
       ccg7g: // global
           R1 = _sccfe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccg7i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccfe::P64;
           _sccfa::I64 = I64[_sccfe::P64 + 16];
           I64[Hp - 16] = sat_sccfd_info;
           I64[Hp] = _sccfa::I64;
           R3 = Hp - 16;
           R2 = lvl2_rccbi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$werrorBadFormat_entry() //  [R2]
         { info_tbl: [(ccg7m,
                       label: Text.Printf.$werrorBadFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg7m: // global
           _sccfa::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccg7n; else goto ccg7o;
       ccg7o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccg7q; else goto ccg7p;
       ccg7q: // global
           HpAlloc = 24;
           goto ccg7n;
       ccg7n: // global
           R2 = _sccfa::I64;
           R1 = Text.Printf.$werrorBadFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg7p: // global
           I64[Hp - 16] = sat_sccfe_info;
           I64[Hp] = _sccfa::I64;
           I64[Sp - 8] = block_ccg7k_info;
           R3 = Hp - 16;
           R2 = lvl_rccbg_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccg7k() //  [R1]
         { info_tbl: [(ccg7k,
                       label: block_ccg7k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg7k: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.92075029 UTC

[section ""data" . Text.Printf.errorBadFormat_closure" {
     Text.Printf.errorBadFormat_closure:
         const Text.Printf.errorBadFormat_info;
         const 0;
 },
 Text.Printf.errorBadFormat_entry() //  [R2]
         { info_tbl: [(ccg7Y,
                       label: Text.Printf.errorBadFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg7Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg7Z; else goto ccg80;
       ccg7Z: // global
           R2 = R2;
           R1 = Text.Printf.errorBadFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccg80: // global
           I64[Sp - 8] = block_ccg7V_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg84; else goto ccg7W;
       ucg84: // global
           call _ccg7V(R1) args: 0, res: 0, upd: 0;
       ccg7W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg7V() //  [R1]
         { info_tbl: [(ccg7V,
                       label: block_ccg7V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg7V: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.925965561 UTC

[section ""cstring" . lvl3_rccbj_bytes" {
     lvl3_rccbj_bytes:
         I8[] [112,114,105,110,116,102,58,32,102,111,114,109,97,116,116,105,110,103,32,115,116,114,105,110,103,32,101,110,100,101,100,32,112,114,101,109,97,116,117,114,101,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.927902387 UTC

[section ""data" . Text.Printf.errorShortFormat_closure" {
     Text.Printf.errorShortFormat_closure:
         const Text.Printf.errorShortFormat_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorShortFormat_entry() //  [R1]
         { info_tbl: [(ccg8n,
                       label: Text.Printf.errorShortFormat_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg8n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccg8o; else goto ccg8p;
       ccg8o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccg8p: // global
           (_ccg8i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccg8i::I64 == 0) goto ccg8k; else goto ccg8j;
       ccg8k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccg8j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccg8i::I64;
           I64[Sp - 24] = block_ccg8l_info;
           R2 = lvl3_rccbj_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccg8l() //  [R1]
         { info_tbl: [(ccg8l,
                       label: block_ccg8l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg8l: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.936519262 UTC

[section ""data" . Text.Printf.$dmparseFormat_closure" {
     Text.Printf.$dmparseFormat_closure:
         const Text.Printf.$dmparseFormat_info;
         const 0;
 },
 Text.Printf.$dmparseFormat_entry() //  [R2, R3, R4]
         { info_tbl: [(ccg8O,
                       label: Text.Printf.$dmparseFormat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg8O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccg8P; else goto ccg8Q;
       ccg8P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$dmparseFormat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccg8Q: // global
           I64[Sp - 8] = block_ccg8H_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucg90; else goto ccg8I;
       ucg90: // global
           call _ccg8H(R1) args: 0, res: 0, upd: 0;
       ccg8I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg8H() //  [R1]
         { info_tbl: [(ccg8H,
                       label: block_ccg8H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg8H: // global
           if (R1 & 7 == 1) goto ccg8L; else goto ccg8M;
       ccg8L: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccg8M: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccg8Z; else goto ccg8Y;
       ccg8Z: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccg8Y: // global
           _sccfo::P64 = P64[R1 + 6];
           _sccfp::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccfo::P64;
           P64[Hp] = _sccfp::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.94354343 UTC

[section ""cstring" . lvl4_rccbk_bytes" {
     lvl4_rccbk_bytes:
         I8[] [112,114,105,110,116,102,58,32,97,114,103,117,109,101,110,116,32,108,105,115,116,32,101,110,100,101,100,32,112,114,101,109,97,116,117,114,101,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.945809994 UTC

[section ""data" . Text.Printf.errorMissingArgument_closure" {
     Text.Printf.errorMissingArgument_closure:
         const Text.Printf.errorMissingArgument_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorMissingArgument_entry() //  [R1]
         { info_tbl: [(ccg9m,
                       label: Text.Printf.errorMissingArgument_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg9m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccg9n; else goto ccg9o;
       ccg9n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccg9o: // global
           (_ccg9h::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccg9h::I64 == 0) goto ccg9j; else goto ccg9i;
       ccg9j: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccg9i: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccg9h::I64;
           I64[Sp - 24] = block_ccg9k_info;
           R2 = lvl4_rccbk_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccg9k() //  [R1]
         { info_tbl: [(ccg9k,
                       label: block_ccg9k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg9k: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.952994607 UTC

[section ""cstring" . lvl5_rccbl_bytes" {
     lvl5_rccbl_bytes:
         I8[] [112,114,105,110,116,102,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.955332605 UTC

[section ""data" . Text.Printf.errorBadArgument_closure" {
     Text.Printf.errorBadArgument_closure:
         const Text.Printf.errorBadArgument_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorBadArgument_entry() //  [R1]
         { info_tbl: [(ccg9L,
                       label: Text.Printf.errorBadArgument_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg9L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccg9M; else goto ccg9N;
       ccg9M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccg9N: // global
           (_ccg9G::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccg9G::I64 == 0) goto ccg9I; else goto ccg9H;
       ccg9I: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccg9H: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccg9G::I64;
           I64[Sp - 24] = block_ccg9J_info;
           R2 = lvl5_rccbl_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccg9J() //  [R1]
         { info_tbl: [(ccg9J,
                       label: block_ccg9J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg9J: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.961595808 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble9_bytes" {
     Text.Printf.$fPrintfArgDouble9_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.963720309 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble8_closure" {
     Text.Printf.$fPrintfArgDouble8_closure:
         const Text.Printf.$fPrintfArgDouble8_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble8_entry() //  [R1]
         { info_tbl: [(ccga8,
                       label: Text.Printf.$fPrintfArgDouble8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccga8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccga9; else goto ccgaa;
       ccga9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgaa: // global
           (_ccga5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccga5::I64 == 0) goto ccga7; else goto ccga6;
       ccga7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccga6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccga5::I64;
           R2 = Text.Printf.$fPrintfArgDouble9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.968868339 UTC

[section ""cstring" . lvl6_rccbm_bytes" {
     lvl6_rccbm_bytes:
         I8[] [112,114,105,110,116,102,58,32,105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,105,109,112,111,115,115,105,98,108,101,32,100,102,109,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.971163017 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble7_closure" {
     Text.Printf.$fPrintfArgDouble7_closure:
         const Text.Printf.$fPrintfArgDouble7_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble7_entry() //  [R1]
         { info_tbl: [(ccgar,
                       label: Text.Printf.$fPrintfArgDouble7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgar: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccgas; else goto ccgat;
       ccgas: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgat: // global
           (_ccgam::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgam::I64 == 0) goto ccgao; else goto ccgan;
       ccgao: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgan: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgam::I64;
           I64[Sp - 24] = block_ccgap_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgap() //  [R1]
         { info_tbl: [(ccgap,
                       label: block_ccgap_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgap: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:04.978730022 UTC

[section ""data" . Text.Printf.$w$sdfmt_closure" {
     Text.Printf.$w$sdfmt_closure:
         const Text.Printf.$w$sdfmt_info;
         const 0;
 },
 Text.Printf.$w$sdfmt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgaI: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2,
                                           R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$w$sdfmt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccgaO,
                       label: Text.Printf.$w$sdfmt_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgaO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccgaP; else goto ccgaQ;
       ccgaP: // global
           R1 = Text.Printf.$w$sdfmt_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ccgaQ: // global
           _sccfw::P64 = R5;
           _sccfv::P64 = R4;
           _sccfu::P64 = R3;
           (_sccfB::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(R2);
           (_sccfG::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(R2);
           if (_sccfG::I64 > 1114111) goto ccgb5; else goto ccgdJ;
       ccgb5: // global
           R2 = _sccfG::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccgdJ: // global
           if (_sccfG::I64 < 103) goto ucgdO; else goto ucgdQ;
       ucgdO: // global
           if (_sccfG::I64 < 102) goto ucgdP; else goto ccgcw;
       ucgdP: // global
           if (_sccfG::I64 < 101) goto ccgc6; else goto ccgck;
       ccgck: // global
           I64[Sp - 24] = block_ccgce_info;
           R1 = _sccfw::P64;
           P64[Sp - 16] = _sccfu::P64;
           I64[Sp - 8] = _sccfB::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucgdY; else goto ccgcf;
       ucgdY: // global
           call _ccgce(R1) args: 0, res: 0, upd: 0;
       ccgcf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccgcw: // global
           I64[Sp - 32] = block_ccgcv_info;
           R1 = _sccfv::P64;
           P64[Sp - 24] = _sccfu::P64;
           P64[Sp - 16] = _sccfw::P64;
           I64[Sp - 8] = _sccfB::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucgdZ; else goto ccgcy;
       ucgdZ: // global
           call _ccgcv(R1) args: 0, res: 0, upd: 0;
       ccgcy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucgdQ: // global
           if (_sccfG::I64 >= 104) goto ccgc6; else goto ccgda;
       ccgc6: // global
           R1 = Text.Printf.$fPrintfArgDouble7_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccgda: // global
           I64[Sp - 32] = block_ccgd9_info;
           R1 = _sccfv::P64;
           P64[Sp - 24] = _sccfu::P64;
           P64[Sp - 16] = _sccfw::P64;
           I64[Sp - 8] = _sccfB::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucge0; else goto ccgdc;
       ucge0: // global
           call _ccgd9(R1) args: 0, res: 0, upd: 0;
       ccgdc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgce() //  [R1]
         { info_tbl: [(ccgce,
                       label: block_ccgce_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgce: // global
           _sccfu::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccgcj_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = _sccfu::P64;
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 8;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgcj() //  [R1]
         { info_tbl: [(ccgcj,
                       label: block_ccgcj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgcj: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _ccgcv() //  [R1]
         { info_tbl: [(ccgcv,
                       label: block_ccgcv_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgcv: // global
           _sccfw::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccgcK; else goto ccgcZ;
       ccgcK: // global
           I64[Sp] = block_ccgcC_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto ucge6; else goto ccgcD;
       ucge6: // global
           call _ccgcC(R1) args: 0, res: 0, upd: 0;
       ccgcD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccgcZ: // global
           I64[Sp] = block_ccgcS_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto ucge7; else goto ccgcT;
       ucge7: // global
           call _ccgcS(R1) args: 0, res: 0, upd: 0;
       ccgcT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgcC() //  [R1]
         { info_tbl: [(ccgcC,
                       label: block_ccgcC_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgcC: // global
           I64[Sp + 16] = block_ccgcH_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgcH() //  [R1]
         { info_tbl: [(ccgcH,
                       label: block_ccgcH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgcH: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _ccgcS() //  [R1]
         { info_tbl: [(ccgcS,
                       label: block_ccgcS_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgcS: // global
           I64[Sp + 16] = block_ccgcX_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgcX() //  [R1]
         { info_tbl: [(ccgcX,
                       label: block_ccgcX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgcX: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _ccgd9() //  [R1]
         { info_tbl: [(ccgd9,
                       label: block_ccgd9_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgd9: // global
           _sccfw::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccgdo; else goto ccgdD;
       ccgdo: // global
           I64[Sp] = block_ccgdg_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto ucgea; else goto ccgdh;
       ucgea: // global
           call _ccgdg(R1) args: 0, res: 0, upd: 0;
       ccgdh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccgdD: // global
           I64[Sp] = block_ccgdw_info;
           R1 = _sccfw::P64;
           if (R1 & 7 != 0) goto ucgeb; else goto ccgdx;
       ucgeb: // global
           call _ccgdw(R1) args: 0, res: 0, upd: 0;
       ccgdx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgdg() //  [R1]
         { info_tbl: [(ccgdg,
                       label: block_ccgdg_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgdg: // global
           I64[Sp + 16] = block_ccgdl_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgdl() //  [R1]
         { info_tbl: [(ccgdl,
                       label: block_ccgdl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgdl: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _ccgdw() //  [R1]
         { info_tbl: [(ccgdw,
                       label: block_ccgdw_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgdw: // global
           I64[Sp + 16] = block_ccgdB_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgdB() //  [R1]
         { info_tbl: [(ccgdB,
                       label: block_ccgdB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgdB: // global
           P64[Sp] = R1;
           call _sccfK() args: 0, res: 0, upd: 0;
     }
 },
 _sccfK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccfK: // global
           _sccfL::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto ccgbF; else goto ccgbi;
       ccgbF: // global
           I64[Sp + 8] = block_ccgbE_info;
           R1 = _sccfL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucgee; else goto ccgbG;
       ucgee: // global
           call _ccgbE(R1) args: 0, res: 0, upd: 0;
       ccgbG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccgbi: // global
           I64[Sp + 8] = block_ccgbg_info;
           R3 = _sccfL::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgbE() //  [R1]
         { info_tbl: [(ccgbE,
                       label: block_ccgbE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgbE: // global
           if (R1 & 7 == 1) goto ucgdX; else goto ccgbR;
       ucgdX: // global
           Sp = Sp + 8;
           call _ccgbM() args: 0, res: 0, upd: 0;
       ccgbR: // global
           I64[Sp - 16] = block_ccgbP_info;
           _sccfT::P64 = R1;
           _sccfV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccfV::P64;
           P64[Sp] = _sccfT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucge3; else goto ccgbS;
       ucge3: // global
           call _ccgbP(R1) args: 0, res: 0, upd: 0;
       ccgbS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgbP() //  [R1]
         { info_tbl: [(ccgbP,
                       label: block_ccgbP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgbP: // global
           if (I64[R1 + 7] == 45) goto ccgc0; else goto ccgbZ;
       ccgc0: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccgbZ: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccgbg() //  [R1]
         { info_tbl: [(ccgbg,
                       label: block_ccgbg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgbg: // global
           if (R1 & 7 == 1) goto ucgdW; else goto ccgbt;
       ucgdW: // global
           Sp = Sp + 8;
           call _ccgbM() args: 0, res: 0, upd: 0;
       ccgbt: // global
           I64[Sp - 16] = block_ccgbr_info;
           _sccfN::P64 = R1;
           _sccfP::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccfP::P64;
           P64[Sp] = _sccfN::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucge1; else goto ccgbu;
       ucge1: // global
           call _ccgbr(R1) args: 0, res: 0, upd: 0;
       ccgbu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgbM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgbM: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccgbr() //  [R1]
         { info_tbl: [(ccgbr,
                       label: block_ccgbr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgbr: // global
           if (I64[R1 + 7] == 45) goto ccgbC; else goto ccgbB;
       ccgbC: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccgbB: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.016629072 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat1_closure" {
     Text.Printf.$fPrintfArgFloat1_closure:
         const Text.Printf.$fPrintfArgFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat1_entry() //  [R1]
         { info_tbl: [(ccgfH,
                       label: Text.Printf.$fPrintfArgFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgfH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccgfI; else goto ccgfJ;
       ccgfI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgfJ: // global
           (_ccgfC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgfC::I64 == 0) goto ccgfE; else goto ccgfD;
       ccgfE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgfD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgfC::I64;
           I64[Sp - 24] = block_ccgfF_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgfF() //  [R1]
         { info_tbl: [(ccgfF,
                       label: block_ccgfF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgfF: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.024087312 UTC

[section ""data" . Text.Printf.$w$sdfmt1_closure" {
     Text.Printf.$w$sdfmt1_closure:
         const Text.Printf.$w$sdfmt1_info;
         const 0;
 },
 Text.Printf.$w$sdfmt1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgfY: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$w$sdfmt1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccgg4,
                       label: Text.Printf.$w$sdfmt1_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgg4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccgg5; else goto ccgg6;
       ccgg5: // global
           R1 = Text.Printf.$w$sdfmt1_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ccgg6: // global
           _sccgm::P64 = R5;
           _sccgl::P64 = R4;
           _sccgk::P64 = R3;
           (_sccgr::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(R2);
           (_sccgw::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(R2);
           if (_sccgw::I64 > 1114111) goto ccggl; else goto ccgiZ;
       ccggl: // global
           R2 = _sccgw::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccgiZ: // global
           if (_sccgw::I64 < 103) goto ucgj4; else goto ucgj6;
       ucgj4: // global
           if (_sccgw::I64 < 102) goto ucgj5; else goto ccghM;
       ucgj5: // global
           if (_sccgw::I64 < 101) goto ccghm; else goto ccghA;
       ccghA: // global
           I64[Sp - 24] = block_ccghu_info;
           R1 = _sccgm::P64;
           P64[Sp - 16] = _sccgk::P64;
           I64[Sp - 8] = _sccgr::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucgje; else goto ccghv;
       ucgje: // global
           call _ccghu(R1) args: 0, res: 0, upd: 0;
       ccghv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccghM: // global
           I64[Sp - 32] = block_ccghL_info;
           R1 = _sccgl::P64;
           P64[Sp - 24] = _sccgk::P64;
           P64[Sp - 16] = _sccgm::P64;
           I64[Sp - 8] = _sccgr::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucgjf; else goto ccghO;
       ucgjf: // global
           call _ccghL(R1) args: 0, res: 0, upd: 0;
       ccghO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucgj6: // global
           if (_sccgw::I64 >= 104) goto ccghm; else goto ccgiq;
       ccghm: // global
           R1 = Text.Printf.$fPrintfArgFloat1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccgiq: // global
           I64[Sp - 32] = block_ccgip_info;
           R1 = _sccgl::P64;
           P64[Sp - 24] = _sccgk::P64;
           P64[Sp - 16] = _sccgm::P64;
           I64[Sp - 8] = _sccgr::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucgjg; else goto ccgis;
       ucgjg: // global
           call _ccgip(R1) args: 0, res: 0, upd: 0;
       ccgis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccghu() //  [R1]
         { info_tbl: [(ccghu,
                       label: block_ccghu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccghu: // global
           _sccgk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccghz_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = _sccgk::P64;
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 8;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccghz() //  [R1]
         { info_tbl: [(ccghz,
                       label: block_ccghz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccghz: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _ccghL() //  [R1]
         { info_tbl: [(ccghL,
                       label: block_ccghL_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccghL: // global
           _sccgm::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccgi0; else goto ccgif;
       ccgi0: // global
           I64[Sp] = block_ccghS_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto ucgjm; else goto ccghT;
       ucgjm: // global
           call _ccghS(R1) args: 0, res: 0, upd: 0;
       ccghT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccgif: // global
           I64[Sp] = block_ccgi8_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto ucgjn; else goto ccgi9;
       ucgjn: // global
           call _ccgi8(R1) args: 0, res: 0, upd: 0;
       ccgi9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccghS() //  [R1]
         { info_tbl: [(ccghS,
                       label: block_ccghS_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccghS: // global
           I64[Sp + 16] = block_ccghX_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccghX() //  [R1]
         { info_tbl: [(ccghX,
                       label: block_ccghX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccghX: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _ccgi8() //  [R1]
         { info_tbl: [(ccgi8,
                       label: block_ccgi8_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgi8: // global
           I64[Sp + 16] = block_ccgid_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgid() //  [R1]
         { info_tbl: [(ccgid,
                       label: block_ccgid_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgid: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _ccgip() //  [R1]
         { info_tbl: [(ccgip,
                       label: block_ccgip_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgip: // global
           _sccgm::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccgiE; else goto ccgiT;
       ccgiE: // global
           I64[Sp] = block_ccgiw_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto ucgjq; else goto ccgix;
       ucgjq: // global
           call _ccgiw(R1) args: 0, res: 0, upd: 0;
       ccgix: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccgiT: // global
           I64[Sp] = block_ccgiM_info;
           R1 = _sccgm::P64;
           if (R1 & 7 != 0) goto ucgjr; else goto ccgiN;
       ucgjr: // global
           call _ccgiM(R1) args: 0, res: 0, upd: 0;
       ccgiN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgiw() //  [R1]
         { info_tbl: [(ccgiw,
                       label: block_ccgiw_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgiw: // global
           I64[Sp + 16] = block_ccgiB_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgiB() //  [R1]
         { info_tbl: [(ccgiB,
                       label: block_ccgiB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgiB: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _ccgiM() //  [R1]
         { info_tbl: [(ccgiM,
                       label: block_ccgiM_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgiM: // global
           I64[Sp + 16] = block_ccgiR_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgiR() //  [R1]
         { info_tbl: [(ccgiR,
                       label: block_ccgiR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgiR: // global
           P64[Sp] = R1;
           call _sccgA() args: 0, res: 0, upd: 0;
     }
 },
 _sccgA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccgA: // global
           _sccgB::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto ccggV; else goto ccggy;
       ccggV: // global
           I64[Sp + 8] = block_ccggU_info;
           R1 = _sccgB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucgju; else goto ccggW;
       ucgju: // global
           call _ccggU(R1) args: 0, res: 0, upd: 0;
       ccggW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccggy: // global
           I64[Sp + 8] = block_ccggw_info;
           R3 = _sccgB::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccggU() //  [R1]
         { info_tbl: [(ccggU,
                       label: block_ccggU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccggU: // global
           if (R1 & 7 == 1) goto ucgjd; else goto ccgh7;
       ucgjd: // global
           Sp = Sp + 8;
           call _ccgh2() args: 0, res: 0, upd: 0;
       ccgh7: // global
           I64[Sp - 16] = block_ccgh5_info;
           _sccgJ::P64 = R1;
           _sccgL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccgL::P64;
           P64[Sp] = _sccgJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucgjj; else goto ccgh8;
       ucgjj: // global
           call _ccgh5(R1) args: 0, res: 0, upd: 0;
       ccgh8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgh5() //  [R1]
         { info_tbl: [(ccgh5,
                       label: block_ccgh5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgh5: // global
           if (I64[R1 + 7] == 45) goto ccghg; else goto ccghf;
       ccghg: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccghf: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccggw() //  [R1]
         { info_tbl: [(ccggw,
                       label: block_ccggw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccggw: // global
           if (R1 & 7 == 1) goto ucgjc; else goto ccggJ;
       ucgjc: // global
           Sp = Sp + 8;
           call _ccgh2() args: 0, res: 0, upd: 0;
       ccggJ: // global
           I64[Sp - 16] = block_ccggH_info;
           _sccgD::P64 = R1;
           _sccgF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccgF::P64;
           P64[Sp] = _sccgD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucgjh; else goto ccggK;
       ucgjh: // global
           call _ccggH(R1) args: 0, res: 0, upd: 0;
       ccggK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgh2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgh2: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccggH() //  [R1]
         { info_tbl: [(ccggH,
                       label: block_ccggH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccggH: // global
           if (I64[R1 + 7] == 45) goto ccggS; else goto ccggR;
       ccggS: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccggR: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.061007553 UTC

[section ""data" . Text.Printf.formatRealFloat1_closure" {
     Text.Printf.formatRealFloat1_closure:
         const Text.Printf.formatRealFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.formatRealFloat1_entry() //  [R1]
         { info_tbl: [(ccgkX,
                       label: Text.Printf.formatRealFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgkX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccgkY; else goto ccgkZ;
       ccgkY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgkZ: // global
           (_ccgkS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgkS::I64 == 0) goto ccgkU; else goto ccgkT;
       ccgkU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgkT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgkS::I64;
           I64[Sp - 24] = block_ccgkV_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgkV() //  [R1]
         { info_tbl: [(ccgkV,
                       label: block_ccgkV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgkV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.068349319 UTC

[section ""data" . Text.Printf.$wdfmt_closure" {
     Text.Printf.$wdfmt_closure:
         const Text.Printf.$wdfmt_info;
         const 0;
 },
 Text.Printf.$wdfmt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgle: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2,
                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wdfmt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccglk,
                       label: Text.Printf.$wdfmt_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccglk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccgll; else goto ccglm;
       ccgll: // global
           R1 = Text.Printf.$wdfmt_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       ccglm: // global
           _scchd::P64 = R6;
           _scchc::P64 = R5;
           _scchb::P64 = R4;
           _sccha::I64 = R3;
           _ccglp::I64 = R3;
           (_scchi::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(_ccglp::I64);
           (_scchn::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(_sccha::I64);
           if (_scchn::I64 > 1114111) goto ccglB; else goto ccgnL;
       ccglB: // global
           R2 = _scchn::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccgnL: // global
           if (_scchn::I64 < 103) goto ucgnQ; else goto ucgnS;
       ucgnQ: // global
           if (_scchn::I64 < 102) goto ucgnR; else goto ccgmW;
       ucgnR: // global
           if (_scchn::I64 < 101) goto ccgmC; else goto ccgmL;
       ccgmL: // global
           I64[Sp - 16] = block_ccgmK_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFExponent_closure+1;
           R2 = R2;
           I64[Sp - 8] = _scchi::I64;
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccgmW: // global
           I64[Sp - 40] = block_ccgmV_info;
           R1 = _scchc::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = _scchb::P64;
           P64[Sp - 16] = _scchd::P64;
           I64[Sp - 8] = _scchi::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucgo0; else goto ccgmY;
       ucgo0: // global
           call _ccgmV(R1) args: 0, res: 0, upd: 0;
       ccgmY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucgnS: // global
           if (_scchn::I64 >= 104) goto ccgmC; else goto ccgno;
       ccgmC: // global
           R1 = Text.Printf.formatRealFloat1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccgno: // global
           I64[Sp - 40] = block_ccgnn_info;
           R1 = _scchc::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = _scchb::P64;
           P64[Sp - 16] = _scchd::P64;
           I64[Sp - 8] = _scchi::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucgo1; else goto ccgnq;
       ucgo1: // global
           call _ccgnn(R1) args: 0, res: 0, upd: 0;
       ccgnq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgmK() //  [R1]
         { info_tbl: [(ccgmK,
                       label: block_ccgmK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgmK: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _ccgmV() //  [R1]
         { info_tbl: [(ccgmV,
                       label: block_ccgmV_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgmV: // global
           _scch9::P64 = P64[Sp + 8];
           _scchb::P64 = P64[Sp + 16];
           _scchd::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccgn5; else goto ccgne;
       ccgn5: // global
           I64[Sp + 24] = block_ccgn2_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccgne: // global
           I64[Sp + 24] = block_ccgnc_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.True_closure+2;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgn2() //  [R1]
         { info_tbl: [(ccgn2,
                       label: block_ccgn2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgn2: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _ccgnc() //  [R1]
         { info_tbl: [(ccgnc,
                       label: block_ccgnc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgnc: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _ccgnn() //  [R1]
         { info_tbl: [(ccgnn,
                       label: block_ccgnn_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgnn: // global
           _scch9::P64 = P64[Sp + 8];
           _scchb::P64 = P64[Sp + 16];
           _scchd::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccgnx; else goto ccgnG;
       ccgnx: // global
           I64[Sp + 24] = block_ccgnu_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccgnG: // global
           I64[Sp + 24] = block_ccgnE_info;
           R6 = _scchd::P64;
           R5 = GHC.Types.True_closure+2;
           R4 = _scchb::P64;
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = _scch9::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgnu() //  [R1]
         { info_tbl: [(ccgnu,
                       label: block_ccgnu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgnu: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _ccgnE() //  [R1]
         { info_tbl: [(ccgnE,
                       label: block_ccgnE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgnE: // global
           P64[Sp] = R1;
           call _scchr() args: 0, res: 0, upd: 0;
     }
 },
 _scchr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scchr: // global
           _scchs::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto ccgmb; else goto ccglO;
       ccgmb: // global
           I64[Sp + 8] = block_ccgma_info;
           R1 = _scchs::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucgob; else goto ccgmc;
       ucgob: // global
           call _ccgma(R1) args: 0, res: 0, upd: 0;
       ccgmc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccglO: // global
           I64[Sp + 8] = block_ccglM_info;
           R3 = _scchs::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgma() //  [R1]
         { info_tbl: [(ccgma,
                       label: block_ccgma_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgma: // global
           if (R1 & 7 == 1) goto ucgnZ; else goto ccgmn;
       ucgnZ: // global
           Sp = Sp + 8;
           call _ccgmi() args: 0, res: 0, upd: 0;
       ccgmn: // global
           I64[Sp - 16] = block_ccgml_info;
           _scchA::P64 = R1;
           _scchC::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scchC::P64;
           P64[Sp] = _scchA::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucgo4; else goto ccgmo;
       ucgo4: // global
           call _ccgml(R1) args: 0, res: 0, upd: 0;
       ccgmo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgml() //  [R1]
         { info_tbl: [(ccgml,
                       label: block_ccgml_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgml: // global
           if (I64[R1 + 7] == 45) goto ccgmw; else goto ccgmv;
       ccgmw: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccgmv: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccglM() //  [R1]
         { info_tbl: [(ccglM,
                       label: block_ccglM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccglM: // global
           if (R1 & 7 == 1) goto ucgnY; else goto ccglZ;
       ucgnY: // global
           Sp = Sp + 8;
           call _ccgmi() args: 0, res: 0, upd: 0;
       ccglZ: // global
           I64[Sp - 16] = block_ccglX_info;
           _scchu::P64 = R1;
           _scchw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scchw::P64;
           P64[Sp] = _scchu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucgo2; else goto ccgm0;
       ucgo2: // global
           call _ccglX(R1) args: 0, res: 0, upd: 0;
       ccgm0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgmi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgmi: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccglX() //  [R1]
         { info_tbl: [(ccglX,
                       label: block_ccglX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccglX: // global
           if (I64[R1 + 7] == 45) goto ccgm8; else goto ccgm7;
       ccgm8: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccgm7: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.097679525 UTC

[section ""cstring" . Text.Printf.$trModule4_bytes" {
     Text.Printf.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.099318896 UTC

[section ""data" . Text.Printf.$trModule3_closure" {
     Text.Printf.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.100903219 UTC

[section ""cstring" . Text.Printf.$trModule2_bytes" {
     Text.Printf.$trModule2_bytes:
         I8[] [84,101,120,116,46,80,114,105,110,116,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.102864372 UTC

[section ""data" . Text.Printf.$trModule1_closure" {
     Text.Printf.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.104521103 UTC

[section ""data" . Text.Printf.$trModule_closure" {
     Text.Printf.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Text.Printf.$trModule3_closure+1;
         const Text.Printf.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.106296259 UTC

[section ""data" . $krep_rccbn_closure" {
     $krep_rccbn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.107983877 UTC

[section ""data" . $krep1_rccbo_closure" {
     $krep1_rccbo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.110253545 UTC

[section ""data" . $krep2_rccbp_closure" {
     $krep2_rccbp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.111945367 UTC

[section ""data" . $krep3_rccbq_closure" {
     $krep3_rccbq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.113762041 UTC

[section ""data" . $krep4_rccbr_closure" {
     $krep4_rccbr_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.115528469 UTC

[section ""data" . $krep5_rccbs_closure" {
     $krep5_rccbs_closure:
         const :_con_info;
         const $krep1_rccbo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.117320186 UTC

[section ""data" . $krep6_rccbt_closure" {
     $krep6_rccbt_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep5_rccbs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.119084112 UTC

[section ""data" . $krep7_rccbu_closure" {
     $krep7_rccbu_closure:
         const :_con_info;
         const $krep3_rccbq_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.120808559 UTC

[section ""data" . $krep8_rccbv_closure" {
     $krep8_rccbv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep7_rccbu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.12294085 UTC

[section ""data" . $krep9_rccbw_closure" {
     $krep9_rccbw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep8_rccbv_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.124669494 UTC

[section ""data" . Text.Printf.$tcHPrintfType1_closure" {
     Text.Printf.$tcHPrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep4_rccbr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.126422836 UTC

[section ""data" . $krep10_rccbx_closure" {
     $krep10_rccbx_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.128150612 UTC

[section ""data" . $krep11_rccby_closure" {
     $krep11_rccby_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep3_rccbq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.129850927 UTC

[section ""data" . $krep12_rccbz_closure" {
     $krep12_rccbz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep10_rccbx_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.131565479 UTC

[section ""cstring" . Text.Printf.$tcIsChar2_bytes" {
     Text.Printf.$tcIsChar2_bytes:
         I8[] [73,115,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.133220331 UTC

[section ""data" . Text.Printf.$tcIsChar1_closure" {
     Text.Printf.$tcIsChar1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcIsChar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.135527183 UTC

[section ""data" . Text.Printf.$tcIsChar_closure" {
     Text.Printf.$tcIsChar_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcIsChar1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 660225335504909605;
         const 5800397900948792736;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.13796646 UTC

[section ""data" . $krep13_rccbA_closure" {
     $krep13_rccbA_closure:
         const :_con_info;
         const $krep10_rccbx_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.13968854 UTC

[section ""data" . $krep14_rccbB_closure" {
     $krep14_rccbB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcIsChar_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.141452157 UTC

[section ""data" . $krep15_rccbC_closure" {
     $krep15_rccbC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_rccbz_closure+4;
         const $krep14_rccbB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.14314348 UTC

[section ""data" . Text.Printf.$tc'C:IsChar1_closure" {
     Text.Printf.$tc'C:IsChar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rccby_closure+4;
         const $krep15_rccbC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.144725555 UTC

[section ""cstring" . Text.Printf.$tc'C:IsChar3_bytes" {
     Text.Printf.$tc'C:IsChar3_bytes:
         I8[] [39,67,58,73,115,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.14636366 UTC

[section ""data" . Text.Printf.$tc'C:IsChar2_closure" {
     Text.Printf.$tc'C:IsChar2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:IsChar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.148048562 UTC

[section ""data" . Text.Printf.$tc'C:IsChar_closure" {
     Text.Printf.$tc'C:IsChar_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:IsChar2_closure+1;
         const Text.Printf.$tc'C:IsChar1_closure+4;
         const 15586488259906363003;
         const 17643381548147423706;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.149903353 UTC

[section ""cstring" . Text.Printf.$tcFormatAdjustment2_bytes" {
     Text.Printf.$tcFormatAdjustment2_bytes:
         I8[] [70,111,114,109,97,116,65,100,106,117,115,116,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.151621625 UTC

[section ""data" . Text.Printf.$tcFormatAdjustment1_closure" {
     Text.Printf.$tcFormatAdjustment1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatAdjustment2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.153343966 UTC

[section ""data" . Text.Printf.$tcFormatAdjustment_closure" {
     Text.Printf.$tcFormatAdjustment_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatAdjustment1_closure+1;
         const GHC.Types.krep$*_closure;
         const 7532892403054408380;
         const 17299592949916286280;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.155124319 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust1_closure" {
     Text.Printf.$tc'LeftAdjust1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatAdjustment_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.156799521 UTC

[section ""cstring" . Text.Printf.$tc'LeftAdjust3_bytes" {
     Text.Printf.$tc'LeftAdjust3_bytes:
         I8[] [39,76,101,102,116,65,100,106,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.158543762 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust2_closure" {
     Text.Printf.$tc'LeftAdjust2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'LeftAdjust3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.160751786 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust_closure" {
     Text.Printf.$tc'LeftAdjust_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'LeftAdjust2_closure+1;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const 3724221440131574524;
         const 12430068224974793646;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.16304305 UTC

[section ""cstring" . Text.Printf.$tc'ZeroPad2_bytes" {
     Text.Printf.$tc'ZeroPad2_bytes:
         I8[] [39,90,101,114,111,80,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.164691532 UTC

[section ""data" . Text.Printf.$tc'ZeroPad1_closure" {
     Text.Printf.$tc'ZeroPad1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'ZeroPad2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.166413293 UTC

[section ""data" . Text.Printf.$tc'ZeroPad_closure" {
     Text.Printf.$tc'ZeroPad_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'ZeroPad1_closure+1;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const 4688343247861108158;
         const 7307113320833774212;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.168282409 UTC

[section ""data" . $krep16_rccbD_closure" {
     $krep16_rccbD_closure:
         const :_con_info;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.170111283 UTC

[section ""data" . $krep17_rccbE_closure" {
     $krep17_rccbE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep16_rccbD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.171847717 UTC

[section ""cstring" . Text.Printf.$tcFormatSign2_bytes" {
     Text.Printf.$tcFormatSign2_bytes:
         I8[] [70,111,114,109,97,116,83,105,103,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.173526193 UTC

[section ""data" . Text.Printf.$tcFormatSign1_closure" {
     Text.Printf.$tcFormatSign1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatSign2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.175192744 UTC

[section ""data" . Text.Printf.$tcFormatSign_closure" {
     Text.Printf.$tcFormatSign_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatSign1_closure+1;
         const GHC.Types.krep$*_closure;
         const 35986971025498593;
         const 9833165860459639351;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.176963941 UTC

[section ""data" . Text.Printf.$tc'SignPlus1_closure" {
     Text.Printf.$tc'SignPlus1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatSign_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.179447461 UTC

[section ""cstring" . Text.Printf.$tc'SignPlus3_bytes" {
     Text.Printf.$tc'SignPlus3_bytes:
         I8[] [39,83,105,103,110,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.181149851 UTC

[section ""data" . Text.Printf.$tc'SignPlus2_closure" {
     Text.Printf.$tc'SignPlus2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'SignPlus3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.1828899 UTC

[section ""data" . Text.Printf.$tc'SignPlus_closure" {
     Text.Printf.$tc'SignPlus_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'SignPlus2_closure+1;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const 18302065795158432479;
         const 11830941225366619964;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.184658718 UTC

[section ""cstring" . Text.Printf.$tc'SignSpace2_bytes" {
     Text.Printf.$tc'SignSpace2_bytes:
         I8[] [39,83,105,103,110,83,112,97,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.186885547 UTC

[section ""data" . Text.Printf.$tc'SignSpace1_closure" {
     Text.Printf.$tc'SignSpace1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'SignSpace2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.188594692 UTC

[section ""data" . Text.Printf.$tc'SignSpace_closure" {
     Text.Printf.$tc'SignSpace_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'SignSpace1_closure+1;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const 111286303843533919;
         const 13624428119758319457;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.190408552 UTC

[section ""data" . $krep18_rccbF_closure" {
     $krep18_rccbF_closure:
         const :_con_info;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.192177296 UTC

[section ""data" . $krep19_rccbG_closure" {
     $krep19_rccbG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep18_rccbF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.19440488 UTC

[section ""cstring" . Text.Printf.$tcFieldFormat2_bytes" {
     Text.Printf.$tcFieldFormat2_bytes:
         I8[] [70,105,101,108,100,70,111,114,109,97,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.196099772 UTC

[section ""data" . Text.Printf.$tcFieldFormat1_closure" {
     Text.Printf.$tcFieldFormat1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFieldFormat2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.197770161 UTC

[section ""data" . Text.Printf.$tcFieldFormat_closure" {
     Text.Printf.$tcFieldFormat_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFieldFormat1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12330325036165183082;
         const 5846211506648458401;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.199596936 UTC

[section ""data" . $krep20_rccbH_closure" {
     $krep20_rccbH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFieldFormat_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.201225858 UTC

[section ""data" . $krep21_rccbI_closure" {
     $krep21_rccbI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep20_rccbH_closure+1;
         const $krep9_rccbw_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.202932966 UTC

[section ""data" . $krep22_rccbJ_closure" {
     $krep22_rccbJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep21_rccbI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.20464522 UTC

[section ""data" . $krep23_rccbK_closure" {
     $krep23_rccbK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep20_rccbH_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.206804169 UTC

[section ""data" . $krep24_rccbL_closure" {
     $krep24_rccbL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep23_rccbK_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.20847669 UTC

[section ""data" . $krep25_rccbM_closure" {
     $krep25_rccbM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rccbn_closure+1;
         const $krep24_rccbL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.210245384 UTC

[section ""data" . $krep26_rccbN_closure" {
     $krep26_rccbN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep19_rccbG_closure+1;
         const $krep25_rccbM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.21239996 UTC

[section ""data" . $krep27_rccbO_closure" {
     $krep27_rccbO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_rccbE_closure+1;
         const $krep26_rccbN_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.214202939 UTC

[section ""data" . $krep28_rccbP_closure" {
     $krep28_rccbP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rccbt_closure+1;
         const $krep27_rccbO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.215862296 UTC

[section ""data" . Text.Printf.$tc'FieldFormat1_closure" {
     Text.Printf.$tc'FieldFormat1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rccbt_closure+1;
         const $krep28_rccbP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.217661974 UTC

[section ""cstring" . Text.Printf.$tc'FieldFormat3_bytes" {
     Text.Printf.$tc'FieldFormat3_bytes:
         I8[] [39,70,105,101,108,100,70,111,114,109,97,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.219274537 UTC

[section ""data" . Text.Printf.$tc'FieldFormat2_closure" {
     Text.Printf.$tc'FieldFormat2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'FieldFormat3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.220923708 UTC

[section ""data" . Text.Printf.$tc'FieldFormat_closure" {
     Text.Printf.$tc'FieldFormat_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'FieldFormat2_closure+1;
         const Text.Printf.$tc'FieldFormat1_closure+4;
         const 11348432599023007686;
         const 6814357301696130957;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.223098432 UTC

[section ""cstring" . Text.Printf.$tcFormatParse2_bytes" {
     Text.Printf.$tcFormatParse2_bytes:
         I8[] [70,111,114,109,97,116,80,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.224744749 UTC

[section ""data" . Text.Printf.$tcFormatParse1_closure" {
     Text.Printf.$tcFormatParse1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatParse2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.226472953 UTC

[section ""data" . Text.Printf.$tcFormatParse_closure" {
     Text.Printf.$tcFormatParse_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatParse1_closure+1;
         const GHC.Types.krep$*_closure;
         const 5517048358589873764;
         const 8326725038359313810;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.228330416 UTC

[section ""data" . $krep29_rccbQ_closure" {
     $krep29_rccbQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatParse_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.230085619 UTC

[section ""data" . $krep30_rccbR_closure" {
     $krep30_rccbR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep29_rccbQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.231789175 UTC

[section ""data" . $krep31_rccbS_closure" {
     $krep31_rccbS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep30_rccbR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.233970703 UTC

[section ""data" . $krep32_rccbT_closure" {
     $krep32_rccbT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep30_rccbR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.235713023 UTC

[section ""data" . Text.Printf.$tc'FormatParse1_closure" {
     Text.Printf.$tc'FormatParse1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep32_rccbT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.237410223 UTC

[section ""cstring" . Text.Printf.$tc'FormatParse3_bytes" {
     Text.Printf.$tc'FormatParse3_bytes:
         I8[] [39,70,111,114,109,97,116,80,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.239600592 UTC

[section ""data" . Text.Printf.$tc'FormatParse2_closure" {
     Text.Printf.$tc'FormatParse2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'FormatParse3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.241275176 UTC

[section ""data" . Text.Printf.$tc'FormatParse_closure" {
     Text.Printf.$tc'FormatParse_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'FormatParse2_closure+1;
         const Text.Printf.$tc'FormatParse1_closure+4;
         const 549767054447046648;
         const 1116614444935710689;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.243093249 UTC

[section ""data" . $krep33_rccbU_closure" {
     $krep33_rccbU_closure:
         const :_con_info;
         const $krep21_rccbI_closure+4;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.244748685 UTC

[section ""data" . $krep34_rccbV_closure" {
     $krep34_rccbV_closure:
         const :_con_info;
         const $krep30_rccbR_closure+4;
         const $krep33_rccbU_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.246415245 UTC

[section ""data" . $krep35_rccbW_closure" {
     $krep35_rccbW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep34_rccbV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.248125655 UTC

[section ""data" . $krep36_rccbX_closure" {
     $krep36_rccbX_closure:
         const :_con_info;
         const $krep35_rccbW_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.249814103 UTC

[section ""data" . $krep37_rccbY_closure" {
     $krep37_rccbY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep36_rccbX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.251512887 UTC

[section ""data" . $krep38_rccbZ_closure" {
     $krep38_rccbZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep37_rccbY_closure+1;
         const $krep10_rccbx_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.253301612 UTC

[section ""data" . $krep39_rccc0_closure" {
     $krep39_rccc0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep38_rccbZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.255005676 UTC

[section ""data" . $krep40_rccc1_closure" {
     $krep40_rccc1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rccbp_closure+1;
         const $krep39_rccc0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.256681182 UTC

[section ""cstring" . Text.Printf.$tcPrintfArg2_bytes" {
     Text.Printf.$tcPrintfArg2_bytes:
         I8[] [80,114,105,110,116,102,65,114,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.258712426 UTC

[section ""data" . Text.Printf.$tcPrintfArg1_closure" {
     Text.Printf.$tcPrintfArg1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcPrintfArg2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.260406985 UTC

[section ""data" . Text.Printf.$tcPrintfArg_closure" {
     Text.Printf.$tcPrintfArg_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcPrintfArg1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 14684532792197610005;
         const 5760551473172190061;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.262220626 UTC

[section ""data" . $krep41_rccc2_closure" {
     $krep41_rccc2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcPrintfArg_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.264478879 UTC

[section ""data" . $krep42_rccc3_closure" {
     $krep42_rccc3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep31_rccbS_closure+4;
         const $krep41_rccc2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.266226821 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg1_closure" {
     Text.Printf.$tc'C:PrintfArg1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep22_rccbJ_closure+4;
         const $krep42_rccc3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.267984031 UTC

[section ""cstring" . Text.Printf.$tc'C:PrintfArg3_bytes" {
     Text.Printf.$tc'C:PrintfArg3_bytes:
         I8[] [39,67,58,80,114,105,110,116,102,65,114,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.27047859 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg2_closure" {
     Text.Printf.$tc'C:PrintfArg2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:PrintfArg3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.272186802 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg_closure" {
     Text.Printf.$tc'C:PrintfArg_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:PrintfArg2_closure+1;
         const Text.Printf.$tc'C:PrintfArg1_closure+4;
         const 11923342243699112506;
         const 8346787778082712340;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.274095226 UTC

[section ""cstring" . Text.Printf.$tcHPrintfType3_bytes" {
     Text.Printf.$tcHPrintfType3_bytes:
         I8[] [72,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.275754914 UTC

[section ""data" . Text.Printf.$tcHPrintfType2_closure" {
     Text.Printf.$tcHPrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcHPrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.277465964 UTC

[section ""data" . Text.Printf.$tcHPrintfType_closure" {
     Text.Printf.$tcHPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcHPrintfType2_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 13104883804062546050;
         const 15477829653093370802;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.279393689 UTC

[section ""data" . $krep43_rccc4_closure" {
     $krep43_rccc4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcHPrintfType_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.281102781 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType1_closure" {
     Text.Printf.$tc'C:HPrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep40_rccc1_closure+4;
         const $krep43_rccc4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.282907779 UTC

[section ""cstring" . Text.Printf.$tc'C:HPrintfType3_bytes" {
     Text.Printf.$tc'C:HPrintfType3_bytes:
         I8[] [39,67,58,72,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.284589779 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType2_closure" {
     Text.Printf.$tc'C:HPrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:HPrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.286689109 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType_closure" {
     Text.Printf.$tc'C:HPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:HPrintfType2_closure+1;
         const Text.Printf.$tc'C:HPrintfType1_closure+4;
         const 16716104921226462095;
         const 4043378586122981700;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.288528913 UTC

[section ""cstring" . Text.Printf.$tcPrintfType2_bytes" {
     Text.Printf.$tcPrintfType2_bytes:
         I8[] [80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.290754691 UTC

[section ""data" . Text.Printf.$tcPrintfType1_closure" {
     Text.Printf.$tcPrintfType1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcPrintfType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.29247362 UTC

[section ""data" . Text.Printf.$tcPrintfType_closure" {
     Text.Printf.$tcPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcPrintfType1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 16100185319445667829;
         const 10371264040433388740;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.294339572 UTC

[section ""data" . $krep44_rccc5_closure" {
     $krep44_rccc5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcPrintfType_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.296009303 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType1_closure" {
     Text.Printf.$tc'C:PrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep39_rccc0_closure+4;
         const $krep44_rccc5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.298215035 UTC

[section ""cstring" . Text.Printf.$tc'C:PrintfType3_bytes" {
     Text.Printf.$tc'C:PrintfType3_bytes:
         I8[] [39,67,58,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.299758081 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType2_closure" {
     Text.Printf.$tc'C:PrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:PrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.301467159 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType_closure" {
     Text.Printf.$tc'C:PrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:PrintfType2_closure+1;
         const Text.Printf.$tc'C:PrintfType1_closure+4;
         const 6199067271817529220;
         const 10070277982064886839;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.303306202 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar24_bytes" {
     Text.Printf.$fPrintfArgChar24_bytes:
         I8[] [104,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.30531956 UTC

[section ""data" . Text.Printf.$fPrintfArgChar23_closure" {
     Text.Printf.$fPrintfArgChar23_closure:
         const Text.Printf.$fPrintfArgChar23_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar23_entry() //  [R1]
         { info_tbl: [(ccgr8,
                       label: Text.Printf.$fPrintfArgChar23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgr8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgr9; else goto ccgra;
       ccgr9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgra: // global
           (_ccgr5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgr5::I64 == 0) goto ccgr7; else goto ccgr6;
       ccgr7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgr6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgr5::I64;
           R2 = Text.Printf.$fPrintfArgChar24_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.309218901 UTC

[section ""data" . sat_scchP_closure" {
     sat_scchP_closure:
         const GHC.Types.I#_con_info;
         const 128;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.311186647 UTC

[section ""data" . sat_scchQ_closure" {
     sat_scchQ_closure:
         const :_con_info;
         const sat_scchP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.313103769 UTC

[section ""data" . Text.Printf.$fPrintfArgChar22_closure" {
     Text.Printf.$fPrintfArgChar22_closure:
         const Text.Printf.$fPrintfArgChar22_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar22_entry() //  [R1]
         { info_tbl: [(ccgrq,
                       label: Text.Printf.$fPrintfArgChar22_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgrq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgrr; else goto ccgrs;
       ccgrr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgrs: // global
           (_ccgrn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgrn::I64 == 0) goto ccgrp; else goto ccgro;
       ccgrp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgro: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgrn::I64;
           R3 = sat_scchQ_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.317089578 UTC

[section ""data" . Text.Printf.$fPrintfArgChar21_closure" {
     Text.Printf.$fPrintfArgChar21_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar23_closure;
         const Text.Printf.$fPrintfArgChar22_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.319622844 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar20_bytes" {
     Text.Printf.$fPrintfArgChar20_bytes:
         I8[] [104]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.321487143 UTC

[section ""data" . Text.Printf.$fPrintfArgChar19_closure" {
     Text.Printf.$fPrintfArgChar19_closure:
         const Text.Printf.$fPrintfArgChar19_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar19_entry() //  [R1]
         { info_tbl: [(ccgrI,
                       label: Text.Printf.$fPrintfArgChar19_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgrI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgrJ; else goto ccgrK;
       ccgrJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgrK: // global
           (_ccgrF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgrF::I64 == 0) goto ccgrH; else goto ccgrG;
       ccgrH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgrG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgrF::I64;
           R2 = Text.Printf.$fPrintfArgChar20_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.325430848 UTC

[section ""data" . sat_scchR_closure" {
     sat_scchR_closure:
         const GHC.Types.I#_con_info;
         const 32768;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.327101122 UTC

[section ""data" . sat_scchS_closure" {
     sat_scchS_closure:
         const :_con_info;
         const sat_scchR_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.328998485 UTC

[section ""data" . Text.Printf.$fPrintfArgChar18_closure" {
     Text.Printf.$fPrintfArgChar18_closure:
         const Text.Printf.$fPrintfArgChar18_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar18_entry() //  [R1]
         { info_tbl: [(ccgs0,
                       label: Text.Printf.$fPrintfArgChar18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgs0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgs1; else goto ccgs2;
       ccgs1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgs2: // global
           (_ccgrX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgrX::I64 == 0) goto ccgrZ; else goto ccgrY;
       ccgrZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgrY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgrX::I64;
           R3 = sat_scchS_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.332935194 UTC

[section ""data" . Text.Printf.$fPrintfArgChar17_closure" {
     Text.Printf.$fPrintfArgChar17_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar19_closure;
         const Text.Printf.$fPrintfArgChar18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.334542432 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar16_bytes" {
     Text.Printf.$fPrintfArgChar16_bytes:
         I8[] [108]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.336396215 UTC

[section ""data" . Text.Printf.$fPrintfArgChar15_closure" {
     Text.Printf.$fPrintfArgChar15_closure:
         const Text.Printf.$fPrintfArgChar15_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar15_entry() //  [R1]
         { info_tbl: [(ccgsi,
                       label: Text.Printf.$fPrintfArgChar15_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgsi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgsj; else goto ccgsk;
       ccgsj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgsk: // global
           (_ccgsf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgsf::I64 == 0) goto ccgsh; else goto ccgsg;
       ccgsh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgsg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgsf::I64;
           R2 = Text.Printf.$fPrintfArgChar16_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.340622973 UTC

[section ""data" . sat_scchU_closure" {
     sat_scchU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.342351362 UTC

[section ""data" . sat_scchV_closure" {
     sat_scchV_closure:
         const :_con_info;
         const sat_scchU_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.344015754 UTC

[section ""data" . sat_scchT_closure" {
     sat_scchT_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.345768248 UTC

[section ""data" . sat_scchW_closure" {
     sat_scchW_closure:
         const :_con_info;
         const sat_scchT_closure+1;
         const sat_scchV_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.348264534 UTC

[section ""data" . Text.Printf.$fPrintfArgChar14_closure" {
     Text.Printf.$fPrintfArgChar14_closure:
         const Text.Printf.$fPrintfArgChar14_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar14_entry() //  [R1]
         { info_tbl: [(ccgsC,
                       label: Text.Printf.$fPrintfArgChar14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgsC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgsD; else goto ccgsE;
       ccgsD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgsE: // global
           (_ccgsz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgsz::I64 == 0) goto ccgsB; else goto ccgsA;
       ccgsB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgsA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgsz::I64;
           R3 = sat_scchW_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.352384853 UTC

[section ""data" . Text.Printf.$fPrintfArgChar13_closure" {
     Text.Printf.$fPrintfArgChar13_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar15_closure;
         const Text.Printf.$fPrintfArgChar14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.354185527 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar12_bytes" {
     Text.Printf.$fPrintfArgChar12_bytes:
         I8[] [108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.356088474 UTC

[section ""data" . Text.Printf.$fPrintfArgChar11_closure" {
     Text.Printf.$fPrintfArgChar11_closure:
         const Text.Printf.$fPrintfArgChar11_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar11_entry() //  [R1]
         { info_tbl: [(ccgsU,
                       label: Text.Printf.$fPrintfArgChar11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgsU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgsV; else goto ccgsW;
       ccgsV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgsW: // global
           (_ccgsR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgsR::I64 == 0) goto ccgsT; else goto ccgsS;
       ccgsT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgsS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgsR::I64;
           R2 = Text.Printf.$fPrintfArgChar12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.360397941 UTC

[section ""data" . sat_scchZ_closure" {
     sat_scchZ_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.36214392 UTC

[section ""data" . sat_scci0_closure" {
     sat_scci0_closure:
         const :_con_info;
         const sat_scchZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.363838329 UTC

[section ""data" . sat_scchY_closure" {
     sat_scchY_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.365535694 UTC

[section ""data" . sat_scci1_closure" {
     sat_scci1_closure:
         const :_con_info;
         const sat_scchY_closure+1;
         const sat_scci0_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.367226843 UTC

[section ""data" . sat_scchX_closure" {
     sat_scchX_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.368912268 UTC

[section ""data" . sat_scci2_closure" {
     sat_scci2_closure:
         const :_con_info;
         const sat_scchX_closure+1;
         const sat_scci1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.370957274 UTC

[section ""data" . Text.Printf.$fPrintfArgChar7_closure" {
     Text.Printf.$fPrintfArgChar7_closure:
         const Text.Printf.$fPrintfArgChar7_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar7_entry() //  [R1]
         { info_tbl: [(ccgtg,
                       label: Text.Printf.$fPrintfArgChar7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgtg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgth; else goto ccgti;
       ccgth: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgti: // global
           (_ccgtd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgtd::I64 == 0) goto ccgtf; else goto ccgte;
       ccgtf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgte: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgtd::I64;
           R3 = sat_scci2_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.375133659 UTC

[section ""data" . Text.Printf.$fPrintfArgChar10_closure" {
     Text.Printf.$fPrintfArgChar10_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar11_closure;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.377834706 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar9_bytes" {
     Text.Printf.$fPrintfArgChar9_bytes:
         I8[] [76]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.379792887 UTC

[section ""data" . Text.Printf.$fPrintfArgChar8_closure" {
     Text.Printf.$fPrintfArgChar8_closure:
         const Text.Printf.$fPrintfArgChar8_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar8_entry() //  [R1]
         { info_tbl: [(ccgty,
                       label: Text.Printf.$fPrintfArgChar8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgty: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgtz; else goto ccgtA;
       ccgtz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgtA: // global
           (_ccgtv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgtv::I64 == 0) goto ccgtx; else goto ccgtw;
       ccgtx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgtw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgtv::I64;
           R2 = Text.Printf.$fPrintfArgChar9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.383813687 UTC

[section ""data" . Text.Printf.$fPrintfArgChar6_closure" {
     Text.Printf.$fPrintfArgChar6_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar8_closure;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.385564007 UTC

[section ""data" . Text.Printf.$fPrintfArgChar5_closure" {
     Text.Printf.$fPrintfArgChar5_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.387297665 UTC

[section ""data" . Text.Printf.$fPrintfArgChar4_closure" {
     Text.Printf.$fPrintfArgChar4_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar10_closure+1;
         const Text.Printf.$fPrintfArgChar5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.389058618 UTC

[section ""data" . Text.Printf.$fPrintfArgChar3_closure" {
     Text.Printf.$fPrintfArgChar3_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar13_closure+1;
         const Text.Printf.$fPrintfArgChar4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.390829206 UTC

[section ""data" . Text.Printf.$fPrintfArgChar2_closure" {
     Text.Printf.$fPrintfArgChar2_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar17_closure+1;
         const Text.Printf.$fPrintfArgChar3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.392546388 UTC

[section ""data" . Text.Printf.intModifierMap_closure" {
     Text.Printf.intModifierMap_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar21_closure+1;
         const Text.Printf.$fPrintfArgChar2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.394288298 UTC

[section ""cstring" . lvl7_rccc6_bytes" {
     lvl7_rccc6_bytes:
         I8[] [112,114,105,110,116,102,58,32,117,110,107,110,111,119,110,32,102,111,114,109,97,116,32,109,111,100,105,102,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.396257568 UTC

[section ""data" . Text.Printf.$fPrintfArgInt2_closure" {
     Text.Printf.$fPrintfArgInt2_closure:
         const Text.Printf.$fPrintfArgInt2_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgInt2_entry() //  [R1]
         { info_tbl: [(ccgtX,
                       label: Text.Printf.$fPrintfArgInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgtX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccgtY; else goto ccgtZ;
       ccgtY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgtZ: // global
           (_ccgtS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgtS::I64 == 0) goto ccgtU; else goto ccgtT;
       ccgtU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgtT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgtS::I64;
           I64[Sp - 24] = block_ccgtV_info;
           R2 = lvl7_rccc6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgtV() //  [R1]
         { info_tbl: [(ccgtV,
                       label: block_ccgtV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgtV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.402665125 UTC

[section ""data" . Text.Printf.$wfixupMods_closure" {
     Text.Printf.$wfixupMods_closure:
         const Text.Printf.$wfixupMods_info;
         const 0;
 },
 Text.Printf.$wfixupMods_entry() //  [R2, R3]
         { info_tbl: [(ccguo,
                       label: Text.Printf.$wfixupMods_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccguo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgup; else goto ccguq;
       ccgup: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$wfixupMods_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccguq: // global
           I64[Sp - 16] = block_ccguh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucguJ; else goto ccgui;
       ucguJ: // global
           call _ccguh(R1) args: 0, res: 0, upd: 0;
       ccgui: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccguh() //  [R1]
         { info_tbl: [(ccguh,
                       label: block_ccguh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccguh: // global
           if (R1 & 7 == 1) goto ccgul; else goto ccgum;
       ccgul: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccgum: // global
           I64[Sp + 8] = block_ccguw_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           Sp = Sp + 8;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccguw() //  [R1]
         { info_tbl: [(ccguw,
                       label: block_ccguw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccguw: // global
           if (R1 & 7 == 1) goto ccguD; else goto ccguH;
       ccguD: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccguH: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.410752963 UTC

[section ""data" . Text.Printf.fixupMods_closure" {
     Text.Printf.fixupMods_closure:
         const Text.Printf.fixupMods_info;
         const 0;
 },
 Text.Printf.fixupMods_entry() //  [R2, R3]
         { info_tbl: [(ccgvc,
                       label: Text.Printf.fixupMods_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgvc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgvd; else goto ccgve;
       ccgvd: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.fixupMods_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccgve: // global
           I64[Sp - 16] = block_ccgv9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucgvi; else goto ccgva;
       ucgvi: // global
           call _ccgv9(R1) args: 0, res: 0, upd: 0;
       ccgva: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgv9() //  [R1]
         { info_tbl: [(ccgv9,
                       label: block_ccgv9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgv9: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 47];
           Sp = Sp + 16;
           call Text.Printf.$wfixupMods_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.418686326 UTC

[section ""data" . Text.Printf.$wparseIntFormat_closure" {
     Text.Printf.$wparseIntFormat_closure:
         const Text.Printf.$wparseIntFormat_info;
         const 0;
 },
 go_sccim_entry() //  [R1, R2]
         { info_tbl: [(ccgvI,
                       label: go_sccim_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgvI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccgvJ; else goto ccgvK;
       ccgvJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccgvK: // global
           I64[Sp - 24] = block_ccgvB_info;
           _sccim::P64 = R1;
           _sccil::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sccil::P64;
           P64[Sp - 8] = _sccim::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucgxz; else goto ccgvC;
       ucgxz: // global
           call _ccgvB(R1) args: 0, res: 0, upd: 0;
       ccgvC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgvB() //  [R1]
         { info_tbl: [(ccgvB,
                       label: block_ccgvB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgvB: // global
           if (R1 & 7 == 1) goto ucgxr; else goto ccgvG;
       ucgxr: // global
           Sp = Sp + 24;
           call _ccgwa() args: 0, res: 0, upd: 0;
       ccgvG: // global
           I64[Sp - 8] = block_ccgvQ_info;
           _scciq::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scciq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucgxx; else goto ccgvS;
       ucgxx: // global
           call _ccgvQ(R1) args: 0, res: 0, upd: 0;
       ccgvS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgvQ() //  [R1]
         { info_tbl: [(ccgvQ,
                       label: block_ccgvQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgvQ: // global
           _scciq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccgvW_info;
           R2 = _scciq::P64;
           _sccis::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sccis::P64;
           Sp = Sp + 8;
           call go_sccim_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgvW() //  [R1]
         { info_tbl: [(ccgvW,
                       label: block_ccgvW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgvW: // global
           if (R1 & 7 == 1) goto ccgw4; else goto ccgwI;
       ccgw4: // global
           _sccil::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccgw1_info;
           R4 = _sccil::P64;
           R3 = P64[Sp + 16];
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp + 8;
           call Data.OldList.stripPrefix_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
       ccgwI: // global
           I64[Sp - 8] = block_ccgwx_info;
           _scciu::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _scciu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucgxA; else goto ccgwy;
       ucgxA: // global
           call _ccgwx(R1) args: 0, res: 0, upd: 0;
       ccgwy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgw1() //  [R1]
         { info_tbl: [(ccgw1,
                       label: block_ccgw1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgw1: // global
           if (R1 & 7 == 1) goto ucgxv; else goto ccgwf;
       ucgxv: // global
           Sp = Sp + 16;
           call _ccgwa() args: 0, res: 0, upd: 0;
       ccgwf: // global
           I64[Sp] = block_ccgwd_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucgxB; else goto ccgwg;
       ucgxB: // global
           call _ccgwd(R1) args: 0, res: 0, upd: 0;
       ccgwg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgwa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgwa: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccgwd() //  [R1]
         { info_tbl: [(ccgwd,
                       label: block_ccgwd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgwd: // global
           if (R1 & 7 == 1) goto ucgxw; else goto ccgwr;
       ucgxw: // global
           Sp = Sp + 16;
           call _ccgxc() args: 0, res: 0, upd: 0;
       ccgwr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccgwu; else goto ccgwt;
       ccgwu: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgwt: // global
           _scciy::P64 = P64[R1 + 6];
           _scciz::P64 = P64[R1 + 14];
           I64[Hp - 40] = Text.Printf.FormatParse_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _scciy::P64;
           P64[Hp - 16] = _scciz::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccgwx() //  [R1]
         { info_tbl: [(ccgwx,
                       label: block_ccgwx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgwx: // global
           I64[Sp] = block_ccgwC_info;
           R3 = 0;
           R2 = P64[R1 + 7];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgwC() //  [R1]
         { info_tbl: [(ccgwC,
                       label: block_ccgwC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgwC: // global
           I64[Sp - 8] = block_ccgwG_info;
           R3 = 0;
           R2 = P64[Sp + 24];
           I64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgwG() //  [R1]
         { info_tbl: [(ccgwG,
                       label: block_ccgwG_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgwG: // global
           if (%MO_S_Lt_W64(I64[Sp + 8], R1)) goto ccgwU; else goto ucgxs;
       ccgwU: // global
           I64[Sp + 8] = block_ccgwS_info;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp + 8;
           call Data.OldList.stripPrefix_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
       ucgxs: // global
           Sp = Sp + 16;
           call _ccgxl() args: 0, res: 0, upd: 0;
     }
 },
 _ccgwS() //  [R1]
         { info_tbl: [(ccgwS,
                       label: block_ccgwS_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgwS: // global
           if (R1 & 7 == 1) goto ucgxt; else goto ccgx5;
       ucgxt: // global
           Sp = Sp + 8;
           call _ccgxl() args: 0, res: 0, upd: 0;
       ccgx5: // global
           I64[Sp + 16] = block_ccgx3_info;
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ucgxF; else goto ccgx6;
       ucgxF: // global
           call _ccgx3(R1) args: 0, res: 0, upd: 0;
       ccgx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgx3() //  [R1]
         { info_tbl: [(ccgx3,
                       label: block_ccgx3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgx3: // global
           if (R1 & 7 == 1) goto ucgxu; else goto ccgxh;
       ucgxu: // global
           Sp = Sp + 16;
           call _ccgxc() args: 0, res: 0, upd: 0;
       ccgxh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccgxk; else goto ccgxj;
       ccgxk: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgxj: // global
           _scciN::P64 = P64[R1 + 6];
           _scciO::P64 = P64[R1 + 14];
           I64[Hp - 40] = Text.Printf.FormatParse_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _scciN::P64;
           P64[Hp - 16] = _scciO::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccgxc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgxc: // global
           R1 = Text.Printf.errorShortFormat_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccgxl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgxl: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wparseIntFormat_entry() //  [R2]
         { info_tbl: [(ccgxO,
                       label: Text.Printf.$wparseIntFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgxO: // global
           _sccil::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccgxP; else goto ccgxQ;
       ccgxQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccgxS; else goto ccgxR;
       ccgxS: // global
           HpAlloc = 16;
           goto ccgxP;
       ccgxP: // global
           R2 = _sccil::P64;
           R1 = Text.Printf.$wparseIntFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccgxR: // global
           I64[Hp - 8] = go_sccim_info;
           P64[Hp] = _sccil::P64;
           I64[Sp - 16] = block_ccgxI_info;
           R2 = Text.Printf.intModifierMap_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sccil::P64;
           Sp = Sp - 16;
           call go_sccim_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgxI() //  [R1]
         { info_tbl: [(ccgxI,
                       label: block_ccgxI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgxI: // global
           if (R1 & 7 == 1) goto ccgxL; else goto ccgxM;
       ccgxL: // global
           _sccil::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccgxV_info;
           R1 = _sccil::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucgyf; else goto ccgxX;
       ucgyf: // global
           call _ccgxV(R1) args: 0, res: 0, upd: 0;
       ccgxX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccgxM: // global
           R1 = P64[R1 + 6] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccgxV() //  [R1]
         { info_tbl: [(ccgxV,
                       label: block_ccgxV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgxV: // global
           if (R1 & 7 == 1) goto ccgy3; else goto ccgy7;
       ccgy3: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccgy7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccgya; else goto ccgy9;
       ccgya: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgy9: // global
           _scciS::P64 = P64[R1 + 6];
           _scciT::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _scciS::P64;
           P64[Hp] = _scciT::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.450766831 UTC

[section ""data" . Text.Printf.parseIntFormat_closure" {
     Text.Printf.parseIntFormat_closure:
         const Text.Printf.parseIntFormat_info;
         const 0;
 },
 Text.Printf.parseIntFormat_entry() //  [R3]
         { info_tbl: [(ccgzH,
                       label: Text.Printf.parseIntFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgzH: // global
           R2 = R3;
           call Text.Printf.$wparseIntFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.454022123 UTC

[section ""cstring" . lvl8_rccc7_bytes" {
     lvl8_rccc7_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.45580448 UTC

[section ""data" . lvl9_rccc8_closure" {
     lvl9_rccc8_closure:
         const lvl9_rccc8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rccc8_entry() //  [R1]
         { info_tbl: [(ccgzV,
                       label: lvl9_rccc8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgzV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgzW; else goto ccgzX;
       ccgzW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgzX: // global
           (_ccgzS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgzS::I64 == 0) goto ccgzU; else goto ccgzT;
       ccgzU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgzT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgzS::I64;
           R2 = lvl8_rccc7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.459643602 UTC

[section ""data" . lvl10_rccc9_closure" {
     lvl10_rccc9_closure:
         const lvl10_rccc9_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_rccc9_entry() //  [R1]
         { info_tbl: [(ccgAb,
                       label: lvl10_rccc9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgAb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgAc; else goto ccgAd;
       ccgAc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgAd: // global
           (_ccgA8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgA8::I64 == 0) goto ccgAa; else goto ccgA9;
       ccgAa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgA9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgA8::I64;
           R2 = Text.Printf.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.463888532 UTC

[section ""data" . lvl11_rccca_closure" {
     lvl11_rccca_closure:
         const lvl11_rccca_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rccca_entry() //  [R1]
         { info_tbl: [(ccgAr,
                       label: lvl11_rccca_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgAr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgAs; else goto ccgAt;
       ccgAs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgAt: // global
           (_ccgAo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgAo::I64 == 0) goto ccgAq; else goto ccgAp;
       ccgAq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgAp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgAo::I64;
           R2 = Text.Printf.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.467636636 UTC

[section ""cstring" . lvl12_rcccb_bytes" {
     lvl12_rcccb_bytes:
         I8[] [46,47,84,101,120,116,47,80,114,105,110,116,102,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.469432633 UTC

[section ""data" . lvl13_rcccc_closure" {
     lvl13_rcccc_closure:
         const lvl13_rcccc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rcccc_entry() //  [R1]
         { info_tbl: [(ccgAI,
                       label: lvl13_rcccc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgAI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgAJ; else goto ccgAK;
       ccgAJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgAK: // global
           (_ccgAF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgAF::I64 == 0) goto ccgAH; else goto ccgAG;
       ccgAH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgAG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgAF::I64;
           R2 = lvl12_rcccb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.473227558 UTC

[section ""data" . lvl14_rcccd_closure" {
     lvl14_rcccd_closure:
         const GHC.Types.I#_con_info;
         const 323;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.475301249 UTC

[section ""data" . lvl15_rccce_closure" {
     lvl15_rccce_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.47694505 UTC

[section ""data" . lvl16_rcccf_closure" {
     lvl16_rcccf_closure:
         const GHC.Types.I#_con_info;
         const 49;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.478677041 UTC

[section ""data" . lvl17_rcccg_closure" {
     lvl17_rcccg_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl10_rccc9_closure;
         const lvl11_rccca_closure;
         const lvl13_rcccc_closure;
         const lvl14_rcccd_closure+1;
         const lvl15_rccce_closure+1;
         const lvl14_rcccd_closure+1;
         const lvl16_rcccf_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.481025793 UTC

[section ""data" . lvl18_rccch_closure" {
     lvl18_rccch_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl9_rccc8_closure;
         const lvl17_rcccg_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.483029932 UTC

[section ""data" . Text.Printf.$fPrintfArgChar1_closure" {
     Text.Printf.$fPrintfArgChar1_closure:
         const Text.Printf.$fPrintfArgChar1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar1_entry() //  [R1]
         { info_tbl: [(ccgB3,
                       label: Text.Printf.$fPrintfArgChar1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgB3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgB4; else goto ccgB5;
       ccgB4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgB5: // global
           (_ccgB0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgB0::I64 == 0) goto ccgB2; else goto ccgB1;
       ccgB2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgB1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgB0::I64;
           R2 = lvl18_rccch_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.487124647 UTC

[section ""data" . Text.Printf.$fPrintfArgChar_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgChar_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgChar_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgChar_$cparseFormat_entry() //  [R3]
         { info_tbl: [(ccgBh,
                       label: Text.Printf.$fPrintfArgChar_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgBh: // global
           R2 = R3;
           call Text.Printf.$wparseIntFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.490532626 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble5_closure" {
     Text.Printf.$fPrintfArgDouble5_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.493716049 UTC

[section ""data" . integral_prec_rc8qj_closure" {
     integral_prec_rc8qj_closure:
         const integral_prec_rc8qj_info;
 },
 sat_sccjf_entry() //  [R1]
         { info_tbl: [(ccgC8,
                       label: sat_sccjf_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgC8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgC9; else goto ccgCa;
       ccgC9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgCa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sccjb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_sccjb_entry() //  [R1, R2]
         { info_tbl: [(ccgCe,
                       label: $wxs_sccjb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgCe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccgCi; else goto ccgCh;
       ccgCi: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccgCh: // global
           if (R2 == 1) goto ccgCd; else goto ccgCc;
       ccgCd: // global
           _sccja::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _sccja::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccgCc: // global
           I64[Hp - 48] = sat_sccjf_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Text.Printf.$fPrintfArgDouble5_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 integral_prec_rc8qj_entry() //  [R2, R3]
         { info_tbl: [(ccgCo,
                       label: integral_prec_rc8qj_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgCo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccgCp; else goto ccgCq;
       ccgCp: // global
           R3 = R3;
           R2 = R2;
           R1 = integral_prec_rc8qj_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccgCq: // global
           I64[Sp - 16] = block_ccgBt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucgDr; else goto ccgBu;
       ucgDr: // global
           call _ccgBt(R1) args: 0, res: 0, upd: 0;
       ccgBu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgBt() //  [R1]
         { info_tbl: [(ccgBt,
                       label: block_ccgBt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgBt: // global
           if (R1 & 7 == 1) goto ccgCl; else goto ccgCm;
       ccgCl: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccgCm: // global
           I64[Sp] = block_ccgBz_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucgDo; else goto ccgBA;
       ucgDo: // global
           call _ccgBz(R1) args: 0, res: 0, upd: 0;
       ccgBA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgBz() //  [R1]
         { info_tbl: [(ccgBz,
                       label: block_ccgBz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgBz: // global
           _sccj4::I64 = I64[R1 + 7];
           if (_sccj4::I64 == 0) goto ccgCI; else goto ucgDk;
       ccgCI: // global
           I64[Sp - 8] = block_ccgCH_info;
           R1 = P64[Sp + 8];
           I64[Sp] = _sccj4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucgDp; else goto ccgCJ;
       ucgDp: // global
           call _ccgCH(R1) args: 0, res: 0, upd: 0;
       ccgCJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucgDk: // global
           I64[Sp] = _sccj4::I64;
           call _sccj5() args: 0, res: 0, upd: 0;
     }
 },
 _ccgCH() //  [R1]
         { info_tbl: [(ccgCH,
                       label: block_ccgCH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgCH: // global
           if (R1 & 7 == 1) goto ucgDl; else goto ccgCU;
       ucgDl: // global
           Sp = Sp + 8;
           call _sccj5() args: 0, res: 0, upd: 0;
       ccgCU: // global
           I64[Sp - 8] = block_ccgCS_info;
           _sccjj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccjj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucgDs; else goto ccgCV;
       ucgDs: // global
           call _ccgCS(R1) args: 0, res: 0, upd: 0;
       ccgCV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgCS() //  [R1]
         { info_tbl: [(ccgCS,
                       label: block_ccgCS_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgCS: // global
           if (I64[R1 + 7] == 48) goto ccgD6; else goto ucgDm;
       ccgD6: // global
           _sccjj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccgD5_info;
           R1 = _sccjj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucgDu; else goto ccgD7;
       ucgDu: // global
           call _ccgD5(R1) args: 0, res: 0, upd: 0;
       ccgD7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucgDm: // global
           Sp = Sp + 16;
           call _sccj5() args: 0, res: 0, upd: 0;
     }
 },
 _ccgD5() //  [R1]
         { info_tbl: [(ccgD5,
                       label: block_ccgD5_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgD5: // global
           if (R1 & 7 == 1) goto ccgDd; else goto ucgDn;
       ccgDd: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ucgDn: // global
           Sp = Sp + 8;
           call _sccj5() args: 0, res: 0, upd: 0;
     }
 },
 _sccj5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccj5: // global
           I64[Sp - 8] = block_ccgBJ_info;
           R3 = 0;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgBJ() //  [R1]
         { info_tbl: [(ccgBJ,
                       label: block_ccgBJ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgBJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccgCy; else goto ccgCx;
       ccgCy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccgCx: // global
           _sccj0::P64 = P64[Sp + 16];
           _sccj8::I64 = I64[Sp + 8] - R1;
           if (%MO_S_Ge_W64(0, _sccj8::I64)) goto ccgCA; else goto ccgCB;
       ccgCA: // global
           Hp = Hp - 40;
           R1 = _sccj0::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccgCB: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Text.Printf.$fPrintfArgDouble5_closure+1;
           P64[Hp - 16] = _sccj0::P64;
           I64[Hp - 8] = $wxs_sccjb_info;
           P64[Hp] = Hp - 30;
           R2 = _sccj8::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call $wxs_sccjb_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.51386722 UTC

[section ""cstring" . lvl19_rccci_bytes" {
     lvl19_rccci_bytes:
         I8[] [84,101,120,116,47,80,114,105,110,116,102,46,104,115,58,55,49,52,58,55,45,51,57,124,40,34,34,44,32,115,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.515804196 UTC

[section ""data" . lvl20_rcccj_closure" {
     lvl20_rcccj_closure:
         const lvl20_rcccj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_rcccj_entry() //  [R1]
         { info_tbl: [(ccgEw,
                       label: lvl20_rcccj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgEw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgEx; else goto ccgEy;
       ccgEx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgEy: // global
           (_ccgEt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgEt::I64 == 0) goto ccgEv; else goto ccgEu;
       ccgEv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgEu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgEt::I64;
           R2 = lvl19_rccci_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.52086927 UTC

[section ""data" . Text.Printf.formatChar2_closure" {
     Text.Printf.formatChar2_closure:
         const Text.Printf.formatChar2_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.formatChar2_entry() //  [R1]
         { info_tbl: [(ccgEM,
                       label: Text.Printf.formatChar2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgEM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgEN; else goto ccgEO;
       ccgEN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgEO: // global
           (_ccgEJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgEJ::I64 == 0) goto ccgEL; else goto ccgEK;
       ccgEL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgEK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgEJ::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.525558163 UTC

[section ""data" . sat_sccjq_closure" {
     sat_sccjq_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.527203606 UTC

[section ""data" . sat_sccjr_closure" {
     sat_sccjr_closure:
         const :_con_info;
         const sat_sccjq_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.529140143 UTC

[section ""data" . lvl21_rccck_closure" {
     lvl21_rccck_closure:
         const lvl21_rccck_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_rccck_entry() //  [R1]
         { info_tbl: [(ccgF4,
                       label: lvl21_rccck_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgF4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgF5; else goto ccgF6;
       ccgF5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgF6: // global
           (_ccgF1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgF1::I64 == 0) goto ccgF3; else goto ccgF2;
       ccgF3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgF2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgF1::I64;
           R3 = sat_sccjr_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.53643794 UTC

[section ""data" . $wfmtu_rcccl_closure" {
     $wfmtu_rcccl_closure:
         const $wfmtu_rcccl_info;
         const 0;
 },
 sat_sccjG_entry() //  [R1]
         { info_tbl: [(ccgFL,
                       label: sat_sccjG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgFL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccgFM; else goto ccgFN;
       ccgFM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgFN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 24];
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = P64[R1 + 16];
           R3 = GHC.Show.$fShowInteger_closure;
           R2 = GHC.Real.$fIntegralInteger_closure;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 32, res: 0, upd: 24;
     }
 },
 sat_sccjL_entry() //  [R1]
         { info_tbl: [(ccgG4,
                       label: sat_sccjL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgG4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgG5; else goto ccgG6;
       ccgG5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgG6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 fmtu'_sccjy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccgGe,
                       label: fmtu'_sccjy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgGe: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgGf; else goto ucgHj;
       ccgGf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ucgHj: // global
           P64[Sp - 32] = R1;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call _ccgFp() args: 0, res: 0, upd: 0;
     }
 },
 _ccgFp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgFp: // global
           _sccjs::P64 = P64[P64[Sp] + 5];
           I64[Sp - 8] = block_ccgG7_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sccjs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucgHq; else goto ccgG8;
       ucgHq: // global
           call _ccgG7(R1) args: 0, res: 0, upd: 0;
       ccgG8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgG7() //  [R1]
         { info_tbl: [(ccgG7,
                       label: block_ccgG7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgG7: // global
           if (R1 & 7 == 1) goto ucgHk; else goto ccgGc;
       ucgHk: // global
           Sp = Sp + 8;
           call _sccjC() args: 0, res: 0, upd: 0;
       ccgGc: // global
           I64[Sp - 8] = block_ccgGQ_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = P64[Sp + 32];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgGQ() //  [R1]
         { info_tbl: [(ccgGQ,
                       label: block_ccgGQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgGQ: // global
           if (R1 == 1) goto ccgHa; else goto ucgHl;
       ccgHa: // global
           _sccjN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccgH0_info;
           R3 = _sccjN::P64;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ucgHl: // global
           Sp = Sp + 16;
           call _sccjC() args: 0, res: 0, upd: 0;
     }
 },
 _ccgH0() //  [R1]
         { info_tbl: [(ccgH0,
                       label: block_ccgH0_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgH0: // global
           I64[Sp] = block_ccgH4_info;
           R2 = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgH4() //  [R1]
         { info_tbl: [(ccgH4,
                       label: block_ccgH4_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgH4: // global
           I64[Sp] = block_ccgH8_info;
           R3 = P64[Sp + 32];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgH8() //  [R1]
         { info_tbl: [(ccgH8,
                       label: block_ccgH8_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgH8: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = GHC.Base.Nothing_closure+1;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ccgFp() args: 0, res: 0, upd: 0;
     }
 },
 _sccjC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccjC: // global
           I64[Sp - 8] = block_ccgFx_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucgHy; else goto ccgFy;
       ucgHy: // global
           call _ccgFx(R1) args: 0, res: 0, upd: 0;
       ccgFy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgFx() //  [R1]
         { info_tbl: [(ccgFx,
                       label: block_ccgFx_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgFx: // global
           _sccjB::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccgGk; else goto ccgGv;
       ccgGk: // global
           I64[Sp + 16] = block_ccgFC_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sccjB::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ccgGv: // global
           I64[Sp] = block_ccgFQ_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sccjB::P64;
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgFC() //  [R1]
         { info_tbl: [(ccgFC,
                       label: block_ccgFC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgFC: // global
           if (R1 == 1) goto ccgGq; else goto ucgHp;
       ccgGq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccgGt; else goto ccgGs;
       ccgGt: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccgGs: // global
           I64[Hp - 40] = sat_sccjG_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ucgHp: // global
           Sp = Sp + 24;
           call _ccgGF() args: 0, res: 0, upd: 0;
     }
 },
 _ccgFQ() //  [R1]
         { info_tbl: [(ccgFQ,
                       label: block_ccgFQ_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgFQ: // global
           if (R1 == 1) goto ccgGB; else goto ucgHn;
       ccgGB: // global
           I64[Sp + 16] = block_ccgFV_info;
           R4 = P64[Sp + 32];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call fmtu'_sccjy_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ucgHn: // global
           Sp = Sp + 40;
           call _ccgGF() args: 0, res: 0, upd: 0;
     }
 },
 _ccgFV() //  [R1]
         { info_tbl: [(ccgFV,
                       label: block_ccgFV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgFV: // global
           if (R1 & 7 == 1) goto ucgHo; else goto ccgGH;
       ucgHo: // global
           Sp = Sp + 24;
           call _ccgGF() args: 0, res: 0, upd: 0;
       ccgGH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccgGK; else goto ccgGJ;
       ccgGK: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgGJ: // global
           _sccjK::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sccjL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sccjK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccgGF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgGF: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 s_sccjW_entry() //  [R1]
         { info_tbl: [(ccgHO,
                       label: s_sccjW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgHO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccgHP; else goto ccgHQ;
       ccgHP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgHQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccgHF_info;
           R6 = P64[R1 + 40];
           R5 = P64[R1 + 32];
           R4 = P64[R1 + 24];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgHF() //  [R1, R2]
         { info_tbl: [(ccgHF,
                       label: block_ccgHF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgHF: // global
           I64[Sp - 8] = block_ccgHH_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucgHY; else goto ccgHI;
       ucgHY: // global
           call _ccgHH(R1) args: 0, res: 0, upd: 0;
       ccgHI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccgHH() //  [R1]
         { info_tbl: [(ccgHH,
                       label: block_ccgHH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgHH: // global
           if (R1 & 7 == 1) goto ccgHL; else goto ccgHM;
       ccgHL: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccgHM: // global
           R1 = lvl20_rcccj_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wfmtu_rcccl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccgI3,
                       label: $wfmtu_rcccl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgI3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccgI4; else goto ccgI5;
       ccgI4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wfmtu_rcccl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccgI5: // global
           I64[Sp - 40] = block_ccgFi_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucgJq; else goto ccgFj;
       ucgJq: // global
           call _ccgFi(R1) args: 0, res: 0, upd: 0;
       ccgFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgFi() //  [R1]
         { info_tbl: [(ccgFi,
                       label: block_ccgFi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgFi: // global
           _sccjs::P64 = P64[Sp + 8];
           _sccju::P64 = P64[Sp + 16];
           _sccjv::P64 = P64[Sp + 24];
           _sccjw::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccgI0; else goto ccgI1;
       ccgI0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccgI9; else goto ccgI8;
       ccgI9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgI8: // global
           I64[Hp - 8] = fmtu'_sccjy_info;
           P64[Hp] = _sccjs::P64;
           I64[Sp + 32] = block_ccgI6_info;
           R4 = _sccjw::P64;
           R3 = _sccjv::P64;
           R2 = _sccju::P64;
           R1 = Hp - 5;
           Sp = Sp + 32;
           call fmtu'_sccjy_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ccgI1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccgIn; else goto ccgIm;
       ccgIn: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgIm: // global
           _sccjV::P64 = P64[R1 + 6];
           I64[Hp - 40] = s_sccjW_info;
           P64[Hp - 24] = _sccjs::P64;
           P64[Hp - 16] = _sccju::P64;
           P64[Hp - 8] = _sccjv::P64;
           P64[Hp] = _sccjw::P64;
           I64[Sp + 24] = block_ccgIk_info;
           R1 = _sccjV::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ucgJp; else goto ccgIo;
       ucgJp: // global
           call _ccgIk(R1) args: 0, res: 0, upd: 0;
       ccgIo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgI6() //  [R1]
         { info_tbl: [(ccgI6,
                       label: block_ccgI6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgI6: // global
           if (R1 & 7 == 1) goto ccgIf; else goto ccgIj;
       ccgIf: // global
           R1 = Text.Printf.errorBadArgument_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccgIj: // global
           R2 = P64[R1 + 6];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccgIk() //  [R1]
         { info_tbl: [(ccgIk,
                       label: block_ccgIk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgIk: // global
           if (R1 & 7 == 1) goto ccgIu; else goto ccgIz;
       ccgIu: // global
           R2 = P64[Sp + 8];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccgIz: // global
           I64[Sp - 16] = block_ccgIx_info;
           _scck4::P64 = R1;
           _scck6::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scck6::P64;
           P64[Sp] = _scck4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucgJr; else goto ccgIA;
       ucgJr: // global
           call _ccgIx(R1) args: 0, res: 0, upd: 0;
       ccgIA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgIx() //  [R1]
         { info_tbl: [(ccgIx,
                       label: block_ccgIx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgIx: // global
           if (I64[R1 + 7] == 48) goto ccgIL; else goto ucgJn;
       ccgIL: // global
           _scck6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccgIK_info;
           R1 = _scck6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucgJs; else goto ccgIM;
       ucgJs: // global
           call _ccgIK(R1) args: 0, res: 0, upd: 0;
       ccgIM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucgJn: // global
           Sp = Sp + 16;
           call _ccgJi() args: 0, res: 0, upd: 0;
     }
 },
 _ccgIK() //  [R1]
         { info_tbl: [(ccgIK,
                       label: block_ccgIK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgIK: // global
           if (R1 & 7 == 1) goto ccgIT; else goto ucgJo;
       ccgIT: // global
           I64[Sp] = block_ccgIQ_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ucgJu; else goto ccgIU;
       ucgJu: // global
           call _ccgIQ(R1) args: 0, res: 0, upd: 0;
       ccgIU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucgJo: // global
           Sp = Sp + 8;
           call _ccgJi() args: 0, res: 0, upd: 0;
     }
 },
 _ccgIQ() //  [R1]
         { info_tbl: [(ccgIQ,
                       label: block_ccgIQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgIQ: // global
           if (R1 & 7 == 1) goto ccgJ0; else goto ccgJ5;
       ccgJ0: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccgJ5: // global
           I64[Sp] = block_ccgJ3_info;
           _scckb::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _scckb::P64;
           if (R1 & 7 != 0) goto ucgJw; else goto ccgJ6;
       ucgJw: // global
           call _ccgJ3(R1) args: 0, res: 0, upd: 0;
       ccgJ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgJ3() //  [R1]
         { info_tbl: [(ccgJ3,
                       label: block_ccgJ3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgJ3: // global
           _scckb::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 48) goto ccgJe; else goto ccgJd;
       ccgJe: // global
           R2 = _scckb::P64;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccgJd: // global
           R2 = _scckb::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccgJi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgJi: // global
           R2 = P64[Sp + 8];
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.589179415 UTC

[section ""data" . $wfmti_rcccm_closure" {
     $wfmti_rcccm_closure:
         const $wfmti_rcccm_info;
         const 0;
 },
 sat_scckq_entry() //  [R1]
         { info_tbl: [(ccgLT,
                       label: sat_scckq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgLT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccgLU; else goto ccgLV;
       ccgLU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgLV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccgLQ_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgLQ() //  [R1, R2]
         { info_tbl: [(ccgLQ,
                       label: block_ccgLQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgLQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccgLY; else goto ccgLX;
       ccgLY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccgLX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 14;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scckw_entry() //  [R1]
         { info_tbl: [(ccgM7,
                       label: sat_scckw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgM7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccgMd; else goto ccgMe;
       ccgMd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgMe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccgM5_info;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgM5() //  [R1]
         { info_tbl: [(ccgM5,
                       label: block_ccgM5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgM5: // global
           I64[Sp] = block_ccgMa_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgMa() //  [R1, R2]
         { info_tbl: [(ccgMa,
                       label: block_ccgMa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgMa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccgMi; else goto ccgMh;
       ccgMi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccgMh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 14;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucgMv_srtd" {
     ucgMv_srtd:
         const SccKB_srt+104;
         const 33;
         const 6509559809;
 },
 $wfmti_rcccm_entry() //  [R2, R3]
         { info_tbl: [(ccgMm,
                       label: $wfmti_rcccm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgMm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccgMn; else goto ccgMo;
       ccgMn: // global
           R3 = R3;
           R2 = R2;
           R1 = $wfmti_rcccm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccgMo: // global
           I64[Sp - 24] = block_ccgLI_info;
           _scckk::P64 = R3;
           R3 = Text.Printf.formatChar2_closure;
           _scckj::P64 = R2;
           R2 = _scckk::P64;
           P64[Sp - 16] = _scckj::P64;
           P64[Sp - 8] = _scckk::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgLI() //  [R1]
         { info_tbl: [(ccgLI,
                       label: block_ccgLI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgLI: // global
           _scckj::P64 = P64[Sp + 8];
           _scckk::P64 = P64[Sp + 16];
           if (R1 == 1) goto ccgMl; else goto ccgMk;
       ccgMl: // global
           Hp = Hp + 32;
           _scckl::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccgMu; else goto ccgMt;
       ccgMt: // global
           I64[Hp - 24] = sat_scckw_info;
           P64[Hp - 8] = _scckj::P64;
           P64[Hp] = _scckk::P64;
           R2 = Hp - 24;
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccgMk: // global
           Hp = Hp + 32;
           _scckl::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccgMu; else goto ccgMq;
       ccgMu: // global
           HpAlloc = 32;
           R1 = _scckl::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccgMq: // global
           I64[Hp - 24] = sat_scckq_info;
           P64[Hp - 8] = _scckj::P64;
           P64[Hp] = _scckk::P64;
           R2 = Hp - 24;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.60623506 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble6_closure" {
     Text.Printf.$fPrintfArgDouble6_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.6110757 UTC

[section ""data" . Text.Printf.$wadjust_closure" {
     Text.Printf.$wadjust_closure:
         const Text.Printf.$wadjust_info;
 },
 x1_scckM_entry() //  [R1]
         { info_tbl: [(ccgNR,
                       label: x1_scckM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgNR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccgNS; else goto ccgNT;
       ccgNS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgNT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccgNK_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucgOh; else goto ccgNL;
       ucgOh: // global
           call _ccgNK(R1) args: 0, res: 0, upd: 0;
       ccgNL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccgNK() //  [R1]
         { info_tbl: [(ccgNK,
                       label: block_ccgNK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgNK: // global
           if (R1 & 7 == 1) goto ucgOd; else goto ccgNP;
       ucgOd: // global
           Sp = Sp + 8;
           call _ccgO7() args: 0, res: 0, upd: 0;
       ccgNP: // global
           I64[Sp] = block_ccgNZ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucgOf; else goto ccgO1;
       ucgOf: // global
           call _ccgNZ(R1) args: 0, res: 0, upd: 0;
       ccgO1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccgNZ() //  [R1]
         { info_tbl: [(ccgNZ,
                       label: block_ccgNZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgNZ: // global
           if (R1 & 7 == 1) goto ucgOe; else goto ccgOb;
       ucgOe: // global
           Sp = Sp + 8;
           call _ccgO7() args: 0, res: 0, upd: 0;
       ccgOb: // global
           R1 = Text.Printf.$fPrintfArgDouble5_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccgO7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgO7: // global
           R1 = Text.Printf.$fPrintfArgDouble6_closure+1;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scckV_entry() //  [R1]
         { info_tbl: [(ccgOx,
                       label: sat_scckV_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgOx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgOy; else goto ccgOz;
       ccgOy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgOz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_scckR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_scckR_entry() //  [R1, R2]
         { info_tbl: [(ccgOD,
                       label: $wxs_scckR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgOD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccgOH; else goto ccgOG;
       ccgOH: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccgOG: // global
           if (R2 == 1) goto ccgOC; else goto ccgOB;
       ccgOC: // global
           _scckQ::P64 = P64[R1 + 15];
           Hp = Hp - 56;
           R1 = _scckQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccgOB: // global
           _scckM::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scckV_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _scckM::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 fill_scckB_entry() //  [R1]
         { info_tbl: [(ccgON,
                       label: fill_scckB_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgON: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccgOO; else goto ccgOP;
       ccgOO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgOP: // global
           I64[Sp - 32] = block_ccgN9_info;
           _sccky::P64 = P64[R1 + 24];
           _scckz::P64 = P64[R1 + 32];
           _scckA::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccky::P64;
           P64[Sp - 16] = _scckz::P64;
           P64[Sp - 8] = _scckA::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucgP5; else goto ccgNa;
       ucgP5: // global
           call _ccgN9(R1) args: 0, res: 0, upd: 0;
       ccgNa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgN9() //  [R1]
         { info_tbl: [(ccgN9,
                       label: block_ccgN9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgN9: // global
           if (R1 & 7 == 1) goto ccgOK; else goto ccgOL;
       ccgOK: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccgOL: // global
           I64[Sp] = block_ccgNf_info;
           R3 = 0;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgNf() //  [R1]
         { info_tbl: [(ccgNf,
                       label: block_ccgNf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgNf: // global
           I64[Sp] = block_ccgNj_info;
           R3 = 0;
           R2 = P64[Sp + 24];
           I64[Sp + 24] = R1;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccgNj() //  [R1]
         { info_tbl: [(ccgNj,
                       label: block_ccgNj_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgNj: // global
           I64[Sp] = block_ccgNn_info;
           _scckF::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _scckF::I64;
           if (R1 & 7 != 0) goto ucgP4; else goto ccgNo;
       ucgP4: // global
           call _ccgNn(R1) args: 0, res: 0, upd: 0;
       ccgNo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgNn() //  [R1]
         { info_tbl: [(ccgNn,
                       label: block_ccgNn_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgNn: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccgOX; else goto ccgOW;
       ccgOX: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgOW: // global
           _scckH::I64 = I64[R1 + 7];
           _scckI::I64 = I64[Sp + 24] + I64[Sp + 16];
           if (%MO_S_Ge_W64(_scckI::I64,
                            _scckH::I64)) goto ccgP1; else goto ccgP3;
       ccgP3: // global
           _scckK::I64 = _scckH::I64 - _scckI::I64;
           if (%MO_S_Ge_W64(0, _scckK::I64)) goto ccgP1; else goto ccgP2;
       ccgP1: // global
           Hp = Hp - 72;
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccgP2: // global
           I64[Hp - 64] = x1_scckM_info;
           P64[Hp - 48] = P64[Sp + 8];
           I64[Hp - 40] = :_con_info;
           _ccgNG::P64 = Hp - 64;
           P64[Hp - 32] = _ccgNG::P64;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = $wxs_scckR_info;
           P64[Hp - 8] = _ccgNG::P64;
           P64[Hp] = Hp - 38;
           R2 = _scckK::I64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call $wxs_scckR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scckY_entry() //  [R1]
         { info_tbl: [(ccgPk,
                       label: sat_scckY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgPk: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccl1_entry() //  [R1]
         { info_tbl: [(ccgPy,
                       label: sat_sccl1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgPy: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccl2_entry() //  [R1]
         { info_tbl: [(ccgPH,
                       label: sat_sccl2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgPH: // global
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccl6_entry() //  [R1]
         { info_tbl: [(ccgPZ,
                       label: sat_sccl6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgPZ: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wadjust_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccgQ6,
                       label: Text.Printf.$wadjust_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgQ6: // global
           _scckA::P64 = R5;
           _scckz::P64 = R4;
           _sccky::P64 = R3;
           _scckx::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto ccgQ7; else goto ccgQ8;
       ccgQ8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccgQa; else goto ccgQ9;
       ccgQa: // global
           HpAlloc = 48;
           goto ccgQ7;
       ccgQ7: // global
           R5 = _scckA::P64;
           R4 = _scckz::P64;
           R3 = _sccky::P64;
           R2 = _scckx::P64;
           R1 = Text.Printf.$wadjust_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccgQ9: // global
           I64[Hp - 40] = fill_scckB_info;
           P64[Hp - 24] = _scckx::P64;
           P64[Hp - 16] = _sccky::P64;
           P64[Hp - 8] = _scckz::P64;
           P64[Hp] = _scckA::P64;
           I64[Sp - 40] = block_ccgPK_info;
           R1 = _sccky::P64;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = _sccky::P64;
           P64[Sp - 16] = _scckz::P64;
           P64[Sp - 8] = _scckA::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucgQN; else goto ccgPL;
       ucgQN: // global
           call _ccgPK(R1) args: 0, res: 0, upd: 0;
       ccgPL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgPK() //  [R1]
         { info_tbl: [(ccgPK,
                       label: block_ccgPK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgPK: // global
           if (R1 & 7 == 1) goto ucgQH; else goto ccgQ4;
       ucgQH: // global
           Sp = Sp + 8;
           call _scckW() args: 0, res: 0, upd: 0;
       ccgQ4: // global
           I64[Sp] = block_ccgPQ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucgQK; else goto ccgPR;
       ucgQK: // global
           call _ccgPQ(R1) args: 0, res: 0, upd: 0;
       ccgPR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgPQ() //  [R1]
         { info_tbl: [(ccgPQ,
                       label: block_ccgPQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgPQ: // global
           if (R1 & 7 == 1) goto ccgQw; else goto ucgQI;
       ccgQw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccgQz; else goto ccgQy;
       ccgQz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgQy: // global
           I64[Hp - 24] = sat_sccl6_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ucgQI: // global
           Sp = Sp + 8;
           call _scckW() args: 0, res: 0, upd: 0;
     }
 },
 _scckW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scckW: // global
           I64[Sp - 8] = block_ccgPb_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucgQO; else goto ccgPc;
       ucgQO: // global
           call _ccgPb(R1) args: 0, res: 0, upd: 0;
       ccgPc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgPb() //  [R1]
         { info_tbl: [(ccgPb,
                       label: block_ccgPb_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgPb: // global
           if (R1 & 7 == 1) goto ccgQd; else goto ccgQi;
       ccgQd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccgQg; else goto ccgQf;
       ccgQg: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgQf: // global
           I64[Hp - 24] = sat_scckY_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccgQi: // global
           I64[Sp] = block_ccgPp_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucgQJ; else goto ccgPq;
       ucgQJ: // global
           call _ccgPp(R1) args: 0, res: 0, upd: 0;
       ccgPq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgPp() //  [R1]
         { info_tbl: [(ccgPp,
                       label: block_ccgPp_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgPp: // global
           _ccgN5::P64 = P64[Sp + 8];
           _scckz::P64 = P64[Sp + 24];
           _scckA::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccgQk; else goto ccgQo;
       ccgQk: // global
           Hp = Hp + 32;
           _sccl0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccgQr; else goto ccgQm;
       ccgQm: // global
           I64[Hp - 24] = sat_sccl1_info;
           P64[Hp - 8] = _scckz::P64;
           P64[Hp] = _scckA::P64;
           R3 = Hp - 24;
           R2 = _ccgN5::P64;
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccgQo: // global
           Hp = Hp + 32;
           _sccl0::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccgQr; else goto ccgQq;
       ccgQr: // global
           HpAlloc = 32;
           R1 = _sccl0::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgQq: // global
           I64[Hp - 24] = sat_sccl2_info;
           P64[Hp - 8] = _scckA::P64;
           P64[Hp] = _ccgN5::P64;
           R3 = Hp - 24;
           R2 = _scckz::P64;
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.652154115 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble4_bytes" {
     Text.Printf.$fPrintfArgDouble4_bytes:
         I8[] [43]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.654256522 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble3_closure" {
     Text.Printf.$fPrintfArgDouble3_closure:
         const Text.Printf.$fPrintfArgDouble3_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble3_entry() //  [R1]
         { info_tbl: [(ccgSE,
                       label: Text.Printf.$fPrintfArgDouble3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgSE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgSF; else goto ccgSG;
       ccgSF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgSG: // global
           (_ccgSB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgSB::I64 == 0) goto ccgSD; else goto ccgSC;
       ccgSD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgSC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgSB::I64;
           R2 = Text.Printf.$fPrintfArgDouble4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.658419897 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble2_bytes" {
     Text.Printf.$fPrintfArgDouble2_bytes:
         I8[] [32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.660304371 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble1_closure" {
     Text.Printf.$fPrintfArgDouble1_closure:
         const Text.Printf.$fPrintfArgDouble1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble1_entry() //  [R1]
         { info_tbl: [(ccgSV,
                       label: Text.Printf.$fPrintfArgDouble1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgSV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccgSW; else goto ccgSX;
       ccgSW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgSX: // global
           (_ccgSS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccgSS::I64 == 0) goto ccgSU; else goto ccgST;
       ccgSU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccgST: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccgSS::I64;
           R2 = Text.Printf.$fPrintfArgDouble2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.664811174 UTC

[section ""data" . Text.Printf.$wadjustSigned_closure" {
     Text.Printf.$wadjustSigned_closure:
         const Text.Printf.$wadjustSigned_info;
         const 0;
 },
 Text.Printf.$wadjustSigned_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccgTg,
                       label: Text.Printf.$wadjustSigned_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgTg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccgTh; else goto ccgTi;
       ccgTh: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$wadjustSigned_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccgTi: // global
           I64[Sp - 40] = block_ccgT9_info;
           R1 = R4;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucgU3; else goto ccgTa;
       ucgU3: // global
           call _ccgT9(R1) args: 0, res: 0, upd: 0;
       ccgTa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgT9() //  [R1]
         { info_tbl: [(ccgT9,
                       label: block_ccgT9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgT9: // global
           if (R1 & 7 == 1) goto ccgTd; else goto ccgTe;
       ccgTd: // global
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       ccgTe: // global
           I64[Sp] = block_ccgTo_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucgU2; else goto ccgTq;
       ucgU2: // global
           call _ccgTo(R1) args: 0, res: 0, upd: 0;
       ccgTq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgTo() //  [R1]
         { info_tbl: [(ccgTo,
                       label: block_ccgTo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgTo: // global
           _sccla::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccgTx; else goto ccgTN;
       ccgTx: // global
           I64[Sp] = block_ccgTu_info;
           R1 = _sccla::P64;
           if (R1 & 7 != 0) goto ucgU4; else goto ccgTy;
       ucgU4: // global
           call _ccgTu(R1) args: 0, res: 0, upd: 0;
       ccgTy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccgTN: // global
           I64[Sp] = block_ccgTL_info;
           R1 = _sccla::P64;
           if (R1 & 7 != 0) goto ucgU5; else goto ccgTO;
       ucgU5: // global
           call _ccgTL(R1) args: 0, res: 0, upd: 0;
       ccgTO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgTu() //  [R1]
         { info_tbl: [(ccgTu,
                       label: block_ccgTu_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgTu: // global
           _sccl7::P64 = P64[Sp + 8];
           _sccl8::P64 = P64[Sp + 16];
           _scclb::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccgTE; else goto ccgTI;
       ccgTE: // global
           R5 = _scclb::P64;
           R4 = Text.Printf.$fPrintfArgDouble3_closure;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       ccgTI: // global
           R5 = _scclb::P64;
           R4 = R1;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccgTL() //  [R1]
         { info_tbl: [(ccgTL,
                       label: block_ccgTL_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgTL: // global
           _sccl7::P64 = P64[Sp + 8];
           _sccl8::P64 = P64[Sp + 16];
           _scclb::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccgTU; else goto ccgTY;
       ccgTU: // global
           R5 = _scclb::P64;
           R4 = Text.Printf.$fPrintfArgDouble1_closure;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       ccgTY: // global
           R5 = _scclb::P64;
           R4 = R1;
           R3 = _sccl8::P64;
           R2 = _sccl7::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.681662607 UTC

[section ""data" . Text.Printf.$w$sformatRealFloat_closure" {
     Text.Printf.$w$sformatRealFloat_closure:
         const Text.Printf.$w$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$w$sformatRealFloat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgUA: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucgWh_srtd" {
     ucgWh_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclw_entry() //  [R1]
         { info_tbl: [(ccgUN,
                       label: sat_scclw_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgUN: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgUO; else goto ccgUP;
       ccgUO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgUP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgUL_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 69;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgUL() //  [R1, R2]
         { info_tbl: [(ccgUL,
                       label: block_ccgUL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgUL: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucgWi_srtd" {
     ucgWi_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclA_entry() //  [R1]
         { info_tbl: [(ccgUY,
                       label: sat_scclA_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgUY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgUZ; else goto ccgV0;
       ccgUZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgV0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgUW_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 70;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgUW() //  [R1, R2]
         { info_tbl: [(ccgUW,
                       label: block_ccgUW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgUW: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucgWj_srtd" {
     ucgWj_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclE_entry() //  [R1]
         { info_tbl: [(ccgV9,
                       label: sat_scclE_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgV9: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgVa; else goto ccgVb;
       ccgVa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgVb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgV7_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 71;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgV7() //  [R1, R2]
         { info_tbl: [(ccgV7,
                       label: block_ccgV7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgV7: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucgWk_srtd" {
     ucgWk_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclI_entry() //  [R1]
         { info_tbl: [(ccgVk,
                       label: sat_scclI_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgVk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgVl; else goto ccgVm;
       ccgVl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgVm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgVi_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 101;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgVi() //  [R1, R2]
         { info_tbl: [(ccgVi,
                       label: block_ccgVi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgVi: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucgWl_srtd" {
     ucgWl_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclM_entry() //  [R1]
         { info_tbl: [(ccgVv,
                       label: sat_scclM_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgVv: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgVw; else goto ccgVx;
       ccgVw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgVx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgVt_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 102;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgVt() //  [R1, R2]
         { info_tbl: [(ccgVt,
                       label: block_ccgVt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgVt: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucgWm_srtd" {
     ucgWm_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclQ_entry() //  [R1]
         { info_tbl: [(ccgVG,
                       label: sat_scclQ_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgVG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgVH; else goto ccgVI;
       ccgVH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgVI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgVE_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgVE() //  [R1, R2]
         { info_tbl: [(ccgVE,
                       label: block_ccgVE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgVE: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucgWn_srtd" {
     ucgWn_srtd:
         const SccKB_srt+88;
         const 36;
         const 34359738369;
 },
 sat_scclU_entry() //  [R1]
         { info_tbl: [(ccgVR,
                       label: sat_scclU_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgVR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgVS; else goto ccgVT;
       ccgVS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgVT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgVP_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgVP() //  [R1, R2]
         { info_tbl: [(ccgVP,
                       label: block_ccgVP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgVP: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucgWo_srtd" {
     ucgWo_srtd:
         const SccKB_srt+32;
         const 46;
         const 39582418600065;
 },
 Text.Printf.$w$sformatRealFloat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccgW4,
                       label: Text.Printf.$w$sformatRealFloat_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgW4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccgW8; else goto ccgW7;
       ccgW8: // global
           HpAlloc = 64;
           R1 = Text.Printf.$w$sformatRealFloat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ccgW7: // global
           _scclq::P64 = P64[Sp];
           _sccls::I64 = I64[Sp + 8];
           if (_sccls::I64 < 101) goto ucgW9; else goto ucgWd;
       ucgW9: // global
           if (_sccls::I64 < 71) goto ucgWa; else goto ucgWc;
       ucgWa: // global
           if (_sccls::I64 < 70) goto ucgWb; else goto ccgVY;
       ucgWb: // global
           if (_sccls::I64 < 69) goto ccgVW; else goto ccgVX;
       ccgVX: // global
           I64[Hp - 56] = sat_scclw_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccgVY: // global
           I64[Hp - 56] = sat_scclA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucgWc: // global
           if (_sccls::I64 >= 72) goto ccgVW; else goto ccgVZ;
       ccgVZ: // global
           I64[Hp - 56] = sat_scclE_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucgWd: // global
           if (_sccls::I64 < 103) goto ucgWe; else goto ucgWf;
       ucgWe: // global
           if (_sccls::I64 < 102) goto ccgW0; else goto ccgW1;
       ccgW0: // global
           I64[Hp - 56] = sat_scclI_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccgW1: // global
           I64[Hp - 56] = sat_scclM_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucgWf: // global
           if (_sccls::I64 < 104) goto ccgW2; else goto ucgWg;
       ccgW2: // global
           I64[Hp - 56] = sat_scclQ_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucgWg: // global
           if (_sccls::I64 != 118) goto ccgVW; else goto ccgW3;
       ccgVW: // global
           Hp = Hp - 64;
           R2 = _sccls::I64;
           Sp = Sp + 16;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       ccgW3: // global
           I64[Hp - 56] = sat_scclU_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _scclq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.727109619 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure" {
     Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure:
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble_$sformatRealFloat_entry() //  [R2,
                                                              R3]
         { info_tbl: [(ccgXS,
                       label: Text.Printf.$fPrintfArgDouble_$sformatRealFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgXS: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccgXW; else goto ccgXX;
       ccgXW: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccgXX: // global
           I64[Sp - 16] = block_ccgXP_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucgY5; else goto ccgXQ;
       ucgY5: // global
           call _ccgXP(R1) args: 0, res: 0, upd: 0;
       ccgXQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgXP() //  [R1]
         { info_tbl: [(ccgXP,
                       label: block_ccgXP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgXP: // global
           I64[Sp - 40] = block_ccgXV_info;
           _scclY::P64 = P64[R1 + 7];
           _scclZ::P64 = P64[R1 + 15];
           _sccm0::P64 = P64[R1 + 23];
           _sccm1::P64 = P64[R1 + 31];
           _sccm2::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _scclZ::P64;
           P64[Sp - 24] = _sccm0::P64;
           P64[Sp - 16] = _sccm1::P64;
           P64[Sp - 8] = _sccm2::P64;
           P64[Sp] = _scclY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucgY4; else goto ccgXZ;
       ucgY4: // global
           call _ccgXV(R1) args: 0, res: 0, upd: 0;
       ccgXZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccgXV() //  [R1]
         { info_tbl: [(ccgXV,
                       label: block_ccgXV_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgXV: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 32];
           I64[Sp + 48] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.738042921 UTC

[section ""data" . Text.Printf.$w$sformatRealFloat1_closure" {
     Text.Printf.$w$sformatRealFloat1_closure:
         const Text.Printf.$w$sformatRealFloat1_info;
         const 0;
 },
 Text.Printf.$w$sformatRealFloat1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgYm: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sccmi_entry() //  [R1]
         { info_tbl: [(ccgYz,
                       label: sat_sccmi_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgYz: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgYA; else goto ccgYB;
       ccgYA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgYB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgYx_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 69;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgYx() //  [R1, R2]
         { info_tbl: [(ccgYx,
                       label: block_ccgYx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgYx: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmm_entry() //  [R1]
         { info_tbl: [(ccgYK,
                       label: sat_sccmm_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgYK: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgYL; else goto ccgYM;
       ccgYL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgYM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgYI_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 70;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgYI() //  [R1, R2]
         { info_tbl: [(ccgYI,
                       label: block_ccgYI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgYI: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmq_entry() //  [R1]
         { info_tbl: [(ccgYV,
                       label: sat_sccmq_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgYV: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgYW; else goto ccgYX;
       ccgYW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgYX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgYT_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 71;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgYT() //  [R1, R2]
         { info_tbl: [(ccgYT,
                       label: block_ccgYT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgYT: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmu_entry() //  [R1]
         { info_tbl: [(ccgZ6,
                       label: sat_sccmu_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgZ6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgZ7; else goto ccgZ8;
       ccgZ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgZ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgZ4_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 101;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgZ4() //  [R1, R2]
         { info_tbl: [(ccgZ4,
                       label: block_ccgZ4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgZ4: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmy_entry() //  [R1]
         { info_tbl: [(ccgZh,
                       label: sat_sccmy_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgZh: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgZi; else goto ccgZj;
       ccgZi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgZj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgZf_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 102;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgZf() //  [R1, R2]
         { info_tbl: [(ccgZf,
                       label: block_ccgZf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgZf: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmC_entry() //  [R1]
         { info_tbl: [(ccgZs,
                       label: sat_sccmC_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgZs: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgZt; else goto ccgZu;
       ccgZt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgZu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgZq_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgZq() //  [R1, R2]
         { info_tbl: [(ccgZq,
                       label: block_ccgZq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgZq: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccmG_entry() //  [R1]
         { info_tbl: [(ccgZD,
                       label: sat_sccmG_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgZD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccgZE; else goto ccgZF;
       ccgZE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgZF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccgZB_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccgZB() //  [R1, R2]
         { info_tbl: [(ccgZB,
                       label: block_ccgZB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgZB: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uch03_srtd" {
     uch03_srtd:
         const SccKB_srt+32;
         const 48;
         const 145135534868481;
 },
 Text.Printf.$w$sformatRealFloat1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccgZQ,
                       label: Text.Printf.$w$sformatRealFloat1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgZQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccgZU; else goto ccgZT;
       ccgZU: // global
           HpAlloc = 64;
           R1 = Text.Printf.$w$sformatRealFloat1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ccgZT: // global
           _sccmc::P64 = P64[Sp];
           _sccme::I64 = I64[Sp + 8];
           if (_sccme::I64 < 101) goto ucgZV; else goto ucgZZ;
       ucgZV: // global
           if (_sccme::I64 < 71) goto ucgZW; else goto ucgZY;
       ucgZW: // global
           if (_sccme::I64 < 70) goto ucgZX; else goto ccgZK;
       ucgZX: // global
           if (_sccme::I64 < 69) goto ccgZI; else goto ccgZJ;
       ccgZJ: // global
           I64[Hp - 56] = sat_sccmi_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccgZK: // global
           I64[Hp - 56] = sat_sccmm_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucgZY: // global
           if (_sccme::I64 >= 72) goto ccgZI; else goto ccgZL;
       ccgZL: // global
           I64[Hp - 56] = sat_sccmq_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ucgZZ: // global
           if (_sccme::I64 < 103) goto uch00; else goto uch01;
       uch00: // global
           if (_sccme::I64 < 102) goto ccgZM; else goto ccgZN;
       ccgZM: // global
           I64[Hp - 56] = sat_sccmu_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccgZN: // global
           I64[Hp - 56] = sat_sccmy_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uch01: // global
           if (_sccme::I64 < 104) goto ccgZO; else goto uch02;
       ccgZO: // global
           I64[Hp - 56] = sat_sccmC_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uch02: // global
           if (_sccme::I64 != 118) goto ccgZI; else goto ccgZP;
       ccgZI: // global
           Hp = Hp - 64;
           R2 = _sccme::I64;
           Sp = Sp + 16;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       ccgZP: // global
           I64[Hp - 56] = sat_sccmG_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sccmc::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.773726836 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure" {
     Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure:
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat_$sformatRealFloat_entry() //  [R2, R3]
         { info_tbl: [(cch1q,
                       label: Text.Printf.$fPrintfArgFloat_$sformatRealFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch1q: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cch1u; else goto cch1v;
       cch1u: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cch1v: // global
           I64[Sp - 16] = block_cch1n_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uch1D; else goto cch1o;
       uch1D: // global
           call _cch1n(R1) args: 0, res: 0, upd: 0;
       cch1o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cch1n() //  [R1]
         { info_tbl: [(cch1n,
                       label: block_cch1n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch1n: // global
           I64[Sp - 40] = block_cch1t_info;
           _sccmK::P64 = P64[R1 + 7];
           _sccmL::P64 = P64[R1 + 15];
           _sccmM::P64 = P64[R1 + 23];
           _sccmN::P64 = P64[R1 + 31];
           _sccmO::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _sccmL::P64;
           P64[Sp - 24] = _sccmM::P64;
           P64[Sp - 16] = _sccmN::P64;
           P64[Sp - 8] = _sccmO::P64;
           P64[Sp] = _sccmK::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uch1C; else goto cch1x;
       uch1C: // global
           call _cch1t(R1) args: 0, res: 0, upd: 0;
       cch1x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cch1t() //  [R1]
         { info_tbl: [(cch1t,
                       label: block_cch1t_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch1t: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 32];
           I64[Sp + 48] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.784323085 UTC

[section ""data" . Text.Printf.$wformatRealFloat_closure" {
     Text.Printf.$wformatRealFloat_closure:
         const Text.Printf.$wformatRealFloat_info;
         const 0;
 },
 Text.Printf.$wformatRealFloat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch1U: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatRealFloat_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccn5_entry() //  [R1]
         { info_tbl: [(cch27,
                       label: sat_sccn5_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch27: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cch28; else goto cch29;
       cch28: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch29: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cch25_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 69;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cch25() //  [R1, R2]
         { info_tbl: [(cch25,
                       label: block_cch25_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch25: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccn9_entry() //  [R1]
         { info_tbl: [(cch2i,
                       label: sat_sccn9_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch2i: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cch2j; else goto cch2k;
       cch2j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch2k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cch2g_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 70;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cch2g() //  [R1, R2]
         { info_tbl: [(cch2g,
                       label: block_cch2g_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch2g: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnd_entry() //  [R1]
         { info_tbl: [(cch2t,
                       label: sat_sccnd_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch2t: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cch2u; else goto cch2v;
       cch2u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch2v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cch2r_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 71;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cch2r() //  [R1, R2]
         { info_tbl: [(cch2r,
                       label: block_cch2r_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch2r: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnh_entry() //  [R1]
         { info_tbl: [(cch2E,
                       label: sat_sccnh_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch2E: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cch2F; else goto cch2G;
       cch2F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch2G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cch2C_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 101;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cch2C() //  [R1, R2]
         { info_tbl: [(cch2C,
                       label: block_cch2C_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch2C: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnl_entry() //  [R1]
         { info_tbl: [(cch2P,
                       label: sat_sccnl_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch2P: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cch2Q; else goto cch2R;
       cch2Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch2R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cch2N_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 102;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cch2N() //  [R1, R2]
         { info_tbl: [(cch2N,
                       label: block_cch2N_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch2N: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnp_entry() //  [R1]
         { info_tbl: [(cch30,
                       label: sat_sccnp_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch30: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cch31; else goto cch32;
       cch31: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch32: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cch2Y_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 103;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cch2Y() //  [R1, R2]
         { info_tbl: [(cch2Y,
                       label: block_cch2Y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch2Y: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccnt_entry() //  [R1]
         { info_tbl: [(cch3b,
                       label: sat_sccnt_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch3b: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cch3c; else goto cch3d;
       cch3c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch3d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cch39_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 103;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cch39() //  [R1, R2]
         { info_tbl: [(cch39,
                       label: block_cch39_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch39: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uch3B_srtd" {
     uch3B_srtd:
         const SccKB_srt+32;
         const 50;
         const 567347999948801;
 },
 Text.Printf.$wformatRealFloat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cch3o,
                       label: Text.Printf.$wformatRealFloat_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch3o: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cch3s; else goto cch3r;
       cch3s: // global
           HpAlloc = 72;
           R1 = Text.Printf.$wformatRealFloat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cch3r: // global
           _sccmY::P64 = P64[Sp];
           _sccmZ::P64 = P64[Sp + 8];
           _sccn1::I64 = I64[Sp + 16];
           if (_sccn1::I64 < 101) goto uch3t; else goto uch3x;
       uch3t: // global
           if (_sccn1::I64 < 71) goto uch3u; else goto uch3w;
       uch3u: // global
           if (_sccn1::I64 < 70) goto uch3v; else goto cch3i;
       uch3v: // global
           if (_sccn1::I64 < 69) goto cch3g; else goto cch3h;
       cch3h: // global
           I64[Hp - 64] = sat_sccn5_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cch3i: // global
           I64[Hp - 64] = sat_sccn9_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uch3w: // global
           if (_sccn1::I64 >= 72) goto cch3g; else goto cch3j;
       cch3j: // global
           I64[Hp - 64] = sat_sccnd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uch3x: // global
           if (_sccn1::I64 < 103) goto uch3y; else goto uch3z;
       uch3y: // global
           if (_sccn1::I64 < 102) goto cch3k; else goto cch3l;
       cch3k: // global
           I64[Hp - 64] = sat_sccnh_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cch3l: // global
           I64[Hp - 64] = sat_sccnl_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uch3z: // global
           if (_sccn1::I64 < 104) goto cch3m; else goto uch3A;
       cch3m: // global
           I64[Hp - 64] = sat_sccnp_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uch3A: // global
           if (_sccn1::I64 != 118) goto cch3g; else goto cch3n;
       cch3g: // global
           Hp = Hp - 72;
           R2 = _sccn1::I64;
           Sp = Sp + 24;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       cch3n: // global
           I64[Hp - 64] = sat_sccnt_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sccmY::P64;
           P64[Hp] = _sccmZ::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.820541808 UTC

[section ""data" . Text.Printf.formatRealFloat_closure" {
     Text.Printf.formatRealFloat_closure:
         const Text.Printf.formatRealFloat_info;
         const 0;
 },
 Text.Printf.formatRealFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(cch4Y,
                       label: Text.Printf.formatRealFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch4Y: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cch52; else goto cch53;
       cch52: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatRealFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cch53: // global
           I64[Sp - 24] = block_cch4V_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uch5b; else goto cch4W;
       uch5b: // global
           call _cch4V(R1) args: 0, res: 0, upd: 0;
       cch4W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cch4V() //  [R1]
         { info_tbl: [(cch4V,
                       label: block_cch4V_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch4V: // global
           I64[Sp - 40] = block_cch51_info;
           _sccny::P64 = P64[R1 + 7];
           _sccnz::P64 = P64[R1 + 15];
           _sccnA::P64 = P64[R1 + 23];
           _sccnB::P64 = P64[R1 + 31];
           _sccnC::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _sccnz::P64;
           P64[Sp - 24] = _sccnA::P64;
           P64[Sp - 16] = _sccnB::P64;
           P64[Sp - 8] = _sccnC::P64;
           P64[Sp] = _sccny::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uch5a; else goto cch55;
       uch5a: // global
           call _cch51(R1) args: 0, res: 0, upd: 0;
       cch55: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cch51() //  [R1]
         { info_tbl: [(cch51,
                       label: block_cch51_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch51: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 56];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatRealFloat_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.82936596 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgDouble_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble_$cparseFormat_entry() //  [R2, R3]
         { info_tbl: [(cch5D,
                       label: Text.Printf.$fPrintfArgDouble_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch5D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cch5E; else goto cch5F;
       cch5E: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgDouble_$cparseFormat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cch5F: // global
           I64[Sp - 8] = block_cch5w_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uch5P; else goto cch5x;
       uch5P: // global
           call _cch5w(R1) args: 0, res: 0, upd: 0;
       cch5x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cch5w() //  [R1]
         { info_tbl: [(cch5w,
                       label: block_cch5w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch5w: // global
           if (R1 & 7 == 1) goto cch5A; else goto cch5B;
       cch5A: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cch5B: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cch5O; else goto cch5N;
       cch5O: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cch5N: // global
           _sccnK::P64 = P64[R1 + 6];
           _sccnL::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccnK::P64;
           P64[Hp] = _sccnL::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.835514588 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_closure" {
     Text.Printf.$fPrintfArgDouble_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure+2;
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.83770712 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgFloat_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat_$cparseFormat_entry() //  [R2, R3]
         { info_tbl: [(cch6e,
                       label: Text.Printf.$fPrintfArgFloat_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch6e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cch6f; else goto cch6g;
       cch6f: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgFloat_$cparseFormat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cch6g: // global
           I64[Sp - 8] = block_cch67_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uch6q; else goto cch68;
       uch6q: // global
           call _cch67(R1) args: 0, res: 0, upd: 0;
       cch68: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cch67() //  [R1]
         { info_tbl: [(cch67,
                       label: block_cch67_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch67: // global
           if (R1 & 7 == 1) goto cch6b; else goto cch6c;
       cch6b: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cch6c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cch6p; else goto cch6o;
       cch6p: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cch6o: // global
           _sccnP::P64 = P64[R1 + 6];
           _sccnQ::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccnP::P64;
           P64[Hp] = _sccnQ::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.843614641 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_closure" {
     Text.Printf.$fPrintfArgFloat_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure+2;
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.84665309 UTC

[section ""data" . Text.Printf.$w$sformatString_closure" {
     Text.Printf.$w$sformatString_closure:
         const Text.Printf.$w$sformatString_info;
         const 0;
 },
 Text.Printf.$w$sformatString_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch6F: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatString_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scco5_entry() //  [R1]
         { info_tbl: [(cch76,
                       label: sat_scco5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch76: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cch77; else goto cch78;
       cch77: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch78: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cch6Z_info;
           _sccnR::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sccnR::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uch7r; else goto cch70;
       uch7r: // global
           call _cch6Z(R1) args: 0, res: 0, upd: 0;
       cch70: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cch6Z() //  [R1]
         { info_tbl: [(cch6Z,
                       label: block_cch6Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch6Z: // global
           if (R1 & 7 == 1) goto cch73; else goto cch74;
       cch73: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cch74: // global
           I64[Sp] = block_cch7e_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uch7q; else goto cch7g;
       uch7q: // global
           call _cch7e(R1) args: 0, res: 0, upd: 0;
       cch7g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cch7e() //  [R1]
         { info_tbl: [(cch7e,
                       label: block_cch7e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch7e: // global
           _scco3::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _scco3::I64)) goto cch7o; else goto cch7p;
       cch7o: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cch7p: // global
           R3 = P64[Sp + 8];
           R2 = _scco3::I64;
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sccnZ_entry() //  [R1]
         { info_tbl: [(cch7s,
                       label: g_sccnZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch7s: // global
           _sccnZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cch7t; else goto cch7u;
       cch7u: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cch7w; else goto cch7v;
       cch7w: // global
           HpAlloc = 32;
           goto cch7t;
       cch7t: // global
           R1 = _sccnZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch7v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccnZ::P64;
           _sccnR::P64 = P64[_sccnZ::P64 + 16];
           _sccnS::P64 = P64[_sccnZ::P64 + 24];
           _sccnT::P64 = P64[_sccnZ::P64 + 32];
           _sccnU::P64 = P64[_sccnZ::P64 + 40];
           I64[Hp - 24] = sat_scco5_info;
           P64[Hp - 8] = _sccnR::P64;
           P64[Hp] = _sccnT::P64;
           R5 = Hp - 24;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sccnU::P64;
           R2 = _sccnS::P64;
           Sp = Sp - 16;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$w$sformatString_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cch7B,
                       label: Text.Printf.$w$sformatString_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch7B: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cch7C; else goto cch7D;
       cch7C: // global
           R1 = Text.Printf.$w$sformatString_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cch7D: // global
           if (R6 == 118) goto cch7A; else goto cch7z;
       cch7A: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = 115;
           Sp = Sp - 40;
           goto uch7P;
       cch7z: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           goto uch7P;
       uch7P: // global
           call _cch6M() args: 0, res: 0, upd: 0;
     }
 },
 _cch6M() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch6M: // global
           Hp = Hp + 48;
           _sccnX::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto cch7G; else goto cch7F;
       cch7G: // global
           HpAlloc = 48;
           I64[Sp - 8] = block_cch6L_info;
           R1 = _sccnX::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cch7F: // global
           if (_sccnX::I64 == 115) goto cch7J; else goto cch7I;
       cch7J: // global
           I64[Hp - 40] = g_sccnZ_info;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 40;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 40;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cch7I: // global
           Hp = Hp - 48;
           R2 = _sccnX::I64;
           Sp = Sp + 40;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cch6L() //  [R1]
         { info_tbl: [(cch6L,
                       label: block_cch6L_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch6L: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _cch6M() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.866370313 UTC

[section ""data" . Text.Printf.$wformatString_closure" {
     Text.Printf.$wformatString_closure:
         const Text.Printf.$wformatString_info;
         const 0;
 },
 Text.Printf.$wformatString_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch8s: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatString_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sccoj_entry() //  [R1]
         { info_tbl: [(cch8V,
                       label: sat_sccoj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch8V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cch8W; else goto cch8X;
       cch8W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch8X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.Printf.toChar_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccox_entry() //  [R1]
         { info_tbl: [(cch9s,
                       label: sat_sccox_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch9s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cch9t; else goto cch9u;
       cch9t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch9u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 32] - 1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wgo_sccoo_entry(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccov_entry() //  [R1]
         { info_tbl: [(cch9z,
                       label: sat_sccov_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch9z: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cch9A; else goto cch9B;
       cch9A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch9B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.toChar_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sccoy_entry() //  [R1]
         { info_tbl: [(cch9H,
                       label: sat_sccoy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch9H: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cch9I; else goto cch9J;
       cch9I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cch9J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.toChar_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $wgo_sccoo_entry() //  [R1, R2, R3]
         { info_tbl: [(cch9O,
                       label: $wgo_sccoo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch9O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cch9P; else goto cch9Q;
       cch9P: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cch9Q: // global
           I64[Sp - 32] = block_cch9e_info;
           _sccoo::P64 = R1;
           _scco8::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 24] = _scco8::P64;
           P64[Sp - 16] = _sccoo::P64;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucha1; else goto cch9f;
       ucha1: // global
           call _cch9e(R1) args: 0, res: 0, upd: 0;
       cch9f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cch9e() //  [R1]
         { info_tbl: [(cch9e,
                       label: block_cch9e_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch9e: // global
           if (R1 & 7 == 1) goto cch9L; else goto cch9M;
       cch9L: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cch9M: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cch9V; else goto cch9U;
       cch9V: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cch9U: // global
           _scco8::P64 = P64[Sp + 8];
           _sccos::P64 = P64[R1 + 6];
           _sccou::I64 = I64[Sp + 24];
           if (_sccou::I64 != 1) goto cch9Y; else goto ccha0;
       cch9Y: // global
           _sccot::P64 = P64[R1 + 14];
           I64[Hp - 88] = sat_sccox_info;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sccot::P64;
           I64[Hp - 56] = _sccou::I64;
           I64[Hp - 48] = sat_sccov_info;
           P64[Hp - 32] = _scco8::P64;
           P64[Hp - 24] = _sccos::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccha0: // global
           I64[Hp - 88] = sat_sccoy_info;
           P64[Hp - 72] = _scco8::P64;
           P64[Hp - 64] = _sccos::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 88;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cch9Z::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cch9Z::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccoz_entry() //  [R1]
         { info_tbl: [(ccha6,
                       label: sat_sccoz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccha6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccha7; else goto ccha8;
       ccha7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccha8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cch8M_info;
           _scco8::P64 = P64[R1 + 16];
           _scco9::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _scco8::P64;
           P64[Sp - 24] = _scco9::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uchak; else goto cch8N;
       uchak: // global
           call _cch8M(R1) args: 0, res: 0, upd: 0;
       cch8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cch8M() //  [R1]
         { info_tbl: [(cch8M,
                       label: block_cch8M_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch8M: // global
           if (R1 & 7 == 1) goto ccha3; else goto ccha4;
       ccha3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchab; else goto cchaa;
       cchab: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cchaa: // global
           I64[Hp - 16] = sat_sccoj_info;
           P64[Hp] = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
       ccha4: // global
           I64[Sp] = block_cch90_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uchaj; else goto cch91;
       uchaj: // global
           call _cch90(R1) args: 0, res: 0, upd: 0;
       cch91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cch90() //  [R1]
         { info_tbl: [(cch90,
                       label: block_cch90_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch90: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cchaf; else goto cchae;
       cchaf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cchae: // global
           _sccom::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _sccom::I64)) goto cchah; else goto cchai;
       cchah: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cchai: // global
           I64[Hp - 8] = $wgo_sccoo_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _sccom::I64;
           R2 = P64[Sp + 16];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call $wgo_sccoo_entry(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sccoh_entry() //  [R1]
         { info_tbl: [(cchal,
                       label: g_sccoh_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchal: // global
           _sccoh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccham; else goto cchan;
       cchan: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cchap; else goto cchao;
       cchap: // global
           HpAlloc = 40;
           goto ccham;
       ccham: // global
           R1 = _sccoh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchao: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccoh::P64;
           _scco8::P64 = P64[_sccoh::P64 + 16];
           _scco9::P64 = P64[_sccoh::P64 + 24];
           _sccoa::P64 = P64[_sccoh::P64 + 32];
           _sccob::P64 = P64[_sccoh::P64 + 40];
           _sccoc::P64 = P64[_sccoh::P64 + 48];
           I64[Hp - 32] = sat_sccoz_info;
           P64[Hp - 16] = _scco8::P64;
           P64[Hp - 8] = _scco9::P64;
           P64[Hp] = _sccob::P64;
           R5 = Hp - 32;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sccoc::P64;
           R2 = _sccoa::P64;
           Sp = Sp - 16;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$wformatString_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cchau,
                       label: Text.Printf.$wformatString_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchau: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cchav; else goto cchaw;
       cchav: // global
           R1 = Text.Printf.$wformatString_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cchaw: // global
           _sccoB::I64 = I64[Sp];
           if (_sccoB::I64 == 118) goto cchat; else goto cchas;
       cchat: // global
           P64[Sp] = R2;
           P64[Sp - 40] = R3;
           P64[Sp - 32] = R4;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           I64[Sp - 8] = 115;
           Sp = Sp - 40;
           goto uchaI;
       cchas: // global
           P64[Sp - 40] = R3;
           P64[Sp - 32] = R4;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           I64[Sp - 8] = _sccoB::I64;
           P64[Sp] = R2;
           Sp = Sp - 40;
           goto uchaI;
       uchaI: // global
           call _cch8z() args: 0, res: 0, upd: 0;
     }
 },
 _cch8z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch8z: // global
           Hp = Hp + 56;
           _sccof::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto cchaz; else goto cchay;
       cchaz: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_cch8y_info;
           R1 = _sccof::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cchay: // global
           if (_sccof::I64 == 115) goto cchaC; else goto cchaB;
       cchaC: // global
           I64[Hp - 48] = g_sccoh_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 48;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cchaB: // global
           Hp = Hp - 56;
           R2 = _sccof::I64;
           Sp = Sp + 48;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cch8y() //  [R1]
         { info_tbl: [(cch8y,
                       label: block_cch8y_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch8y: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _cch8z() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.896359762 UTC

[section ""data" . Text.Printf.formatString_closure" {
     Text.Printf.formatString_closure:
         const Text.Printf.formatString_info;
         const 0;
 },
 Text.Printf.formatString_entry() //  [R2, R3, R4]
         { info_tbl: [(cchc2,
                       label: Text.Printf.formatString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchc2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cchc6; else goto cchc7;
       cchc6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatString_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cchc7: // global
           I64[Sp - 24] = block_cchbZ_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uchcf; else goto cchc0;
       uchcf: // global
           call _cchbZ(R1) args: 0, res: 0, upd: 0;
       cchc0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchbZ() //  [R1]
         { info_tbl: [(cchbZ,
                       label: block_cchbZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchbZ: // global
           I64[Sp - 24] = block_cchc5_info;
           _sccoG::P64 = P64[R1 + 7];
           _sccoH::P64 = P64[R1 + 15];
           _sccoI::P64 = P64[R1 + 23];
           R1 = P64[R1 + 55];
           P64[Sp - 16] = _sccoH::P64;
           P64[Sp - 8] = _sccoI::P64;
           P64[Sp] = _sccoG::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uchce; else goto cchc9;
       uchce: // global
           call _cchc5(R1) args: 0, res: 0, upd: 0;
       cchc9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchc5() //  [R1]
         { info_tbl: [(cchc5,
                       label: block_cchc5_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchc5: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatString_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.904273009 UTC

[section ""data" . lvl22_rcccn_closure" {
     lvl22_rcccn_closure:
         const lvl22_rcccn_info;
         const 0;
 },
 lvl22_rcccn_entry() //  [R2, R3]
         { info_tbl: [(cchcF,
                       label: lvl22_rcccn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchcF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchcG; else goto cchcH;
       cchcG: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl22_rcccn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchcH: // global
           I64[Sp - 8] = block_cchcy_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchcR; else goto cchcz;
       uchcR: // global
           call _cchcy(R1) args: 0, res: 0, upd: 0;
       cchcz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchcy() //  [R1]
         { info_tbl: [(cchcy,
                       label: block_cchcy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchcy: // global
           if (R1 & 7 == 1) goto cchcC; else goto cchcD;
       cchcC: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cchcD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cchcQ; else goto cchcP;
       cchcQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchcP: // global
           _sccoS::P64 = P64[R1 + 6];
           _sccoT::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sccoS::P64;
           P64[Hp] = _sccoT::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.911425355 UTC

[section ""data" . Text.Printf.$fPrintfArg[]_closure" {
     Text.Printf.$fPrintfArg[]_closure:
         const Text.Printf.$fPrintfArg[]_info;
         const 0;
 },
 sat_sccoV_entry() //  [R1, R2, R3]
         { info_tbl: [(cchdd,
                       label: sat_sccoV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchdd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Text.Printf.formatString_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$fPrintfArg[]_entry() //  [R2]
         { info_tbl: [(cchdh,
                       label: Text.Printf.$fPrintfArg[]_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchdh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cchdl; else goto cchdk;
       cchdl: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArg[]_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cchdk: // global
           I64[Hp - 32] = sat_sccoV_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Text.Printf.C:PrintfArg_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = lvl22_rcccn_closure+2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.916696537 UTC

[section ""data" . lvl23_rccco_closure" {
     lvl23_rccco_closure:
         const GHC.Types.C#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.918598888 UTC

[section ""data" . sat_sccoW_closure" {
     sat_sccoW_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.920246922 UTC

[section ""data" . sat_sccoX_closure" {
     sat_sccoX_closure:
         const :_con_info;
         const sat_sccoW_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.922275368 UTC

[section ""data" . lvl24_rcccp_closure" {
     lvl24_rcccp_closure:
         const lvl24_rcccp_info;
         const 0;
         const 0;
         const 0;
 },
 lvl24_rcccp_entry() //  [R1]
         { info_tbl: [(cchdE,
                       label: lvl24_rcccp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchdE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchdF; else goto cchdG;
       cchdF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchdG: // global
           (_cchdB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cchdB::I64 == 0) goto cchdD; else goto cchdC;
       cchdD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchdC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cchdB::I64;
           R3 = sat_sccoX_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.926218979 UTC

[section ""cstring" . lvl25_rcccq_bytes" {
     lvl25_rcccq_bytes:
         I8[] [48,88]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.928045893 UTC

[section ""data" . lvl26_rcccr_closure" {
     lvl26_rcccr_closure:
         const lvl26_rcccr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_rcccr_entry() //  [R1]
         { info_tbl: [(cchdV,
                       label: lvl26_rcccr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchdV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchdW; else goto cchdX;
       cchdW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchdX: // global
           (_cchdS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cchdS::I64 == 0) goto cchdU; else goto cchdT;
       cchdU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchdT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cchdS::I64;
           R2 = lvl25_rcccq_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.931919857 UTC

[section ""cstring" . lvl27_rcccs_bytes" {
     lvl27_rcccs_bytes:
         I8[] [48,98]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.934087855 UTC

[section ""data" . lvl28_rccct_closure" {
     lvl28_rccct_closure:
         const lvl28_rccct_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_rccct_entry() //  [R1]
         { info_tbl: [(cchec,
                       label: lvl28_rccct_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchec: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cched; else goto cchee;
       cched: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchee: // global
           (_cche9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cche9::I64 == 0) goto ccheb; else goto cchea;
       ccheb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchea: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cche9::I64;
           R2 = lvl27_rcccs_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.937773844 UTC

[section ""cstring" . lvl29_rcccu_bytes" {
     lvl29_rcccu_bytes:
         I8[] [112,114,105,110,116,102,58,32,105,108,108,101,103,97,108,32,99,104,97,114,32,99,111,110,118,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.940202049 UTC

[section ""data" . lvl30_rcccv_closure" {
     lvl30_rcccv_closure:
         const lvl30_rcccv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_rcccv_entry() //  [R1]
         { info_tbl: [(cchev,
                       label: lvl30_rcccv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchev: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cchew; else goto cchex;
       cchew: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchex: // global
           (_ccheq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccheq::I64 == 0) goto cches; else goto ccher;
       cches: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccher: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccheq::I64;
           I64[Sp - 24] = block_cchet_info;
           R2 = lvl29_rcccu_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchet() //  [R1]
         { info_tbl: [(cchet,
                       label: block_cchet_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchet: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.945493797 UTC

[section ""data" . sat_sccoZ_closure" {
     sat_sccoZ_closure:
         const GHC.Types.I#_con_info;
         const 1114111;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.947078506 UTC

[section ""data" . sat_sccp0_closure" {
     sat_sccp0_closure:
         const :_con_info;
         const sat_sccoZ_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.948975517 UTC

[section ""data" . lvl31_rcccw_closure" {
     lvl31_rcccw_closure:
         const lvl31_rcccw_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_rcccw_entry() //  [R1]
         { info_tbl: [(ccheT,
                       label: lvl31_rcccw_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccheT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccheU; else goto ccheV;
       ccheU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccheV: // global
           (_ccheQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccheQ::I64 == 0) goto ccheS; else goto ccheR;
       ccheS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccheR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccheQ::I64;
           R3 = sat_sccp0_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.953146049 UTC

[section ""data" . sat_sccp1_closure" {
     sat_sccp1_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.954872003 UTC

[section ""data" . sat_sccp2_closure" {
     sat_sccp2_closure:
         const :_con_info;
         const sat_sccp1_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.95675457 UTC

[section ""data" . lvl32_rcccx_closure" {
     lvl32_rcccx_closure:
         const lvl32_rcccx_info;
         const 0;
         const 0;
         const 0;
 },
 lvl32_rcccx_entry() //  [R1]
         { info_tbl: [(cchfb,
                       label: lvl32_rcccx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchfb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchfc; else goto cchfd;
       cchfc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchfd: // global
           (_cchf8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cchf8::I64 == 0) goto cchfa; else goto cchf9;
       cchfa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchf9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cchf8::I64;
           R3 = sat_sccp2_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.960591164 UTC

[section ""cstring" . lvl33_rcccy_bytes" {
     lvl33_rcccy_bytes:
         I8[] [48]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.962417028 UTC

[section ""data" . lvl34_rcccz_closure" {
     lvl34_rcccz_closure:
         const lvl34_rcccz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl34_rcccz_entry() //  [R1]
         { info_tbl: [(cchfs,
                       label: lvl34_rcccz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchfs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchft; else goto cchfu;
       cchft: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchfu: // global
           (_cchfp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cchfp::I64 == 0) goto cchfr; else goto cchfq;
       cchfr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchfq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cchfp::I64;
           R2 = lvl33_rcccy_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.966519459 UTC

[section ""data" . sat_sccp3_closure" {
     sat_sccp3_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.968183144 UTC

[section ""data" . sat_sccp4_closure" {
     sat_sccp4_closure:
         const :_con_info;
         const sat_sccp3_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.97055601 UTC

[section ""data" . lvl35_rcccA_closure" {
     lvl35_rcccA_closure:
         const lvl35_rcccA_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_rcccA_entry() //  [R1]
         { info_tbl: [(cchfK,
                       label: lvl35_rcccA_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchfK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchfL; else goto cchfM;
       cchfL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchfM: // global
           (_cchfH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cchfH::I64 == 0) goto cchfJ; else goto cchfI;
       cchfJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchfI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cchfH::I64;
           R3 = sat_sccp4_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.974366638 UTC

[section ""cstring" . lvl36_rcccB_bytes" {
     lvl36_rcccB_bytes:
         I8[] [48,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.976152562 UTC

[section ""data" . lvl37_rcccC_closure" {
     lvl37_rcccC_closure:
         const lvl37_rcccC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_rcccC_entry() //  [R1]
         { info_tbl: [(cchg1,
                       label: lvl37_rcccC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchg1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchg2; else goto cchg3;
       cchg2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchg3: // global
           (_cchfY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cchfY::I64 == 0) goto cchg0; else goto cchfZ;
       cchg0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchfZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cchfY::I64;
           R2 = lvl36_rcccB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.979780333 UTC

[section ""data" . lvl38_rcccD_closure" {
     lvl38_rcccD_closure:
         const GHC.Base.Just_con_info;
         const lvl26_rcccr_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.981781005 UTC

[section ""data" . lvl39_rcccE_closure" {
     lvl39_rcccE_closure:
         const GHC.Base.Just_con_info;
         const lvl28_rccct_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.98338691 UTC

[section ""data" . lvl40_rcccF_closure" {
     lvl40_rcccF_closure:
         const GHC.Base.Just_con_info;
         const lvl34_rcccz_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.985019636 UTC

[section ""data" . lvl41_rcccG_closure" {
     lvl41_rcccG_closure:
         const GHC.Base.Just_con_info;
         const lvl37_rcccC_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:05.993554428 UTC

[section ""data" . Text.Printf.$wformatIntegral_closure" {
     Text.Printf.$wformatIntegral_closure:
         const Text.Printf.$wformatIntegral_info;
         const 0;
 },
 Text.Printf.$wformatIntegral_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchgg: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sccpt_entry() //  [R1]
         { info_tbl: [(cchhu,
                       label: sat_sccpt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchhu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchhv; else goto cchhw;
       cchhv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchhw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccpx_entry() //  [R1]
         { info_tbl: [(cchhF,
                       label: sat_sccpx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchhF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchhG; else goto cchhH;
       cchhG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchhH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccpB_entry() //  [R1]
         { info_tbl: [(cchhQ,
                       label: sat_sccpB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchhQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchhR; else goto cchhS;
       cchhR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchhS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchnu_srtd" {
     uchnu_srtd:
         const SccKB_srt+312;
         const 33;
         const 7516192777;
 },
 sat_sccpC_entry() //  [R1]
         { info_tbl: [(cchhW,
                       label: sat_sccpC_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchhW: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cchhX; else goto cchhY;
       cchhX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchhY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cchhf_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchhf() //  [R1]
         { info_tbl: [(cchhf,
                       label: block_cchhf_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchhf: // global
           if (R1 == 1) goto cchhV; else goto cchhU;
       cchhV: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cchhK_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cchhU: // global
           I64[Sp] = block_cchhj_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uchig; else goto cchhk;
       uchig: // global
           call _cchhj(R1) args: 0, res: 0, upd: 0;
       cchhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cchhK() //  [R1, R2]
         { info_tbl: [(cchhK,
                       label: block_cchhK_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchhK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchie; else goto cchid;
       cchie: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cchid: // global
           I64[Hp - 16] = sat_sccpB_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cchhj() //  [R1]
         { info_tbl: [(cchhj,
                       label: block_cchhj_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchhj: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cchi2; else goto cchi7;
       cchi2: // global
           I64[Sp + 24] = block_cchho_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cchi7: // global
           I64[Sp + 24] = block_cchhz_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl38_rcccD_closure+2;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchho() //  [R1, R2]
         { info_tbl: [(cchho,
                       label: block_cchho_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchho: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchi5; else goto cchi4;
       cchi5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cchi4: // global
           I64[Hp - 16] = sat_sccpt_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cchhz() //  [R1, R2]
         { info_tbl: [(cchhz,
                       label: block_cchhz_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchhz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchia; else goto cchi9;
       cchia: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cchi9: // global
           I64[Hp - 16] = sat_sccpx_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchnv_srtd" {
     uchnv_srtd:
         const SccKB_srt+312;
         const 34;
         const 8589934603;
 },
 sat_sccpO_entry() //  [R1]
         { info_tbl: [(cchir,
                       label: sat_sccpO_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchir: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cchis; else goto cchit;
       cchis: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchit: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cchim_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . uchnw_srtd" {
     uchnw_srtd:
         const SccKB_srt+320;
         const 33;
         const 4294967301;
 },
 _cchim() //  [R1]
         { info_tbl: [(cchim,
                       label: block_cchim_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchim: // global
           if (R1 == 1) goto cchiq; else goto cchip;
       cchiq: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cchiR_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cchip: // global
           I64[Sp] = block_cchiw_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uchiW; else goto cchiy;
       uchiW: // global
           call _cchiw(R1) args: 0, res: 0, upd: 0;
       cchiy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cchiR() //  [R1, R2]
         { info_tbl: [(cchiR,
                       label: block_cchiR_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchiR: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchnx_srtd" {
     uchnx_srtd:
         const SccKB_srt+320;
         const 33;
         const 4294967301;
 },
 _cchiw() //  [R1]
         { info_tbl: [(cchiw,
                       label: block_cchiw_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchiw: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cchiF; else goto cchiM;
       cchiF: // global
           I64[Sp + 24] = block_cchiC_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cchiM: // global
           I64[Sp + 24] = block_cchiK_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl39_rcccE_closure+2;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchiC() //  [R1, R2]
         { info_tbl: [(cchiC,
                       label: block_cchiC_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchiC: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cchiK() //  [R1, R2]
         { info_tbl: [(cchiK,
                       label: block_cchiK_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchiK: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccpX_entry() //  [R1]
         { info_tbl: [(cchjo,
                       label: sat_sccpX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchjo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cchjp; else goto cchjq;
       cchjp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchjq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cchjm_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchjm() //  [R1]
         { info_tbl: [(cchjm,
                       label: block_cchjm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchjm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cchjv; else goto cchju;
       cchjv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cchju: // global
           if (R1 > 1114111) goto cchjC; else goto cchjJ;
       cchjC: // global
           Hp = Hp - 16;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cchjJ: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccq3_entry() //  [R1]
         { info_tbl: [(cchjR,
                       label: sat_sccq3_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchjR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cchjS; else goto cchjT;
       cchjS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchjT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cchjP_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call $wfmti_rcccm_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchjP() //  [R1, R2]
         { info_tbl: [(cchjP,
                       label: block_cchjP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchjP: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccq7_entry() //  [R1]
         { info_tbl: [(cchk2,
                       label: sat_sccq7_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchk2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cchk3; else goto cchk4;
       cchk3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchk4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cchk0_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call $wfmti_rcccm_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchk0() //  [R1, R2]
         { info_tbl: [(cchk0,
                       label: block_cchk0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchk0: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccqj_entry() //  [R1]
         { info_tbl: [(cchkg,
                       label: sat_sccqj_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchkg: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cchkh; else goto cchki;
       cchkh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchki: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cchkb_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchkb() //  [R1]
         { info_tbl: [(cchkb,
                       label: block_cchkb_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchkb: // global
           if (R1 == 1) goto cchkf; else goto cchke;
       cchkf: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cchkG_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cchke: // global
           I64[Sp] = block_cchkl_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uchkL; else goto cchkn;
       uchkL: // global
           call _cchkl(R1) args: 0, res: 0, upd: 0;
       cchkn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cchkG() //  [R1, R2]
         { info_tbl: [(cchkG,
                       label: block_cchkG_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchkG: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cchkl() //  [R1]
         { info_tbl: [(cchkl,
                       label: block_cchkl_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchkl: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cchku; else goto cchkB;
       cchku: // global
           I64[Sp + 24] = block_cchkr_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cchkB: // global
           I64[Sp + 24] = block_cchkz_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl40_rcccF_closure+2;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchkr() //  [R1, R2]
         { info_tbl: [(cchkr,
                       label: block_cchkr_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchkr: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cchkz() //  [R1, R2]
         { info_tbl: [(cchkz,
                       label: block_cchkz_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchkz: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccqn_entry() //  [R1]
         { info_tbl: [(cchkT,
                       label: sat_sccqn_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchkT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cchkU; else goto cchkV;
       cchkU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchkV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cchkR_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 32];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl35_rcccA_closure;
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 40;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchkR() //  [R1, R2]
         { info_tbl: [(cchkR,
                       label: block_cchkR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchkR: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccqz_entry() //  [R1]
         { info_tbl: [(cchl7,
                       label: sat_sccqz_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchl7: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cchl8; else goto cchl9;
       cchl8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchl9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cchl2_info;
           R3 = Text.Printf.formatChar2_closure;
           _sccp6::P64 = P64[R1 + 24];
           R2 = _sccp6::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sccp6::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchl2() //  [R1]
         { info_tbl: [(cchl2,
                       label: block_cchl2_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchl2: // global
           if (R1 == 1) goto cchl6; else goto cchl5;
       cchl6: // global
           _sccp8::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cchlx_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cchl5: // global
           I64[Sp] = block_cchlc_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uchlC; else goto cchle;
       uchlC: // global
           call _cchlc(R1) args: 0, res: 0, upd: 0;
       cchle: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cchlx() //  [R1, R2]
         { info_tbl: [(cchlx,
                       label: block_cchlx_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchlx: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cchlc() //  [R1]
         { info_tbl: [(cchlc,
                       label: block_cchlc_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchlc: // global
           _sccp5::P64 = P64[Sp + 8];
           _sccp6::P64 = P64[Sp + 16];
           _sccp8::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cchll; else goto cchls;
       cchll: // global
           I64[Sp + 24] = block_cchli_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cchls: // global
           I64[Sp + 24] = block_cchlq_info;
           R6 = _sccp6::P64;
           R5 = _sccp5::P64;
           R4 = _sccp8::P64;
           R3 = lvl41_rcccG_closure+2;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchli() //  [R1, R2]
         { info_tbl: [(cchli,
                       label: block_cchli_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchli: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cchlq() //  [R1, R2]
         { info_tbl: [(cchlq,
                       label: block_cchlq_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchlq: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchny_srtd" {
     uchny_srtd:
         const SccKB_srt+320;
         const 43;
         const 8795556937825;
 },
 Text.Printf.$wformatIntegral_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cchlH,
                       label: Text.Printf.$wformatIntegral_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchlH: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cchlI; else goto cchlJ;
       cchlI: // global
           R1 = Text.Printf.$wformatIntegral_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cchlJ: // global
           I64[Sp - 48] = block_cchgm_info;
           R1 = R5;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchnt; else goto cchgn;
       uchnt: // global
           call _cchgm(R1) args: 0, res: 0, upd: 0;
       cchgn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchnz_srtd" {
     uchnz_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _cchgm() //  [R1]
         { info_tbl: [(cchgm,
                       label: block_cchgm_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchgm: // global
           _sccp9::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cchlE; else goto cchlF;
       cchlE: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cchmr; else goto cchmq;
       cchmr: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchmq: // global
           _sccp7::P64 = P64[Sp + 24];
           _sccpa::P64 = P64[Sp + 48];
           _sccpb::P64 = P64[Sp + 56];
           _sccpc::P64 = P64[Sp + 64];
           _sccqB::I64 = I64[Sp + 72];
           if (_sccqB::I64 != 118) goto cchmt; else goto cchmu;
       cchmt: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccqB::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = _sccp9::P64;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sccp9::P64;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = _sccqB::I64;
           Sp = Sp - 8;
           goto uchng;
       cchmu: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = GHC.Base.Nothing_closure+1;
           P64[Hp - 48] = _sccp9::P64;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _cchgw::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sccp9::P64;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = 100;
           Sp = Sp - 8;
           goto uchng;
       uchng: // global
           call _cchh5() args: 0, res: 0, upd: 0;
       cchlF: // global
           I64[Sp] = block_cchgz_info;
           _sccqA::P64 = R1;
           R1 = _sccp9::P64;
           P64[Sp + 40] = _sccqA::P64;
           if (R1 & 7 != 0) goto uchne; else goto cchgA;
       uchne: // global
           call _cchgz(R1) args: 0, res: 0, upd: 0;
       cchgA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchnA_srtd" {
     uchnA_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _cchgz() //  [R1]
         { info_tbl: [(cchgz,
                       label: block_cchgz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchgz: // global
           if (R1 & 7 == 1) goto cchmx; else goto cchmF;
       cchmx: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cchmA; else goto cchmz;
       cchmA: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchmz: // global
           _sccp7::P64 = P64[Sp + 24];
           _sccpa::P64 = P64[Sp + 48];
           _sccpb::P64 = P64[Sp + 56];
           _sccpc::P64 = P64[Sp + 64];
           _sccqA::P64 = P64[Sp + 40];
           _sccqH::I64 = I64[Sp + 72];
           if (_sccqH::I64 != 118) goto cchmC; else goto cchmD;
       cchmC: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccqH::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = _sccqA::P64;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = _sccqA::P64;
           P64[Sp + 56] = GHC.Base.Nothing_closure+1;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = _sccqH::I64;
           Sp = Sp - 8;
           goto uchnj;
       cchmD: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = _sccqA::P64;
           P64[Hp - 48] = GHC.Base.Nothing_closure+1;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _cchgJ::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 72] = _sccp7::P64;
           P64[Sp + 64] = _sccqA::P64;
           P64[Sp + 56] = GHC.Base.Nothing_closure+1;
           P64[Sp + 48] = _sccpa::P64;
           P64[Sp + 40] = _sccpb::P64;
           P64[Sp + 24] = _sccpc::P64;
           I64[Sp] = 100;
           Sp = Sp - 8;
           goto uchnj;
       uchnj: // global
           call _cchh5() args: 0, res: 0, upd: 0;
       cchmF: // global
           I64[Sp - 8] = block_cchgM_info;
           _sccqG::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _sccqG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchnh; else goto cchgN;
       uchnh: // global
           call _cchgM(R1) args: 0, res: 0, upd: 0;
       cchgN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchnB_srtd" {
     uchnB_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _cchgM() //  [R1]
         { info_tbl: [(cchgM,
                       label: block_cchgM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchgM: // global
           _sccp7::P64 = P64[Sp + 32];
           _sccpa::P64 = P64[Sp + 56];
           _sccpb::P64 = P64[Sp + 64];
           _sccpc::P64 = P64[Sp + 72];
           _sccpd::I64 = I64[Sp + 80];
           _sccqA::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto cchmH; else goto cchmO;
       cchmH: // global
           Hp = Hp + 80;
           _sccqM::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cchmR; else goto cchmJ;
       cchmJ: // global
           _sccqG::P64 = P64[Sp + 8];
           if (_sccpd::I64 == 118) goto cchmN; else goto cchmM;
       cchmN: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = _sccqA::P64;
           P64[Hp - 48] = _sccqG::P64;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _cchgW::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 80] = _sccp7::P64;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 64] = _sccqG::P64;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 32] = _sccpc::P64;
           I64[Sp + 8] = 100;
           goto uchnn;
       cchmM: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccpd::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = _sccqA::P64;
           P64[Hp - 32] = _sccqG::P64;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 80] = _sccp7::P64;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 64] = _sccqG::P64;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 32] = _sccpc::P64;
           I64[Sp + 8] = _sccpd::I64;
           goto uchnn;
       cchmO: // global
           Hp = Hp + 80;
           _sccqM::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cchmR; else goto cchmQ;
       cchmR: // global
           HpAlloc = 80;
           R1 = _sccqM::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchmQ: // global
           if (_sccpd::I64 == 118) goto cchmU; else goto cchmT;
       cchmU: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sccp7::P64;
           P64[Hp - 56] = _sccqA::P64;
           P64[Hp - 48] = GHC.Base.Nothing_closure+1;
           P64[Hp - 40] = _sccpa::P64;
           P64[Hp - 32] = _sccpb::P64;
           P64[Hp - 24] = _sccpc::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _cchh4::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 80] = _sccp7::P64;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 32] = _sccpc::P64;
           I64[Sp + 8] = 100;
           goto uchnn;
       cchmT: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sccpd::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sccp7::P64;
           P64[Hp - 40] = _sccqA::P64;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = _sccpa::P64;
           P64[Hp - 16] = _sccpb::P64;
           P64[Hp - 8] = _sccpc::P64;
           P64[Hp] = Hp - 71;
           I64[Sp + 8] = _sccpd::I64;
           P64[Sp + 32] = _sccpc::P64;
           P64[Sp + 48] = _sccpb::P64;
           P64[Sp + 56] = _sccpa::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 72] = _sccqA::P64;
           P64[Sp + 80] = _sccp7::P64;
           goto uchnn;
       uchnn: // global
           call _cchh5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uchnC_srtd" {
     uchnC_srtd:
         const SccKB_srt+320;
         const 43;
         const 7696045310049;
 },
 _cchh5() //  []
         { info_tbl: [(cchh5,
                       label: block_cchh5_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchh5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cchlM; else goto cchlL;
       cchlM: // global
           HpAlloc = 64;
           I64[Sp] = block_cchh5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cchlL: // global
           _sccpn::I64 = I64[Sp + 8];
           if (_sccpn::I64 >= 121) goto cchlO; else goto uchmZ;
       uchmZ: // global
           _sccp5::P64 = P64[Sp + 16];
           _sccp6::P64 = P64[Sp + 24];
           _sccp8::P64 = P64[Sp + 40];
           _sccpf::P64 = P64[Sp + 80];
           _sccph::P64 = P64[Sp + 64];
           _sccpj::P64 = P64[Sp + 48];
           if (_sccpn::I64 < 98) goto uchn0; else goto uchn1;
       uchn0: // global
           if (_sccpn::I64 != 88) goto cchlO; else goto cchlP;
       cchlP: // global
           I64[Hp - 56] = sat_sccpC_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uchn1: // global
           _sccpi::P64 = P64[Sp + 56];
           switch [98 .. 120] _sccpn::I64 {
               case 98 : goto cchlQ;
               case 99 : goto cchlR;
               case 100 : goto cchmk;
               case 105 : goto cchml;
               case 111 : goto cchmm;
               case 117 : goto cchmn;
               case 120 : goto cchmo;
               default: {goto cchlO;}
           }
       cchmo: // global
           I64[Hp - 56] = sat_sccqz_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cchmn: // global
           I64[Hp - 56] = sat_sccqn_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           _cchkN::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _cchkN::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cchmm: // global
           I64[Hp - 56] = sat_sccqj_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cchml: // global
           I64[Hp - 56] = sat_sccq7_info;
           P64[Hp - 40] = _sccp6::P64;
           P64[Hp - 32] = _sccp8::P64;
           P64[Hp - 24] = _sccpf::P64;
           P64[Hp - 16] = _sccph::P64;
           P64[Hp - 8] = _sccpi::P64;
           _cchjW::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _cchjW::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cchmk: // global
           I64[Hp - 56] = sat_sccq3_info;
           P64[Hp - 40] = _sccp6::P64;
           P64[Hp - 32] = _sccp8::P64;
           P64[Hp - 24] = _sccpf::P64;
           P64[Hp - 16] = _sccph::P64;
           P64[Hp - 8] = _sccpi::P64;
           _cchjL::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _cchjL::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cchlR: // global
           Hp = Hp - 64;
           I64[Sp + 16] = block_cchiY_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sccp6::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cchlQ: // global
           I64[Hp - 56] = sat_sccpO_info;
           P64[Hp - 40] = _sccp5::P64;
           P64[Hp - 32] = _sccp6::P64;
           P64[Hp - 24] = _sccp8::P64;
           P64[Hp - 16] = _sccpf::P64;
           P64[Hp - 8] = _sccph::P64;
           P64[Hp] = _sccpj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cchlO: // global
           Hp = Hp - 64;
           R2 = _sccpn::I64;
           Sp = Sp + 88;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cchiY() //  [R1]
         { info_tbl: [(cchiY,
                       label: block_cchiY_info
                       rep:StackRep [False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchiY: // global
           if (R1 == 1) goto cchlX; else goto uchna;
       cchlX: // global
           I64[Sp] = block_cchj3_info;
           R3 = lvl31_rcccw_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       uchna: // global
           Sp = Sp + 72;
           call _cchmj() args: 0, res: 0, upd: 0;
     }
 },
 _cchj3() //  [R1]
         { info_tbl: [(cchj3,
                       label: block_cchj3_info
                       rep:StackRep [False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchj3: // global
           if (R1 == 1) goto cchm3; else goto uchnb;
       cchm3: // global
           I64[Sp] = block_cchj8_info;
           R1 = P64[Sp + 56];
           if (R1 & 7 != 0) goto uchnp; else goto cchj9;
       uchnp: // global
           call _cchj8(R1) args: 0, res: 0, upd: 0;
       cchj9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uchnb: // global
           Sp = Sp + 72;
           call _cchmj() args: 0, res: 0, upd: 0;
     }
 },
 _cchj8() //  [R1]
         { info_tbl: [(cchj8,
                       label: block_cchj8_info
                       rep:StackRep [False, False, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchj8: // global
           if (R1 & 7 == 1) goto cchm6; else goto uchnc;
       cchm6: // global
           I64[Sp] = block_cchjd_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[Sp + 16];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       uchnc: // global
           Sp = Sp + 72;
           call _cchmj() args: 0, res: 0, upd: 0;
     }
 },
 _cchjd() //  [R1]
         { info_tbl: [(cchjd,
                       label: block_cchjd_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchjd: // global
           if (R1 & 7 == 1) goto uchnd; else goto cchmc;
       uchnd: // global
           Sp = Sp + 72;
           call _cchmj() args: 0, res: 0, upd: 0;
       cchmc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchmf; else goto cchme;
       cchmf: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchme: // global
           I64[Hp - 40] = sat_sccpX_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R6 = 115;
           R5 = P64[Sp + 48];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[Sp + 64];
           R2 = Hp - 14;
           Sp = Sp + 72;
           call Text.Printf.$w$sformatString_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 _cchmj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchmj: // global
           R1 = lvl30_rcccv_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.105040791 UTC

[section ""data" . Text.Printf.formatIntegral_closure" {
     Text.Printf.formatIntegral_closure:
         const Text.Printf.formatIntegral_info;
         const 0;
 },
 Text.Printf.formatIntegral_entry() //  [R2, R3, R4]
         { info_tbl: [(cchrj,
                       label: Text.Printf.formatIntegral_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchrj: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cchrn; else goto cchro;
       cchrn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatIntegral_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cchro: // global
           I64[Sp - 24] = block_cchrg_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uchrw; else goto cchrh;
       uchrw: // global
           call _cchrg(R1) args: 0, res: 0, upd: 0;
       cchrh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchrg() //  [R1]
         { info_tbl: [(cchrg,
                       label: block_cchrg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchrg: // global
           I64[Sp - 48] = block_cchrm_info;
           _sccqZ::P64 = P64[R1 + 7];
           _sccr0::P64 = P64[R1 + 15];
           _sccr1::P64 = P64[R1 + 23];
           _sccr2::P64 = P64[R1 + 31];
           _sccr3::P64 = P64[R1 + 39];
           _sccr4::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccr0::P64;
           P64[Sp - 32] = _sccr1::P64;
           P64[Sp - 24] = _sccr2::P64;
           P64[Sp - 16] = _sccr3::P64;
           P64[Sp - 8] = _sccr4::P64;
           P64[Sp] = _sccqZ::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchrv; else goto cchrq;
       uchrv: // global
           call _cchrm(R1) args: 0, res: 0, upd: 0;
       cchrq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchrm() //  [R1]
         { info_tbl: [(cchrm,
                       label: block_cchrm_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchrm: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           _sccr4::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccr4::P64;
           I64[Sp + 64] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.112898862 UTC

[section ""data" . Text.Printf.formatChar1_closure" {
     Text.Printf.formatChar1_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.formatChar2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.115742208 UTC

[section ""data" . Text.Printf.$wformatChar_closure" {
     Text.Printf.$wformatChar_closure:
         const Text.Printf.$wformatChar_info;
         const 0;
 },
 Text.Printf.$wformatChar_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchrP: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatChar_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccrk_entry() //  [R1]
         { info_tbl: [(cchs2,
                       label: sat_sccrk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchs2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cchs3; else goto cchs4;
       cchs3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchs4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cchrZ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uchs9; else goto cchs0;
       uchs9: // global
           call _cchrZ(R1) args: 0, res: 0, upd: 0;
       cchs0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cchrZ() //  [R1]
         { info_tbl: [(cchrZ,
                       label: block_cchrZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchrZ: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccro_entry() //  [R1]
         { info_tbl: [(cchsi,
                       label: sat_sccro_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchsi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cchsj; else goto cchsk;
       cchsj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchsk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cchsf_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uchsp; else goto cchsg;
       uchsp: // global
           call _cchsf(R1) args: 0, res: 0, upd: 0;
       cchsg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cchsf() //  [R1]
         { info_tbl: [(cchsf,
                       label: block_cchsf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchsf: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$wformatChar_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cchst,
                       label: Text.Printf.$wformatChar_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchst: // global
           _sccrc::P64 = R6;
           _sccrb::P64 = R5;
           _sccra::P64 = R4;
           _sccr9::P64 = R3;
           _sccr8::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cchsu; else goto cchsv;
       cchsv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchsx; else goto cchsw;
       cchsx: // global
           HpAlloc = 24;
           goto cchsu;
       cchsu: // global
           R1 = Text.Printf.$wformatChar_closure;
           P64[Sp - 40] = _sccr8::P64;
           P64[Sp - 32] = _sccr9::P64;
           P64[Sp - 24] = _sccra::P64;
           P64[Sp - 16] = _sccrb::P64;
           P64[Sp - 8] = _sccrc::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cchsw: // global
           _sccrg::I64 = I64[Sp + 16];
           if (_sccrg::I64 != 118) goto cchsr; else goto cchss;
       cchsr: // global
           I64[Hp - 16] = sat_sccrk_info;
           P64[Hp] = _sccr8::P64;
           R6 = _sccrb::P64;
           R5 = _sccra::P64;
           R4 = _sccr9::P64;
           R3 = Hp - 16;
           R2 = Text.Printf.formatChar1_closure+2;
           P64[Sp - 8] = _sccrc::P64;
           I64[Sp + 16] = _sccrg::I64;
           Sp = Sp - 8;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
       cchss: // global
           I64[Hp - 16] = sat_sccro_info;
           P64[Hp] = _sccr8::P64;
           R6 = _sccrb::P64;
           R5 = _sccra::P64;
           R4 = _sccr9::P64;
           R3 = Hp - 16;
           R2 = Text.Printf.formatChar1_closure+2;
           P64[Sp - 8] = _sccrc::P64;
           I64[Sp + 16] = 99;
           Sp = Sp - 8;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.128586897 UTC

[section ""data" . Text.Printf.formatChar_closure" {
     Text.Printf.formatChar_closure:
         const Text.Printf.formatChar_info;
         const 0;
 },
 Text.Printf.formatChar_entry() //  [R2, R3]
         { info_tbl: [(ccht2,
                       label: Text.Printf.formatChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccht2: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccht6; else goto ccht7;
       ccht6: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccht7: // global
           I64[Sp - 16] = block_cchsZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchtf; else goto ccht0;
       uchtf: // global
           call _cchsZ(R1) args: 0, res: 0, upd: 0;
       ccht0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchsZ() //  [R1]
         { info_tbl: [(cchsZ,
                       label: block_cchsZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchsZ: // global
           I64[Sp - 48] = block_ccht5_info;
           _sccrs::P64 = P64[R1 + 7];
           _sccrt::P64 = P64[R1 + 15];
           _sccru::P64 = P64[R1 + 23];
           _sccrv::P64 = P64[R1 + 31];
           _sccrw::P64 = P64[R1 + 39];
           _sccrx::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccrt::P64;
           P64[Sp - 32] = _sccru::P64;
           P64[Sp - 24] = _sccrv::P64;
           P64[Sp - 16] = _sccrw::P64;
           P64[Sp - 8] = _sccrx::P64;
           P64[Sp] = _sccrs::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchte; else goto ccht9;
       uchte: // global
           call _ccht5(R1) args: 0, res: 0, upd: 0;
       ccht9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccht5() //  [R1]
         { info_tbl: [(ccht5,
                       label: block_ccht5_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccht5: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccrx::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccrx::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatChar_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.136524753 UTC

[section ""data" . Text.Printf.$fPrintfArgChar_closure" {
     Text.Printf.$fPrintfArgChar_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.formatChar_closure+2;
         const Text.Printf.$fPrintfArgChar_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.138356601 UTC

[section ""data" . Text.Printf.$fPrintfArgWord1_closure" {
     Text.Printf.$fPrintfArgWord1_closure:
         const GHC.Types.C#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.141356326 UTC

[section ""data" . Text.Printf.$w$sformatInt3_closure" {
     Text.Printf.$w$sformatInt3_closure:
         const Text.Printf.$w$sformatInt3_info;
         const 0;
 },
 Text.Printf.$w$sformatInt3_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchty: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt3_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccrZ_entry() //  [R1]
         { info_tbl: [(cchtT,
                       label: sat_sccrZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchtT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchtU; else goto cchtV;
       cchtU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchtV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$fIntegralWord64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchuG_srtd" {
     uchuG_srtd:
         const SccKB_srt+192;
         const 62;
         const 2305843009213693957;
 },
 sat_sccrY_entry() //  [R1]
         { info_tbl: [(cchu7,
                       label: sat_sccrY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchu7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchu8; else goto cchu9;
       cchu8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchu9: // global
           I64[Sp - 8] = block_cchu0_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchus; else goto cchu1;
       uchus: // global
           call _cchu0(R1) args: 0, res: 0, upd: 0;
       cchu1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchuH_srtd" {
     uchuH_srtd:
         const SccKB_srt+192;
         const 62;
         const 2305843009213693957;
 },
 _cchu0() //  [R1]
         { info_tbl: [(cchu0,
                       label: block_cchu0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchu0: // global
           if (R1 & 7 == 1) goto cchu4; else goto cchu5;
       cchu4: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchu5: // global
           I64[Sp] = block_cchuf_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchuf() //  [R1]
         { info_tbl: [(cchuf,
                       label: block_cchuf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchuf: // global
           if (R1 & 7 == 1) goto cchum; else goto cchuq;
       cchum: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchuq: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchuI_srtd" {
     uchuI_srtd:
         const SccKB_srt+192;
         const 65;
         const 11601272640106397697;
         const 1;
 },
 Text.Printf.$w$sformatInt3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cchuw,
                       label: Text.Printf.$w$sformatInt3_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchuw: // global
           _sccrF::P64 = R6;
           _sccrE::P64 = R5;
           _sccrD::P64 = R4;
           _sccrC::P64 = R3;
           _sccrB::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cchux; else goto cchuy;
       cchuy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cchuA; else goto cchuz;
       cchuA: // global
           HpAlloc = 16;
           goto cchux;
       cchux: // global
           R1 = Text.Printf.$w$sformatInt3_closure;
           P64[Sp - 40] = _sccrB::P64;
           P64[Sp - 32] = _sccrC::P64;
           P64[Sp - 24] = _sccrD::P64;
           P64[Sp - 16] = _sccrE::P64;
           P64[Sp - 8] = _sccrF::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cchuz: // global
           _sccrG::P64 = P64[Sp];
           _sccrH::P64 = P64[Sp + 8];
           _sccs0::I64 = I64[Sp + 16];
           if (_sccs0::I64 != 118) goto cchuu; else goto cchuv;
       cchuu: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccs0::I64;
           _sccrQ::P64 = Hp - 7;
           _sccrP::P64 = _sccrH::P64;
           _sccrO::P64 = _sccrG::P64;
           _sccrN::P64 = _sccrF::P64;
           _sccrM::P64 = _sccrE::P64;
           _sccrL::P64 = _sccrD::P64;
           _sccrK::P64 = _sccrC::P64;
           goto sccrJ;
       cchuv: // global
           Hp = Hp - 16;
           _sccrQ::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccrP::P64 = _sccrH::P64;
           _sccrO::P64 = _sccrG::P64;
           _sccrN::P64 = _sccrF::P64;
           _sccrM::P64 = _sccrE::P64;
           _sccrL::P64 = _sccrD::P64;
           _sccrK::P64 = _sccrC::P64;
           goto sccrJ;
       sccrJ: // global
           I64[Sp - 48] = block_cchtK_info;
           R1 = _sccrQ::P64;
           P64[Sp - 40] = _sccrL::P64;
           P64[Sp - 32] = _sccrM::P64;
           P64[Sp - 24] = _sccrN::P64;
           P64[Sp - 16] = _sccrO::P64;
           P64[Sp - 8] = _sccrP::P64;
           P64[Sp] = _sccrK::P64;
           P64[Sp + 16] = _sccrB::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchuF; else goto cchtL;
       uchuF: // global
           call _cchtK(R1) args: 0, res: 0, upd: 0;
       cchtL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchuJ_srtd" {
     uchuJ_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _cchtK() //  [R1]
         { info_tbl: [(cchtK,
                       label: block_cchtK_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchtK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchuE; else goto cchuD;
       cchuE: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchuD: // global
           _sccrS::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccrZ_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccrY_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccrP::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccrP::P64;
           I64[Sp + 64] = _sccrS::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.16086688 UTC

[section ""data" . Text.Printf.$fPrintfArgWord64_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord64_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord64_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord64_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cchvx,
                       label: Text.Printf.$fPrintfArgWord64_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchvx: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchvB; else goto cchvC;
       cchvB: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord64_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchvC: // global
           I64[Sp - 16] = block_cchvu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchvK; else goto cchvv;
       uchvK: // global
           call _cchvu(R1) args: 0, res: 0, upd: 0;
       cchvv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchvu() //  [R1]
         { info_tbl: [(cchvu,
                       label: block_cchvu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchvu: // global
           I64[Sp - 48] = block_cchvA_info;
           _sccs5::P64 = P64[R1 + 7];
           _sccs6::P64 = P64[R1 + 15];
           _sccs7::P64 = P64[R1 + 23];
           _sccs8::P64 = P64[R1 + 31];
           _sccs9::P64 = P64[R1 + 39];
           _sccsa::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccs6::P64;
           P64[Sp - 32] = _sccs7::P64;
           P64[Sp - 24] = _sccs8::P64;
           P64[Sp - 16] = _sccs9::P64;
           P64[Sp - 8] = _sccsa::P64;
           P64[Sp] = _sccs5::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchvJ; else goto cchvE;
       uchvJ: // global
           call _cchvA(R1) args: 0, res: 0, upd: 0;
       cchvE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchvA() //  [R1]
         { info_tbl: [(cchvA,
                       label: block_cchvA_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchvA: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccsa::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccsa::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt3_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.170111446 UTC

[section ""data" . Text.Printf.$w$sformatInt2_closure" {
     Text.Printf.$w$sformatInt2_closure:
         const Text.Printf.$w$sformatInt2_info;
         const 0;
 },
 Text.Printf.$w$sformatInt2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchw1: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt2_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccsC_entry() //  [R1]
         { info_tbl: [(cchwm,
                       label: sat_sccsC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchwm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchwn; else goto cchwo;
       cchwn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchwo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchx9_srtd" {
     uchx9_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sccsB_entry() //  [R1]
         { info_tbl: [(cchwA,
                       label: sat_sccsB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchwA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchwB; else goto cchwC;
       cchwB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchwC: // global
           I64[Sp - 8] = block_cchwt_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchwV; else goto cchwu;
       uchwV: // global
           call _cchwt(R1) args: 0, res: 0, upd: 0;
       cchwu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchxa_srtd" {
     uchxa_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _cchwt() //  [R1]
         { info_tbl: [(cchwt,
                       label: block_cchwt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchwt: // global
           if (R1 & 7 == 1) goto cchwx; else goto cchwy;
       cchwx: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchwy: // global
           I64[Sp] = block_cchwI_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchwI() //  [R1]
         { info_tbl: [(cchwI,
                       label: block_cchwI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchwI: // global
           if (R1 & 7 == 1) goto cchwP; else goto cchwT;
       cchwP: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchwT: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchxb_srtd" {
     uchxb_srtd:
         const SccKB_srt+192;
         const 67;
         const 11601272640106397697;
         const 4;
 },
 Text.Printf.$w$sformatInt2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cchwZ,
                       label: Text.Printf.$w$sformatInt2_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchwZ: // global
           _sccsi::P64 = R6;
           _sccsh::P64 = R5;
           _sccsg::P64 = R4;
           _sccsf::P64 = R3;
           _sccse::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cchx0; else goto cchx1;
       cchx1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cchx3; else goto cchx2;
       cchx3: // global
           HpAlloc = 16;
           goto cchx0;
       cchx0: // global
           R1 = Text.Printf.$w$sformatInt2_closure;
           P64[Sp - 40] = _sccse::P64;
           P64[Sp - 32] = _sccsf::P64;
           P64[Sp - 24] = _sccsg::P64;
           P64[Sp - 16] = _sccsh::P64;
           P64[Sp - 8] = _sccsi::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cchx2: // global
           _sccsj::P64 = P64[Sp];
           _sccsk::P64 = P64[Sp + 8];
           _sccsD::I64 = I64[Sp + 16];
           if (_sccsD::I64 != 118) goto cchwX; else goto cchwY;
       cchwX: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccsD::I64;
           _sccst::P64 = Hp - 7;
           _sccss::P64 = _sccsk::P64;
           _sccsr::P64 = _sccsj::P64;
           _sccsq::P64 = _sccsi::P64;
           _sccsp::P64 = _sccsh::P64;
           _sccso::P64 = _sccsg::P64;
           _sccsn::P64 = _sccsf::P64;
           goto sccsm;
       cchwY: // global
           Hp = Hp - 16;
           _sccst::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccss::P64 = _sccsk::P64;
           _sccsr::P64 = _sccsj::P64;
           _sccsq::P64 = _sccsi::P64;
           _sccsp::P64 = _sccsh::P64;
           _sccso::P64 = _sccsg::P64;
           _sccsn::P64 = _sccsf::P64;
           goto sccsm;
       sccsm: // global
           I64[Sp - 48] = block_cchwd_info;
           R1 = _sccst::P64;
           P64[Sp - 40] = _sccso::P64;
           P64[Sp - 32] = _sccsp::P64;
           P64[Sp - 24] = _sccsq::P64;
           P64[Sp - 16] = _sccsr::P64;
           P64[Sp - 8] = _sccss::P64;
           P64[Sp] = _sccsn::P64;
           P64[Sp + 16] = _sccse::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchx8; else goto cchwe;
       uchx8: // global
           call _cchwd(R1) args: 0, res: 0, upd: 0;
       cchwe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchxc_srtd" {
     uchxc_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _cchwd() //  [R1]
         { info_tbl: [(cchwd,
                       label: block_cchwd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchwd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchx7; else goto cchx6;
       cchx7: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchx6: // global
           _sccsv::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccsC_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccsB_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccss::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccss::P64;
           I64[Sp + 64] = _sccsv::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.189905454 UTC

[section ""data" . Text.Printf.$fPrintfArgWord32_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord32_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord32_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord32_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cchy0,
                       label: Text.Printf.$fPrintfArgWord32_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchy0: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchy4; else goto cchy5;
       cchy4: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord32_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchy5: // global
           I64[Sp - 16] = block_cchxX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchyd; else goto cchxY;
       uchyd: // global
           call _cchxX(R1) args: 0, res: 0, upd: 0;
       cchxY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchxX() //  [R1]
         { info_tbl: [(cchxX,
                       label: block_cchxX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchxX: // global
           I64[Sp - 48] = block_cchy3_info;
           _sccsI::P64 = P64[R1 + 7];
           _sccsJ::P64 = P64[R1 + 15];
           _sccsK::P64 = P64[R1 + 23];
           _sccsL::P64 = P64[R1 + 31];
           _sccsM::P64 = P64[R1 + 39];
           _sccsN::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccsJ::P64;
           P64[Sp - 32] = _sccsK::P64;
           P64[Sp - 24] = _sccsL::P64;
           P64[Sp - 16] = _sccsM::P64;
           P64[Sp - 8] = _sccsN::P64;
           P64[Sp] = _sccsI::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchyc; else goto cchy7;
       uchyc: // global
           call _cchy3(R1) args: 0, res: 0, upd: 0;
       cchy7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchy3() //  [R1]
         { info_tbl: [(cchy3,
                       label: block_cchy3_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchy3: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccsN::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccsN::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt2_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.198765004 UTC

[section ""data" . Text.Printf.$w$sformatInt1_closure" {
     Text.Printf.$w$sformatInt1_closure:
         const Text.Printf.$w$sformatInt1_info;
         const 0;
 },
 Text.Printf.$w$sformatInt1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchyu: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt1_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_scctf_entry() //  [R1]
         { info_tbl: [(cchyP,
                       label: sat_scctf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchyP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchyQ; else goto cchyR;
       cchyQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchyR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchzC_srtd" {
     uchzC_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sccte_entry() //  [R1]
         { info_tbl: [(cchz3,
                       label: sat_sccte_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchz3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchz4; else goto cchz5;
       cchz4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchz5: // global
           I64[Sp - 8] = block_cchyW_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchzo; else goto cchyX;
       uchzo: // global
           call _cchyW(R1) args: 0, res: 0, upd: 0;
       cchyX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchzD_srtd" {
     uchzD_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _cchyW() //  [R1]
         { info_tbl: [(cchyW,
                       label: block_cchyW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchyW: // global
           if (R1 & 7 == 1) goto cchz0; else goto cchz1;
       cchz0: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchz1: // global
           I64[Sp] = block_cchzb_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchzb() //  [R1]
         { info_tbl: [(cchzb,
                       label: block_cchzb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchzb: // global
           if (R1 & 7 == 1) goto cchzi; else goto cchzm;
       cchzi: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchzm: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchzE_srtd" {
     uchzE_srtd:
         const SccKB_srt+192;
         const 69;
         const 11601272640106397697;
         const 16;
 },
 Text.Printf.$w$sformatInt1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cchzs,
                       label: Text.Printf.$w$sformatInt1_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchzs: // global
           _sccsV::P64 = R6;
           _sccsU::P64 = R5;
           _sccsT::P64 = R4;
           _sccsS::P64 = R3;
           _sccsR::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cchzt; else goto cchzu;
       cchzu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cchzw; else goto cchzv;
       cchzw: // global
           HpAlloc = 16;
           goto cchzt;
       cchzt: // global
           R1 = Text.Printf.$w$sformatInt1_closure;
           P64[Sp - 40] = _sccsR::P64;
           P64[Sp - 32] = _sccsS::P64;
           P64[Sp - 24] = _sccsT::P64;
           P64[Sp - 16] = _sccsU::P64;
           P64[Sp - 8] = _sccsV::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cchzv: // global
           _sccsW::P64 = P64[Sp];
           _sccsX::P64 = P64[Sp + 8];
           _scctg::I64 = I64[Sp + 16];
           if (_scctg::I64 != 118) goto cchzq; else goto cchzr;
       cchzq: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _scctg::I64;
           _scct6::P64 = Hp - 7;
           _scct5::P64 = _sccsX::P64;
           _scct4::P64 = _sccsW::P64;
           _scct3::P64 = _sccsV::P64;
           _scct2::P64 = _sccsU::P64;
           _scct1::P64 = _sccsT::P64;
           _scct0::P64 = _sccsS::P64;
           goto sccsZ;
       cchzr: // global
           Hp = Hp - 16;
           _scct6::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _scct5::P64 = _sccsX::P64;
           _scct4::P64 = _sccsW::P64;
           _scct3::P64 = _sccsV::P64;
           _scct2::P64 = _sccsU::P64;
           _scct1::P64 = _sccsT::P64;
           _scct0::P64 = _sccsS::P64;
           goto sccsZ;
       sccsZ: // global
           I64[Sp - 48] = block_cchyG_info;
           R1 = _scct6::P64;
           P64[Sp - 40] = _scct1::P64;
           P64[Sp - 32] = _scct2::P64;
           P64[Sp - 24] = _scct3::P64;
           P64[Sp - 16] = _scct4::P64;
           P64[Sp - 8] = _scct5::P64;
           P64[Sp] = _scct0::P64;
           P64[Sp + 16] = _sccsR::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchzB; else goto cchyH;
       uchzB: // global
           call _cchyG(R1) args: 0, res: 0, upd: 0;
       cchyH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchzF_srtd" {
     uchzF_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _cchyG() //  [R1]
         { info_tbl: [(cchyG,
                       label: block_cchyG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchyG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchzA; else goto cchzz;
       cchzA: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchzz: // global
           _scct8::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_scctf_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccte_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _scct5::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _scct5::P64;
           I64[Sp + 64] = _scct8::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.217894202 UTC

[section ""data" . Text.Printf.$fPrintfArgWord16_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord16_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord16_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord16_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cchAt,
                       label: Text.Printf.$fPrintfArgWord16_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchAt: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchAx; else goto cchAy;
       cchAx: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord16_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchAy: // global
           I64[Sp - 16] = block_cchAq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchAG; else goto cchAr;
       uchAG: // global
           call _cchAq(R1) args: 0, res: 0, upd: 0;
       cchAr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchAq() //  [R1]
         { info_tbl: [(cchAq,
                       label: block_cchAq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchAq: // global
           I64[Sp - 48] = block_cchAw_info;
           _scctl::P64 = P64[R1 + 7];
           _scctm::P64 = P64[R1 + 15];
           _scctn::P64 = P64[R1 + 23];
           _sccto::P64 = P64[R1 + 31];
           _scctp::P64 = P64[R1 + 39];
           _scctq::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _scctm::P64;
           P64[Sp - 32] = _scctn::P64;
           P64[Sp - 24] = _sccto::P64;
           P64[Sp - 16] = _scctp::P64;
           P64[Sp - 8] = _scctq::P64;
           P64[Sp] = _scctl::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchAF; else goto cchAA;
       uchAF: // global
           call _cchAw(R1) args: 0, res: 0, upd: 0;
       cchAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchAw() //  [R1]
         { info_tbl: [(cchAw,
                       label: block_cchAw_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchAw: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _scctq::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _scctq::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt1_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.227656953 UTC

[section ""data" . Text.Printf.$w$sformatInt4_closure" {
     Text.Printf.$w$sformatInt4_closure:
         const Text.Printf.$w$sformatInt4_info;
         const 0;
 },
 Text.Printf.$w$sformatInt4_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchAX: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt4_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_scctS_entry() //  [R1]
         { info_tbl: [(cchBi,
                       label: sat_scctS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchBi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchBj; else goto cchBk;
       cchBj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchBk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchC5_srtd" {
     uchC5_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_scctR_entry() //  [R1]
         { info_tbl: [(cchBw,
                       label: sat_scctR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchBw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchBx; else goto cchBy;
       cchBx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchBy: // global
           I64[Sp - 8] = block_cchBp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchBR; else goto cchBq;
       uchBR: // global
           call _cchBp(R1) args: 0, res: 0, upd: 0;
       cchBq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchC6_srtd" {
     uchC6_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _cchBp() //  [R1]
         { info_tbl: [(cchBp,
                       label: block_cchBp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchBp: // global
           if (R1 & 7 == 1) goto cchBt; else goto cchBu;
       cchBt: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchBu: // global
           I64[Sp] = block_cchBE_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchBE() //  [R1]
         { info_tbl: [(cchBE,
                       label: block_cchBE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchBE: // global
           if (R1 & 7 == 1) goto cchBL; else goto cchBP;
       cchBL: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchBP: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchC7_srtd" {
     uchC7_srtd:
         const SccKB_srt+192;
         const 71;
         const 11601272640106397697;
         const 64;
 },
 Text.Printf.$w$sformatInt4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cchBV,
                       label: Text.Printf.$w$sformatInt4_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchBV: // global
           _sccty::P64 = R6;
           _scctx::P64 = R5;
           _scctw::P64 = R4;
           _scctv::P64 = R3;
           _scctu::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cchBW; else goto cchBX;
       cchBX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cchBZ; else goto cchBY;
       cchBZ: // global
           HpAlloc = 16;
           goto cchBW;
       cchBW: // global
           R1 = Text.Printf.$w$sformatInt4_closure;
           P64[Sp - 40] = _scctu::P64;
           P64[Sp - 32] = _scctv::P64;
           P64[Sp - 24] = _scctw::P64;
           P64[Sp - 16] = _scctx::P64;
           P64[Sp - 8] = _sccty::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cchBY: // global
           _scctz::P64 = P64[Sp];
           _scctA::P64 = P64[Sp + 8];
           _scctT::I64 = I64[Sp + 16];
           if (_scctT::I64 != 118) goto cchBT; else goto cchBU;
       cchBT: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _scctT::I64;
           _scctJ::P64 = Hp - 7;
           _scctI::P64 = _scctA::P64;
           _scctH::P64 = _scctz::P64;
           _scctG::P64 = _sccty::P64;
           _scctF::P64 = _scctx::P64;
           _scctE::P64 = _scctw::P64;
           _scctD::P64 = _scctv::P64;
           goto scctC;
       cchBU: // global
           Hp = Hp - 16;
           _scctJ::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _scctI::P64 = _scctA::P64;
           _scctH::P64 = _scctz::P64;
           _scctG::P64 = _sccty::P64;
           _scctF::P64 = _scctx::P64;
           _scctE::P64 = _scctw::P64;
           _scctD::P64 = _scctv::P64;
           goto scctC;
       scctC: // global
           I64[Sp - 48] = block_cchB9_info;
           R1 = _scctJ::P64;
           P64[Sp - 40] = _scctE::P64;
           P64[Sp - 32] = _scctF::P64;
           P64[Sp - 24] = _scctG::P64;
           P64[Sp - 16] = _scctH::P64;
           P64[Sp - 8] = _scctI::P64;
           P64[Sp] = _scctD::P64;
           P64[Sp + 16] = _scctu::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchC4; else goto cchBa;
       uchC4: // global
           call _cchB9(R1) args: 0, res: 0, upd: 0;
       cchBa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchC8_srtd" {
     uchC8_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _cchB9() //  [R1]
         { info_tbl: [(cchB9,
                       label: block_cchB9_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchB9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchC3; else goto cchC2;
       cchC3: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchC2: // global
           _scctL::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_scctS_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_scctR_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _scctI::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _scctI::P64;
           I64[Sp + 64] = _scctL::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.247075815 UTC

[section ""data" . Text.Printf.$fPrintfArgWord8_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord8_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord8_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord8_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cchCW,
                       label: Text.Printf.$fPrintfArgWord8_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchCW: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchD0; else goto cchD1;
       cchD0: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord8_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchD1: // global
           I64[Sp - 16] = block_cchCT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchD9; else goto cchCU;
       uchD9: // global
           call _cchCT(R1) args: 0, res: 0, upd: 0;
       cchCU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchCT() //  [R1]
         { info_tbl: [(cchCT,
                       label: block_cchCT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchCT: // global
           I64[Sp - 48] = block_cchCZ_info;
           _scctY::P64 = P64[R1 + 7];
           _scctZ::P64 = P64[R1 + 15];
           _sccu0::P64 = P64[R1 + 23];
           _sccu1::P64 = P64[R1 + 31];
           _sccu2::P64 = P64[R1 + 39];
           _sccu3::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _scctZ::P64;
           P64[Sp - 32] = _sccu0::P64;
           P64[Sp - 24] = _sccu1::P64;
           P64[Sp - 16] = _sccu2::P64;
           P64[Sp - 8] = _sccu3::P64;
           P64[Sp] = _scctY::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchD8; else goto cchD3;
       uchD8: // global
           call _cchCZ(R1) args: 0, res: 0, upd: 0;
       cchD3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchCZ() //  [R1]
         { info_tbl: [(cchCZ,
                       label: block_cchCZ_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchCZ: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccu3::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccu3::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt4_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.255845197 UTC

[section ""data" . Text.Printf.$w$sformatInt_closure" {
     Text.Printf.$w$sformatInt_closure:
         const Text.Printf.$w$sformatInt_info;
         const 0;
 },
 Text.Printf.$w$sformatInt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchDq: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt_entry(R6,
                                                R5,
                                                R4,
                                                R3,
                                                R2,
                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sccuv_entry() //  [R1]
         { info_tbl: [(cchDL,
                       label: sat_sccuv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchDL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchDM; else goto cchDN;
       cchDM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchDN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fIntegralWord_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchEy_srtd" {
     uchEy_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sccuu_entry() //  [R1]
         { info_tbl: [(cchDZ,
                       label: sat_sccuu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchDZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchE0; else goto cchE1;
       cchE0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchE1: // global
           I64[Sp - 8] = block_cchDS_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchEk; else goto cchDT;
       uchEk: // global
           call _cchDS(R1) args: 0, res: 0, upd: 0;
       cchDT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchEz_srtd" {
     uchEz_srtd:
         const SccKB_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _cchDS() //  [R1]
         { info_tbl: [(cchDS,
                       label: block_cchDS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchDS: // global
           if (R1 & 7 == 1) goto cchDW; else goto cchDX;
       cchDW: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchDX: // global
           I64[Sp] = block_cchE7_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchE7() //  [R1]
         { info_tbl: [(cchE7,
                       label: block_cchE7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchE7: // global
           if (R1 & 7 == 1) goto cchEe; else goto cchEi;
       cchEe: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchEi: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchEA_srtd" {
     uchEA_srtd:
         const SccKB_srt+192;
         const 73;
         const 11601272640106397697;
         const 256;
 },
 Text.Printf.$w$sformatInt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cchEo,
                       label: Text.Printf.$w$sformatInt_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchEo: // global
           _sccub::P64 = R6;
           _sccua::P64 = R5;
           _sccu9::P64 = R4;
           _sccu8::P64 = R3;
           _sccu7::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cchEp; else goto cchEq;
       cchEq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cchEs; else goto cchEr;
       cchEs: // global
           HpAlloc = 16;
           goto cchEp;
       cchEp: // global
           R1 = Text.Printf.$w$sformatInt_closure;
           P64[Sp - 40] = _sccu7::P64;
           P64[Sp - 32] = _sccu8::P64;
           P64[Sp - 24] = _sccu9::P64;
           P64[Sp - 16] = _sccua::P64;
           P64[Sp - 8] = _sccub::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cchEr: // global
           _sccuc::P64 = P64[Sp];
           _sccud::P64 = P64[Sp + 8];
           _sccuw::I64 = I64[Sp + 16];
           if (_sccuw::I64 != 118) goto cchEm; else goto cchEn;
       cchEm: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccuw::I64;
           _sccum::P64 = Hp - 7;
           _sccul::P64 = _sccud::P64;
           _sccuk::P64 = _sccuc::P64;
           _sccuj::P64 = _sccub::P64;
           _sccui::P64 = _sccua::P64;
           _sccuh::P64 = _sccu9::P64;
           _sccug::P64 = _sccu8::P64;
           goto sccuf;
       cchEn: // global
           Hp = Hp - 16;
           _sccum::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccul::P64 = _sccud::P64;
           _sccuk::P64 = _sccuc::P64;
           _sccuj::P64 = _sccub::P64;
           _sccui::P64 = _sccua::P64;
           _sccuh::P64 = _sccu9::P64;
           _sccug::P64 = _sccu8::P64;
           goto sccuf;
       sccuf: // global
           I64[Sp - 48] = block_cchDC_info;
           R1 = _sccum::P64;
           P64[Sp - 40] = _sccuh::P64;
           P64[Sp - 32] = _sccui::P64;
           P64[Sp - 24] = _sccuj::P64;
           P64[Sp - 16] = _sccuk::P64;
           P64[Sp - 8] = _sccul::P64;
           P64[Sp] = _sccug::P64;
           P64[Sp + 16] = _sccu7::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchEx; else goto cchDD;
       uchEx: // global
           call _cchDC(R1) args: 0, res: 0, upd: 0;
       cchDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchEB_srtd" {
     uchEB_srtd:
         const SccKB_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _cchDC() //  [R1]
         { info_tbl: [(cchDC,
                       label: block_cchDC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchDC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchEw; else goto cchEv;
       cchEw: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchEv: // global
           _sccuo::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccuv_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sccuu_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccul::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sccul::P64;
           I64[Sp + 64] = _sccuo::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.276049418 UTC

[section ""data" . Text.Printf.$fPrintfArgWord_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cchFp,
                       label: Text.Printf.$fPrintfArgWord_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchFp: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchFt; else goto cchFu;
       cchFt: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchFu: // global
           I64[Sp - 16] = block_cchFm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchFC; else goto cchFn;
       uchFC: // global
           call _cchFm(R1) args: 0, res: 0, upd: 0;
       cchFn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchFm() //  [R1]
         { info_tbl: [(cchFm,
                       label: block_cchFm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchFm: // global
           I64[Sp - 48] = block_cchFs_info;
           _sccuB::P64 = P64[R1 + 7];
           _sccuC::P64 = P64[R1 + 15];
           _sccuD::P64 = P64[R1 + 23];
           _sccuE::P64 = P64[R1 + 31];
           _sccuF::P64 = P64[R1 + 39];
           _sccuG::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccuC::P64;
           P64[Sp - 32] = _sccuD::P64;
           P64[Sp - 24] = _sccuE::P64;
           P64[Sp - 16] = _sccuF::P64;
           P64[Sp - 8] = _sccuG::P64;
           P64[Sp] = _sccuB::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchFB; else goto cchFw;
       uchFB: // global
           call _cchFs(R1) args: 0, res: 0, upd: 0;
       cchFw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchFs() //  [R1]
         { info_tbl: [(cchFs,
                       label: block_cchFs_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchFs: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sccuG::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sccuG::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt_entry(R6,
                                                R5,
                                                R4,
                                                R3,
                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.283977973 UTC

[section ""data" . Text.Printf.$fPrintfArgInt1_closure" {
     Text.Printf.$fPrintfArgInt1_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.287078638 UTC

[section ""data" . Text.Printf.$fPrintfArgInt64_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt64_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt64_$sformatInt_info;
         const 0;
 },
 sat_sccv2_entry() //  [R1]
         { info_tbl: [(cchGb,
                       label: sat_sccv2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchGb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchGc; else goto cchGd;
       cchGc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchGd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchGU_srtd" {
     uchGU_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 sat_sccv1_entry() //  [R1]
         { info_tbl: [(cchGp,
                       label: sat_sccv1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchGp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchGq; else goto cchGr;
       cchGq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchGr: // global
           I64[Sp - 8] = block_cchGi_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchGK; else goto cchGj;
       uchGK: // global
           call _cchGi(R1) args: 0, res: 0, upd: 0;
       cchGj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchGV_srtd" {
     uchGV_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 _cchGi() //  [R1]
         { info_tbl: [(cchGi,
                       label: block_cchGi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchGi: // global
           if (R1 & 7 == 1) goto cchGm; else goto cchGn;
       cchGm: // global
           R1 = Text.Printf.$fPrintfArgInt1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchGn: // global
           I64[Sp] = block_cchGx_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchGx() //  [R1]
         { info_tbl: [(cchGx,
                       label: block_cchGx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchGx: // global
           if (R1 & 7 == 1) goto cchGE; else goto cchGI;
       cchGE: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchGI: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchGW_srtd" {
     uchGW_srtd:
         const SccKB_srt+192;
         const 76;
         const 9295429630892703745;
         const 3072;
 },
 Text.Printf.$fPrintfArgInt64_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cchGL,
                       label: Text.Printf.$fPrintfArgInt64_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchGL: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchGM; else goto cchGN;
       cchGM: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt64_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchGN: // global
           I64[Sp - 16] = block_cchFX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchGT; else goto cchFY;
       uchGT: // global
           call _cchFX(R1) args: 0, res: 0, upd: 0;
       cchFY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchGX_srtd" {
     uchGX_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _cchFX() //  [R1]
         { info_tbl: [(cchFX,
                       label: block_cchFX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchFX: // global
           I64[Sp - 48] = block_cchG2_info;
           _sccuN::P64 = P64[R1 + 7];
           _sccuO::P64 = P64[R1 + 15];
           _sccuP::P64 = P64[R1 + 23];
           _sccuQ::P64 = P64[R1 + 31];
           _sccuR::P64 = P64[R1 + 39];
           _sccuS::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccuO::P64;
           P64[Sp - 32] = _sccuP::P64;
           P64[Sp - 24] = _sccuQ::P64;
           P64[Sp - 16] = _sccuR::P64;
           P64[Sp - 8] = _sccuS::P64;
           P64[Sp] = _sccuN::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchGS; else goto cchG3;
       uchGS: // global
           call _cchG2(R1) args: 0, res: 0, upd: 0;
       cchG3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchGY_srtd" {
     uchGY_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _cchG2() //  [R1]
         { info_tbl: [(cchG2,
                       label: block_cchG2_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchG2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchGR; else goto cchGQ;
       cchGR: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchGQ: // global
           _sccuV::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccv2_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccv1_info;
           _sccuS::P64 = P64[Sp + 40];
           P64[Hp] = _sccuS::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccuR::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccuR::P64;
           P64[Sp + 48] = _sccuS::P64;
           I64[Sp + 56] = _sccuV::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.305928888 UTC

[section ""data" . Text.Printf.$fPrintfArgInt4_closure" {
     Text.Printf.$fPrintfArgInt4_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.309486696 UTC

[section ""data" . Text.Printf.$fPrintfArgInt32_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt32_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt32_$sformatInt_info;
         const 0;
 },
 sat_sccvl_entry() //  [R1]
         { info_tbl: [(cchHZ,
                       label: sat_sccvl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchHZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchI0; else goto cchI1;
       cchI0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchI1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt32_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchII_srtd" {
     uchII_srtd:
         const SccKB_srt+192;
         const 77;
         const 9223372036854775809;
         const 4096;
 },
 sat_sccvk_entry() //  [R1]
         { info_tbl: [(cchId,
                       label: sat_sccvk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchId: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchIe; else goto cchIf;
       cchIe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchIf: // global
           I64[Sp - 8] = block_cchI6_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchIy; else goto cchI7;
       uchIy: // global
           call _cchI6(R1) args: 0, res: 0, upd: 0;
       cchI7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchIJ_srtd" {
     uchIJ_srtd:
         const SccKB_srt+192;
         const 77;
         const 9223372036854775809;
         const 4096;
 },
 _cchI6() //  [R1]
         { info_tbl: [(cchI6,
                       label: block_cchI6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchI6: // global
           if (R1 & 7 == 1) goto cchIa; else goto cchIb;
       cchIa: // global
           R1 = Text.Printf.$fPrintfArgInt4_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchIb: // global
           I64[Sp] = block_cchIl_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchIl() //  [R1]
         { info_tbl: [(cchIl,
                       label: block_cchIl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchIl: // global
           if (R1 & 7 == 1) goto cchIs; else goto cchIw;
       cchIs: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchIw: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchIK_srtd" {
     uchIK_srtd:
         const SccKB_srt+192;
         const 78;
         const 9295429630892703745;
         const 12288;
 },
 Text.Printf.$fPrintfArgInt32_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cchIz,
                       label: Text.Printf.$fPrintfArgInt32_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchIz: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchIA; else goto cchIB;
       cchIA: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt32_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchIB: // global
           I64[Sp - 16] = block_cchHL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchIH; else goto cchHM;
       uchIH: // global
           call _cchHL(R1) args: 0, res: 0, upd: 0;
       cchHM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchIL_srtd" {
     uchIL_srtd:
         const SccKB_srt+192;
         const 77;
         const 9295429630892703745;
         const 4096;
 },
 _cchHL() //  [R1]
         { info_tbl: [(cchHL,
                       label: block_cchHL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchHL: // global
           I64[Sp - 48] = block_cchHQ_info;
           _sccv6::P64 = P64[R1 + 7];
           _sccv7::P64 = P64[R1 + 15];
           _sccv8::P64 = P64[R1 + 23];
           _sccv9::P64 = P64[R1 + 31];
           _sccva::P64 = P64[R1 + 39];
           _sccvb::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccv7::P64;
           P64[Sp - 32] = _sccv8::P64;
           P64[Sp - 24] = _sccv9::P64;
           P64[Sp - 16] = _sccva::P64;
           P64[Sp - 8] = _sccvb::P64;
           P64[Sp] = _sccv6::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchIG; else goto cchHR;
       uchIG: // global
           call _cchHQ(R1) args: 0, res: 0, upd: 0;
       cchHR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchIM_srtd" {
     uchIM_srtd:
         const SccKB_srt+192;
         const 77;
         const 9295429630892703745;
         const 4096;
 },
 _cchHQ() //  [R1]
         { info_tbl: [(cchHQ,
                       label: block_cchHQ_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchHQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchIF; else goto cchIE;
       cchIF: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchIE: // global
           _sccve::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccvl_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccvk_info;
           _sccvb::P64 = P64[Sp + 40];
           P64[Hp] = _sccvb::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccva::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccva::P64;
           P64[Sp + 48] = _sccvb::P64;
           I64[Sp + 56] = _sccve::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.32834979 UTC

[section ""data" . Text.Printf.$fPrintfArgInt3_closure" {
     Text.Printf.$fPrintfArgInt3_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.331159587 UTC

[section ""data" . Text.Printf.$fPrintfArgInt16_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt16_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt16_$sformatInt_info;
         const 0;
 },
 sat_sccvE_entry() //  [R1]
         { info_tbl: [(cchJN,
                       label: sat_sccvE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchJN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchJO; else goto cchJP;
       cchJO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchJP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt16_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchKw_srtd" {
     uchKw_srtd:
         const SccKB_srt+192;
         const 79;
         const 9223372036854775809;
         const 16384;
 },
 sat_sccvD_entry() //  [R1]
         { info_tbl: [(cchK1,
                       label: sat_sccvD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchK1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchK2; else goto cchK3;
       cchK2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchK3: // global
           I64[Sp - 8] = block_cchJU_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchKm; else goto cchJV;
       uchKm: // global
           call _cchJU(R1) args: 0, res: 0, upd: 0;
       cchJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchKx_srtd" {
     uchKx_srtd:
         const SccKB_srt+192;
         const 79;
         const 9223372036854775809;
         const 16384;
 },
 _cchJU() //  [R1]
         { info_tbl: [(cchJU,
                       label: block_cchJU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchJU: // global
           if (R1 & 7 == 1) goto cchJY; else goto cchJZ;
       cchJY: // global
           R1 = Text.Printf.$fPrintfArgInt3_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchJZ: // global
           I64[Sp] = block_cchK9_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchK9() //  [R1]
         { info_tbl: [(cchK9,
                       label: block_cchK9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchK9: // global
           if (R1 & 7 == 1) goto cchKg; else goto cchKk;
       cchKg: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchKk: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchKy_srtd" {
     uchKy_srtd:
         const SccKB_srt+192;
         const 80;
         const 9295429630892703745;
         const 49152;
 },
 Text.Printf.$fPrintfArgInt16_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cchKn,
                       label: Text.Printf.$fPrintfArgInt16_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchKn: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchKo; else goto cchKp;
       cchKo: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt16_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchKp: // global
           I64[Sp - 16] = block_cchJz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchKv; else goto cchJA;
       uchKv: // global
           call _cchJz(R1) args: 0, res: 0, upd: 0;
       cchJA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchKz_srtd" {
     uchKz_srtd:
         const SccKB_srt+192;
         const 79;
         const 9295429630892703745;
         const 16384;
 },
 _cchJz() //  [R1]
         { info_tbl: [(cchJz,
                       label: block_cchJz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchJz: // global
           I64[Sp - 48] = block_cchJE_info;
           _sccvp::P64 = P64[R1 + 7];
           _sccvq::P64 = P64[R1 + 15];
           _sccvr::P64 = P64[R1 + 23];
           _sccvs::P64 = P64[R1 + 31];
           _sccvt::P64 = P64[R1 + 39];
           _sccvu::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccvq::P64;
           P64[Sp - 32] = _sccvr::P64;
           P64[Sp - 24] = _sccvs::P64;
           P64[Sp - 16] = _sccvt::P64;
           P64[Sp - 8] = _sccvu::P64;
           P64[Sp] = _sccvp::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchKu; else goto cchJF;
       uchKu: // global
           call _cchJE(R1) args: 0, res: 0, upd: 0;
       cchJF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchKA_srtd" {
     uchKA_srtd:
         const SccKB_srt+192;
         const 79;
         const 9295429630892703745;
         const 16384;
 },
 _cchJE() //  [R1]
         { info_tbl: [(cchJE,
                       label: block_cchJE_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchJE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchKt; else goto cchKs;
       cchKt: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchKs: // global
           _sccvx::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccvE_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccvD_info;
           _sccvu::P64 = P64[Sp + 40];
           P64[Hp] = _sccvu::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccvt::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccvt::P64;
           P64[Sp + 48] = _sccvu::P64;
           I64[Sp + 56] = _sccvx::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.35077865 UTC

[section ""data" . Text.Printf.$fPrintfArgInt5_closure" {
     Text.Printf.$fPrintfArgInt5_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar22_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.353715894 UTC

[section ""data" . Text.Printf.$fPrintfArgInt8_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt8_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt8_$sformatInt_info;
         const 0;
 },
 sat_sccvX_entry() //  [R1]
         { info_tbl: [(cchLB,
                       label: sat_sccvX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchLB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchLC; else goto cchLD;
       cchLC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchLD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt8_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchMk_srtd" {
     uchMk_srtd:
         const SccKB_srt+192;
         const 81;
         const 9223372036854775809;
         const 65536;
 },
 sat_sccvW_entry() //  [R1]
         { info_tbl: [(cchLP,
                       label: sat_sccvW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchLP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchLQ; else goto cchLR;
       cchLQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchLR: // global
           I64[Sp - 8] = block_cchLI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchMa; else goto cchLJ;
       uchMa: // global
           call _cchLI(R1) args: 0, res: 0, upd: 0;
       cchLJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchMl_srtd" {
     uchMl_srtd:
         const SccKB_srt+192;
         const 81;
         const 9223372036854775809;
         const 65536;
 },
 _cchLI() //  [R1]
         { info_tbl: [(cchLI,
                       label: block_cchLI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchLI: // global
           if (R1 & 7 == 1) goto cchLM; else goto cchLN;
       cchLM: // global
           R1 = Text.Printf.$fPrintfArgInt5_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchLN: // global
           I64[Sp] = block_cchLX_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchLX() //  [R1]
         { info_tbl: [(cchLX,
                       label: block_cchLX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchLX: // global
           if (R1 & 7 == 1) goto cchM4; else goto cchM8;
       cchM4: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchM8: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchMm_srtd" {
     uchMm_srtd:
         const SccKB_srt+192;
         const 82;
         const 9295429630892703745;
         const 196608;
 },
 Text.Printf.$fPrintfArgInt8_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cchMb,
                       label: Text.Printf.$fPrintfArgInt8_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchMb: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchMc; else goto cchMd;
       cchMc: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt8_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchMd: // global
           I64[Sp - 16] = block_cchLn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchMj; else goto cchLo;
       uchMj: // global
           call _cchLn(R1) args: 0, res: 0, upd: 0;
       cchLo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchMn_srtd" {
     uchMn_srtd:
         const SccKB_srt+192;
         const 81;
         const 9295429630892703745;
         const 65536;
 },
 _cchLn() //  [R1]
         { info_tbl: [(cchLn,
                       label: block_cchLn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchLn: // global
           I64[Sp - 48] = block_cchLs_info;
           _sccvI::P64 = P64[R1 + 7];
           _sccvJ::P64 = P64[R1 + 15];
           _sccvK::P64 = P64[R1 + 23];
           _sccvL::P64 = P64[R1 + 31];
           _sccvM::P64 = P64[R1 + 39];
           _sccvN::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccvJ::P64;
           P64[Sp - 32] = _sccvK::P64;
           P64[Sp - 24] = _sccvL::P64;
           P64[Sp - 16] = _sccvM::P64;
           P64[Sp - 8] = _sccvN::P64;
           P64[Sp] = _sccvI::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchMi; else goto cchLt;
       uchMi: // global
           call _cchLs(R1) args: 0, res: 0, upd: 0;
       cchLt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchMo_srtd" {
     uchMo_srtd:
         const SccKB_srt+192;
         const 81;
         const 9295429630892703745;
         const 65536;
 },
 _cchLs() //  [R1]
         { info_tbl: [(cchLs,
                       label: block_cchLs_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchLs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchMh; else goto cchMg;
       cchMh: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchMg: // global
           _sccvQ::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccvX_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccvW_info;
           _sccvN::P64 = P64[Sp + 40];
           P64[Hp] = _sccvN::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccvM::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccvM::P64;
           P64[Sp + 48] = _sccvN::P64;
           I64[Sp + 56] = _sccvQ::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.373775575 UTC

[section ""data" . Text.Printf.$fPrintfArgInt_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt_$sformatInt_info;
         const 0;
 },
 sat_sccwg_entry() //  [R1]
         { info_tbl: [(cchNo,
                       label: sat_sccwg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchNo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchNp; else goto cchNq;
       cchNp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchNq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fIntegralInt_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchO7_srtd" {
     uchO7_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 sat_sccwf_entry() //  [R1]
         { info_tbl: [(cchNC,
                       label: sat_sccwf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchNC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchND; else goto cchNE;
       cchND: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchNE: // global
           I64[Sp - 8] = block_cchNv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchNX; else goto cchNw;
       uchNX: // global
           call _cchNv(R1) args: 0, res: 0, upd: 0;
       cchNw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchO8_srtd" {
     uchO8_srtd:
         const SccKB_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 _cchNv() //  [R1]
         { info_tbl: [(cchNv,
                       label: block_cchNv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchNv: // global
           if (R1 & 7 == 1) goto cchNz; else goto cchNA;
       cchNz: // global
           R1 = Text.Printf.$fPrintfArgInt1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchNA: // global
           I64[Sp] = block_cchNK_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchNK() //  [R1]
         { info_tbl: [(cchNK,
                       label: block_cchNK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchNK: // global
           if (R1 & 7 == 1) goto cchNR; else goto cchNV;
       cchNR: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchNV: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchO9_srtd" {
     uchO9_srtd:
         const SccKB_srt+192;
         const 83;
         const 9295429630892703745;
         const 263168;
 },
 Text.Printf.$fPrintfArgInt_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cchNY,
                       label: Text.Printf.$fPrintfArgInt_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchNY: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchNZ; else goto cchO0;
       cchNZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchO0: // global
           I64[Sp - 16] = block_cchNa_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchO6; else goto cchNb;
       uchO6: // global
           call _cchNa(R1) args: 0, res: 0, upd: 0;
       cchNb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchOa_srtd" {
     uchOa_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _cchNa() //  [R1]
         { info_tbl: [(cchNa,
                       label: block_cchNa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchNa: // global
           I64[Sp - 48] = block_cchNf_info;
           _sccw1::P64 = P64[R1 + 7];
           _sccw2::P64 = P64[R1 + 15];
           _sccw3::P64 = P64[R1 + 23];
           _sccw4::P64 = P64[R1 + 31];
           _sccw5::P64 = P64[R1 + 39];
           _sccw6::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccw2::P64;
           P64[Sp - 32] = _sccw3::P64;
           P64[Sp - 24] = _sccw4::P64;
           P64[Sp - 16] = _sccw5::P64;
           P64[Sp - 8] = _sccw6::P64;
           P64[Sp] = _sccw1::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchO5; else goto cchNg;
       uchO5: // global
           call _cchNf(R1) args: 0, res: 0, upd: 0;
       cchNg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchOb_srtd" {
     uchOb_srtd:
         const SccKB_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _cchNf() //  [R1]
         { info_tbl: [(cchNf,
                       label: block_cchNf_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchNf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchO4; else goto cchO3;
       cchO4: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchO3: // global
           _sccw9::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sccwg_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sccwf_info;
           _sccw6::P64 = P64[Sp + 40];
           P64[Hp] = _sccw6::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sccw5::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccw5::P64;
           P64[Sp + 48] = _sccw6::P64;
           I64[Sp + 56] = _sccw9::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.395508351 UTC

[section ""data" . Text.Printf.$wformatInt_closure" {
     Text.Printf.$wformatInt_closure:
         const Text.Printf.$wformatInt_info;
         const 0;
 },
 Text.Printf.$wformatInt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchOU: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatInt_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sccws_entry() //  [R1]
         { info_tbl: [(cchPi,
                       label: sat_sccws_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchPi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchPj; else goto cchPk;
       cchPj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchPk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccwJ_entry() //  [R1]
         { info_tbl: [(cchPx,
                       label: sat_sccwJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchPx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cchPy; else goto cchPz;
       cchPy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchPz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uchQx_srtd" {
     uchQx_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sccwI_entry() //  [R1]
         { info_tbl: [(cchPL,
                       label: sat_sccwI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchPL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchPM; else goto cchPN;
       cchPM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchPN: // global
           I64[Sp - 16] = block_cchPE_info;
           _sccwr::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _sccwr::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchQ9; else goto cchPF;
       uchQ9: // global
           call _cchPE(R1) args: 0, res: 0, upd: 0;
       cchPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchQy_srtd" {
     uchQy_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _cchPE() //  [R1]
         { info_tbl: [(cchPE,
                       label: block_cchPE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchPE: // global
           if (R1 & 7 == 1) goto cchPI; else goto cchPJ;
       cchPI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cchPT; else goto cchPS;
       cchPT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchPS: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchPJ: // global
           I64[Sp + 8] = block_cchPW_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           Sp = Sp + 8;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchPW() //  [R1]
         { info_tbl: [(cchPW,
                       label: block_cchPW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchPW: // global
           if (R1 & 7 == 1) goto cchQ3; else goto cchQ7;
       cchQ3: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchQ7: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchQz_srtd" {
     uchQz_srtd:
         const SccKB_srt+192;
         const 84;
         const 9304436830147444737;
         const 524288;
 },
 Text.Printf.$wformatInt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cchQa,
                       label: Text.Printf.$wformatInt_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchQa: // global
           _sccwl::P64 = R6;
           _sccwk::P64 = R5;
           _sccwj::P64 = R4;
           _sccwi::P64 = R3;
           _sccwh::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto cchQb; else goto cchQc;
       cchQc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchQe; else goto cchQd;
       cchQe: // global
           HpAlloc = 24;
           goto cchQb;
       cchQb: // global
           R1 = Text.Printf.$wformatInt_closure;
           P64[Sp - 40] = _sccwh::P64;
           P64[Sp - 32] = _sccwi::P64;
           P64[Sp - 24] = _sccwj::P64;
           P64[Sp - 16] = _sccwk::P64;
           P64[Sp - 8] = _sccwl::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       cchQd: // global
           I64[Hp - 16] = sat_sccws_info;
           P64[Hp] = _sccwi::P64;
           I64[Sp - 40] = block_cchP0_info;
           R2 = _sccwh::P64;
           I64[Sp - 56] = stg_ap_p_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 32] = _sccwh::P64;
           P64[Sp - 24] = _sccwj::P64;
           P64[Sp - 16] = _sccwk::P64;
           P64[Sp - 8] = _sccwl::P64;
           Sp = Sp - 56;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchQA_srtd" {
     uchQA_srtd:
         const SccKB_srt+192;
         const 64;
         const 9304436830147444737;
 },
 _cchP0() //  [R1]
         { info_tbl: [(cchP0,
                       label: block_cchP0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchP0: // global
           I64[Sp - 8] = block_cchP6_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchQB_srtd" {
     uchQB_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _cchP6() //  [R1]
         { info_tbl: [(cchP6,
                       label: block_cchP6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchP6: // global
           _sccwk::P64 = P64[Sp + 32];
           _sccwl::P64 = P64[Sp + 40];
           _sccwm::P64 = P64[Sp + 48];
           _sccwn::P64 = P64[Sp + 56];
           _sccwo::P64 = P64[Sp + 64];
           _sccwp::P64 = P64[Sp + 72];
           _sccwq::I64 = I64[Sp + 80];
           if (R1 == 1) goto cchQp; else goto cchQl;
       cchQp: // global
           Hp = Hp + 16;
           _sccwK::I64 = R1;
           if (Hp > HpLim) (likely: False) goto cchQs; else goto cchQr;
       cchQr: // global
           if (_sccwq::I64 == 118) goto cchQv; else goto cchQu;
       cchQv: // global
           Hp = Hp - 16;
           _sccwA::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sccwz::P64 = _sccwp::P64;
           _sccwy::P64 = _sccwo::P64;
           _sccwx::P64 = _sccwn::P64;
           _sccww::P64 = _sccwm::P64;
           _sccwv::P64 = _sccwl::P64;
           _sccwu::P64 = _sccwk::P64;
           goto sccwt;
       cchQu: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccwq::I64;
           _sccwA::P64 = Hp - 7;
           _sccwz::P64 = _sccwp::P64;
           _sccwy::P64 = _sccwo::P64;
           _sccwx::P64 = _sccwn::P64;
           _sccww::P64 = _sccwm::P64;
           _sccwv::P64 = _sccwl::P64;
           _sccwu::P64 = _sccwk::P64;
           goto sccwt;
       cchQl: // global
           Hp = Hp + 16;
           _sccwK::I64 = R1;
           if (Hp > HpLim) (likely: False) goto cchQs; else goto cchQn;
       cchQs: // global
           HpAlloc = 16;
           R1 = _sccwK::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cchQn: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sccwq::I64;
           _sccwA::P64 = Hp - 7;
           _sccwz::P64 = _sccwp::P64;
           _sccwy::P64 = _sccwo::P64;
           _sccwx::P64 = _sccwn::P64;
           _sccww::P64 = _sccwm::P64;
           _sccwv::P64 = _sccwl::P64;
           _sccwu::P64 = _sccwk::P64;
           goto sccwt;
       sccwt: // global
           I64[Sp] = block_cchPo_info;
           R1 = _sccwA::P64;
           P64[Sp + 32] = _sccwz::P64;
           P64[Sp + 40] = _sccwy::P64;
           P64[Sp + 48] = _sccwx::P64;
           P64[Sp + 56] = _sccww::P64;
           P64[Sp + 64] = _sccwv::P64;
           P64[Sp + 80] = _sccwu::P64;
           if (R1 & 7 != 0) goto uchQw; else goto cchPp;
       uchQw: // global
           call _cchPo(R1) args: 0, res: 0, upd: 0;
       cchPp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchQC_srtd" {
     uchQC_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _cchPo() //  [R1]
         { info_tbl: [(cchPo,
                       label: block_cchPo_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchPo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cchQj; else goto cchQi;
       cchQj: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchQi: // global
           _sccwC::I64 = I64[R1 + 7];
           I64[Hp - 56] = sat_sccwJ_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_sccwI_info;
           P64[Hp - 8] = P64[Sp + 72];
           P64[Hp] = P64[Sp + 8];
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 64];
           R4 = P64[Sp + 80];
           R3 = Hp - 56;
           R2 = Hp - 24;
           P64[Sp + 56] = P64[Sp + 48];
           P64[Sp + 64] = P64[Sp + 40];
           P64[Sp + 72] = P64[Sp + 32];
           I64[Sp + 80] = _sccwC::I64;
           Sp = Sp + 56;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.424652873 UTC

[section ""data" . Text.Printf.formatInt_closure" {
     Text.Printf.formatInt_closure:
         const Text.Printf.formatInt_info;
         const 0;
 },
 Text.Printf.formatInt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cchRI,
                       label: Text.Printf.formatInt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchRI: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cchRM; else goto cchRN;
       cchRM: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatInt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cchRN: // global
           I64[Sp - 32] = block_cchRF_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uchRV; else goto cchRG;
       uchRV: // global
           call _cchRF(R1) args: 0, res: 0, upd: 0;
       cchRG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchRF() //  [R1]
         { info_tbl: [(cchRF,
                       label: block_cchRF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchRF: // global
           I64[Sp - 48] = block_cchRL_info;
           _sccwT::P64 = P64[R1 + 7];
           _sccwU::P64 = P64[R1 + 15];
           _sccwV::P64 = P64[R1 + 23];
           _sccwW::P64 = P64[R1 + 31];
           _sccwX::P64 = P64[R1 + 39];
           _sccwY::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccwU::P64;
           P64[Sp - 32] = _sccwV::P64;
           P64[Sp - 24] = _sccwW::P64;
           P64[Sp - 16] = _sccwX::P64;
           P64[Sp - 8] = _sccwY::P64;
           P64[Sp] = _sccwT::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchRU; else goto cchRP;
       uchRU: // global
           call _cchRL(R1) args: 0, res: 0, upd: 0;
       cchRP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchRL() //  [R1]
         { info_tbl: [(cchRL,
                       label: block_cchRL_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchRL: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           _sccwY::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 16];
           P64[Sp + 48] = P64[Sp + 24];
           P64[Sp + 56] = P64[Sp + 32];
           P64[Sp + 64] = _sccwY::P64;
           I64[Sp + 72] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatInt_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.433638143 UTC

[section ""data" . Text.Printf.$fPrintfArgWord64_closure" {
     Text.Printf.$fPrintfArgWord64_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord64_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.435500639 UTC

[section ""data" . Text.Printf.$fPrintfArgWord32_closure" {
     Text.Printf.$fPrintfArgWord32_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord32_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.437503811 UTC

[section ""data" . Text.Printf.$fPrintfArgWord16_closure" {
     Text.Printf.$fPrintfArgWord16_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord16_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.439221637 UTC

[section ""data" . Text.Printf.$fPrintfArgWord8_closure" {
     Text.Printf.$fPrintfArgWord8_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord8_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.440965478 UTC

[section ""data" . Text.Printf.$fPrintfArgWord_closure" {
     Text.Printf.$fPrintfArgWord_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.442814957 UTC

[section ""data" . Text.Printf.$fPrintfArgInt64_closure" {
     Text.Printf.$fPrintfArgInt64_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt64_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.444651735 UTC

[section ""data" . Text.Printf.$fPrintfArgInt32_closure" {
     Text.Printf.$fPrintfArgInt32_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt32_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.446694086 UTC

[section ""data" . Text.Printf.$fPrintfArgInt16_closure" {
     Text.Printf.$fPrintfArgInt16_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt16_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.448455526 UTC

[section ""data" . Text.Printf.$fPrintfArgInt8_closure" {
     Text.Printf.$fPrintfArgInt8_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt8_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.450174036 UTC

[section ""data" . Text.Printf.$fPrintfArgInt_closure" {
     Text.Printf.$fPrintfArgInt_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.452893172 UTC

[section ""data" . Text.Printf.formatInteger_closure" {
     Text.Printf.formatInteger_closure:
         const Text.Printf.formatInteger_info;
         const 0;
 },
 section ""relreadonly" . uchTh_srtd" {
     uchTh_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sccxj_entry() //  [R1]
         { info_tbl: [(cchSM,
                       label: sat_sccxj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchSM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchSN; else goto cchSO;
       cchSN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchSO: // global
           I64[Sp - 8] = block_cchSF_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchT7; else goto cchSG;
       uchT7: // global
           call _cchSF(R1) args: 0, res: 0, upd: 0;
       cchSG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchTi_srtd" {
     uchTi_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _cchSF() //  [R1]
         { info_tbl: [(cchSF,
                       label: block_cchSF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchSF: // global
           if (R1 & 7 == 1) goto cchSJ; else goto cchSK;
       cchSJ: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchSK: // global
           I64[Sp] = block_cchSU_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchSU() //  [R1]
         { info_tbl: [(cchSU,
                       label: block_cchSU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchSU: // global
           if (R1 & 7 == 1) goto cchT1; else goto cchT5;
       cchT1: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchT5: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchTj_srtd" {
     uchTj_srtd:
         const SccKB_srt+192;
         const 86;
         const 9295429630892703745;
         const 2097152;
 },
 Text.Printf.formatInteger_entry() //  [R2, R3]
         { info_tbl: [(cchT8,
                       label: Text.Printf.formatInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchT8: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchT9; else goto cchTa;
       cchT9: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchTa: // global
           I64[Sp - 16] = block_cchSr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchTg; else goto cchSs;
       uchTg: // global
           call _cchSr(R1) args: 0, res: 0, upd: 0;
       cchSs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchTk_srtd" {
     uchTk_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _cchSr() //  [R1]
         { info_tbl: [(cchSr,
                       label: block_cchSr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchSr: // global
           I64[Sp - 48] = block_cchSw_info;
           _sccx5::P64 = P64[R1 + 7];
           _sccx6::P64 = P64[R1 + 15];
           _sccx7::P64 = P64[R1 + 23];
           _sccx8::P64 = P64[R1 + 31];
           _sccx9::P64 = P64[R1 + 39];
           _sccxa::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccx6::P64;
           P64[Sp - 32] = _sccx7::P64;
           P64[Sp - 24] = _sccx8::P64;
           P64[Sp - 16] = _sccx9::P64;
           P64[Sp - 8] = _sccxa::P64;
           P64[Sp] = _sccx5::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchTf; else goto cchSx;
       uchTf: // global
           call _cchSw(R1) args: 0, res: 0, upd: 0;
       cchSx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchTl_srtd" {
     uchTl_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _cchSw() //  [R1]
         { info_tbl: [(cchSw,
                       label: block_cchSw_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchSw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchTe; else goto cchTd;
       cchTe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchTd: // global
           _sccxd::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sccxj_info;
           _sccxa::P64 = P64[Sp + 40];
           P64[Hp] = _sccxa::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 56];
           R2 = Hp - 16;
           _sccx9::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccx9::P64;
           P64[Sp + 48] = _sccxa::P64;
           I64[Sp + 56] = _sccxd::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.471843453 UTC

[section ""data" . Text.Printf.$fPrintfArgNatural_$cformatArg_closure" {
     Text.Printf.$fPrintfArgNatural_$cformatArg_closure:
         const Text.Printf.$fPrintfArgNatural_$cformatArg_info;
         const 0;
 },
 section ""relreadonly" . uchUS_srtd" {
     uchUS_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sccxB_entry() //  [R1]
         { info_tbl: [(cchUn,
                       label: sat_sccxB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchUn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cchUo; else goto cchUp;
       cchUo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchUp: // global
           I64[Sp - 8] = block_cchUg_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchUI; else goto cchUh;
       uchUI: // global
           call _cchUg(R1) args: 0, res: 0, upd: 0;
       cchUh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchUT_srtd" {
     uchUT_srtd:
         const SccKB_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _cchUg() //  [R1]
         { info_tbl: [(cchUg,
                       label: block_cchUg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchUg: // global
           if (R1 & 7 == 1) goto cchUk; else goto cchUl;
       cchUk: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cchUl: // global
           I64[Sp] = block_cchUv_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cchUv() //  [R1]
         { info_tbl: [(cchUv,
                       label: block_cchUv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchUv: // global
           if (R1 & 7 == 1) goto cchUC; else goto cchUG;
       cchUC: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cchUG: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uchUU_srtd" {
     uchUU_srtd:
         const SccKB_srt+192;
         const 87;
         const 9295429630892703745;
         const 4194304;
 },
 Text.Printf.$fPrintfArgNatural_$cformatArg_entry() //  [R2, R3]
         { info_tbl: [(cchUJ,
                       label: Text.Printf.$fPrintfArgNatural_$cformatArg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchUJ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cchUK; else goto cchUL;
       cchUK: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgNatural_$cformatArg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cchUL: // global
           I64[Sp - 16] = block_cchU2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uchUR; else goto cchU3;
       uchUR: // global
           call _cchU2(R1) args: 0, res: 0, upd: 0;
       cchU3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchUV_srtd" {
     uchUV_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _cchU2() //  [R1]
         { info_tbl: [(cchU2,
                       label: block_cchU2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchU2: // global
           I64[Sp - 48] = block_cchU7_info;
           _sccxn::P64 = P64[R1 + 7];
           _sccxo::P64 = P64[R1 + 15];
           _sccxp::P64 = P64[R1 + 23];
           _sccxq::P64 = P64[R1 + 31];
           _sccxr::P64 = P64[R1 + 39];
           _sccxs::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sccxo::P64;
           P64[Sp - 32] = _sccxp::P64;
           P64[Sp - 24] = _sccxq::P64;
           P64[Sp - 16] = _sccxr::P64;
           P64[Sp - 8] = _sccxs::P64;
           P64[Sp] = _sccxn::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uchUQ; else goto cchU8;
       uchUQ: // global
           call _cchU7(R1) args: 0, res: 0, upd: 0;
       cchU8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uchUW_srtd" {
     uchUW_srtd:
         const SccKB_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _cchU7() //  [R1]
         { info_tbl: [(cchU7,
                       label: block_cchU7_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchU7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchUP; else goto cchUO;
       cchUP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchUO: // global
           _sccxv::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sccxB_info;
           _sccxs::P64 = P64[Sp + 40];
           P64[Hp] = _sccxs::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 56];
           R2 = Hp - 16;
           _sccxr::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sccxr::P64;
           P64[Sp + 48] = _sccxs::P64;
           I64[Sp + 56] = _sccxv::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.489029899 UTC

[section ""data" . Text.Printf.$fPrintfArgNatural_closure" {
     Text.Printf.$fPrintfArgNatural_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgNatural_$cformatArg_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.490840963 UTC

[section ""data" . Text.Printf.$fPrintfArgInteger_closure" {
     Text.Printf.$fPrintfArgInteger_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.formatInteger_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.492902046 UTC

[section ""data" . lvl42_rcccH_closure" {
     lvl42_rcccH_closure:
         const lvl42_rcccH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rcccH_entry() //  [R1]
         { info_tbl: [(cchVH,
                       label: lvl42_rcccH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchVH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchVI; else goto cchVJ;
       cchVI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchVJ: // global
           (_cchVE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cchVE::I64 == 0) goto cchVG; else goto cchVF;
       cchVG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchVF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cchVE::I64;
           R4 = Text.Read.readEither7_closure+1;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadInt2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.496904257 UTC

[section ""data" . lvl43_rcccI_closure" {
     lvl43_rcccI_closure:
         const Text.Printf.FieldFormat_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Types.False_closure+1;
         const GHC.Types.[]_closure+1;
         const lvl23_rccco_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.499449674 UTC

[section ""data" . lvl44_rcccJ_closure" {
     lvl44_rcccJ_closure:
         const lvl44_rcccJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rcccJ_entry() //  [R1]
         { info_tbl: [(cchVY,
                       label: lvl44_rcccJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchVY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchVZ; else goto cchW0;
       cchVZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchW0: // global
           (_cchVV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cchVV::I64 == 0) goto cchVX; else goto cchVW;
       cchVX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchVW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cchVV::I64;
           R2 = Text.Read.readEither5_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.503628551 UTC

[section ""data" . lvl45_rcccK_closure" {
     lvl45_rcccK_closure:
         const lvl45_rcccK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl45_rcccK_entry() //  [R1]
         { info_tbl: [(cchWe,
                       label: lvl45_rcccK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchWe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchWf; else goto cchWg;
       cchWf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchWg: // global
           (_cchWb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cchWb::I64 == 0) goto cchWd; else goto cchWc;
       cchWd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchWc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cchWb::I64;
           R2 = Text.Read.readEither2_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.508399527 UTC

[section ""data" . $wgetStar_rcccL_closure" {
     $wgetStar_rcccL_closure:
         const $wgetStar_rcccL_info;
         const 0;
 },
 sat_sccxK_entry() //  [R1]
         { info_tbl: [(cchWL,
                       label: sat_sccxK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchWL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchWM; else goto cchWN;
       cchWM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchWN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Types.[]_closure+1;
           R2 = lvl43_rcccI_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccxS_entry() //  [R1]
         { info_tbl: [(cchWQ,
                       label: sat_sccxS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchWQ: // global
           _sccxS::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cchWR; else goto cchWS;
       cchWS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchWU; else goto cchWT;
       cchWU: // global
           HpAlloc = 24;
           goto cchWR;
       cchWR: // global
           R1 = _sccxS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchWT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccxS::P64;
           _sccxJ::P64 = P64[_sccxS::P64 + 16];
           I64[Hp - 16] = sat_sccxK_info;
           P64[Hp] = _sccxJ::P64;
           I64[Sp - 24] = block_cchWO_info;
           R3 = Hp - 16;
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchWO() //  [R1]
         { info_tbl: [(cchWO,
                       label: block_cchWO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchWO: // global
           I64[Sp] = block_cchWX_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchWX() //  [R1]
         { info_tbl: [(cchWX,
                       label: block_cchWX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchWX: // global
           if (R1 & 7 == 1) goto cchX4; else goto cchX9;
       cchX4: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cchX9: // global
           I64[Sp - 8] = block_cchX7_info;
           _sccxN::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccxN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchXn; else goto cchXa;
       uchXn: // global
           call _cchX7(R1) args: 0, res: 0, upd: 0;
       cchXa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cchX7() //  [R1]
         { info_tbl: [(cchX7,
                       label: block_cchX7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchX7: // global
           if (R1 & 7 == 1) goto cchXg; else goto cchXk;
       cchXg: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cchXk: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgetStar_rcccL_entry() //  [R2]
         { info_tbl: [(cchXs,
                       label: $wgetStar_rcccL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchXs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cchXt; else goto cchXu;
       cchXt: // global
           R2 = R2;
           R1 = $wgetStar_rcccL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cchXu: // global
           I64[Sp - 8] = block_cchWs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchXC; else goto cchWt;
       uchXC: // global
           call _cchWs(R1) args: 0, res: 0, upd: 0;
       cchWt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchWs() //  [R1]
         { info_tbl: [(cchWs,
                       label: block_cchWs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchWs: // global
           if (R1 & 7 == 1) goto cchXp; else goto cchXq;
       cchXp: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cchXq: // global
           I64[Sp - 8] = block_cchWy_info;
           _sccxG::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccxG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchXB; else goto cchWz;
       uchXB: // global
           call _cchWy(R1) args: 0, res: 0, upd: 0;
       cchWz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchWy() //  [R1]
         { info_tbl: [(cchWy,
                       label: block_cchWy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchWy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchXA; else goto cchXz;
       cchXA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cchXz: // global
           _sccxJ::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sccxS_info;
           P64[Hp] = _sccxJ::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.525213165 UTC

[section ""data" . lvl46_rcccM_closure" {
     lvl46_rcccM_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.527116232 UTC

[section ""data" . lvl47_rcccN_closure" {
     lvl47_rcccN_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.LeftAdjust_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.528817868 UTC

[section ""data" . lvl48_rcccO_closure" {
     lvl48_rcccO_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.ZeroPad_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.531640734 UTC

[section ""data" . lvl49_rcccP_closure" {
     lvl49_rcccP_closure:
         const lvl49_rcccP_info;
         const 0;
         const 0;
         const 0;
 },
 sat_sccy6_entry() //  [R1]
         { info_tbl: [(cchYG,
                       label: sat_sccy6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchYG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cchYH; else goto cchYI;
       cchYH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchYI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cchYE_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchYE() //  [R1]
         { info_tbl: [(cchYE,
                       label: block_cchYE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchYE: // global
           I64[Sp] = block_cchYL_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchYL() //  [R1]
         { info_tbl: [(cchYL,
                       label: block_cchYL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchYL: // global
           if (R1 & 7 == 1) goto cchYS; else goto cchYX;
       cchYS: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cchYX: // global
           I64[Sp - 8] = block_cchYV_info;
           _sccy1::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccy1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchZb; else goto cchYY;
       uchZb: // global
           call _cchYV(R1) args: 0, res: 0, upd: 0;
       cchYY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cchYV() //  [R1]
         { info_tbl: [(cchYV,
                       label: block_cchYV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchYV: // global
           if (R1 & 7 == 1) goto cchZ4; else goto cchZ8;
       cchZ4: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cchZ8: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl49_rcccP_entry() //  [R1]
         { info_tbl: [(cchZg,
                       label: lvl49_rcccP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchZg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cchZh; else goto cchZi;
       cchZh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cchZi: // global
           (_cchYp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cchYp::I64 == 0) goto cchYr; else goto cchYq;
       cchYr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cchYq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cchYp::I64;
           I64[Sp - 24] = block_cchYs_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cchYs() //  [R1, R2]
         { info_tbl: [(cchYs,
                       label: block_cchYs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchYs: // global
           I64[Sp - 8] = block_cchYu_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uchZt; else goto cchYv;
       uchZt: // global
           call _cchYu(R1) args: 0, res: 0, upd: 0;
       cchYv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cchYu() //  [R1]
         { info_tbl: [(cchYu,
                       label: block_cchYu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchYu: // global
           _sccxV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cchZd; else goto cchZe;
       cchZd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cchZo; else goto cchZn;
       cchZo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cchZn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sccxV::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cchZe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cchZs; else goto cchZr;
       cchZs: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cchZr: // global
           I64[Hp - 40] = sat_sccy6_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sccxV::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.547719262 UTC

[section ""data" . lvl50_rcccQ_closure" {
     lvl50_rcccQ_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.SignPlus_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.549901708 UTC

[section ""data" . lvl51_rcccR_closure" {
     lvl51_rcccR_closure:
         const lvl51_rcccR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl51_rcccR_entry() //  [R1]
         { info_tbl: [(cci0j,
                       label: lvl51_rcccR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci0j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cci0k; else goto cci0l;
       cci0k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci0l: // global
           (_cci0d::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cci0d::I64 == 0) goto cci0f; else goto cci0e;
       cci0f: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cci0e: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cci0d::I64;
           I64[Sp - 24] = block_cci0g_info;
           R1 = lvl49_rcccP_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uci0p; else goto cci0h;
       uci0p: // global
           call _cci0g(R1) args: 0, res: 0, upd: 0;
       cci0h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci0g() //  [R1]
         { info_tbl: [(cci0g,
                       label: block_cci0g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci0g: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.55556355 UTC

[section ""data" . lvl52_rcccS_closure" {
     lvl52_rcccS_closure:
         const GHC.Base.Just_con_info;
         const lvl51_rcccR_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.557537911 UTC

[section ""data" . lvl53_rcccT_closure" {
     lvl53_rcccT_closure:
         const lvl53_rcccT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl53_rcccT_entry() //  [R1]
         { info_tbl: [(cci0N,
                       label: lvl53_rcccT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci0N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cci0O; else goto cci0P;
       cci0O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci0P: // global
           (_cci0H::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cci0H::I64 == 0) goto cci0J; else goto cci0I;
       cci0J: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cci0I: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cci0H::I64;
           I64[Sp - 24] = block_cci0K_info;
           R1 = lvl49_rcccP_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uci0T; else goto cci0L;
       uci0T: // global
           call _cci0K(R1) args: 0, res: 0, upd: 0;
       cci0L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci0K() //  [R1]
         { info_tbl: [(cci0K,
                       label: block_cci0K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci0K: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.562988759 UTC

[section ""data" . lvl54_rcccU_closure" {
     lvl54_rcccU_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.SignSpace_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.578037381 UTC

[section ""data" . $wgetSpecs_rcccV_closure" {
     $wgetSpecs_rcccV_closure:
         const $wgetSpecs_rcccV_info;
         const 0;
 },
 ds3_sccyu_entry() //  [R1]
         { info_tbl: [(cci1O,
                       label: ds3_sccyu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci1O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cci1P; else goto cci1Q;
       cci1P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci1Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cci1H_info;
           _sccyj::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccyj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uci24; else goto cci1I;
       uci24: // global
           call _cci1H(R1) args: 0, res: 0, upd: 0;
       cci1I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci1H() //  [R1]
         { info_tbl: [(cci1H,
                       label: block_cci1H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci1H: // global
           if (R1 & 7 == 1) goto cci1L; else goto cci1M;
       cci1L: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cci1M: // global
           I64[Sp] = block_cci1W_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uci23; else goto cci1Y;
       uci23: // global
           call _cci1W(R1) args: 0, res: 0, upd: 0;
       cci1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci1W() //  [R1]
         { info_tbl: [(cci1W,
                       label: block_cci1W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci1W: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccyD_entry() //  [R1]
         { info_tbl: [(cci2j,
                       label: sat_sccyD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci2j: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cci2k; else goto cci2l;
       cci2k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci2l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cci2c_info;
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uci2G; else goto cci2d;
       uci2G: // global
           call _cci2c(R1) args: 0, res: 0, upd: 0;
       cci2d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci2c() //  [R1]
         { info_tbl: [(cci2c,
                       label: block_cci2c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci2c: // global
           if (R1 & 7 == 1) goto cci2g; else goto cci2h;
       cci2g: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cci2o_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uci2F; else goto cci2q;
       uci2F: // global
           call _cci2o(R1) args: 0, res: 0, upd: 0;
       cci2q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cci2h: // global
           R1 = lvl47_rcccN_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cci2o() //  [R1]
         { info_tbl: [(cci2o,
                       label: block_cci2o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci2o: // global
           if (R1 & 7 == 1) goto cci2w; else goto cci2A;
       cci2w: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cci2A: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccz8_entry() //  [R1]
         { info_tbl: [(cci30,
                       label: sat_sccz8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci30: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cci31; else goto cci32;
       cci31: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci32: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cci2Y_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cci2Y() //  [R1]
         { info_tbl: [(cci2Y,
                       label: block_cci2Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci2Y: // global
           I64[Sp] = block_cci35_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cci35() //  [R1]
         { info_tbl: [(cci35,
                       label: block_cci35_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci35: // global
           if (R1 & 7 == 1) goto cci3c; else goto cci3h;
       cci3c: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cci3h: // global
           I64[Sp - 8] = block_cci3f_info;
           _sccz3::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccz3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uci3v; else goto cci3i;
       uci3v: // global
           call _cci3f(R1) args: 0, res: 0, upd: 0;
       cci3i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci3f() //  [R1]
         { info_tbl: [(cci3f,
                       label: block_cci3f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci3f: // global
           if (R1 & 7 == 1) goto cci3o; else goto cci3s;
       cci3o: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cci3s: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sccyU_entry() //  [R1]
         { info_tbl: [(cci3A,
                       label: ds3_sccyU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci3A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cci3B; else goto cci3C;
       cci3B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci3C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cci2M_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cci2M() //  [R1, R2]
         { info_tbl: [(cci2M,
                       label: block_cci2M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci2M: // global
           I64[Sp - 8] = block_cci2O_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uci3N; else goto cci2P;
       uci3N: // global
           call _cci2O(R1) args: 0, res: 0, upd: 0;
       cci2P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci2O() //  [R1]
         { info_tbl: [(cci2O,
                       label: block_cci2O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci2O: // global
           _sccyX::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cci3x; else goto cci3y;
       cci3x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cci3I; else goto cci3H;
       cci3I: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cci3H: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sccyX::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cci3y: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cci3M; else goto cci3L;
       cci3M: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cci3L: // global
           I64[Hp - 40] = sat_sccz8_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sccyX::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scczD_entry() //  [R1]
         { info_tbl: [(cci4G,
                       label: sat_scczD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci4G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cci4H; else goto cci4I;
       cci4H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci4I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cci4E_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cci4E() //  [R1]
         { info_tbl: [(cci4E,
                       label: block_cci4E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci4E: // global
           I64[Sp] = block_cci4L_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cci4L() //  [R1]
         { info_tbl: [(cci4L,
                       label: block_cci4L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci4L: // global
           if (R1 & 7 == 1) goto cci4S; else goto cci4X;
       cci4S: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cci4X: // global
           I64[Sp - 8] = block_cci4V_info;
           _scczy::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _scczy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uci5b; else goto cci4Y;
       uci5b: // global
           call _cci4V(R1) args: 0, res: 0, upd: 0;
       cci4Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci4V() //  [R1]
         { info_tbl: [(cci4V,
                       label: block_cci4V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci4V: // global
           if (R1 & 7 == 1) goto cci54; else goto cci58;
       cci54: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cci58: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_scczp_entry() //  [R1]
         { info_tbl: [(cci5g,
                       label: ds12_scczp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci5g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cci5h; else goto cci5i;
       cci5h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci5i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cci4s_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cci4s() //  [R1, R2]
         { info_tbl: [(cci4s,
                       label: block_cci4s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci4s: // global
           I64[Sp - 8] = block_cci4u_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uci5t; else goto cci4v;
       uci5t: // global
           call _cci4u(R1) args: 0, res: 0, upd: 0;
       cci4v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci4u() //  [R1]
         { info_tbl: [(cci4u,
                       label: block_cci4u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci4u: // global
           _scczs::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cci5d; else goto cci5e;
       cci5d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cci5o; else goto cci5n;
       cci5o: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cci5n: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _scczs::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cci5e: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cci5s; else goto cci5r;
       cci5s: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cci5r: // global
           I64[Hp - 40] = sat_scczD_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _scczs::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_scczN_entry() //  [R1]
         { info_tbl: [(cci5C,
                       label: ds12_scczN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci5C: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cci5D; else goto cci5E;
       cci5D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci5E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cci5z_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cci5z() //  [R1, R2]
         { info_tbl: [(cci5z,
                       label: block_cci5z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci5z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cci5H; else goto cci5G;
       cci5H: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cci5G: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sccz9_entry() //  [R1]
         { info_tbl: [(cci5I,
                       label: ds4_sccz9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci5I: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cci5J; else goto cci5K;
       cci5J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci5K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cci3S_info;
           _sccyi::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sccyi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uci6v; else goto cci3T;
       uci6v: // global
           call _cci3S(R1) args: 0, res: 0, upd: 0;
       cci3T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci3S() //  [R1]
         { info_tbl: [(cci3S,
                       label: block_cci3S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci3S: // global
           I64[Sp] = block_cci3X_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uci6r; else goto cci3Y;
       uci6r: // global
           call _cci3X(R1) args: 0, res: 0, upd: 0;
       cci3Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci3X() //  [R1]
         { info_tbl: [(cci3X,
                       label: block_cci3X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci3X: // global
           if (R1 & 7 == 1) goto cci5P; else goto cci5U;
       cci5P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cci5S; else goto cci5R;
       cci5S: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cci5R: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cci5U: // global
           I64[Sp - 16] = block_cci43_info;
           _scczd::P64 = R1;
           _scczf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scczf::P64;
           P64[Sp] = _scczd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uci6s; else goto cci44;
       uci6s: // global
           call _cci43(R1) args: 0, res: 0, upd: 0;
       cci44: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci43() //  [R1]
         { info_tbl: [(cci43,
                       label: block_cci43_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci43: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cci5X; else goto cci5W;
       cci5X: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cci5W: // global
           if (I64[R1 + 7] == 46) goto cci61; else goto cci60;
       cci61: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cci4b_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uci6t; else goto cci4c;
       uci6t: // global
           call _cci4b(R1) args: 0, res: 0, upd: 0;
       cci4c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cci60: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cci4b() //  [R1]
         { info_tbl: [(cci4b,
                       label: block_cci4b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci4b: // global
           if (R1 & 7 == 1) goto cci65; else goto cci6a;
       cci65: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cci68; else goto cci67;
       cci68: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cci67: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl52_rcccS_closure+2;
           P64[Hp - 8] = lvl53_rcccT_closure;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cci6a: // global
           I64[Sp - 16] = block_cci4h_info;
           _scczj::P64 = R1;
           _scczl::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scczl::P64;
           P64[Sp] = _scczj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uci6u; else goto cci4i;
       uci6u: // global
           call _cci4h(R1) args: 0, res: 0, upd: 0;
       cci4i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci4h() //  [R1]
         { info_tbl: [(cci4h,
                       label: block_cci4h_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci4h: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cci6d; else goto cci6c;
       cci6d: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cci6c: // global
           _sccyi::P64 = P64[Sp + 24];
           if (I64[R1 + 7] == 42) goto cci6o; else goto cci6j;
       cci6o: // global
           I64[Hp - 112] = ds12_scczN_info;
           P64[Hp - 96] = _sccyi::P64;
           I64[Hp - 88] = stg_sel_0_upd_info;
           _cci5v::P64 = Hp - 112;
           P64[Hp - 72] = _cci5v::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cci5v::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 88;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cci6j: // global
           I64[Hp - 112] = ds12_scczp_info;
           P64[Hp - 96] = P64[Sp + 16];
           I64[Hp - 88] = stg_sel_1_upd_info;
           _cci4o::P64 = Hp - 112;
           P64[Hp - 72] = _cci4o::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cci4o::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = _sccyi::P64;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds5_sccA0_entry() //  [R1]
         { info_tbl: [(cci6D,
                       label: ds5_sccA0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci6D: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cci6E; else goto cci6F;
       cci6E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci6F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cci6A_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uci73; else goto cci6B;
       uci73: // global
           call _cci6A(R1) args: 0, res: 0, upd: 0;
       cci6B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci6A() //  [R1]
         { info_tbl: [(cci6A,
                       label: block_cci6A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci6A: // global
           I64[Sp - 8] = block_cci6I_info;
           _sccA3::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sccA3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uci72; else goto cci6K;
       uci72: // global
           call _cci6I(R1) args: 0, res: 0, upd: 0;
       cci6K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci6I() //  [R1]
         { info_tbl: [(cci6I,
                       label: block_cci6I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci6I: // global
           if (R1 & 7 == 1) goto cci6Q; else goto cci6V;
       cci6Q: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cci6V: // global
           I64[Sp] = block_cci6T_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uci74; else goto cci6W;
       uci74: // global
           call _cci6T(R1) args: 0, res: 0, upd: 0;
       cci6W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci6T() //  [R1]
         { info_tbl: [(cci6T,
                       label: block_cci6T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci6T: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccAx_entry() //  [R1]
         { info_tbl: [(cci7g,
                       label: sat_sccAx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci7g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cci7k; else goto cci7l;
       cci7k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci7l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cci7d_info;
           _sccyd::P64 = P64[R1 + 16];
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sccyd::P64;
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uci81; else goto cci7e;
       uci81: // global
           call _cci7d(R1) args: 0, res: 0, upd: 0;
       cci7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci7d() //  [R1]
         { info_tbl: [(cci7d,
                       label: block_cci7d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci7d: // global
           I64[Sp] = block_cci7j_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uci80; else goto cci7n;
       uci80: // global
           call _cci7j(R1) args: 0, res: 0, upd: 0;
       cci7n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci7j() //  [R1]
         { info_tbl: [(cci7j,
                       label: block_cci7j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci7j: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cci7x; else goto uci7Y;
       cci7x: // global
           _sccyd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cci7v_info;
           R1 = _sccyd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uci82; else goto cci7y;
       uci82: // global
           call _cci7v(R1) args: 0, res: 0, upd: 0;
       cci7y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uci7Y: // global
           Sp = Sp + 24;
           call _cci7V() args: 0, res: 0, upd: 0;
     }
 },
 _cci7v() //  [R1]
         { info_tbl: [(cci7v,
                       label: block_cci7v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci7v: // global
           if (R1 & 7 == 1) goto cci7F; else goto uci7Z;
       cci7F: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cci7C_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uci84; else goto cci7G;
       uci84: // global
           call _cci7C(R1) args: 0, res: 0, upd: 0;
       cci7G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uci7Z: // global
           Sp = Sp + 16;
           call _cci7V() args: 0, res: 0, upd: 0;
     }
 },
 _cci7C() //  [R1]
         { info_tbl: [(cci7C,
                       label: block_cci7C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci7C: // global
           if (R1 & 7 == 1) goto cci7M; else goto cci7Q;
       cci7M: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cci7Q: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cci7V() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci7V: // global
           R1 = lvl47_rcccN_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccAi_entry() //  [R1]
         { info_tbl: [(cci8e,
                       label: sat_sccAi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci8e: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cci8i; else goto cci8j;
       cci8i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci8j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cci8b_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uci8D; else goto cci8c;
       uci8D: // global
           call _cci8b(R1) args: 0, res: 0, upd: 0;
       cci8c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci8b() //  [R1]
         { info_tbl: [(cci8b,
                       label: block_cci8b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci8b: // global
           I64[Sp] = block_cci8h_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uci8C; else goto cci8l;
       uci8C: // global
           call _cci8h(R1) args: 0, res: 0, upd: 0;
       cci8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci8h() //  [R1]
         { info_tbl: [(cci8h,
                       label: block_cci8h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci8h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cci8r; else goto cci8q;
       cci8r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cci8q: // global
           _sccAf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sccAf::I64, 0)) goto cci8A; else goto cci8B;
       cci8A: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_sccAf::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cci8B: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccAW_entry() //  [R1]
         { info_tbl: [(cci8O,
                       label: sat_sccAW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci8O: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cci8P; else goto cci8Q;
       cci8P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci8Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cci8H_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uci9e; else goto cci8I;
       uci9e: // global
           call _cci8H(R1) args: 0, res: 0, upd: 0;
       cci8I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci8H() //  [R1]
         { info_tbl: [(cci8H,
                       label: block_cci8H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci8H: // global
           if (R1 & 7 == 1) goto uci9a; else goto cci8M;
       uci9a: // global
           Sp = Sp + 8;
           call _cci98() args: 0, res: 0, upd: 0;
       cci8M: // global
           I64[Sp] = block_cci8W_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uci9c; else goto cci8Y;
       uci9c: // global
           call _cci8W(R1) args: 0, res: 0, upd: 0;
       cci8Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci8W() //  [R1]
         { info_tbl: [(cci8W,
                       label: block_cci8W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci8W: // global
           if (R1 & 7 == 1) goto cci94; else goto uci9b;
       cci94: // global
           R1 = lvl50_rcccQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uci9b: // global
           Sp = Sp + 8;
           call _cci98() args: 0, res: 0, upd: 0;
     }
 },
 _cci98() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci98: // global
           R1 = lvl54_rcccU_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sccAX_entry() //  [R1]
         { info_tbl: [(cci9p,
                       label: ds3_sccAX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci9p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cci9q; else goto cci9r;
       cci9q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cci9r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cci9m_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cci9m() //  [R1, R2]
         { info_tbl: [(cci9m,
                       label: block_cci9m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci9m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cci9u; else goto cci9t;
       cci9u: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cci9t: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccBE_entry() //  [R1]
         { info_tbl: [(cciai,
                       label: sat_sccBE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciai: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cciaj; else goto cciak;
       cciaj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cciak: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cciag_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cciag() //  [R1]
         { info_tbl: [(cciag,
                       label: block_cciag_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciag: // global
           I64[Sp] = block_ccian_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccian() //  [R1]
         { info_tbl: [(ccian,
                       label: block_ccian_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccian: // global
           if (R1 & 7 == 1) goto cciau; else goto cciaz;
       cciau: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cciaz: // global
           I64[Sp - 8] = block_cciax_info;
           _sccBz::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccBz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uciaN; else goto cciaA;
       uciaN: // global
           call _cciax(R1) args: 0, res: 0, upd: 0;
       cciaA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cciax() //  [R1]
         { info_tbl: [(cciax,
                       label: block_cciax_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciax: // global
           if (R1 & 7 == 1) goto cciaG; else goto cciaK;
       cciaG: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cciaK: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_sccBq_entry() //  [R1]
         { info_tbl: [(cciaS,
                       label: ds12_sccBq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciaS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cciaT; else goto cciaU;
       cciaT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cciaU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccia4_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccia4() //  [R1, R2]
         { info_tbl: [(ccia4,
                       label: block_ccia4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccia4: // global
           I64[Sp - 8] = block_ccia6_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucib5; else goto ccia7;
       ucib5: // global
           call _ccia6(R1) args: 0, res: 0, upd: 0;
       ccia7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccia6() //  [R1]
         { info_tbl: [(ccia6,
                       label: block_ccia6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccia6: // global
           _sccBt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cciaP; else goto cciaQ;
       cciaP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccib0; else goto cciaZ;
       ccib0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cciaZ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sccBt::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cciaQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccib4; else goto ccib3;
       ccib4: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccib3: // global
           I64[Hp - 40] = sat_sccBE_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sccBt::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_sccBS_entry() //  [R1]
         { info_tbl: [(ccibe,
                       label: ds12_sccBS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccibe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccibk; else goto ccibl;
       ccibk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccibl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccibb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucibq; else goto ccibc;
       ucibq: // global
           call _ccibb(R1) args: 0, res: 0, upd: 0;
       ccibc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccibb() //  [R1]
         { info_tbl: [(ccibb,
                       label: block_ccibb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccibb: // global
           I64[Sp] = block_ccibh_info;
           R2 = P64[R1 + 7];
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccibh() //  [R1, R2]
         { info_tbl: [(ccibh,
                       label: block_ccibh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccibh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccibp; else goto ccibo;
       ccibp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccibo: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sccB1_entry() //  [R1]
         { info_tbl: [(ccibv,
                       label: ds4_sccB1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccibv: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccibw; else goto ccibx;
       ccibw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccibx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cci9z_info;
           _sccAX::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccAX::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucicg; else goto cci9A;
       ucicg: // global
           call _cci9z(R1) args: 0, res: 0, upd: 0;
       cci9A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci9z() //  [R1]
         { info_tbl: [(cci9z,
                       label: block_cci9z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci9z: // global
           if (R1 & 7 == 1) goto ccibs; else goto ccibt;
       ccibs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccibD; else goto ccibC;
       ccibD: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccibC: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccibt: // global
           I64[Sp - 16] = block_cci9F_info;
           _sccB2::P64 = R1;
           _sccB8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccB8::P64;
           P64[Sp] = _sccB2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucicd; else goto cci9G;
       ucicd: // global
           call _cci9F(R1) args: 0, res: 0, upd: 0;
       cci9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci9F() //  [R1]
         { info_tbl: [(cci9F,
                       label: block_cci9F_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci9F: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccibH; else goto ccibG;
       ccibH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccibG: // global
           if (I64[R1 + 7] == 46) goto ccibM; else goto ccibL;
       ccibM: // global
           Hp = Hp - 56;
           I64[Sp + 16] = block_cci9N_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ucice; else goto cci9O;
       ucice: // global
           call _cci9N(R1) args: 0, res: 0, upd: 0;
       cci9O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccibL: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cci9N() //  [R1]
         { info_tbl: [(cci9N,
                       label: block_cci9N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci9N: // global
           if (R1 & 7 == 1) goto ccibR; else goto ccibW;
       ccibR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccibU; else goto ccibT;
       ccibU: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccibT: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl52_rcccS_closure+2;
           P64[Hp - 8] = lvl53_rcccT_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccibW: // global
           I64[Sp - 16] = block_cci9T_info;
           _sccBg::P64 = R1;
           _sccBm::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccBm::P64;
           P64[Sp] = _sccBg::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucicf; else goto cci9U;
       ucicf: // global
           call _cci9T(R1) args: 0, res: 0, upd: 0;
       cci9U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cci9T() //  [R1]
         { info_tbl: [(cci9T,
                       label: block_cci9T_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci9T: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccibZ; else goto ccibY;
       ccibZ: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccibY: // global
           _sccAX::P64 = P64[Sp + 24];
           if (I64[R1 + 7] == 42) goto ccicb; else goto ccic6;
       ccicb: // global
           I64[Hp - 136] = ds12_sccBS_info;
           P64[Hp - 120] = _sccAX::P64;
           I64[Hp - 112] = stg_sel_0_upd_info;
           _ccib7::P64 = Hp - 136;
           P64[Hp - 96] = _ccib7::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _ccib7::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = Hp - 88;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = Hp - 112;
           _ccica::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _ccica::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccic6: // global
           I64[Hp - 136] = ds12_sccBq_info;
           P64[Hp - 120] = P64[Sp + 16];
           I64[Hp - 112] = stg_sel_0_upd_info;
           P64[Hp - 96] = _sccAX::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           _ccia0::P64 = Hp - 136;
           P64[Hp - 72] = _ccia0::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _ccia0::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 112;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds5_sccC8_entry() //  [R1]
         { info_tbl: [(ccico,
                       label: ds5_sccC8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccico: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccicp; else goto ccicq;
       ccicp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccicq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccicl_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucicO; else goto ccicm;
       ucicO: // global
           call _ccicl(R1) args: 0, res: 0, upd: 0;
       ccicm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccicl() //  [R1]
         { info_tbl: [(ccicl,
                       label: block_ccicl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccicl: // global
           I64[Sp - 8] = block_ccict_info;
           _sccCb::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sccCb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucicN; else goto ccicv;
       ucicN: // global
           call _ccict(R1) args: 0, res: 0, upd: 0;
       ccicv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccict() //  [R1]
         { info_tbl: [(ccict,
                       label: block_ccict_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccict: // global
           if (R1 & 7 == 1) goto ccicB; else goto ccicG;
       ccicB: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccicG: // global
           I64[Sp] = block_ccicE_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucicP; else goto ccicH;
       ucicP: // global
           call _ccicE(R1) args: 0, res: 0, upd: 0;
       ccicH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccicE() //  [R1]
         { info_tbl: [(ccicE,
                       label: block_ccicE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccicE: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccCF_entry() //  [R1]
         { info_tbl: [(ccid1,
                       label: sat_sccCF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccid1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccid5; else goto ccid6;
       ccid5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccid6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccicY_info;
           _sccyd::P64 = P64[R1 + 16];
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sccyd::P64;
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucidM; else goto ccicZ;
       ucidM: // global
           call _ccicY(R1) args: 0, res: 0, upd: 0;
       ccicZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccicY() //  [R1]
         { info_tbl: [(ccicY,
                       label: block_ccicY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccicY: // global
           I64[Sp] = block_ccid4_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ucidL; else goto ccid8;
       ucidL: // global
           call _ccid4(R1) args: 0, res: 0, upd: 0;
       ccid8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccid4() //  [R1]
         { info_tbl: [(ccid4,
                       label: block_ccid4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccid4: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto ccidi; else goto ucidJ;
       ccidi: // global
           _sccyd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccidg_info;
           R1 = _sccyd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucidN; else goto ccidj;
       ucidN: // global
           call _ccidg(R1) args: 0, res: 0, upd: 0;
       ccidj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ucidJ: // global
           Sp = Sp + 24;
           call _ccidG() args: 0, res: 0, upd: 0;
     }
 },
 _ccidg() //  [R1]
         { info_tbl: [(ccidg,
                       label: block_ccidg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccidg: // global
           if (R1 & 7 == 1) goto ccidq; else goto ucidK;
       ccidq: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccidn_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucidP; else goto ccidr;
       ucidP: // global
           call _ccidn(R1) args: 0, res: 0, upd: 0;
       ccidr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ucidK: // global
           Sp = Sp + 16;
           call _ccidG() args: 0, res: 0, upd: 0;
     }
 },
 _ccidn() //  [R1]
         { info_tbl: [(ccidn,
                       label: block_ccidn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccidn: // global
           if (R1 & 7 == 1) goto ccidx; else goto ccidB;
       ccidx: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccidB: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccidG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccidG: // global
           R1 = lvl47_rcccN_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccCq_entry() //  [R1]
         { info_tbl: [(ccidZ,
                       label: sat_sccCq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccidZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccie3; else goto ccie4;
       ccie3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccie4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccidW_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucieo; else goto ccidX;
       ucieo: // global
           call _ccidW(R1) args: 0, res: 0, upd: 0;
       ccidX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccidW() //  [R1]
         { info_tbl: [(ccidW,
                       label: block_ccidW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccidW: // global
           I64[Sp] = block_ccie2_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ucien; else goto ccie6;
       ucien: // global
           call _ccie2(R1) args: 0, res: 0, upd: 0;
       ccie6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccie2() //  [R1]
         { info_tbl: [(ccie2,
                       label: block_ccie2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccie2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cciec; else goto ccieb;
       cciec: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccieb: // global
           _sccCn::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sccCn::I64, 0)) goto cciel; else goto cciem;
       cciel: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_sccCn::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cciem: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccDo_entry() //  [R1]
         { info_tbl: [(ccieX,
                       label: sat_sccDo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccieX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccieY; else goto ccieZ;
       ccieY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccieZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccieV_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccieV() //  [R1]
         { info_tbl: [(ccieV,
                       label: block_ccieV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccieV: // global
           I64[Sp] = block_ccif2_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccif2() //  [R1]
         { info_tbl: [(ccif2,
                       label: block_ccif2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccif2: // global
           if (R1 & 7 == 1) goto ccif9; else goto ccife;
       ccif9: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccife: // global
           I64[Sp - 8] = block_ccifc_info;
           _sccDj::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sccDj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucifs; else goto cciff;
       ucifs: // global
           call _ccifc(R1) args: 0, res: 0, upd: 0;
       cciff: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccifc() //  [R1]
         { info_tbl: [(ccifc,
                       label: block_ccifc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccifc: // global
           if (R1 & 7 == 1) goto ccifl; else goto ccifp;
       ccifl: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccifp: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds7_sccDp_entry() //  [R1]
         { info_tbl: [(ccifB,
                       label: ds7_sccDp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccifB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccifC; else goto ccifD;
       ccifC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccifD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccify_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccify() //  [R1, R2]
         { info_tbl: [(ccify,
                       label: block_ccify_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccify: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccifG; else goto ccifF;
       ccifG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccifF: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sccD1_entry() //  [R1]
         { info_tbl: [(ccifL,
                       label: ds3_sccD1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccifL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccifM; else goto ccifN;
       ccifM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccifN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cciew_info;
           _sccyi::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sccyi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucigq; else goto cciex;
       ucigq: // global
           call _cciew(R1) args: 0, res: 0, upd: 0;
       cciex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cciew() //  [R1]
         { info_tbl: [(cciew,
                       label: block_cciew_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciew: // global
           if (R1 & 7 == 1) goto ccifI; else goto ccifJ;
       ccifI: // global
           I64[Sp] = block_ccifP_info;
           R1 = lvl49_rcccP_closure;
           if (R1 & 7 != 0) goto ucign; else goto ccifQ;
       ucign: // global
           call _ccifP(R1) args: 0, res: 0, upd: 0;
       ccifQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccifJ: // global
           I64[Sp - 16] = block_ccieC_info;
           _sccD2::P64 = R1;
           _sccD7::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sccD7::P64;
           P64[Sp] = _sccD2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucigo; else goto ccieD;
       ucigo: // global
           call _ccieC(R1) args: 0, res: 0, upd: 0;
       ccieD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccifP() //  [R1]
         { info_tbl: [(ccifP,
                       label: block_ccifP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccifP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccifY; else goto ccifX;
       ccifY: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccifX: // global
           _sccD4::P64 = P64[R1 + 7];
           _sccD5::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = _sccD4::P64;
           P64[Hp - 8] = _sccD5::P64;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccieC() //  [R1]
         { info_tbl: [(ccieC,
                       label: block_ccieC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccieC: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccig2; else goto ccig1;
       ccig2: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccig1: // global
           if (I64[R1 + 7] == 42) goto ccigl; else goto ccig4;
       ccigl: // global
           I64[Hp - 96] = ds7_sccDp_info;
           P64[Hp - 80] = P64[Sp + 24];
           I64[Hp - 72] = stg_sel_0_upd_info;
           _ccifu::P64 = Hp - 96;
           P64[Hp - 56] = _ccifu::P64;
           I64[Hp - 48] = stg_sel_1_upd_info;
           P64[Hp - 32] = _ccifu::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 72;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccig4: // global
           Hp = Hp - 104;
           _sccD2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccieJ_info;
           R3 = _sccD2::P64;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 16;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccieJ() //  [R1, R2]
         { info_tbl: [(ccieJ,
                       label: block_ccieJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccieJ: // global
           I64[Sp - 8] = block_ccieL_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucigp; else goto ccieM;
       ucigp: // global
           call _ccieL(R1) args: 0, res: 0, upd: 0;
       ccieM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccieL() //  [R1]
         { info_tbl: [(ccieL,
                       label: block_ccieL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccieL: // global
           _sccyi::P64 = P64[Sp + 16];
           _sccDd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccig9; else goto ccige;
       ccig9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccigc; else goto ccigb;
       ccigc: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccigb: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl46_rcccM_closure+1;
           P64[Hp - 8] = _sccDd::P64;
           P64[Hp] = _sccyi::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccige: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccigh; else goto ccigg;
       ccigh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccigg: // global
           I64[Hp - 48] = sat_sccDo_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = _sccDd::P64;
           P64[Hp] = _sccyi::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sccDB_entry() //  [R1]
         { info_tbl: [(ccigy,
                       label: ds4_sccDB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccigy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccigz; else goto ccigA;
       ccigz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccigA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccigv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucigY; else goto ccigw;
       ucigY: // global
           call _ccigv(R1) args: 0, res: 0, upd: 0;
       ccigw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccigv() //  [R1]
         { info_tbl: [(ccigv,
                       label: block_ccigv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccigv: // global
           I64[Sp - 8] = block_ccigD_info;
           _sccDE::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sccDE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucigX; else goto ccigF;
       ucigX: // global
           call _ccigD(R1) args: 0, res: 0, upd: 0;
       ccigF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccigD() //  [R1]
         { info_tbl: [(ccigD,
                       label: block_ccigD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccigD: // global
           if (R1 & 7 == 1) goto ccigL; else goto ccigQ;
       ccigL: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccigQ: // global
           I64[Sp] = block_ccigO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucigZ; else goto ccigR;
       ucigZ: // global
           call _ccigO(R1) args: 0, res: 0, upd: 0;
       ccigR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccigO() //  [R1]
         { info_tbl: [(ccigO,
                       label: block_ccigO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccigO: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccDU_entry() //  [R1]
         { info_tbl: [(ccihf,
                       label: sat_sccDU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccihf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccihg; else goto ccihh;
       ccihg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccihh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccih8_info;
           _sccye::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sccye::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucihC; else goto ccih9;
       ucihC: // global
           call _ccih8(R1) args: 0, res: 0, upd: 0;
       ccih9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccih8() //  [R1]
         { info_tbl: [(ccih8,
                       label: block_ccih8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccih8: // global
           if (R1 & 7 == 1) goto ccihc; else goto ccihd;
       ccihc: // global
           _sccye::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccihk_info;
           R1 = _sccye::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucihB; else goto ccihm;
       ucihB: // global
           call _ccihk(R1) args: 0, res: 0, upd: 0;
       ccihm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccihd: // global
           R1 = lvl47_rcccN_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccihk() //  [R1]
         { info_tbl: [(ccihk,
                       label: block_ccihk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccihk: // global
           if (R1 & 7 == 1) goto ccihs; else goto ccihw;
       ccihs: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccihw: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uciiq_srtd" {
     uciiq_srtd:
         const SccKB_srt+448;
         const 69;
         const 17293822569102704641;
         const 31;
 },
 $wgetSpecs_rcccV_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccihH,
                       label: $wgetSpecs_rcccV_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccihH: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccihI; else goto uciic;
       ccihI: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wgetSpecs_rcccV_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       uciic: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cci19() args: 0, res: 0, upd: 0;
     }
 },
 _cci19() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci19: // global
           I64[Sp - 8] = block_cci1c_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uciii; else goto cci1d;
       uciii: // global
           call _cci1c(R1) args: 0, res: 0, upd: 0;
       cci1d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uciir_srtd" {
     uciir_srtd:
         const SccKB_srt+448;
         const 68;
         const 17293822569102704641;
         const 15;
 },
 _cci1c() //  [R1]
         { info_tbl: [(cci1c,
                       label: block_cci1c_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci1c: // global
           if (R1 & 7 == 1) goto ccihE; else goto ccihF;
       ccihE: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccihF: // global
           I64[Sp - 8] = block_cci1i_info;
           _sccyj::P64 = R1;
           _sccym::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccym::P64;
           P64[Sp + 40] = _sccyj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uciij; else goto cci1j;
       uciij: // global
           call _cci1i(R1) args: 0, res: 0, upd: 0;
       cci1j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uciis_srtd" {
     uciis_srtd:
         const SccKB_srt+448;
         const 68;
         const 17293822569102704641;
         const 15;
 },
 _cci1i() //  [R1]
         { info_tbl: [(cci1i,
                       label: block_cci1i_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci1i: // global
           Hp = Hp + 344;
           if (Hp > HpLim) (likely: False) goto ccihP; else goto ccihO;
       ccihP: // global
           HpAlloc = 344;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccihO: // global
           _sccyd::P64 = P64[Sp + 16];
           _sccye::P64 = P64[Sp + 24];
           _sccyf::P64 = P64[Sp + 32];
           _sccyg::P64 = P64[Sp + 40];
           _sccyi::P64 = P64[Sp + 56];
           _sccyj::P64 = P64[Sp + 48];
           _sccyp::I64 = I64[R1 + 7];
           if (_sccyp::I64 >= 49) goto ccihX; else goto uciia;
       uciia: // global
           if (_sccyp::I64 < 32) goto ccihX; else goto uciib;
       uciib: // global
           _sccym::P64 = P64[Sp + 8];
           switch [32 .. 48] _sccyp::I64 {
               case 32 : goto ccihY;
               case 35 : goto ccihZ;
               case 42 : goto ccii2;
               case 43 : goto ccii3;
               case 45 : goto ccii4;
               case 46 : goto ccii8;
               case 48 : goto ccii9;
               default: {goto ccihX;}
           }
       ccii9: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = GHC.Types.True_closure+2;
           P64[Sp + 32] = _sccyf::P64;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto uciio;
       ccii8: // global
           I64[Hp - 336] = ds3_sccD1_info;
           P64[Hp - 320] = _sccyi::P64;
           P64[Hp - 312] = _sccym::P64;
           I64[Hp - 304] = ds4_sccDB_info;
           _ccies::P64 = Hp - 336;
           P64[Hp - 288] = _ccies::P64;
           I64[Hp - 280] = stg_sel_2_upd_info;
           P64[Hp - 264] = _ccies::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           _ccigr::P64 = Hp - 304;
           P64[Hp - 240] = _ccigr::P64;
           I64[Hp - 232] = stg_sel_1_upd_info;
           P64[Hp - 216] = _ccigr::P64;
           I64[Hp - 208] = stg_sel_0_upd_info;
           P64[Hp - 192] = _ccigr::P64;
           I64[Hp - 184] = sat_sccDU_info;
           P64[Hp - 168] = _sccyd::P64;
           P64[Hp - 160] = _sccye::P64;
           I64[Hp - 152] = stg_sel_0_upd_info;
           P64[Hp - 136] = _ccies::P64;
           I64[Hp - 128] = GHC.Base.Just_con_info;
           P64[Hp - 120] = Hp - 152;
           I64[Hp - 112] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 104] = GHC.Base.Nothing_closure+1;
           P64[Hp - 96] = Hp - 126;
           P64[Hp - 88] = Hp - 184;
           P64[Hp - 80] = _sccyf::P64;
           P64[Hp - 72] = _sccyg::P64;
           P64[Hp - 64] = Hp - 208;
           P64[Hp - 56] = Hp - 232;
           _ccih0::P64 = Hp - 280;
           _ccih1::P64 = Hp - 256;
           _ccii7::P64 = Hp - 111;
           Hp = Hp - 56;
           R3 = _ccih0::P64;
           R2 = _ccih1::P64;
           R1 = _ccii7::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccii4: // global
           Hp = Hp - 344;
           P64[Sp + 16] = GHC.Types.True_closure+2;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = _sccyf::P64;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto uciio;
       ccii3: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = lvl50_rcccQ_closure+2;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto uciio;
       ccii2: // global
           I64[Hp - 336] = ds3_sccAX_info;
           P64[Hp - 320] = _sccyi::P64;
           I64[Hp - 312] = ds4_sccB1_info;
           P64[Hp - 296] = _sccym::P64;
           _cci9i::P64 = Hp - 336;
           P64[Hp - 288] = _cci9i::P64;
           I64[Hp - 280] = ds5_sccC8_info;
           _cci9v::P64 = Hp - 312;
           P64[Hp - 264] = _cci9v::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           P64[Hp - 240] = _cci9v::P64;
           I64[Hp - 232] = stg_sel_2_upd_info;
           _ccich::P64 = Hp - 280;
           P64[Hp - 216] = _ccich::P64;
           I64[Hp - 208] = stg_sel_1_upd_info;
           P64[Hp - 192] = _ccich::P64;
           I64[Hp - 184] = stg_sel_0_upd_info;
           P64[Hp - 168] = _ccich::P64;
           I64[Hp - 160] = sat_sccCF_info;
           P64[Hp - 144] = _sccyd::P64;
           P64[Hp - 136] = _sccye::P64;
           P64[Hp - 128] = _cci9i::P64;
           I64[Hp - 120] = stg_sel_0_upd_info;
           P64[Hp - 104] = _cci9v::P64;
           I64[Hp - 96] = sat_sccCq_info;
           P64[Hp - 80] = _cci9i::P64;
           I64[Hp - 72] = GHC.Base.Just_con_info;
           P64[Hp - 64] = Hp - 96;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 120;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = _sccyf::P64;
           P64[Hp - 16] = _sccyg::P64;
           P64[Hp - 8] = Hp - 184;
           P64[Hp] = Hp - 208;
           R3 = Hp - 256;
           R2 = Hp - 232;
           R1 = Hp - 55;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccihZ: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = _sccyf::P64;
           P64[Sp + 40] = GHC.Types.True_closure+2;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto uciio;
       ccihY: // global
           I64[Hp - 336] = sat_sccAW_info;
           P64[Hp - 320] = _sccyf::P64;
           _cci1q::P64 = Hp - 336;
           Hp = Hp - 320;
           P64[Sp + 16] = _sccyd::P64;
           P64[Sp + 24] = _sccye::P64;
           P64[Sp + 32] = _cci1q::P64;
           P64[Sp + 40] = _sccyg::P64;
           P64[Sp + 48] = _sccym::P64;
           P64[Sp + 56] = _sccyi::P64;
           Sp = Sp + 16;
           goto uciio;
       uciio: // global
           call _cci19() args: 0, res: 0, upd: 0;
       ccihX: // global
           if ((_sccyp::I64 + -48) > 9) goto ccihS; else goto ccihV;
       ccihS: // global
           I64[Hp - 336] = ds3_sccyu_info;
           P64[Hp - 320] = _sccyi::P64;
           P64[Hp - 312] = _sccyj::P64;
           I64[Hp - 304] = stg_sel_2_upd_info;
           _cci1D::P64 = Hp - 336;
           P64[Hp - 288] = _cci1D::P64;
           I64[Hp - 280] = stg_sel_1_upd_info;
           P64[Hp - 264] = _cci1D::P64;
           I64[Hp - 256] = stg_sel_0_upd_info;
           P64[Hp - 240] = _cci1D::P64;
           I64[Hp - 232] = sat_sccyD_info;
           P64[Hp - 216] = _sccyd::P64;
           P64[Hp - 208] = _sccye::P64;
           I64[Hp - 200] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 192] = GHC.Base.Nothing_closure+1;
           P64[Hp - 184] = GHC.Base.Nothing_closure+1;
           P64[Hp - 176] = Hp - 232;
           P64[Hp - 168] = _sccyf::P64;
           P64[Hp - 160] = _sccyg::P64;
           P64[Hp - 152] = Hp - 256;
           P64[Hp - 144] = Hp - 280;
           _cci25::P64 = Hp - 304;
           _ccihQ::P64 = Hp - 199;
           Hp = Hp - 144;
           R3 = _sccyi::P64;
           R2 = _cci25::P64;
           R1 = _ccihQ::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccihV: // global
           I64[Hp - 336] = ds3_sccyU_info;
           P64[Hp - 320] = _sccyj::P64;
           I64[Hp - 312] = ds4_sccz9_info;
           P64[Hp - 296] = _sccyi::P64;
           _cci2I::P64 = Hp - 336;
           P64[Hp - 288] = _cci2I::P64;
           I64[Hp - 280] = ds5_sccA0_info;
           _cci3O::P64 = Hp - 312;
           P64[Hp - 264] = _cci3O::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           P64[Hp - 240] = _cci3O::P64;
           I64[Hp - 232] = stg_sel_2_upd_info;
           _cci6w::P64 = Hp - 280;
           P64[Hp - 216] = _cci6w::P64;
           I64[Hp - 208] = stg_sel_1_upd_info;
           P64[Hp - 192] = _cci6w::P64;
           I64[Hp - 184] = stg_sel_0_upd_info;
           P64[Hp - 168] = _cci6w::P64;
           I64[Hp - 160] = sat_sccAx_info;
           P64[Hp - 144] = _sccyd::P64;
           P64[Hp - 136] = _sccye::P64;
           P64[Hp - 128] = _cci2I::P64;
           I64[Hp - 120] = stg_sel_0_upd_info;
           P64[Hp - 104] = _cci3O::P64;
           I64[Hp - 96] = sat_sccAi_info;
           P64[Hp - 80] = _cci2I::P64;
           I64[Hp - 72] = GHC.Base.Just_con_info;
           P64[Hp - 64] = Hp - 96;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 120;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = _sccyf::P64;
           P64[Hp - 16] = _sccyg::P64;
           P64[Hp - 8] = Hp - 184;
           P64[Hp] = Hp - 208;
           R3 = Hp - 256;
           R2 = Hp - 232;
           R1 = Hp - 55;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.780225218 UTC

[section ""data" . f_rcccW_closure" {
     f_rcccW_closure:
         const GHC.Types.C#_con_info;
         const 37;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.784508788 UTC

[section ""data" . Text.Printf.uprintfs_closure" {
     Text.Printf.uprintfs_closure:
         const Text.Printf.uprintfs_info;
         const 0;
 },
 sat_sccEt_entry() //  [R1]
         { info_tbl: [(ccirT,
                       label: sat_sccEt_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccirT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccirU; else goto ccirV;
       ccirU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccirV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccEL_entry() //  [R1]
         { info_tbl: [(ccisp,
                       label: sat_sccEL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccisp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccisq; else goto ccisr;
       ccisq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccisr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 16];
           R3 = P64[R1 + 32];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sccES_entry() //  [R1]
         { info_tbl: [(ccisK,
                       label: sat_sccES_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccisK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccisL; else goto ccisM;
       ccisL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccisM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uciu4_srtd" {
     uciu4_srtd:
         const SccKB_srt+448;
         const 70;
         const 9223372036854775809;
         const 48;
 },
 Text.Printf.uprintfs_entry() //  [R2, R3, R4]
         { info_tbl: [(ccisR,
                       label: Text.Printf.uprintfs_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccisR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccisS; else goto ccisT;
       ccisS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.uprintfs_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccisT: // global
           I64[Sp - 24] = block_ccirC_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uciu2; else goto ccirD;
       uciu2: // global
           call _ccirC(R1) args: 0, res: 0, upd: 0;
       ccirD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uciu5_srtd" {
     uciu5_srtd:
         const SccKB_srt+448;
         const 70;
         const 9223372036854775809;
         const 48;
 },
 _ccirC() //  [R1]
         { info_tbl: [(ccirC,
                       label: block_ccirC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccirC: // global
           if (R1 & 7 == 1) goto ccisO; else goto ccisP;
       ccisO: // global
           _sccEh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccisV_info;
           R1 = _sccEh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucitS; else goto ccisX;
       ucitS: // global
           call _ccisV(R1) args: 0, res: 0, upd: 0;
       ccisX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccisP: // global
           I64[Sp - 8] = block_ccirI_info;
           _sccEp::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccEp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucitT; else goto ccirJ;
       ucitT: // global
           call _ccirI(R1) args: 0, res: 0, upd: 0;
       ccirJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccisV() //  [R1]
         { info_tbl: [(ccisV,
                       label: block_ccisV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccisV: // global
           if (R1 & 7 == 1) goto ccit3; else goto ccit7;
       ccit3: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccit7: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccirI() //  [R1]
         { info_tbl: [(ccirI,
                       label: block_ccirI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccirI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccitb; else goto ccita;
       ccitb: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccita: // global
           _sccEp::P64 = P64[Sp + 8];
           if (I64[R1 + 7] == 37) goto ccitw; else goto ccite;
       ccitw: // global
           Hp = Hp - 64;
           I64[Sp] = block_cciss_info;
           R1 = _sccEp::P64;
           if (R1 & 7 != 0) goto ucitU; else goto ccist;
       ucitU: // global
           call _cciss(R1) args: 0, res: 0, upd: 0;
       ccist: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccite: // global
           I64[Hp - 56] = sat_sccEt_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sccEp::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cciss() //  [R1]
         { info_tbl: [(cciss,
                       label: block_cciss_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciss: // global
           if (R1 & 7 == 1) goto ucitO; else goto ccitC;
       ucitO: // global
           Sp = Sp + 8;
           call _sccEu() args: 0, res: 0, upd: 0;
       ccitC: // global
           I64[Sp - 8] = block_ccisy_info;
           _sccEO::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccEO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucitZ; else goto ccisz;
       ucitZ: // global
           call _ccisy(R1) args: 0, res: 0, upd: 0;
       ccisz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccisy() //  [R1]
         { info_tbl: [(ccisy,
                       label: block_ccisy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccisy: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccitF; else goto ccitE;
       ccitF: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccitE: // global
           if (I64[R1 + 7] == 37) goto ccitJ; else goto ccitH;
       ccitJ: // global
           I64[Hp - 56] = sat_sccES_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = f_rcccW_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccitH: // global
           Hp = Hp - 64;
           Sp = Sp + 16;
           call _sccEu() args: 0, res: 0, upd: 0;
     }
 },
 _sccEu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sccEu: // global
           I64[Sp - 8] = block_ccis2_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uciu3; else goto ccis3;
       uciu3: // global
           call _ccis2(R1) args: 0, res: 0, upd: 0;
       ccis3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccis2() //  [R1]
         { info_tbl: [(ccis2,
                       label: block_ccis2_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccis2: // global
           if (R1 & 7 == 1) goto ucitQ; else goto ccitl;
       ucitQ: // global
           Sp = Sp + 32;
           call _ccitq() args: 0, res: 0, upd: 0;
       ccitl: // global
           I64[Sp + 16] = block_ccis8_info;
           R6 = P64[Sp + 8];
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = GHC.Types.False_closure+1;
           R2 = GHC.Types.False_closure+1;
           P64[Sp + 8] = R1;
           Sp = Sp + 8;
           call $wgetSpecs_rcccV_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 16, res: 8, upd: 8;
     }
 },
 _ccis8() //  [R1, R2, R3]
         { info_tbl: [(ccis8,
                       label: block_ccis8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccis8: // global
           I64[Sp - 16] = block_ccisa_info;
           _sccEB::P64 = R1;
           R1 = R3;
           P64[Sp - 8] = R2;
           P64[Sp] = _sccEB::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucitW; else goto ccisb;
       ucitW: // global
           call _ccisa(R1) args: 0, res: 0, upd: 0;
       ccisb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccisa() //  [R1]
         { info_tbl: [(ccisa,
                       label: block_ccisa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccisa: // global
           if (R1 & 7 == 1) goto ucitR; else goto ccits;
       ucitR: // global
           Sp = Sp + 32;
           call _ccitq() args: 0, res: 0, upd: 0;
       ccits: // global
           I64[Sp - 8] = block_ccisg_info;
           _sccEH::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sccEH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucitX; else goto ccish;
       ucitX: // global
           call _ccisg(R1) args: 0, res: 0, upd: 0;
       ccish: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccitq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccitq: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccisg() //  [R1]
         { info_tbl: [(ccisg,
                       label: block_ccisg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccisg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccitv; else goto ccitu;
       ccitv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccitu: // global
           _sccEK::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sccEL_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 32;
           R2 = P64[Sp + 24];
           R1 = _sccEK::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.816834352 UTC

[section ""data" . Text.Printf.$fPrintfTypeIO_$cspr_closure" {
     Text.Printf.$fPrintfTypeIO_$cspr_closure:
         const Text.Printf.$fPrintfTypeIO_$cspr_info;
         const 0;
 },
 sat_sccEW_entry() //  [R1]
         { info_tbl: [(ccivE,
                       label: sat_sccEW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccivE: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccEX_entry() //  [R1]
         { info_tbl: [(ccivH,
                       label: sat_sccEX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccivH: // global
           _sccEX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccivI; else goto ccivJ;
       ccivJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccivL; else goto ccivK;
       ccivL: // global
           HpAlloc = 24;
           goto ccivI;
       ccivI: // global
           R1 = _sccEX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccivK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccEX::P64;
           _sccEU::P64 = P64[_sccEX::P64 + 16];
           _sccEV::P64 = P64[_sccEX::P64 + 24];
           I64[Hp - 16] = sat_sccEW_info;
           P64[Hp] = _sccEV::P64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _sccEU::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfTypeIO_$cspr_entry() //  [R2, R3, R4]
         { info_tbl: [(ccivM,
                       label: Text.Printf.$fPrintfTypeIO_$cspr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccivM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccivN; else goto ccivO;
       ccivN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfTypeIO_$cspr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccivO: // global
           I64[Sp - 24] = block_ccivu_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccivu() //  []
         { info_tbl: [(ccivu,
                       label: block_ccivu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccivu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccivR; else goto ccivQ;
       ccivR: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccivQ: // global
           I64[Hp - 24] = sat_sccEX_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           Sp = Sp + 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.826722085 UTC

[section ""data" . Text.Printf.$fPrintfTypeIO_closure" {
     Text.Printf.$fPrintfTypeIO_closure:
         const Text.Printf.$fPrintfTypeIO_info;
         const 0;
 },
 Text.Printf.$fPrintfTypeIO_entry() //  [R2, R3, R4]
         { info_tbl: [(cciwd,
                       label: Text.Printf.$fPrintfTypeIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciwd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfTypeIO_$cspr_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.830649582 UTC

[section ""data" . Text.Printf.$fPrintfType[]_$cspr_closure" {
     Text.Printf.$fPrintfType[]_$cspr_closure:
         const Text.Printf.$fPrintfType[]_$cspr_info;
         const 0;
 },
 sat_sccF2_entry() //  [R1]
         { info_tbl: [(cciws,
                       label: sat_sccF2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciws: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccF1_entry() //  [R1]
         { info_tbl: [(cciwD,
                       label: sat_sccF1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciwD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cciwE; else goto cciwF;
       cciwE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cciwF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.Printf.fromChar_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfType[]_$cspr_entry() //  [R2, R3, R4]
         { info_tbl: [(cciwG,
                       label: Text.Printf.$fPrintfType[]_$cspr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciwG: // global
           _sccF0::P64 = R4;
           _sccEZ::P64 = R3;
           _sccEY::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cciwH; else goto cciwI;
       cciwI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cciwK; else goto cciwJ;
       cciwK: // global
           HpAlloc = 24;
           goto cciwH;
       cciwH: // global
           R4 = _sccF0::P64;
           R3 = _sccEZ::P64;
           R2 = _sccEY::P64;
           R1 = Text.Printf.$fPrintfType[]_$cspr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cciwJ: // global
           I64[Hp - 16] = sat_sccF2_info;
           P64[Hp] = _sccF0::P64;
           I64[Sp - 16] = block_cciwv_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _sccEZ::P64;
           P64[Sp - 8] = _sccEY::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cciwv() //  [R1]
         { info_tbl: [(cciwv,
                       label: block_cciwv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciwv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cciwN; else goto cciwM;
       cciwN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cciwM: // global
           I64[Hp - 16] = sat_sccF1_info;
           P64[Hp] = P64[Sp + 8];
           R3 = R1;
           R2 = Hp - 16;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.840982379 UTC

[section ""data" . Text.Printf.$fPrintfType[]_closure" {
     Text.Printf.$fPrintfType[]_closure:
         const Text.Printf.$fPrintfType[]_info;
         const 0;
 },
 Text.Printf.$fPrintfType[]_entry() //  [R2, R3, R4]
         { info_tbl: [(ccix8,
                       label: Text.Printf.$fPrintfType[]_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccix8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfType[]_$cspr_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.844877627 UTC

[section ""data" . Text.Printf.$fHPrintfTypeIO_$chspr_closure" {
     Text.Printf.$fHPrintfTypeIO_$chspr_closure:
         const Text.Printf.$fHPrintfTypeIO_$chspr_info;
         const 0;
 },
 sat_sccF8_entry() //  [R1]
         { info_tbl: [(ccixt,
                       label: sat_sccF8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccixt: // global
           R2 = P64[R1 + 16];
           call GHC.List.reverse_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sccF9_entry() //  [R1]
         { info_tbl: [(ccixw,
                       label: sat_sccF9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccixw: // global
           _sccF9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccixx; else goto ccixy;
       ccixy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccixA; else goto ccixz;
       ccixA: // global
           HpAlloc = 24;
           goto ccixx;
       ccixx: // global
           R1 = _sccF9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccixz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sccF9::P64;
           _sccF6::P64 = P64[_sccF9::P64 + 16];
           _sccF7::P64 = P64[_sccF9::P64 + 24];
           I64[Hp - 16] = sat_sccF8_info;
           P64[Hp] = _sccF7::P64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _sccF6::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fHPrintfTypeIO_$chspr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccixB,
                       label: Text.Printf.$fHPrintfTypeIO_$chspr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccixB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccixC; else goto ccixD;
       ccixC: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fHPrintfTypeIO_$chspr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccixD: // global
           I64[Sp - 32] = block_ccixj_info;
           R2 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccixj() //  []
         { info_tbl: [(ccixj,
                       label: block_ccixj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccixj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccixG; else goto ccixF;
       ccixG: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccixF: // global
           I64[Hp - 24] = sat_sccF9_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.854624946 UTC

[section ""data" . Text.Printf.$fHPrintfTypeIO_closure" {
     Text.Printf.$fHPrintfTypeIO_closure:
         const Text.Printf.$fHPrintfTypeIO_info;
         const 0;
 },
 Text.Printf.$fHPrintfTypeIO_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cciy2,
                       label: Text.Printf.$fHPrintfTypeIO_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciy2: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fHPrintfTypeIO_$chspr_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.85811658 UTC

[section ""data" . Text.Printf.FormatParse_closure" {
     Text.Printf.FormatParse_closure:
         const Text.Printf.FormatParse_info;
 },
 Text.Printf.FormatParse_entry() //  [R2, R3, R4]
         { info_tbl: [(cciye,
                       label: Text.Printf.FormatParse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciye: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cciyi; else goto cciyh;
       cciyi: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.FormatParse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cciyh: // global
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.862373528 UTC

[section ""data" . Text.Printf.FieldFormat_closure" {
     Text.Printf.FieldFormat_closure:
         const Text.Printf.FieldFormat_info;
 },
 Text.Printf.FieldFormat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciyp: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.FieldFormat_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 24, res: 0, upd: 8;
     }
 },
 Text.Printf.FieldFormat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cciyu,
                       label: Text.Printf.FieldFormat_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciyu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cciyy; else goto cciyx;
       cciyy: // global
           HpAlloc = 64;
           R1 = Text.Printf.FieldFormat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cciyx: // global
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.867430507 UTC

[section ""data" . Text.Printf.SignPlus_closure" {
     Text.Printf.SignPlus_closure:
         const Text.Printf.SignPlus_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.869173699 UTC

[section ""data" . Text.Printf.SignSpace_closure" {
     Text.Printf.SignSpace_closure:
         const Text.Printf.SignSpace_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.870919089 UTC

[section ""data" . Text.Printf.LeftAdjust_closure" {
     Text.Printf.LeftAdjust_closure:
         const Text.Printf.LeftAdjust_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.87313613 UTC

[section ""data" . Text.Printf.ZeroPad_closure" {
     Text.Printf.ZeroPad_closure:
         const Text.Printf.ZeroPad_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.875408393 UTC

[section ""data" . Text.Printf.C:IsChar_closure" {
     Text.Printf.C:IsChar_closure:
         const Text.Printf.C:IsChar_info;
 },
 Text.Printf.C:IsChar_entry() //  [R2, R3]
         { info_tbl: [(cciyR,
                       label: Text.Printf.C:IsChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciyR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cciyV; else goto cciyU;
       cciyV: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.C:IsChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cciyU: // global
           I64[Hp - 16] = Text.Printf.C:IsChar_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.8793902 UTC

[section ""data" . Text.Printf.C:PrintfArg_closure" {
     Text.Printf.C:PrintfArg_closure:
         const Text.Printf.C:PrintfArg_info;
 },
 Text.Printf.C:PrintfArg_entry() //  [R2, R3]
         { info_tbl: [(cciz6,
                       label: Text.Printf.C:PrintfArg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciz6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cciza; else goto cciz9;
       cciza: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.C:PrintfArg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cciz9: // global
           I64[Hp - 16] = Text.Printf.C:PrintfArg_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.883026885 UTC

[Text.Printf.FormatParse_con_entry() //  [R1]
         { info_tbl: [(ccizg,
                       label: Text.Printf.FormatParse_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,70,111,114,109,97,116,80,97,114,115,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccizg: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.886286278 UTC

[Text.Printf.FieldFormat_con_entry() //  [R1]
         { info_tbl: [(ccizm,
                       label: Text.Printf.FieldFormat_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,70,105,101,108,100,70,111,114,109,97,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccizm: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.889819374 UTC

[section ""relreadonly" . Text.Printf.FormatSign_closure_tbl" {
     Text.Printf.FormatSign_closure_tbl:
         const Text.Printf.SignPlus_closure+1;
         const Text.Printf.SignSpace_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.891593777 UTC

[Text.Printf.SignPlus_con_entry() //  [R1]
         { info_tbl: [(ccizt,
                       label: Text.Printf.SignPlus_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,83,105,103,110,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccizt: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.894831723 UTC

[Text.Printf.SignSpace_con_entry() //  [R1]
         { info_tbl: [(ccizz,
                       label: Text.Printf.SignSpace_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,83,105,103,110,83,112,97,99,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccizz: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.898037559 UTC

[section ""relreadonly" . Text.Printf.FormatAdjustment_closure_tbl" {
     Text.Printf.FormatAdjustment_closure_tbl:
         const Text.Printf.LeftAdjust_closure+1;
         const Text.Printf.ZeroPad_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.899802766 UTC

[Text.Printf.LeftAdjust_con_entry() //  [R1]
         { info_tbl: [(ccizG,
                       label: Text.Printf.LeftAdjust_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,76,101,102,116,65,100,106,117,115,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccizG: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.903494631 UTC

[Text.Printf.ZeroPad_con_entry() //  [R1]
         { info_tbl: [(ccizM,
                       label: Text.Printf.ZeroPad_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,90,101,114,111,80,97,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccizM: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.907101653 UTC

[Text.Printf.C:IsChar_con_entry() //  [R1]
         { info_tbl: [(ccizS,
                       label: Text.Printf.C:IsChar_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,67,58,73,115,67,104,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccizS: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.910310466 UTC

[Text.Printf.C:PrintfArg_con_entry() //  [R1]
         { info_tbl: [(ccizY,
                       label: Text.Printf.C:PrintfArg_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,67,58,80,114,105,110,116,102,65,114,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccizY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:06.913516501 UTC

[section ""relreadonly" . SccKB_srt" {
     SccKB_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Printf.perror_closure;
         const GHC.Show.$wshowLitChar_closure;
         const GHC.Show.$fShowChar1_closure;
         const Text.Printf.$werrorBadFormat_closure;
         const Text.Printf.errorBadFormat_closure;
         const Text.Printf.errorShortFormat_closure;
         const Text.Printf.$dmparseFormat_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.Unicode.toUpper_closure;
         const GHC.Float.$w$sformatRealFloatAlt_closure;
         const Text.Printf.$w$sdfmt_closure;
         const Text.Printf.$fPrintfArgDouble7_closure;
         const Text.Printf.$fPrintfArgDouble8_closure;
         const GHC.Float.$w$sformatRealFloatAlt1_closure;
         const Text.Printf.$w$sdfmt1_closure;
         const Text.Printf.$fPrintfArgFloat1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Text.Printf.$wdfmt_closure;
         const Text.Printf.formatRealFloat1_closure;
         const sat_scchQ_closure;
         const sat_scchS_closure;
         const sat_scchW_closure;
         const sat_scci2_closure;
         const Text.Printf.intModifierMap_closure;
         const Text.Printf.$wfixupMods_closure;
         const Text.Printf.$fPrintfArgInt2_closure;
         const Text.Printf.fixupMods_closure;
         const Text.Printf.$wparseIntFormat_closure;
         const GHC.Err.undefined_closure;
         const lvl18_rccch_closure;
         const Control.Exception.Base.patError_closure;
         const sat_sccjr_closure;
         const GHC.Show.intToDigit_closure;
         const GHC.Show.$fShowInteger_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Numeric.showIntAtBase_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const Text.Printf.formatChar2_closure;
         const lvl21_rccck_closure;
         const lvl20_rcccj_closure;
         const $wfmtu_rcccl_closure;
         const Text.Printf.errorBadArgument_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const $wfmti_rcccm_closure;
         const Text.Printf.$wadjustSigned_closure;
         const Text.Printf.$fPrintfArgDouble1_closure;
         const Text.Printf.$fPrintfArgDouble3_closure;
         const Text.Printf.$w$sformatRealFloat_closure;
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure;
         const Text.Printf.$w$sformatRealFloat1_closure;
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure;
         const Text.Printf.$wformatRealFloat_closure;
         const Text.Printf.formatRealFloat_closure;
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_closure;
         const Text.Printf.errorShortFormat_closure;
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_closure;
         const Text.Printf.$w$sformatString_closure;
         const Text.Printf.$werrorBadFormat_closure;
         const Text.Printf.$wformatString_closure;
         const Text.Printf.formatString_closure;
         const lvl22_rcccn_closure;
         const Text.Printf.$fPrintfArg[]_closure;
         const sat_sccoX_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const sat_sccp0_closure;
         const sat_sccp2_closure;
         const sat_sccp4_closure;
         const GHC.Unicode.toUpper_closure;
         const lvl24_rcccp_closure;
         const lvl38_rcccD_closure;
         const lvl39_rcccE_closure;
         const GHC.Char.$wlvl_closure;
         const lvl32_rcccx_closure;
         const lvl40_rcccF_closure;
         const $wfmtu_rcccl_closure;
         const Text.Printf.formatChar2_closure;
         const lvl35_rcccA_closure;
         const lvl41_rcccG_closure;
         const Text.Printf.$wformatIntegral_closure;
         const lvl30_rcccv_closure;
         const lvl31_rcccw_closure;
         const Text.Printf.formatIntegral_closure;
         const Text.Printf.$wformatChar_closure;
         const Text.Printf.formatChar1_closure;
         const Text.Printf.formatChar_closure;
         const Text.Printf.$fPrintfArgInt2_closure;
         const Text.Printf.$w$sformatInt3_closure;
         const Text.Printf.$fPrintfArgWord64_$sformatInt_closure;
         const Text.Printf.$w$sformatInt2_closure;
         const Text.Printf.$fPrintfArgWord32_$sformatInt_closure;
         const Text.Printf.$w$sformatInt1_closure;
         const Text.Printf.$fPrintfArgWord16_$sformatInt_closure;
         const Text.Printf.$w$sformatInt4_closure;
         const Text.Printf.$fPrintfArgWord8_$sformatInt_closure;
         const Text.Printf.$w$sformatInt_closure;
         const Text.Printf.$fPrintfArgWord_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt1_closure;
         const Text.Printf.$fPrintfArgInt64_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt4_closure;
         const Text.Printf.$fPrintfArgInt32_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt3_closure;
         const Text.Printf.$fPrintfArgInt16_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt5_closure;
         const Text.Printf.$fPrintfArgInt8_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt_$sformatInt_closure;
         const Text.Printf.$wformatInt_closure;
         const Text.Printf.formatInt_closure;
         const Text.Printf.formatInteger_closure;
         const Text.Printf.$fPrintfArgNatural_$cformatArg_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Text.Read.readEither5_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Read.readEither2_closure;
         const lvl42_rcccH_closure;
         const lvl44_rcccJ_closure;
         const lvl45_rcccK_closure;
         const Text.Printf.errorMissingArgument_closure;
         const $wgetStar_rcccL_closure;
         const lvl49_rcccP_closure;
         const lvl52_rcccS_closure;
         const lvl53_rcccT_closure;
         const $wgetSpecs_rcccV_closure;
         const Text.Printf.uprintfs_closure;
         const Text.Printf.errorShortFormat_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const Text.Printf.$fPrintfTypeIO_$cspr_closure;
         const Text.Printf.$fPrintfType[]_$cspr_closure;
         const Text.Printf.$fHPrintfTypeIO_$chspr_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.707975662 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:12.709534055 UTC

[section ""data" . Text.Printf.toChar_closure" {
     Text.Printf.toChar_closure:
         const Text.Printf.toChar_info;
 },
 Text.Printf.toChar_entry() //  [R2]
         { info_tbl: [(ccj2o,
                       label: Text.Printf.toChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj2o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj2p; else goto ccj2q;
       ccj2p: // global
           R2 = R2;
           R1 = Text.Printf.toChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj2q: // global
           I64[Sp - 8] = block_ccj2l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj2u; else goto ccj2m;
       ucj2u: // global
           call _ccj2l(R1) args: 0, res: 0, upd: 0;
       ccj2m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj2l() //  [R1]
         { info_tbl: [(ccj2l,
                       label: block_ccj2l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj2l: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.71525241 UTC

[section ""data" . Text.Printf.fromChar_closure" {
     Text.Printf.fromChar_closure:
         const Text.Printf.fromChar_info;
 },
 Text.Printf.fromChar_entry() //  [R2]
         { info_tbl: [(ccj2M,
                       label: Text.Printf.fromChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj2M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj2N; else goto ccj2O;
       ccj2N: // global
           R2 = R2;
           R1 = Text.Printf.fromChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj2O: // global
           I64[Sp - 8] = block_ccj2J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj2S; else goto ccj2K;
       ucj2S: // global
           call _ccj2J(R1) args: 0, res: 0, upd: 0;
       ccj2K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj2J() //  [R1]
         { info_tbl: [(ccj2J,
                       label: block_ccj2J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj2J: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.720767371 UTC

[section ""data" . Text.Printf.formatArg_closure" {
     Text.Printf.formatArg_closure:
         const Text.Printf.formatArg_info;
 },
 Text.Printf.formatArg_entry() //  [R2]
         { info_tbl: [(ccj3a,
                       label: Text.Printf.formatArg_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj3a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj3b; else goto ccj3c;
       ccj3b: // global
           R2 = R2;
           R1 = Text.Printf.formatArg_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj3c: // global
           I64[Sp - 8] = block_ccj37_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj3g; else goto ccj38;
       ucj3g: // global
           call _ccj37(R1) args: 0, res: 0, upd: 0;
       ccj38: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj37() //  [R1]
         { info_tbl: [(ccj37,
                       label: block_ccj37_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj37: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.726335206 UTC

[section ""data" . Text.Printf.parseFormat_closure" {
     Text.Printf.parseFormat_closure:
         const Text.Printf.parseFormat_info;
 },
 Text.Printf.parseFormat_entry() //  [R2]
         { info_tbl: [(ccj3y,
                       label: Text.Printf.parseFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj3y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj3z; else goto ccj3A;
       ccj3z: // global
           R2 = R2;
           R1 = Text.Printf.parseFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj3A: // global
           I64[Sp - 8] = block_ccj3v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj3E; else goto ccj3w;
       ucj3E: // global
           call _ccj3v(R1) args: 0, res: 0, upd: 0;
       ccj3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj3v() //  [R1]
         { info_tbl: [(ccj3v,
                       label: block_ccj3v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj3v: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.732234719 UTC

[section ""data" . Text.Printf.hspr_closure" {
     Text.Printf.hspr_closure:
         const Text.Printf.hspr_info;
 },
 Text.Printf.hspr_entry() //  [R2]
         { info_tbl: [(ccj3T,
                       label: Text.Printf.hspr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj3T: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.739044125 UTC

[section ""data" . Text.Printf.spr_closure" {
     Text.Printf.spr_closure:
         const Text.Printf.spr_info;
 },
 Text.Printf.spr_entry() //  [R2]
         { info_tbl: [(ccj44,
                       label: Text.Printf.spr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj44: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.742909689 UTC

[section ""data" . Text.Printf.$fIsCharChar_$cfromChar_closure" {
     Text.Printf.$fIsCharChar_$cfromChar_closure:
         const Text.Printf.$fIsCharChar_$cfromChar_info;
 },
 Text.Printf.$fIsCharChar_$cfromChar_entry() //  [R2]
         { info_tbl: [(ccj4f,
                       label: Text.Printf.$fIsCharChar_$cfromChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj4f: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.746291109 UTC

[section ""data" . Text.Printf.$fIsCharChar_closure" {
     Text.Printf.$fIsCharChar_closure:
         const Text.Printf.C:IsChar_con_info;
         const Text.Printf.$fIsCharChar_$cfromChar_closure+1;
         const Text.Printf.$fIsCharChar_$cfromChar_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.7488123 UTC

[section ""data" . Text.Printf.$fHPrintfType(->)_$chspr_closure" {
     Text.Printf.$fHPrintfType(->)_$chspr_closure:
         const Text.Printf.$fHPrintfType(->)_$chspr_info;
 },
 sat_sciAv_entry() //  [R1]
         { info_tbl: [(ccj4x,
                       label: sat_sciAv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj4x: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccj4y; else goto ccj4z;
       ccj4y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccj4z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.formatArg_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sciAu_entry() //  [R1]
         { info_tbl: [(ccj4E,
                       label: sat_sciAu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj4E: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccj4F; else goto ccj4G;
       ccj4F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccj4G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.parseFormat_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Text.Printf.$fHPrintfType(->)_$chspr_entry() //  [R2, R3, R4, R5,
                                                   R6]
         { info_tbl: [(ccj4J,
                       label: Text.Printf.$fHPrintfType(->)_$chspr_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj4J: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccj4N; else goto ccj4M;
       ccj4N: // global
           HpAlloc = 112;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fHPrintfType(->)_$chspr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ccj4M: // global
           I64[Hp - 104] = sat_sciAv_info;
           P64[Hp - 88] = R2;
           _sciAt::P64 = P64[Sp];
           P64[Hp - 80] = _sciAt::P64;
           I64[Hp - 72] = sat_sciAu_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = _sciAt::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = R6;
           _sciAq::P64 = R4;
           R4 = Hp - 14;
           _sciAp::P64 = R3;
           R3 = R5;
           R2 = _sciAq::P64;
           R1 = _sciAp::P64;
           Sp = Sp + 8;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.757686092 UTC

[section ""data" . Text.Printf.$fHPrintfType(->)_closure" {
     Text.Printf.$fHPrintfType(->)_closure:
         const Text.Printf.$fHPrintfType(->)_info;
 },
 Text.Printf.$fHPrintfType(->)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccj5h,
                       label: Text.Printf.$fHPrintfType(->)_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj5h: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fHPrintfType(->)_$chspr_entry(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.761686541 UTC

[section ""data" . Text.Printf.$fPrintfType(->)_$cspr_closure" {
     Text.Printf.$fPrintfType(->)_$cspr_closure:
         const Text.Printf.$fPrintfType(->)_$cspr_info;
 },
 sat_sciAE_entry() //  [R1]
         { info_tbl: [(ccj5w,
                       label: sat_sciAE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj5w: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccj5x; else goto ccj5y;
       ccj5x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccj5y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.formatArg_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sciAD_entry() //  [R1]
         { info_tbl: [(ccj5D,
                       label: sat_sciAD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj5D: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccj5E; else goto ccj5F;
       ccj5E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccj5F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.parseFormat_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfType(->)_$cspr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccj5I,
                       label: Text.Printf.$fPrintfType(->)_$cspr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj5I: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccj5M; else goto ccj5L;
       ccj5M: // global
           HpAlloc = 112;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfType(->)_$cspr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccj5L: // global
           I64[Hp - 104] = sat_sciAE_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R6;
           I64[Hp - 72] = sat_sciAD_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R6;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 72;
           P64[Hp - 24] = Hp - 104;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = R5;
           _sciAz::P64 = R3;
           R3 = Hp - 14;
           R2 = R4;
           R1 = _sciAz::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.771077815 UTC

[section ""data" . Text.Printf.$fPrintfType(->)_closure" {
     Text.Printf.$fPrintfType(->)_closure:
         const Text.Printf.$fPrintfType(->)_info;
 },
 Text.Printf.$fPrintfType(->)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccj6g,
                       label: Text.Printf.$fPrintfType(->)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj6g: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfType(->)_$cspr_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.776978982 UTC

[section ""data" . Text.Printf.fmtChar_closure" {
     Text.Printf.fmtChar_closure:
         const Text.Printf.fmtChar_info;
 },
 Text.Printf.fmtChar_entry() //  [R2]
         { info_tbl: [(ccj6u,
                       label: Text.Printf.fmtChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj6u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj6v; else goto ccj6w;
       ccj6v: // global
           R2 = R2;
           R1 = Text.Printf.fmtChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj6w: // global
           I64[Sp - 8] = block_ccj6r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj6A; else goto ccj6s;
       ucj6A: // global
           call _ccj6r(R1) args: 0, res: 0, upd: 0;
       ccj6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj6r() //  [R1]
         { info_tbl: [(ccj6r,
                       label: block_ccj6r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj6r: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.785671264 UTC

[section ""data" . Text.Printf.fmtModifiers_closure" {
     Text.Printf.fmtModifiers_closure:
         const Text.Printf.fmtModifiers_info;
 },
 Text.Printf.fmtModifiers_entry() //  [R2]
         { info_tbl: [(ccj6U,
                       label: Text.Printf.fmtModifiers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj6U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj6V; else goto ccj6W;
       ccj6V: // global
           R2 = R2;
           R1 = Text.Printf.fmtModifiers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj6W: // global
           I64[Sp - 8] = block_ccj6R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj70; else goto ccj6S;
       ucj70: // global
           call _ccj6R(R1) args: 0, res: 0, upd: 0;
       ccj6S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj6R() //  [R1]
         { info_tbl: [(ccj6R,
                       label: block_ccj6R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj6R: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.7940185 UTC

[section ""data" . Text.Printf.fmtAlternate_closure" {
     Text.Printf.fmtAlternate_closure:
         const Text.Printf.fmtAlternate_info;
 },
 Text.Printf.fmtAlternate_entry() //  [R2]
         { info_tbl: [(ccj7k,
                       label: Text.Printf.fmtAlternate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj7k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj7l; else goto ccj7m;
       ccj7l: // global
           R2 = R2;
           R1 = Text.Printf.fmtAlternate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj7m: // global
           I64[Sp - 8] = block_ccj7h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj7q; else goto ccj7i;
       ucj7q: // global
           call _ccj7h(R1) args: 0, res: 0, upd: 0;
       ccj7i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj7h() //  [R1]
         { info_tbl: [(ccj7h,
                       label: block_ccj7h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj7h: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.802653166 UTC

[section ""data" . Text.Printf.fmtSign_closure" {
     Text.Printf.fmtSign_closure:
         const Text.Printf.fmtSign_info;
 },
 Text.Printf.fmtSign_entry() //  [R2]
         { info_tbl: [(ccj7K,
                       label: Text.Printf.fmtSign_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj7K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj7L; else goto ccj7M;
       ccj7L: // global
           R2 = R2;
           R1 = Text.Printf.fmtSign_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj7M: // global
           I64[Sp - 8] = block_ccj7H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj7Q; else goto ccj7I;
       ucj7Q: // global
           call _ccj7H(R1) args: 0, res: 0, upd: 0;
       ccj7I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj7H() //  [R1]
         { info_tbl: [(ccj7H,
                       label: block_ccj7H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj7H: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.810898648 UTC

[section ""data" . Text.Printf.fmtAdjust_closure" {
     Text.Printf.fmtAdjust_closure:
         const Text.Printf.fmtAdjust_info;
 },
 Text.Printf.fmtAdjust_entry() //  [R2]
         { info_tbl: [(ccj8a,
                       label: Text.Printf.fmtAdjust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj8a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj8b; else goto ccj8c;
       ccj8b: // global
           R2 = R2;
           R1 = Text.Printf.fmtAdjust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj8c: // global
           I64[Sp - 8] = block_ccj87_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj8g; else goto ccj88;
       ucj8g: // global
           call _ccj87(R1) args: 0, res: 0, upd: 0;
       ccj88: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj87() //  [R1]
         { info_tbl: [(ccj87,
                       label: block_ccj87_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj87: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.819814191 UTC

[section ""data" . Text.Printf.fmtPrecision_closure" {
     Text.Printf.fmtPrecision_closure:
         const Text.Printf.fmtPrecision_info;
 },
 Text.Printf.fmtPrecision_entry() //  [R2]
         { info_tbl: [(ccj8A,
                       label: Text.Printf.fmtPrecision_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj8A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj8B; else goto ccj8C;
       ccj8B: // global
           R2 = R2;
           R1 = Text.Printf.fmtPrecision_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj8C: // global
           I64[Sp - 8] = block_ccj8x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj8G; else goto ccj8y;
       ucj8G: // global
           call _ccj8x(R1) args: 0, res: 0, upd: 0;
       ccj8y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj8x() //  [R1]
         { info_tbl: [(ccj8x,
                       label: block_ccj8x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj8x: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.829387874 UTC

[section ""data" . Text.Printf.fmtWidth_closure" {
     Text.Printf.fmtWidth_closure:
         const Text.Printf.fmtWidth_info;
 },
 Text.Printf.fmtWidth_entry() //  [R2]
         { info_tbl: [(ccj90,
                       label: Text.Printf.fmtWidth_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj90: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj91; else goto ccj92;
       ccj91: // global
           R2 = R2;
           R1 = Text.Printf.fmtWidth_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj92: // global
           I64[Sp - 8] = block_ccj8X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj96; else goto ccj8Y;
       ucj96: // global
           call _ccj8X(R1) args: 0, res: 0, upd: 0;
       ccj8Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj8X() //  [R1]
         { info_tbl: [(ccj8X,
                       label: block_ccj8X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj8X: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.838170388 UTC

[section ""data" . Text.Printf.fpRest_closure" {
     Text.Printf.fpRest_closure:
         const Text.Printf.fpRest_info;
 },
 Text.Printf.fpRest_entry() //  [R2]
         { info_tbl: [(ccj9q,
                       label: Text.Printf.fpRest_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj9q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj9r; else goto ccj9s;
       ccj9r: // global
           R2 = R2;
           R1 = Text.Printf.fpRest_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj9s: // global
           I64[Sp - 8] = block_ccj9n_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj9w; else goto ccj9o;
       ucj9w: // global
           call _ccj9n(R1) args: 0, res: 0, upd: 0;
       ccj9o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj9n() //  [R1]
         { info_tbl: [(ccj9n,
                       label: block_ccj9n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj9n: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.846197591 UTC

[section ""data" . Text.Printf.fpChar_closure" {
     Text.Printf.fpChar_closure:
         const Text.Printf.fpChar_info;
 },
 Text.Printf.fpChar_entry() //  [R2]
         { info_tbl: [(ccj9Q,
                       label: Text.Printf.fpChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj9Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccj9R; else goto ccj9S;
       ccj9R: // global
           R2 = R2;
           R1 = Text.Printf.fpChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccj9S: // global
           I64[Sp - 8] = block_ccj9N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucj9W; else goto ccj9O;
       ucj9W: // global
           call _ccj9N(R1) args: 0, res: 0, upd: 0;
       ccj9O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccj9N() //  [R1]
         { info_tbl: [(ccj9N,
                       label: block_ccj9N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj9N: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.852989276 UTC

[section ""data" . Text.Printf.fpModifiers_closure" {
     Text.Printf.fpModifiers_closure:
         const Text.Printf.fpModifiers_info;
 },
 Text.Printf.fpModifiers_entry() //  [R2]
         { info_tbl: [(ccjag,
                       label: Text.Printf.fpModifiers_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjag: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccjah; else goto ccjai;
       ccjah: // global
           R2 = R2;
           R1 = Text.Printf.fpModifiers_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccjai: // global
           I64[Sp - 8] = block_ccjad_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucjam; else goto ccjae;
       ucjam: // global
           call _ccjad(R1) args: 0, res: 0, upd: 0;
       ccjae: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjad() //  [R1]
         { info_tbl: [(ccjad,
                       label: block_ccjad_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjad: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.858779724 UTC

[section ""data" . Text.Printf.printf_closure" {
     Text.Printf.printf_closure:
         const Text.Printf.printf_info;
 },
 Text.Printf.printf_entry() //  [R2, R3]
         { info_tbl: [(ccjaD,
                       label: Text.Printf.printf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjaD: // global
           _sciBY::P64 = R3;
           R3 = GHC.Types.[]_closure+1;
           _sciBX::P64 = R2;
           R2 = _sciBY::P64;
           R1 = _sciBX::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.862561247 UTC

[section ""data" . Text.Printf.hPrintf_closure" {
     Text.Printf.hPrintf_closure:
         const Text.Printf.hPrintf_info;
 },
 Text.Printf.hPrintf_entry() //  [R2, R3, R4]
         { info_tbl: [(ccjaP,
                       label: Text.Printf.hPrintf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjaP: // global
           _sciC1::P64 = R4;
           R4 = GHC.Types.[]_closure+1;
           _sciC0::P64 = R3;
           R3 = _sciC1::P64;
           _sciBZ::P64 = R2;
           R2 = _sciC0::P64;
           R1 = _sciBZ::P64;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.866982416 UTC

[section ""data" . Text.Printf.vFmt_closure" {
     Text.Printf.vFmt_closure:
         const Text.Printf.vFmt_info;
 },
 Text.Printf.vFmt_entry() //  [R2, R3]
         { info_tbl: [(ccjb4,
                       label: Text.Printf.vFmt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjb4: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccjb8; else goto ccjb9;
       ccjb8: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.vFmt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccjb9: // global
           I64[Sp - 16] = block_ccjb1_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjbq; else goto ccjb2;
       ucjbq: // global
           call _ccjb1(R1) args: 0, res: 0, upd: 0;
       ccjb2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjb1() //  [R1]
         { info_tbl: [(ccjb1,
                       label: block_ccjb1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjb1: // global
           I64[Sp - 56] = block_ccjb7_info;
           _sciC4::P64 = R1;
           _sciC5::P64 = P64[R1 + 7];
           _sciC6::P64 = P64[R1 + 15];
           _sciC7::P64 = P64[R1 + 23];
           _sciC8::P64 = P64[R1 + 31];
           _sciC9::P64 = P64[R1 + 39];
           _sciCa::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 48] = _sciC5::P64;
           P64[Sp - 40] = _sciC6::P64;
           P64[Sp - 32] = _sciC7::P64;
           P64[Sp - 24] = _sciC8::P64;
           P64[Sp - 16] = _sciC9::P64;
           P64[Sp - 8] = _sciCa::P64;
           P64[Sp] = _sciC4::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ucjbp; else goto ccjbb;
       ucjbp: // global
           call _ccjb7(R1) args: 0, res: 0, upd: 0;
       ccjbb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjb7() //  [R1]
         { info_tbl: [(ccjb7,
                       label: block_ccjb7_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjb7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccjbh; else goto ccjbg;
       ccjbh: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjbg: // global
           if (I64[R1 + 7] == 118) goto ccjbo; else goto ccjbk;
       ccjbo: // global
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 64];
           R1 = Hp - 55;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccjbk: // global
           Hp = Hp - 64;
           R1 = P64[Sp + 56] & (-8);
           Sp = Sp + 72;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.87663419 UTC

[section ""cstring" . lvl_rccbg_bytes" {
     lvl_rccbg_bytes:
         I8[] [112,114,105,110,116,102,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.878727957 UTC

[section ""data" . Text.Printf.perror_closure" {
     Text.Printf.perror_closure:
         const Text.Printf.perror_info;
         const 0;
 },
 Text.Printf.perror_entry() //  [R2]
         { info_tbl: [(ccjbY,
                       label: Text.Printf.perror_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjbY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccjbZ; else goto ccjc0;
       ccjbZ: // global
           R2 = R2;
           R1 = Text.Printf.perror_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccjc0: // global
           I64[Sp - 8] = block_ccjbW_info;
           R3 = R2;
           R2 = lvl_rccbg_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjbW() //  [R1]
         { info_tbl: [(ccjbW,
                       label: block_ccjbW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjbW: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.884151906 UTC

[section ""data" . lvl1_rccbh_closure" {
     lvl1_rccbh_closure:
         const :_con_info;
         const GHC.Show.$fShowChar3_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.886031125 UTC

[section ""cstring" . lvl2_rccbi_bytes" {
     lvl2_rccbi_bytes:
         I8[] [98,97,100,32,102,111,114,109,97,116,116,105,110,103,32,99,104,97,114,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.888572946 UTC

[section ""data" . Text.Printf.$werrorBadFormat_closure" {
     Text.Printf.$werrorBadFormat_closure:
         const Text.Printf.$werrorBadFormat_info;
         const 0;
 },
 sat_sciCj_entry() //  [R1]
         { info_tbl: [(ccjcy,
                       label: sat_sciCj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjcy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjcz; else goto ccjcA;
       ccjcz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjcA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = lvl1_rccbh_closure+2;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$wshowLitChar_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciCk_entry() //  [R1]
         { info_tbl: [(ccjcE,
                       label: sat_sciCk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjcE: // global
           _sciCk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccjcF; else goto ccjcG;
       ccjcG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccjcI; else goto ccjcH;
       ccjcI: // global
           HpAlloc = 48;
           goto ccjcF;
       ccjcF: // global
           R1 = _sciCk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjcH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sciCk::P64;
           _sciCi::I64 = I64[_sciCk::P64 + 16];
           if (_sciCi::I64 != 39) goto ccjcC; else goto ccjcD;
       ccjcC: // global
           I64[Hp - 40] = sat_sciCj_info;
           I64[Hp - 24] = _sciCi::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShowChar3_closure;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccjcD: // global
           Hp = Hp - 48;
           R1 = GHC.Show.$fShowChar1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciCl_entry() //  [R1]
         { info_tbl: [(ccjcK,
                       label: sat_sciCl_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjcK: // global
           _sciCl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccjcL; else goto ccjcM;
       ccjcM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccjcO; else goto ccjcN;
       ccjcO: // global
           HpAlloc = 24;
           goto ccjcL;
       ccjcL: // global
           R1 = _sciCl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjcN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sciCl::P64;
           _sciCh::I64 = I64[_sciCl::P64 + 16];
           I64[Hp - 16] = sat_sciCk_info;
           I64[Hp] = _sciCh::I64;
           R3 = Hp - 16;
           R2 = lvl2_rccbi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$werrorBadFormat_entry() //  [R2]
         { info_tbl: [(ccjcR,
                       label: Text.Printf.$werrorBadFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjcR: // global
           _sciCh::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccjcS; else goto ccjcT;
       ccjcT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccjcV; else goto ccjcU;
       ccjcV: // global
           HpAlloc = 24;
           goto ccjcS;
       ccjcS: // global
           R2 = _sciCh::I64;
           R1 = Text.Printf.$werrorBadFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccjcU: // global
           I64[Hp - 16] = sat_sciCl_info;
           I64[Hp] = _sciCh::I64;
           I64[Sp - 8] = block_ccjcP_info;
           R3 = Hp - 16;
           R2 = lvl_rccbg_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjcP() //  [R1]
         { info_tbl: [(ccjcP,
                       label: block_ccjcP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjcP: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.901287016 UTC

[section ""data" . Text.Printf.errorBadFormat_closure" {
     Text.Printf.errorBadFormat_closure:
         const Text.Printf.errorBadFormat_info;
         const 0;
 },
 Text.Printf.errorBadFormat_entry() //  [R2]
         { info_tbl: [(ccjdC,
                       label: Text.Printf.errorBadFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjdC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccjdD; else goto ccjdE;
       ccjdD: // global
           R2 = R2;
           R1 = Text.Printf.errorBadFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccjdE: // global
           I64[Sp - 8] = block_ccjdz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucjdI; else goto ccjdA;
       ucjdI: // global
           call _ccjdz(R1) args: 0, res: 0, upd: 0;
       ccjdA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjdz() //  [R1]
         { info_tbl: [(ccjdz,
                       label: block_ccjdz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjdz: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.906957161 UTC

[section ""cstring" . lvl3_rccbj_bytes" {
     lvl3_rccbj_bytes:
         I8[] [112,114,105,110,116,102,58,32,102,111,114,109,97,116,116,105,110,103,32,115,116,114,105,110,103,32,101,110,100,101,100,32,112,114,101,109,97,116,117,114,101,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.910086847 UTC

[section ""data" . Text.Printf.errorShortFormat_closure" {
     Text.Printf.errorShortFormat_closure:
         const Text.Printf.errorShortFormat_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorShortFormat_entry() //  [R1]
         { info_tbl: [(ccje2,
                       label: Text.Printf.errorShortFormat_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccje2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccje3; else goto ccje4;
       ccje3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccje4: // global
           (_ccjdX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjdX::I64 == 0) goto ccjdZ; else goto ccjdY;
       ccjdZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjdY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjdX::I64;
           I64[Sp - 24] = block_ccje0_info;
           R2 = lvl3_rccbj_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccje0() //  [R1]
         { info_tbl: [(ccje0,
                       label: block_ccje0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccje0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.916413943 UTC

[section ""data" . Text.Printf.$dmparseFormat_closure" {
     Text.Printf.$dmparseFormat_closure:
         const Text.Printf.$dmparseFormat_info;
         const 0;
 },
 Text.Printf.$dmparseFormat_entry() //  [R2, R3, R4]
         { info_tbl: [(ccjev,
                       label: Text.Printf.$dmparseFormat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjev: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccjew; else goto ccjex;
       ccjew: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$dmparseFormat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccjex: // global
           I64[Sp - 8] = block_ccjeo_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucjeH; else goto ccjep;
       ucjeH: // global
           call _ccjeo(R1) args: 0, res: 0, upd: 0;
       ccjep: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjeo() //  [R1]
         { info_tbl: [(ccjeo,
                       label: block_ccjeo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjeo: // global
           if (R1 & 7 == 1) goto ccjes; else goto ccjet;
       ccjes: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccjet: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccjeG; else goto ccjeF;
       ccjeG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjeF: // global
           _sciCv::P64 = P64[R1 + 6];
           _sciCw::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sciCv::P64;
           P64[Hp] = _sciCw::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.922707214 UTC

[section ""cstring" . lvl4_rccbk_bytes" {
     lvl4_rccbk_bytes:
         I8[] [112,114,105,110,116,102,58,32,97,114,103,117,109,101,110,116,32,108,105,115,116,32,101,110,100,101,100,32,112,114,101,109,97,116,117,114,101,108,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.924728027 UTC

[section ""data" . Text.Printf.errorMissingArgument_closure" {
     Text.Printf.errorMissingArgument_closure:
         const Text.Printf.errorMissingArgument_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorMissingArgument_entry() //  [R1]
         { info_tbl: [(ccjf7,
                       label: Text.Printf.errorMissingArgument_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjf7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccjf8; else goto ccjf9;
       ccjf8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjf9: // global
           (_ccjf2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjf2::I64 == 0) goto ccjf4; else goto ccjf3;
       ccjf4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjf3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjf2::I64;
           I64[Sp - 24] = block_ccjf5_info;
           R2 = lvl4_rccbk_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccjf5() //  [R1]
         { info_tbl: [(ccjf5,
                       label: block_ccjf5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjf5: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.930994119 UTC

[section ""cstring" . lvl5_rccbl_bytes" {
     lvl5_rccbl_bytes:
         I8[] [112,114,105,110,116,102,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.933004965 UTC

[section ""data" . Text.Printf.errorBadArgument_closure" {
     Text.Printf.errorBadArgument_closure:
         const Text.Printf.errorBadArgument_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.errorBadArgument_entry() //  [R1]
         { info_tbl: [(ccjfy,
                       label: Text.Printf.errorBadArgument_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjfy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccjfz; else goto ccjfA;
       ccjfz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjfA: // global
           (_ccjft::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjft::I64 == 0) goto ccjfv; else goto ccjfu;
       ccjfv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjfu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjft::I64;
           I64[Sp - 24] = block_ccjfw_info;
           R2 = lvl5_rccbl_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccjfw() //  [R1]
         { info_tbl: [(ccjfw,
                       label: block_ccjfw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjfw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.938742906 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble9_bytes" {
     Text.Printf.$fPrintfArgDouble9_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.94079111 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble8_closure" {
     Text.Printf.$fPrintfArgDouble8_closure:
         const Text.Printf.$fPrintfArgDouble8_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble8_entry() //  [R1]
         { info_tbl: [(ccjfX,
                       label: Text.Printf.$fPrintfArgDouble8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjfX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjfY; else goto ccjfZ;
       ccjfY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjfZ: // global
           (_ccjfU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjfU::I64 == 0) goto ccjfW; else goto ccjfV;
       ccjfW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjfV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjfU::I64;
           R2 = Text.Printf.$fPrintfArgDouble9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.945939746 UTC

[section ""cstring" . lvl6_rccbm_bytes" {
     lvl6_rccbm_bytes:
         I8[] [112,114,105,110,116,102,58,32,105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,105,109,112,111,115,115,105,98,108,101,32,100,102,109,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.947975335 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble7_closure" {
     Text.Printf.$fPrintfArgDouble7_closure:
         const Text.Printf.$fPrintfArgDouble7_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble7_entry() //  [R1]
         { info_tbl: [(ccjgh,
                       label: Text.Printf.$fPrintfArgDouble7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjgh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccjgi; else goto ccjgj;
       ccjgi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjgj: // global
           (_ccjgc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjgc::I64 == 0) goto ccjge; else goto ccjgd;
       ccjge: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjgd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjgc::I64;
           I64[Sp - 24] = block_ccjgf_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccjgf() //  [R1]
         { info_tbl: [(ccjgf,
                       label: block_ccjgf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjgf: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.956039874 UTC

[section ""data" . Text.Printf.$w$sdfmt_closure" {
     Text.Printf.$w$sdfmt_closure:
         const Text.Printf.$w$sdfmt_info;
         const 0;
 },
 Text.Printf.$w$sdfmt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjgA: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2,
                                           R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$w$sdfmt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccjgG,
                       label: Text.Printf.$w$sdfmt_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjgG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccjgH; else goto ccjgI;
       ccjgH: // global
           R1 = Text.Printf.$w$sdfmt_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ccjgI: // global
           _sciCD::P64 = R5;
           _sciCC::P64 = R4;
           _sciCB::P64 = R3;
           (_sciCI::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(R2);
           (_sciCN::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(R2);
           if (_sciCN::I64 > 1114111) goto ccjgX; else goto ccjjB;
       ccjgX: // global
           R2 = _sciCN::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccjjB: // global
           if (_sciCN::I64 < 103) goto ucjjG; else goto ucjjI;
       ucjjG: // global
           if (_sciCN::I64 < 102) goto ucjjH; else goto ccjio;
       ucjjH: // global
           if (_sciCN::I64 < 101) goto ccjhY; else goto ccjic;
       ccjic: // global
           I64[Sp - 24] = block_ccji6_info;
           R1 = _sciCD::P64;
           P64[Sp - 16] = _sciCB::P64;
           I64[Sp - 8] = _sciCI::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucjjQ; else goto ccji7;
       ucjjQ: // global
           call _ccji6(R1) args: 0, res: 0, upd: 0;
       ccji7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccjio: // global
           I64[Sp - 32] = block_ccjin_info;
           R1 = _sciCC::P64;
           P64[Sp - 24] = _sciCB::P64;
           P64[Sp - 16] = _sciCD::P64;
           I64[Sp - 8] = _sciCI::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucjjR; else goto ccjiq;
       ucjjR: // global
           call _ccjin(R1) args: 0, res: 0, upd: 0;
       ccjiq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucjjI: // global
           if (_sciCN::I64 >= 104) goto ccjhY; else goto ccjj2;
       ccjhY: // global
           R1 = Text.Printf.$fPrintfArgDouble7_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccjj2: // global
           I64[Sp - 32] = block_ccjj1_info;
           R1 = _sciCC::P64;
           P64[Sp - 24] = _sciCB::P64;
           P64[Sp - 16] = _sciCD::P64;
           I64[Sp - 8] = _sciCI::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucjjS; else goto ccjj4;
       ucjjS: // global
           call _ccjj1(R1) args: 0, res: 0, upd: 0;
       ccjj4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccji6() //  [R1]
         { info_tbl: [(ccji6,
                       label: block_ccji6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccji6: // global
           _sciCB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccjib_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = _sciCB::P64;
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 8;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjib() //  [R1]
         { info_tbl: [(ccjib,
                       label: block_ccjib_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjib: // global
           P64[Sp] = R1;
           call _sciCR() args: 0, res: 0, upd: 0;
     }
 },
 _ccjin() //  [R1]
         { info_tbl: [(ccjin,
                       label: block_ccjin_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjin: // global
           _sciCD::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccjiC; else goto ccjiR;
       ccjiC: // global
           I64[Sp] = block_ccjiu_info;
           R1 = _sciCD::P64;
           if (R1 & 7 != 0) goto ucjjY; else goto ccjiv;
       ucjjY: // global
           call _ccjiu(R1) args: 0, res: 0, upd: 0;
       ccjiv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccjiR: // global
           I64[Sp] = block_ccjiK_info;
           R1 = _sciCD::P64;
           if (R1 & 7 != 0) goto ucjjZ; else goto ccjiL;
       ucjjZ: // global
           call _ccjiK(R1) args: 0, res: 0, upd: 0;
       ccjiL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjiu() //  [R1]
         { info_tbl: [(ccjiu,
                       label: block_ccjiu_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjiu: // global
           I64[Sp + 16] = block_ccjiz_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjiz() //  [R1]
         { info_tbl: [(ccjiz,
                       label: block_ccjiz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjiz: // global
           P64[Sp] = R1;
           call _sciCR() args: 0, res: 0, upd: 0;
     }
 },
 _ccjiK() //  [R1]
         { info_tbl: [(ccjiK,
                       label: block_ccjiK_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjiK: // global
           I64[Sp + 16] = block_ccjiP_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjiP() //  [R1]
         { info_tbl: [(ccjiP,
                       label: block_ccjiP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjiP: // global
           P64[Sp] = R1;
           call _sciCR() args: 0, res: 0, upd: 0;
     }
 },
 _ccjj1() //  [R1]
         { info_tbl: [(ccjj1,
                       label: block_ccjj1_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjj1: // global
           _sciCD::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccjjg; else goto ccjjv;
       ccjjg: // global
           I64[Sp] = block_ccjj8_info;
           R1 = _sciCD::P64;
           if (R1 & 7 != 0) goto ucjk2; else goto ccjj9;
       ucjk2: // global
           call _ccjj8(R1) args: 0, res: 0, upd: 0;
       ccjj9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccjjv: // global
           I64[Sp] = block_ccjjo_info;
           R1 = _sciCD::P64;
           if (R1 & 7 != 0) goto ucjk3; else goto ccjjp;
       ucjk3: // global
           call _ccjjo(R1) args: 0, res: 0, upd: 0;
       ccjjp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjj8() //  [R1]
         { info_tbl: [(ccjj8,
                       label: block_ccjj8_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjj8: // global
           I64[Sp + 16] = block_ccjjd_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjjd() //  [R1]
         { info_tbl: [(ccjjd,
                       label: block_ccjjd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjjd: // global
           P64[Sp] = R1;
           call _sciCR() args: 0, res: 0, upd: 0;
     }
 },
 _ccjjo() //  [R1]
         { info_tbl: [(ccjjo,
                       label: block_ccjjo_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjjo: // global
           I64[Sp + 16] = block_ccjjt_info;
           D1 = F64[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt_entry(D1,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjjt() //  [R1]
         { info_tbl: [(ccjjt,
                       label: block_ccjjt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjjt: // global
           P64[Sp] = R1;
           call _sciCR() args: 0, res: 0, upd: 0;
     }
 },
 _sciCR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sciCR: // global
           _sciCS::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto ccjhx; else goto ccjha;
       ccjhx: // global
           I64[Sp + 8] = block_ccjhw_info;
           R1 = _sciCS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucjk6; else goto ccjhy;
       ucjk6: // global
           call _ccjhw(R1) args: 0, res: 0, upd: 0;
       ccjhy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccjha: // global
           I64[Sp + 8] = block_ccjh8_info;
           R3 = _sciCS::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjhw() //  [R1]
         { info_tbl: [(ccjhw,
                       label: block_ccjhw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjhw: // global
           if (R1 & 7 == 1) goto ucjjP; else goto ccjhJ;
       ucjjP: // global
           Sp = Sp + 8;
           call _ccjhE() args: 0, res: 0, upd: 0;
       ccjhJ: // global
           I64[Sp - 16] = block_ccjhH_info;
           _sciD0::P64 = R1;
           _sciD2::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciD2::P64;
           P64[Sp] = _sciD0::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjjV; else goto ccjhK;
       ucjjV: // global
           call _ccjhH(R1) args: 0, res: 0, upd: 0;
       ccjhK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjhH() //  [R1]
         { info_tbl: [(ccjhH,
                       label: block_ccjhH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjhH: // global
           if (I64[R1 + 7] == 45) goto ccjhS; else goto ccjhR;
       ccjhS: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccjhR: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjh8() //  [R1]
         { info_tbl: [(ccjh8,
                       label: block_ccjh8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjh8: // global
           if (R1 & 7 == 1) goto ucjjO; else goto ccjhl;
       ucjjO: // global
           Sp = Sp + 8;
           call _ccjhE() args: 0, res: 0, upd: 0;
       ccjhl: // global
           I64[Sp - 16] = block_ccjhj_info;
           _sciCU::P64 = R1;
           _sciCW::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciCW::P64;
           P64[Sp] = _sciCU::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjjT; else goto ccjhm;
       ucjjT: // global
           call _ccjhj(R1) args: 0, res: 0, upd: 0;
       ccjhm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjhE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjhE: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjhj() //  [R1]
         { info_tbl: [(ccjhj,
                       label: block_ccjhj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjhj: // global
           if (I64[R1 + 7] == 45) goto ccjhu; else goto ccjht;
       ccjhu: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccjht: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:12.996028135 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat1_closure" {
     Text.Printf.$fPrintfArgFloat1_closure:
         const Text.Printf.$fPrintfArgFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat1_entry() //  [R1]
         { info_tbl: [(ccjm4,
                       label: Text.Printf.$fPrintfArgFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjm4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccjm5; else goto ccjm6;
       ccjm5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjm6: // global
           (_ccjlZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjlZ::I64 == 0) goto ccjm1; else goto ccjm0;
       ccjm1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjm0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjlZ::I64;
           I64[Sp - 24] = block_ccjm2_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccjm2() //  [R1]
         { info_tbl: [(ccjm2,
                       label: block_ccjm2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjm2: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.00379157 UTC

[section ""data" . Text.Printf.$w$sdfmt1_closure" {
     Text.Printf.$w$sdfmt1_closure:
         const Text.Printf.$w$sdfmt1_info;
         const 0;
 },
 Text.Printf.$w$sdfmt1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjmn: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$w$sdfmt1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccjmt,
                       label: Text.Printf.$w$sdfmt1_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjmt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccjmu; else goto ccjmv;
       ccjmu: // global
           R1 = Text.Printf.$w$sdfmt1_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       ccjmv: // global
           _sciDt::P64 = R5;
           _sciDs::P64 = R4;
           _sciDr::P64 = R3;
           (_sciDy::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(R2);
           (_sciDD::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(R2);
           if (_sciDD::I64 > 1114111) goto ccjmK; else goto ccjpo;
       ccjmK: // global
           R2 = _sciDD::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccjpo: // global
           if (_sciDD::I64 < 103) goto ucjpt; else goto ucjpv;
       ucjpt: // global
           if (_sciDD::I64 < 102) goto ucjpu; else goto ccjob;
       ucjpu: // global
           if (_sciDD::I64 < 101) goto ccjnL; else goto ccjnZ;
       ccjnZ: // global
           I64[Sp - 24] = block_ccjnT_info;
           R1 = _sciDt::P64;
           P64[Sp - 16] = _sciDr::P64;
           I64[Sp - 8] = _sciDy::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucjpD; else goto ccjnU;
       ucjpD: // global
           call _ccjnT(R1) args: 0, res: 0, upd: 0;
       ccjnU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccjob: // global
           I64[Sp - 32] = block_ccjoa_info;
           R1 = _sciDs::P64;
           P64[Sp - 24] = _sciDr::P64;
           P64[Sp - 16] = _sciDt::P64;
           I64[Sp - 8] = _sciDy::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucjpE; else goto ccjod;
       ucjpE: // global
           call _ccjoa(R1) args: 0, res: 0, upd: 0;
       ccjod: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucjpv: // global
           if (_sciDD::I64 >= 104) goto ccjnL; else goto ccjoP;
       ccjnL: // global
           R1 = Text.Printf.$fPrintfArgFloat1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccjoP: // global
           I64[Sp - 32] = block_ccjoO_info;
           R1 = _sciDs::P64;
           P64[Sp - 24] = _sciDr::P64;
           P64[Sp - 16] = _sciDt::P64;
           I64[Sp - 8] = _sciDy::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucjpF; else goto ccjoR;
       ucjpF: // global
           call _ccjoO(R1) args: 0, res: 0, upd: 0;
       ccjoR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjnT() //  [R1]
         { info_tbl: [(ccjnT,
                       label: block_ccjnT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjnT: // global
           _sciDr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccjnY_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = _sciDr::P64;
           R2 = GHC.Float.FFExponent_closure+1;
           Sp = Sp + 8;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjnY() //  [R1]
         { info_tbl: [(ccjnY,
                       label: block_ccjnY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjnY: // global
           P64[Sp] = R1;
           call _sciDH() args: 0, res: 0, upd: 0;
     }
 },
 _ccjoa() //  [R1]
         { info_tbl: [(ccjoa,
                       label: block_ccjoa_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjoa: // global
           _sciDt::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccjop; else goto ccjoE;
       ccjop: // global
           I64[Sp] = block_ccjoh_info;
           R1 = _sciDt::P64;
           if (R1 & 7 != 0) goto ucjpL; else goto ccjoi;
       ucjpL: // global
           call _ccjoh(R1) args: 0, res: 0, upd: 0;
       ccjoi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccjoE: // global
           I64[Sp] = block_ccjox_info;
           R1 = _sciDt::P64;
           if (R1 & 7 != 0) goto ucjpM; else goto ccjoy;
       ucjpM: // global
           call _ccjox(R1) args: 0, res: 0, upd: 0;
       ccjoy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjoh() //  [R1]
         { info_tbl: [(ccjoh,
                       label: block_ccjoh_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjoh: // global
           I64[Sp + 16] = block_ccjom_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjom() //  [R1]
         { info_tbl: [(ccjom,
                       label: block_ccjom_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjom: // global
           P64[Sp] = R1;
           call _sciDH() args: 0, res: 0, upd: 0;
     }
 },
 _ccjox() //  [R1]
         { info_tbl: [(ccjox,
                       label: block_ccjox_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjox: // global
           I64[Sp + 16] = block_ccjoC_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFFixed_closure+2;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjoC() //  [R1]
         { info_tbl: [(ccjoC,
                       label: block_ccjoC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjoC: // global
           P64[Sp] = R1;
           call _sciDH() args: 0, res: 0, upd: 0;
     }
 },
 _ccjoO() //  [R1]
         { info_tbl: [(ccjoO,
                       label: block_ccjoO_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjoO: // global
           _sciDt::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccjp3; else goto ccjpi;
       ccjp3: // global
           I64[Sp] = block_ccjoV_info;
           R1 = _sciDt::P64;
           if (R1 & 7 != 0) goto ucjpP; else goto ccjoW;
       ucjpP: // global
           call _ccjoV(R1) args: 0, res: 0, upd: 0;
       ccjoW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccjpi: // global
           I64[Sp] = block_ccjpb_info;
           R1 = _sciDt::P64;
           if (R1 & 7 != 0) goto ucjpQ; else goto ccjpc;
       ucjpQ: // global
           call _ccjpb(R1) args: 0, res: 0, upd: 0;
       ccjpc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjoV() //  [R1]
         { info_tbl: [(ccjoV,
                       label: block_ccjoV_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjoV: // global
           I64[Sp + 16] = block_ccjp0_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.False_closure+1;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjp0() //  [R1]
         { info_tbl: [(ccjp0,
                       label: block_ccjp0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjp0: // global
           P64[Sp] = R1;
           call _sciDH() args: 0, res: 0, upd: 0;
     }
 },
 _ccjpb() //  [R1]
         { info_tbl: [(ccjpb,
                       label: block_ccjpb_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjpb: // global
           I64[Sp + 16] = block_ccjpg_info;
           F1 = F32[R1 + 7];
           R4 = GHC.Types.True_closure+2;
           R3 = P64[Sp + 8];
           R2 = GHC.Float.FFGeneric_closure+3;
           Sp = Sp + 16;
           call GHC.Float.$w$sformatRealFloatAlt1_entry(F1,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjpg() //  [R1]
         { info_tbl: [(ccjpg,
                       label: block_ccjpg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjpg: // global
           P64[Sp] = R1;
           call _sciDH() args: 0, res: 0, upd: 0;
     }
 },
 _sciDH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sciDH: // global
           _sciDI::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto ccjnk; else goto ccjmX;
       ccjnk: // global
           I64[Sp + 8] = block_ccjnj_info;
           R1 = _sciDI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucjpT; else goto ccjnl;
       ucjpT: // global
           call _ccjnj(R1) args: 0, res: 0, upd: 0;
       ccjnl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccjmX: // global
           I64[Sp + 8] = block_ccjmV_info;
           R3 = _sciDI::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjnj() //  [R1]
         { info_tbl: [(ccjnj,
                       label: block_ccjnj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjnj: // global
           if (R1 & 7 == 1) goto ucjpC; else goto ccjnw;
       ucjpC: // global
           Sp = Sp + 8;
           call _ccjnr() args: 0, res: 0, upd: 0;
       ccjnw: // global
           I64[Sp - 16] = block_ccjnu_info;
           _sciDQ::P64 = R1;
           _sciDS::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciDS::P64;
           P64[Sp] = _sciDQ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjpI; else goto ccjnx;
       ucjpI: // global
           call _ccjnu(R1) args: 0, res: 0, upd: 0;
       ccjnx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjnu() //  [R1]
         { info_tbl: [(ccjnu,
                       label: block_ccjnu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjnu: // global
           if (I64[R1 + 7] == 45) goto ccjnF; else goto ccjnE;
       ccjnF: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccjnE: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjmV() //  [R1]
         { info_tbl: [(ccjmV,
                       label: block_ccjmV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjmV: // global
           if (R1 & 7 == 1) goto ucjpB; else goto ccjn8;
       ucjpB: // global
           Sp = Sp + 8;
           call _ccjnr() args: 0, res: 0, upd: 0;
       ccjn8: // global
           I64[Sp - 16] = block_ccjn6_info;
           _sciDK::P64 = R1;
           _sciDM::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciDM::P64;
           P64[Sp] = _sciDK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjpG; else goto ccjn9;
       ucjpG: // global
           call _ccjn6(R1) args: 0, res: 0, upd: 0;
       ccjn9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjnr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjnr: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjn6() //  [R1]
         { info_tbl: [(ccjn6,
                       label: block_ccjn6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjn6: // global
           if (I64[R1 + 7] == 45) goto ccjnh; else goto ccjng;
       ccjnh: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccjng: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.042769859 UTC

[section ""data" . Text.Printf.formatRealFloat1_closure" {
     Text.Printf.formatRealFloat1_closure:
         const Text.Printf.formatRealFloat1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.formatRealFloat1_entry() //  [R1]
         { info_tbl: [(ccjrR,
                       label: Text.Printf.formatRealFloat1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjrR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccjrS; else goto ccjrT;
       ccjrS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjrT: // global
           (_ccjrM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjrM::I64 == 0) goto ccjrO; else goto ccjrN;
       ccjrO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjrN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjrM::I64;
           I64[Sp - 24] = block_ccjrP_info;
           R2 = lvl6_rccbm_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccjrP() //  [R1]
         { info_tbl: [(ccjrP,
                       label: block_ccjrP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjrP: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.050209934 UTC

[section ""data" . Text.Printf.$wdfmt_closure" {
     Text.Printf.$wdfmt_closure:
         const Text.Printf.$wdfmt_info;
         const 0;
 },
 Text.Printf.$wdfmt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjsa: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2,
                                         R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wdfmt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccjsg,
                       label: Text.Printf.$wdfmt_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjsg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccjsh; else goto ccjsi;
       ccjsh: // global
           R1 = Text.Printf.$wdfmt_closure;
           P64[Sp - 40] = R2;
           I64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       ccjsi: // global
           _sciEk::P64 = R6;
           _sciEj::P64 = R5;
           _sciEi::P64 = R4;
           _sciEh::I64 = R3;
           _ccjsl::I64 = R3;
           (_sciEp::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_iswupper(_ccjsl::I64);
           (_sciEu::I64) = call "ccall" arg hints:  [‘signed’]  result hints:  [‘signed’] u_towlower(_sciEh::I64);
           if (_sciEu::I64 > 1114111) goto ccjsx; else goto ccjuH;
       ccjsx: // global
           R2 = _sciEu::I64;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccjuH: // global
           if (_sciEu::I64 < 103) goto ucjuM; else goto ucjuO;
       ucjuM: // global
           if (_sciEu::I64 < 102) goto ucjuN; else goto ccjtS;
       ucjuN: // global
           if (_sciEu::I64 < 101) goto ccjty; else goto ccjtH;
       ccjtH: // global
           I64[Sp - 16] = block_ccjtG_info;
           R6 = _sciEk::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _sciEi::P64;
           R3 = GHC.Float.FFExponent_closure+1;
           R2 = R2;
           I64[Sp - 8] = _sciEp::I64;
           Sp = Sp - 16;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccjtS: // global
           I64[Sp - 40] = block_ccjtR_info;
           R1 = _sciEj::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = _sciEi::P64;
           P64[Sp - 16] = _sciEk::P64;
           I64[Sp - 8] = _sciEp::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucjuW; else goto ccjtU;
       ucjuW: // global
           call _ccjtR(R1) args: 0, res: 0, upd: 0;
       ccjtU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucjuO: // global
           if (_sciEu::I64 >= 104) goto ccjty; else goto ccjuk;
       ccjty: // global
           R1 = Text.Printf.formatRealFloat1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccjuk: // global
           I64[Sp - 40] = block_ccjuj_info;
           R1 = _sciEj::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = _sciEi::P64;
           P64[Sp - 16] = _sciEk::P64;
           I64[Sp - 8] = _sciEp::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucjuX; else goto ccjum;
       ucjuX: // global
           call _ccjuj(R1) args: 0, res: 0, upd: 0;
       ccjum: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjtG() //  [R1]
         { info_tbl: [(ccjtG,
                       label: block_ccjtG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjtG: // global
           P64[Sp] = R1;
           call _sciEy() args: 0, res: 0, upd: 0;
     }
 },
 _ccjtR() //  [R1]
         { info_tbl: [(ccjtR,
                       label: block_ccjtR_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjtR: // global
           _sciEg::P64 = P64[Sp + 8];
           _sciEi::P64 = P64[Sp + 16];
           _sciEk::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccju1; else goto ccjua;
       ccju1: // global
           I64[Sp + 24] = block_ccjtY_info;
           R6 = _sciEk::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _sciEi::P64;
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = _sciEg::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccjua: // global
           I64[Sp + 24] = block_ccju8_info;
           R6 = _sciEk::P64;
           R5 = GHC.Types.True_closure+2;
           R4 = _sciEi::P64;
           R3 = GHC.Float.FFFixed_closure+2;
           R2 = _sciEg::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjtY() //  [R1]
         { info_tbl: [(ccjtY,
                       label: block_ccjtY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjtY: // global
           P64[Sp] = R1;
           call _sciEy() args: 0, res: 0, upd: 0;
     }
 },
 _ccju8() //  [R1]
         { info_tbl: [(ccju8,
                       label: block_ccju8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccju8: // global
           P64[Sp] = R1;
           call _sciEy() args: 0, res: 0, upd: 0;
     }
 },
 _ccjuj() //  [R1]
         { info_tbl: [(ccjuj,
                       label: block_ccjuj_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjuj: // global
           _sciEg::P64 = P64[Sp + 8];
           _sciEi::P64 = P64[Sp + 16];
           _sciEk::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ccjut; else goto ccjuC;
       ccjut: // global
           I64[Sp + 24] = block_ccjuq_info;
           R6 = _sciEk::P64;
           R5 = GHC.Types.False_closure+1;
           R4 = _sciEi::P64;
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = _sciEg::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccjuC: // global
           I64[Sp + 24] = block_ccjuA_info;
           R6 = _sciEk::P64;
           R5 = GHC.Types.True_closure+2;
           R4 = _sciEi::P64;
           R3 = GHC.Float.FFGeneric_closure+3;
           R2 = _sciEg::P64;
           Sp = Sp + 24;
           call GHC.Float.formatRealFloatAlt_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjuq() //  [R1]
         { info_tbl: [(ccjuq,
                       label: block_ccjuq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjuq: // global
           P64[Sp] = R1;
           call _sciEy() args: 0, res: 0, upd: 0;
     }
 },
 _ccjuA() //  [R1]
         { info_tbl: [(ccjuA,
                       label: block_ccjuA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjuA: // global
           P64[Sp] = R1;
           call _sciEy() args: 0, res: 0, upd: 0;
     }
 },
 _sciEy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sciEy: // global
           _sciEz::P64 = P64[Sp];
           if (I64[Sp + 8] == 0) goto ccjt7; else goto ccjsK;
       ccjt7: // global
           I64[Sp + 8] = block_ccjt6_info;
           R1 = _sciEz::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucjv7; else goto ccjt8;
       ucjv7: // global
           call _ccjt6(R1) args: 0, res: 0, upd: 0;
       ccjt8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccjsK: // global
           I64[Sp + 8] = block_ccjsI_info;
           R3 = _sciEz::P64;
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjt6() //  [R1]
         { info_tbl: [(ccjt6,
                       label: block_ccjt6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjt6: // global
           if (R1 & 7 == 1) goto ucjuV; else goto ccjtj;
       ucjuV: // global
           Sp = Sp + 8;
           call _ccjte() args: 0, res: 0, upd: 0;
       ccjtj: // global
           I64[Sp - 16] = block_ccjth_info;
           _sciEH::P64 = R1;
           _sciEJ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciEJ::P64;
           P64[Sp] = _sciEH::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjv0; else goto ccjtk;
       ucjv0: // global
           call _ccjth(R1) args: 0, res: 0, upd: 0;
       ccjtk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjth() //  [R1]
         { info_tbl: [(ccjth,
                       label: block_ccjth_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjth: // global
           if (I64[R1 + 7] == 45) goto ccjts; else goto ccjtr;
       ccjts: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccjtr: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjsI() //  [R1]
         { info_tbl: [(ccjsI,
                       label: block_ccjsI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjsI: // global
           if (R1 & 7 == 1) goto ucjuU; else goto ccjsV;
       ucjuU: // global
           Sp = Sp + 8;
           call _ccjte() args: 0, res: 0, upd: 0;
       ccjsV: // global
           I64[Sp - 16] = block_ccjsT_info;
           _sciEB::P64 = R1;
           _sciED::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciED::P64;
           P64[Sp] = _sciEB::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjuY; else goto ccjsW;
       ucjuY: // global
           call _ccjsT(R1) args: 0, res: 0, upd: 0;
       ccjsW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjte() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjte: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjsT() //  [R1]
         { info_tbl: [(ccjsT,
                       label: block_ccjsT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjsT: // global
           if (I64[R1 + 7] == 45) goto ccjt4; else goto ccjt3;
       ccjt4: // global
           R2 = P64[Sp + 8];
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccjt3: // global
           R2 = P64[Sp + 16];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.080095848 UTC

[section ""cstring" . Text.Printf.$trModule4_bytes" {
     Text.Printf.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.081869961 UTC

[section ""data" . Text.Printf.$trModule3_closure" {
     Text.Printf.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.083616281 UTC

[section ""cstring" . Text.Printf.$trModule2_bytes" {
     Text.Printf.$trModule2_bytes:
         I8[] [84,101,120,116,46,80,114,105,110,116,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.085368461 UTC

[section ""data" . Text.Printf.$trModule1_closure" {
     Text.Printf.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.087134777 UTC

[section ""data" . Text.Printf.$trModule_closure" {
     Text.Printf.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Text.Printf.$trModule3_closure+1;
         const Text.Printf.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.088868806 UTC

[section ""data" . $krep_rccbn_closure" {
     $krep_rccbn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.090957806 UTC

[section ""data" . $krep1_rccbo_closure" {
     $krep1_rccbo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.092738101 UTC

[section ""data" . $krep2_rccbp_closure" {
     $krep2_rccbp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.094664032 UTC

[section ""data" . $krep3_rccbq_closure" {
     $krep3_rccbq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.096408069 UTC

[section ""data" . $krep4_rccbr_closure" {
     $krep4_rccbr_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.098163716 UTC

[section ""data" . $krep5_rccbs_closure" {
     $krep5_rccbs_closure:
         const :_con_info;
         const $krep1_rccbo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.099971795 UTC

[section ""data" . $krep6_rccbt_closure" {
     $krep6_rccbt_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep5_rccbs_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.101771626 UTC

[section ""data" . $krep7_rccbu_closure" {
     $krep7_rccbu_closure:
         const :_con_info;
         const $krep3_rccbq_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.104102672 UTC

[section ""data" . $krep8_rccbv_closure" {
     $krep8_rccbv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep7_rccbu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.106212404 UTC

[section ""data" . $krep9_rccbw_closure" {
     $krep9_rccbw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep8_rccbv_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.107949759 UTC

[section ""data" . Text.Printf.$tcHPrintfType1_closure" {
     Text.Printf.$tcHPrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep4_rccbr_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.109788363 UTC

[section ""data" . $krep10_rccbx_closure" {
     $krep10_rccbx_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.111470143 UTC

[section ""data" . $krep11_rccby_closure" {
     $krep11_rccby_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep3_rccbq_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.113294932 UTC

[section ""data" . $krep12_rccbz_closure" {
     $krep12_rccbz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep10_rccbx_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.11505579 UTC

[section ""cstring" . Text.Printf.$tcIsChar2_bytes" {
     Text.Printf.$tcIsChar2_bytes:
         I8[] [73,115,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.1167876 UTC

[section ""data" . Text.Printf.$tcIsChar1_closure" {
     Text.Printf.$tcIsChar1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcIsChar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.119027794 UTC

[section ""data" . Text.Printf.$tcIsChar_closure" {
     Text.Printf.$tcIsChar_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcIsChar1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 660225335504909605;
         const 5800397900948792736;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.12085702 UTC

[section ""data" . $krep13_rccbA_closure" {
     $krep13_rccbA_closure:
         const :_con_info;
         const $krep10_rccbx_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.122633395 UTC

[section ""data" . $krep14_rccbB_closure" {
     $krep14_rccbB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcIsChar_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.124380446 UTC

[section ""data" . $krep15_rccbC_closure" {
     $krep15_rccbC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_rccbz_closure+4;
         const $krep14_rccbB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.126084518 UTC

[section ""data" . Text.Printf.$tc'C:IsChar1_closure" {
     Text.Printf.$tc'C:IsChar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_rccby_closure+4;
         const $krep15_rccbC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.127759526 UTC

[section ""cstring" . Text.Printf.$tc'C:IsChar3_bytes" {
     Text.Printf.$tc'C:IsChar3_bytes:
         I8[] [39,67,58,73,115,67,104,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.130477137 UTC

[section ""data" . Text.Printf.$tc'C:IsChar2_closure" {
     Text.Printf.$tc'C:IsChar2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:IsChar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.132188437 UTC

[section ""data" . Text.Printf.$tc'C:IsChar_closure" {
     Text.Printf.$tc'C:IsChar_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:IsChar2_closure+1;
         const Text.Printf.$tc'C:IsChar1_closure+4;
         const 15586488259906363003;
         const 17643381548147423706;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.134028555 UTC

[section ""cstring" . Text.Printf.$tcFormatAdjustment2_bytes" {
     Text.Printf.$tcFormatAdjustment2_bytes:
         I8[] [70,111,114,109,97,116,65,100,106,117,115,116,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.135699988 UTC

[section ""data" . Text.Printf.$tcFormatAdjustment1_closure" {
     Text.Printf.$tcFormatAdjustment1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatAdjustment2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.137428426 UTC

[section ""data" . Text.Printf.$tcFormatAdjustment_closure" {
     Text.Printf.$tcFormatAdjustment_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatAdjustment1_closure+1;
         const GHC.Types.krep$*_closure;
         const 7532892403054408380;
         const 17299592949916286280;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.139257624 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust1_closure" {
     Text.Printf.$tc'LeftAdjust1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatAdjustment_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.141013549 UTC

[section ""cstring" . Text.Printf.$tc'LeftAdjust3_bytes" {
     Text.Printf.$tc'LeftAdjust3_bytes:
         I8[] [39,76,101,102,116,65,100,106,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.142749046 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust2_closure" {
     Text.Printf.$tc'LeftAdjust2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'LeftAdjust3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.144365441 UTC

[section ""data" . Text.Printf.$tc'LeftAdjust_closure" {
     Text.Printf.$tc'LeftAdjust_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'LeftAdjust2_closure+1;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const 3724221440131574524;
         const 12430068224974793646;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.146336244 UTC

[section ""cstring" . Text.Printf.$tc'ZeroPad2_bytes" {
     Text.Printf.$tc'ZeroPad2_bytes:
         I8[] [39,90,101,114,111,80,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.148073915 UTC

[section ""data" . Text.Printf.$tc'ZeroPad1_closure" {
     Text.Printf.$tc'ZeroPad1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'ZeroPad2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.149829106 UTC

[section ""data" . Text.Printf.$tc'ZeroPad_closure" {
     Text.Printf.$tc'ZeroPad_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'ZeroPad1_closure+1;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const 4688343247861108158;
         const 7307113320833774212;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.151703695 UTC

[section ""data" . $krep16_rccbD_closure" {
     $krep16_rccbD_closure:
         const :_con_info;
         const Text.Printf.$tc'LeftAdjust1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.153541923 UTC

[section ""data" . $krep17_rccbE_closure" {
     $krep17_rccbE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep16_rccbD_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.155869003 UTC

[section ""cstring" . Text.Printf.$tcFormatSign2_bytes" {
     Text.Printf.$tcFormatSign2_bytes:
         I8[] [70,111,114,109,97,116,83,105,103,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.157668616 UTC

[section ""data" . Text.Printf.$tcFormatSign1_closure" {
     Text.Printf.$tcFormatSign1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatSign2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.15939288 UTC

[section ""data" . Text.Printf.$tcFormatSign_closure" {
     Text.Printf.$tcFormatSign_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatSign1_closure+1;
         const GHC.Types.krep$*_closure;
         const 35986971025498593;
         const 9833165860459639351;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.161220228 UTC

[section ""data" . Text.Printf.$tc'SignPlus1_closure" {
     Text.Printf.$tc'SignPlus1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatSign_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.163005168 UTC

[section ""cstring" . Text.Printf.$tc'SignPlus3_bytes" {
     Text.Printf.$tc'SignPlus3_bytes:
         I8[] [39,83,105,103,110,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.164712796 UTC

[section ""data" . Text.Printf.$tc'SignPlus2_closure" {
     Text.Printf.$tc'SignPlus2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'SignPlus3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.167096746 UTC

[section ""data" . Text.Printf.$tc'SignPlus_closure" {
     Text.Printf.$tc'SignPlus_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'SignPlus2_closure+1;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const 18302065795158432479;
         const 11830941225366619964;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.168916424 UTC

[section ""cstring" . Text.Printf.$tc'SignSpace2_bytes" {
     Text.Printf.$tc'SignSpace2_bytes:
         I8[] [39,83,105,103,110,83,112,97,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.17060226 UTC

[section ""data" . Text.Printf.$tc'SignSpace1_closure" {
     Text.Printf.$tc'SignSpace1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'SignSpace2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.172289362 UTC

[section ""data" . Text.Printf.$tc'SignSpace_closure" {
     Text.Printf.$tc'SignSpace_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'SignSpace1_closure+1;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const 111286303843533919;
         const 13624428119758319457;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.17421045 UTC

[section ""data" . $krep18_rccbF_closure" {
     $krep18_rccbF_closure:
         const :_con_info;
         const Text.Printf.$tc'SignPlus1_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.175959984 UTC

[section ""data" . $krep19_rccbG_closure" {
     $krep19_rccbG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep18_rccbF_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.177795363 UTC

[section ""cstring" . Text.Printf.$tcFieldFormat2_bytes" {
     Text.Printf.$tcFieldFormat2_bytes:
         I8[] [70,105,101,108,100,70,111,114,109,97,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.179596252 UTC

[section ""data" . Text.Printf.$tcFieldFormat1_closure" {
     Text.Printf.$tcFieldFormat1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFieldFormat2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.182676063 UTC

[section ""data" . Text.Printf.$tcFieldFormat_closure" {
     Text.Printf.$tcFieldFormat_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFieldFormat1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12330325036165183082;
         const 5846211506648458401;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.184600257 UTC

[section ""data" . $krep20_rccbH_closure" {
     $krep20_rccbH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFieldFormat_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.186330104 UTC

[section ""data" . $krep21_rccbI_closure" {
     $krep21_rccbI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep20_rccbH_closure+1;
         const $krep9_rccbw_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.188040337 UTC

[section ""data" . $krep22_rccbJ_closure" {
     $krep22_rccbJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep21_rccbI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.189875681 UTC

[section ""data" . $krep23_rccbK_closure" {
     $krep23_rccbK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep20_rccbH_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.19161519 UTC

[section ""data" . $krep24_rccbL_closure" {
     $krep24_rccbL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep23_rccbK_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.193391092 UTC

[section ""data" . $krep25_rccbM_closure" {
     $krep25_rccbM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rccbn_closure+1;
         const $krep24_rccbL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.195155441 UTC

[section ""data" . $krep26_rccbN_closure" {
     $krep26_rccbN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep19_rccbG_closure+1;
         const $krep25_rccbM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.196869633 UTC

[section ""data" . $krep27_rccbO_closure" {
     $krep27_rccbO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_rccbE_closure+1;
         const $krep26_rccbN_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.199065739 UTC

[section ""data" . $krep28_rccbP_closure" {
     $krep28_rccbP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rccbt_closure+1;
         const $krep27_rccbO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.200781093 UTC

[section ""data" . Text.Printf.$tc'FieldFormat1_closure" {
     Text.Printf.$tc'FieldFormat1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_rccbt_closure+1;
         const $krep28_rccbP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.202579703 UTC

[section ""cstring" . Text.Printf.$tc'FieldFormat3_bytes" {
     Text.Printf.$tc'FieldFormat3_bytes:
         I8[] [39,70,105,101,108,100,70,111,114,109,97,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.204248091 UTC

[section ""data" . Text.Printf.$tc'FieldFormat2_closure" {
     Text.Printf.$tc'FieldFormat2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'FieldFormat3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.206102661 UTC

[section ""data" . Text.Printf.$tc'FieldFormat_closure" {
     Text.Printf.$tc'FieldFormat_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'FieldFormat2_closure+1;
         const Text.Printf.$tc'FieldFormat1_closure+4;
         const 11348432599023007686;
         const 6814357301696130957;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.208565794 UTC

[section ""cstring" . Text.Printf.$tcFormatParse2_bytes" {
     Text.Printf.$tcFormatParse2_bytes:
         I8[] [70,111,114,109,97,116,80,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.210419164 UTC

[section ""data" . Text.Printf.$tcFormatParse1_closure" {
     Text.Printf.$tcFormatParse1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcFormatParse2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.21217829 UTC

[section ""data" . Text.Printf.$tcFormatParse_closure" {
     Text.Printf.$tcFormatParse_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcFormatParse1_closure+1;
         const GHC.Types.krep$*_closure;
         const 5517048358589873764;
         const 8326725038359313810;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.214569649 UTC

[section ""data" . $krep29_rccbQ_closure" {
     $krep29_rccbQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcFormatParse_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.216256837 UTC

[section ""data" . $krep30_rccbR_closure" {
     $krep30_rccbR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep29_rccbQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.218133455 UTC

[section ""data" . $krep31_rccbS_closure" {
     $krep31_rccbS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_rccbx_closure+2;
         const $krep30_rccbR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.219910529 UTC

[section ""data" . $krep32_rccbT_closure" {
     $krep32_rccbT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rccbq_closure+1;
         const $krep30_rccbR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.221730908 UTC

[section ""data" . Text.Printf.$tc'FormatParse1_closure" {
     Text.Printf.$tc'FormatParse1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep32_rccbT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.223433724 UTC

[section ""cstring" . Text.Printf.$tc'FormatParse3_bytes" {
     Text.Printf.$tc'FormatParse3_bytes:
         I8[] [39,70,111,114,109,97,116,80,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.225058755 UTC

[section ""data" . Text.Printf.$tc'FormatParse2_closure" {
     Text.Printf.$tc'FormatParse2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'FormatParse3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.226855481 UTC

[section ""data" . Text.Printf.$tc'FormatParse_closure" {
     Text.Printf.$tc'FormatParse_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'FormatParse2_closure+1;
         const Text.Printf.$tc'FormatParse1_closure+4;
         const 549767054447046648;
         const 1116614444935710689;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.228739258 UTC

[section ""data" . $krep33_rccbU_closure" {
     $krep33_rccbU_closure:
         const :_con_info;
         const $krep21_rccbI_closure+4;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.230909796 UTC

[section ""data" . $krep34_rccbV_closure" {
     $krep34_rccbV_closure:
         const :_con_info;
         const $krep30_rccbR_closure+4;
         const $krep33_rccbU_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.232621074 UTC

[section ""data" . $krep35_rccbW_closure" {
     $krep35_rccbW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc(,)_closure;
         const $krep34_rccbV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.234445587 UTC

[section ""data" . $krep36_rccbX_closure" {
     $krep36_rccbX_closure:
         const :_con_info;
         const $krep35_rccbW_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.236805933 UTC

[section ""data" . $krep37_rccbY_closure" {
     $krep37_rccbY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep36_rccbX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.238550813 UTC

[section ""data" . $krep38_rccbZ_closure" {
     $krep38_rccbZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep37_rccbY_closure+1;
         const $krep10_rccbx_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.240225155 UTC

[section ""data" . $krep39_rccc0_closure" {
     $krep39_rccc0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_rccbv_closure+1;
         const $krep38_rccbZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.241925111 UTC

[section ""data" . $krep40_rccc1_closure" {
     $krep40_rccc1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rccbp_closure+1;
         const $krep39_rccc0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.243698655 UTC

[section ""cstring" . Text.Printf.$tcPrintfArg2_bytes" {
     Text.Printf.$tcPrintfArg2_bytes:
         I8[] [80,114,105,110,116,102,65,114,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.245956755 UTC

[section ""data" . Text.Printf.$tcPrintfArg1_closure" {
     Text.Printf.$tcPrintfArg1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcPrintfArg2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.247712169 UTC

[section ""data" . Text.Printf.$tcPrintfArg_closure" {
     Text.Printf.$tcPrintfArg_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcPrintfArg1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 14684532792197610005;
         const 5760551473172190061;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.249605984 UTC

[section ""data" . $krep41_rccc2_closure" {
     $krep41_rccc2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcPrintfArg_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.251326946 UTC

[section ""data" . $krep42_rccc3_closure" {
     $krep42_rccc3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep31_rccbS_closure+4;
         const $krep41_rccc2_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.253070866 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg1_closure" {
     Text.Printf.$tc'C:PrintfArg1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep22_rccbJ_closure+4;
         const $krep42_rccc3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.254855126 UTC

[section ""cstring" . Text.Printf.$tc'C:PrintfArg3_bytes" {
     Text.Printf.$tc'C:PrintfArg3_bytes:
         I8[] [39,67,58,80,114,105,110,116,102,65,114,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.256570322 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg2_closure" {
     Text.Printf.$tc'C:PrintfArg2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:PrintfArg3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.258308595 UTC

[section ""data" . Text.Printf.$tc'C:PrintfArg_closure" {
     Text.Printf.$tc'C:PrintfArg_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:PrintfArg2_closure+1;
         const Text.Printf.$tc'C:PrintfArg1_closure+4;
         const 11923342243699112506;
         const 8346787778082712340;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.260256265 UTC

[section ""cstring" . Text.Printf.$tcHPrintfType3_bytes" {
     Text.Printf.$tcHPrintfType3_bytes:
         I8[] [72,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.26256735 UTC

[section ""data" . Text.Printf.$tcHPrintfType2_closure" {
     Text.Printf.$tcHPrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcHPrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.264251097 UTC

[section ""data" . Text.Printf.$tcHPrintfType_closure" {
     Text.Printf.$tcHPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcHPrintfType2_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 13104883804062546050;
         const 15477829653093370802;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.266578911 UTC

[section ""data" . $krep43_rccc4_closure" {
     $krep43_rccc4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcHPrintfType_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.268352812 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType1_closure" {
     Text.Printf.$tc'C:HPrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep40_rccc1_closure+4;
         const $krep43_rccc4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.270148281 UTC

[section ""cstring" . Text.Printf.$tc'C:HPrintfType3_bytes" {
     Text.Printf.$tc'C:HPrintfType3_bytes:
         I8[] [39,67,58,72,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.27181443 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType2_closure" {
     Text.Printf.$tc'C:HPrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:HPrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.273576508 UTC

[section ""data" . Text.Printf.$tc'C:HPrintfType_closure" {
     Text.Printf.$tc'C:HPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:HPrintfType2_closure+1;
         const Text.Printf.$tc'C:HPrintfType1_closure+4;
         const 16716104921226462095;
         const 4043378586122981700;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.275391775 UTC

[section ""cstring" . Text.Printf.$tcPrintfType2_bytes" {
     Text.Printf.$tcPrintfType2_bytes:
         I8[] [80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.277058839 UTC

[section ""data" . Text.Printf.$tcPrintfType1_closure" {
     Text.Printf.$tcPrintfType1_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tcPrintfType2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.279035864 UTC

[section ""data" . Text.Printf.$tcPrintfType_closure" {
     Text.Printf.$tcPrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tcPrintfType1_closure+1;
         const Text.Printf.$tcHPrintfType1_closure+4;
         const 16100185319445667829;
         const 10371264040433388740;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.28087486 UTC

[section ""data" . $krep44_rccc5_closure" {
     $krep44_rccc5_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Text.Printf.$tcPrintfType_closure+1;
         const $krep13_rccbA_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.282677974 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType1_closure" {
     Text.Printf.$tc'C:PrintfType1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep39_rccc0_closure+4;
         const $krep44_rccc5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.284354645 UTC

[section ""cstring" . Text.Printf.$tc'C:PrintfType3_bytes" {
     Text.Printf.$tc'C:PrintfType3_bytes:
         I8[] [39,67,58,80,114,105,110,116,102,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.286023247 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType2_closure" {
     Text.Printf.$tc'C:PrintfType2_closure:
         const GHC.Types.TrNameS_con_info;
         const Text.Printf.$tc'C:PrintfType3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.288273678 UTC

[section ""data" . Text.Printf.$tc'C:PrintfType_closure" {
     Text.Printf.$tc'C:PrintfType_closure:
         const GHC.Types.TyCon_con_info;
         const Text.Printf.$trModule_closure+1;
         const Text.Printf.$tc'C:PrintfType2_closure+1;
         const Text.Printf.$tc'C:PrintfType1_closure+4;
         const 6199067271817529220;
         const 10070277982064886839;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.290116745 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar24_bytes" {
     Text.Printf.$fPrintfArgChar24_bytes:
         I8[] [104,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.292091024 UTC

[section ""data" . Text.Printf.$fPrintfArgChar23_closure" {
     Text.Printf.$fPrintfArgChar23_closure:
         const Text.Printf.$fPrintfArgChar23_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar23_entry() //  [R1]
         { info_tbl: [(ccjyu,
                       label: Text.Printf.$fPrintfArgChar23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjyu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjyv; else goto ccjyw;
       ccjyv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjyw: // global
           (_ccjyr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjyr::I64 == 0) goto ccjyt; else goto ccjys;
       ccjyt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjys: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjyr::I64;
           R2 = Text.Printf.$fPrintfArgChar24_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.296842329 UTC

[section ""data" . sat_sciEW_closure" {
     sat_sciEW_closure:
         const GHC.Types.I#_con_info;
         const 128;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.298553573 UTC

[section ""data" . sat_sciEX_closure" {
     sat_sciEX_closure:
         const :_con_info;
         const sat_sciEW_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.300458879 UTC

[section ""data" . Text.Printf.$fPrintfArgChar22_closure" {
     Text.Printf.$fPrintfArgChar22_closure:
         const Text.Printf.$fPrintfArgChar22_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar22_entry() //  [R1]
         { info_tbl: [(ccjyN,
                       label: Text.Printf.$fPrintfArgChar22_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjyN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjyO; else goto ccjyP;
       ccjyO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjyP: // global
           (_ccjyK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjyK::I64 == 0) goto ccjyM; else goto ccjyL;
       ccjyM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjyL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjyK::I64;
           R3 = sat_sciEX_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.304551797 UTC

[section ""data" . Text.Printf.$fPrintfArgChar21_closure" {
     Text.Printf.$fPrintfArgChar21_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar23_closure;
         const Text.Printf.$fPrintfArgChar22_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.306318063 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar20_bytes" {
     Text.Printf.$fPrintfArgChar20_bytes:
         I8[] [104]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.308301195 UTC

[section ""data" . Text.Printf.$fPrintfArgChar19_closure" {
     Text.Printf.$fPrintfArgChar19_closure:
         const Text.Printf.$fPrintfArgChar19_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar19_entry() //  [R1]
         { info_tbl: [(ccjz7,
                       label: Text.Printf.$fPrintfArgChar19_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjz7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjz8; else goto ccjz9;
       ccjz8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjz9: // global
           (_ccjz4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjz4::I64 == 0) goto ccjz6; else goto ccjz5;
       ccjz6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjz5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjz4::I64;
           R2 = Text.Printf.$fPrintfArgChar20_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.312439959 UTC

[section ""data" . sat_sciEY_closure" {
     sat_sciEY_closure:
         const GHC.Types.I#_con_info;
         const 32768;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.314184011 UTC

[section ""data" . sat_sciEZ_closure" {
     sat_sciEZ_closure:
         const :_con_info;
         const sat_sciEY_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.316213636 UTC

[section ""data" . Text.Printf.$fPrintfArgChar18_closure" {
     Text.Printf.$fPrintfArgChar18_closure:
         const Text.Printf.$fPrintfArgChar18_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar18_entry() //  [R1]
         { info_tbl: [(ccjzq,
                       label: Text.Printf.$fPrintfArgChar18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjzq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjzr; else goto ccjzs;
       ccjzr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjzs: // global
           (_ccjzn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjzn::I64 == 0) goto ccjzp; else goto ccjzo;
       ccjzp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjzo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjzn::I64;
           R3 = sat_sciEZ_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.321225455 UTC

[section ""data" . Text.Printf.$fPrintfArgChar17_closure" {
     Text.Printf.$fPrintfArgChar17_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar19_closure;
         const Text.Printf.$fPrintfArgChar18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.322938499 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar16_bytes" {
     Text.Printf.$fPrintfArgChar16_bytes:
         I8[] [108]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.324850501 UTC

[section ""data" . Text.Printf.$fPrintfArgChar15_closure" {
     Text.Printf.$fPrintfArgChar15_closure:
         const Text.Printf.$fPrintfArgChar15_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar15_entry() //  [R1]
         { info_tbl: [(ccjzK,
                       label: Text.Printf.$fPrintfArgChar15_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjzK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjzL; else goto ccjzM;
       ccjzL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjzM: // global
           (_ccjzH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjzH::I64 == 0) goto ccjzJ; else goto ccjzI;
       ccjzJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjzI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjzH::I64;
           R2 = Text.Printf.$fPrintfArgChar16_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.329335018 UTC

[section ""data" . sat_sciF1_closure" {
     sat_sciF1_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.331060497 UTC

[section ""data" . sat_sciF2_closure" {
     sat_sciF2_closure:
         const :_con_info;
         const sat_sciF1_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.332722009 UTC

[section ""data" . sat_sciF0_closure" {
     sat_sciF0_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.334340835 UTC

[section ""data" . sat_sciF3_closure" {
     sat_sciF3_closure:
         const :_con_info;
         const sat_sciF0_closure+1;
         const sat_sciF2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.336337369 UTC

[section ""data" . Text.Printf.$fPrintfArgChar14_closure" {
     Text.Printf.$fPrintfArgChar14_closure:
         const Text.Printf.$fPrintfArgChar14_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar14_entry() //  [R1]
         { info_tbl: [(ccjA5,
                       label: Text.Printf.$fPrintfArgChar14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjA5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjA6; else goto ccjA7;
       ccjA6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjA7: // global
           (_ccjA2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjA2::I64 == 0) goto ccjA4; else goto ccjA3;
       ccjA4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjA3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjA2::I64;
           R3 = sat_sciF3_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.340448887 UTC

[section ""data" . Text.Printf.$fPrintfArgChar13_closure" {
     Text.Printf.$fPrintfArgChar13_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar15_closure;
         const Text.Printf.$fPrintfArgChar14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.342382899 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar12_bytes" {
     Text.Printf.$fPrintfArgChar12_bytes:
         I8[] [108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.344282169 UTC

[section ""data" . Text.Printf.$fPrintfArgChar11_closure" {
     Text.Printf.$fPrintfArgChar11_closure:
         const Text.Printf.$fPrintfArgChar11_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar11_entry() //  [R1]
         { info_tbl: [(ccjAp,
                       label: Text.Printf.$fPrintfArgChar11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjAp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjAq; else goto ccjAr;
       ccjAq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjAr: // global
           (_ccjAm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjAm::I64 == 0) goto ccjAo; else goto ccjAn;
       ccjAo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjAn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjAm::I64;
           R2 = Text.Printf.$fPrintfArgChar12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.348233831 UTC

[section ""data" . sat_sciF6_closure" {
     sat_sciF6_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.350521404 UTC

[section ""data" . sat_sciF7_closure" {
     sat_sciF7_closure:
         const :_con_info;
         const sat_sciF6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.352276638 UTC

[section ""data" . sat_sciF5_closure" {
     sat_sciF5_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.353986365 UTC

[section ""data" . sat_sciF8_closure" {
     sat_sciF8_closure:
         const :_con_info;
         const sat_sciF5_closure+1;
         const sat_sciF7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.355762506 UTC

[section ""data" . sat_sciF4_closure" {
     sat_sciF4_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.357841069 UTC

[section ""data" . sat_sciF9_closure" {
     sat_sciF9_closure:
         const :_con_info;
         const sat_sciF4_closure+1;
         const sat_sciF8_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.359898433 UTC

[section ""data" . Text.Printf.$fPrintfArgChar7_closure" {
     Text.Printf.$fPrintfArgChar7_closure:
         const Text.Printf.$fPrintfArgChar7_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar7_entry() //  [R1]
         { info_tbl: [(ccjAM,
                       label: Text.Printf.$fPrintfArgChar7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjAM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjAN; else goto ccjAO;
       ccjAN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjAO: // global
           (_ccjAJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjAJ::I64 == 0) goto ccjAL; else goto ccjAK;
       ccjAL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjAK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjAJ::I64;
           R3 = sat_sciF9_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.364148408 UTC

[section ""data" . Text.Printf.$fPrintfArgChar10_closure" {
     Text.Printf.$fPrintfArgChar10_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar11_closure;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.365919726 UTC

[section ""cstring" . Text.Printf.$fPrintfArgChar9_bytes" {
     Text.Printf.$fPrintfArgChar9_bytes:
         I8[] [76]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.367822985 UTC

[section ""data" . Text.Printf.$fPrintfArgChar8_closure" {
     Text.Printf.$fPrintfArgChar8_closure:
         const Text.Printf.$fPrintfArgChar8_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar8_entry() //  [R1]
         { info_tbl: [(ccjB6,
                       label: Text.Printf.$fPrintfArgChar8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjB6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjB7; else goto ccjB8;
       ccjB7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjB8: // global
           (_ccjB3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjB3::I64 == 0) goto ccjB5; else goto ccjB4;
       ccjB5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjB4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjB3::I64;
           R2 = Text.Printf.$fPrintfArgChar9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.37176074 UTC

[section ""data" . Text.Printf.$fPrintfArgChar6_closure" {
     Text.Printf.$fPrintfArgChar6_closure:
         const (,)_con_info;
         const Text.Printf.$fPrintfArgChar8_closure;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.3735519 UTC

[section ""data" . Text.Printf.$fPrintfArgChar5_closure" {
     Text.Printf.$fPrintfArgChar5_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.375304101 UTC

[section ""data" . Text.Printf.$fPrintfArgChar4_closure" {
     Text.Printf.$fPrintfArgChar4_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar10_closure+1;
         const Text.Printf.$fPrintfArgChar5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.377107831 UTC

[section ""data" . Text.Printf.$fPrintfArgChar3_closure" {
     Text.Printf.$fPrintfArgChar3_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar13_closure+1;
         const Text.Printf.$fPrintfArgChar4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.379859095 UTC

[section ""data" . Text.Printf.$fPrintfArgChar2_closure" {
     Text.Printf.$fPrintfArgChar2_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar17_closure+1;
         const Text.Printf.$fPrintfArgChar3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.381608268 UTC

[section ""data" . Text.Printf.intModifierMap_closure" {
     Text.Printf.intModifierMap_closure:
         const :_con_info;
         const Text.Printf.$fPrintfArgChar21_closure+1;
         const Text.Printf.$fPrintfArgChar2_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.383420451 UTC

[section ""cstring" . lvl7_rccc6_bytes" {
     lvl7_rccc6_bytes:
         I8[] [112,114,105,110,116,102,58,32,117,110,107,110,111,119,110,32,102,111,114,109,97,116,32,109,111,100,105,102,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.38556493 UTC

[section ""data" . Text.Printf.$fPrintfArgInt2_closure" {
     Text.Printf.$fPrintfArgInt2_closure:
         const Text.Printf.$fPrintfArgInt2_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgInt2_entry() //  [R1]
         { info_tbl: [(ccjBw,
                       label: Text.Printf.$fPrintfArgInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjBw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccjBx; else goto ccjBy;
       ccjBx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjBy: // global
           (_ccjBr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjBr::I64 == 0) goto ccjBt; else goto ccjBs;
       ccjBt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjBs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjBr::I64;
           I64[Sp - 24] = block_ccjBu_info;
           R2 = lvl7_rccc6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccjBu() //  [R1]
         { info_tbl: [(ccjBu,
                       label: block_ccjBu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjBu: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.391603487 UTC

[section ""data" . Text.Printf.$wfixupMods_closure" {
     Text.Printf.$wfixupMods_closure:
         const Text.Printf.$wfixupMods_info;
         const 0;
 },
 Text.Printf.$wfixupMods_entry() //  [R2, R3]
         { info_tbl: [(ccjBZ,
                       label: Text.Printf.$wfixupMods_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjBZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjC0; else goto ccjC1;
       ccjC0: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$wfixupMods_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccjC1: // global
           I64[Sp - 16] = block_ccjBS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjCk; else goto ccjBT;
       ucjCk: // global
           call _ccjBS(R1) args: 0, res: 0, upd: 0;
       ccjBT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjBS() //  [R1]
         { info_tbl: [(ccjBS,
                       label: block_ccjBS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjBS: // global
           if (R1 & 7 == 1) goto ccjBW; else goto ccjBX;
       ccjBW: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccjBX: // global
           I64[Sp + 8] = block_ccjC7_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           Sp = Sp + 8;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjC7() //  [R1]
         { info_tbl: [(ccjC7,
                       label: block_ccjC7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjC7: // global
           if (R1 & 7 == 1) goto ccjCe; else goto ccjCi;
       ccjCe: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccjCi: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.3998269 UTC

[section ""data" . Text.Printf.fixupMods_closure" {
     Text.Printf.fixupMods_closure:
         const Text.Printf.fixupMods_info;
         const 0;
 },
 Text.Printf.fixupMods_entry() //  [R2, R3]
         { info_tbl: [(ccjCP,
                       label: Text.Printf.fixupMods_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjCP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjCQ; else goto ccjCR;
       ccjCQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.fixupMods_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccjCR: // global
           I64[Sp - 16] = block_ccjCM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjCV; else goto ccjCN;
       ucjCV: // global
           call _ccjCM(R1) args: 0, res: 0, upd: 0;
       ccjCN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjCM() //  [R1]
         { info_tbl: [(ccjCM,
                       label: block_ccjCM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjCM: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 47];
           Sp = Sp + 16;
           call Text.Printf.$wfixupMods_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.407167509 UTC

[section ""data" . Text.Printf.$wparseIntFormat_closure" {
     Text.Printf.$wparseIntFormat_closure:
         const Text.Printf.$wparseIntFormat_info;
         const 0;
 },
 go_sciFt_entry() //  [R1, R2]
         { info_tbl: [(ccjDm,
                       label: go_sciFt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjDm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccjDn; else goto ccjDo;
       ccjDn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccjDo: // global
           I64[Sp - 24] = block_ccjDf_info;
           _sciFt::P64 = R1;
           _sciFs::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sciFs::P64;
           P64[Sp - 8] = _sciFt::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucjFd; else goto ccjDg;
       ucjFd: // global
           call _ccjDf(R1) args: 0, res: 0, upd: 0;
       ccjDg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjDf() //  [R1]
         { info_tbl: [(ccjDf,
                       label: block_ccjDf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjDf: // global
           if (R1 & 7 == 1) goto ucjF5; else goto ccjDk;
       ucjF5: // global
           Sp = Sp + 24;
           call _ccjDO() args: 0, res: 0, upd: 0;
       ccjDk: // global
           I64[Sp - 8] = block_ccjDu_info;
           _sciFx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sciFx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucjFb; else goto ccjDw;
       ucjFb: // global
           call _ccjDu(R1) args: 0, res: 0, upd: 0;
       ccjDw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjDu() //  [R1]
         { info_tbl: [(ccjDu,
                       label: block_ccjDu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjDu: // global
           _sciFx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccjDA_info;
           R2 = _sciFx::P64;
           _sciFz::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sciFz::P64;
           Sp = Sp + 8;
           call go_sciFt_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjDA() //  [R1]
         { info_tbl: [(ccjDA,
                       label: block_ccjDA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjDA: // global
           if (R1 & 7 == 1) goto ccjDI; else goto ccjEm;
       ccjDI: // global
           _sciFs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccjDF_info;
           R4 = _sciFs::P64;
           R3 = P64[Sp + 16];
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp + 8;
           call Data.OldList.stripPrefix_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
       ccjEm: // global
           I64[Sp - 8] = block_ccjEb_info;
           _sciFB::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _sciFB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucjFe; else goto ccjEc;
       ucjFe: // global
           call _ccjEb(R1) args: 0, res: 0, upd: 0;
       ccjEc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjDF() //  [R1]
         { info_tbl: [(ccjDF,
                       label: block_ccjDF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjDF: // global
           if (R1 & 7 == 1) goto ucjF9; else goto ccjDT;
       ucjF9: // global
           Sp = Sp + 16;
           call _ccjDO() args: 0, res: 0, upd: 0;
       ccjDT: // global
           I64[Sp] = block_ccjDR_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucjFf; else goto ccjDU;
       ucjFf: // global
           call _ccjDR(R1) args: 0, res: 0, upd: 0;
       ccjDU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjDO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjDO: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjDR() //  [R1]
         { info_tbl: [(ccjDR,
                       label: block_ccjDR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjDR: // global
           if (R1 & 7 == 1) goto ucjFa; else goto ccjE5;
       ucjFa: // global
           Sp = Sp + 16;
           call _ccjEQ() args: 0, res: 0, upd: 0;
       ccjE5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccjE8; else goto ccjE7;
       ccjE8: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjE7: // global
           _sciFF::P64 = P64[R1 + 6];
           _sciFG::P64 = P64[R1 + 14];
           I64[Hp - 40] = Text.Printf.FormatParse_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sciFF::P64;
           P64[Hp - 16] = _sciFG::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjEb() //  [R1]
         { info_tbl: [(ccjEb,
                       label: block_ccjEb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjEb: // global
           I64[Sp] = block_ccjEg_info;
           R3 = 0;
           R2 = P64[R1 + 7];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjEg() //  [R1]
         { info_tbl: [(ccjEg,
                       label: block_ccjEg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjEg: // global
           I64[Sp - 8] = block_ccjEk_info;
           R3 = 0;
           R2 = P64[Sp + 24];
           I64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjEk() //  [R1]
         { info_tbl: [(ccjEk,
                       label: block_ccjEk_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjEk: // global
           if (%MO_S_Lt_W64(I64[Sp + 8], R1)) goto ccjEy; else goto ucjF6;
       ccjEy: // global
           I64[Sp + 8] = block_ccjEw_info;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp + 8;
           call Data.OldList.stripPrefix_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
       ucjF6: // global
           Sp = Sp + 16;
           call _ccjEZ() args: 0, res: 0, upd: 0;
     }
 },
 _ccjEw() //  [R1]
         { info_tbl: [(ccjEw,
                       label: block_ccjEw_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjEw: // global
           if (R1 & 7 == 1) goto ucjF7; else goto ccjEJ;
       ucjF7: // global
           Sp = Sp + 8;
           call _ccjEZ() args: 0, res: 0, upd: 0;
       ccjEJ: // global
           I64[Sp + 16] = block_ccjEH_info;
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ucjFj; else goto ccjEK;
       ucjFj: // global
           call _ccjEH(R1) args: 0, res: 0, upd: 0;
       ccjEK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjEH() //  [R1]
         { info_tbl: [(ccjEH,
                       label: block_ccjEH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjEH: // global
           if (R1 & 7 == 1) goto ucjF8; else goto ccjEV;
       ucjF8: // global
           Sp = Sp + 16;
           call _ccjEQ() args: 0, res: 0, upd: 0;
       ccjEV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccjEY; else goto ccjEX;
       ccjEY: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjEX: // global
           _sciFU::P64 = P64[R1 + 6];
           _sciFV::P64 = P64[R1 + 14];
           I64[Hp - 40] = Text.Printf.FormatParse_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sciFU::P64;
           P64[Hp - 16] = _sciFV::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 39;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjEQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjEQ: // global
           R1 = Text.Printf.errorShortFormat_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjEZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjEZ: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wparseIntFormat_entry() //  [R2]
         { info_tbl: [(ccjFs,
                       label: Text.Printf.$wparseIntFormat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjFs: // global
           _sciFs::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ccjFt; else goto ccjFu;
       ccjFu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccjFw; else goto ccjFv;
       ccjFw: // global
           HpAlloc = 16;
           goto ccjFt;
       ccjFt: // global
           R2 = _sciFs::P64;
           R1 = Text.Printf.$wparseIntFormat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccjFv: // global
           I64[Hp - 8] = go_sciFt_info;
           P64[Hp] = _sciFs::P64;
           I64[Sp - 16] = block_ccjFm_info;
           R2 = Text.Printf.intModifierMap_closure+2;
           R1 = Hp - 7;
           P64[Sp - 8] = _sciFs::P64;
           Sp = Sp - 16;
           call go_sciFt_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjFm() //  [R1]
         { info_tbl: [(ccjFm,
                       label: block_ccjFm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjFm: // global
           if (R1 & 7 == 1) goto ccjFp; else goto ccjFq;
       ccjFp: // global
           _sciFs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccjFz_info;
           R1 = _sciFs::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucjFT; else goto ccjFB;
       ucjFT: // global
           call _ccjFz(R1) args: 0, res: 0, upd: 0;
       ccjFB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccjFq: // global
           R1 = P64[R1 + 6] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjFz() //  [R1]
         { info_tbl: [(ccjFz,
                       label: block_ccjFz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjFz: // global
           if (R1 & 7 == 1) goto ccjFH; else goto ccjFL;
       ccjFH: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccjFL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccjFO; else goto ccjFN;
       ccjFO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjFN: // global
           _sciFZ::P64 = P64[R1 + 6];
           _sciG0::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sciFZ::P64;
           P64[Hp] = _sciG0::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.440564936 UTC

[section ""data" . Text.Printf.parseIntFormat_closure" {
     Text.Printf.parseIntFormat_closure:
         const Text.Printf.parseIntFormat_info;
         const 0;
 },
 Text.Printf.parseIntFormat_entry() //  [R3]
         { info_tbl: [(ccjHG,
                       label: Text.Printf.parseIntFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjHG: // global
           R2 = R3;
           call Text.Printf.$wparseIntFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.443898209 UTC

[section ""cstring" . lvl8_rccc7_bytes" {
     lvl8_rccc7_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.44608637 UTC

[section ""data" . lvl9_rccc8_closure" {
     lvl9_rccc8_closure:
         const lvl9_rccc8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rccc8_entry() //  [R1]
         { info_tbl: [(ccjHU,
                       label: lvl9_rccc8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjHU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjHV; else goto ccjHW;
       ccjHV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjHW: // global
           (_ccjHR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjHR::I64 == 0) goto ccjHT; else goto ccjHS;
       ccjHT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjHS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjHR::I64;
           R2 = lvl8_rccc7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.450072893 UTC

[section ""data" . lvl10_rccc9_closure" {
     lvl10_rccc9_closure:
         const lvl10_rccc9_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_rccc9_entry() //  [R1]
         { info_tbl: [(ccjIb,
                       label: lvl10_rccc9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjIb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjIc; else goto ccjId;
       ccjIc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjId: // global
           (_ccjI8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjI8::I64 == 0) goto ccjIa; else goto ccjI9;
       ccjIa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjI9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjI8::I64;
           R2 = Text.Printf.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.454784326 UTC

[section ""data" . lvl11_rccca_closure" {
     lvl11_rccca_closure:
         const lvl11_rccca_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rccca_entry() //  [R1]
         { info_tbl: [(ccjIs,
                       label: lvl11_rccca_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjIs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjIt; else goto ccjIu;
       ccjIt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjIu: // global
           (_ccjIp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjIp::I64 == 0) goto ccjIr; else goto ccjIq;
       ccjIr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjIq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjIp::I64;
           R2 = Text.Printf.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.458729141 UTC

[section ""cstring" . lvl12_rcccb_bytes" {
     lvl12_rcccb_bytes:
         I8[] [46,47,84,101,120,116,47,80,114,105,110,116,102,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.460611948 UTC

[section ""data" . lvl13_rcccc_closure" {
     lvl13_rcccc_closure:
         const lvl13_rcccc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rcccc_entry() //  [R1]
         { info_tbl: [(ccjIK,
                       label: lvl13_rcccc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjIK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjIL; else goto ccjIM;
       ccjIL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjIM: // global
           (_ccjIH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjIH::I64 == 0) goto ccjIJ; else goto ccjII;
       ccjIJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjII: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjIH::I64;
           R2 = lvl12_rcccb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.464971934 UTC

[section ""data" . lvl14_rcccd_closure" {
     lvl14_rcccd_closure:
         const GHC.Types.I#_con_info;
         const 323;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.466630748 UTC

[section ""data" . lvl15_rccce_closure" {
     lvl15_rccce_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.468303135 UTC

[section ""data" . lvl16_rcccf_closure" {
     lvl16_rcccf_closure:
         const GHC.Types.I#_con_info;
         const 49;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.47005964 UTC

[section ""data" . lvl17_rcccg_closure" {
     lvl17_rcccg_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl10_rccc9_closure;
         const lvl11_rccca_closure;
         const lvl13_rcccc_closure;
         const lvl14_rcccd_closure+1;
         const lvl15_rccce_closure+1;
         const lvl14_rcccd_closure+1;
         const lvl16_rcccf_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.471812292 UTC

[section ""data" . lvl18_rccch_closure" {
     lvl18_rccch_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl9_rccc8_closure;
         const lvl17_rcccg_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.47392344 UTC

[section ""data" . Text.Printf.$fPrintfArgChar1_closure" {
     Text.Printf.$fPrintfArgChar1_closure:
         const Text.Printf.$fPrintfArgChar1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgChar1_entry() //  [R1]
         { info_tbl: [(ccjJ6,
                       label: Text.Printf.$fPrintfArgChar1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjJ7; else goto ccjJ8;
       ccjJ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjJ8: // global
           (_ccjJ3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjJ3::I64 == 0) goto ccjJ5; else goto ccjJ4;
       ccjJ5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjJ4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjJ3::I64;
           R2 = lvl18_rccch_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.4785803 UTC

[section ""data" . Text.Printf.$fPrintfArgChar_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgChar_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgChar_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgChar_$cparseFormat_entry() //  [R3]
         { info_tbl: [(ccjJl,
                       label: Text.Printf.$fPrintfArgChar_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjJl: // global
           R2 = R3;
           call Text.Printf.$wparseIntFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.481928619 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble5_closure" {
     Text.Printf.$fPrintfArgDouble5_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.485293242 UTC

[section ""data" . integral_prec_rc8qj_closure" {
     integral_prec_rc8qj_closure:
         const integral_prec_rc8qj_info;
 },
 sat_sciGm_entry() //  [R1]
         { info_tbl: [(ccjKc,
                       label: sat_sciGm_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjKc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjKd; else goto ccjKe;
       ccjKd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjKe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sciGi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_sciGi_entry() //  [R1, R2]
         { info_tbl: [(ccjKi,
                       label: $wxs_sciGi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjKi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccjKm; else goto ccjKl;
       ccjKm: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccjKl: // global
           if (R2 == 1) goto ccjKh; else goto ccjKg;
       ccjKh: // global
           _sciGh::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _sciGh::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccjKg: // global
           I64[Hp - 48] = sat_sciGm_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Text.Printf.$fPrintfArgDouble5_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 integral_prec_rc8qj_entry() //  [R2, R3]
         { info_tbl: [(ccjKs,
                       label: integral_prec_rc8qj_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjKs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccjKt; else goto ccjKu;
       ccjKt: // global
           R3 = R3;
           R2 = R2;
           R1 = integral_prec_rc8qj_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccjKu: // global
           I64[Sp - 16] = block_ccjJx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjLv; else goto ccjJy;
       ucjLv: // global
           call _ccjJx(R1) args: 0, res: 0, upd: 0;
       ccjJy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjJx() //  [R1]
         { info_tbl: [(ccjJx,
                       label: block_ccjJx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjJx: // global
           if (R1 & 7 == 1) goto ccjKp; else goto ccjKq;
       ccjKp: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccjKq: // global
           I64[Sp] = block_ccjJD_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucjLs; else goto ccjJE;
       ucjLs: // global
           call _ccjJD(R1) args: 0, res: 0, upd: 0;
       ccjJE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjJD() //  [R1]
         { info_tbl: [(ccjJD,
                       label: block_ccjJD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjJD: // global
           _sciGb::I64 = I64[R1 + 7];
           if (_sciGb::I64 == 0) goto ccjKM; else goto ucjLo;
       ccjKM: // global
           I64[Sp - 8] = block_ccjKL_info;
           R1 = P64[Sp + 8];
           I64[Sp] = _sciGb::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucjLt; else goto ccjKN;
       ucjLt: // global
           call _ccjKL(R1) args: 0, res: 0, upd: 0;
       ccjKN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucjLo: // global
           I64[Sp] = _sciGb::I64;
           call _sciGc() args: 0, res: 0, upd: 0;
     }
 },
 _ccjKL() //  [R1]
         { info_tbl: [(ccjKL,
                       label: block_ccjKL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjKL: // global
           if (R1 & 7 == 1) goto ucjLp; else goto ccjKY;
       ucjLp: // global
           Sp = Sp + 8;
           call _sciGc() args: 0, res: 0, upd: 0;
       ccjKY: // global
           I64[Sp - 8] = block_ccjKW_info;
           _sciGq::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sciGq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucjLw; else goto ccjKZ;
       ucjLw: // global
           call _ccjKW(R1) args: 0, res: 0, upd: 0;
       ccjKZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjKW() //  [R1]
         { info_tbl: [(ccjKW,
                       label: block_ccjKW_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjKW: // global
           if (I64[R1 + 7] == 48) goto ccjLa; else goto ucjLq;
       ccjLa: // global
           _sciGq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccjL9_info;
           R1 = _sciGq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucjLy; else goto ccjLb;
       ucjLy: // global
           call _ccjL9(R1) args: 0, res: 0, upd: 0;
       ccjLb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucjLq: // global
           Sp = Sp + 16;
           call _sciGc() args: 0, res: 0, upd: 0;
     }
 },
 _ccjL9() //  [R1]
         { info_tbl: [(ccjL9,
                       label: block_ccjL9_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjL9: // global
           if (R1 & 7 == 1) goto ccjLh; else goto ucjLr;
       ccjLh: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ucjLr: // global
           Sp = Sp + 8;
           call _sciGc() args: 0, res: 0, upd: 0;
     }
 },
 _sciGc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sciGc: // global
           I64[Sp - 8] = block_ccjJN_info;
           R3 = 0;
           R2 = P64[Sp + 8];
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjJN() //  [R1]
         { info_tbl: [(ccjJN,
                       label: block_ccjJN_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjJN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccjKC; else goto ccjKB;
       ccjKC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccjKB: // global
           _sciG7::P64 = P64[Sp + 16];
           _sciGf::I64 = I64[Sp + 8] - R1;
           if (%MO_S_Ge_W64(0, _sciGf::I64)) goto ccjKE; else goto ccjKF;
       ccjKE: // global
           Hp = Hp - 40;
           R1 = _sciG7::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccjKF: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Text.Printf.$fPrintfArgDouble5_closure+1;
           P64[Hp - 16] = _sciG7::P64;
           I64[Hp - 8] = $wxs_sciGi_info;
           P64[Hp] = Hp - 30;
           R2 = _sciGf::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call $wxs_sciGi_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.507044542 UTC

[section ""cstring" . lvl19_rccci_bytes" {
     lvl19_rccci_bytes:
         I8[] [84,101,120,116,47,80,114,105,110,116,102,46,104,115,58,55,49,52,58,55,45,51,57,124,40,34,34,44,32,115,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.50910341 UTC

[section ""data" . lvl20_rcccj_closure" {
     lvl20_rcccj_closure:
         const lvl20_rcccj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_rcccj_entry() //  [R1]
         { info_tbl: [(ccjMO,
                       label: lvl20_rcccj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjMO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjMP; else goto ccjMQ;
       ccjMP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjMQ: // global
           (_ccjML::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjML::I64 == 0) goto ccjMN; else goto ccjMM;
       ccjMN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjMM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjML::I64;
           R2 = lvl19_rccci_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.513810319 UTC

[section ""data" . Text.Printf.formatChar2_closure" {
     Text.Printf.formatChar2_closure:
         const Text.Printf.formatChar2_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.formatChar2_entry() //  [R1]
         { info_tbl: [(ccjN5,
                       label: Text.Printf.formatChar2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjN5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjN6; else goto ccjN7;
       ccjN6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjN7: // global
           (_ccjN2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjN2::I64 == 0) goto ccjN4; else goto ccjN3;
       ccjN4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjN3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjN2::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.518098826 UTC

[section ""data" . sat_sciGx_closure" {
     sat_sciGx_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.519926679 UTC

[section ""data" . sat_sciGy_closure" {
     sat_sciGy_closure:
         const :_con_info;
         const sat_sciGx_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.522062071 UTC

[section ""data" . lvl21_rccck_closure" {
     lvl21_rccck_closure:
         const lvl21_rccck_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_rccck_entry() //  [R1]
         { info_tbl: [(ccjNq,
                       label: lvl21_rccck_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjNq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjNr; else goto ccjNs;
       ccjNr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjNs: // global
           (_ccjNn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccjNn::I64 == 0) goto ccjNp; else goto ccjNo;
       ccjNp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccjNo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccjNn::I64;
           R3 = sat_sciGy_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.53033457 UTC

[section ""data" . $wfmtu_rcccl_closure" {
     $wfmtu_rcccl_closure:
         const $wfmtu_rcccl_info;
         const 0;
 },
 sat_sciGN_entry() //  [R1]
         { info_tbl: [(ccjO9,
                       label: sat_sciGN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjO9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccjOa; else goto ccjOb;
       ccjOa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjOb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 24];
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = P64[R1 + 16];
           R3 = GHC.Show.$fShowInteger_closure;
           R2 = GHC.Real.$fIntegralInteger_closure;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 32, res: 0, upd: 24;
     }
 },
 sat_sciGS_entry() //  [R1]
         { info_tbl: [(ccjOs,
                       label: sat_sciGS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjOs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjOt; else goto ccjOu;
       ccjOt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjOu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 fmtu'_sciGF_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccjOC,
                       label: fmtu'_sciGF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjOC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccjOD; else goto ucjPH;
       ccjOD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ucjPH: // global
           P64[Sp - 32] = R1;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call _ccjNN() args: 0, res: 0, upd: 0;
     }
 },
 _ccjNN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjNN: // global
           _sciGz::P64 = P64[P64[Sp] + 5];
           I64[Sp - 8] = block_ccjOv_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sciGz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucjPO; else goto ccjOw;
       ucjPO: // global
           call _ccjOv(R1) args: 0, res: 0, upd: 0;
       ccjOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjOv() //  [R1]
         { info_tbl: [(ccjOv,
                       label: block_ccjOv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjOv: // global
           if (R1 & 7 == 1) goto ucjPI; else goto ccjOA;
       ucjPI: // global
           Sp = Sp + 8;
           call _sciGJ() args: 0, res: 0, upd: 0;
       ccjOA: // global
           I64[Sp - 8] = block_ccjPe_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = P64[Sp + 32];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjPe() //  [R1]
         { info_tbl: [(ccjPe,
                       label: block_ccjPe_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjPe: // global
           if (R1 == 1) goto ccjPy; else goto ucjPJ;
       ccjPy: // global
           _sciGU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccjPo_info;
           R3 = _sciGU::P64;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ucjPJ: // global
           Sp = Sp + 16;
           call _sciGJ() args: 0, res: 0, upd: 0;
     }
 },
 _ccjPo() //  [R1]
         { info_tbl: [(ccjPo,
                       label: block_ccjPo_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjPo: // global
           I64[Sp] = block_ccjPs_info;
           R2 = R1;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjPs() //  [R1]
         { info_tbl: [(ccjPs,
                       label: block_ccjPs_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjPs: // global
           I64[Sp] = block_ccjPw_info;
           R3 = P64[Sp + 32];
           R2 = R1;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjPw() //  [R1]
         { info_tbl: [(ccjPw,
                       label: block_ccjPw_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjPw: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = GHC.Base.Nothing_closure+1;
           P64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _ccjNN() args: 0, res: 0, upd: 0;
     }
 },
 _sciGJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sciGJ: // global
           I64[Sp - 8] = block_ccjNV_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucjPW; else goto ccjNW;
       ucjPW: // global
           call _ccjNV(R1) args: 0, res: 0, upd: 0;
       ccjNW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjNV() //  [R1]
         { info_tbl: [(ccjNV,
                       label: block_ccjNV_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjNV: // global
           _sciGI::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccjOI; else goto ccjOT;
       ccjOI: // global
           I64[Sp + 16] = block_ccjO0_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sciGI::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ccjOT: // global
           I64[Sp] = block_ccjOe_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sciGI::P64;
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjO0() //  [R1]
         { info_tbl: [(ccjO0,
                       label: block_ccjO0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjO0: // global
           if (R1 == 1) goto ccjOO; else goto ucjPN;
       ccjOO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccjOR; else goto ccjOQ;
       ccjOR: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccjOQ: // global
           I64[Hp - 40] = sat_sciGN_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ucjPN: // global
           Sp = Sp + 24;
           call _ccjP3() args: 0, res: 0, upd: 0;
     }
 },
 _ccjOe() //  [R1]
         { info_tbl: [(ccjOe,
                       label: block_ccjOe_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjOe: // global
           if (R1 == 1) goto ccjOZ; else goto ucjPL;
       ccjOZ: // global
           I64[Sp + 16] = block_ccjOj_info;
           R4 = P64[Sp + 32];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call fmtu'_sciGF_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ucjPL: // global
           Sp = Sp + 40;
           call _ccjP3() args: 0, res: 0, upd: 0;
     }
 },
 _ccjOj() //  [R1]
         { info_tbl: [(ccjOj,
                       label: block_ccjOj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjOj: // global
           if (R1 & 7 == 1) goto ucjPM; else goto ccjP5;
       ucjPM: // global
           Sp = Sp + 24;
           call _ccjP3() args: 0, res: 0, upd: 0;
       ccjP5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccjP8; else goto ccjP7;
       ccjP8: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjP7: // global
           _sciGR::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sciGS_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sciGR::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjP3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjP3: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 s_sciH3_entry() //  [R1]
         { info_tbl: [(ccjQc,
                       label: s_sciH3_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjQc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccjQd; else goto ccjQe;
       ccjQd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjQe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccjQ3_info;
           R6 = P64[R1 + 40];
           R5 = P64[R1 + 32];
           R4 = P64[R1 + 24];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccjQ3() //  [R1, R2]
         { info_tbl: [(ccjQ3,
                       label: block_ccjQ3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjQ3: // global
           I64[Sp - 8] = block_ccjQ5_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucjQm; else goto ccjQ6;
       ucjQm: // global
           call _ccjQ5(R1) args: 0, res: 0, upd: 0;
       ccjQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccjQ5() //  [R1]
         { info_tbl: [(ccjQ5,
                       label: block_ccjQ5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjQ5: // global
           if (R1 & 7 == 1) goto ccjQ9; else goto ccjQa;
       ccjQ9: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccjQa: // global
           R1 = lvl20_rcccj_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wfmtu_rcccl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccjQr,
                       label: $wfmtu_rcccl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjQr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccjQs; else goto ccjQt;
       ccjQs: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wfmtu_rcccl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccjQt: // global
           I64[Sp - 40] = block_ccjNG_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucjRO; else goto ccjNH;
       ucjRO: // global
           call _ccjNG(R1) args: 0, res: 0, upd: 0;
       ccjNH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjNG() //  [R1]
         { info_tbl: [(ccjNG,
                       label: block_ccjNG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjNG: // global
           _sciGz::P64 = P64[Sp + 8];
           _sciGB::P64 = P64[Sp + 16];
           _sciGC::P64 = P64[Sp + 24];
           _sciGD::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccjQo; else goto ccjQp;
       ccjQo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccjQx; else goto ccjQw;
       ccjQx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjQw: // global
           I64[Hp - 8] = fmtu'_sciGF_info;
           P64[Hp] = _sciGz::P64;
           I64[Sp + 32] = block_ccjQu_info;
           R4 = _sciGD::P64;
           R3 = _sciGC::P64;
           R2 = _sciGB::P64;
           R1 = Hp - 5;
           Sp = Sp + 32;
           call fmtu'_sciGF_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ccjQp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccjQL; else goto ccjQK;
       ccjQL: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjQK: // global
           _sciH2::P64 = P64[R1 + 6];
           I64[Hp - 40] = s_sciH3_info;
           P64[Hp - 24] = _sciGz::P64;
           P64[Hp - 16] = _sciGB::P64;
           P64[Hp - 8] = _sciGC::P64;
           P64[Hp] = _sciGD::P64;
           I64[Sp + 24] = block_ccjQI_info;
           R1 = _sciH2::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto ucjRN; else goto ccjQM;
       ucjRN: // global
           call _ccjQI(R1) args: 0, res: 0, upd: 0;
       ccjQM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjQu() //  [R1]
         { info_tbl: [(ccjQu,
                       label: block_ccjQu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjQu: // global
           if (R1 & 7 == 1) goto ccjQD; else goto ccjQH;
       ccjQD: // global
           R1 = Text.Printf.errorBadArgument_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccjQH: // global
           R2 = P64[R1 + 6];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjQI() //  [R1]
         { info_tbl: [(ccjQI,
                       label: block_ccjQI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjQI: // global
           if (R1 & 7 == 1) goto ccjQS; else goto ccjQX;
       ccjQS: // global
           R2 = P64[Sp + 8];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccjQX: // global
           I64[Sp - 16] = block_ccjQV_info;
           _sciHb::P64 = R1;
           _sciHd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciHd::P64;
           P64[Sp] = _sciHb::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjRP; else goto ccjQY;
       ucjRP: // global
           call _ccjQV(R1) args: 0, res: 0, upd: 0;
       ccjQY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjQV() //  [R1]
         { info_tbl: [(ccjQV,
                       label: block_ccjQV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjQV: // global
           if (I64[R1 + 7] == 48) goto ccjR9; else goto ucjRL;
       ccjR9: // global
           _sciHd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccjR8_info;
           R1 = _sciHd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucjRQ; else goto ccjRa;
       ucjRQ: // global
           call _ccjR8(R1) args: 0, res: 0, upd: 0;
       ccjRa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucjRL: // global
           Sp = Sp + 16;
           call _ccjRG() args: 0, res: 0, upd: 0;
     }
 },
 _ccjR8() //  [R1]
         { info_tbl: [(ccjR8,
                       label: block_ccjR8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjR8: // global
           if (R1 & 7 == 1) goto ccjRh; else goto ucjRM;
       ccjRh: // global
           I64[Sp] = block_ccjRe_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ucjRS; else goto ccjRi;
       ucjRS: // global
           call _ccjRe(R1) args: 0, res: 0, upd: 0;
       ccjRi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ucjRM: // global
           Sp = Sp + 8;
           call _ccjRG() args: 0, res: 0, upd: 0;
     }
 },
 _ccjRe() //  [R1]
         { info_tbl: [(ccjRe,
                       label: block_ccjRe_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjRe: // global
           if (R1 & 7 == 1) goto ccjRo; else goto ccjRt;
       ccjRo: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccjRt: // global
           I64[Sp] = block_ccjRr_info;
           _sciHi::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sciHi::P64;
           if (R1 & 7 != 0) goto ucjRU; else goto ccjRu;
       ucjRU: // global
           call _ccjRr(R1) args: 0, res: 0, upd: 0;
       ccjRu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjRr() //  [R1]
         { info_tbl: [(ccjRr,
                       label: block_ccjRr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjRr: // global
           _sciHi::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 48) goto ccjRC; else goto ccjRB;
       ccjRC: // global
           R2 = _sciHi::P64;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccjRB: // global
           R2 = _sciHi::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccjRG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjRG: // global
           R2 = P64[Sp + 8];
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.585283045 UTC

[section ""data" . $wfmti_rcccm_closure" {
     $wfmti_rcccm_closure:
         const $wfmti_rcccm_info;
         const 0;
 },
 sat_sciHx_entry() //  [R1]
         { info_tbl: [(ccjUV,
                       label: sat_sciHx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjUV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccjUW; else goto ccjUX;
       ccjUW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjUX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccjUS_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 24];
           R2 = 0;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccjUS() //  [R1, R2]
         { info_tbl: [(ccjUS,
                       label: block_ccjUS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjUS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccjV0; else goto ccjUZ;
       ccjV0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccjUZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 14;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciHD_entry() //  [R1]
         { info_tbl: [(ccjV9,
                       label: sat_sciHD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjV9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccjVf; else goto ccjVg;
       ccjVf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjVg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccjV7_info;
           R2 = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccjV7() //  [R1]
         { info_tbl: [(ccjV7,
                       label: block_ccjV7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjV7: // global
           I64[Sp] = block_ccjVc_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccjVc() //  [R1, R2]
         { info_tbl: [(ccjVc,
                       label: block_ccjVc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjVc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccjVk; else goto ccjVj;
       ccjVk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccjVj: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 14;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call integral_prec_rc8qj_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucjVx_srtd" {
     ucjVx_srtd:
         const Scjc4_srt+104;
         const 33;
         const 6509559809;
 },
 $wfmti_rcccm_entry() //  [R2, R3]
         { info_tbl: [(ccjVo,
                       label: $wfmti_rcccm_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjVo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccjVp; else goto ccjVq;
       ccjVp: // global
           R3 = R3;
           R2 = R2;
           R1 = $wfmti_rcccm_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccjVq: // global
           I64[Sp - 24] = block_ccjUK_info;
           _sciHr::P64 = R3;
           R3 = Text.Printf.formatChar2_closure;
           _sciHq::P64 = R2;
           R2 = _sciHr::P64;
           P64[Sp - 16] = _sciHq::P64;
           P64[Sp - 8] = _sciHr::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjUK() //  [R1]
         { info_tbl: [(ccjUK,
                       label: block_ccjUK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjUK: // global
           _sciHq::P64 = P64[Sp + 8];
           _sciHr::P64 = P64[Sp + 16];
           if (R1 == 1) goto ccjVn; else goto ccjVm;
       ccjVn: // global
           Hp = Hp + 32;
           _sciHs::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccjVw; else goto ccjVv;
       ccjVv: // global
           I64[Hp - 24] = sat_sciHD_info;
           P64[Hp - 8] = _sciHq::P64;
           P64[Hp] = _sciHr::P64;
           R2 = Hp - 24;
           R1 = Text.Printf.$fPrintfArgDouble8_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ccjVm: // global
           Hp = Hp + 32;
           _sciHs::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccjVw; else goto ccjVs;
       ccjVw: // global
           HpAlloc = 32;
           R1 = _sciHs::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccjVs: // global
           I64[Hp - 24] = sat_sciHx_info;
           P64[Hp - 8] = _sciHq::P64;
           P64[Hp] = _sciHr::P64;
           R2 = Hp - 24;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.602453242 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble6_closure" {
     Text.Printf.$fPrintfArgDouble6_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.607552767 UTC

[section ""data" . Text.Printf.$wadjust_closure" {
     Text.Printf.$wadjust_closure:
         const Text.Printf.$wadjust_info;
 },
 x1_sciHT_entry() //  [R1]
         { info_tbl: [(ccjX6,
                       label: x1_sciHT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjX6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccjX7; else goto ccjX8;
       ccjX7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjX8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccjWZ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucjXw; else goto ccjX0;
       ucjXw: // global
           call _ccjWZ(R1) args: 0, res: 0, upd: 0;
       ccjX0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccjWZ() //  [R1]
         { info_tbl: [(ccjWZ,
                       label: block_ccjWZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjWZ: // global
           if (R1 & 7 == 1) goto ucjXs; else goto ccjX4;
       ucjXs: // global
           Sp = Sp + 8;
           call _ccjXm() args: 0, res: 0, upd: 0;
       ccjX4: // global
           I64[Sp] = block_ccjXe_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucjXu; else goto ccjXg;
       ucjXu: // global
           call _ccjXe(R1) args: 0, res: 0, upd: 0;
       ccjXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccjXe() //  [R1]
         { info_tbl: [(ccjXe,
                       label: block_ccjXe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjXe: // global
           if (R1 & 7 == 1) goto ucjXt; else goto ccjXq;
       ucjXt: // global
           Sp = Sp + 8;
           call _ccjXm() args: 0, res: 0, upd: 0;
       ccjXq: // global
           R1 = Text.Printf.$fPrintfArgDouble5_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccjXm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjXm: // global
           R1 = Text.Printf.$fPrintfArgDouble6_closure+1;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciI2_entry() //  [R1]
         { info_tbl: [(ccjXM,
                       label: sat_sciI2_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjXM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjXN; else goto ccjXO;
       ccjXN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjXO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sciHY_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_sciHY_entry() //  [R1, R2]
         { info_tbl: [(ccjXS,
                       label: $wxs_sciHY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjXS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccjXW; else goto ccjXV;
       ccjXW: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccjXV: // global
           if (R2 == 1) goto ccjXR; else goto ccjXQ;
       ccjXR: // global
           _sciHX::P64 = P64[R1 + 15];
           Hp = Hp - 56;
           R1 = _sciHX::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccjXQ: // global
           _sciHT::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sciI2_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sciHT::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 fill_sciHI_entry() //  [R1]
         { info_tbl: [(ccjY2,
                       label: fill_sciHI_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjY2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccjY3; else goto ccjY4;
       ccjY3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjY4: // global
           I64[Sp - 32] = block_ccjWo_info;
           _sciHF::P64 = P64[R1 + 24];
           _sciHG::P64 = P64[R1 + 32];
           _sciHH::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sciHF::P64;
           P64[Sp - 16] = _sciHG::P64;
           P64[Sp - 8] = _sciHH::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucjYk; else goto ccjWp;
       ucjYk: // global
           call _ccjWo(R1) args: 0, res: 0, upd: 0;
       ccjWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjWo() //  [R1]
         { info_tbl: [(ccjWo,
                       label: block_ccjWo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjWo: // global
           if (R1 & 7 == 1) goto ccjXZ; else goto ccjY0;
       ccjXZ: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccjY0: // global
           I64[Sp] = block_ccjWu_info;
           R3 = 0;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjWu() //  [R1]
         { info_tbl: [(ccjWu,
                       label: block_ccjWu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjWu: // global
           I64[Sp] = block_ccjWy_info;
           R3 = 0;
           R2 = P64[Sp + 24];
           I64[Sp + 24] = R1;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccjWy() //  [R1]
         { info_tbl: [(ccjWy,
                       label: block_ccjWy_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjWy: // global
           I64[Sp] = block_ccjWC_info;
           _sciHM::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sciHM::I64;
           if (R1 & 7 != 0) goto ucjYj; else goto ccjWD;
       ucjYj: // global
           call _ccjWC(R1) args: 0, res: 0, upd: 0;
       ccjWD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjWC() //  [R1]
         { info_tbl: [(ccjWC,
                       label: block_ccjWC_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjWC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccjYc; else goto ccjYb;
       ccjYc: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjYb: // global
           _sciHO::I64 = I64[R1 + 7];
           _sciHP::I64 = I64[Sp + 24] + I64[Sp + 16];
           if (%MO_S_Ge_W64(_sciHP::I64,
                            _sciHO::I64)) goto ccjYg; else goto ccjYi;
       ccjYi: // global
           _sciHR::I64 = _sciHO::I64 - _sciHP::I64;
           if (%MO_S_Ge_W64(0, _sciHR::I64)) goto ccjYg; else goto ccjYh;
       ccjYg: // global
           Hp = Hp - 72;
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccjYh: // global
           I64[Hp - 64] = x1_sciHT_info;
           P64[Hp - 48] = P64[Sp + 8];
           I64[Hp - 40] = :_con_info;
           _ccjWV::P64 = Hp - 64;
           P64[Hp - 32] = _ccjWV::P64;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = $wxs_sciHY_info;
           P64[Hp - 8] = _ccjWV::P64;
           P64[Hp] = Hp - 38;
           R2 = _sciHR::I64;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call $wxs_sciHY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sciI5_entry() //  [R1]
         { info_tbl: [(ccjYz,
                       label: sat_sciI5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjYz: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sciI8_entry() //  [R1]
         { info_tbl: [(ccjYN,
                       label: sat_sciI8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjYN: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sciI9_entry() //  [R1]
         { info_tbl: [(ccjYW,
                       label: sat_sciI9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjYW: // global
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sciId_entry() //  [R1]
         { info_tbl: [(ccjZe,
                       label: sat_sciId_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjZe: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$wadjust_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccjZl,
                       label: Text.Printf.$wadjust_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjZl: // global
           _sciHH::P64 = R5;
           _sciHG::P64 = R4;
           _sciHF::P64 = R3;
           _sciHE::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto ccjZm; else goto ccjZn;
       ccjZn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccjZp; else goto ccjZo;
       ccjZp: // global
           HpAlloc = 48;
           goto ccjZm;
       ccjZm: // global
           R5 = _sciHH::P64;
           R4 = _sciHG::P64;
           R3 = _sciHF::P64;
           R2 = _sciHE::P64;
           R1 = Text.Printf.$wadjust_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccjZo: // global
           I64[Hp - 40] = fill_sciHI_info;
           P64[Hp - 24] = _sciHE::P64;
           P64[Hp - 16] = _sciHF::P64;
           P64[Hp - 8] = _sciHG::P64;
           P64[Hp] = _sciHH::P64;
           I64[Sp - 40] = block_ccjYZ_info;
           R1 = _sciHF::P64;
           P64[Sp - 32] = Hp - 40;
           P64[Sp - 24] = _sciHF::P64;
           P64[Sp - 16] = _sciHG::P64;
           P64[Sp - 8] = _sciHH::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uck02; else goto ccjZ0;
       uck02: // global
           call _ccjYZ(R1) args: 0, res: 0, upd: 0;
       ccjZ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjYZ() //  [R1]
         { info_tbl: [(ccjYZ,
                       label: block_ccjYZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjYZ: // global
           if (R1 & 7 == 1) goto ucjZW; else goto ccjZj;
       ucjZW: // global
           Sp = Sp + 8;
           call _sciI3() args: 0, res: 0, upd: 0;
       ccjZj: // global
           I64[Sp] = block_ccjZ5_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucjZZ; else goto ccjZ6;
       ucjZZ: // global
           call _ccjZ5(R1) args: 0, res: 0, upd: 0;
       ccjZ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjZ5() //  [R1]
         { info_tbl: [(ccjZ5,
                       label: block_ccjZ5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjZ5: // global
           if (R1 & 7 == 1) goto ccjZL; else goto ucjZX;
       ccjZL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccjZO; else goto ccjZN;
       ccjZO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjZN: // global
           I64[Hp - 24] = sat_sciId_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ucjZX: // global
           Sp = Sp + 8;
           call _sciI3() args: 0, res: 0, upd: 0;
     }
 },
 _sciI3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sciI3: // global
           I64[Sp - 8] = block_ccjYq_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uck03; else goto ccjYr;
       uck03: // global
           call _ccjYq(R1) args: 0, res: 0, upd: 0;
       ccjYr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjYq() //  [R1]
         { info_tbl: [(ccjYq,
                       label: block_ccjYq_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjYq: // global
           if (R1 & 7 == 1) goto ccjZs; else goto ccjZx;
       ccjZs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccjZv; else goto ccjZu;
       ccjZv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjZu: // global
           I64[Hp - 24] = sat_sciI5_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccjZx: // global
           I64[Sp] = block_ccjYE_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucjZY; else goto ccjYF;
       ucjZY: // global
           call _ccjYE(R1) args: 0, res: 0, upd: 0;
       ccjYF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjYE() //  [R1]
         { info_tbl: [(ccjYE,
                       label: block_ccjYE_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjYE: // global
           _ccjWk::P64 = P64[Sp + 8];
           _sciHG::P64 = P64[Sp + 24];
           _sciHH::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto ccjZz; else goto ccjZD;
       ccjZz: // global
           Hp = Hp + 32;
           _sciI7::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccjZG; else goto ccjZB;
       ccjZB: // global
           I64[Hp - 24] = sat_sciI8_info;
           P64[Hp - 8] = _sciHG::P64;
           P64[Hp] = _sciHH::P64;
           R3 = Hp - 24;
           R2 = _ccjWk::P64;
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccjZD: // global
           Hp = Hp + 32;
           _sciI7::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccjZG; else goto ccjZF;
       ccjZG: // global
           HpAlloc = 32;
           R1 = _sciI7::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccjZF: // global
           I64[Hp - 24] = sat_sciI9_info;
           P64[Hp - 8] = _sciHH::P64;
           P64[Hp] = _ccjWk::P64;
           R3 = Hp - 24;
           R2 = _sciHG::P64;
           Sp = Sp + 40;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.651612662 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble4_bytes" {
     Text.Printf.$fPrintfArgDouble4_bytes:
         I8[] [43]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.653720419 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble3_closure" {
     Text.Printf.$fPrintfArgDouble3_closure:
         const Text.Printf.$fPrintfArgDouble3_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble3_entry() //  [R1]
         { info_tbl: [(cck2j,
                       label: Text.Printf.$fPrintfArgDouble3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck2j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cck2k; else goto cck2l;
       cck2k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck2l: // global
           (_cck2g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cck2g::I64 == 0) goto cck2i; else goto cck2h;
       cck2i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cck2h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cck2g::I64;
           R2 = Text.Printf.$fPrintfArgDouble4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.658548914 UTC

[section ""cstring" . Text.Printf.$fPrintfArgDouble2_bytes" {
     Text.Printf.$fPrintfArgDouble2_bytes:
         I8[] [32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.660647329 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble1_closure" {
     Text.Printf.$fPrintfArgDouble1_closure:
         const Text.Printf.$fPrintfArgDouble1_info;
         const 0;
         const 0;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble1_entry() //  [R1]
         { info_tbl: [(cck2B,
                       label: Text.Printf.$fPrintfArgDouble1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck2B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cck2C; else goto cck2D;
       cck2C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck2D: // global
           (_cck2y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cck2y::I64 == 0) goto cck2A; else goto cck2z;
       cck2A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cck2z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cck2y::I64;
           R2 = Text.Printf.$fPrintfArgDouble2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.665635317 UTC

[section ""data" . Text.Printf.$wadjustSigned_closure" {
     Text.Printf.$wadjustSigned_closure:
         const Text.Printf.$wadjustSigned_info;
         const 0;
 },
 Text.Printf.$wadjustSigned_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cck2X,
                       label: Text.Printf.$wadjustSigned_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck2X: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cck2Y; else goto cck2Z;
       cck2Y: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$wadjustSigned_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cck2Z: // global
           I64[Sp - 40] = block_cck2Q_info;
           R1 = R4;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uck3K; else goto cck2R;
       uck3K: // global
           call _cck2Q(R1) args: 0, res: 0, upd: 0;
       cck2R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cck2Q() //  [R1]
         { info_tbl: [(cck2Q,
                       label: block_cck2Q_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck2Q: // global
           if (R1 & 7 == 1) goto cck2U; else goto cck2V;
       cck2U: // global
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       cck2V: // global
           I64[Sp] = block_cck35_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uck3J; else goto cck37;
       uck3J: // global
           call _cck35(R1) args: 0, res: 0, upd: 0;
       cck37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cck35() //  [R1]
         { info_tbl: [(cck35,
                       label: block_cck35_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck35: // global
           _sciIh::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cck3e; else goto cck3u;
       cck3e: // global
           I64[Sp] = block_cck3b_info;
           R1 = _sciIh::P64;
           if (R1 & 7 != 0) goto uck3L; else goto cck3f;
       uck3L: // global
           call _cck3b(R1) args: 0, res: 0, upd: 0;
       cck3f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cck3u: // global
           I64[Sp] = block_cck3s_info;
           R1 = _sciIh::P64;
           if (R1 & 7 != 0) goto uck3M; else goto cck3v;
       uck3M: // global
           call _cck3s(R1) args: 0, res: 0, upd: 0;
       cck3v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cck3b() //  [R1]
         { info_tbl: [(cck3b,
                       label: block_cck3b_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck3b: // global
           _sciIe::P64 = P64[Sp + 8];
           _sciIf::P64 = P64[Sp + 16];
           _sciIi::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cck3l; else goto cck3p;
       cck3l: // global
           R5 = _sciIi::P64;
           R4 = Text.Printf.$fPrintfArgDouble3_closure;
           R3 = _sciIf::P64;
           R2 = _sciIe::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       cck3p: // global
           R5 = _sciIi::P64;
           R4 = R1;
           R3 = _sciIf::P64;
           R2 = _sciIe::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 _cck3s() //  [R1]
         { info_tbl: [(cck3s,
                       label: block_cck3s_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck3s: // global
           _sciIe::P64 = P64[Sp + 8];
           _sciIf::P64 = P64[Sp + 16];
           _sciIi::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cck3B; else goto cck3F;
       cck3B: // global
           R5 = _sciIi::P64;
           R4 = Text.Printf.$fPrintfArgDouble1_closure;
           R3 = _sciIf::P64;
           R2 = _sciIe::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       cck3F: // global
           R5 = _sciIi::P64;
           R4 = R1;
           R3 = _sciIf::P64;
           R2 = _sciIe::P64;
           Sp = Sp + 40;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.681160517 UTC

[section ""data" . Text.Printf.$w$sformatRealFloat_closure" {
     Text.Printf.$w$sformatRealFloat_closure:
         const Text.Printf.$w$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$w$sformatRealFloat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck4l: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2,
                                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uck62_srtd" {
     uck62_srtd:
         const Scjc4_srt+88;
         const 36;
         const 34359738369;
 },
 sat_sciID_entry() //  [R1]
         { info_tbl: [(cck4y,
                       label: sat_sciID_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck4y: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck4z; else goto cck4A;
       cck4z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck4A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck4w_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 69;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck4w() //  [R1, R2]
         { info_tbl: [(cck4w,
                       label: block_cck4w_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck4w: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uck63_srtd" {
     uck63_srtd:
         const Scjc4_srt+88;
         const 36;
         const 34359738369;
 },
 sat_sciIH_entry() //  [R1]
         { info_tbl: [(cck4J,
                       label: sat_sciIH_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck4J: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck4K; else goto cck4L;
       cck4K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck4L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck4H_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 70;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck4H() //  [R1, R2]
         { info_tbl: [(cck4H,
                       label: block_cck4H_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck4H: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uck64_srtd" {
     uck64_srtd:
         const Scjc4_srt+88;
         const 36;
         const 34359738369;
 },
 sat_sciIL_entry() //  [R1]
         { info_tbl: [(cck4U,
                       label: sat_sciIL_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck4U: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck4V; else goto cck4W;
       cck4V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck4W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck4S_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 71;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck4S() //  [R1, R2]
         { info_tbl: [(cck4S,
                       label: block_cck4S_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck4S: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uck65_srtd" {
     uck65_srtd:
         const Scjc4_srt+88;
         const 36;
         const 34359738369;
 },
 sat_sciIP_entry() //  [R1]
         { info_tbl: [(cck55,
                       label: sat_sciIP_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck55: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck56; else goto cck57;
       cck56: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck57: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck53_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 101;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck53() //  [R1, R2]
         { info_tbl: [(cck53,
                       label: block_cck53_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck53: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uck66_srtd" {
     uck66_srtd:
         const Scjc4_srt+88;
         const 36;
         const 34359738369;
 },
 sat_sciIT_entry() //  [R1]
         { info_tbl: [(cck5g,
                       label: sat_sciIT_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck5g: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck5h; else goto cck5i;
       cck5h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck5i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck5e_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 102;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck5e() //  [R1, R2]
         { info_tbl: [(cck5e,
                       label: block_cck5e_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck5e: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uck67_srtd" {
     uck67_srtd:
         const Scjc4_srt+88;
         const 36;
         const 34359738369;
 },
 sat_sciIX_entry() //  [R1]
         { info_tbl: [(cck5r,
                       label: sat_sciIX_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck5r: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck5s; else goto cck5t;
       cck5s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck5t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck5p_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck5p() //  [R1, R2]
         { info_tbl: [(cck5p,
                       label: block_cck5p_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck5p: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uck68_srtd" {
     uck68_srtd:
         const Scjc4_srt+88;
         const 36;
         const 34359738369;
 },
 sat_sciJ1_entry() //  [R1]
         { info_tbl: [(cck5C,
                       label: sat_sciJ1_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck5C: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck5D; else goto cck5E;
       cck5D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck5E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck5A_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck5A() //  [R1, R2]
         { info_tbl: [(cck5A,
                       label: block_cck5A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck5A: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uck69_srtd" {
     uck69_srtd:
         const Scjc4_srt+32;
         const 46;
         const 39582418600065;
 },
 Text.Printf.$w$sformatRealFloat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cck5P,
                       label: Text.Printf.$w$sformatRealFloat_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck5P: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cck5T; else goto cck5S;
       cck5T: // global
           HpAlloc = 64;
           R1 = Text.Printf.$w$sformatRealFloat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cck5S: // global
           _sciIx::P64 = P64[Sp];
           _sciIz::I64 = I64[Sp + 8];
           if (_sciIz::I64 < 101) goto uck5U; else goto uck5Y;
       uck5U: // global
           if (_sciIz::I64 < 71) goto uck5V; else goto uck5X;
       uck5V: // global
           if (_sciIz::I64 < 70) goto uck5W; else goto cck5J;
       uck5W: // global
           if (_sciIz::I64 < 69) goto cck5H; else goto cck5I;
       cck5I: // global
           I64[Hp - 56] = sat_sciID_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciIx::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cck5J: // global
           I64[Hp - 56] = sat_sciIH_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciIx::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uck5X: // global
           if (_sciIz::I64 >= 72) goto cck5H; else goto cck5K;
       cck5K: // global
           I64[Hp - 56] = sat_sciIL_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciIx::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uck5Y: // global
           if (_sciIz::I64 < 103) goto uck5Z; else goto uck60;
       uck5Z: // global
           if (_sciIz::I64 < 102) goto cck5L; else goto cck5M;
       cck5L: // global
           I64[Hp - 56] = sat_sciIP_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciIx::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cck5M: // global
           I64[Hp - 56] = sat_sciIT_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciIx::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uck60: // global
           if (_sciIz::I64 < 104) goto cck5N; else goto uck61;
       cck5N: // global
           I64[Hp - 56] = sat_sciIX_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciIx::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uck61: // global
           if (_sciIz::I64 != 118) goto cck5H; else goto cck5O;
       cck5H: // global
           Hp = Hp - 64;
           R2 = _sciIz::I64;
           Sp = Sp + 16;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       cck5O: // global
           I64[Hp - 56] = sat_sciJ1_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciIx::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.725403261 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure" {
     Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure:
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble_$sformatRealFloat_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cck85,
                       label: Text.Printf.$fPrintfArgDouble_$sformatRealFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck85: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cck89; else goto cck8a;
       cck89: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cck8a: // global
           I64[Sp - 16] = block_cck82_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uck8i; else goto cck83;
       uck8i: // global
           call _cck82(R1) args: 0, res: 0, upd: 0;
       cck83: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cck82() //  [R1]
         { info_tbl: [(cck82,
                       label: block_cck82_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck82: // global
           I64[Sp - 40] = block_cck88_info;
           _sciJ5::P64 = P64[R1 + 7];
           _sciJ6::P64 = P64[R1 + 15];
           _sciJ7::P64 = P64[R1 + 23];
           _sciJ8::P64 = P64[R1 + 31];
           _sciJ9::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _sciJ6::P64;
           P64[Sp - 24] = _sciJ7::P64;
           P64[Sp - 16] = _sciJ8::P64;
           P64[Sp - 8] = _sciJ9::P64;
           P64[Sp] = _sciJ5::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uck8h; else goto cck8c;
       uck8h: // global
           call _cck88(R1) args: 0, res: 0, upd: 0;
       cck8c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cck88() //  [R1]
         { info_tbl: [(cck88,
                       label: block_cck88_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck88: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 32];
           I64[Sp + 48] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.735833353 UTC

[section ""data" . Text.Printf.$w$sformatRealFloat1_closure" {
     Text.Printf.$w$sformatRealFloat1_closure:
         const Text.Printf.$w$sformatRealFloat1_info;
         const 0;
 },
 Text.Printf.$w$sformatRealFloat1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck8B: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sciJp_entry() //  [R1]
         { info_tbl: [(cck8O,
                       label: sat_sciJp_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck8O: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck8P; else goto cck8Q;
       cck8P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck8Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck8M_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 69;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck8M() //  [R1, R2]
         { info_tbl: [(cck8M,
                       label: block_cck8M_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck8M: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciJt_entry() //  [R1]
         { info_tbl: [(cck8Z,
                       label: sat_sciJt_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck8Z: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck90; else goto cck91;
       cck90: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck91: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck8X_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 70;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck8X() //  [R1, R2]
         { info_tbl: [(cck8X,
                       label: block_cck8X_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck8X: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciJx_entry() //  [R1]
         { info_tbl: [(cck9a,
                       label: sat_sciJx_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck9a: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck9b; else goto cck9c;
       cck9b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck9c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck98_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 71;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck98() //  [R1, R2]
         { info_tbl: [(cck98,
                       label: block_cck98_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck98: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciJB_entry() //  [R1]
         { info_tbl: [(cck9l,
                       label: sat_sciJB_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck9l: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck9m; else goto cck9n;
       cck9m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck9n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck9j_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 101;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck9j() //  [R1, R2]
         { info_tbl: [(cck9j,
                       label: block_cck9j_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck9j: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciJF_entry() //  [R1]
         { info_tbl: [(cck9w,
                       label: sat_sciJF_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck9w: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck9x; else goto cck9y;
       cck9x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck9y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck9u_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 102;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck9u() //  [R1, R2]
         { info_tbl: [(cck9u,
                       label: block_cck9u_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck9u: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciJJ_entry() //  [R1]
         { info_tbl: [(cck9H,
                       label: sat_sciJJ_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck9H: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck9I; else goto cck9J;
       cck9I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck9J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck9F_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck9F() //  [R1, R2]
         { info_tbl: [(cck9F,
                       label: block_cck9F_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck9F: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciJN_entry() //  [R1]
         { info_tbl: [(cck9S,
                       label: sat_sciJN_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck9S: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cck9T; else goto cck9U;
       cck9T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cck9U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cck9Q_info;
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 56];
           R3 = P64[R1 + 32];
           R2 = 103;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call Text.Printf.$w$sdfmt1_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 24;
     }
 },
 _cck9Q() //  [R1, R2]
         { info_tbl: [(cck9Q,
                       label: block_cck9Q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck9Q: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckai_srtd" {
     uckai_srtd:
         const Scjc4_srt+32;
         const 48;
         const 145135534868481;
 },
 Text.Printf.$w$sformatRealFloat1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccka5,
                       label: Text.Printf.$w$sformatRealFloat1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccka5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccka9; else goto ccka8;
       ccka9: // global
           HpAlloc = 64;
           R1 = Text.Printf.$w$sformatRealFloat1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ccka8: // global
           _sciJj::P64 = P64[Sp];
           _sciJl::I64 = I64[Sp + 8];
           if (_sciJl::I64 < 101) goto uckaa; else goto uckae;
       uckaa: // global
           if (_sciJl::I64 < 71) goto uckab; else goto uckad;
       uckab: // global
           if (_sciJl::I64 < 70) goto uckac; else goto cck9Z;
       uckac: // global
           if (_sciJl::I64 < 69) goto cck9X; else goto cck9Y;
       cck9Y: // global
           I64[Hp - 56] = sat_sciJp_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciJj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cck9Z: // global
           I64[Hp - 56] = sat_sciJt_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciJj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uckad: // global
           if (_sciJl::I64 >= 72) goto cck9X; else goto ccka0;
       ccka0: // global
           I64[Hp - 56] = sat_sciJx_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciJj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uckae: // global
           if (_sciJl::I64 < 103) goto uckaf; else goto uckag;
       uckaf: // global
           if (_sciJl::I64 < 102) goto ccka1; else goto ccka2;
       ccka1: // global
           I64[Hp - 56] = sat_sciJB_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciJj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccka2: // global
           I64[Hp - 56] = sat_sciJF_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciJj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uckag: // global
           if (_sciJl::I64 < 104) goto ccka3; else goto uckah;
       ccka3: // global
           I64[Hp - 56] = sat_sciJJ_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciJj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uckah: // global
           if (_sciJl::I64 != 118) goto cck9X; else goto ccka4;
       cck9X: // global
           Hp = Hp - 64;
           R2 = _sciJl::I64;
           Sp = Sp + 16;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       ccka4: // global
           I64[Hp - 56] = sat_sciJN_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = _sciJj::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.774971895 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure" {
     Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure:
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat_$sformatRealFloat_entry() //  [R2, R3]
         { info_tbl: [(cckc7,
                       label: Text.Printf.$fPrintfArgFloat_$sformatRealFloat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckc7: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cckcb; else goto cckcc;
       cckcb: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckcc: // global
           I64[Sp - 16] = block_cckc4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uckck; else goto cckc5;
       uckck: // global
           call _cckc4(R1) args: 0, res: 0, upd: 0;
       cckc5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckc4() //  [R1]
         { info_tbl: [(cckc4,
                       label: block_cckc4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckc4: // global
           I64[Sp - 40] = block_cckca_info;
           _sciJR::P64 = P64[R1 + 7];
           _sciJS::P64 = P64[R1 + 15];
           _sciJT::P64 = P64[R1 + 23];
           _sciJU::P64 = P64[R1 + 31];
           _sciJV::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _sciJS::P64;
           P64[Sp - 24] = _sciJT::P64;
           P64[Sp - 16] = _sciJU::P64;
           P64[Sp - 8] = _sciJV::P64;
           P64[Sp] = _sciJR::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uckcj; else goto cckce;
       uckcj: // global
           call _cckca(R1) args: 0, res: 0, upd: 0;
       cckce: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckca() //  [R1]
         { info_tbl: [(cckca,
                       label: block_cckca_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckca: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 32];
           I64[Sp + 48] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatRealFloat1_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.785643952 UTC

[section ""data" . Text.Printf.$wformatRealFloat_closure" {
     Text.Printf.$wformatRealFloat_closure:
         const Text.Printf.$wformatRealFloat_info;
         const 0;
 },
 Text.Printf.$wformatRealFloat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckcD: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatRealFloat_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2,
                                                    R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sciKc_entry() //  [R1]
         { info_tbl: [(cckcQ,
                       label: sat_sciKc_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckcQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckcR; else goto cckcS;
       cckcR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckcS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cckcO_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 69;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckcO() //  [R1, R2]
         { info_tbl: [(cckcO,
                       label: block_cckcO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckcO: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciKg_entry() //  [R1]
         { info_tbl: [(cckd1,
                       label: sat_sciKg_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckd1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckd2; else goto cckd3;
       cckd2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckd3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cckcZ_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 70;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckcZ() //  [R1, R2]
         { info_tbl: [(cckcZ,
                       label: block_cckcZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckcZ: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciKk_entry() //  [R1]
         { info_tbl: [(cckdc,
                       label: sat_sciKk_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckdc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckdd; else goto cckde;
       cckdd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckde: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cckda_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 71;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckda() //  [R1, R2]
         { info_tbl: [(cckda,
                       label: block_cckda_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckda: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciKo_entry() //  [R1]
         { info_tbl: [(cckdn,
                       label: sat_sciKo_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckdn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckdo; else goto cckdp;
       cckdo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckdp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cckdl_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 101;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckdl() //  [R1, R2]
         { info_tbl: [(cckdl,
                       label: block_cckdl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckdl: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciKs_entry() //  [R1]
         { info_tbl: [(cckdy,
                       label: sat_sciKs_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckdy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckdz; else goto cckdA;
       cckdz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckdA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cckdw_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 102;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckdw() //  [R1, R2]
         { info_tbl: [(cckdw,
                       label: block_cckdw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckdw: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciKw_entry() //  [R1]
         { info_tbl: [(cckdJ,
                       label: sat_sciKw_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckdJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckdK; else goto cckdL;
       cckdK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckdL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cckdH_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 103;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckdH() //  [R1, R2]
         { info_tbl: [(cckdH,
                       label: block_cckdH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckdH: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciKA_entry() //  [R1]
         { info_tbl: [(cckdU,
                       label: sat_sciKA_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckdU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckdV; else goto cckdW;
       cckdV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckdW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cckdS_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 64];
           R4 = P64[R1 + 40];
           R3 = 103;
           R2 = P64[R1 + 16];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 48;
           call Text.Printf.$wdfmt_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckdS() //  [R1, R2]
         { info_tbl: [(cckdS,
                       label: block_cckdS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckdS: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckek_srtd" {
     uckek_srtd:
         const Scjc4_srt+32;
         const 50;
         const 567347999948801;
 },
 Text.Printf.$wformatRealFloat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccke7,
                       label: Text.Printf.$wformatRealFloat_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccke7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cckeb; else goto cckea;
       cckeb: // global
           HpAlloc = 72;
           R1 = Text.Printf.$wformatRealFloat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cckea: // global
           _sciK5::P64 = P64[Sp];
           _sciK6::P64 = P64[Sp + 8];
           _sciK8::I64 = I64[Sp + 16];
           if (_sciK8::I64 < 101) goto uckec; else goto uckeg;
       uckec: // global
           if (_sciK8::I64 < 71) goto ucked; else goto uckef;
       ucked: // global
           if (_sciK8::I64 < 70) goto uckee; else goto ccke1;
       uckee: // global
           if (_sciK8::I64 < 69) goto cckdZ; else goto ccke0;
       ccke0: // global
           I64[Hp - 64] = sat_sciKc_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sciK5::P64;
           P64[Hp] = _sciK6::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccke1: // global
           I64[Hp - 64] = sat_sciKg_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sciK5::P64;
           P64[Hp] = _sciK6::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uckef: // global
           if (_sciK8::I64 >= 72) goto cckdZ; else goto ccke2;
       ccke2: // global
           I64[Hp - 64] = sat_sciKk_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sciK5::P64;
           P64[Hp] = _sciK6::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uckeg: // global
           if (_sciK8::I64 < 103) goto uckeh; else goto uckei;
       uckeh: // global
           if (_sciK8::I64 < 102) goto ccke3; else goto ccke4;
       ccke3: // global
           I64[Hp - 64] = sat_sciKo_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sciK5::P64;
           P64[Hp] = _sciK6::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccke4: // global
           I64[Hp - 64] = sat_sciKs_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sciK5::P64;
           P64[Hp] = _sciK6::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uckei: // global
           if (_sciK8::I64 < 104) goto ccke5; else goto uckej;
       ccke5: // global
           I64[Hp - 64] = sat_sciKw_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sciK5::P64;
           P64[Hp] = _sciK6::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uckej: // global
           if (_sciK8::I64 != 118) goto cckdZ; else goto ccke6;
       cckdZ: // global
           Hp = Hp - 72;
           R2 = _sciK8::I64;
           Sp = Sp + 24;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
       ccke6: // global
           I64[Hp - 64] = sat_sciKA_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = _sciK5::P64;
           P64[Hp] = _sciK6::P64;
           R2 = Hp - 64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.824335847 UTC

[section ""data" . Text.Printf.formatRealFloat_closure" {
     Text.Printf.formatRealFloat_closure:
         const Text.Printf.formatRealFloat_info;
         const 0;
 },
 Text.Printf.formatRealFloat_entry() //  [R2, R3, R4]
         { info_tbl: [(cckg9,
                       label: Text.Printf.formatRealFloat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckg9: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cckgd; else goto cckge;
       cckgd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatRealFloat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cckge: // global
           I64[Sp - 24] = block_cckg6_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uckgm; else goto cckg7;
       uckgm: // global
           call _cckg6(R1) args: 0, res: 0, upd: 0;
       cckg7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckg6() //  [R1]
         { info_tbl: [(cckg6,
                       label: block_cckg6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckg6: // global
           I64[Sp - 40] = block_cckgc_info;
           _sciKF::P64 = P64[R1 + 7];
           _sciKG::P64 = P64[R1 + 15];
           _sciKH::P64 = P64[R1 + 23];
           _sciKI::P64 = P64[R1 + 31];
           _sciKJ::P64 = P64[R1 + 39];
           R1 = P64[R1 + 55];
           P64[Sp - 32] = _sciKG::P64;
           P64[Sp - 24] = _sciKH::P64;
           P64[Sp - 16] = _sciKI::P64;
           P64[Sp - 8] = _sciKJ::P64;
           P64[Sp] = _sciKF::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uckgl; else goto cckgg;
       uckgl: // global
           call _cckgc(R1) args: 0, res: 0, upd: 0;
       cckgg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckgc() //  [R1]
         { info_tbl: [(cckgc,
                       label: block_cckgc_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckgc: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 56];
           R2 = P64[Sp + 48];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatRealFloat_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.832860199 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgDouble_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgDouble_$cparseFormat_entry() //  [R2, R3]
         { info_tbl: [(cckgQ,
                       label: Text.Printf.$fPrintfArgDouble_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckgQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckgR; else goto cckgS;
       cckgR: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgDouble_$cparseFormat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckgS: // global
           I64[Sp - 8] = block_cckgJ_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckh2; else goto cckgK;
       uckh2: // global
           call _cckgJ(R1) args: 0, res: 0, upd: 0;
       cckgK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckgJ() //  [R1]
         { info_tbl: [(cckgJ,
                       label: block_cckgJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckgJ: // global
           if (R1 & 7 == 1) goto cckgN; else goto cckgO;
       cckgN: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cckgO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cckh1; else goto cckh0;
       cckh1: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckh0: // global
           _sciKR::P64 = P64[R1 + 6];
           _sciKS::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sciKR::P64;
           P64[Hp] = _sciKS::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.839097328 UTC

[section ""data" . Text.Printf.$fPrintfArgDouble_closure" {
     Text.Printf.$fPrintfArgDouble_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure+2;
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.842299601 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_$cparseFormat_closure" {
     Text.Printf.$fPrintfArgFloat_$cparseFormat_closure:
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_info;
         const 0;
 },
 Text.Printf.$fPrintfArgFloat_$cparseFormat_entry() //  [R2, R3]
         { info_tbl: [(cckhv,
                       label: Text.Printf.$fPrintfArgFloat_$cparseFormat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckhv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckhw; else goto cckhx;
       cckhw: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgFloat_$cparseFormat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckhx: // global
           I64[Sp - 8] = block_cckho_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckhH; else goto cckhp;
       uckhH: // global
           call _cckho(R1) args: 0, res: 0, upd: 0;
       cckhp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckho() //  [R1]
         { info_tbl: [(cckho,
                       label: block_cckho_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckho: // global
           if (R1 & 7 == 1) goto cckhs; else goto cckht;
       cckhs: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cckht: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cckhG; else goto cckhF;
       cckhG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckhF: // global
           _sciKW::P64 = P64[R1 + 6];
           _sciKX::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sciKW::P64;
           P64[Hp] = _sciKX::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.848345259 UTC

[section ""data" . Text.Printf.$fPrintfArgFloat_closure" {
     Text.Printf.$fPrintfArgFloat_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure+2;
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.851448005 UTC

[section ""data" . Text.Printf.$w$sformatString_closure" {
     Text.Printf.$w$sformatString_closure:
         const Text.Printf.$w$sformatString_info;
         const 0;
 },
 Text.Printf.$w$sformatString_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccki0: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatString_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sciLc_entry() //  [R1]
         { info_tbl: [(cckir,
                       label: sat_sciLc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckir: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cckis; else goto cckit;
       cckis: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckit: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cckik_info;
           _sciKY::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sciKY::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uckiM; else goto cckil;
       uckiM: // global
           call _cckik(R1) args: 0, res: 0, upd: 0;
       cckil: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cckik() //  [R1]
         { info_tbl: [(cckik,
                       label: block_cckik_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckik: // global
           if (R1 & 7 == 1) goto cckio; else goto cckip;
       cckio: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cckip: // global
           I64[Sp] = block_cckiz_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uckiL; else goto cckiB;
       uckiL: // global
           call _cckiz(R1) args: 0, res: 0, upd: 0;
       cckiB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cckiz() //  [R1]
         { info_tbl: [(cckiz,
                       label: block_cckiz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckiz: // global
           _sciLa::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _sciLa::I64)) goto cckiJ; else goto cckiK;
       cckiJ: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cckiK: // global
           R3 = P64[Sp + 8];
           R2 = _sciLa::I64;
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sciL6_entry() //  [R1]
         { info_tbl: [(cckiN,
                       label: g_sciL6_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckiN: // global
           _sciL6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cckiO; else goto cckiP;
       cckiP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cckiR; else goto cckiQ;
       cckiR: // global
           HpAlloc = 32;
           goto cckiO;
       cckiO: // global
           R1 = _sciL6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckiQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sciL6::P64;
           _sciKY::P64 = P64[_sciL6::P64 + 16];
           _sciKZ::P64 = P64[_sciL6::P64 + 24];
           _sciL0::P64 = P64[_sciL6::P64 + 32];
           _sciL1::P64 = P64[_sciL6::P64 + 40];
           I64[Hp - 24] = sat_sciLc_info;
           P64[Hp - 8] = _sciKY::P64;
           P64[Hp] = _sciL0::P64;
           R5 = Hp - 24;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sciL1::P64;
           R2 = _sciKZ::P64;
           Sp = Sp - 16;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$w$sformatString_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cckiW,
                       label: Text.Printf.$w$sformatString_info
                       rep:HeapRep static {
                             Fun {arity: 5
                                  fun_type: ArgGen [False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckiW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckiX; else goto cckiY;
       cckiX: // global
           R1 = Text.Printf.$w$sformatString_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cckiY: // global
           if (R6 == 118) goto cckiV; else goto cckiU;
       cckiV: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = 115;
           Sp = Sp - 40;
           goto uckja;
       cckiU: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           goto uckja;
       uckja: // global
           call _ccki7() args: 0, res: 0, upd: 0;
     }
 },
 _ccki7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccki7: // global
           Hp = Hp + 48;
           _sciL4::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto cckj1; else goto cckj0;
       cckj1: // global
           HpAlloc = 48;
           I64[Sp - 8] = block_ccki6_info;
           R1 = _sciL4::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cckj0: // global
           if (_sciL4::I64 == 115) goto cckj4; else goto cckj3;
       cckj4: // global
           I64[Hp - 40] = g_sciL6_info;
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 40;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 40;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cckj3: // global
           Hp = Hp - 48;
           R2 = _sciL4::I64;
           Sp = Sp + 40;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccki6() //  [R1]
         { info_tbl: [(ccki6,
                       label: block_ccki6_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccki6: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _ccki7() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.870567026 UTC

[section ""data" . Text.Printf.$wformatString_closure" {
     Text.Printf.$wformatString_closure:
         const Text.Printf.$wformatString_info;
         const 0;
 },
 Text.Printf.$wformatString_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckjX: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatString_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 16, res: 0, upd: 8;
     }
 },
 sat_sciLq_entry() //  [R1]
         { info_tbl: [(cckkq,
                       label: sat_sciLq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckkq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckkr; else goto cckks;
       cckkr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckks: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.Printf.toChar_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciLE_entry() //  [R1]
         { info_tbl: [(cckkX,
                       label: sat_sciLE_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckkX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckkY; else goto cckkZ;
       cckkY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckkZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 32] - 1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wgo_sciLv_entry(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciLC_entry() //  [R1]
         { info_tbl: [(cckl4,
                       label: sat_sciLC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckl4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cckl5; else goto cckl6;
       cckl5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckl6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.toChar_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sciLF_entry() //  [R1]
         { info_tbl: [(ccklc,
                       label: sat_sciLF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccklc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cckld; else goto cckle;
       cckld: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckle: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Text.Printf.toChar_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $wgo_sciLv_entry() //  [R1, R2, R3]
         { info_tbl: [(ccklj,
                       label: $wgo_sciLv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccklj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccklk; else goto cckll;
       ccklk: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckll: // global
           I64[Sp - 32] = block_cckkJ_info;
           _sciLv::P64 = R1;
           _sciLf::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 24] = _sciLf::P64;
           P64[Sp - 16] = _sciLv::P64;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucklw; else goto cckkK;
       ucklw: // global
           call _cckkJ(R1) args: 0, res: 0, upd: 0;
       cckkK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckkJ() //  [R1]
         { info_tbl: [(cckkJ,
                       label: block_cckkJ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckkJ: // global
           if (R1 & 7 == 1) goto ccklg; else goto ccklh;
       ccklg: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccklh: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccklq; else goto ccklp;
       ccklq: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccklp: // global
           _sciLf::P64 = P64[Sp + 8];
           _sciLz::P64 = P64[R1 + 6];
           _sciLB::I64 = I64[Sp + 24];
           if (_sciLB::I64 != 1) goto ccklt; else goto ccklv;
       ccklt: // global
           _sciLA::P64 = P64[R1 + 14];
           I64[Hp - 88] = sat_sciLE_info;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = _sciLA::P64;
           I64[Hp - 56] = _sciLB::I64;
           I64[Hp - 48] = sat_sciLC_info;
           P64[Hp - 32] = _sciLf::P64;
           P64[Hp - 24] = _sciLz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccklv: // global
           I64[Hp - 88] = sat_sciLF_info;
           P64[Hp - 72] = _sciLf::P64;
           P64[Hp - 64] = _sciLz::P64;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 88;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccklu::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccklu::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sciLG_entry() //  [R1]
         { info_tbl: [(ccklB,
                       label: sat_sciLG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccklB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccklC; else goto ccklD;
       ccklC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccklD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cckkh_info;
           _sciLf::P64 = P64[R1 + 16];
           _sciLg::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sciLf::P64;
           P64[Sp - 24] = _sciLg::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucklP; else goto cckki;
       ucklP: // global
           call _cckkh(R1) args: 0, res: 0, upd: 0;
       cckki: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cckkh() //  [R1]
         { info_tbl: [(cckkh,
                       label: block_cckkh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckkh: // global
           if (R1 & 7 == 1) goto cckly; else goto ccklz;
       cckly: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccklG; else goto ccklF;
       ccklG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccklF: // global
           I64[Hp - 16] = sat_sciLq_info;
           P64[Hp] = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
       ccklz: // global
           I64[Sp] = block_cckkv_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucklO; else goto cckkw;
       ucklO: // global
           call _cckkv(R1) args: 0, res: 0, upd: 0;
       cckkw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cckkv() //  [R1]
         { info_tbl: [(cckkv,
                       label: block_cckkv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckkv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccklK; else goto ccklJ;
       ccklK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccklJ: // global
           _sciLt::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _sciLt::I64)) goto ccklM; else goto ccklN;
       ccklM: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccklN: // global
           I64[Hp - 8] = $wgo_sciLv_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _sciLt::I64;
           R2 = P64[Sp + 16];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call $wgo_sciLv_entry(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sciLo_entry() //  [R1]
         { info_tbl: [(ccklQ,
                       label: g_sciLo_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccklQ: // global
           _sciLo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccklR; else goto ccklS;
       ccklS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccklU; else goto ccklT;
       ccklU: // global
           HpAlloc = 40;
           goto ccklR;
       ccklR: // global
           R1 = _sciLo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccklT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sciLo::P64;
           _sciLf::P64 = P64[_sciLo::P64 + 16];
           _sciLg::P64 = P64[_sciLo::P64 + 24];
           _sciLh::P64 = P64[_sciLo::P64 + 32];
           _sciLi::P64 = P64[_sciLo::P64 + 40];
           _sciLj::P64 = P64[_sciLo::P64 + 48];
           I64[Hp - 32] = sat_sciLG_info;
           P64[Hp - 16] = _sciLf::P64;
           P64[Hp - 8] = _sciLg::P64;
           P64[Hp] = _sciLi::P64;
           R5 = Hp - 32;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sciLj::P64;
           R2 = _sciLh::P64;
           Sp = Sp - 16;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$wformatString_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccklZ,
                       label: Text.Printf.$wformatString_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [False, False, False, False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccklZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckm0; else goto cckm1;
       cckm0: // global
           R1 = Text.Printf.$wformatString_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cckm1: // global
           _sciLI::I64 = I64[Sp];
           if (_sciLI::I64 == 118) goto ccklY; else goto ccklX;
       ccklY: // global
           P64[Sp] = R2;
           P64[Sp - 40] = R3;
           P64[Sp - 32] = R4;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           I64[Sp - 8] = 115;
           Sp = Sp - 40;
           goto uckmd;
       ccklX: // global
           P64[Sp - 40] = R3;
           P64[Sp - 32] = R4;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           I64[Sp - 8] = _sciLI::I64;
           P64[Sp] = R2;
           Sp = Sp - 40;
           goto uckmd;
       uckmd: // global
           call _cckk4() args: 0, res: 0, upd: 0;
     }
 },
 _cckk4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckk4: // global
           Hp = Hp + 56;
           _sciLm::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto cckm4; else goto cckm3;
       cckm4: // global
           HpAlloc = 56;
           I64[Sp - 8] = block_cckk3_info;
           R1 = _sciLm::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cckm3: // global
           if (_sciLm::I64 == 115) goto cckm7; else goto cckm6;
       cckm7: // global
           I64[Hp - 48] = g_sciLo_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp];
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R2 = Hp - 48;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 48;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cckm6: // global
           Hp = Hp - 56;
           R2 = _sciLm::I64;
           Sp = Sp + 48;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cckk3() //  [R1]
         { info_tbl: [(cckk3,
                       label: block_cckk3_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckk3: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _cckk4() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.902999994 UTC

[section ""data" . Text.Printf.formatString_closure" {
     Text.Printf.formatString_closure:
         const Text.Printf.formatString_info;
         const 0;
 },
 Text.Printf.formatString_entry() //  [R2, R3, R4]
         { info_tbl: [(ccknY,
                       label: Text.Printf.formatString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccknY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccko2; else goto ccko3;
       ccko2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatString_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccko3: // global
           I64[Sp - 24] = block_ccknV_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uckob; else goto ccknW;
       uckob: // global
           call _ccknV(R1) args: 0, res: 0, upd: 0;
       ccknW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccknV() //  [R1]
         { info_tbl: [(ccknV,
                       label: block_ccknV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccknV: // global
           I64[Sp - 24] = block_ccko1_info;
           _sciLN::P64 = P64[R1 + 7];
           _sciLO::P64 = P64[R1 + 15];
           _sciLP::P64 = P64[R1 + 23];
           R1 = P64[R1 + 55];
           P64[Sp - 16] = _sciLO::P64;
           P64[Sp - 8] = _sciLP::P64;
           P64[Sp] = _sciLN::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uckoa; else goto ccko5;
       uckoa: // global
           call _ccko1(R1) args: 0, res: 0, upd: 0;
       ccko5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccko1() //  [R1]
         { info_tbl: [(ccko1,
                       label: block_ccko1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccko1: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           I64[Sp + 40] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatString_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.911302815 UTC

[section ""data" . lvl22_rcccn_closure" {
     lvl22_rcccn_closure:
         const lvl22_rcccn_info;
         const 0;
 },
 lvl22_rcccn_entry() //  [R2, R3]
         { info_tbl: [(cckoD,
                       label: lvl22_rcccn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckoD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckoE; else goto cckoF;
       cckoE: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl22_rcccn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckoF: // global
           I64[Sp - 8] = block_cckow_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckoP; else goto cckox;
       uckoP: // global
           call _cckow(R1) args: 0, res: 0, upd: 0;
       cckox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckow() //  [R1]
         { info_tbl: [(cckow,
                       label: block_cckow_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckow: // global
           if (R1 & 7 == 1) goto cckoA; else goto cckoB;
       cckoA: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cckoB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cckoO; else goto cckoN;
       cckoO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckoN: // global
           _sciLZ::P64 = P64[R1 + 6];
           _sciM0::P64 = P64[R1 + 14];
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           P64[Hp - 8] = _sciLZ::P64;
           P64[Hp] = _sciM0::P64;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.917576327 UTC

[section ""data" . Text.Printf.$fPrintfArg[]_closure" {
     Text.Printf.$fPrintfArg[]_closure:
         const Text.Printf.$fPrintfArg[]_info;
         const 0;
 },
 sat_sciM2_entry() //  [R1, R2, R3]
         { info_tbl: [(cckpf,
                       label: sat_sciM2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckpf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Text.Printf.formatString_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Text.Printf.$fPrintfArg[]_entry() //  [R2]
         { info_tbl: [(cckpj,
                       label: Text.Printf.$fPrintfArg[]_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckpj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cckpn; else goto cckpm;
       cckpn: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArg[]_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cckpm: // global
           I64[Hp - 32] = sat_sciM2_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = Text.Printf.C:PrintfArg_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = lvl22_rcccn_closure+2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.922924186 UTC

[section ""data" . lvl23_rccco_closure" {
     lvl23_rccco_closure:
         const GHC.Types.C#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.924664995 UTC

[section ""data" . sat_sciM3_closure" {
     sat_sciM3_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.927288772 UTC

[section ""data" . sat_sciM4_closure" {
     sat_sciM4_closure:
         const :_con_info;
         const sat_sciM3_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.929196764 UTC

[section ""data" . lvl24_rcccp_closure" {
     lvl24_rcccp_closure:
         const lvl24_rcccp_info;
         const 0;
         const 0;
         const 0;
 },
 lvl24_rcccp_entry() //  [R1]
         { info_tbl: [(cckpJ,
                       label: lvl24_rcccp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckpJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckpK; else goto cckpL;
       cckpK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckpL: // global
           (_cckpG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cckpG::I64 == 0) goto cckpI; else goto cckpH;
       cckpI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cckpH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cckpG::I64;
           R3 = sat_sciM4_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.933169968 UTC

[section ""cstring" . lvl25_rcccq_bytes" {
     lvl25_rcccq_bytes:
         I8[] [48,88]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.935051763 UTC

[section ""data" . lvl26_rcccr_closure" {
     lvl26_rcccr_closure:
         const lvl26_rcccr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_rcccr_entry() //  [R1]
         { info_tbl: [(cckq2,
                       label: lvl26_rcccr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckq2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckq3; else goto cckq4;
       cckq3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckq4: // global
           (_cckpZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cckpZ::I64 == 0) goto cckq1; else goto cckq0;
       cckq1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cckq0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cckpZ::I64;
           R2 = lvl25_rcccq_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.938838182 UTC

[section ""cstring" . lvl27_rcccs_bytes" {
     lvl27_rcccs_bytes:
         I8[] [48,98]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.940680304 UTC

[section ""data" . lvl28_rccct_closure" {
     lvl28_rccct_closure:
         const lvl28_rccct_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_rccct_entry() //  [R1]
         { info_tbl: [(cckqk,
                       label: lvl28_rccct_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckqk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckql; else goto cckqm;
       cckql: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckqm: // global
           (_cckqh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cckqh::I64 == 0) goto cckqj; else goto cckqi;
       cckqj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cckqi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cckqh::I64;
           R2 = lvl27_rcccs_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.944837794 UTC

[section ""cstring" . lvl29_rcccu_bytes" {
     lvl29_rcccu_bytes:
         I8[] [112,114,105,110,116,102,58,32,105,108,108,101,103,97,108,32,99,104,97,114,32,99,111,110,118,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.946764852 UTC

[section ""data" . lvl30_rcccv_closure" {
     lvl30_rcccv_closure:
         const lvl30_rcccv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_rcccv_entry() //  [R1]
         { info_tbl: [(cckqE,
                       label: lvl30_rcccv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckqE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cckqF; else goto cckqG;
       cckqF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckqG: // global
           (_cckqz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cckqz::I64 == 0) goto cckqB; else goto cckqA;
       cckqB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cckqA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cckqz::I64;
           I64[Sp - 24] = block_cckqC_info;
           R2 = lvl29_rcccu_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckqC() //  [R1]
         { info_tbl: [(cckqC,
                       label: block_cckqC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckqC: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.95214036 UTC

[section ""data" . sat_sciM6_closure" {
     sat_sciM6_closure:
         const GHC.Types.I#_con_info;
         const 1114111;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.953843163 UTC

[section ""data" . sat_sciM7_closure" {
     sat_sciM7_closure:
         const :_con_info;
         const sat_sciM6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.955793724 UTC

[section ""data" . lvl31_rcccw_closure" {
     lvl31_rcccw_closure:
         const lvl31_rcccw_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_rcccw_entry() //  [R1]
         { info_tbl: [(cckr4,
                       label: lvl31_rcccw_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckr4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckr5; else goto cckr6;
       cckr5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckr6: // global
           (_cckr1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cckr1::I64 == 0) goto cckr3; else goto cckr2;
       cckr3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cckr2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cckr1::I64;
           R3 = sat_sciM7_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.960346012 UTC

[section ""data" . sat_sciM8_closure" {
     sat_sciM8_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.962052909 UTC

[section ""data" . sat_sciM9_closure" {
     sat_sciM9_closure:
         const :_con_info;
         const sat_sciM8_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.963966747 UTC

[section ""data" . lvl32_rcccx_closure" {
     lvl32_rcccx_closure:
         const lvl32_rcccx_info;
         const 0;
         const 0;
         const 0;
 },
 lvl32_rcccx_entry() //  [R1]
         { info_tbl: [(cckro,
                       label: lvl32_rcccx_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckro: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckrp; else goto cckrq;
       cckrp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckrq: // global
           (_cckrl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cckrl::I64 == 0) goto cckrn; else goto cckrm;
       cckrn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cckrm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cckrl::I64;
           R3 = sat_sciM9_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.9682701 UTC

[section ""cstring" . lvl33_rcccy_bytes" {
     lvl33_rcccy_bytes:
         I8[] [48]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.970118277 UTC

[section ""data" . lvl34_rcccz_closure" {
     lvl34_rcccz_closure:
         const lvl34_rcccz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl34_rcccz_entry() //  [R1]
         { info_tbl: [(cckrH,
                       label: lvl34_rcccz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckrH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckrI; else goto cckrJ;
       cckrI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckrJ: // global
           (_cckrE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cckrE::I64 == 0) goto cckrG; else goto cckrF;
       cckrG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cckrF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cckrE::I64;
           R2 = lvl33_rcccy_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.973942795 UTC

[section ""data" . sat_sciMa_closure" {
     sat_sciMa_closure:
         const GHC.Types.I#_con_info;
         const 10;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.975608271 UTC

[section ""data" . sat_sciMb_closure" {
     sat_sciMb_closure:
         const :_con_info;
         const sat_sciMa_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.977547425 UTC

[section ""data" . lvl35_rcccA_closure" {
     lvl35_rcccA_closure:
         const lvl35_rcccA_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_rcccA_entry() //  [R1]
         { info_tbl: [(ccks0,
                       label: lvl35_rcccA_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccks0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccks1; else goto ccks2;
       ccks1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccks2: // global
           (_cckrX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cckrX::I64 == 0) goto cckrZ; else goto cckrY;
       cckrZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cckrY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cckrX::I64;
           R3 = sat_sciMb_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.981600328 UTC

[section ""cstring" . lvl36_rcccB_bytes" {
     lvl36_rcccB_bytes:
         I8[] [48,120]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.983425908 UTC

[section ""data" . lvl37_rcccC_closure" {
     lvl37_rcccC_closure:
         const lvl37_rcccC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_rcccC_entry() //  [R1]
         { info_tbl: [(ccksj,
                       label: lvl37_rcccC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccksj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccksk; else goto ccksl;
       ccksk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccksl: // global
           (_ccksg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccksg::I64 == 0) goto ccksi; else goto ccksh;
       ccksi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccksh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccksg::I64;
           R2 = lvl36_rcccB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.987899094 UTC

[section ""data" . lvl38_rcccD_closure" {
     lvl38_rcccD_closure:
         const GHC.Base.Just_con_info;
         const lvl26_rcccr_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.990242456 UTC

[section ""data" . lvl39_rcccE_closure" {
     lvl39_rcccE_closure:
         const GHC.Base.Just_con_info;
         const lvl28_rccct_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.991924141 UTC

[section ""data" . lvl40_rcccF_closure" {
     lvl40_rcccF_closure:
         const GHC.Base.Just_con_info;
         const lvl34_rcccz_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:13.993633613 UTC

[section ""data" . lvl41_rcccG_closure" {
     lvl41_rcccG_closure:
         const GHC.Base.Just_con_info;
         const lvl37_rcccC_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.002110192 UTC

[section ""data" . Text.Printf.$wformatIntegral_closure" {
     Text.Printf.$wformatIntegral_closure:
         const Text.Printf.$wformatIntegral_info;
         const 0;
 },
 Text.Printf.$wformatIntegral_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccksz: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_sciMA_entry() //  [R1]
         { info_tbl: [(ccktN,
                       label: sat_sciMA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccktN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccktO; else goto ccktP;
       ccktO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccktP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciME_entry() //  [R1]
         { info_tbl: [(ccktY,
                       label: sat_sciME_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccktY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccktZ; else goto ccku0;
       ccktZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccku0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciMI_entry() //  [R1]
         { info_tbl: [(ccku9,
                       label: sat_sciMI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccku9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckua; else goto cckub;
       cckua: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckub: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.toUpper_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckzN_srtd" {
     uckzN_srtd:
         const Scjc4_srt+312;
         const 33;
         const 7516192777;
 },
 sat_sciMJ_entry() //  [R1]
         { info_tbl: [(cckuf,
                       label: sat_sciMJ_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckuf: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cckug; else goto cckuh;
       cckug: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckuh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cckty_info;
           R3 = Text.Printf.formatChar2_closure;
           _sciMd::P64 = P64[R1 + 24];
           R2 = _sciMd::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sciMd::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckty() //  [R1]
         { info_tbl: [(cckty,
                       label: block_cckty_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckty: // global
           if (R1 == 1) goto cckue; else goto cckud;
       cckue: // global
           _sciMf::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccku3_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sciMf::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cckud: // global
           I64[Sp] = block_ccktC_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uckuz; else goto ccktD;
       uckuz: // global
           call _ccktC(R1) args: 0, res: 0, upd: 0;
       ccktD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccku3() //  [R1, R2]
         { info_tbl: [(ccku3,
                       label: block_ccku3_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccku3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cckux; else goto cckuw;
       cckux: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cckuw: // global
           I64[Hp - 16] = sat_sciMI_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccktC() //  [R1]
         { info_tbl: [(ccktC,
                       label: block_ccktC_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccktC: // global
           _sciMc::P64 = P64[Sp + 8];
           _sciMd::P64 = P64[Sp + 16];
           _sciMf::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cckul; else goto cckuq;
       cckul: // global
           I64[Sp + 24] = block_ccktH_info;
           R6 = _sciMd::P64;
           R5 = _sciMc::P64;
           R4 = _sciMf::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cckuq: // global
           I64[Sp + 24] = block_ccktS_info;
           R6 = _sciMd::P64;
           R5 = _sciMc::P64;
           R4 = _sciMf::P64;
           R3 = lvl38_rcccD_closure+2;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccktH() //  [R1, R2]
         { info_tbl: [(ccktH,
                       label: block_ccktH_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccktH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cckuo; else goto cckun;
       cckuo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cckun: // global
           I64[Hp - 16] = sat_sciMA_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _ccktS() //  [R1, R2]
         { info_tbl: [(ccktS,
                       label: block_ccktS_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccktS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cckut; else goto cckus;
       cckut: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cckus: // global
           I64[Hp - 16] = sat_sciME_info;
           P64[Hp] = R2;
           R5 = Hp - 16;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckzO_srtd" {
     uckzO_srtd:
         const Scjc4_srt+312;
         const 34;
         const 8589934603;
 },
 sat_sciMV_entry() //  [R1]
         { info_tbl: [(cckuK,
                       label: sat_sciMV_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckuK: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cckuL; else goto cckuM;
       cckuL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckuM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cckuF_info;
           R3 = Text.Printf.formatChar2_closure;
           _sciMd::P64 = P64[R1 + 24];
           R2 = _sciMd::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sciMd::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . uckzP_srtd" {
     uckzP_srtd:
         const Scjc4_srt+320;
         const 33;
         const 4294967301;
 },
 _cckuF() //  [R1]
         { info_tbl: [(cckuF,
                       label: block_cckuF_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckuF: // global
           if (R1 == 1) goto cckuJ; else goto cckuI;
       cckuJ: // global
           _sciMf::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cckva_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sciMf::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cckuI: // global
           I64[Sp] = block_cckuP_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uckvf; else goto cckuR;
       uckvf: // global
           call _cckuP(R1) args: 0, res: 0, upd: 0;
       cckuR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cckva() //  [R1, R2]
         { info_tbl: [(cckva,
                       label: block_cckva_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckva: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckzQ_srtd" {
     uckzQ_srtd:
         const Scjc4_srt+320;
         const 33;
         const 4294967301;
 },
 _cckuP() //  [R1]
         { info_tbl: [(cckuP,
                       label: block_cckuP_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckuP: // global
           _sciMc::P64 = P64[Sp + 8];
           _sciMd::P64 = P64[Sp + 16];
           _sciMf::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cckuY; else goto cckv5;
       cckuY: // global
           I64[Sp + 24] = block_cckuV_info;
           R6 = _sciMd::P64;
           R5 = _sciMc::P64;
           R4 = _sciMf::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cckv5: // global
           I64[Sp + 24] = block_cckv3_info;
           R6 = _sciMd::P64;
           R5 = _sciMc::P64;
           R4 = _sciMf::P64;
           R3 = lvl39_rcccE_closure+2;
           R2 = lvl21_rccck_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckuV() //  [R1, R2]
         { info_tbl: [(cckuV,
                       label: block_cckuV_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckuV: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cckv3() //  [R1, R2]
         { info_tbl: [(cckv3,
                       label: block_cckv3_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckv3: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciN4_entry() //  [R1]
         { info_tbl: [(cckvH,
                       label: sat_sciN4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckvH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cckvI; else goto cckvJ;
       cckvI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckvJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cckvF_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckvF() //  [R1]
         { info_tbl: [(cckvF,
                       label: block_cckvF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckvF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cckvO; else goto cckvN;
       cckvO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cckvN: // global
           if (R1 > 1114111) goto cckvV; else goto cckw2;
       cckvV: // global
           Hp = Hp - 16;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cckw2: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciNa_entry() //  [R1]
         { info_tbl: [(cckwa,
                       label: sat_sciNa_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckwa: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckwb; else goto cckwc;
       cckwb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckwc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cckw8_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call $wfmti_rcccm_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckw8() //  [R1, R2]
         { info_tbl: [(cckw8,
                       label: block_cckw8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckw8: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciNe_entry() //  [R1]
         { info_tbl: [(cckwl,
                       label: sat_sciNe_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckwl: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cckwm; else goto cckwn;
       cckwm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckwn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cckwj_info;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 48;
           call $wfmti_rcccm_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckwj() //  [R1, R2]
         { info_tbl: [(cckwj,
                       label: block_cckwj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckwj: // global
           R6 = R2;
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjustSigned_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciNq_entry() //  [R1]
         { info_tbl: [(cckwz,
                       label: sat_sciNq_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckwz: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cckwA; else goto cckwB;
       cckwA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckwB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cckwu_info;
           R3 = Text.Printf.formatChar2_closure;
           _sciMd::P64 = P64[R1 + 24];
           R2 = _sciMd::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sciMd::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckwu() //  [R1]
         { info_tbl: [(cckwu,
                       label: block_cckwu_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckwu: // global
           if (R1 == 1) goto cckwy; else goto cckwx;
       cckwy: // global
           _sciMf::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cckwZ_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sciMf::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cckwx: // global
           I64[Sp] = block_cckwE_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uckx4; else goto cckwG;
       uckx4: // global
           call _cckwE(R1) args: 0, res: 0, upd: 0;
       cckwG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cckwZ() //  [R1, R2]
         { info_tbl: [(cckwZ,
                       label: block_cckwZ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckwZ: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cckwE() //  [R1]
         { info_tbl: [(cckwE,
                       label: block_cckwE_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckwE: // global
           _sciMc::P64 = P64[Sp + 8];
           _sciMd::P64 = P64[Sp + 16];
           _sciMf::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cckwN; else goto cckwU;
       cckwN: // global
           I64[Sp + 24] = block_cckwK_info;
           R6 = _sciMd::P64;
           R5 = _sciMc::P64;
           R4 = _sciMf::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cckwU: // global
           I64[Sp + 24] = block_cckwS_info;
           R6 = _sciMd::P64;
           R5 = _sciMc::P64;
           R4 = _sciMf::P64;
           R3 = lvl40_rcccF_closure+2;
           R2 = lvl32_rcccx_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckwK() //  [R1, R2]
         { info_tbl: [(cckwK,
                       label: block_cckwK_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckwK: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cckwS() //  [R1, R2]
         { info_tbl: [(cckwS,
                       label: block_cckwS_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckwS: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciNu_entry() //  [R1]
         { info_tbl: [(cckxc,
                       label: sat_sciNu_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckxc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cckxd; else goto cckxe;
       cckxd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckxe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cckxa_info;
           R6 = P64[R1 + 24];
           R5 = P64[R1 + 16];
           R4 = P64[R1 + 32];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl35_rcccA_closure;
           P64[Sp - 32] = P64[R1 + 40];
           P64[Sp - 24] = P64[R1 + 48];
           Sp = Sp - 40;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckxa() //  [R1, R2]
         { info_tbl: [(cckxa,
                       label: block_cckxa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckxa: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciNG_entry() //  [R1]
         { info_tbl: [(cckxq,
                       label: sat_sciNG_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckxq: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cckxr; else goto cckxs;
       cckxr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckxs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_cckxl_info;
           R3 = Text.Printf.formatChar2_closure;
           _sciMd::P64 = P64[R1 + 24];
           R2 = _sciMd::P64;
           P64[Sp - 64] = P64[R1 + 16];
           P64[Sp - 56] = _sciMd::P64;
           P64[Sp - 48] = P64[R1 + 32];
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 48];
           P64[Sp - 24] = P64[R1 + 56];
           Sp = Sp - 72;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckxl() //  [R1]
         { info_tbl: [(cckxl,
                       label: block_cckxl_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckxl: // global
           if (R1 == 1) goto cckxp; else goto cckxo;
       cckxp: // global
           _sciMf::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cckxQ_info;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = _sciMf::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cckxo: // global
           I64[Sp] = block_cckxv_info;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto uckxV; else goto cckxx;
       uckxV: // global
           call _cckxv(R1) args: 0, res: 0, upd: 0;
       cckxx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cckxQ() //  [R1, R2]
         { info_tbl: [(cckxQ,
                       label: block_cckxQ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckxQ: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cckxv() //  [R1]
         { info_tbl: [(cckxv,
                       label: block_cckxv_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckxv: // global
           _sciMc::P64 = P64[Sp + 8];
           _sciMd::P64 = P64[Sp + 16];
           _sciMf::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cckxE; else goto cckxL;
       cckxE: // global
           I64[Sp + 24] = block_cckxB_info;
           R6 = _sciMd::P64;
           R5 = _sciMc::P64;
           R4 = _sciMf::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
       cckxL: // global
           I64[Sp + 24] = block_cckxJ_info;
           R6 = _sciMd::P64;
           R5 = _sciMc::P64;
           R4 = _sciMf::P64;
           R3 = lvl41_rcccG_closure+2;
           R2 = lvl24_rcccp_closure;
           Sp = Sp + 24;
           call $wfmtu_rcccl_entry(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _cckxB() //  [R1, R2]
         { info_tbl: [(cckxB,
                       label: block_cckxB_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckxB: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 _cckxJ() //  [R1, R2]
         { info_tbl: [(cckxJ,
                       label: block_cckxJ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckxJ: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Text.Printf.$wadjust_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckzR_srtd" {
     uckzR_srtd:
         const Scjc4_srt+320;
         const 43;
         const 8795556937825;
 },
 Text.Printf.$wformatIntegral_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccky0,
                       label: Text.Printf.$wformatIntegral_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccky0: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccky1; else goto ccky2;
       ccky1: // global
           R1 = Text.Printf.$wformatIntegral_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       ccky2: // global
           I64[Sp - 48] = block_ccksF_info;
           R1 = R5;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckzM; else goto ccksG;
       uckzM: // global
           call _ccksF(R1) args: 0, res: 0, upd: 0;
       ccksG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckzS_srtd" {
     uckzS_srtd:
         const Scjc4_srt+320;
         const 43;
         const 7696045310049;
 },
 _ccksF() //  [R1]
         { info_tbl: [(ccksF,
                       label: block_ccksF_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccksF: // global
           _sciMg::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cckxX; else goto cckxY;
       cckxX: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cckyK; else goto cckyJ;
       cckyK: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckyJ: // global
           _sciMe::P64 = P64[Sp + 24];
           _sciMh::P64 = P64[Sp + 48];
           _sciMi::P64 = P64[Sp + 56];
           _sciMj::P64 = P64[Sp + 64];
           _sciNI::I64 = I64[Sp + 72];
           if (_sciNI::I64 != 118) goto cckyM; else goto cckyN;
       cckyM: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sciNI::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sciMe::P64;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = _sciMg::P64;
           P64[Hp - 24] = _sciMh::P64;
           P64[Hp - 16] = _sciMi::P64;
           P64[Hp - 8] = _sciMj::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 72] = _sciMe::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sciMg::P64;
           P64[Sp + 48] = _sciMh::P64;
           P64[Sp + 40] = _sciMi::P64;
           P64[Sp + 24] = _sciMj::P64;
           I64[Sp] = _sciNI::I64;
           Sp = Sp - 8;
           goto uckzz;
       cckyN: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sciMe::P64;
           P64[Hp - 56] = GHC.Base.Nothing_closure+1;
           P64[Hp - 48] = _sciMg::P64;
           P64[Hp - 40] = _sciMh::P64;
           P64[Hp - 32] = _sciMi::P64;
           P64[Hp - 24] = _sciMj::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccksP::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 72] = _sciMe::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sciMg::P64;
           P64[Sp + 48] = _sciMh::P64;
           P64[Sp + 40] = _sciMi::P64;
           P64[Sp + 24] = _sciMj::P64;
           I64[Sp] = 100;
           Sp = Sp - 8;
           goto uckzz;
       uckzz: // global
           call _cckto() args: 0, res: 0, upd: 0;
       cckxY: // global
           I64[Sp] = block_ccksS_info;
           _sciNH::P64 = R1;
           R1 = _sciMg::P64;
           P64[Sp + 40] = _sciNH::P64;
           if (R1 & 7 != 0) goto uckzx; else goto ccksT;
       uckzx: // global
           call _ccksS(R1) args: 0, res: 0, upd: 0;
       ccksT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckzT_srtd" {
     uckzT_srtd:
         const Scjc4_srt+320;
         const 43;
         const 7696045310049;
 },
 _ccksS() //  [R1]
         { info_tbl: [(ccksS,
                       label: block_ccksS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccksS: // global
           if (R1 & 7 == 1) goto cckyQ; else goto cckyY;
       cckyQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cckyT; else goto cckyS;
       cckyT: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckyS: // global
           _sciMe::P64 = P64[Sp + 24];
           _sciMh::P64 = P64[Sp + 48];
           _sciMi::P64 = P64[Sp + 56];
           _sciMj::P64 = P64[Sp + 64];
           _sciNH::P64 = P64[Sp + 40];
           _sciNO::I64 = I64[Sp + 72];
           if (_sciNO::I64 != 118) goto cckyV; else goto cckyW;
       cckyV: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sciNO::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sciMe::P64;
           P64[Hp - 40] = _sciNH::P64;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = _sciMh::P64;
           P64[Hp - 16] = _sciMi::P64;
           P64[Hp - 8] = _sciMj::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 72] = _sciMe::P64;
           P64[Sp + 64] = _sciNH::P64;
           P64[Sp + 56] = GHC.Base.Nothing_closure+1;
           P64[Sp + 48] = _sciMh::P64;
           P64[Sp + 40] = _sciMi::P64;
           P64[Sp + 24] = _sciMj::P64;
           I64[Sp] = _sciNO::I64;
           Sp = Sp - 8;
           goto uckzC;
       cckyW: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sciMe::P64;
           P64[Hp - 56] = _sciNH::P64;
           P64[Hp - 48] = GHC.Base.Nothing_closure+1;
           P64[Hp - 40] = _sciMh::P64;
           P64[Hp - 32] = _sciMi::P64;
           P64[Hp - 24] = _sciMj::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _cckt2::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 72] = _sciMe::P64;
           P64[Sp + 64] = _sciNH::P64;
           P64[Sp + 56] = GHC.Base.Nothing_closure+1;
           P64[Sp + 48] = _sciMh::P64;
           P64[Sp + 40] = _sciMi::P64;
           P64[Sp + 24] = _sciMj::P64;
           I64[Sp] = 100;
           Sp = Sp - 8;
           goto uckzC;
       uckzC: // global
           call _cckto() args: 0, res: 0, upd: 0;
       cckyY: // global
           I64[Sp - 8] = block_cckt5_info;
           _sciNN::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp] = _sciNN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckzA; else goto cckt6;
       uckzA: // global
           call _cckt5(R1) args: 0, res: 0, upd: 0;
       cckt6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckzU_srtd" {
     uckzU_srtd:
         const Scjc4_srt+320;
         const 43;
         const 7696045310049;
 },
 _cckt5() //  [R1]
         { info_tbl: [(cckt5,
                       label: block_cckt5_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckt5: // global
           _sciMe::P64 = P64[Sp + 32];
           _sciMh::P64 = P64[Sp + 56];
           _sciMi::P64 = P64[Sp + 64];
           _sciMj::P64 = P64[Sp + 72];
           _sciMk::I64 = I64[Sp + 80];
           _sciNH::P64 = P64[Sp + 48];
           if (R1 & 7 == 1) goto cckz0; else goto cckz7;
       cckz0: // global
           Hp = Hp + 80;
           _sciNT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cckza; else goto cckz2;
       cckz2: // global
           _sciNN::P64 = P64[Sp + 8];
           if (_sciMk::I64 == 118) goto cckz6; else goto cckz5;
       cckz6: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sciMe::P64;
           P64[Hp - 56] = _sciNH::P64;
           P64[Hp - 48] = _sciNN::P64;
           P64[Hp - 40] = _sciMh::P64;
           P64[Hp - 32] = _sciMi::P64;
           P64[Hp - 24] = _sciMj::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccktf::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 80] = _sciMe::P64;
           P64[Sp + 72] = _sciNH::P64;
           P64[Sp + 64] = _sciNN::P64;
           P64[Sp + 56] = _sciMh::P64;
           P64[Sp + 48] = _sciMi::P64;
           P64[Sp + 32] = _sciMj::P64;
           I64[Sp + 8] = 100;
           goto uckzG;
       cckz5: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sciMk::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sciMe::P64;
           P64[Hp - 40] = _sciNH::P64;
           P64[Hp - 32] = _sciNN::P64;
           P64[Hp - 24] = _sciMh::P64;
           P64[Hp - 16] = _sciMi::P64;
           P64[Hp - 8] = _sciMj::P64;
           P64[Hp] = Hp - 71;
           P64[Sp + 80] = _sciMe::P64;
           P64[Sp + 72] = _sciNH::P64;
           P64[Sp + 64] = _sciNN::P64;
           P64[Sp + 56] = _sciMh::P64;
           P64[Sp + 48] = _sciMi::P64;
           P64[Sp + 32] = _sciMj::P64;
           I64[Sp + 8] = _sciMk::I64;
           goto uckzG;
       cckz7: // global
           Hp = Hp + 80;
           _sciNT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cckza; else goto cckz9;
       cckza: // global
           HpAlloc = 80;
           R1 = _sciNT::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckz9: // global
           if (_sciMk::I64 == 118) goto cckzd; else goto cckzc;
       cckzd: // global
           I64[Hp - 72] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 64] = _sciMe::P64;
           P64[Hp - 56] = _sciNH::P64;
           P64[Hp - 48] = GHC.Base.Nothing_closure+1;
           P64[Hp - 40] = _sciMh::P64;
           P64[Hp - 32] = _sciMi::P64;
           P64[Hp - 24] = _sciMj::P64;
           P64[Hp - 16] = lvl23_rccco_closure+1;
           _ccktn::P64 = Hp - 71;
           Hp = Hp - 16;
           P64[Sp + 80] = _sciMe::P64;
           P64[Sp + 72] = _sciNH::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 56] = _sciMh::P64;
           P64[Sp + 48] = _sciMi::P64;
           P64[Sp + 32] = _sciMj::P64;
           I64[Sp + 8] = 100;
           goto uckzG;
       cckzc: // global
           I64[Hp - 72] = GHC.Types.C#_con_info;
           I64[Hp - 64] = _sciMk::I64;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = _sciMe::P64;
           P64[Hp - 40] = _sciNH::P64;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = _sciMh::P64;
           P64[Hp - 16] = _sciMi::P64;
           P64[Hp - 8] = _sciMj::P64;
           P64[Hp] = Hp - 71;
           I64[Sp + 8] = _sciMk::I64;
           P64[Sp + 32] = _sciMj::P64;
           P64[Sp + 48] = _sciMi::P64;
           P64[Sp + 56] = _sciMh::P64;
           P64[Sp + 64] = GHC.Base.Nothing_closure+1;
           P64[Sp + 72] = _sciNH::P64;
           P64[Sp + 80] = _sciMe::P64;
           goto uckzG;
       uckzG: // global
           call _cckto() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . uckzV_srtd" {
     uckzV_srtd:
         const Scjc4_srt+320;
         const 43;
         const 7696045310049;
 },
 _cckto() //  []
         { info_tbl: [(cckto,
                       label: block_cckto_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckto: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccky5; else goto ccky4;
       ccky5: // global
           HpAlloc = 64;
           I64[Sp] = block_cckto_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccky4: // global
           _sciMu::I64 = I64[Sp + 8];
           if (_sciMu::I64 >= 121) goto ccky7; else goto uckzi;
       uckzi: // global
           _sciMc::P64 = P64[Sp + 16];
           _sciMd::P64 = P64[Sp + 24];
           _sciMf::P64 = P64[Sp + 40];
           _sciMm::P64 = P64[Sp + 80];
           _sciMo::P64 = P64[Sp + 64];
           _sciMq::P64 = P64[Sp + 48];
           if (_sciMu::I64 < 98) goto uckzj; else goto uckzk;
       uckzj: // global
           if (_sciMu::I64 != 88) goto ccky7; else goto ccky8;
       ccky8: // global
           I64[Hp - 56] = sat_sciMJ_info;
           P64[Hp - 40] = _sciMc::P64;
           P64[Hp - 32] = _sciMd::P64;
           P64[Hp - 24] = _sciMf::P64;
           P64[Hp - 16] = _sciMm::P64;
           P64[Hp - 8] = _sciMo::P64;
           P64[Hp] = _sciMq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       uckzk: // global
           _sciMp::P64 = P64[Sp + 56];
           switch [98 .. 120] _sciMu::I64 {
               case 98 : goto ccky9;
               case 99 : goto cckya;
               case 100 : goto cckyD;
               case 105 : goto cckyE;
               case 111 : goto cckyF;
               case 117 : goto cckyG;
               case 120 : goto cckyH;
               default: {goto ccky7;}
           }
       cckyH: // global
           I64[Hp - 56] = sat_sciNG_info;
           P64[Hp - 40] = _sciMc::P64;
           P64[Hp - 32] = _sciMd::P64;
           P64[Hp - 24] = _sciMf::P64;
           P64[Hp - 16] = _sciMm::P64;
           P64[Hp - 8] = _sciMo::P64;
           P64[Hp] = _sciMq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cckyG: // global
           I64[Hp - 56] = sat_sciNu_info;
           P64[Hp - 40] = _sciMc::P64;
           P64[Hp - 32] = _sciMd::P64;
           P64[Hp - 24] = _sciMf::P64;
           P64[Hp - 16] = _sciMm::P64;
           P64[Hp - 8] = _sciMo::P64;
           _cckx6::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _cckx6::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cckyF: // global
           I64[Hp - 56] = sat_sciNq_info;
           P64[Hp - 40] = _sciMc::P64;
           P64[Hp - 32] = _sciMd::P64;
           P64[Hp - 24] = _sciMf::P64;
           P64[Hp - 16] = _sciMm::P64;
           P64[Hp - 8] = _sciMo::P64;
           P64[Hp] = _sciMq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cckyE: // global
           I64[Hp - 56] = sat_sciNe_info;
           P64[Hp - 40] = _sciMd::P64;
           P64[Hp - 32] = _sciMf::P64;
           P64[Hp - 24] = _sciMm::P64;
           P64[Hp - 16] = _sciMo::P64;
           P64[Hp - 8] = _sciMp::P64;
           _cckwf::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _cckwf::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cckyD: // global
           I64[Hp - 56] = sat_sciNa_info;
           P64[Hp - 40] = _sciMd::P64;
           P64[Hp - 32] = _sciMf::P64;
           P64[Hp - 24] = _sciMm::P64;
           P64[Hp - 16] = _sciMo::P64;
           P64[Hp - 8] = _sciMp::P64;
           _cckw4::P64 = Hp - 56;
           Hp = Hp - 8;
           R2 = _cckw4::P64;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cckya: // global
           Hp = Hp - 64;
           I64[Sp + 16] = block_cckvh_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = _sciMd::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ccky9: // global
           I64[Hp - 56] = sat_sciMV_info;
           P64[Hp - 40] = _sciMc::P64;
           P64[Hp - 32] = _sciMd::P64;
           P64[Hp - 24] = _sciMf::P64;
           P64[Hp - 16] = _sciMm::P64;
           P64[Hp - 8] = _sciMo::P64;
           P64[Hp] = _sciMq::P64;
           R2 = Hp - 56;
           R1 = GHC.Base.++_closure+2;
           Sp = Sp + 88;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       ccky7: // global
           Hp = Hp - 64;
           R2 = _sciMu::I64;
           Sp = Sp + 88;
           call Text.Printf.$werrorBadFormat_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cckvh() //  [R1]
         { info_tbl: [(cckvh,
                       label: block_cckvh_info
                       rep:StackRep [False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckvh: // global
           if (R1 == 1) goto cckyg; else goto uckzt;
       cckyg: // global
           I64[Sp] = block_cckvm_info;
           R3 = lvl31_rcccw_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       uckzt: // global
           Sp = Sp + 72;
           call _cckyC() args: 0, res: 0, upd: 0;
     }
 },
 _cckvm() //  [R1]
         { info_tbl: [(cckvm,
                       label: block_cckvm_info
                       rep:StackRep [False, False, True, True, True, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckvm: // global
           if (R1 == 1) goto cckym; else goto uckzu;
       cckym: // global
           I64[Sp] = block_cckvr_info;
           R1 = P64[Sp + 56];
           if (R1 & 7 != 0) goto uckzI; else goto cckvs;
       uckzI: // global
           call _cckvr(R1) args: 0, res: 0, upd: 0;
       cckvs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uckzu: // global
           Sp = Sp + 72;
           call _cckyC() args: 0, res: 0, upd: 0;
     }
 },
 _cckvr() //  [R1]
         { info_tbl: [(cckvr,
                       label: block_cckvr_info
                       rep:StackRep [False, False, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckvr: // global
           if (R1 & 7 == 1) goto cckyp; else goto uckzv;
       cckyp: // global
           I64[Sp] = block_cckvw_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[Sp + 16];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
       uckzv: // global
           Sp = Sp + 72;
           call _cckyC() args: 0, res: 0, upd: 0;
     }
 },
 _cckvw() //  [R1]
         { info_tbl: [(cckvw,
                       label: block_cckvw_info
                       rep:StackRep [False, True, True, True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckvw: // global
           if (R1 & 7 == 1) goto uckzw; else goto cckyv;
       uckzw: // global
           Sp = Sp + 72;
           call _cckyC() args: 0, res: 0, upd: 0;
       cckyv: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cckyy; else goto cckyx;
       cckyy: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckyx: // global
           I64[Hp - 40] = sat_sciN4_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R6 = 115;
           R5 = P64[Sp + 48];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[Sp + 64];
           R2 = Hp - 14;
           Sp = Sp + 72;
           call Text.Printf.$w$sformatString_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 _cckyC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckyC: // global
           R1 = lvl30_rcccv_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.113635868 UTC

[section ""data" . Text.Printf.formatIntegral_closure" {
     Text.Printf.formatIntegral_closure:
         const Text.Printf.formatIntegral_info;
         const 0;
 },
 Text.Printf.formatIntegral_entry() //  [R2, R3, R4]
         { info_tbl: [(cckFz,
                       label: Text.Printf.formatIntegral_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckFz: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cckFD; else goto cckFE;
       cckFD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatIntegral_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cckFE: // global
           I64[Sp - 24] = block_cckFw_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uckFM; else goto cckFx;
       uckFM: // global
           call _cckFw(R1) args: 0, res: 0, upd: 0;
       cckFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckFw() //  [R1]
         { info_tbl: [(cckFw,
                       label: block_cckFw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckFw: // global
           I64[Sp - 48] = block_cckFC_info;
           _sciO6::P64 = P64[R1 + 7];
           _sciO7::P64 = P64[R1 + 15];
           _sciO8::P64 = P64[R1 + 23];
           _sciO9::P64 = P64[R1 + 31];
           _sciOa::P64 = P64[R1 + 39];
           _sciOb::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciO7::P64;
           P64[Sp - 32] = _sciO8::P64;
           P64[Sp - 24] = _sciO9::P64;
           P64[Sp - 16] = _sciOa::P64;
           P64[Sp - 8] = _sciOb::P64;
           P64[Sp] = _sciO6::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckFL; else goto cckFG;
       uckFL: // global
           call _cckFC(R1) args: 0, res: 0, upd: 0;
       cckFG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckFC() //  [R1]
         { info_tbl: [(cckFC,
                       label: block_cckFC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckFC: // global
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           _sciOb::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sciOb::P64;
           I64[Sp + 64] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.121614349 UTC

[section ""data" . Text.Printf.formatChar1_closure" {
     Text.Printf.formatChar1_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.formatChar2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.124253393 UTC

[section ""data" . Text.Printf.$wformatChar_closure" {
     Text.Printf.$wformatChar_closure:
         const Text.Printf.$wformatChar_info;
         const 0;
 },
 Text.Printf.$wformatChar_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckG7: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatChar_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2,
                                               R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sciOr_entry() //  [R1]
         { info_tbl: [(cckGk,
                       label: sat_sciOr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckGk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cckGl; else goto cckGm;
       cckGl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckGm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cckGh_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uckGr; else goto cckGi;
       uckGr: // global
           call _cckGh(R1) args: 0, res: 0, upd: 0;
       cckGi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cckGh() //  [R1]
         { info_tbl: [(cckGh,
                       label: block_cckGh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckGh: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciOv_entry() //  [R1]
         { info_tbl: [(cckGA,
                       label: sat_sciOv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckGA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cckGB; else goto cckGC;
       cckGB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckGC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cckGx_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uckGH; else goto cckGy;
       uckGH: // global
           call _cckGx(R1) args: 0, res: 0, upd: 0;
       cckGy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cckGx() //  [R1]
         { info_tbl: [(cckGx,
                       label: block_cckGx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckGx: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$wformatChar_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cckGL,
                       label: Text.Printf.$wformatChar_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckGL: // global
           _sciOj::P64 = R6;
           _sciOi::P64 = R5;
           _sciOh::P64 = R4;
           _sciOg::P64 = R3;
           _sciOf::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cckGM; else goto cckGN;
       cckGN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cckGP; else goto cckGO;
       cckGP: // global
           HpAlloc = 24;
           goto cckGM;
       cckGM: // global
           R1 = Text.Printf.$wformatChar_closure;
           P64[Sp - 40] = _sciOf::P64;
           P64[Sp - 32] = _sciOg::P64;
           P64[Sp - 24] = _sciOh::P64;
           P64[Sp - 16] = _sciOi::P64;
           P64[Sp - 8] = _sciOj::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cckGO: // global
           _sciOn::I64 = I64[Sp + 16];
           if (_sciOn::I64 != 118) goto cckGJ; else goto cckGK;
       cckGJ: // global
           I64[Hp - 16] = sat_sciOr_info;
           P64[Hp] = _sciOf::P64;
           R6 = _sciOi::P64;
           R5 = _sciOh::P64;
           R4 = _sciOg::P64;
           R3 = Hp - 16;
           R2 = Text.Printf.formatChar1_closure+2;
           P64[Sp - 8] = _sciOj::P64;
           I64[Sp + 16] = _sciOn::I64;
           Sp = Sp - 8;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
       cckGK: // global
           I64[Hp - 16] = sat_sciOv_info;
           P64[Hp] = _sciOf::P64;
           R6 = _sciOi::P64;
           R5 = _sciOh::P64;
           R4 = _sciOg::P64;
           R3 = Hp - 16;
           R2 = Text.Printf.formatChar1_closure+2;
           P64[Sp - 8] = _sciOj::P64;
           I64[Sp + 16] = 99;
           Sp = Sp - 8;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.138070545 UTC

[section ""data" . Text.Printf.formatChar_closure" {
     Text.Printf.formatChar_closure:
         const Text.Printf.formatChar_info;
         const 0;
 },
 Text.Printf.formatChar_entry() //  [R2, R3]
         { info_tbl: [(cckHq,
                       label: Text.Printf.formatChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckHq: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cckHu; else goto cckHv;
       cckHu: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckHv: // global
           I64[Sp - 16] = block_cckHn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uckHD; else goto cckHo;
       uckHD: // global
           call _cckHn(R1) args: 0, res: 0, upd: 0;
       cckHo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckHn() //  [R1]
         { info_tbl: [(cckHn,
                       label: block_cckHn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckHn: // global
           I64[Sp - 48] = block_cckHt_info;
           _sciOz::P64 = P64[R1 + 7];
           _sciOA::P64 = P64[R1 + 15];
           _sciOB::P64 = P64[R1 + 23];
           _sciOC::P64 = P64[R1 + 31];
           _sciOD::P64 = P64[R1 + 39];
           _sciOE::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciOA::P64;
           P64[Sp - 32] = _sciOB::P64;
           P64[Sp - 24] = _sciOC::P64;
           P64[Sp - 16] = _sciOD::P64;
           P64[Sp - 8] = _sciOE::P64;
           P64[Sp] = _sciOz::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckHC; else goto cckHx;
       uckHC: // global
           call _cckHt(R1) args: 0, res: 0, upd: 0;
       cckHx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckHt() //  [R1]
         { info_tbl: [(cckHt,
                       label: block_cckHt_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckHt: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sciOE::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sciOE::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatChar_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.146726902 UTC

[section ""data" . Text.Printf.$fPrintfArgChar_closure" {
     Text.Printf.$fPrintfArgChar_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.formatChar_closure+2;
         const Text.Printf.$fPrintfArgChar_$cparseFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.148467602 UTC

[section ""data" . Text.Printf.$fPrintfArgWord1_closure" {
     Text.Printf.$fPrintfArgWord1_closure:
         const GHC.Types.C#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.151820108 UTC

[section ""data" . Text.Printf.$w$sformatInt3_closure" {
     Text.Printf.$w$sformatInt3_closure:
         const Text.Printf.$w$sformatInt3_info;
         const 0;
 },
 Text.Printf.$w$sformatInt3_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckHY: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt3_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sciP6_entry() //  [R1]
         { info_tbl: [(cckIj,
                       label: sat_sciP6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckIj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckIk; else goto cckIl;
       cckIk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckIl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$fIntegralWord64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckJ6_srtd" {
     uckJ6_srtd:
         const Scjc4_srt+192;
         const 62;
         const 2305843009213693957;
 },
 sat_sciP5_entry() //  [R1]
         { info_tbl: [(cckIx,
                       label: sat_sciP5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckIx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckIy; else goto cckIz;
       cckIy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckIz: // global
           I64[Sp - 8] = block_cckIq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckIS; else goto cckIr;
       uckIS: // global
           call _cckIq(R1) args: 0, res: 0, upd: 0;
       cckIr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckJ7_srtd" {
     uckJ7_srtd:
         const Scjc4_srt+192;
         const 62;
         const 2305843009213693957;
 },
 _cckIq() //  [R1]
         { info_tbl: [(cckIq,
                       label: block_cckIq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckIq: // global
           if (R1 & 7 == 1) goto cckIu; else goto cckIv;
       cckIu: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cckIv: // global
           I64[Sp] = block_cckIF_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cckIF() //  [R1]
         { info_tbl: [(cckIF,
                       label: block_cckIF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckIF: // global
           if (R1 & 7 == 1) goto cckIM; else goto cckIQ;
       cckIM: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cckIQ: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uckJ8_srtd" {
     uckJ8_srtd:
         const Scjc4_srt+192;
         const 65;
         const 11601272640106397697;
         const 1;
 },
 Text.Printf.$w$sformatInt3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cckIW,
                       label: Text.Printf.$w$sformatInt3_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckIW: // global
           _sciOM::P64 = R6;
           _sciOL::P64 = R5;
           _sciOK::P64 = R4;
           _sciOJ::P64 = R3;
           _sciOI::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cckIX; else goto cckIY;
       cckIY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cckJ0; else goto cckIZ;
       cckJ0: // global
           HpAlloc = 16;
           goto cckIX;
       cckIX: // global
           R1 = Text.Printf.$w$sformatInt3_closure;
           P64[Sp - 40] = _sciOI::P64;
           P64[Sp - 32] = _sciOJ::P64;
           P64[Sp - 24] = _sciOK::P64;
           P64[Sp - 16] = _sciOL::P64;
           P64[Sp - 8] = _sciOM::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cckIZ: // global
           _sciON::P64 = P64[Sp];
           _sciOO::P64 = P64[Sp + 8];
           _sciP7::I64 = I64[Sp + 16];
           if (_sciP7::I64 != 118) goto cckIU; else goto cckIV;
       cckIU: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sciP7::I64;
           _sciOX::P64 = Hp - 7;
           _sciOW::P64 = _sciOO::P64;
           _sciOV::P64 = _sciON::P64;
           _sciOU::P64 = _sciOM::P64;
           _sciOT::P64 = _sciOL::P64;
           _sciOS::P64 = _sciOK::P64;
           _sciOR::P64 = _sciOJ::P64;
           goto sciOQ;
       cckIV: // global
           Hp = Hp - 16;
           _sciOX::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sciOW::P64 = _sciOO::P64;
           _sciOV::P64 = _sciON::P64;
           _sciOU::P64 = _sciOM::P64;
           _sciOT::P64 = _sciOL::P64;
           _sciOS::P64 = _sciOK::P64;
           _sciOR::P64 = _sciOJ::P64;
           goto sciOQ;
       sciOQ: // global
           I64[Sp - 48] = block_cckIa_info;
           R1 = _sciOX::P64;
           P64[Sp - 40] = _sciOS::P64;
           P64[Sp - 32] = _sciOT::P64;
           P64[Sp - 24] = _sciOU::P64;
           P64[Sp - 16] = _sciOV::P64;
           P64[Sp - 8] = _sciOW::P64;
           P64[Sp] = _sciOR::P64;
           P64[Sp + 16] = _sciOI::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckJ5; else goto cckIb;
       uckJ5: // global
           call _cckIa(R1) args: 0, res: 0, upd: 0;
       cckIb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckJ9_srtd" {
     uckJ9_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _cckIa() //  [R1]
         { info_tbl: [(cckIa,
                       label: block_cckIa_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckIa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cckJ4; else goto cckJ3;
       cckJ4: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckJ3: // global
           _sciOZ::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sciP6_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sciP5_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sciOW::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sciOW::P64;
           I64[Sp + 64] = _sciOZ::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.171277269 UTC

[section ""data" . Text.Printf.$fPrintfArgWord64_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord64_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord64_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord64_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cckK4,
                       label: Text.Printf.$fPrintfArgWord64_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckK4: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cckK8; else goto cckK9;
       cckK8: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord64_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckK9: // global
           I64[Sp - 16] = block_cckK1_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uckKh; else goto cckK2;
       uckKh: // global
           call _cckK1(R1) args: 0, res: 0, upd: 0;
       cckK2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckK1() //  [R1]
         { info_tbl: [(cckK1,
                       label: block_cckK1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckK1: // global
           I64[Sp - 48] = block_cckK7_info;
           _sciPc::P64 = P64[R1 + 7];
           _sciPd::P64 = P64[R1 + 15];
           _sciPe::P64 = P64[R1 + 23];
           _sciPf::P64 = P64[R1 + 31];
           _sciPg::P64 = P64[R1 + 39];
           _sciPh::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciPd::P64;
           P64[Sp - 32] = _sciPe::P64;
           P64[Sp - 24] = _sciPf::P64;
           P64[Sp - 16] = _sciPg::P64;
           P64[Sp - 8] = _sciPh::P64;
           P64[Sp] = _sciPc::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckKg; else goto cckKb;
       uckKg: // global
           call _cckK7(R1) args: 0, res: 0, upd: 0;
       cckKb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckK7() //  [R1]
         { info_tbl: [(cckK7,
                       label: block_cckK7_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckK7: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sciPh::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sciPh::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt3_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.180979634 UTC

[section ""data" . Text.Printf.$w$sformatInt2_closure" {
     Text.Printf.$w$sformatInt2_closure:
         const Text.Printf.$w$sformatInt2_info;
         const 0;
 },
 Text.Printf.$w$sformatInt2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckKA: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt2_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sciPJ_entry() //  [R1]
         { info_tbl: [(cckKV,
                       label: sat_sciPJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckKV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckKW; else goto cckKX;
       cckKW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckKX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckLI_srtd" {
     uckLI_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sciPI_entry() //  [R1]
         { info_tbl: [(cckL9,
                       label: sat_sciPI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckL9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckLa; else goto cckLb;
       cckLa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckLb: // global
           I64[Sp - 8] = block_cckL2_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckLu; else goto cckL3;
       uckLu: // global
           call _cckL2(R1) args: 0, res: 0, upd: 0;
       cckL3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckLJ_srtd" {
     uckLJ_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _cckL2() //  [R1]
         { info_tbl: [(cckL2,
                       label: block_cckL2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckL2: // global
           if (R1 & 7 == 1) goto cckL6; else goto cckL7;
       cckL6: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cckL7: // global
           I64[Sp] = block_cckLh_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cckLh() //  [R1]
         { info_tbl: [(cckLh,
                       label: block_cckLh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckLh: // global
           if (R1 & 7 == 1) goto cckLo; else goto cckLs;
       cckLo: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cckLs: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uckLK_srtd" {
     uckLK_srtd:
         const Scjc4_srt+192;
         const 67;
         const 11601272640106397697;
         const 4;
 },
 Text.Printf.$w$sformatInt2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cckLy,
                       label: Text.Printf.$w$sformatInt2_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckLy: // global
           _sciPp::P64 = R6;
           _sciPo::P64 = R5;
           _sciPn::P64 = R4;
           _sciPm::P64 = R3;
           _sciPl::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cckLz; else goto cckLA;
       cckLA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cckLC; else goto cckLB;
       cckLC: // global
           HpAlloc = 16;
           goto cckLz;
       cckLz: // global
           R1 = Text.Printf.$w$sformatInt2_closure;
           P64[Sp - 40] = _sciPl::P64;
           P64[Sp - 32] = _sciPm::P64;
           P64[Sp - 24] = _sciPn::P64;
           P64[Sp - 16] = _sciPo::P64;
           P64[Sp - 8] = _sciPp::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cckLB: // global
           _sciPq::P64 = P64[Sp];
           _sciPr::P64 = P64[Sp + 8];
           _sciPK::I64 = I64[Sp + 16];
           if (_sciPK::I64 != 118) goto cckLw; else goto cckLx;
       cckLw: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sciPK::I64;
           _sciPA::P64 = Hp - 7;
           _sciPz::P64 = _sciPr::P64;
           _sciPy::P64 = _sciPq::P64;
           _sciPx::P64 = _sciPp::P64;
           _sciPw::P64 = _sciPo::P64;
           _sciPv::P64 = _sciPn::P64;
           _sciPu::P64 = _sciPm::P64;
           goto sciPt;
       cckLx: // global
           Hp = Hp - 16;
           _sciPA::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sciPz::P64 = _sciPr::P64;
           _sciPy::P64 = _sciPq::P64;
           _sciPx::P64 = _sciPp::P64;
           _sciPw::P64 = _sciPo::P64;
           _sciPv::P64 = _sciPn::P64;
           _sciPu::P64 = _sciPm::P64;
           goto sciPt;
       sciPt: // global
           I64[Sp - 48] = block_cckKM_info;
           R1 = _sciPA::P64;
           P64[Sp - 40] = _sciPv::P64;
           P64[Sp - 32] = _sciPw::P64;
           P64[Sp - 24] = _sciPx::P64;
           P64[Sp - 16] = _sciPy::P64;
           P64[Sp - 8] = _sciPz::P64;
           P64[Sp] = _sciPu::P64;
           P64[Sp + 16] = _sciPl::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckLH; else goto cckKN;
       uckLH: // global
           call _cckKM(R1) args: 0, res: 0, upd: 0;
       cckKN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckLL_srtd" {
     uckLL_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _cckKM() //  [R1]
         { info_tbl: [(cckKM,
                       label: block_cckKM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckKM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cckLG; else goto cckLF;
       cckLG: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckLF: // global
           _sciPC::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sciPJ_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sciPI_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sciPz::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sciPz::P64;
           I64[Sp + 64] = _sciPC::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.201266734 UTC

[section ""data" . Text.Printf.$fPrintfArgWord32_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord32_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord32_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord32_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cckMG,
                       label: Text.Printf.$fPrintfArgWord32_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckMG: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cckMK; else goto cckML;
       cckMK: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord32_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckML: // global
           I64[Sp - 16] = block_cckMD_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uckMT; else goto cckME;
       uckMT: // global
           call _cckMD(R1) args: 0, res: 0, upd: 0;
       cckME: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckMD() //  [R1]
         { info_tbl: [(cckMD,
                       label: block_cckMD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckMD: // global
           I64[Sp - 48] = block_cckMJ_info;
           _sciPP::P64 = P64[R1 + 7];
           _sciPQ::P64 = P64[R1 + 15];
           _sciPR::P64 = P64[R1 + 23];
           _sciPS::P64 = P64[R1 + 31];
           _sciPT::P64 = P64[R1 + 39];
           _sciPU::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciPQ::P64;
           P64[Sp - 32] = _sciPR::P64;
           P64[Sp - 24] = _sciPS::P64;
           P64[Sp - 16] = _sciPT::P64;
           P64[Sp - 8] = _sciPU::P64;
           P64[Sp] = _sciPP::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckMS; else goto cckMN;
       uckMS: // global
           call _cckMJ(R1) args: 0, res: 0, upd: 0;
       cckMN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckMJ() //  [R1]
         { info_tbl: [(cckMJ,
                       label: block_cckMJ_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckMJ: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sciPU::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sciPU::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt2_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.210367295 UTC

[section ""data" . Text.Printf.$w$sformatInt1_closure" {
     Text.Printf.$w$sformatInt1_closure:
         const Text.Printf.$w$sformatInt1_info;
         const 0;
 },
 Text.Printf.$w$sformatInt1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckNc: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt1_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sciQm_entry() //  [R1]
         { info_tbl: [(cckNx,
                       label: sat_sciQm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckNx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckNy; else goto cckNz;
       cckNy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckNz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckOk_srtd" {
     uckOk_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sciQl_entry() //  [R1]
         { info_tbl: [(cckNL,
                       label: sat_sciQl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckNL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckNM; else goto cckNN;
       cckNM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckNN: // global
           I64[Sp - 8] = block_cckNE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckO6; else goto cckNF;
       uckO6: // global
           call _cckNE(R1) args: 0, res: 0, upd: 0;
       cckNF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckOl_srtd" {
     uckOl_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _cckNE() //  [R1]
         { info_tbl: [(cckNE,
                       label: block_cckNE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckNE: // global
           if (R1 & 7 == 1) goto cckNI; else goto cckNJ;
       cckNI: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cckNJ: // global
           I64[Sp] = block_cckNT_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cckNT() //  [R1]
         { info_tbl: [(cckNT,
                       label: block_cckNT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckNT: // global
           if (R1 & 7 == 1) goto cckO0; else goto cckO4;
       cckO0: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cckO4: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uckOm_srtd" {
     uckOm_srtd:
         const Scjc4_srt+192;
         const 69;
         const 11601272640106397697;
         const 16;
 },
 Text.Printf.$w$sformatInt1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cckOa,
                       label: Text.Printf.$w$sformatInt1_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckOa: // global
           _sciQ2::P64 = R6;
           _sciQ1::P64 = R5;
           _sciQ0::P64 = R4;
           _sciPZ::P64 = R3;
           _sciPY::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cckOb; else goto cckOc;
       cckOc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cckOe; else goto cckOd;
       cckOe: // global
           HpAlloc = 16;
           goto cckOb;
       cckOb: // global
           R1 = Text.Printf.$w$sformatInt1_closure;
           P64[Sp - 40] = _sciPY::P64;
           P64[Sp - 32] = _sciPZ::P64;
           P64[Sp - 24] = _sciQ0::P64;
           P64[Sp - 16] = _sciQ1::P64;
           P64[Sp - 8] = _sciQ2::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cckOd: // global
           _sciQ3::P64 = P64[Sp];
           _sciQ4::P64 = P64[Sp + 8];
           _sciQn::I64 = I64[Sp + 16];
           if (_sciQn::I64 != 118) goto cckO8; else goto cckO9;
       cckO8: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sciQn::I64;
           _sciQd::P64 = Hp - 7;
           _sciQc::P64 = _sciQ4::P64;
           _sciQb::P64 = _sciQ3::P64;
           _sciQa::P64 = _sciQ2::P64;
           _sciQ9::P64 = _sciQ1::P64;
           _sciQ8::P64 = _sciQ0::P64;
           _sciQ7::P64 = _sciPZ::P64;
           goto sciQ6;
       cckO9: // global
           Hp = Hp - 16;
           _sciQd::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sciQc::P64 = _sciQ4::P64;
           _sciQb::P64 = _sciQ3::P64;
           _sciQa::P64 = _sciQ2::P64;
           _sciQ9::P64 = _sciQ1::P64;
           _sciQ8::P64 = _sciQ0::P64;
           _sciQ7::P64 = _sciPZ::P64;
           goto sciQ6;
       sciQ6: // global
           I64[Sp - 48] = block_cckNo_info;
           R1 = _sciQd::P64;
           P64[Sp - 40] = _sciQ8::P64;
           P64[Sp - 32] = _sciQ9::P64;
           P64[Sp - 24] = _sciQa::P64;
           P64[Sp - 16] = _sciQb::P64;
           P64[Sp - 8] = _sciQc::P64;
           P64[Sp] = _sciQ7::P64;
           P64[Sp + 16] = _sciPY::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckOj; else goto cckNp;
       uckOj: // global
           call _cckNo(R1) args: 0, res: 0, upd: 0;
       cckNp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckOn_srtd" {
     uckOn_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _cckNo() //  [R1]
         { info_tbl: [(cckNo,
                       label: block_cckNo_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckNo: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cckOi; else goto cckOh;
       cckOi: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckOh: // global
           _sciQf::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sciQm_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sciQl_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sciQc::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sciQc::P64;
           I64[Sp + 64] = _sciQf::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.230442413 UTC

[section ""data" . Text.Printf.$fPrintfArgWord16_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord16_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord16_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord16_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cckPi,
                       label: Text.Printf.$fPrintfArgWord16_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckPi: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cckPm; else goto cckPn;
       cckPm: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord16_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckPn: // global
           I64[Sp - 16] = block_cckPf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uckPv; else goto cckPg;
       uckPv: // global
           call _cckPf(R1) args: 0, res: 0, upd: 0;
       cckPg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckPf() //  [R1]
         { info_tbl: [(cckPf,
                       label: block_cckPf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckPf: // global
           I64[Sp - 48] = block_cckPl_info;
           _sciQs::P64 = P64[R1 + 7];
           _sciQt::P64 = P64[R1 + 15];
           _sciQu::P64 = P64[R1 + 23];
           _sciQv::P64 = P64[R1 + 31];
           _sciQw::P64 = P64[R1 + 39];
           _sciQx::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciQt::P64;
           P64[Sp - 32] = _sciQu::P64;
           P64[Sp - 24] = _sciQv::P64;
           P64[Sp - 16] = _sciQw::P64;
           P64[Sp - 8] = _sciQx::P64;
           P64[Sp] = _sciQs::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckPu; else goto cckPp;
       uckPu: // global
           call _cckPl(R1) args: 0, res: 0, upd: 0;
       cckPp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckPl() //  [R1]
         { info_tbl: [(cckPl,
                       label: block_cckPl_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckPl: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sciQx::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sciQx::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt1_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.23955557 UTC

[section ""data" . Text.Printf.$w$sformatInt4_closure" {
     Text.Printf.$w$sformatInt4_closure:
         const Text.Printf.$w$sformatInt4_info;
         const 0;
 },
 Text.Printf.$w$sformatInt4_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckPO: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt4_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sciQZ_entry() //  [R1]
         { info_tbl: [(cckQ9,
                       label: sat_sciQZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckQ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckQa; else goto cckQb;
       cckQa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckQb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Word.$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckQW_srtd" {
     uckQW_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sciQY_entry() //  [R1]
         { info_tbl: [(cckQn,
                       label: sat_sciQY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckQn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckQo; else goto cckQp;
       cckQo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckQp: // global
           I64[Sp - 8] = block_cckQg_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckQI; else goto cckQh;
       uckQI: // global
           call _cckQg(R1) args: 0, res: 0, upd: 0;
       cckQh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckQX_srtd" {
     uckQX_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _cckQg() //  [R1]
         { info_tbl: [(cckQg,
                       label: block_cckQg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckQg: // global
           if (R1 & 7 == 1) goto cckQk; else goto cckQl;
       cckQk: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cckQl: // global
           I64[Sp] = block_cckQv_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cckQv() //  [R1]
         { info_tbl: [(cckQv,
                       label: block_cckQv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckQv: // global
           if (R1 & 7 == 1) goto cckQC; else goto cckQG;
       cckQC: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cckQG: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uckQY_srtd" {
     uckQY_srtd:
         const Scjc4_srt+192;
         const 71;
         const 11601272640106397697;
         const 64;
 },
 Text.Printf.$w$sformatInt4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cckQM,
                       label: Text.Printf.$w$sformatInt4_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckQM: // global
           _sciQF::P64 = R6;
           _sciQE::P64 = R5;
           _sciQD::P64 = R4;
           _sciQC::P64 = R3;
           _sciQB::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cckQN; else goto cckQO;
       cckQO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cckQQ; else goto cckQP;
       cckQQ: // global
           HpAlloc = 16;
           goto cckQN;
       cckQN: // global
           R1 = Text.Printf.$w$sformatInt4_closure;
           P64[Sp - 40] = _sciQB::P64;
           P64[Sp - 32] = _sciQC::P64;
           P64[Sp - 24] = _sciQD::P64;
           P64[Sp - 16] = _sciQE::P64;
           P64[Sp - 8] = _sciQF::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cckQP: // global
           _sciQG::P64 = P64[Sp];
           _sciQH::P64 = P64[Sp + 8];
           _sciR0::I64 = I64[Sp + 16];
           if (_sciR0::I64 != 118) goto cckQK; else goto cckQL;
       cckQK: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sciR0::I64;
           _sciQQ::P64 = Hp - 7;
           _sciQP::P64 = _sciQH::P64;
           _sciQO::P64 = _sciQG::P64;
           _sciQN::P64 = _sciQF::P64;
           _sciQM::P64 = _sciQE::P64;
           _sciQL::P64 = _sciQD::P64;
           _sciQK::P64 = _sciQC::P64;
           goto sciQJ;
       cckQL: // global
           Hp = Hp - 16;
           _sciQQ::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sciQP::P64 = _sciQH::P64;
           _sciQO::P64 = _sciQG::P64;
           _sciQN::P64 = _sciQF::P64;
           _sciQM::P64 = _sciQE::P64;
           _sciQL::P64 = _sciQD::P64;
           _sciQK::P64 = _sciQC::P64;
           goto sciQJ;
       sciQJ: // global
           I64[Sp - 48] = block_cckQ0_info;
           R1 = _sciQQ::P64;
           P64[Sp - 40] = _sciQL::P64;
           P64[Sp - 32] = _sciQM::P64;
           P64[Sp - 24] = _sciQN::P64;
           P64[Sp - 16] = _sciQO::P64;
           P64[Sp - 8] = _sciQP::P64;
           P64[Sp] = _sciQK::P64;
           P64[Sp + 16] = _sciQB::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckQV; else goto cckQ1;
       uckQV: // global
           call _cckQ0(R1) args: 0, res: 0, upd: 0;
       cckQ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckQZ_srtd" {
     uckQZ_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _cckQ0() //  [R1]
         { info_tbl: [(cckQ0,
                       label: block_cckQ0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckQ0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cckQU; else goto cckQT;
       cckQU: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckQT: // global
           _sciQS::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sciQZ_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sciQY_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sciQP::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sciQP::P64;
           I64[Sp + 64] = _sciQS::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.258858624 UTC

[section ""data" . Text.Printf.$fPrintfArgWord8_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord8_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord8_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord8_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cckRU,
                       label: Text.Printf.$fPrintfArgWord8_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckRU: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cckRY; else goto cckRZ;
       cckRY: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord8_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckRZ: // global
           I64[Sp - 16] = block_cckRR_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uckS7; else goto cckRS;
       uckS7: // global
           call _cckRR(R1) args: 0, res: 0, upd: 0;
       cckRS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckRR() //  [R1]
         { info_tbl: [(cckRR,
                       label: block_cckRR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckRR: // global
           I64[Sp - 48] = block_cckRX_info;
           _sciR5::P64 = P64[R1 + 7];
           _sciR6::P64 = P64[R1 + 15];
           _sciR7::P64 = P64[R1 + 23];
           _sciR8::P64 = P64[R1 + 31];
           _sciR9::P64 = P64[R1 + 39];
           _sciRa::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciR6::P64;
           P64[Sp - 32] = _sciR7::P64;
           P64[Sp - 24] = _sciR8::P64;
           P64[Sp - 16] = _sciR9::P64;
           P64[Sp - 8] = _sciRa::P64;
           P64[Sp] = _sciR5::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckS6; else goto cckS1;
       uckS6: // global
           call _cckRX(R1) args: 0, res: 0, upd: 0;
       cckS1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckRX() //  [R1]
         { info_tbl: [(cckRX,
                       label: block_cckRX_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckRX: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sciRa::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sciRa::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt4_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.268009218 UTC

[section ""data" . Text.Printf.$w$sformatInt_closure" {
     Text.Printf.$w$sformatInt_closure:
         const Text.Printf.$w$sformatInt_info;
         const 0;
 },
 Text.Printf.$w$sformatInt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckSq: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt_entry(R6,
                                                R5,
                                                R4,
                                                R3,
                                                R2,
                                                R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_sciRC_entry() //  [R1]
         { info_tbl: [(cckSL,
                       label: sat_sciRC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckSL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckSM; else goto cckSN;
       cckSM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckSN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fIntegralWord_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckTy_srtd" {
     uckTy_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11529215046068469761;
 },
 sat_sciRB_entry() //  [R1]
         { info_tbl: [(cckSZ,
                       label: sat_sciRB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckSZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckT0; else goto cckT1;
       cckT0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckT1: // global
           I64[Sp - 8] = block_cckSS_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckTk; else goto cckST;
       uckTk: // global
           call _cckSS(R1) args: 0, res: 0, upd: 0;
       cckST: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckTz_srtd" {
     uckTz_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11529215046068469761;
 },
 _cckSS() //  [R1]
         { info_tbl: [(cckSS,
                       label: block_cckSS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckSS: // global
           if (R1 & 7 == 1) goto cckSW; else goto cckSX;
       cckSW: // global
           R1 = Text.Printf.formatChar1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cckSX: // global
           I64[Sp] = block_cckT7_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cckT7() //  [R1]
         { info_tbl: [(cckT7,
                       label: block_cckT7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckT7: // global
           if (R1 & 7 == 1) goto cckTe; else goto cckTi;
       cckTe: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cckTi: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uckTA_srtd" {
     uckTA_srtd:
         const Scjc4_srt+192;
         const 73;
         const 11601272640106397697;
         const 256;
 },
 Text.Printf.$w$sformatInt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cckTo,
                       label: Text.Printf.$w$sformatInt_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckTo: // global
           _sciRi::P64 = R6;
           _sciRh::P64 = R5;
           _sciRg::P64 = R4;
           _sciRf::P64 = R3;
           _sciRe::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cckTp; else goto cckTq;
       cckTq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cckTs; else goto cckTr;
       cckTs: // global
           HpAlloc = 16;
           goto cckTp;
       cckTp: // global
           R1 = Text.Printf.$w$sformatInt_closure;
           P64[Sp - 40] = _sciRe::P64;
           P64[Sp - 32] = _sciRf::P64;
           P64[Sp - 24] = _sciRg::P64;
           P64[Sp - 16] = _sciRh::P64;
           P64[Sp - 8] = _sciRi::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cckTr: // global
           _sciRj::P64 = P64[Sp];
           _sciRk::P64 = P64[Sp + 8];
           _sciRD::I64 = I64[Sp + 16];
           if (_sciRD::I64 != 118) goto cckTm; else goto cckTn;
       cckTm: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sciRD::I64;
           _sciRt::P64 = Hp - 7;
           _sciRs::P64 = _sciRk::P64;
           _sciRr::P64 = _sciRj::P64;
           _sciRq::P64 = _sciRi::P64;
           _sciRp::P64 = _sciRh::P64;
           _sciRo::P64 = _sciRg::P64;
           _sciRn::P64 = _sciRf::P64;
           goto sciRm;
       cckTn: // global
           Hp = Hp - 16;
           _sciRt::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sciRs::P64 = _sciRk::P64;
           _sciRr::P64 = _sciRj::P64;
           _sciRq::P64 = _sciRi::P64;
           _sciRp::P64 = _sciRh::P64;
           _sciRo::P64 = _sciRg::P64;
           _sciRn::P64 = _sciRf::P64;
           goto sciRm;
       sciRm: // global
           I64[Sp - 48] = block_cckSC_info;
           R1 = _sciRt::P64;
           P64[Sp - 40] = _sciRo::P64;
           P64[Sp - 32] = _sciRp::P64;
           P64[Sp - 24] = _sciRq::P64;
           P64[Sp - 16] = _sciRr::P64;
           P64[Sp - 8] = _sciRs::P64;
           P64[Sp] = _sciRn::P64;
           P64[Sp + 16] = _sciRe::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckTx; else goto cckSD;
       uckTx: // global
           call _cckSC(R1) args: 0, res: 0, upd: 0;
       cckSD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckTB_srtd" {
     uckTB_srtd:
         const Scjc4_srt+192;
         const 64;
         const 11601272640106397697;
 },
 _cckSC() //  [R1]
         { info_tbl: [(cckSC,
                       label: block_cckSC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckSC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cckTw; else goto cckTv;
       cckTw: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckTv: // global
           _sciRv::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sciRC_info;
           P64[Hp - 24] = P64[Sp + 64];
           I64[Hp - 16] = sat_sciRB_info;
           P64[Hp] = P64[Sp + 56];
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sciRs::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 32];
           P64[Sp + 56] = _sciRs::P64;
           I64[Sp + 64] = _sciRv::I64;
           Sp = Sp + 40;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.288126478 UTC

[section ""data" . Text.Printf.$fPrintfArgWord_$sformatInt_closure" {
     Text.Printf.$fPrintfArgWord_$sformatInt_closure:
         const Text.Printf.$fPrintfArgWord_$sformatInt_info;
         const 0;
 },
 Text.Printf.$fPrintfArgWord_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cckUw,
                       label: Text.Printf.$fPrintfArgWord_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckUw: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cckUA; else goto cckUB;
       cckUA: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgWord_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckUB: // global
           I64[Sp - 16] = block_cckUt_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uckUJ; else goto cckUu;
       uckUJ: // global
           call _cckUt(R1) args: 0, res: 0, upd: 0;
       cckUu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckUt() //  [R1]
         { info_tbl: [(cckUt,
                       label: block_cckUt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckUt: // global
           I64[Sp - 48] = block_cckUz_info;
           _sciRI::P64 = P64[R1 + 7];
           _sciRJ::P64 = P64[R1 + 15];
           _sciRK::P64 = P64[R1 + 23];
           _sciRL::P64 = P64[R1 + 31];
           _sciRM::P64 = P64[R1 + 39];
           _sciRN::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciRJ::P64;
           P64[Sp - 32] = _sciRK::P64;
           P64[Sp - 24] = _sciRL::P64;
           P64[Sp - 16] = _sciRM::P64;
           P64[Sp - 8] = _sciRN::P64;
           P64[Sp] = _sciRI::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckUI; else goto cckUD;
       uckUI: // global
           call _cckUz(R1) args: 0, res: 0, upd: 0;
       cckUD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckUz() //  [R1]
         { info_tbl: [(cckUz,
                       label: block_cckUz_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckUz: // global
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 48];
           R2 = P64[Sp + 56];
           _sciRN::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 32];
           P64[Sp + 48] = _sciRN::P64;
           I64[Sp + 56] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$w$sformatInt_entry(R6,
                                                R5,
                                                R4,
                                                R3,
                                                R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.296037434 UTC

[section ""data" . Text.Printf.$fPrintfArgInt1_closure" {
     Text.Printf.$fPrintfArgInt1_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar7_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.29880439 UTC

[section ""data" . Text.Printf.$fPrintfArgInt64_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt64_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt64_$sformatInt_info;
         const 0;
 },
 sat_sciS9_entry() //  [R1]
         { info_tbl: [(cckVk,
                       label: sat_sciS9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckVk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckVl; else goto cckVm;
       cckVl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckVm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt64_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckW3_srtd" {
     uckW3_srtd:
         const Scjc4_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 sat_sciS8_entry() //  [R1]
         { info_tbl: [(cckVy,
                       label: sat_sciS8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckVy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckVz; else goto cckVA;
       cckVz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckVA: // global
           I64[Sp - 8] = block_cckVr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckVT; else goto cckVs;
       uckVT: // global
           call _cckVr(R1) args: 0, res: 0, upd: 0;
       cckVs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckW4_srtd" {
     uckW4_srtd:
         const Scjc4_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 _cckVr() //  [R1]
         { info_tbl: [(cckVr,
                       label: block_cckVr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckVr: // global
           if (R1 & 7 == 1) goto cckVv; else goto cckVw;
       cckVv: // global
           R1 = Text.Printf.$fPrintfArgInt1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cckVw: // global
           I64[Sp] = block_cckVG_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cckVG() //  [R1]
         { info_tbl: [(cckVG,
                       label: block_cckVG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckVG: // global
           if (R1 & 7 == 1) goto cckVN; else goto cckVR;
       cckVN: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cckVR: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uckW5_srtd" {
     uckW5_srtd:
         const Scjc4_srt+192;
         const 76;
         const 9295429630892703745;
         const 3072;
 },
 Text.Printf.$fPrintfArgInt64_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cckVU,
                       label: Text.Printf.$fPrintfArgInt64_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckVU: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cckVV; else goto cckVW;
       cckVV: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt64_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckVW: // global
           I64[Sp - 16] = block_cckV6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uckW2; else goto cckV7;
       uckW2: // global
           call _cckV6(R1) args: 0, res: 0, upd: 0;
       cckV7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckW6_srtd" {
     uckW6_srtd:
         const Scjc4_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _cckV6() //  [R1]
         { info_tbl: [(cckV6,
                       label: block_cckV6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckV6: // global
           I64[Sp - 48] = block_cckVb_info;
           _sciRU::P64 = P64[R1 + 7];
           _sciRV::P64 = P64[R1 + 15];
           _sciRW::P64 = P64[R1 + 23];
           _sciRX::P64 = P64[R1 + 31];
           _sciRY::P64 = P64[R1 + 39];
           _sciRZ::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciRV::P64;
           P64[Sp - 32] = _sciRW::P64;
           P64[Sp - 24] = _sciRX::P64;
           P64[Sp - 16] = _sciRY::P64;
           P64[Sp - 8] = _sciRZ::P64;
           P64[Sp] = _sciRU::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckW1; else goto cckVc;
       uckW1: // global
           call _cckVb(R1) args: 0, res: 0, upd: 0;
       cckVc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckW7_srtd" {
     uckW7_srtd:
         const Scjc4_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _cckVb() //  [R1]
         { info_tbl: [(cckVb,
                       label: block_cckVb_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckVb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cckW0; else goto cckVZ;
       cckW0: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckVZ: // global
           _sciS2::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sciS9_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sciS8_info;
           _sciRZ::P64 = P64[Sp + 40];
           P64[Hp] = _sciRZ::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sciRY::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sciRY::P64;
           P64[Sp + 48] = _sciRZ::P64;
           I64[Sp + 56] = _sciS2::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.319149216 UTC

[section ""data" . Text.Printf.$fPrintfArgInt4_closure" {
     Text.Printf.$fPrintfArgInt4_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.321894246 UTC

[section ""data" . Text.Printf.$fPrintfArgInt32_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt32_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt32_$sformatInt_info;
         const 0;
 },
 sat_sciSs_entry() //  [R1]
         { info_tbl: [(cckXf,
                       label: sat_sciSs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckXf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckXg; else goto cckXh;
       cckXg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckXh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt32_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckXY_srtd" {
     uckXY_srtd:
         const Scjc4_srt+192;
         const 77;
         const 9223372036854775809;
         const 4096;
 },
 sat_sciSr_entry() //  [R1]
         { info_tbl: [(cckXt,
                       label: sat_sciSr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckXt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckXu; else goto cckXv;
       cckXu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckXv: // global
           I64[Sp - 8] = block_cckXm_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckXO; else goto cckXn;
       uckXO: // global
           call _cckXm(R1) args: 0, res: 0, upd: 0;
       cckXn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckXZ_srtd" {
     uckXZ_srtd:
         const Scjc4_srt+192;
         const 77;
         const 9223372036854775809;
         const 4096;
 },
 _cckXm() //  [R1]
         { info_tbl: [(cckXm,
                       label: block_cckXm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckXm: // global
           if (R1 & 7 == 1) goto cckXq; else goto cckXr;
       cckXq: // global
           R1 = Text.Printf.$fPrintfArgInt4_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cckXr: // global
           I64[Sp] = block_cckXB_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cckXB() //  [R1]
         { info_tbl: [(cckXB,
                       label: block_cckXB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckXB: // global
           if (R1 & 7 == 1) goto cckXI; else goto cckXM;
       cckXI: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cckXM: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uckY0_srtd" {
     uckY0_srtd:
         const Scjc4_srt+192;
         const 78;
         const 9295429630892703745;
         const 12288;
 },
 Text.Printf.$fPrintfArgInt32_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cckXP,
                       label: Text.Printf.$fPrintfArgInt32_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckXP: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cckXQ; else goto cckXR;
       cckXQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt32_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckXR: // global
           I64[Sp - 16] = block_cckX1_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uckXX; else goto cckX2;
       uckXX: // global
           call _cckX1(R1) args: 0, res: 0, upd: 0;
       cckX2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckY1_srtd" {
     uckY1_srtd:
         const Scjc4_srt+192;
         const 77;
         const 9295429630892703745;
         const 4096;
 },
 _cckX1() //  [R1]
         { info_tbl: [(cckX1,
                       label: block_cckX1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckX1: // global
           I64[Sp - 48] = block_cckX6_info;
           _sciSd::P64 = P64[R1 + 7];
           _sciSe::P64 = P64[R1 + 15];
           _sciSf::P64 = P64[R1 + 23];
           _sciSg::P64 = P64[R1 + 31];
           _sciSh::P64 = P64[R1 + 39];
           _sciSi::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciSe::P64;
           P64[Sp - 32] = _sciSf::P64;
           P64[Sp - 24] = _sciSg::P64;
           P64[Sp - 16] = _sciSh::P64;
           P64[Sp - 8] = _sciSi::P64;
           P64[Sp] = _sciSd::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckXW; else goto cckX7;
       uckXW: // global
           call _cckX6(R1) args: 0, res: 0, upd: 0;
       cckX7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckY2_srtd" {
     uckY2_srtd:
         const Scjc4_srt+192;
         const 77;
         const 9295429630892703745;
         const 4096;
 },
 _cckX6() //  [R1]
         { info_tbl: [(cckX6,
                       label: block_cckX6_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckX6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cckXV; else goto cckXU;
       cckXV: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckXU: // global
           _sciSl::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sciSs_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sciSr_info;
           _sciSi::P64 = P64[Sp + 40];
           P64[Hp] = _sciSi::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sciSh::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sciSh::P64;
           P64[Sp + 48] = _sciSi::P64;
           I64[Sp + 56] = _sciSl::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.340978355 UTC

[section ""data" . Text.Printf.$fPrintfArgInt3_closure" {
     Text.Printf.$fPrintfArgInt3_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.343914994 UTC

[section ""data" . Text.Printf.$fPrintfArgInt16_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt16_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt16_$sformatInt_info;
         const 0;
 },
 sat_sciSL_entry() //  [R1]
         { info_tbl: [(cckZa,
                       label: sat_sciSL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckZa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cckZb; else goto cckZc;
       cckZb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckZc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt16_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uckZT_srtd" {
     uckZT_srtd:
         const Scjc4_srt+192;
         const 79;
         const 9223372036854775809;
         const 16384;
 },
 sat_sciSK_entry() //  [R1]
         { info_tbl: [(cckZo,
                       label: sat_sciSK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckZo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cckZp; else goto cckZq;
       cckZp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckZq: // global
           I64[Sp - 8] = block_cckZh_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckZJ; else goto cckZi;
       uckZJ: // global
           call _cckZh(R1) args: 0, res: 0, upd: 0;
       cckZi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckZU_srtd" {
     uckZU_srtd:
         const Scjc4_srt+192;
         const 79;
         const 9223372036854775809;
         const 16384;
 },
 _cckZh() //  [R1]
         { info_tbl: [(cckZh,
                       label: block_cckZh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckZh: // global
           if (R1 & 7 == 1) goto cckZl; else goto cckZm;
       cckZl: // global
           R1 = Text.Printf.$fPrintfArgInt3_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cckZm: // global
           I64[Sp] = block_cckZw_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cckZw() //  [R1]
         { info_tbl: [(cckZw,
                       label: block_cckZw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckZw: // global
           if (R1 & 7 == 1) goto cckZD; else goto cckZH;
       cckZD: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cckZH: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uckZV_srtd" {
     uckZV_srtd:
         const Scjc4_srt+192;
         const 80;
         const 9295429630892703745;
         const 49152;
 },
 Text.Printf.$fPrintfArgInt16_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(cckZK,
                       label: Text.Printf.$fPrintfArgInt16_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckZK: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cckZL; else goto cckZM;
       cckZL: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt16_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cckZM: // global
           I64[Sp - 16] = block_cckYW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uckZS; else goto cckYX;
       uckZS: // global
           call _cckYW(R1) args: 0, res: 0, upd: 0;
       cckYX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckZW_srtd" {
     uckZW_srtd:
         const Scjc4_srt+192;
         const 79;
         const 9295429630892703745;
         const 16384;
 },
 _cckYW() //  [R1]
         { info_tbl: [(cckYW,
                       label: block_cckYW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckYW: // global
           I64[Sp - 48] = block_cckZ1_info;
           _sciSw::P64 = P64[R1 + 7];
           _sciSx::P64 = P64[R1 + 15];
           _sciSy::P64 = P64[R1 + 23];
           _sciSz::P64 = P64[R1 + 31];
           _sciSA::P64 = P64[R1 + 39];
           _sciSB::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciSx::P64;
           P64[Sp - 32] = _sciSy::P64;
           P64[Sp - 24] = _sciSz::P64;
           P64[Sp - 16] = _sciSA::P64;
           P64[Sp - 8] = _sciSB::P64;
           P64[Sp] = _sciSw::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uckZR; else goto cckZ2;
       uckZR: // global
           call _cckZ1(R1) args: 0, res: 0, upd: 0;
       cckZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uckZX_srtd" {
     uckZX_srtd:
         const Scjc4_srt+192;
         const 79;
         const 9295429630892703745;
         const 16384;
 },
 _cckZ1() //  [R1]
         { info_tbl: [(cckZ1,
                       label: block_cckZ1_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckZ1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cckZQ; else goto cckZP;
       cckZQ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cckZP: // global
           _sciSE::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sciSL_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sciSK_info;
           _sciSB::P64 = P64[Sp + 40];
           P64[Hp] = _sciSB::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sciSA::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sciSA::P64;
           P64[Sp + 48] = _sciSB::P64;
           I64[Sp + 56] = _sciSE::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.36383497 UTC

[section ""data" . Text.Printf.$fPrintfArgInt5_closure" {
     Text.Printf.$fPrintfArgInt5_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.$fPrintfArgChar22_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.36667268 UTC

[section ""data" . Text.Printf.$fPrintfArgInt8_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt8_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt8_$sformatInt_info;
         const 0;
 },
 sat_sciT4_entry() //  [R1]
         { info_tbl: [(ccl15,
                       label: sat_sciT4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl15: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccl16; else goto ccl17;
       ccl16: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccl17: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fIntegralInt8_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucl1O_srtd" {
     ucl1O_srtd:
         const Scjc4_srt+192;
         const 81;
         const 9223372036854775809;
         const 65536;
 },
 sat_sciT3_entry() //  [R1]
         { info_tbl: [(ccl1j,
                       label: sat_sciT3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl1j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccl1k; else goto ccl1l;
       ccl1k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccl1l: // global
           I64[Sp - 8] = block_ccl1c_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucl1E; else goto ccl1d;
       ucl1E: // global
           call _ccl1c(R1) args: 0, res: 0, upd: 0;
       ccl1d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl1P_srtd" {
     ucl1P_srtd:
         const Scjc4_srt+192;
         const 81;
         const 9223372036854775809;
         const 65536;
 },
 _ccl1c() //  [R1]
         { info_tbl: [(ccl1c,
                       label: block_ccl1c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl1c: // global
           if (R1 & 7 == 1) goto ccl1g; else goto ccl1h;
       ccl1g: // global
           R1 = Text.Printf.$fPrintfArgInt5_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccl1h: // global
           I64[Sp] = block_ccl1r_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccl1r() //  [R1]
         { info_tbl: [(ccl1r,
                       label: block_ccl1r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl1r: // global
           if (R1 & 7 == 1) goto ccl1y; else goto ccl1C;
       ccl1y: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccl1C: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucl1Q_srtd" {
     ucl1Q_srtd:
         const Scjc4_srt+192;
         const 82;
         const 9295429630892703745;
         const 196608;
 },
 Text.Printf.$fPrintfArgInt8_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccl1F,
                       label: Text.Printf.$fPrintfArgInt8_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl1F: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccl1G; else goto ccl1H;
       ccl1G: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt8_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccl1H: // global
           I64[Sp - 16] = block_ccl0R_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucl1N; else goto ccl0S;
       ucl1N: // global
           call _ccl0R(R1) args: 0, res: 0, upd: 0;
       ccl0S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl1R_srtd" {
     ucl1R_srtd:
         const Scjc4_srt+192;
         const 81;
         const 9295429630892703745;
         const 65536;
 },
 _ccl0R() //  [R1]
         { info_tbl: [(ccl0R,
                       label: block_ccl0R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl0R: // global
           I64[Sp - 48] = block_ccl0W_info;
           _sciSP::P64 = P64[R1 + 7];
           _sciSQ::P64 = P64[R1 + 15];
           _sciSR::P64 = P64[R1 + 23];
           _sciSS::P64 = P64[R1 + 31];
           _sciST::P64 = P64[R1 + 39];
           _sciSU::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciSQ::P64;
           P64[Sp - 32] = _sciSR::P64;
           P64[Sp - 24] = _sciSS::P64;
           P64[Sp - 16] = _sciST::P64;
           P64[Sp - 8] = _sciSU::P64;
           P64[Sp] = _sciSP::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucl1M; else goto ccl0X;
       ucl1M: // global
           call _ccl0W(R1) args: 0, res: 0, upd: 0;
       ccl0X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl1S_srtd" {
     ucl1S_srtd:
         const Scjc4_srt+192;
         const 81;
         const 9295429630892703745;
         const 65536;
 },
 _ccl0W() //  [R1]
         { info_tbl: [(ccl0W,
                       label: block_ccl0W_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl0W: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccl1L; else goto ccl1K;
       ccl1L: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccl1K: // global
           _sciSX::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sciT4_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sciT3_info;
           _sciSU::P64 = P64[Sp + 40];
           P64[Hp] = _sciSU::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sciST::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sciST::P64;
           P64[Sp + 48] = _sciSU::P64;
           I64[Sp + 56] = _sciSX::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.387242378 UTC

[section ""data" . Text.Printf.$fPrintfArgInt_$sformatInt_closure" {
     Text.Printf.$fPrintfArgInt_$sformatInt_closure:
         const Text.Printf.$fPrintfArgInt_$sformatInt_info;
         const 0;
 },
 sat_sciTn_entry() //  [R1]
         { info_tbl: [(ccl2Z,
                       label: sat_sciTn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl2Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccl30; else goto ccl31;
       ccl30: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccl31: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$fIntegralInt_$ctoInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucl3I_srtd" {
     ucl3I_srtd:
         const Scjc4_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 sat_sciTm_entry() //  [R1]
         { info_tbl: [(ccl3d,
                       label: sat_sciTm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl3d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccl3e; else goto ccl3f;
       ccl3e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccl3f: // global
           I64[Sp - 8] = block_ccl36_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucl3y; else goto ccl37;
       ucl3y: // global
           call _ccl36(R1) args: 0, res: 0, upd: 0;
       ccl37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl3J_srtd" {
     ucl3J_srtd:
         const Scjc4_srt+192;
         const 75;
         const 9223372036854775809;
         const 1024;
 },
 _ccl36() //  [R1]
         { info_tbl: [(ccl36,
                       label: block_ccl36_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl36: // global
           if (R1 & 7 == 1) goto ccl3a; else goto ccl3b;
       ccl3a: // global
           R1 = Text.Printf.$fPrintfArgInt1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccl3b: // global
           I64[Sp] = block_ccl3l_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccl3l() //  [R1]
         { info_tbl: [(ccl3l,
                       label: block_ccl3l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl3l: // global
           if (R1 & 7 == 1) goto ccl3s; else goto ccl3w;
       ccl3s: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccl3w: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucl3K_srtd" {
     ucl3K_srtd:
         const Scjc4_srt+192;
         const 83;
         const 9295429630892703745;
         const 263168;
 },
 Text.Printf.$fPrintfArgInt_$sformatInt_entry() //  [R2, R3]
         { info_tbl: [(ccl3z,
                       label: Text.Printf.$fPrintfArgInt_$sformatInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl3z: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccl3A; else goto ccl3B;
       ccl3A: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgInt_$sformatInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccl3B: // global
           I64[Sp - 16] = block_ccl2L_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucl3H; else goto ccl2M;
       ucl3H: // global
           call _ccl2L(R1) args: 0, res: 0, upd: 0;
       ccl2M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl3L_srtd" {
     ucl3L_srtd:
         const Scjc4_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _ccl2L() //  [R1]
         { info_tbl: [(ccl2L,
                       label: block_ccl2L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl2L: // global
           I64[Sp - 48] = block_ccl2Q_info;
           _sciT8::P64 = P64[R1 + 7];
           _sciT9::P64 = P64[R1 + 15];
           _sciTa::P64 = P64[R1 + 23];
           _sciTb::P64 = P64[R1 + 31];
           _sciTc::P64 = P64[R1 + 39];
           _sciTd::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciT9::P64;
           P64[Sp - 32] = _sciTa::P64;
           P64[Sp - 24] = _sciTb::P64;
           P64[Sp - 16] = _sciTc::P64;
           P64[Sp - 8] = _sciTd::P64;
           P64[Sp] = _sciT8::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucl3G; else goto ccl2R;
       ucl3G: // global
           call _ccl2Q(R1) args: 0, res: 0, upd: 0;
       ccl2R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl3M_srtd" {
     ucl3M_srtd:
         const Scjc4_srt+192;
         const 75;
         const 9295429630892703745;
         const 1024;
 },
 _ccl2Q() //  [R1]
         { info_tbl: [(ccl2Q,
                       label: block_ccl2Q_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl2Q: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccl3F; else goto ccl3E;
       ccl3F: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccl3E: // global
           _sciTg::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_sciTn_info;
           P64[Hp - 24] = P64[Sp + 56];
           I64[Hp - 16] = sat_sciTm_info;
           _sciTd::P64 = P64[Sp + 40];
           P64[Hp] = _sciTd::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = Hp - 40;
           R2 = Hp - 16;
           _sciTc::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sciTc::P64;
           P64[Sp + 48] = _sciTd::P64;
           I64[Sp + 56] = _sciTg::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.408703861 UTC

[section ""data" . Text.Printf.$wformatInt_closure" {
     Text.Printf.$wformatInt_closure:
         const Text.Printf.$wformatInt_info;
         const 0;
 },
 Text.Printf.$wformatInt_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl4C: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.$wformatInt_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 48, res: 0, upd: 8;
     }
 },
 sat_sciTz_entry() //  [R1]
         { info_tbl: [(ccl50,
                       label: sat_sciTz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl50: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccl51; else goto ccl52;
       ccl51: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccl52: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciTQ_entry() //  [R1]
         { info_tbl: [(ccl5f,
                       label: sat_sciTQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl5f: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccl5g; else goto ccl5h;
       ccl5g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccl5h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ucl6f_srtd" {
     ucl6f_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sciTP_entry() //  [R1]
         { info_tbl: [(ccl5t,
                       label: sat_sciTP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl5t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccl5u; else goto ccl5v;
       ccl5u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccl5v: // global
           I64[Sp - 16] = block_ccl5m_info;
           _sciTy::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _sciTy::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucl5R; else goto ccl5n;
       ucl5R: // global
           call _ccl5m(R1) args: 0, res: 0, upd: 0;
       ccl5n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl6g_srtd" {
     ucl6g_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _ccl5m() //  [R1]
         { info_tbl: [(ccl5m,
                       label: block_ccl5m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl5m: // global
           if (R1 & 7 == 1) goto ccl5q; else goto ccl5r;
       ccl5q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccl5B; else goto ccl5A;
       ccl5B: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccl5A: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccl5r: // global
           I64[Sp + 8] = block_ccl5E_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           Sp = Sp + 8;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccl5E() //  [R1]
         { info_tbl: [(ccl5E,
                       label: block_ccl5E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl5E: // global
           if (R1 & 7 == 1) goto ccl5L; else goto ccl5P;
       ccl5L: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccl5P: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucl6h_srtd" {
     ucl6h_srtd:
         const Scjc4_srt+192;
         const 84;
         const 9304436830147444737;
         const 524288;
 },
 Text.Printf.$wformatInt_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccl5S,
                       label: Text.Printf.$wformatInt_info
                       rep:HeapRep static {
                             Fun {arity: 10
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl5S: // global
           _sciTs::P64 = R6;
           _sciTr::P64 = R5;
           _sciTq::P64 = R4;
           _sciTp::P64 = R3;
           _sciTo::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto ccl5T; else goto ccl5U;
       ccl5U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccl5W; else goto ccl5V;
       ccl5W: // global
           HpAlloc = 24;
           goto ccl5T;
       ccl5T: // global
           R1 = Text.Printf.$wformatInt_closure;
           P64[Sp - 40] = _sciTo::P64;
           P64[Sp - 32] = _sciTp::P64;
           P64[Sp - 24] = _sciTq::P64;
           P64[Sp - 16] = _sciTr::P64;
           P64[Sp - 8] = _sciTs::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 88, res: 0, upd: 8;
       ccl5V: // global
           I64[Hp - 16] = sat_sciTz_info;
           P64[Hp] = _sciTp::P64;
           I64[Sp - 40] = block_ccl4I_info;
           R2 = _sciTo::P64;
           I64[Sp - 56] = stg_ap_p_info;
           P64[Sp - 48] = Hp - 16;
           P64[Sp - 32] = _sciTo::P64;
           P64[Sp - 24] = _sciTq::P64;
           P64[Sp - 16] = _sciTr::P64;
           P64[Sp - 8] = _sciTs::P64;
           Sp = Sp - 56;
           call GHC.Real.toInteger_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl6i_srtd" {
     ucl6i_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9304436830147444737;
 },
 _ccl4I() //  [R1]
         { info_tbl: [(ccl4I,
                       label: block_ccl4I_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl4I: // global
           I64[Sp - 8] = block_ccl4O_info;
           R3 = Text.Printf.formatChar2_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl6j_srtd" {
     ucl6j_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccl4O() //  [R1]
         { info_tbl: [(ccl4O,
                       label: block_ccl4O_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl4O: // global
           _sciTr::P64 = P64[Sp + 32];
           _sciTs::P64 = P64[Sp + 40];
           _sciTt::P64 = P64[Sp + 48];
           _sciTu::P64 = P64[Sp + 56];
           _sciTv::P64 = P64[Sp + 64];
           _sciTw::P64 = P64[Sp + 72];
           _sciTx::I64 = I64[Sp + 80];
           if (R1 == 1) goto ccl67; else goto ccl63;
       ccl67: // global
           Hp = Hp + 16;
           _sciTR::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccl6a; else goto ccl69;
       ccl69: // global
           if (_sciTx::I64 == 118) goto ccl6d; else goto ccl6c;
       ccl6d: // global
           Hp = Hp - 16;
           _sciTH::P64 = Text.Printf.$fPrintfArgWord1_closure+1;
           _sciTG::P64 = _sciTw::P64;
           _sciTF::P64 = _sciTv::P64;
           _sciTE::P64 = _sciTu::P64;
           _sciTD::P64 = _sciTt::P64;
           _sciTC::P64 = _sciTs::P64;
           _sciTB::P64 = _sciTr::P64;
           goto sciTA;
       ccl6c: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sciTx::I64;
           _sciTH::P64 = Hp - 7;
           _sciTG::P64 = _sciTw::P64;
           _sciTF::P64 = _sciTv::P64;
           _sciTE::P64 = _sciTu::P64;
           _sciTD::P64 = _sciTt::P64;
           _sciTC::P64 = _sciTs::P64;
           _sciTB::P64 = _sciTr::P64;
           goto sciTA;
       ccl63: // global
           Hp = Hp + 16;
           _sciTR::I64 = R1;
           if (Hp > HpLim) (likely: False) goto ccl6a; else goto ccl65;
       ccl6a: // global
           HpAlloc = 16;
           R1 = _sciTR::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccl65: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sciTx::I64;
           _sciTH::P64 = Hp - 7;
           _sciTG::P64 = _sciTw::P64;
           _sciTF::P64 = _sciTv::P64;
           _sciTE::P64 = _sciTu::P64;
           _sciTD::P64 = _sciTt::P64;
           _sciTC::P64 = _sciTs::P64;
           _sciTB::P64 = _sciTr::P64;
           goto sciTA;
       sciTA: // global
           I64[Sp] = block_ccl56_info;
           R1 = _sciTH::P64;
           P64[Sp + 32] = _sciTG::P64;
           P64[Sp + 40] = _sciTF::P64;
           P64[Sp + 48] = _sciTE::P64;
           P64[Sp + 56] = _sciTD::P64;
           P64[Sp + 64] = _sciTC::P64;
           P64[Sp + 80] = _sciTB::P64;
           if (R1 & 7 != 0) goto ucl6e; else goto ccl57;
       ucl6e: // global
           call _ccl56(R1) args: 0, res: 0, upd: 0;
       ccl57: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl6k_srtd" {
     ucl6k_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccl56() //  [R1]
         { info_tbl: [(ccl56,
                       label: block_ccl56_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl56: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccl61; else goto ccl60;
       ccl61: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccl60: // global
           _sciTJ::I64 = I64[R1 + 7];
           I64[Hp - 56] = sat_sciTQ_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_sciTP_info;
           P64[Hp - 8] = P64[Sp + 72];
           P64[Hp] = P64[Sp + 8];
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 64];
           R4 = P64[Sp + 80];
           R3 = Hp - 56;
           R2 = Hp - 24;
           P64[Sp + 56] = P64[Sp + 48];
           P64[Sp + 64] = P64[Sp + 40];
           P64[Sp + 72] = P64[Sp + 32];
           I64[Sp + 80] = _sciTJ::I64;
           Sp = Sp + 56;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.437128786 UTC

[section ""data" . Text.Printf.formatInt_closure" {
     Text.Printf.formatInt_closure:
         const Text.Printf.formatInt_info;
         const 0;
 },
 Text.Printf.formatInt_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccl7F,
                       label: Text.Printf.formatInt_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl7F: // global
           if ((Sp + -80) < SpLim) (likely: False) goto ccl7J; else goto ccl7K;
       ccl7J: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatInt_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccl7K: // global
           I64[Sp - 32] = block_ccl7C_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucl7S; else goto ccl7D;
       ucl7S: // global
           call _ccl7C(R1) args: 0, res: 0, upd: 0;
       ccl7D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccl7C() //  [R1]
         { info_tbl: [(ccl7C,
                       label: block_ccl7C_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl7C: // global
           I64[Sp - 48] = block_ccl7I_info;
           _sciU0::P64 = P64[R1 + 7];
           _sciU1::P64 = P64[R1 + 15];
           _sciU2::P64 = P64[R1 + 23];
           _sciU3::P64 = P64[R1 + 31];
           _sciU4::P64 = P64[R1 + 39];
           _sciU5::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciU1::P64;
           P64[Sp - 32] = _sciU2::P64;
           P64[Sp - 24] = _sciU3::P64;
           P64[Sp - 16] = _sciU4::P64;
           P64[Sp - 8] = _sciU5::P64;
           P64[Sp] = _sciU0::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucl7R; else goto ccl7M;
       ucl7R: // global
           call _ccl7I(R1) args: 0, res: 0, upd: 0;
       ccl7M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccl7I() //  [R1]
         { info_tbl: [(ccl7I,
                       label: block_ccl7I_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl7I: // global
           R6 = P64[Sp + 8];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           _sciU5::P64 = P64[Sp + 40];
           P64[Sp + 40] = P64[Sp + 16];
           P64[Sp + 48] = P64[Sp + 24];
           P64[Sp + 56] = P64[Sp + 32];
           P64[Sp + 64] = _sciU5::P64;
           I64[Sp + 72] = I64[R1 + 7];
           Sp = Sp + 40;
           call Text.Printf.$wformatInt_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.445411722 UTC

[section ""data" . Text.Printf.$fPrintfArgWord64_closure" {
     Text.Printf.$fPrintfArgWord64_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord64_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.447212915 UTC

[section ""data" . Text.Printf.$fPrintfArgWord32_closure" {
     Text.Printf.$fPrintfArgWord32_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord32_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.44898195 UTC

[section ""data" . Text.Printf.$fPrintfArgWord16_closure" {
     Text.Printf.$fPrintfArgWord16_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord16_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.450650119 UTC

[section ""data" . Text.Printf.$fPrintfArgWord8_closure" {
     Text.Printf.$fPrintfArgWord8_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord8_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.452450338 UTC

[section ""data" . Text.Printf.$fPrintfArgWord_closure" {
     Text.Printf.$fPrintfArgWord_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgWord_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.454254596 UTC

[section ""data" . Text.Printf.$fPrintfArgInt64_closure" {
     Text.Printf.$fPrintfArgInt64_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt64_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.456005686 UTC

[section ""data" . Text.Printf.$fPrintfArgInt32_closure" {
     Text.Printf.$fPrintfArgInt32_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt32_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.45803279 UTC

[section ""data" . Text.Printf.$fPrintfArgInt16_closure" {
     Text.Printf.$fPrintfArgInt16_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt16_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.459805622 UTC

[section ""data" . Text.Printf.$fPrintfArgInt8_closure" {
     Text.Printf.$fPrintfArgInt8_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt8_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.462146266 UTC

[section ""data" . Text.Printf.$fPrintfArgInt_closure" {
     Text.Printf.$fPrintfArgInt_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgInt_$sformatInt_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.465010791 UTC

[section ""data" . Text.Printf.formatInteger_closure" {
     Text.Printf.formatInteger_closure:
         const Text.Printf.formatInteger_info;
         const 0;
 },
 section ""relreadonly" . ucl9g_srtd" {
     ucl9g_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sciUq_entry() //  [R1]
         { info_tbl: [(ccl8L,
                       label: sat_sciUq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl8L: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccl8M; else goto ccl8N;
       ccl8M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccl8N: // global
           I64[Sp - 8] = block_ccl8E_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucl96; else goto ccl8F;
       ucl96: // global
           call _ccl8E(R1) args: 0, res: 0, upd: 0;
       ccl8F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl9h_srtd" {
     ucl9h_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _ccl8E() //  [R1]
         { info_tbl: [(ccl8E,
                       label: block_ccl8E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl8E: // global
           if (R1 & 7 == 1) goto ccl8I; else goto ccl8J;
       ccl8I: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccl8J: // global
           I64[Sp] = block_ccl8T_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccl8T() //  [R1]
         { info_tbl: [(ccl8T,
                       label: block_ccl8T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl8T: // global
           if (R1 & 7 == 1) goto ccl90; else goto ccl94;
       ccl90: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccl94: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucl9i_srtd" {
     ucl9i_srtd:
         const Scjc4_srt+192;
         const 86;
         const 9295429630892703745;
         const 2097152;
 },
 Text.Printf.formatInteger_entry() //  [R2, R3]
         { info_tbl: [(ccl97,
                       label: Text.Printf.formatInteger_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl97: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccl98; else goto ccl99;
       ccl98: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.formatInteger_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccl99: // global
           I64[Sp - 16] = block_ccl8q_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucl9f; else goto ccl8r;
       ucl9f: // global
           call _ccl8q(R1) args: 0, res: 0, upd: 0;
       ccl8r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl9j_srtd" {
     ucl9j_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccl8q() //  [R1]
         { info_tbl: [(ccl8q,
                       label: block_ccl8q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl8q: // global
           I64[Sp - 48] = block_ccl8v_info;
           _sciUc::P64 = P64[R1 + 7];
           _sciUd::P64 = P64[R1 + 15];
           _sciUe::P64 = P64[R1 + 23];
           _sciUf::P64 = P64[R1 + 31];
           _sciUg::P64 = P64[R1 + 39];
           _sciUh::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciUd::P64;
           P64[Sp - 32] = _sciUe::P64;
           P64[Sp - 24] = _sciUf::P64;
           P64[Sp - 16] = _sciUg::P64;
           P64[Sp - 8] = _sciUh::P64;
           P64[Sp] = _sciUc::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucl9e; else goto ccl8w;
       ucl9e: // global
           call _ccl8v(R1) args: 0, res: 0, upd: 0;
       ccl8w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ucl9k_srtd" {
     ucl9k_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccl8v() //  [R1]
         { info_tbl: [(ccl8v,
                       label: block_ccl8v_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl8v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccl9d; else goto ccl9c;
       ccl9d: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccl9c: // global
           _sciUk::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sciUq_info;
           _sciUh::P64 = P64[Sp + 40];
           P64[Hp] = _sciUh::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 56];
           R2 = Hp - 16;
           _sciUg::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sciUg::P64;
           P64[Sp + 48] = _sciUh::P64;
           I64[Sp + 56] = _sciUk::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.483512966 UTC

[section ""data" . Text.Printf.$fPrintfArgNatural_$cformatArg_closure" {
     Text.Printf.$fPrintfArgNatural_$cformatArg_closure:
         const Text.Printf.$fPrintfArgNatural_$cformatArg_info;
         const 0;
 },
 section ""relreadonly" . uclaX_srtd" {
     uclaX_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9223372036854775809;
 },
 sat_sciUI_entry() //  [R1]
         { info_tbl: [(cclas,
                       label: sat_sciUI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclas: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cclat; else goto cclau;
       cclat: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclau: // global
           I64[Sp - 8] = block_cclal_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclaN; else goto cclam;
       uclaN: // global
           call _cclal(R1) args: 0, res: 0, upd: 0;
       cclam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uclaY_srtd" {
     uclaY_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9223372036854775809;
 },
 _cclal() //  [R1]
         { info_tbl: [(cclal,
                       label: block_cclal_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclal: // global
           if (R1 & 7 == 1) goto cclap; else goto cclaq;
       cclap: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cclaq: // global
           I64[Sp] = block_cclaA_info;
           R4 = Text.Printf.intModifierMap_closure+2;
           R3 = R1;
           R2 = GHC.Classes.$fEq[]_$s$fEq[]1_closure;
           call GHC.List.lookup_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cclaA() //  [R1]
         { info_tbl: [(cclaA,
                       label: block_cclaA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclaA: // global
           if (R1 & 7 == 1) goto cclaH; else goto cclaL;
       cclaH: // global
           R1 = Text.Printf.$fPrintfArgInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cclaL: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . uclaZ_srtd" {
     uclaZ_srtd:
         const Scjc4_srt+192;
         const 87;
         const 9295429630892703745;
         const 4194304;
 },
 Text.Printf.$fPrintfArgNatural_$cformatArg_entry() //  [R2, R3]
         { info_tbl: [(cclaO,
                       label: Text.Printf.$fPrintfArgNatural_$cformatArg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclaO: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cclaP; else goto cclaQ;
       cclaP: // global
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfArgNatural_$cformatArg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cclaQ: // global
           I64[Sp - 16] = block_ccla7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uclaW; else goto ccla8;
       uclaW: // global
           call _ccla7(R1) args: 0, res: 0, upd: 0;
       ccla8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uclb0_srtd" {
     uclb0_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _ccla7() //  [R1]
         { info_tbl: [(ccla7,
                       label: block_ccla7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccla7: // global
           I64[Sp - 48] = block_cclac_info;
           _sciUu::P64 = P64[R1 + 7];
           _sciUv::P64 = P64[R1 + 15];
           _sciUw::P64 = P64[R1 + 23];
           _sciUx::P64 = P64[R1 + 31];
           _sciUy::P64 = P64[R1 + 39];
           _sciUz::P64 = P64[R1 + 47];
           R1 = P64[R1 + 55];
           P64[Sp - 40] = _sciUv::P64;
           P64[Sp - 32] = _sciUw::P64;
           P64[Sp - 24] = _sciUx::P64;
           P64[Sp - 16] = _sciUy::P64;
           P64[Sp - 8] = _sciUz::P64;
           P64[Sp] = _sciUu::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uclaV; else goto cclad;
       uclaV: // global
           call _cclac(R1) args: 0, res: 0, upd: 0;
       cclad: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uclb1_srtd" {
     uclb1_srtd:
         const Scjc4_srt+192;
         const 64;
         const 9295429630892703745;
 },
 _cclac() //  [R1]
         { info_tbl: [(cclac,
                       label: block_cclac_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclac: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclaU; else goto cclaT;
       cclaU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cclaT: // global
           _sciUC::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sciUI_info;
           _sciUz::P64 = P64[Sp + 40];
           P64[Hp] = _sciUz::P64;
           R6 = P64[Sp + 16];
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 48];
           R3 = P64[Sp + 56];
           R2 = Hp - 16;
           _sciUy::P64 = P64[Sp + 32];
           P64[Sp + 32] = P64[Sp + 24];
           P64[Sp + 40] = _sciUy::P64;
           P64[Sp + 48] = _sciUz::P64;
           I64[Sp + 56] = _sciUC::I64;
           Sp = Sp + 32;
           call Text.Printf.$wformatIntegral_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.500747223 UTC

[section ""data" . Text.Printf.$fPrintfArgNatural_closure" {
     Text.Printf.$fPrintfArgNatural_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.$fPrintfArgNatural_$cformatArg_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.502868077 UTC

[section ""data" . Text.Printf.$fPrintfArgInteger_closure" {
     Text.Printf.$fPrintfArgInteger_closure:
         const Text.Printf.C:PrintfArg_con_info;
         const Text.Printf.formatInteger_closure+2;
         const Text.Printf.parseIntFormat_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.504825935 UTC

[section ""data" . lvl42_rcccH_closure" {
     lvl42_rcccH_closure:
         const lvl42_rcccH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rcccH_entry() //  [R1]
         { info_tbl: [(cclbS,
                       label: lvl42_rcccH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclbS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cclbT; else goto cclbU;
       cclbT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclbU: // global
           (_cclbP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cclbP::I64 == 0) goto cclbR; else goto cclbQ;
       cclbR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cclbQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cclbP::I64;
           R4 = Text.Read.readEither7_closure+1;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadInt2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.508926185 UTC

[section ""data" . lvl43_rcccI_closure" {
     lvl43_rcccI_closure:
         const Text.Printf.FieldFormat_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Types.False_closure+1;
         const GHC.Types.[]_closure+1;
         const lvl23_rccco_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.511009976 UTC

[section ""data" . lvl44_rcccJ_closure" {
     lvl44_rcccJ_closure:
         const lvl44_rcccJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rcccJ_entry() //  [R1]
         { info_tbl: [(cclcc,
                       label: lvl44_rcccJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclcc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cclcd; else goto cclce;
       cclcd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclce: // global
           (_cclc9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cclc9::I64 == 0) goto cclcb; else goto cclca;
       cclcb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cclca: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cclc9::I64;
           R2 = Text.Read.readEither5_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.515331435 UTC

[section ""data" . lvl45_rcccK_closure" {
     lvl45_rcccK_closure:
         const lvl45_rcccK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl45_rcccK_entry() //  [R1]
         { info_tbl: [(cclct,
                       label: lvl45_rcccK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclct: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cclcu; else goto cclcv;
       cclcu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclcv: // global
           (_cclcq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cclcq::I64 == 0) goto cclcs; else goto cclcr;
       cclcs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cclcr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cclcq::I64;
           R2 = Text.Read.readEither2_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.520144508 UTC

[section ""data" . $wgetStar_rcccL_closure" {
     $wgetStar_rcccL_closure:
         const $wgetStar_rcccL_info;
         const 0;
 },
 sat_sciUR_entry() //  [R1]
         { info_tbl: [(ccld1,
                       label: sat_sciUR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccld1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccld2; else goto ccld3;
       ccld2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccld3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Types.[]_closure+1;
           R2 = lvl43_rcccI_closure+1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciUZ_entry() //  [R1]
         { info_tbl: [(ccld6,
                       label: sat_sciUZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccld6: // global
           _sciUZ::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto ccld7; else goto ccld8;
       ccld8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclda; else goto ccld9;
       cclda: // global
           HpAlloc = 24;
           goto ccld7;
       ccld7: // global
           R1 = _sciUZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccld9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sciUZ::P64;
           _sciUQ::P64 = P64[_sciUZ::P64 + 16];
           I64[Hp - 16] = sat_sciUR_info;
           P64[Hp] = _sciUQ::P64;
           I64[Sp - 24] = block_ccld4_info;
           R3 = Hp - 16;
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccld4() //  [R1]
         { info_tbl: [(ccld4,
                       label: block_ccld4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccld4: // global
           I64[Sp] = block_ccldd_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccldd() //  [R1]
         { info_tbl: [(ccldd,
                       label: block_ccldd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccldd: // global
           if (R1 & 7 == 1) goto ccldk; else goto ccldp;
       ccldk: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccldp: // global
           I64[Sp - 8] = block_ccldn_info;
           _sciUU::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sciUU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucldD; else goto ccldq;
       ucldD: // global
           call _ccldn(R1) args: 0, res: 0, upd: 0;
       ccldq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccldn() //  [R1]
         { info_tbl: [(ccldn,
                       label: block_ccldn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccldn: // global
           if (R1 & 7 == 1) goto ccldw; else goto ccldA;
       ccldw: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccldA: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgetStar_rcccL_entry() //  [R2]
         { info_tbl: [(ccldI,
                       label: $wgetStar_rcccL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccldI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccldJ; else goto ccldK;
       ccldJ: // global
           R2 = R2;
           R1 = $wgetStar_rcccL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccldK: // global
           I64[Sp - 8] = block_cclcI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucldS; else goto cclcJ;
       ucldS: // global
           call _cclcI(R1) args: 0, res: 0, upd: 0;
       cclcJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cclcI() //  [R1]
         { info_tbl: [(cclcI,
                       label: block_cclcI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclcI: // global
           if (R1 & 7 == 1) goto ccldF; else goto ccldG;
       ccldF: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ccldG: // global
           I64[Sp - 8] = block_cclcO_info;
           _sciUN::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sciUN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucldR; else goto cclcP;
       ucldR: // global
           call _cclcO(R1) args: 0, res: 0, upd: 0;
       cclcP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cclcO() //  [R1]
         { info_tbl: [(cclcO,
                       label: block_cclcO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclcO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccldQ; else goto ccldP;
       ccldQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccldP: // global
           _sciUQ::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sciUZ_info;
           P64[Hp] = _sciUQ::P64;
           R2 = Hp - 16;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.538213892 UTC

[section ""data" . lvl46_rcccM_closure" {
     lvl46_rcccM_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.53998842 UTC

[section ""data" . lvl47_rcccN_closure" {
     lvl47_rcccN_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.LeftAdjust_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.541659692 UTC

[section ""data" . lvl48_rcccO_closure" {
     lvl48_rcccO_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.ZeroPad_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.544372691 UTC

[section ""data" . lvl49_rcccP_closure" {
     lvl49_rcccP_closure:
         const lvl49_rcccP_info;
         const 0;
         const 0;
         const 0;
 },
 sat_sciVd_entry() //  [R1]
         { info_tbl: [(cclf6,
                       label: sat_sciVd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclf6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclf7; else goto cclf8;
       cclf7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclf8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclf4_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclf4() //  [R1]
         { info_tbl: [(cclf4,
                       label: block_cclf4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclf4: // global
           I64[Sp] = block_cclfb_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclfb() //  [R1]
         { info_tbl: [(cclfb,
                       label: block_cclfb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclfb: // global
           if (R1 & 7 == 1) goto cclfi; else goto cclfn;
       cclfi: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cclfn: // global
           I64[Sp - 8] = block_cclfl_info;
           _sciV8::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sciV8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclfB; else goto cclfo;
       uclfB: // global
           call _cclfl(R1) args: 0, res: 0, upd: 0;
       cclfo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclfl() //  [R1]
         { info_tbl: [(cclfl,
                       label: block_cclfl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclfl: // global
           if (R1 & 7 == 1) goto cclfu; else goto cclfy;
       cclfu: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cclfy: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl49_rcccP_entry() //  [R1]
         { info_tbl: [(cclfG,
                       label: lvl49_rcccP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclfG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclfH; else goto cclfI;
       cclfH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclfI: // global
           (_ccleP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccleP::I64 == 0) goto ccleR; else goto ccleQ;
       ccleR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccleQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccleP::I64;
           I64[Sp - 24] = block_ccleS_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccleS() //  [R1, R2]
         { info_tbl: [(ccleS,
                       label: block_ccleS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccleS: // global
           I64[Sp - 8] = block_ccleU_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclfT; else goto ccleV;
       uclfT: // global
           call _ccleU(R1) args: 0, res: 0, upd: 0;
       ccleV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccleU() //  [R1]
         { info_tbl: [(ccleU,
                       label: block_ccleU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccleU: // global
           _sciV2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cclfD; else goto cclfE;
       cclfD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclfO; else goto cclfN;
       cclfO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclfN: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sciV2::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclfE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cclfS; else goto cclfR;
       cclfS: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclfR: // global
           I64[Hp - 40] = sat_sciVd_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sciV2::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.56001269 UTC

[section ""data" . lvl50_rcccQ_closure" {
     lvl50_rcccQ_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.SignPlus_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.562368633 UTC

[section ""data" . lvl51_rcccR_closure" {
     lvl51_rcccR_closure:
         const lvl51_rcccR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl51_rcccR_entry() //  [R1]
         { info_tbl: [(cclgW,
                       label: lvl51_rcccR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclgW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cclgX; else goto cclgY;
       cclgX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclgY: // global
           (_cclgQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cclgQ::I64 == 0) goto cclgS; else goto cclgR;
       cclgS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cclgR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cclgQ::I64;
           I64[Sp - 24] = block_cclgT_info;
           R1 = lvl49_rcccP_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uclh2; else goto cclgU;
       uclh2: // global
           call _cclgT(R1) args: 0, res: 0, upd: 0;
       cclgU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclgT() //  [R1]
         { info_tbl: [(cclgT,
                       label: block_cclgT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclgT: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.568066183 UTC

[section ""data" . lvl52_rcccS_closure" {
     lvl52_rcccS_closure:
         const GHC.Base.Just_con_info;
         const lvl51_rcccR_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.57006955 UTC

[section ""data" . lvl53_rcccT_closure" {
     lvl53_rcccT_closure:
         const lvl53_rcccT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl53_rcccT_entry() //  [R1]
         { info_tbl: [(cclhs,
                       label: lvl53_rcccT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclhs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cclht; else goto cclhu;
       cclht: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclhu: // global
           (_cclhm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cclhm::I64 == 0) goto cclho; else goto cclhn;
       cclho: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cclhn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cclhm::I64;
           I64[Sp - 24] = block_cclhp_info;
           R1 = lvl49_rcccP_closure;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uclhy; else goto cclhq;
       uclhy: // global
           call _cclhp(R1) args: 0, res: 0, upd: 0;
       cclhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclhp() //  [R1]
         { info_tbl: [(cclhp,
                       label: block_cclhp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclhp: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.576265979 UTC

[section ""data" . lvl54_rcccU_closure" {
     lvl54_rcccU_closure:
         const GHC.Base.Just_con_info;
         const Text.Printf.SignSpace_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.591078415 UTC

[section ""data" . $wgetSpecs_rcccV_closure" {
     $wgetSpecs_rcccV_closure:
         const $wgetSpecs_rcccV_info;
         const 0;
 },
 ds3_sciVB_entry() //  [R1]
         { info_tbl: [(ccliv,
                       label: ds3_sciVB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccliv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccliw; else goto cclix;
       ccliw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclix: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cclio_info;
           _sciVq::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sciVq::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucliL; else goto cclip;
       ucliL: // global
           call _cclio(R1) args: 0, res: 0, upd: 0;
       cclip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclio() //  [R1]
         { info_tbl: [(cclio,
                       label: block_cclio_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclio: // global
           if (R1 & 7 == 1) goto cclis; else goto cclit;
       cclis: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cclit: // global
           I64[Sp] = block_ccliD_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucliK; else goto ccliF;
       ucliK: // global
           call _ccliD(R1) args: 0, res: 0, upd: 0;
       ccliF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccliD() //  [R1]
         { info_tbl: [(ccliD,
                       label: block_ccliD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccliD: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciVK_entry() //  [R1]
         { info_tbl: [(cclj0,
                       label: sat_sciVK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclj0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclj1; else goto cclj2;
       cclj1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclj2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccliT_info;
           _sciVl::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sciVl::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucljn; else goto ccliU;
       ucljn: // global
           call _ccliT(R1) args: 0, res: 0, upd: 0;
       ccliU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccliT() //  [R1]
         { info_tbl: [(ccliT,
                       label: block_ccliT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccliT: // global
           if (R1 & 7 == 1) goto ccliX; else goto ccliY;
       ccliX: // global
           _sciVl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cclj5_info;
           R1 = _sciVl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucljm; else goto cclj7;
       ucljm: // global
           call _cclj5(R1) args: 0, res: 0, upd: 0;
       cclj7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ccliY: // global
           R1 = lvl47_rcccN_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cclj5() //  [R1]
         { info_tbl: [(cclj5,
                       label: block_cclj5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclj5: // global
           if (R1 & 7 == 1) goto ccljd; else goto ccljh;
       ccljd: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccljh: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciWf_entry() //  [R1]
         { info_tbl: [(ccljH,
                       label: sat_sciWf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccljH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccljI; else goto ccljJ;
       ccljI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccljJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccljF_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccljF() //  [R1]
         { info_tbl: [(ccljF,
                       label: block_ccljF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccljF: // global
           I64[Sp] = block_ccljM_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccljM() //  [R1]
         { info_tbl: [(ccljM,
                       label: block_ccljM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccljM: // global
           if (R1 & 7 == 1) goto ccljT; else goto ccljY;
       ccljT: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccljY: // global
           I64[Sp - 8] = block_ccljW_info;
           _sciWa::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sciWa::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclkc; else goto ccljZ;
       uclkc: // global
           call _ccljW(R1) args: 0, res: 0, upd: 0;
       ccljZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccljW() //  [R1]
         { info_tbl: [(ccljW,
                       label: block_ccljW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccljW: // global
           if (R1 & 7 == 1) goto cclk5; else goto cclk9;
       cclk5: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cclk9: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sciW1_entry() //  [R1]
         { info_tbl: [(cclkh,
                       label: ds3_sciW1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclkh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclki; else goto cclkj;
       cclki: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclkj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccljt_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccljt() //  [R1, R2]
         { info_tbl: [(ccljt,
                       label: block_ccljt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccljt: // global
           I64[Sp - 8] = block_ccljv_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclku; else goto ccljw;
       uclku: // global
           call _ccljv(R1) args: 0, res: 0, upd: 0;
       ccljw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccljv() //  [R1]
         { info_tbl: [(ccljv,
                       label: block_ccljv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccljv: // global
           _sciW4::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cclke; else goto cclkf;
       cclke: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclkp; else goto cclko;
       cclkp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclko: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sciW4::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclkf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cclkt; else goto cclks;
       cclkt: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclks: // global
           I64[Hp - 40] = sat_sciWf_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sciW4::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciWK_entry() //  [R1]
         { info_tbl: [(cclln,
                       label: sat_sciWK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclln: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccllo; else goto ccllp;
       ccllo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccllp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclll_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclll() //  [R1]
         { info_tbl: [(cclll,
                       label: block_cclll_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclll: // global
           I64[Sp] = block_cclls_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclls() //  [R1]
         { info_tbl: [(cclls,
                       label: block_cclls_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclls: // global
           if (R1 & 7 == 1) goto ccllz; else goto ccllE;
       ccllz: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccllE: // global
           I64[Sp - 8] = block_ccllC_info;
           _sciWF::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sciWF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucllS; else goto ccllF;
       ucllS: // global
           call _ccllC(R1) args: 0, res: 0, upd: 0;
       ccllF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccllC() //  [R1]
         { info_tbl: [(ccllC,
                       label: block_ccllC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccllC: // global
           if (R1 & 7 == 1) goto ccllL; else goto ccllP;
       ccllL: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       ccllP: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_sciWw_entry() //  [R1]
         { info_tbl: [(ccllX,
                       label: ds12_sciWw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccllX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccllY; else goto ccllZ;
       ccllY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccllZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccll9_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccll9() //  [R1, R2]
         { info_tbl: [(ccll9,
                       label: block_ccll9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccll9: // global
           I64[Sp - 8] = block_ccllb_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclma; else goto ccllc;
       uclma: // global
           call _ccllb(R1) args: 0, res: 0, upd: 0;
       ccllc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccllb() //  [R1]
         { info_tbl: [(ccllb,
                       label: block_ccllb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccllb: // global
           _sciWz::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccllU; else goto ccllV;
       ccllU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclm5; else goto cclm4;
       cclm5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclm4: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sciWz::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccllV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cclm9; else goto cclm8;
       cclm9: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclm8: // global
           I64[Hp - 40] = sat_sciWK_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sciWz::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_sciWU_entry() //  [R1]
         { info_tbl: [(cclmj,
                       label: ds12_sciWU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclmj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cclmk; else goto cclml;
       cclmk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclml: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclmg_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclmg() //  [R1, R2]
         { info_tbl: [(cclmg,
                       label: block_cclmg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclmg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclmo; else goto cclmn;
       cclmo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cclmn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sciWg_entry() //  [R1]
         { info_tbl: [(cclmp,
                       label: ds4_sciWg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclmp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cclmq; else goto cclmr;
       cclmq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclmr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cclkz_info;
           _sciVp::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sciVp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uclnc; else goto cclkA;
       uclnc: // global
           call _cclkz(R1) args: 0, res: 0, upd: 0;
       cclkA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclkz() //  [R1]
         { info_tbl: [(cclkz,
                       label: block_cclkz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclkz: // global
           I64[Sp] = block_cclkE_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ucln8; else goto cclkF;
       ucln8: // global
           call _cclkE(R1) args: 0, res: 0, upd: 0;
       cclkF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclkE() //  [R1]
         { info_tbl: [(cclkE,
                       label: block_cclkE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclkE: // global
           if (R1 & 7 == 1) goto cclmw; else goto cclmB;
       cclmw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cclmz; else goto cclmy;
       cclmz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclmy: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclmB: // global
           I64[Sp - 16] = block_cclkK_info;
           _sciWk::P64 = R1;
           _sciWm::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciWm::P64;
           P64[Sp] = _sciWk::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucln9; else goto cclkL;
       ucln9: // global
           call _cclkK(R1) args: 0, res: 0, upd: 0;
       cclkL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclkK() //  [R1]
         { info_tbl: [(cclkK,
                       label: block_cclkK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclkK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cclmE; else goto cclmD;
       cclmE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclmD: // global
           if (I64[R1 + 7] == 46) goto cclmI; else goto cclmH;
       cclmI: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cclkS_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uclna; else goto cclkT;
       uclna: // global
           call _cclkS(R1) args: 0, res: 0, upd: 0;
       cclkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cclmH: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cclkS() //  [R1]
         { info_tbl: [(cclkS,
                       label: block_cclkS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclkS: // global
           if (R1 & 7 == 1) goto cclmM; else goto cclmR;
       cclmM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cclmP; else goto cclmO;
       cclmP: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclmO: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl52_rcccS_closure+2;
           P64[Hp - 8] = lvl53_rcccT_closure;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclmR: // global
           I64[Sp - 16] = block_cclkY_info;
           _sciWq::P64 = R1;
           _sciWs::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciWs::P64;
           P64[Sp] = _sciWq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uclnb; else goto cclkZ;
       uclnb: // global
           call _cclkY(R1) args: 0, res: 0, upd: 0;
       cclkZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclkY() //  [R1]
         { info_tbl: [(cclkY,
                       label: block_cclkY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclkY: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cclmU; else goto cclmT;
       cclmU: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclmT: // global
           _sciVp::P64 = P64[Sp + 24];
           if (I64[R1 + 7] == 42) goto ccln5; else goto ccln0;
       ccln5: // global
           I64[Hp - 112] = ds12_sciWU_info;
           P64[Hp - 96] = _sciVp::P64;
           I64[Hp - 88] = stg_sel_0_upd_info;
           _cclmc::P64 = Hp - 112;
           P64[Hp - 72] = _cclmc::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cclmc::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 88;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccln0: // global
           I64[Hp - 112] = ds12_sciWw_info;
           P64[Hp - 96] = P64[Sp + 16];
           I64[Hp - 88] = stg_sel_1_upd_info;
           _ccll5::P64 = Hp - 112;
           P64[Hp - 72] = _ccll5::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _ccll5::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = _sciVp::P64;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds5_sciX7_entry() //  [R1]
         { info_tbl: [(cclnk,
                       label: ds5_sciX7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclnk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclnl; else goto cclnm;
       cclnl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclnm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclnh_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uclnK; else goto cclni;
       uclnK: // global
           call _cclnh(R1) args: 0, res: 0, upd: 0;
       cclni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclnh() //  [R1]
         { info_tbl: [(cclnh,
                       label: block_cclnh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclnh: // global
           I64[Sp - 8] = block_cclnp_info;
           _sciXa::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sciXa::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclnJ; else goto cclnr;
       uclnJ: // global
           call _cclnp(R1) args: 0, res: 0, upd: 0;
       cclnr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclnp() //  [R1]
         { info_tbl: [(cclnp,
                       label: block_cclnp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclnp: // global
           if (R1 & 7 == 1) goto cclnx; else goto cclnC;
       cclnx: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cclnC: // global
           I64[Sp] = block_cclnA_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uclnL; else goto cclnD;
       uclnL: // global
           call _cclnA(R1) args: 0, res: 0, upd: 0;
       cclnD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclnA() //  [R1]
         { info_tbl: [(cclnA,
                       label: block_cclnA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclnA: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciXE_entry() //  [R1]
         { info_tbl: [(cclnX,
                       label: sat_sciXE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclnX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cclo1; else goto cclo2;
       cclo1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclo2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cclnU_info;
           _sciVk::P64 = P64[R1 + 16];
           _sciVl::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sciVk::P64;
           P64[Sp - 24] = _sciVl::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucloI; else goto cclnV;
       ucloI: // global
           call _cclnU(R1) args: 0, res: 0, upd: 0;
       cclnV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclnU() //  [R1]
         { info_tbl: [(cclnU,
                       label: block_cclnU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclnU: // global
           I64[Sp] = block_cclo0_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto ucloH; else goto cclo4;
       ucloH: // global
           call _cclo0(R1) args: 0, res: 0, upd: 0;
       cclo4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclo0() //  [R1]
         { info_tbl: [(cclo0,
                       label: block_cclo0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclo0: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto ccloe; else goto ucloF;
       ccloe: // global
           _sciVk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccloc_info;
           R1 = _sciVk::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucloJ; else goto cclof;
       ucloJ: // global
           call _ccloc(R1) args: 0, res: 0, upd: 0;
       cclof: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ucloF: // global
           Sp = Sp + 24;
           call _ccloC() args: 0, res: 0, upd: 0;
     }
 },
 _ccloc() //  [R1]
         { info_tbl: [(ccloc,
                       label: block_ccloc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccloc: // global
           if (R1 & 7 == 1) goto cclom; else goto ucloG;
       cclom: // global
           _sciVl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccloj_info;
           R1 = _sciVl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucloL; else goto cclon;
       ucloL: // global
           call _ccloj(R1) args: 0, res: 0, upd: 0;
       cclon: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ucloG: // global
           Sp = Sp + 16;
           call _ccloC() args: 0, res: 0, upd: 0;
     }
 },
 _ccloj() //  [R1]
         { info_tbl: [(ccloj,
                       label: block_ccloj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccloj: // global
           if (R1 & 7 == 1) goto cclot; else goto cclox;
       cclot: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclox: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccloC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccloC: // global
           R1 = lvl47_rcccN_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciXp_entry() //  [R1]
         { info_tbl: [(ccloV,
                       label: sat_sciXp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccloV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccloZ; else goto cclp0;
       ccloZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclp0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccloS_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uclpk; else goto ccloT;
       uclpk: // global
           call _ccloS(R1) args: 0, res: 0, upd: 0;
       ccloT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccloS() //  [R1]
         { info_tbl: [(ccloS,
                       label: block_ccloS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccloS: // global
           I64[Sp] = block_ccloY_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uclpj; else goto cclp2;
       uclpj: // global
           call _ccloY(R1) args: 0, res: 0, upd: 0;
       cclp2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccloY() //  [R1]
         { info_tbl: [(ccloY,
                       label: block_ccloY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccloY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cclp8; else goto cclp7;
       cclp8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclp7: // global
           _sciXm::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sciXm::I64, 0)) goto cclph; else goto cclpi;
       cclph: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_sciXm::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclpi: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciY3_entry() //  [R1]
         { info_tbl: [(cclpv,
                       label: sat_sciY3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclpv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cclpw; else goto cclpx;
       cclpw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclpx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclpo_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uclpV; else goto cclpp;
       uclpV: // global
           call _cclpo(R1) args: 0, res: 0, upd: 0;
       cclpp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclpo() //  [R1]
         { info_tbl: [(cclpo,
                       label: block_cclpo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclpo: // global
           if (R1 & 7 == 1) goto uclpR; else goto cclpt;
       uclpR: // global
           Sp = Sp + 8;
           call _cclpP() args: 0, res: 0, upd: 0;
       cclpt: // global
           I64[Sp] = block_cclpD_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uclpT; else goto cclpF;
       uclpT: // global
           call _cclpD(R1) args: 0, res: 0, upd: 0;
       cclpF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclpD() //  [R1]
         { info_tbl: [(cclpD,
                       label: block_cclpD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclpD: // global
           if (R1 & 7 == 1) goto cclpL; else goto uclpS;
       cclpL: // global
           R1 = lvl50_rcccQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       uclpS: // global
           Sp = Sp + 8;
           call _cclpP() args: 0, res: 0, upd: 0;
     }
 },
 _cclpP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclpP: // global
           R1 = lvl54_rcccU_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_sciY4_entry() //  [R1]
         { info_tbl: [(cclq6,
                       label: ds3_sciY4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclq6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cclq7; else goto cclq8;
       cclq7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclq8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclq3_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclq3() //  [R1, R2]
         { info_tbl: [(cclq3,
                       label: block_cclq3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclq3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclqb; else goto cclqa;
       cclqb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cclqa: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciYL_entry() //  [R1]
         { info_tbl: [(cclqZ,
                       label: sat_sciYL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclqZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclr0; else goto cclr1;
       cclr0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclr1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclqX_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclqX() //  [R1]
         { info_tbl: [(cclqX,
                       label: block_cclqX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclqX: // global
           I64[Sp] = block_cclr4_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclr4() //  [R1]
         { info_tbl: [(cclr4,
                       label: block_cclr4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclr4: // global
           if (R1 & 7 == 1) goto cclrb; else goto cclrg;
       cclrb: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cclrg: // global
           I64[Sp - 8] = block_cclre_info;
           _sciYG::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sciYG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclru; else goto cclrh;
       uclru: // global
           call _cclre(R1) args: 0, res: 0, upd: 0;
       cclrh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclre() //  [R1]
         { info_tbl: [(cclre,
                       label: block_cclre_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclre: // global
           if (R1 & 7 == 1) goto cclrn; else goto cclrr;
       cclrn: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cclrr: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_sciYx_entry() //  [R1]
         { info_tbl: [(cclrz,
                       label: ds12_sciYx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclrz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclrA; else goto cclrB;
       cclrA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclrB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclqL_info;
           R3 = P64[R1 + 16];
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclqL() //  [R1, R2]
         { info_tbl: [(cclqL,
                       label: block_cclqL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclqL: // global
           I64[Sp - 8] = block_cclqN_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclrM; else goto cclqO;
       uclrM: // global
           call _cclqN(R1) args: 0, res: 0, upd: 0;
       cclqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclqN() //  [R1]
         { info_tbl: [(cclqN,
                       label: block_cclqN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclqN: // global
           _sciYA::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cclrw; else goto cclrx;
       cclrw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclrH; else goto cclrG;
       cclrH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclrG: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl46_rcccM_closure+1;
           P64[Hp] = _sciYA::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclrx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cclrL; else goto cclrK;
       cclrL: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclrK: // global
           I64[Hp - 40] = sat_sciYL_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = _sciYA::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds12_sciYZ_entry() //  [R1]
         { info_tbl: [(cclrV,
                       label: ds12_sciYZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclrV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccls1; else goto ccls2;
       ccls1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccls2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclrS_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucls7; else goto cclrT;
       ucls7: // global
           call _cclrS(R1) args: 0, res: 0, upd: 0;
       cclrT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclrS() //  [R1]
         { info_tbl: [(cclrS,
                       label: block_cclrS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclrS: // global
           I64[Sp] = block_cclrY_info;
           R2 = P64[R1 + 7];
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclrY() //  [R1, R2]
         { info_tbl: [(cclrY,
                       label: block_cclrY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclrY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccls6; else goto ccls5;
       ccls6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccls5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_sciY8_entry() //  [R1]
         { info_tbl: [(cclsc,
                       label: ds4_sciY8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclsc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cclsd; else goto cclse;
       cclsd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclse: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cclqg_info;
           _sciY4::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sciY4::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uclsX; else goto cclqh;
       uclsX: // global
           call _cclqg(R1) args: 0, res: 0, upd: 0;
       cclqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclqg() //  [R1]
         { info_tbl: [(cclqg,
                       label: block_cclqg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclqg: // global
           if (R1 & 7 == 1) goto ccls9; else goto cclsa;
       ccls9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cclsk; else goto cclsj;
       cclsk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclsj: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclsa: // global
           I64[Sp - 16] = block_cclqm_info;
           _sciY9::P64 = R1;
           _sciYf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciYf::P64;
           P64[Sp] = _sciY9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uclsU; else goto cclqn;
       uclsU: // global
           call _cclqm(R1) args: 0, res: 0, upd: 0;
       cclqn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclqm() //  [R1]
         { info_tbl: [(cclqm,
                       label: block_cclqm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclqm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cclso; else goto cclsn;
       cclso: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclsn: // global
           if (I64[R1 + 7] == 46) goto cclst; else goto cclss;
       cclst: // global
           Hp = Hp - 56;
           I64[Sp + 16] = block_cclqu_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uclsV; else goto cclqv;
       uclsV: // global
           call _cclqu(R1) args: 0, res: 0, upd: 0;
       cclqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cclss: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cclqu() //  [R1]
         { info_tbl: [(cclqu,
                       label: block_cclqu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclqu: // global
           if (R1 & 7 == 1) goto cclsy; else goto cclsD;
       cclsy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cclsB; else goto cclsA;
       cclsB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclsA: // global
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl52_rcccS_closure+2;
           P64[Hp - 8] = lvl53_rcccT_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclsD: // global
           I64[Sp - 16] = block_cclqA_info;
           _sciYn::P64 = R1;
           _sciYt::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sciYt::P64;
           P64[Sp] = _sciYn::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uclsW; else goto cclqB;
       uclsW: // global
           call _cclqA(R1) args: 0, res: 0, upd: 0;
       cclqB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclqA() //  [R1]
         { info_tbl: [(cclqA,
                       label: block_cclqA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclqA: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cclsG; else goto cclsF;
       cclsG: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclsF: // global
           _sciY4::P64 = P64[Sp + 24];
           if (I64[R1 + 7] == 42) goto cclsS; else goto cclsN;
       cclsS: // global
           I64[Hp - 136] = ds12_sciYZ_info;
           P64[Hp - 120] = _sciY4::P64;
           I64[Hp - 112] = stg_sel_0_upd_info;
           _cclrO::P64 = Hp - 136;
           P64[Hp - 96] = _cclrO::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _cclrO::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = Hp - 88;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = Hp - 112;
           _cclsR::P64 = Hp - 47;
           Hp = Hp - 24;
           R1 = _cclsR::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclsN: // global
           I64[Hp - 136] = ds12_sciYx_info;
           P64[Hp - 120] = P64[Sp + 16];
           I64[Hp - 112] = stg_sel_0_upd_info;
           P64[Hp - 96] = _sciY4::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           _cclqH::P64 = Hp - 136;
           P64[Hp - 72] = _cclqH::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cclqH::P64;
           I64[Hp - 40] = GHC.Base.Just_con_info;
           P64[Hp - 32] = Hp - 64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 112;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds5_sciZf_entry() //  [R1]
         { info_tbl: [(cclt5,
                       label: ds5_sciZf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclt5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclt6; else goto cclt7;
       cclt6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclt7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclt2_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucltv; else goto cclt3;
       ucltv: // global
           call _cclt2(R1) args: 0, res: 0, upd: 0;
       cclt3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclt2() //  [R1]
         { info_tbl: [(cclt2,
                       label: block_cclt2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclt2: // global
           I64[Sp - 8] = block_cclta_info;
           _sciZi::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _sciZi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucltu; else goto ccltc;
       ucltu: // global
           call _cclta(R1) args: 0, res: 0, upd: 0;
       ccltc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclta() //  [R1]
         { info_tbl: [(cclta,
                       label: block_cclta_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclta: // global
           if (R1 & 7 == 1) goto cclti; else goto ccltn;
       cclti: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccltn: // global
           I64[Sp] = block_ccltl_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ucltw; else goto cclto;
       ucltw: // global
           call _ccltl(R1) args: 0, res: 0, upd: 0;
       cclto: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccltl() //  [R1]
         { info_tbl: [(ccltl,
                       label: block_ccltl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccltl: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciZM_entry() //  [R1]
         { info_tbl: [(ccltI,
                       label: sat_sciZM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccltI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccltM; else goto ccltN;
       ccltM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccltN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccltF_info;
           _sciVk::P64 = P64[R1 + 16];
           _sciVl::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sciVk::P64;
           P64[Sp - 24] = _sciVl::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uclut; else goto ccltG;
       uclut: // global
           call _ccltF(R1) args: 0, res: 0, upd: 0;
       ccltG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccltF() //  [R1]
         { info_tbl: [(ccltF,
                       label: block_ccltF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccltF: // global
           I64[Sp] = block_ccltL_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uclus; else goto ccltP;
       uclus: // global
           call _ccltL(R1) args: 0, res: 0, upd: 0;
       ccltP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccltL() //  [R1]
         { info_tbl: [(ccltL,
                       label: block_ccltL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccltL: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto ccltZ; else goto ucluq;
       ccltZ: // global
           _sciVk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccltX_info;
           R1 = _sciVk::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucluu; else goto cclu0;
       ucluu: // global
           call _ccltX(R1) args: 0, res: 0, upd: 0;
       cclu0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       ucluq: // global
           Sp = Sp + 24;
           call _cclun() args: 0, res: 0, upd: 0;
     }
 },
 _ccltX() //  [R1]
         { info_tbl: [(ccltX,
                       label: block_ccltX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccltX: // global
           if (R1 & 7 == 1) goto cclu7; else goto uclur;
       cclu7: // global
           _sciVl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cclu4_info;
           R1 = _sciVl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucluw; else goto cclu8;
       ucluw: // global
           call _cclu4(R1) args: 0, res: 0, upd: 0;
       cclu8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       uclur: // global
           Sp = Sp + 16;
           call _cclun() args: 0, res: 0, upd: 0;
     }
 },
 _cclu4() //  [R1]
         { info_tbl: [(cclu4,
                       label: block_cclu4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclu4: // global
           if (R1 & 7 == 1) goto cclue; else goto cclui;
       cclue: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclui: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cclun() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclun: // global
           R1 = lvl47_rcccN_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sciZx_entry() //  [R1]
         { info_tbl: [(ccluG,
                       label: sat_sciZx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccluG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccluK; else goto ccluL;
       ccluK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccluL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccluD_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uclv5; else goto ccluE;
       uclv5: // global
           call _ccluD(R1) args: 0, res: 0, upd: 0;
       ccluE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccluD() //  [R1]
         { info_tbl: [(ccluD,
                       label: block_ccluD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccluD: // global
           I64[Sp] = block_ccluJ_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uclv4; else goto ccluN;
       uclv4: // global
           call _ccluJ(R1) args: 0, res: 0, upd: 0;
       ccluN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccluJ() //  [R1]
         { info_tbl: [(ccluJ,
                       label: block_ccluJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccluJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccluT; else goto ccluS;
       ccluT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccluS: // global
           _sciZu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_sciZu::I64, 0)) goto cclv2; else goto cclv3;
       cclv2: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_sciZu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclv3: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scj0v_entry() //  [R1]
         { info_tbl: [(cclvE,
                       label: sat_scj0v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclvE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclvF; else goto cclvG;
       cclvF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclvG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclvC_info;
           R3 = P64[R1 + 16];
           R2 = lvl42_rcccH_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclvC() //  [R1]
         { info_tbl: [(cclvC,
                       label: block_cclvC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclvC: // global
           I64[Sp] = block_cclvJ_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclvJ() //  [R1]
         { info_tbl: [(cclvJ,
                       label: block_cclvJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclvJ: // global
           if (R1 & 7 == 1) goto cclvQ; else goto cclvV;
       cclvQ: // global
           R1 = lvl44_rcccJ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cclvV: // global
           I64[Sp - 8] = block_cclvT_info;
           _scj0q::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _scj0q::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclw9; else goto cclvW;
       uclw9: // global
           call _cclvT(R1) args: 0, res: 0, upd: 0;
       cclvW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclvT() //  [R1]
         { info_tbl: [(cclvT,
                       label: block_cclvT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclvT: // global
           if (R1 & 7 == 1) goto cclw2; else goto cclw6;
       cclw2: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cclw6: // global
           R1 = lvl45_rcccK_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds7_scj0w_entry() //  [R1]
         { info_tbl: [(cclwi,
                       label: ds7_scj0w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclwi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cclwj; else goto cclwk;
       cclwj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclwk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclwf_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgetStar_rcccL_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclwf() //  [R1, R2]
         { info_tbl: [(cclwf,
                       label: block_cclwf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclwf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclwn; else goto cclwm;
       cclwn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cclwm: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds3_scj08_entry() //  [R1]
         { info_tbl: [(cclws,
                       label: ds3_scj08_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclws: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cclwt; else goto cclwu;
       cclwt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclwu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cclvd_info;
           _sciVp::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sciVp::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uclx7; else goto cclve;
       uclx7: // global
           call _cclvd(R1) args: 0, res: 0, upd: 0;
       cclve: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclvd() //  [R1]
         { info_tbl: [(cclvd,
                       label: block_cclvd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclvd: // global
           if (R1 & 7 == 1) goto cclwp; else goto cclwq;
       cclwp: // global
           I64[Sp] = block_cclww_info;
           R1 = lvl49_rcccP_closure;
           if (R1 & 7 != 0) goto uclx4; else goto cclwx;
       uclx4: // global
           call _cclww(R1) args: 0, res: 0, upd: 0;
       cclwx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cclwq: // global
           I64[Sp - 16] = block_cclvj_info;
           _scj09::P64 = R1;
           _scj0e::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _scj0e::P64;
           P64[Sp] = _scj09::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uclx5; else goto cclvk;
       uclx5: // global
           call _cclvj(R1) args: 0, res: 0, upd: 0;
       cclvk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclww() //  [R1]
         { info_tbl: [(cclww,
                       label: block_cclww_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclww: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cclwF; else goto cclwE;
       cclwF: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclwE: // global
           _scj0b::P64 = P64[R1 + 7];
           _scj0c::P64 = P64[R1 + 15];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = _scj0b::P64;
           P64[Hp - 8] = _scj0c::P64;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cclvj() //  [R1]
         { info_tbl: [(cclvj,
                       label: block_cclvj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclvj: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cclwJ; else goto cclwI;
       cclwJ: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclwI: // global
           if (I64[R1 + 7] == 42) goto cclx2; else goto cclwL;
       cclx2: // global
           I64[Hp - 96] = ds7_scj0w_info;
           P64[Hp - 80] = P64[Sp + 24];
           I64[Hp - 72] = stg_sel_0_upd_info;
           _cclwb::P64 = Hp - 96;
           P64[Hp - 56] = _cclwb::P64;
           I64[Hp - 48] = stg_sel_1_upd_info;
           P64[Hp - 32] = _cclwb::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 72;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclwL: // global
           Hp = Hp - 104;
           _scj09::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cclvq_info;
           R3 = _scj09::P64;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 16;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cclvq() //  [R1, R2]
         { info_tbl: [(cclvq,
                       label: block_cclvq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclvq: // global
           I64[Sp - 8] = block_cclvs_info;
           R1 = R1;
           P64[Sp] = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclx6; else goto cclvt;
       uclx6: // global
           call _cclvs(R1) args: 0, res: 0, upd: 0;
       cclvt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclvs() //  [R1]
         { info_tbl: [(cclvs,
                       label: block_cclvs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclvs: // global
           _sciVp::P64 = P64[Sp + 16];
           _scj0k::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cclwQ; else goto cclwV;
       cclwQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cclwT; else goto cclwS;
       cclwT: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclwS: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = lvl46_rcccM_closure+1;
           P64[Hp - 8] = _scj0k::P64;
           P64[Hp] = _sciVp::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclwV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cclwY; else goto cclwX;
       cclwY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cclwX: // global
           I64[Hp - 48] = sat_scj0v_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = _scj0k::P64;
           P64[Hp] = _sciVp::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds4_scj0I_entry() //  [R1]
         { info_tbl: [(cclxf,
                       label: ds4_scj0I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclxf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclxg; else goto cclxh;
       cclxg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclxh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cclxc_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uclxF; else goto cclxd;
       uclxF: // global
           call _cclxc(R1) args: 0, res: 0, upd: 0;
       cclxd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclxc() //  [R1]
         { info_tbl: [(cclxc,
                       label: block_cclxc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclxc: // global
           I64[Sp - 8] = block_cclxk_info;
           _scj0L::P64 = P64[R1 + 15];
           R1 = P64[R1 + 23];
           P64[Sp] = _scj0L::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclxE; else goto cclxm;
       uclxE: // global
           call _cclxk(R1) args: 0, res: 0, upd: 0;
       cclxm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclxk() //  [R1]
         { info_tbl: [(cclxk,
                       label: block_cclxk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclxk: // global
           if (R1 & 7 == 1) goto cclxs; else goto cclxx;
       cclxs: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cclxx: // global
           I64[Sp] = block_cclxv_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uclxG; else goto cclxy;
       uclxG: // global
           call _cclxv(R1) args: 0, res: 0, upd: 0;
       cclxy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclxv() //  [R1]
         { info_tbl: [(cclxv,
                       label: block_cclxv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclxv: // global
           R2 = P64[Sp + 8];
           R1 = P64[R1 + 7];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scj11_entry() //  [R1]
         { info_tbl: [(cclxW,
                       label: sat_scj11_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclxW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclxX; else goto cclxY;
       cclxX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclxY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cclxP_info;
           _sciVl::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sciVl::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uclyj; else goto cclxQ;
       uclyj: // global
           call _cclxP(R1) args: 0, res: 0, upd: 0;
       cclxQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cclxP() //  [R1]
         { info_tbl: [(cclxP,
                       label: block_cclxP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclxP: // global
           if (R1 & 7 == 1) goto cclxT; else goto cclxU;
       cclxT: // global
           _sciVl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccly1_info;
           R1 = _sciVl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uclyi; else goto ccly3;
       uclyi: // global
           call _ccly1(R1) args: 0, res: 0, upd: 0;
       ccly3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cclxU: // global
           R1 = lvl47_rcccN_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _ccly1() //  [R1]
         { info_tbl: [(ccly1,
                       label: block_ccly1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccly1: // global
           if (R1 & 7 == 1) goto ccly9; else goto cclyd;
       ccly9: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cclyd: // global
           R1 = lvl48_rcccO_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uclz7_srtd" {
     uclz7_srtd:
         const Scjc4_srt+448;
         const 69;
         const 17293822569102704641;
         const 31;
 },
 $wgetSpecs_rcccV_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cclyo,
                       label: $wgetSpecs_rcccV_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclyo: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cclyp; else goto uclyT;
       cclyp: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wgetSpecs_rcccV_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       uclyT: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call _cclhQ() args: 0, res: 0, upd: 0;
     }
 },
 _cclhQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclhQ: // global
           I64[Sp - 8] = block_cclhT_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclyZ; else goto cclhU;
       uclyZ: // global
           call _cclhT(R1) args: 0, res: 0, upd: 0;
       cclhU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uclz8_srtd" {
     uclz8_srtd:
         const Scjc4_srt+448;
         const 68;
         const 17293822569102704641;
         const 15;
 },
 _cclhT() //  [R1]
         { info_tbl: [(cclhT,
                       label: block_cclhT_info
                       rep:StackRep [False, False, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclhT: // global
           if (R1 & 7 == 1) goto cclyl; else goto cclym;
       cclyl: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cclym: // global
           I64[Sp - 8] = block_cclhZ_info;
           _sciVq::P64 = R1;
           _sciVt::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sciVt::P64;
           P64[Sp + 40] = _sciVq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclz0; else goto ccli0;
       uclz0: // global
           call _cclhZ(R1) args: 0, res: 0, upd: 0;
       ccli0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uclz9_srtd" {
     uclz9_srtd:
         const Scjc4_srt+448;
         const 68;
         const 17293822569102704641;
         const 15;
 },
 _cclhZ() //  [R1]
         { info_tbl: [(cclhZ,
                       label: block_cclhZ_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclhZ: // global
           Hp = Hp + 344;
           if (Hp > HpLim) (likely: False) goto cclyw; else goto cclyv;
       cclyw: // global
           HpAlloc = 344;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cclyv: // global
           _sciVk::P64 = P64[Sp + 16];
           _sciVl::P64 = P64[Sp + 24];
           _sciVm::P64 = P64[Sp + 32];
           _sciVn::P64 = P64[Sp + 40];
           _sciVp::P64 = P64[Sp + 56];
           _sciVq::P64 = P64[Sp + 48];
           _sciVw::I64 = I64[R1 + 7];
           if (_sciVw::I64 >= 49) goto cclyE; else goto uclyR;
       uclyR: // global
           if (_sciVw::I64 < 32) goto cclyE; else goto uclyS;
       uclyS: // global
           _sciVt::P64 = P64[Sp + 8];
           switch [32 .. 48] _sciVw::I64 {
               case 32 : goto cclyF;
               case 35 : goto cclyG;
               case 42 : goto cclyJ;
               case 43 : goto cclyK;
               case 45 : goto cclyL;
               case 46 : goto cclyP;
               case 48 : goto cclyQ;
               default: {goto cclyE;}
           }
       cclyQ: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sciVk::P64;
           P64[Sp + 24] = GHC.Types.True_closure+2;
           P64[Sp + 32] = _sciVm::P64;
           P64[Sp + 40] = _sciVn::P64;
           P64[Sp + 48] = _sciVt::P64;
           P64[Sp + 56] = _sciVp::P64;
           Sp = Sp + 16;
           goto uclz5;
       cclyP: // global
           I64[Hp - 336] = ds3_scj08_info;
           P64[Hp - 320] = _sciVp::P64;
           P64[Hp - 312] = _sciVt::P64;
           I64[Hp - 304] = ds4_scj0I_info;
           _cclv9::P64 = Hp - 336;
           P64[Hp - 288] = _cclv9::P64;
           I64[Hp - 280] = stg_sel_2_upd_info;
           P64[Hp - 264] = _cclv9::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           _cclx8::P64 = Hp - 304;
           P64[Hp - 240] = _cclx8::P64;
           I64[Hp - 232] = stg_sel_1_upd_info;
           P64[Hp - 216] = _cclx8::P64;
           I64[Hp - 208] = stg_sel_0_upd_info;
           P64[Hp - 192] = _cclx8::P64;
           I64[Hp - 184] = sat_scj11_info;
           P64[Hp - 168] = _sciVk::P64;
           P64[Hp - 160] = _sciVl::P64;
           I64[Hp - 152] = stg_sel_0_upd_info;
           P64[Hp - 136] = _cclv9::P64;
           I64[Hp - 128] = GHC.Base.Just_con_info;
           P64[Hp - 120] = Hp - 152;
           I64[Hp - 112] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 104] = GHC.Base.Nothing_closure+1;
           P64[Hp - 96] = Hp - 126;
           P64[Hp - 88] = Hp - 184;
           P64[Hp - 80] = _sciVm::P64;
           P64[Hp - 72] = _sciVn::P64;
           P64[Hp - 64] = Hp - 208;
           P64[Hp - 56] = Hp - 232;
           _cclxH::P64 = Hp - 280;
           _cclxI::P64 = Hp - 256;
           _cclyO::P64 = Hp - 111;
           Hp = Hp - 56;
           R3 = _cclxH::P64;
           R2 = _cclxI::P64;
           R1 = _cclyO::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cclyL: // global
           Hp = Hp - 344;
           P64[Sp + 16] = GHC.Types.True_closure+2;
           P64[Sp + 24] = _sciVl::P64;
           P64[Sp + 32] = _sciVm::P64;
           P64[Sp + 40] = _sciVn::P64;
           P64[Sp + 48] = _sciVt::P64;
           P64[Sp + 56] = _sciVp::P64;
           Sp = Sp + 16;
           goto uclz5;
       cclyK: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sciVk::P64;
           P64[Sp + 24] = _sciVl::P64;
           P64[Sp + 32] = lvl50_rcccQ_closure+2;
           P64[Sp + 40] = _sciVn::P64;
           P64[Sp + 48] = _sciVt::P64;
           P64[Sp + 56] = _sciVp::P64;
           Sp = Sp + 16;
           goto uclz5;
       cclyJ: // global
           I64[Hp - 336] = ds3_sciY4_info;
           P64[Hp - 320] = _sciVp::P64;
           I64[Hp - 312] = ds4_sciY8_info;
           P64[Hp - 296] = _sciVt::P64;
           _cclpZ::P64 = Hp - 336;
           P64[Hp - 288] = _cclpZ::P64;
           I64[Hp - 280] = ds5_sciZf_info;
           _cclqc::P64 = Hp - 312;
           P64[Hp - 264] = _cclqc::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           P64[Hp - 240] = _cclqc::P64;
           I64[Hp - 232] = stg_sel_2_upd_info;
           _cclsY::P64 = Hp - 280;
           P64[Hp - 216] = _cclsY::P64;
           I64[Hp - 208] = stg_sel_1_upd_info;
           P64[Hp - 192] = _cclsY::P64;
           I64[Hp - 184] = stg_sel_0_upd_info;
           P64[Hp - 168] = _cclsY::P64;
           I64[Hp - 160] = sat_sciZM_info;
           P64[Hp - 144] = _sciVk::P64;
           P64[Hp - 136] = _sciVl::P64;
           P64[Hp - 128] = _cclpZ::P64;
           I64[Hp - 120] = stg_sel_0_upd_info;
           P64[Hp - 104] = _cclqc::P64;
           I64[Hp - 96] = sat_sciZx_info;
           P64[Hp - 80] = _cclpZ::P64;
           I64[Hp - 72] = GHC.Base.Just_con_info;
           P64[Hp - 64] = Hp - 96;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 120;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = _sciVm::P64;
           P64[Hp - 16] = _sciVn::P64;
           P64[Hp - 8] = Hp - 184;
           P64[Hp] = Hp - 208;
           R3 = Hp - 256;
           R2 = Hp - 232;
           R1 = Hp - 55;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cclyG: // global
           Hp = Hp - 344;
           P64[Sp + 16] = _sciVk::P64;
           P64[Sp + 24] = _sciVl::P64;
           P64[Sp + 32] = _sciVm::P64;
           P64[Sp + 40] = GHC.Types.True_closure+2;
           P64[Sp + 48] = _sciVt::P64;
           P64[Sp + 56] = _sciVp::P64;
           Sp = Sp + 16;
           goto uclz5;
       cclyF: // global
           I64[Hp - 336] = sat_sciY3_info;
           P64[Hp - 320] = _sciVm::P64;
           _ccli7::P64 = Hp - 336;
           Hp = Hp - 320;
           P64[Sp + 16] = _sciVk::P64;
           P64[Sp + 24] = _sciVl::P64;
           P64[Sp + 32] = _ccli7::P64;
           P64[Sp + 40] = _sciVn::P64;
           P64[Sp + 48] = _sciVt::P64;
           P64[Sp + 56] = _sciVp::P64;
           Sp = Sp + 16;
           goto uclz5;
       uclz5: // global
           call _cclhQ() args: 0, res: 0, upd: 0;
       cclyE: // global
           if ((_sciVw::I64 + -48) > 9) goto cclyz; else goto cclyC;
       cclyz: // global
           I64[Hp - 336] = ds3_sciVB_info;
           P64[Hp - 320] = _sciVp::P64;
           P64[Hp - 312] = _sciVq::P64;
           I64[Hp - 304] = stg_sel_2_upd_info;
           _cclik::P64 = Hp - 336;
           P64[Hp - 288] = _cclik::P64;
           I64[Hp - 280] = stg_sel_1_upd_info;
           P64[Hp - 264] = _cclik::P64;
           I64[Hp - 256] = stg_sel_0_upd_info;
           P64[Hp - 240] = _cclik::P64;
           I64[Hp - 232] = sat_sciVK_info;
           P64[Hp - 216] = _sciVk::P64;
           P64[Hp - 208] = _sciVl::P64;
           I64[Hp - 200] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 192] = GHC.Base.Nothing_closure+1;
           P64[Hp - 184] = GHC.Base.Nothing_closure+1;
           P64[Hp - 176] = Hp - 232;
           P64[Hp - 168] = _sciVm::P64;
           P64[Hp - 160] = _sciVn::P64;
           P64[Hp - 152] = Hp - 256;
           P64[Hp - 144] = Hp - 280;
           _ccliM::P64 = Hp - 304;
           _cclyx::P64 = Hp - 199;
           Hp = Hp - 144;
           R3 = _sciVp::P64;
           R2 = _ccliM::P64;
           R1 = _cclyx::P64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cclyC: // global
           I64[Hp - 336] = ds3_sciW1_info;
           P64[Hp - 320] = _sciVq::P64;
           I64[Hp - 312] = ds4_sciWg_info;
           P64[Hp - 296] = _sciVp::P64;
           _ccljp::P64 = Hp - 336;
           P64[Hp - 288] = _ccljp::P64;
           I64[Hp - 280] = ds5_sciX7_info;
           _cclkv::P64 = Hp - 312;
           P64[Hp - 264] = _cclkv::P64;
           I64[Hp - 256] = stg_sel_2_upd_info;
           P64[Hp - 240] = _cclkv::P64;
           I64[Hp - 232] = stg_sel_2_upd_info;
           _cclnd::P64 = Hp - 280;
           P64[Hp - 216] = _cclnd::P64;
           I64[Hp - 208] = stg_sel_1_upd_info;
           P64[Hp - 192] = _cclnd::P64;
           I64[Hp - 184] = stg_sel_0_upd_info;
           P64[Hp - 168] = _cclnd::P64;
           I64[Hp - 160] = sat_sciXE_info;
           P64[Hp - 144] = _sciVk::P64;
           P64[Hp - 136] = _sciVl::P64;
           P64[Hp - 128] = _ccljp::P64;
           I64[Hp - 120] = stg_sel_0_upd_info;
           P64[Hp - 104] = _cclkv::P64;
           I64[Hp - 96] = sat_sciXp_info;
           P64[Hp - 80] = _ccljp::P64;
           I64[Hp - 72] = GHC.Base.Just_con_info;
           P64[Hp - 64] = Hp - 96;
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = Hp - 70;
           P64[Hp - 40] = Hp - 120;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = _sciVm::P64;
           P64[Hp - 16] = _sciVn::P64;
           P64[Hp - 8] = Hp - 184;
           P64[Hp] = Hp - 208;
           R3 = Hp - 256;
           R2 = Hp - 232;
           R1 = Hp - 55;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.797095652 UTC

[section ""data" . f_rcccW_closure" {
     f_rcccW_closure:
         const GHC.Types.C#_con_info;
         const 37;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.801611869 UTC

[section ""data" . Text.Printf.uprintfs_closure" {
     Text.Printf.uprintfs_closure:
         const Text.Printf.uprintfs_info;
         const 0;
 },
 sat_scj1A_entry() //  [R1]
         { info_tbl: [(cclMi,
                       label: sat_scj1A_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclMi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cclMj; else goto cclMk;
       cclMj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclMk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scj1S_entry() //  [R1]
         { info_tbl: [(cclMO,
                       label: sat_scj1S_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclMO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cclMP; else goto cclMQ;
       cclMP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclMQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 16];
           R3 = P64[R1 + 32];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scj1Z_entry() //  [R1]
         { info_tbl: [(cclN9,
                       label: sat_scj1Z_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclN9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cclNa; else goto cclNb;
       cclNa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclNb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . uclOt_srtd" {
     uclOt_srtd:
         const Scjc4_srt+448;
         const 70;
         const 9223372036854775809;
         const 48;
 },
 Text.Printf.uprintfs_entry() //  [R2, R3, R4]
         { info_tbl: [(cclNg,
                       label: Text.Printf.uprintfs_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclNg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cclNh; else goto cclNi;
       cclNh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.uprintfs_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cclNi: // global
           I64[Sp - 24] = block_cclM1_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uclOr; else goto cclM2;
       uclOr: // global
           call _cclM1(R1) args: 0, res: 0, upd: 0;
       cclM2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . uclOu_srtd" {
     uclOu_srtd:
         const Scjc4_srt+448;
         const 70;
         const 9223372036854775809;
         const 48;
 },
 _cclM1() //  [R1]
         { info_tbl: [(cclM1,
                       label: block_cclM1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclM1: // global
           if (R1 & 7 == 1) goto cclNd; else goto cclNe;
       cclNd: // global
           _scj1o::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cclNk_info;
           R1 = _scj1o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uclOh; else goto cclNm;
       uclOh: // global
           call _cclNk(R1) args: 0, res: 0, upd: 0;
       cclNm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cclNe: // global
           I64[Sp - 8] = block_cclM7_info;
           _scj1w::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scj1w::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclOi; else goto cclM8;
       uclOi: // global
           call _cclM7(R1) args: 0, res: 0, upd: 0;
       cclM8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cclNk() //  [R1]
         { info_tbl: [(cclNk,
                       label: block_cclNk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclNk: // global
           if (R1 & 7 == 1) goto cclNs; else goto cclNw;
       cclNs: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cclNw: // global
           R1 = Text.Printf.errorShortFormat_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cclM7() //  [R1]
         { info_tbl: [(cclM7,
                       label: block_cclM7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclM7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cclNA; else goto cclNz;
       cclNA: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cclNz: // global
           _scj1w::P64 = P64[Sp + 8];
           if (I64[R1 + 7] == 37) goto cclNV; else goto cclND;
       cclNV: // global
           Hp = Hp - 64;
           I64[Sp] = block_cclMR_info;
           R1 = _scj1w::P64;
           if (R1 & 7 != 0) goto uclOj; else goto cclMS;
       uclOj: // global
           call _cclMR(R1) args: 0, res: 0, upd: 0;
       cclMS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cclND: // global
           I64[Hp - 56] = sat_scj1A_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _scj1w::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cclMR() //  [R1]
         { info_tbl: [(cclMR,
                       label: block_cclMR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclMR: // global
           if (R1 & 7 == 1) goto uclOd; else goto cclO1;
       uclOd: // global
           Sp = Sp + 8;
           call _scj1B() args: 0, res: 0, upd: 0;
       cclO1: // global
           I64[Sp - 8] = block_cclMX_info;
           _scj1V::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scj1V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclOo; else goto cclMY;
       uclOo: // global
           call _cclMX(R1) args: 0, res: 0, upd: 0;
       cclMY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cclMX() //  [R1]
         { info_tbl: [(cclMX,
                       label: block_cclMX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclMX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cclO4; else goto cclO3;
       cclO4: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cclO3: // global
           if (I64[R1 + 7] == 37) goto cclO8; else goto cclO6;
       cclO8: // global
           I64[Hp - 56] = sat_scj1Z_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = f_rcccW_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cclO6: // global
           Hp = Hp - 64;
           Sp = Sp + 16;
           call _scj1B() args: 0, res: 0, upd: 0;
     }
 },
 _scj1B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       scj1B: // global
           I64[Sp - 8] = block_cclMr_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclOs; else goto cclMs;
       uclOs: // global
           call _cclMr(R1) args: 0, res: 0, upd: 0;
       cclMs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cclMr() //  [R1]
         { info_tbl: [(cclMr,
                       label: block_cclMr_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclMr: // global
           if (R1 & 7 == 1) goto uclOf; else goto cclNK;
       uclOf: // global
           Sp = Sp + 32;
           call _cclNP() args: 0, res: 0, upd: 0;
       cclNK: // global
           I64[Sp + 16] = block_cclMx_info;
           R6 = P64[Sp + 8];
           R5 = GHC.Types.False_closure+1;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = GHC.Types.False_closure+1;
           R2 = GHC.Types.False_closure+1;
           P64[Sp + 8] = R1;
           Sp = Sp + 8;
           call $wgetSpecs_rcccV_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 16, res: 8, upd: 8;
     }
 },
 _cclMx() //  [R1, R2, R3]
         { info_tbl: [(cclMx,
                       label: block_cclMx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclMx: // global
           I64[Sp - 16] = block_cclMz_info;
           _scj1I::P64 = R1;
           R1 = R3;
           P64[Sp - 8] = R2;
           P64[Sp] = _scj1I::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uclOl; else goto cclMA;
       uclOl: // global
           call _cclMz(R1) args: 0, res: 0, upd: 0;
       cclMA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cclMz() //  [R1]
         { info_tbl: [(cclMz,
                       label: block_cclMz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclMz: // global
           if (R1 & 7 == 1) goto uclOg; else goto cclNR;
       uclOg: // global
           Sp = Sp + 32;
           call _cclNP() args: 0, res: 0, upd: 0;
       cclNR: // global
           I64[Sp - 8] = block_cclMF_info;
           _scj1O::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scj1O::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uclOm; else goto cclMG;
       uclOm: // global
           call _cclMF(R1) args: 0, res: 0, upd: 0;
       cclMG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cclNP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclNP: // global
           R1 = Text.Printf.errorMissingArgument_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cclMF() //  [R1]
         { info_tbl: [(cclMF,
                       label: block_cclMF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclMF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cclNU; else goto cclNT;
       cclNU: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cclNT: // global
           _scj1R::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_scj1S_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 32;
           R2 = P64[Sp + 24];
           R1 = _scj1R::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.834748958 UTC

[section ""data" . Text.Printf.$fPrintfTypeIO_$cspr_closure" {
     Text.Printf.$fPrintfTypeIO_$cspr_closure:
         const Text.Printf.$fPrintfTypeIO_$cspr_info;
         const 0;
 },
 sat_scj23_entry() //  [R1]
         { info_tbl: [(cclQp,
                       label: sat_scj23_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclQp: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scj24_entry() //  [R1]
         { info_tbl: [(cclQs,
                       label: sat_scj24_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclQs: // global
           _scj24::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cclQt; else goto cclQu;
       cclQu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclQw; else goto cclQv;
       cclQw: // global
           HpAlloc = 24;
           goto cclQt;
       cclQt: // global
           R1 = _scj24::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclQv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scj24::P64;
           _scj21::P64 = P64[_scj24::P64 + 16];
           _scj22::P64 = P64[_scj24::P64 + 24];
           I64[Hp - 16] = sat_scj23_info;
           P64[Hp] = _scj22::P64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _scj21::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfTypeIO_$cspr_entry() //  [R2, R3, R4]
         { info_tbl: [(cclQx,
                       label: Text.Printf.$fPrintfTypeIO_$cspr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclQx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cclQy; else goto cclQz;
       cclQy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fPrintfTypeIO_$cspr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cclQz: // global
           I64[Sp - 24] = block_cclQf_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cclQf() //  []
         { info_tbl: [(cclQf,
                       label: block_cclQf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclQf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cclQC; else goto cclQB;
       cclQC: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cclQB: // global
           I64[Hp - 24] = sat_scj24_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           Sp = Sp + 24;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.844366535 UTC

[section ""data" . Text.Printf.$fPrintfTypeIO_closure" {
     Text.Printf.$fPrintfTypeIO_closure:
         const Text.Printf.$fPrintfTypeIO_info;
         const 0;
 },
 Text.Printf.$fPrintfTypeIO_entry() //  [R2, R3, R4]
         { info_tbl: [(cclR6,
                       label: Text.Printf.$fPrintfTypeIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclR6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfTypeIO_$cspr_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.849215295 UTC

[section ""data" . Text.Printf.$fPrintfType[]_$cspr_closure" {
     Text.Printf.$fPrintfType[]_$cspr_closure:
         const Text.Printf.$fPrintfType[]_$cspr_info;
         const 0;
 },
 sat_scj29_entry() //  [R1]
         { info_tbl: [(cclRl,
                       label: sat_scj29_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclRl: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scj28_entry() //  [R1]
         { info_tbl: [(cclRw,
                       label: sat_scj28_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclRw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cclRx; else goto cclRy;
       cclRx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclRy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Text.Printf.fromChar_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fPrintfType[]_$cspr_entry() //  [R2, R3, R4]
         { info_tbl: [(cclRz,
                       label: Text.Printf.$fPrintfType[]_$cspr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclRz: // global
           _scj27::P64 = R4;
           _scj26::P64 = R3;
           _scj25::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cclRA; else goto cclRB;
       cclRB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclRD; else goto cclRC;
       cclRD: // global
           HpAlloc = 24;
           goto cclRA;
       cclRA: // global
           R4 = _scj27::P64;
           R3 = _scj26::P64;
           R2 = _scj25::P64;
           R1 = Text.Printf.$fPrintfType[]_$cspr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cclRC: // global
           I64[Hp - 16] = sat_scj29_info;
           P64[Hp] = _scj27::P64;
           I64[Sp - 16] = block_cclRo_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _scj26::P64;
           P64[Sp - 8] = _scj25::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cclRo() //  [R1]
         { info_tbl: [(cclRo,
                       label: block_cclRo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclRo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclRG; else goto cclRF;
       cclRG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cclRF: // global
           I64[Hp - 16] = sat_scj28_info;
           P64[Hp] = P64[Sp + 8];
           R3 = R1;
           R2 = Hp - 16;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.858640765 UTC

[section ""data" . Text.Printf.$fPrintfType[]_closure" {
     Text.Printf.$fPrintfType[]_closure:
         const Text.Printf.$fPrintfType[]_info;
         const 0;
 },
 Text.Printf.$fPrintfType[]_entry() //  [R2, R3, R4]
         { info_tbl: [(cclS7,
                       label: Text.Printf.$fPrintfType[]_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclS7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fPrintfType[]_$cspr_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.862712254 UTC

[section ""data" . Text.Printf.$fHPrintfTypeIO_$chspr_closure" {
     Text.Printf.$fHPrintfTypeIO_$chspr_closure:
         const Text.Printf.$fHPrintfTypeIO_$chspr_info;
         const 0;
 },
 sat_scj2f_entry() //  [R1]
         { info_tbl: [(cclSs,
                       label: sat_scj2f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclSs: // global
           R2 = P64[R1 + 16];
           call GHC.List.reverse_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scj2g_entry() //  [R1]
         { info_tbl: [(cclSv,
                       label: sat_scj2g_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclSv: // global
           _scj2g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cclSw; else goto cclSx;
       cclSx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclSz; else goto cclSy;
       cclSz: // global
           HpAlloc = 24;
           goto cclSw;
       cclSw: // global
           R1 = _scj2g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclSy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scj2g::P64;
           _scj2d::P64 = P64[_scj2g::P64 + 16];
           _scj2e::P64 = P64[_scj2g::P64 + 24];
           I64[Hp - 16] = sat_scj2f_info;
           P64[Hp] = _scj2e::P64;
           R4 = GHC.Types.[]_closure+1;
           R3 = Hp - 16;
           R2 = _scj2d::P64;
           Sp = Sp - 16;
           call Text.Printf.uprintfs_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Text.Printf.$fHPrintfTypeIO_$chspr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cclSA,
                       label: Text.Printf.$fHPrintfTypeIO_$chspr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclSA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cclSB; else goto cclSC;
       cclSB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.$fHPrintfTypeIO_$chspr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cclSC: // global
           I64[Sp - 32] = block_cclSi_info;
           R2 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cclSi() //  []
         { info_tbl: [(cclSi,
                       label: block_cclSi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclSi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cclSF; else goto cclSE;
       cclSF: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cclSE: // global
           I64[Hp - 24] = sat_scj2g_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           Sp = Sp + 32;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.872369753 UTC

[section ""data" . Text.Printf.$fHPrintfTypeIO_closure" {
     Text.Printf.$fHPrintfTypeIO_closure:
         const Text.Printf.$fHPrintfTypeIO_info;
         const 0;
 },
 Text.Printf.$fHPrintfTypeIO_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cclT8,
                       label: Text.Printf.$fHPrintfTypeIO_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclT8: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Text.Printf.$fHPrintfTypeIO_$chspr_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.876308935 UTC

[section ""data" . Text.Printf.FormatParse_closure" {
     Text.Printf.FormatParse_closure:
         const Text.Printf.FormatParse_info;
 },
 Text.Printf.FormatParse_entry() //  [R2, R3, R4]
         { info_tbl: [(cclTk,
                       label: Text.Printf.FormatParse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclTk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cclTo; else goto cclTn;
       cclTo: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.FormatParse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cclTn: // global
           I64[Hp - 24] = Text.Printf.FormatParse_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.880340789 UTC

[section ""data" . Text.Printf.FieldFormat_closure" {
     Text.Printf.FieldFormat_closure:
         const Text.Printf.FieldFormat_info;
 },
 Text.Printf.FieldFormat_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclTw: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Text.Printf.FieldFormat_entry(R6,
                                              R5,
                                              R4,
                                              R3,
                                              R2,
                                              R1) args: 24, res: 0, upd: 8;
     }
 },
 Text.Printf.FieldFormat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cclTB,
                       label: Text.Printf.FieldFormat_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclTB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cclTF; else goto cclTE;
       cclTF: // global
           HpAlloc = 64;
           R1 = Text.Printf.FieldFormat_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cclTE: // global
           I64[Hp - 56] = Text.Printf.FieldFormat_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.886347143 UTC

[section ""data" . Text.Printf.SignPlus_closure" {
     Text.Printf.SignPlus_closure:
         const Text.Printf.SignPlus_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.888064931 UTC

[section ""data" . Text.Printf.SignSpace_closure" {
     Text.Printf.SignSpace_closure:
         const Text.Printf.SignSpace_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.889765075 UTC

[section ""data" . Text.Printf.LeftAdjust_closure" {
     Text.Printf.LeftAdjust_closure:
         const Text.Printf.LeftAdjust_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.891369304 UTC

[section ""data" . Text.Printf.ZeroPad_closure" {
     Text.Printf.ZeroPad_closure:
         const Text.Printf.ZeroPad_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.893324651 UTC

[section ""data" . Text.Printf.C:IsChar_closure" {
     Text.Printf.C:IsChar_closure:
         const Text.Printf.C:IsChar_info;
 },
 Text.Printf.C:IsChar_entry() //  [R2, R3]
         { info_tbl: [(cclTZ,
                       label: Text.Printf.C:IsChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclTZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclU3; else goto cclU2;
       cclU3: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.C:IsChar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cclU2: // global
           I64[Hp - 16] = Text.Printf.C:IsChar_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.897104269 UTC

[section ""data" . Text.Printf.C:PrintfArg_closure" {
     Text.Printf.C:PrintfArg_closure:
         const Text.Printf.C:PrintfArg_info;
 },
 Text.Printf.C:PrintfArg_entry() //  [R2, R3]
         { info_tbl: [(cclUf,
                       label: Text.Printf.C:PrintfArg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclUf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cclUj; else goto cclUi;
       cclUj: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Text.Printf.C:PrintfArg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cclUi: // global
           I64[Hp - 16] = Text.Printf.C:PrintfArg_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.900636659 UTC

[Text.Printf.FormatParse_con_entry() //  [R1]
         { info_tbl: [(cclUq,
                       label: Text.Printf.FormatParse_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,70,111,114,109,97,116,80,97,114,115,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclUq: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.904116168 UTC

[Text.Printf.FieldFormat_con_entry() //  [R1]
         { info_tbl: [(cclUx,
                       label: Text.Printf.FieldFormat_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,70,105,101,108,100,70,111,114,109,97,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclUx: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.907197868 UTC

[section ""relreadonly" . Text.Printf.FormatSign_closure_tbl" {
     Text.Printf.FormatSign_closure_tbl:
         const Text.Printf.SignPlus_closure+1;
         const Text.Printf.SignSpace_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.908945533 UTC

[Text.Printf.SignPlus_con_entry() //  [R1]
         { info_tbl: [(cclUF,
                       label: Text.Printf.SignPlus_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,83,105,103,110,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclUF: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.912716367 UTC

[Text.Printf.SignSpace_con_entry() //  [R1]
         { info_tbl: [(cclUM,
                       label: Text.Printf.SignSpace_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,83,105,103,110,83,112,97,99,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclUM: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.916377967 UTC

[section ""relreadonly" . Text.Printf.FormatAdjustment_closure_tbl" {
     Text.Printf.FormatAdjustment_closure_tbl:
         const Text.Printf.LeftAdjust_closure+1;
         const Text.Printf.ZeroPad_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.918048044 UTC

[Text.Printf.LeftAdjust_con_entry() //  [R1]
         { info_tbl: [(cclUU,
                       label: Text.Printf.LeftAdjust_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,76,101,102,116,65,100,106,117,115,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclUU: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.921171611 UTC

[Text.Printf.ZeroPad_con_entry() //  [R1]
         { info_tbl: [(cclV1,
                       label: Text.Printf.ZeroPad_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,90,101,114,111,80,97,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclV1: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.924329388 UTC

[Text.Printf.C:IsChar_con_entry() //  [R1]
         { info_tbl: [(cclV8,
                       label: Text.Printf.C:IsChar_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,67,58,73,115,67,104,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclV8: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.927879084 UTC

[Text.Printf.C:PrintfArg_con_entry() //  [R1]
         { info_tbl: [(cclVf,
                       label: Text.Printf.C:PrintfArg_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,84,101,120,116,46,80,114,105,110,116,102,46,67,58,80,114,105,110,116,102,65,114,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclVf: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:14.930963968 UTC

[section ""relreadonly" . Scjc4_srt" {
     Scjc4_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Printf.perror_closure;
         const GHC.Show.$wshowLitChar_closure;
         const GHC.Show.$fShowChar1_closure;
         const Text.Printf.$werrorBadFormat_closure;
         const Text.Printf.errorBadFormat_closure;
         const Text.Printf.errorShortFormat_closure;
         const Text.Printf.$dmparseFormat_closure;
         const GHC.Char.$wlvl_closure;
         const GHC.Unicode.toUpper_closure;
         const GHC.Float.$w$sformatRealFloatAlt_closure;
         const Text.Printf.$w$sdfmt_closure;
         const Text.Printf.$fPrintfArgDouble7_closure;
         const Text.Printf.$fPrintfArgDouble8_closure;
         const GHC.Float.$w$sformatRealFloatAlt1_closure;
         const Text.Printf.$w$sdfmt1_closure;
         const Text.Printf.$fPrintfArgFloat1_closure;
         const GHC.Float.formatRealFloatAlt_closure;
         const Text.Printf.$wdfmt_closure;
         const Text.Printf.formatRealFloat1_closure;
         const sat_sciEX_closure;
         const sat_sciEZ_closure;
         const sat_sciF3_closure;
         const sat_sciF9_closure;
         const Text.Printf.intModifierMap_closure;
         const Text.Printf.$wfixupMods_closure;
         const Text.Printf.$fPrintfArgInt2_closure;
         const Text.Printf.fixupMods_closure;
         const Text.Printf.$wparseIntFormat_closure;
         const GHC.Err.undefined_closure;
         const lvl18_rccch_closure;
         const Control.Exception.Base.patError_closure;
         const sat_sciGy_closure;
         const GHC.Show.intToDigit_closure;
         const GHC.Show.$fShowInteger_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Numeric.showIntAtBase_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const Text.Printf.formatChar2_closure;
         const lvl21_rccck_closure;
         const lvl20_rcccj_closure;
         const $wfmtu_rcccl_closure;
         const Text.Printf.errorBadArgument_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const $wfmti_rcccm_closure;
         const Text.Printf.$wadjustSigned_closure;
         const Text.Printf.$fPrintfArgDouble1_closure;
         const Text.Printf.$fPrintfArgDouble3_closure;
         const Text.Printf.$w$sformatRealFloat_closure;
         const Text.Printf.$fPrintfArgDouble_$sformatRealFloat_closure;
         const Text.Printf.$w$sformatRealFloat1_closure;
         const Text.Printf.$fPrintfArgFloat_$sformatRealFloat_closure;
         const Text.Printf.$wformatRealFloat_closure;
         const Text.Printf.formatRealFloat_closure;
         const Text.Printf.$fPrintfArgDouble_$cparseFormat_closure;
         const Text.Printf.errorShortFormat_closure;
         const Text.Printf.$fPrintfArgFloat_$cparseFormat_closure;
         const Text.Printf.$w$sformatString_closure;
         const Text.Printf.$werrorBadFormat_closure;
         const Text.Printf.$wformatString_closure;
         const Text.Printf.formatString_closure;
         const lvl22_rcccn_closure;
         const Text.Printf.$fPrintfArg[]_closure;
         const sat_sciM4_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const sat_sciM7_closure;
         const sat_sciM9_closure;
         const sat_sciMb_closure;
         const GHC.Unicode.toUpper_closure;
         const lvl24_rcccp_closure;
         const lvl38_rcccD_closure;
         const lvl39_rcccE_closure;
         const GHC.Char.$wlvl_closure;
         const lvl32_rcccx_closure;
         const lvl40_rcccF_closure;
         const $wfmtu_rcccl_closure;
         const Text.Printf.formatChar2_closure;
         const lvl35_rcccA_closure;
         const lvl41_rcccG_closure;
         const Text.Printf.$wformatIntegral_closure;
         const lvl30_rcccv_closure;
         const lvl31_rcccw_closure;
         const Text.Printf.formatIntegral_closure;
         const Text.Printf.$wformatChar_closure;
         const Text.Printf.formatChar1_closure;
         const Text.Printf.formatChar_closure;
         const Text.Printf.$fPrintfArgInt2_closure;
         const Text.Printf.$w$sformatInt3_closure;
         const Text.Printf.$fPrintfArgWord64_$sformatInt_closure;
         const Text.Printf.$w$sformatInt2_closure;
         const Text.Printf.$fPrintfArgWord32_$sformatInt_closure;
         const Text.Printf.$w$sformatInt1_closure;
         const Text.Printf.$fPrintfArgWord16_$sformatInt_closure;
         const Text.Printf.$w$sformatInt4_closure;
         const Text.Printf.$fPrintfArgWord8_$sformatInt_closure;
         const Text.Printf.$w$sformatInt_closure;
         const Text.Printf.$fPrintfArgWord_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt1_closure;
         const Text.Printf.$fPrintfArgInt64_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt4_closure;
         const Text.Printf.$fPrintfArgInt32_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt3_closure;
         const Text.Printf.$fPrintfArgInt16_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt5_closure;
         const Text.Printf.$fPrintfArgInt8_$sformatInt_closure;
         const Text.Printf.$fPrintfArgInt_$sformatInt_closure;
         const Text.Printf.$wformatInt_closure;
         const Text.Printf.formatInt_closure;
         const Text.Printf.formatInteger_closure;
         const Text.Printf.$fPrintfArgNatural_$cformatArg_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Text.Read.readEither5_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Read.readEither2_closure;
         const lvl42_rcccH_closure;
         const lvl44_rcccJ_closure;
         const lvl45_rcccK_closure;
         const Text.Printf.errorMissingArgument_closure;
         const $wgetStar_rcccL_closure;
         const lvl49_rcccP_closure;
         const lvl52_rcccS_closure;
         const lvl53_rcccT_closure;
         const $wgetSpecs_rcccV_closure;
         const Text.Printf.uprintfs_closure;
         const Text.Printf.errorShortFormat_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const Text.Printf.$fPrintfTypeIO_$cspr_closure;
         const Text.Printf.$fPrintfType[]_$cspr_closure;
         const Text.Printf.$fHPrintfTypeIO_$chspr_closure;
 }]

