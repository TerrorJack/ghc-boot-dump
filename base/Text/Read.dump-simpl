
==================== Tidy Core ====================
2018-03-16 16:00:16.807893861 UTC

Result size of Tidy Core
  = {terms: 122, types: 176, coercions: 4, joins: 0/2}

-- RHS size: {terms: 5, types: 5, coercions: 0, joins: 0/0}
reads :: forall a. Read a => ReadS a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)LLL),1*U(1*C1(U),A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5hjo) ($dRead_a5hjq [Occ=Once] :: Read a_a5hjo) ->
                 readsPrec @ a_a5hjo $dRead_a5hjq minPrec}]
reads
  = \ (@ a_a5hjo) ($dRead_a5hjq :: Read a_a5hjo) ->
      readsPrec @ a_a5hjo $dRead_a5hjq minPrec

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.Read.readEither6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Text.Read.readEither6 = "Prelude.read: no parse"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.Read.readEither5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Text.Read.readEither5 = unpackCString# Text.Read.readEither6

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Text.Read.readEither4 :: forall a. Either [Char] a
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.Read.readEither4
  = \ (@ a_a5hip) ->
      Data.Either.Left @ [Char] @ a_a5hip Text.Read.readEither5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.Read.readEither3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 90 0}]
Text.Read.readEither3 = "Prelude.read: ambiguous parse"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.Read.readEither2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Text.Read.readEither2 = unpackCString# Text.Read.readEither3

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Text.Read.readEither1 :: forall a. Either [Char] a
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.Read.readEither1
  = \ (@ a_a5hip) ->
      Data.Either.Left @ [Char] @ a_a5hip Text.Read.readEither2

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/2}
Text.Read.readEither7 [InlPrag=NOUSERINLINE[0]]
  :: forall a. a -> Text.ParserCombinators.ReadP.P a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s5hm2) (w_s5hm3 [Occ=OnceL] :: a_s5hm2) ->
                 let {
                   lvl_s5hkU :: Text.ParserCombinators.ReadP.P a_s5hm2
                   [LclId, Unf=OtherCon []]
                   lvl_s5hkU
                     = Text.ParserCombinators.ReadP.Result
                         @ a_s5hm2
                         w_s5hm3
                         (Text.ParserCombinators.ReadP.Fail @ a_s5hm2) } in
                 let {
                   k_s5hkS [Occ=OnceL] :: () -> Text.ParserCombinators.ReadP.P a_s5hm2
                   [LclId,
                    Arity=1,
                    Str=<L,A>,
                    Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                            WorkFree=True, Expandable=True,
                            Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                            Tmpl= \ _ [Occ=Dead] -> lvl_s5hkU}]
                   k_s5hkS = \ _ [Occ=Dead] -> lvl_s5hkU } in
                 Text.ParserCombinators.ReadP.Look
                   @ a_s5hm2
                   (\ (a1_X3nh2 [Occ=Once] :: String) ->
                      Text.ParserCombinators.ReadP.skipSpaces2
                        a1_X3nh2 @ a_s5hm2 k_s5hkS)}]
Text.Read.readEither7
  = \ (@ a_s5hm2) (w_s5hm3 :: a_s5hm2) ->
      let {
        lvl_s5hkU :: Text.ParserCombinators.ReadP.P a_s5hm2
        [LclId, Unf=OtherCon []]
        lvl_s5hkU
          = Text.ParserCombinators.ReadP.Result
              @ a_s5hm2
              w_s5hm3
              (Text.ParserCombinators.ReadP.Fail @ a_s5hm2) } in
      let {
        k_s5hkS [Dmd=<L,C(U)>]
          :: () -> Text.ParserCombinators.ReadP.P a_s5hm2
        [LclId,
         Arity=1,
         Str=<L,A>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                 Tmpl= \ _ [Occ=Dead] -> lvl_s5hkU}]
        k_s5hkS = \ _ [Occ=Dead] -> lvl_s5hkU } in
      Text.ParserCombinators.ReadP.Look
        @ a_s5hm2
        (\ (a1_X3nh2 :: String) ->
           Text.ParserCombinators.ReadP.skipSpaces2
             a1_X3nh2 @ a_s5hm2 k_s5hkS)

Rec {
-- RHS size: {terms: 20, types: 32, coercions: 0, joins: 0/0}
Text.Read.readEither8 [Occ=LoopBreaker]
  :: forall a. [(a, String)] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
Text.Read.readEither8
  = \ (@ a_a5hip) (ds_i1y1c :: [(a_a5hip, String)]) ->
      case ds_i1y1c of {
        [] -> GHC.Types.[] @ a_a5hip;
        : y_i1y1h ys_i1y1i ->
          case y_i1y1h of { (x_a5hho, ds1_d5hjL) ->
          case ds1_d5hjL of {
            [] ->
              GHC.Types.:
                @ a_a5hip x_a5hho (Text.Read.readEither8 @ a_a5hip ys_i1y1i);
            : ipv_s5hkm ipv1_s5hkn -> Text.Read.readEither8 @ a_a5hip ys_i1y1i
          }
          }
      }
end Rec }

-- RHS size: {terms: 21, types: 24, coercions: 4, joins: 0/0}
readEither :: forall a. Read a => String -> Either String a
[GblId,
 Arity=2,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 140 20}]
readEither
  = \ (@ a_a5hip)
      ($dRead_a5hir :: Read a_a5hip)
      (s_a5hhl :: String) ->
      case Text.Read.readEither8
             @ a_a5hip
             (Text.ParserCombinators.ReadP.run
                @ a_a5hip
                (((((readPrec @ a_a5hip $dRead_a5hir)
                    `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_a5hip>_R
                            :: (ReadPrec a_a5hip :: *) ~R# (Prec -> ReadP a_a5hip :: *)))
                     minPrec)
                  `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a5hip>_R
                          :: (ReadP a_a5hip :: *)
                             ~R# (forall b.
                                  (a_a5hip -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)))
                   @ a_a5hip (Text.Read.readEither7 @ a_a5hip))
                s_a5hhl)
      of {
        [] -> Text.Read.readEither4 @ a_a5hip;
        : x_a5hhp ds_d5hk0 ->
          case ds_d5hk0 of {
            [] -> Data.Either.Right @ String @ a_a5hip x_a5hhp;
            : ipv_s5hkt ipv1_s5hku -> Text.Read.readEither1 @ a_a5hip
          }
      }

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
readMaybe :: forall a. Read a => String -> Maybe a
[GblId,
 Arity=2,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5hj2)
                 ($dRead_a5hj4 [Occ=Once] :: Read a_a5hj2)
                 (s_a5hhq [Occ=Once] :: String) ->
                 case readEither @ a_a5hj2 $dRead_a5hj4 s_a5hhq of {
                   Left _ [Occ=Dead] -> GHC.Base.Nothing @ a_a5hj2;
                   Right a1_a5hhr [Occ=Once] -> GHC.Base.Just @ a_a5hj2 a1_a5hhr
                 }}]
readMaybe
  = \ (@ a_a5hj2)
      ($dRead_a5hj4 :: Read a_a5hj2)
      (s_a5hhq :: String) ->
      case readEither @ a_a5hj2 $dRead_a5hj4 s_a5hhq of {
        Left ds_d5hke -> GHC.Base.Nothing @ a_a5hj2;
        Right a1_a5hhr -> GHC.Base.Just @ a_a5hj2 a1_a5hhr
      }

-- RHS size: {terms: 12, types: 15, coercions: 0, joins: 0/0}
read :: forall a. Read a => String -> a
[GblId,
 Arity=2,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5hjc)
                 ($dRead_a5hje [Occ=Once] :: Read a_a5hjc)
                 (s_a5hhs [Occ=Once] :: String) ->
                 case readEither @ a_a5hjc $dRead_a5hje s_a5hhs of {
                   Left x_a5dNt [Occ=Once] ->
                     errorWithoutStackTrace @ 'LiftedRep @ a_a5hjc x_a5dNt;
                   Right y_a5dNv [Occ=Once] -> y_a5dNv
                 }}]
read
  = \ (@ a_a5hjc)
      ($dRead_a5hje :: Read a_a5hjc)
      (s_a5hhs :: String) ->
      case readEither @ a_a5hjc $dRead_a5hje s_a5hhs of {
        Left x_a5dNt ->
          errorWithoutStackTrace @ 'LiftedRep @ a_a5hjc x_a5dNt;
        Right y_a5dNv -> y_a5dNv
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.Read.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Text.Read.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.Read.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.Read.$trModule3 = GHC.Types.TrNameS Text.Read.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Text.Read.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Text.Read.$trModule2 = "Text.Read"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Text.Read.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Text.Read.$trModule1 = GHC.Types.TrNameS Text.Read.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Text.Read.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Text.Read.$trModule
  = GHC.Types.Module Text.Read.$trModule3 Text.Read.$trModule1


