
==================== Pre unarise: ====================
2018-03-16 15:56:19.469955285 UTC

Data.Function.fix :: forall a. (a -> a) -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_s1xFv]
        let {
          x_s1xFw [Occ=LoopBreaker] :: a_a1xF3
          [LclId] =
              [f_s1xFv x_s1xFw] \u [] f_s1xFv x_s1xFw;
        } in  x_s1xFw;

Data.Function.on
  :: forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,C(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [.*._s1xFx f_s1xFy x_s1xFz y_s1xFA]
        let {
          sat_s1xFC [Occ=Once] :: b_a1xEZ
          [LclId] =
              [f_s1xFy y_s1xFA] \u [] f_s1xFy y_s1xFA; } in
        let {
          sat_s1xFB [Occ=Once] :: b_a1xEZ
          [LclId] =
              [f_s1xFy x_s1xFz] \u [] f_s1xFy x_s1xFz;
        } in  .*._s1xFx sat_s1xFB sat_s1xFC;

Data.Function.& :: forall a b. a -> (a -> b) -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1xFD f_s1xFE] f_s1xFE x_s1xFD;

Data.Function.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Function.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Function.$trModule4];

Data.Function.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Function"#;

Data.Function.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Function.$trModule2];

Data.Function.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Function.$trModule3
                                     Data.Function.$trModule1];


==================== STG syntax: ====================
2018-03-16 15:56:19.471369078 UTC

Data.Function.fix :: forall a. (a -> a) -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_s1xFv]
        let {
          x_s1xFw [Occ=LoopBreaker] :: a_a1xF3
          [LclId] =
              [f_s1xFv x_s1xFw] \u [] f_s1xFv x_s1xFw;
        } in  x_s1xFw;

Data.Function.on
  :: forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,C(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [.*._s1xFx f_s1xFy x_s1xFz y_s1xFA]
        let {
          sat_s1xFC [Occ=Once] :: b_a1xEZ
          [LclId] =
              [f_s1xFy y_s1xFA] \u [] f_s1xFy y_s1xFA; } in
        let {
          sat_s1xFB [Occ=Once] :: b_a1xEZ
          [LclId] =
              [f_s1xFy x_s1xFz] \u [] f_s1xFy x_s1xFz;
        } in  .*._s1xFx sat_s1xFB sat_s1xFC;

Data.Function.& :: forall a b. a -> (a -> b) -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1xFD f_s1xFE] f_s1xFE x_s1xFD;

Data.Function.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Function.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Function.$trModule4];

Data.Function.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Function"#;

Data.Function.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Function.$trModule2];

Data.Function.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Function.$trModule3
                                     Data.Function.$trModule1];


==================== Pre unarise: ====================
2018-03-16 15:56:19.530333229 UTC

Data.Function.fix :: forall a. (a -> a) -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_s1xHk]
        let {
          x_s1xHl [Occ=LoopBreaker] :: a_a1xF3
          [LclId] =
              [f_s1xHk x_s1xHl] \u [] f_s1xHk x_s1xHl;
        } in  x_s1xHl;

Data.Function.on
  :: forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,C(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [.*._s1xHm f_s1xHn x_s1xHo y_s1xHp]
        let {
          sat_s1xHr [Occ=Once] :: b_a1xEZ
          [LclId] =
              [f_s1xHn y_s1xHp] \u [] f_s1xHn y_s1xHp; } in
        let {
          sat_s1xHq [Occ=Once] :: b_a1xEZ
          [LclId] =
              [f_s1xHn x_s1xHo] \u [] f_s1xHn x_s1xHo;
        } in  .*._s1xHm sat_s1xHq sat_s1xHr;

Data.Function.& :: forall a b. a -> (a -> b) -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1xHs f_s1xHt] f_s1xHt x_s1xHs;

Data.Function.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Function.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Function.$trModule4];

Data.Function.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Function"#;

Data.Function.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Function.$trModule2];

Data.Function.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Function.$trModule3
                                     Data.Function.$trModule1];


==================== STG syntax: ====================
2018-03-16 15:56:19.532306908 UTC

Data.Function.fix :: forall a. (a -> a) -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_s1xHk]
        let {
          x_s1xHl [Occ=LoopBreaker] :: a_a1xF3
          [LclId] =
              [f_s1xHk x_s1xHl] \u [] f_s1xHk x_s1xHl;
        } in  x_s1xHl;

Data.Function.on
  :: forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,C(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [.*._s1xHm f_s1xHn x_s1xHo y_s1xHp]
        let {
          sat_s1xHr [Occ=Once] :: b_a1xEZ
          [LclId] =
              [f_s1xHn y_s1xHp] \u [] f_s1xHn y_s1xHp; } in
        let {
          sat_s1xHq [Occ=Once] :: b_a1xEZ
          [LclId] =
              [f_s1xHn x_s1xHo] \u [] f_s1xHn x_s1xHo;
        } in  .*._s1xHm sat_s1xHq sat_s1xHr;

Data.Function.& :: forall a b. a -> (a -> b) -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1xHs f_s1xHt] f_s1xHt x_s1xHs;

Data.Function.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Function.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Function.$trModule4];

Data.Function.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Function"#;

Data.Function.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Function.$trModule2];

Data.Function.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Function.$trModule3
                                     Data.Function.$trModule1];

