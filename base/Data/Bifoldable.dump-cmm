
==================== Output Cmm ====================
2018-03-16 16:08:58.60383952 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:58.604938478 UTC

[section ""data" . Data.Bifoldable.bifold_closure" {
     Data.Bifoldable.bifold_closure:
         const Data.Bifoldable.bifold_info;
 },
 Data.Bifoldable.bifold_entry() //  [R2]
         { info_tbl: [(cdLl1,
                       label: Data.Bifoldable.bifold_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLl1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLl2; else goto cdLl3;
       cdLl2: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifold_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLl3: // global
           I64[Sp - 8] = block_cdLkY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udLl7; else goto cdLkZ;
       udLl7: // global
           call _cdLkY(R1) args: 0, res: 0, upd: 0;
       cdLkZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLkY() //  [R1]
         { info_tbl: [(cdLkY,
                       label: block_cdLkY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLkY: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.606299505 UTC

[section ""data" . Data.Bifoldable.bifoldMap_closure" {
     Data.Bifoldable.bifoldMap_closure:
         const Data.Bifoldable.bifoldMap_info;
 },
 Data.Bifoldable.bifoldMap_entry() //  [R2]
         { info_tbl: [(cdLlf,
                       label: Data.Bifoldable.bifoldMap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLlf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLlg; else goto cdLlh;
       cdLlg: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldMap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLlh: // global
           I64[Sp - 8] = block_cdLlc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udLll; else goto cdLld;
       udLll: // global
           call _cdLlc(R1) args: 0, res: 0, upd: 0;
       cdLld: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLlc() //  [R1]
         { info_tbl: [(cdLlc,
                       label: block_cdLlc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLlc: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.607635008 UTC

[section ""data" . Data.Bifoldable.bifoldr_closure" {
     Data.Bifoldable.bifoldr_closure:
         const Data.Bifoldable.bifoldr_info;
 },
 Data.Bifoldable.bifoldr_entry() //  [R2]
         { info_tbl: [(cdLlt,
                       label: Data.Bifoldable.bifoldr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLlt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLlu; else goto cdLlv;
       cdLlu: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLlv: // global
           I64[Sp - 8] = block_cdLlq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udLlz; else goto cdLlr;
       udLlz: // global
           call _cdLlq(R1) args: 0, res: 0, upd: 0;
       cdLlr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLlq() //  [R1]
         { info_tbl: [(cdLlq,
                       label: block_cdLlq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLlq: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.60898577 UTC

[section ""data" . Data.Bifoldable.bifoldl_closure" {
     Data.Bifoldable.bifoldl_closure:
         const Data.Bifoldable.bifoldl_info;
 },
 Data.Bifoldable.bifoldl_entry() //  [R2]
         { info_tbl: [(cdLlH,
                       label: Data.Bifoldable.bifoldl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLlH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLlI; else goto cdLlJ;
       cdLlI: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLlJ: // global
           I64[Sp - 8] = block_cdLlE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udLlN; else goto cdLlF;
       udLlN: // global
           call _cdLlE(R1) args: 0, res: 0, upd: 0;
       cdLlF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLlE() //  [R1]
         { info_tbl: [(cdLlE,
                       label: block_cdLlE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLlE: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.610775519 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_info;
 },
 sat_sdL9v_entry() //  [R1]
         { info_tbl: [(cdLlX,
                       label: sat_sdL9v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLlX: // global
           _sdL9v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLlY; else goto cdLlZ;
       cdLlZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLm1; else goto cdLm0;
       cdLm1: // global
           HpAlloc = 24;
           goto cdLlY;
       cdLlY: // global
           R1 = _sdL9v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLm0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9v::P64;
           _sdL9k::P64 = P64[_sdL9v::P64 + 16];
           _sdL9l::P64 = P64[_sdL9v::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdL9l::P64;
           R2 = Hp - 16;
           R1 = _sdL9k::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdL9q_entry() //  [R1]
         { info_tbl: [(cdLm7,
                       label: sat_sdL9q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLm7: // global
           _sdL9q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLm8; else goto cdLm9;
       cdLm9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLmb; else goto cdLma;
       cdLmb: // global
           HpAlloc = 24;
           goto cdLm8;
       cdLm8: // global
           R1 = _sdL9q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLma: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9q::P64;
           _sdL9j::P64 = P64[_sdL9q::P64 + 16];
           _sdL9l::P64 = P64[_sdL9q::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdL9l::P64;
           R2 = Hp - 16;
           R1 = _sdL9j::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdLmc,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLmc: // global
           _sdL9l::P64 = R5;
           _sdL9k::P64 = R4;
           _sdL9j::P64 = R3;
           _sdL9i::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLmd; else goto cdLme;
       cdLme: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLmg; else goto cdLmf;
       cdLmg: // global
           HpAlloc = 64;
           goto cdLmd;
       cdLmd: // global
           R5 = _sdL9l::P64;
           R4 = _sdL9k::P64;
           R3 = _sdL9j::P64;
           R2 = _sdL9i::P64;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLmf: // global
           I64[Hp - 56] = sat_sdL9v_info;
           P64[Hp - 40] = _sdL9k::P64;
           P64[Hp - 32] = _sdL9l::P64;
           I64[Hp - 24] = sat_sdL9q_info;
           P64[Hp - 8] = _sdL9j::P64;
           P64[Hp] = _sdL9l::P64;
           R2 = _sdL9i::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.613032917 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldMap_entry() //  [R3, R5]
         { info_tbl: [(cdLml,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLml: // global
           R2 = R5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.614115477 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldMap_entry() //  [R3, R5]
         { info_tbl: [(cdLms,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLms: // global
           R2 = R5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.617131617 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_info;
 },
 sat_sdL9T_entry() //  [R1]
         { info_tbl: [(cdLmE,
                       label: sat_sdL9T_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLmE: // global
           _sdL9T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLmF; else goto cdLmG;
       cdLmG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLmI; else goto cdLmH;
       cdLmI: // global
           HpAlloc = 24;
           goto cdLmF;
       cdLmF: // global
           R1 = _sdL9T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLmH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9T::P64;
           _sdL9G::P64 = P64[_sdL9T::P64 + 16];
           _sdL9H::P64 = P64[_sdL9T::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdL9H::P64;
           R2 = Hp - 16;
           R1 = _sdL9G::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdL9N_entry() //  [R1]
         { info_tbl: [(cdLmO,
                       label: sat_sdL9N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLmO: // global
           _sdL9N::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLmP; else goto cdLmQ;
       cdLmQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLmS; else goto cdLmR;
       cdLmS: // global
           HpAlloc = 24;
           goto cdLmP;
       cdLmP: // global
           R1 = _sdL9N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLmR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9N::P64;
           _sdL9F::P64 = P64[_sdL9N::P64 + 16];
           _sdL9H::P64 = P64[_sdL9N::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdL9H::P64;
           R2 = Hp - 16;
           R1 = _sdL9F::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdLmT,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLmT: // global
           _sdL9H::P64 = R5;
           _sdL9G::P64 = R4;
           _sdL9F::P64 = R3;
           _sdL9E::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLmU; else goto cdLmV;
       cdLmV: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLmX; else goto cdLmW;
       cdLmX: // global
           HpAlloc = 64;
           goto cdLmU;
       cdLmU: // global
           R5 = _sdL9H::P64;
           R4 = _sdL9G::P64;
           R3 = _sdL9F::P64;
           R2 = _sdL9E::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLmW: // global
           I64[Hp - 56] = sat_sdL9T_info;
           P64[Hp - 40] = _sdL9G::P64;
           P64[Hp - 32] = _sdL9H::P64;
           I64[Hp - 24] = sat_sdL9N_info;
           P64[Hp - 8] = _sdL9F::P64;
           P64[Hp] = _sdL9H::P64;
           R2 = _sdL9E::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.619542954 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_info;
 },
 sat_sdLab_entry() //  [R1]
         { info_tbl: [(cdLn7,
                       label: sat_sdLab_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLn7: // global
           _sdLab::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLn8; else goto cdLn9;
       cdLn9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLnb; else goto cdLna;
       cdLnb: // global
           HpAlloc = 24;
           goto cdLn8;
       cdLn8: // global
           R1 = _sdLab::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLna: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLab::P64;
           _sdL9W::P64 = P64[_sdLab::P64 + 16];
           _sdL9X::P64 = P64[_sdLab::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdL9X::P64;
           R2 = Hp - 16;
           R1 = _sdL9W::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLa4_entry() //  [R1]
         { info_tbl: [(cdLnh,
                       label: sat_sdLa4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLnh: // global
           _sdLa4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLni; else goto cdLnj;
       cdLnj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLnl; else goto cdLnk;
       cdLnl: // global
           HpAlloc = 24;
           goto cdLni;
       cdLni: // global
           R1 = _sdLa4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLnk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLa4::P64;
           _sdL9V::P64 = P64[_sdLa4::P64 + 16];
           _sdL9X::P64 = P64[_sdLa4::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdL9X::P64;
           R2 = Hp - 16;
           R1 = _sdL9V::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdLnm,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLnm: // global
           _sdL9X::P64 = R5;
           _sdL9W::P64 = R4;
           _sdL9V::P64 = R3;
           _sdL9U::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLnn; else goto cdLno;
       cdLno: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLnq; else goto cdLnp;
       cdLnq: // global
           HpAlloc = 64;
           goto cdLnn;
       cdLnn: // global
           R5 = _sdL9X::P64;
           R4 = _sdL9W::P64;
           R3 = _sdL9V::P64;
           R2 = _sdL9U::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLnp: // global
           I64[Hp - 56] = sat_sdLab_info;
           P64[Hp - 40] = _sdL9W::P64;
           P64[Hp - 32] = _sdL9X::P64;
           I64[Hp - 24] = sat_sdLa4_info;
           P64[Hp - 8] = _sdL9V::P64;
           P64[Hp] = _sdL9X::P64;
           R2 = _sdL9U::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.621944352 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_info;
 },
 sat_sdLav_entry() //  [R1]
         { info_tbl: [(cdLnA,
                       label: sat_sdLav_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLnA: // global
           _sdLav::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLnB; else goto cdLnC;
       cdLnC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLnE; else goto cdLnD;
       cdLnE: // global
           HpAlloc = 24;
           goto cdLnB;
       cdLnB: // global
           R1 = _sdLav::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLnD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLav::P64;
           _sdLae::P64 = P64[_sdLav::P64 + 16];
           _sdLaf::P64 = P64[_sdLav::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLaf::P64;
           R2 = Hp - 16;
           R1 = _sdLae::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLan_entry() //  [R1]
         { info_tbl: [(cdLnK,
                       label: sat_sdLan_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLnK: // global
           _sdLan::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLnL; else goto cdLnM;
       cdLnM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLnO; else goto cdLnN;
       cdLnO: // global
           HpAlloc = 24;
           goto cdLnL;
       cdLnL: // global
           R1 = _sdLan::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLnN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLan::P64;
           _sdLad::P64 = P64[_sdLan::P64 + 16];
           _sdLaf::P64 = P64[_sdLan::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLaf::P64;
           R2 = Hp - 16;
           R1 = _sdLad::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdLnP,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLnP: // global
           _sdLaf::P64 = R5;
           _sdLae::P64 = R4;
           _sdLad::P64 = R3;
           _sdLac::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLnQ; else goto cdLnR;
       cdLnR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLnT; else goto cdLnS;
       cdLnT: // global
           HpAlloc = 64;
           goto cdLnQ;
       cdLnQ: // global
           R5 = _sdLaf::P64;
           R4 = _sdLae::P64;
           R3 = _sdLad::P64;
           R2 = _sdLac::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLnS: // global
           I64[Hp - 56] = sat_sdLav_info;
           P64[Hp - 40] = _sdLae::P64;
           P64[Hp - 32] = _sdLaf::P64;
           I64[Hp - 24] = sat_sdLan_info;
           P64[Hp - 8] = _sdLad::P64;
           P64[Hp] = _sdLaf::P64;
           R2 = _sdLac::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.624302516 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_info;
 },
 sat_sdLaR_entry() //  [R1]
         { info_tbl: [(cdLo3,
                       label: sat_sdLaR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLo3: // global
           _sdLaR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLo4; else goto cdLo5;
       cdLo5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLo7; else goto cdLo6;
       cdLo7: // global
           HpAlloc = 24;
           goto cdLo4;
       cdLo4: // global
           R1 = _sdLaR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLo6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLaR::P64;
           _sdLay::P64 = P64[_sdLaR::P64 + 16];
           _sdLaz::P64 = P64[_sdLaR::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLaz::P64;
           R2 = Hp - 16;
           R1 = _sdLay::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLaI_entry() //  [R1]
         { info_tbl: [(cdLod,
                       label: sat_sdLaI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLod: // global
           _sdLaI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLoe; else goto cdLof;
       cdLof: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLoh; else goto cdLog;
       cdLoh: // global
           HpAlloc = 24;
           goto cdLoe;
       cdLoe: // global
           R1 = _sdLaI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLog: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLaI::P64;
           _sdLax::P64 = P64[_sdLaI::P64 + 16];
           _sdLaz::P64 = P64[_sdLaI::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLaz::P64;
           R2 = Hp - 16;
           R1 = _sdLax::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdLoi,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLoi: // global
           _sdLaz::P64 = R5;
           _sdLay::P64 = R4;
           _sdLax::P64 = R3;
           _sdLaw::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLoj; else goto cdLok;
       cdLok: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLom; else goto cdLol;
       cdLom: // global
           HpAlloc = 64;
           goto cdLoj;
       cdLoj: // global
           R5 = _sdLaz::P64;
           R4 = _sdLay::P64;
           R3 = _sdLax::P64;
           R2 = _sdLaw::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLol: // global
           I64[Hp - 56] = sat_sdLaR_info;
           P64[Hp - 40] = _sdLay::P64;
           P64[Hp - 32] = _sdLaz::P64;
           I64[Hp - 24] = sat_sdLaI_info;
           P64[Hp - 8] = _sdLax::P64;
           P64[Hp] = _sdLaz::P64;
           R2 = _sdLaw::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.626719408 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_info;
 },
 sat_sdLbf_entry() //  [R1]
         { info_tbl: [(cdLow,
                       label: sat_sdLbf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLow: // global
           _sdLbf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLox; else goto cdLoy;
       cdLoy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLoA; else goto cdLoz;
       cdLoA: // global
           HpAlloc = 24;
           goto cdLox;
       cdLox: // global
           R1 = _sdLbf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLoz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLbf::P64;
           _sdLaU::P64 = P64[_sdLbf::P64 + 16];
           _sdLaV::P64 = P64[_sdLbf::P64 + 24];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdLaV::P64;
           R2 = Hp - 16;
           R1 = _sdLaU::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLb5_entry() //  [R1]
         { info_tbl: [(cdLoG,
                       label: sat_sdLb5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLoG: // global
           _sdLb5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLoH; else goto cdLoI;
       cdLoI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLoK; else goto cdLoJ;
       cdLoK: // global
           HpAlloc = 24;
           goto cdLoH;
       cdLoH: // global
           R1 = _sdLb5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLoJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLb5::P64;
           _sdLaT::P64 = P64[_sdLb5::P64 + 16];
           _sdLaV::P64 = P64[_sdLb5::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLaV::P64;
           R2 = Hp - 16;
           R1 = _sdLaT::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_entry() //  [R2,
                                                               R3, R4, R5]
         { info_tbl: [(cdLoL,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLoL: // global
           _sdLaV::P64 = R5;
           _sdLaU::P64 = R4;
           _sdLaT::P64 = R3;
           _sdLaS::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLoM; else goto cdLoN;
       cdLoN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLoP; else goto cdLoO;
       cdLoP: // global
           HpAlloc = 64;
           goto cdLoM;
       cdLoM: // global
           R5 = _sdLaV::P64;
           R4 = _sdLaU::P64;
           R3 = _sdLaT::P64;
           R2 = _sdLaS::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLoO: // global
           I64[Hp - 56] = sat_sdLbf_info;
           P64[Hp - 40] = _sdLaU::P64;
           P64[Hp - 32] = _sdLaV::P64;
           I64[Hp - 24] = sat_sdLb5_info;
           P64[Hp - 8] = _sdLaT::P64;
           P64[Hp] = _sdLaV::P64;
           R2 = _sdLaS::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.628895251 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldMap_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdLp1,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLp1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdLp2; else goto cdLp3;
       cdLp2: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLp3: // global
           I64[Sp - 24] = block_cdLoU_info;
           R1 = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udLpa; else goto cdLoV;
       udLpa: // global
           call _cdLoU(R1) args: 0, res: 0, upd: 0;
       cdLoV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLoU() //  [R1]
         { info_tbl: [(cdLoU,
                       label: block_cdLoU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLoU: // global
           if (R1 & 7 == 1) goto cdLoY; else goto cdLoZ;
       cdLoY: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdLoZ: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.630582278 UTC

[section ""data" . poly_$dMonoid_rdL8r_closure" {
     poly_$dMonoid_rdL8r_closure:
         const poly_$dMonoid_rdL8r_info;
         const 0;
         const 0;
         const 0;
 },
 poly_$dMonoid_rdL8r_entry() //  [R1]
         { info_tbl: [(cdLph,
                       label: poly_$dMonoid_rdL8r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLph: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLpi; else goto cdLpj;
       cdLpi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLpj: // global
           (_cdLpe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdLpe::I64 == 0) goto cdLpg; else goto cdLpf;
       cdLpg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdLpf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdLpe::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.632050601 UTC

[section ""data" . Data.Bifoldable.$dmbifoldl_closure" {
     Data.Bifoldable.$dmbifoldl_closure:
         const Data.Bifoldable.$dmbifoldl_info;
         const 0;
 },
 sat_sdLbx_entry() //  [R1, R2, R3]
         { info_tbl: [(cdLpu,
                       label: sat_sdLbx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLpu: // global
           _sdLbw::P64 = R3;
           R3 = R2;
           R2 = _sdLbw::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLbu_entry() //  [R1, R2, R3]
         { info_tbl: [(cdLpC,
                       label: sat_sdLbu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLpC: // global
           _sdLbt::P64 = R3;
           R3 = R2;
           R2 = _sdLbt::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.$dmbifoldl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLpF,
                       label: Data.Bifoldable.$dmbifoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLpF: // global
           _sdLbr::P64 = R6;
           _sdLbq::P64 = R5;
           _sdLbp::P64 = R4;
           _sdLbo::P64 = R3;
           _sdLbn::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLpG; else goto cdLpH;
       cdLpH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLpJ; else goto cdLpI;
       cdLpJ: // global
           HpAlloc = 32;
           goto cdLpG;
       cdLpG: // global
           R6 = _sdLbr::P64;
           R5 = _sdLbq::P64;
           R4 = _sdLbp::P64;
           R3 = _sdLbo::P64;
           R2 = _sdLbn::P64;
           R1 = Data.Bifoldable.$dmbifoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLpI: // global
           I64[Hp - 24] = sat_sdLbx_info;
           P64[Hp - 16] = _sdLbp::P64;
           I64[Hp - 8] = sat_sdLbu_info;
           P64[Hp] = _sdLbo::P64;
           R2 = _sdLbn::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = poly_$dMonoid_rdL8r_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdLbr::P64;
           P64[Sp - 8] = _sdLbq::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.634221147 UTC

[section ""data" . Data.Bifoldable.$dmbifoldr_closure" {
     Data.Bifoldable.$dmbifoldr_closure:
         const Data.Bifoldable.$dmbifoldr_info;
         const 0;
 },
 Data.Bifoldable.$dmbifoldr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLpO,
                       label: Data.Bifoldable.$dmbifoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLpO: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdLpP; else goto cdLpQ;
       cdLpP: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$dmbifoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLpQ: // global
           R2 = R2;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R6;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.635988881 UTC

[section ""data" . Data.Bifoldable.$dmbifoldMap_closure" {
     Data.Bifoldable.$dmbifoldMap_closure:
         const Data.Bifoldable.$dmbifoldMap_info;
 },
 sat_sdLbN_entry() //  [R1]
         { info_tbl: [(cdLpZ,
                       label: sat_sdLbN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLpZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLq0; else goto cdLq1;
       cdLq0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLq1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLbM_entry() //  [R1, R2]
         { info_tbl: [(cdLq8,
                       label: sat_sdLbM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLq8: // global
           _sdLbK::P64 = R2;
           _sdLbM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLq9; else goto cdLqa;
       cdLqa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLqc; else goto cdLqb;
       cdLqc: // global
           HpAlloc = 32;
           goto cdLq9;
       cdLq9: // global
           R2 = _sdLbK::P64;
           R1 = _sdLbM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLqb: // global
           _sdLbE::P64 = P64[_sdLbM::P64 + 7];
           _sdLbG::P64 = P64[_sdLbM::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLbG::P64;
           P64[Hp] = _sdLbK::P64;
           R2 = _sdLbE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdLbJ_entry() //  [R1, R2]
         { info_tbl: [(cdLqj,
                       label: sat_sdLbJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLqj: // global
           _sdLbH::P64 = R2;
           _sdLbJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLqk; else goto cdLql;
       cdLql: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLqn; else goto cdLqm;
       cdLqn: // global
           HpAlloc = 32;
           goto cdLqk;
       cdLqk: // global
           R2 = _sdLbH::P64;
           R1 = _sdLbJ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLqm: // global
           _sdLbE::P64 = P64[_sdLbJ::P64 + 7];
           _sdLbF::P64 = P64[_sdLbJ::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLbF::P64;
           P64[Hp] = _sdLbH::P64;
           R2 = _sdLbE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.$dmbifoldMap_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdLqo,
                       label: Data.Bifoldable.$dmbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLqo: // global
           _sdLbG::P64 = R5;
           _sdLbF::P64 = R4;
           _sdLbE::P64 = R3;
           _sdLbD::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdLqp; else goto cdLqq;
       cdLqq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdLqs; else goto cdLqr;
       cdLqs: // global
           HpAlloc = 72;
           goto cdLqp;
       cdLqp: // global
           R5 = _sdLbG::P64;
           R4 = _sdLbF::P64;
           R3 = _sdLbE::P64;
           R2 = _sdLbD::P64;
           R1 = Data.Bifoldable.$dmbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLqr: // global
           I64[Hp - 64] = sat_sdLbN_info;
           P64[Hp - 48] = _sdLbE::P64;
           I64[Hp - 40] = sat_sdLbM_info;
           P64[Hp - 32] = _sdLbE::P64;
           P64[Hp - 24] = _sdLbG::P64;
           I64[Hp - 16] = sat_sdLbJ_info;
           P64[Hp - 8] = _sdLbE::P64;
           P64[Hp] = _sdLbF::P64;
           R2 = _sdLbD::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 15;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.638255452 UTC

[section ""data" . Data.Bifoldable.$dmbifold_closure" {
     Data.Bifoldable.$dmbifold_closure:
         const Data.Bifoldable.$dmbifold_info;
 },
 Data.Bifoldable.$dmbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLqx,
                       label: Data.Bifoldable.$dmbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLqx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLqy; else goto cdLqz;
       cdLqy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$dmbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLqz: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.639441845 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifold_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifold_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLqL,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLqL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLqM; else goto cdLqN;
       cdLqM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLqN: // global
           I64[Sp - 8] = block_cdLqE_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udLqU; else goto cdLqF;
       udLqU: // global
           call _cdLqE(R1) args: 0, res: 0, upd: 0;
       cdLqF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLqE() //  [R1]
         { info_tbl: [(cdLqE,
                       label: block_cdLqE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLqE: // global
           if (R1 & 7 == 1) goto cdLqI; else goto cdLqJ;
       cdLqI: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdLqJ: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.64081828 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldr_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdLr6,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLr6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLr7; else goto cdLr8;
       cdLr7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLr8: // global
           I64[Sp - 32] = block_cdLqZ_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udLrf; else goto cdLr0;
       udLrf: // global
           call _cdLqZ(R1) args: 0, res: 0, upd: 0;
       cdLr0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLqZ() //  [R1]
         { info_tbl: [(cdLqZ,
                       label: block_cdLqZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLqZ: // global
           _sdLbX::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdLr3; else goto cdLr4;
       cdLr3: // global
           R3 = _sdLbX::P64;
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLr4: // global
           R3 = _sdLbX::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.642389758 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldl_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdLrr,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLrr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLrs; else goto cdLrt;
       cdLrs: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLrt: // global
           I64[Sp - 32] = block_cdLrk_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udLrA; else goto cdLrl;
       udLrA: // global
           call _cdLrk(R1) args: 0, res: 0, upd: 0;
       cdLrl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLrk() //  [R1]
         { info_tbl: [(cdLrk,
                       label: block_cdLrk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLrk: // global
           _sdLc4::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdLro; else goto cdLrp;
       cdLro: // global
           R3 = P64[R1 + 7];
           R2 = _sdLc4::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLrp: // global
           R3 = P64[R1 + 6];
           R2 = _sdLc4::P64;
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.643572294 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_closure" {
     Data.Bifoldable.$fBifoldableEither_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableEither_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.644462814 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLrH,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLrH: // global
           _sdLca::P64 = R3;
           _sdLc9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLrI; else goto cdLrJ;
       cdLrJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLrL; else goto cdLrK;
       cdLrL: // global
           HpAlloc = 48;
           goto cdLrI;
       cdLrI: // global
           R3 = _sdLca::P64;
           R2 = _sdLc9::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLrK: // global
           I64[Hp - 40] = stg_sel_6_upd_info;
           P64[Hp - 24] = _sdLca::P64;
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLca::P64;
           R2 = _sdLc9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.645889704 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_info;
 },
 sat_sdLcP_entry() //  [R1]
         { info_tbl: [(cdLrV,
                       label: sat_sdLcP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLrV: // global
           _sdLcP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLrW; else goto cdLrX;
       cdLrX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLrZ; else goto cdLrY;
       cdLrZ: // global
           HpAlloc = 24;
           goto cdLrW;
       cdLrW: // global
           R1 = _sdLcP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLrY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLcP::P64;
           _sdLcu::P64 = P64[_sdLcP::P64 + 16];
           _sdLcv::P64 = P64[_sdLcP::P64 + 24];
           _sdLcw::P64 = P64[_sdLcP::P64 + 32];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdLcw::P64;
           R3 = _sdLcv::P64;
           R2 = Hp - 16;
           R1 = _sdLcu::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdLs1,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLs1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLs5; else goto cdLs4;
       cdLs5: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLs4: // global
           I64[Hp - 56] = sat_sdLcP_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLct::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLct::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.647629957 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_info;
 },
 sat_sdLd3_entry() //  [R1]
         { info_tbl: [(cdLsg,
                       label: sat_sdLd3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLsg: // global
           _sdLd3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLsh; else goto cdLsi;
       cdLsi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLsk; else goto cdLsj;
       cdLsk: // global
           HpAlloc = 24;
           goto cdLsh;
       cdLsh: // global
           R1 = _sdLd3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLsj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLd3::P64;
           _sdLcQ::P64 = P64[_sdLd3::P64 + 16];
           _sdLcS::P64 = P64[_sdLd3::P64 + 24];
           _sdLcT::P64 = P64[_sdLd3::P64 + 32];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLcT::P64;
           R3 = Hp - 16;
           R2 = _sdLcS::P64;
           R1 = _sdLcQ::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdLsl,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLsl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLsp; else goto cdLso;
       cdLsp: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLso: // global
           I64[Hp - 56] = stg_sel_6_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLd3_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLcR::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLcR::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.648979737 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.649957123 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLsw,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLsw: // global
           _sdLde::P64 = R3;
           _sdLdd::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLsx; else goto cdLsy;
       cdLsy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLsA; else goto cdLsz;
       cdLsA: // global
           HpAlloc = 48;
           goto cdLsx;
       cdLsx: // global
           R3 = _sdLde::P64;
           R2 = _sdLdd::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLsz: // global
           I64[Hp - 40] = stg_sel_5_upd_info;
           P64[Hp - 24] = _sdLde::P64;
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLde::P64;
           R2 = _sdLdd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.651353522 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_info;
 },
 sat_sdLdP_entry() //  [R1]
         { info_tbl: [(cdLsK,
                       label: sat_sdLdP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLsK: // global
           _sdLdP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLsL; else goto cdLsM;
       cdLsM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLsO; else goto cdLsN;
       cdLsO: // global
           HpAlloc = 24;
           goto cdLsL;
       cdLsL: // global
           R1 = _sdLdP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLsN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLdP::P64;
           _sdLdw::P64 = P64[_sdLdP::P64 + 16];
           _sdLdx::P64 = P64[_sdLdP::P64 + 24];
           _sdLdy::P64 = P64[_sdLdP::P64 + 32];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLdy::P64;
           R3 = _sdLdx::P64;
           R2 = Hp - 16;
           R1 = _sdLdw::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdLsQ,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLsQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLsU; else goto cdLsT;
       cdLsU: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLsT: // global
           I64[Hp - 56] = sat_sdLdP_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLdv::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLdv::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.653120425 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_info;
 },
 sat_sdLe2_entry() //  [R1]
         { info_tbl: [(cdLt5,
                       label: sat_sdLe2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLt5: // global
           _sdLe2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLt6; else goto cdLt7;
       cdLt7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLt9; else goto cdLt8;
       cdLt9: // global
           HpAlloc = 24;
           goto cdLt6;
       cdLt6: // global
           R1 = _sdLe2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLt8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLe2::P64;
           _sdLdQ::P64 = P64[_sdLe2::P64 + 16];
           _sdLdS::P64 = P64[_sdLe2::P64 + 24];
           _sdLdT::P64 = P64[_sdLe2::P64 + 32];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLdT::P64;
           R3 = Hp - 16;
           R2 = _sdLdS::P64;
           R1 = _sdLdQ::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdLta,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLta: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLte; else goto cdLtd;
       cdLte: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLtd: // global
           I64[Hp - 56] = stg_sel_5_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLe2_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLdR::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLdR::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.654593842 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.655480422 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLtl,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLtl: // global
           _sdLec::P64 = R3;
           _sdLeb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLtm; else goto cdLtn;
       cdLtn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLtp; else goto cdLto;
       cdLtp: // global
           HpAlloc = 48;
           goto cdLtm;
       cdLtm: // global
           R3 = _sdLec::P64;
           R2 = _sdLeb::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLto: // global
           I64[Hp - 40] = stg_sel_4_upd_info;
           P64[Hp - 24] = _sdLec::P64;
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLec::P64;
           R2 = _sdLeb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.656976388 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_info;
 },
 sat_sdLeJ_entry() //  [R1]
         { info_tbl: [(cdLtz,
                       label: sat_sdLeJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLtz: // global
           _sdLeJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLtA; else goto cdLtB;
       cdLtB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLtD; else goto cdLtC;
       cdLtD: // global
           HpAlloc = 24;
           goto cdLtA;
       cdLtA: // global
           R1 = _sdLeJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLtC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLeJ::P64;
           _sdLes::P64 = P64[_sdLeJ::P64 + 16];
           _sdLet::P64 = P64[_sdLeJ::P64 + 24];
           _sdLeu::P64 = P64[_sdLeJ::P64 + 32];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLeu::P64;
           R3 = _sdLet::P64;
           R2 = Hp - 16;
           R1 = _sdLes::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdLtF,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLtF: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLtJ; else goto cdLtI;
       cdLtJ: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLtI: // global
           I64[Hp - 56] = sat_sdLeJ_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLer::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLer::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.658812049 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_info;
 },
 sat_sdLeV_entry() //  [R1]
         { info_tbl: [(cdLtU,
                       label: sat_sdLeV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLtU: // global
           _sdLeV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLtV; else goto cdLtW;
       cdLtW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLtY; else goto cdLtX;
       cdLtY: // global
           HpAlloc = 24;
           goto cdLtV;
       cdLtV: // global
           R1 = _sdLeV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLtX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLeV::P64;
           _sdLeK::P64 = P64[_sdLeV::P64 + 16];
           _sdLeM::P64 = P64[_sdLeV::P64 + 24];
           _sdLeN::P64 = P64[_sdLeV::P64 + 32];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLeN::P64;
           R3 = Hp - 16;
           R2 = _sdLeM::P64;
           R1 = _sdLeK::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdLtZ,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLtZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLu3; else goto cdLu2;
       cdLu3: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLu2: // global
           I64[Hp - 56] = stg_sel_4_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLeV_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLeL::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLeL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.661649405 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.662552476 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLua,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLua: // global
           _sdLf4::P64 = R3;
           _sdLf3::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLub; else goto cdLuc;
       cdLuc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLue; else goto cdLud;
       cdLue: // global
           HpAlloc = 48;
           goto cdLub;
       cdLub: // global
           R3 = _sdLf4::P64;
           R2 = _sdLf3::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLud: // global
           I64[Hp - 40] = stg_sel_3_upd_info;
           P64[Hp - 24] = _sdLf4::P64;
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdLf4::P64;
           R2 = _sdLf3::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.663971604 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_info;
 },
 sat_sdLfx_entry() //  [R1]
         { info_tbl: [(cdLuo,
                       label: sat_sdLfx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLuo: // global
           _sdLfx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLup; else goto cdLuq;
       cdLuq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLus; else goto cdLur;
       cdLus: // global
           HpAlloc = 24;
           goto cdLup;
       cdLup: // global
           R1 = _sdLfx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLur: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLfx::P64;
           _sdLfi::P64 = P64[_sdLfx::P64 + 16];
           _sdLfj::P64 = P64[_sdLfx::P64 + 24];
           _sdLfk::P64 = P64[_sdLfx::P64 + 32];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLfk::P64;
           R3 = _sdLfj::P64;
           R2 = Hp - 16;
           R1 = _sdLfi::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdLuu,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLuu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLuy; else goto cdLux;
       cdLuy: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLux: // global
           I64[Hp - 56] = sat_sdLfx_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLfh::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLfh::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.66573619 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_info;
 },
 sat_sdLfI_entry() //  [R1]
         { info_tbl: [(cdLuJ,
                       label: sat_sdLfI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLuJ: // global
           _sdLfI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLuK; else goto cdLuL;
       cdLuL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLuN; else goto cdLuM;
       cdLuN: // global
           HpAlloc = 24;
           goto cdLuK;
       cdLuK: // global
           R1 = _sdLfI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLuM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLfI::P64;
           _sdLfy::P64 = P64[_sdLfI::P64 + 16];
           _sdLfA::P64 = P64[_sdLfI::P64 + 24];
           _sdLfB::P64 = P64[_sdLfI::P64 + 32];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdLfB::P64;
           R3 = Hp - 16;
           R2 = _sdLfA::P64;
           R1 = _sdLfy::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdLuO,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLuO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLuS; else goto cdLuR;
       cdLuS: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLuR: // global
           I64[Hp - 56] = stg_sel_3_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLfI_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLfz::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLfz::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.667050714 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.667875682 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLuZ,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLuZ: // global
           _sdLfQ::P64 = R3;
           _sdLfP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLv0; else goto cdLv1;
       cdLv1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLv3; else goto cdLv2;
       cdLv3: // global
           HpAlloc = 48;
           goto cdLv0;
       cdLv0: // global
           R3 = _sdLfQ::P64;
           R2 = _sdLfP::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLv2: // global
           I64[Hp - 40] = stg_sel_2_upd_info;
           P64[Hp - 24] = _sdLfQ::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdLfQ::P64;
           R2 = _sdLfP::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.6692824 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_info;
 },
 sat_sdLgf_entry() //  [R1]
         { info_tbl: [(cdLvd,
                       label: sat_sdLgf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLvd: // global
           _sdLgf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLve; else goto cdLvf;
       cdLvf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLvh; else goto cdLvg;
       cdLvh: // global
           HpAlloc = 24;
           goto cdLve;
       cdLve: // global
           R1 = _sdLgf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLvg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLgf::P64;
           _sdLg2::P64 = P64[_sdLgf::P64 + 16];
           _sdLg3::P64 = P64[_sdLgf::P64 + 24];
           _sdLg4::P64 = P64[_sdLgf::P64 + 32];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdLg4::P64;
           R3 = _sdLg3::P64;
           R2 = Hp - 16;
           R1 = _sdLg2::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdLvj,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLvj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLvn; else goto cdLvm;
       cdLvn: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLvm: // global
           I64[Hp - 56] = sat_sdLgf_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLg1::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLg1::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.670972219 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_info;
 },
 sat_sdLgp_entry() //  [R1]
         { info_tbl: [(cdLvy,
                       label: sat_sdLgp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLvy: // global
           _sdLgp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLvz; else goto cdLvA;
       cdLvA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLvC; else goto cdLvB;
       cdLvC: // global
           HpAlloc = 24;
           goto cdLvz;
       cdLvz: // global
           R1 = _sdLgp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLvB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLgp::P64;
           _sdLgg::P64 = P64[_sdLgp::P64 + 16];
           _sdLgi::P64 = P64[_sdLgp::P64 + 24];
           _sdLgj::P64 = P64[_sdLgp::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdLgj::P64;
           R3 = Hp - 16;
           R2 = _sdLgi::P64;
           R1 = _sdLgg::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdLvD,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLvD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLvH; else goto cdLvG;
       cdLvH: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLvG: // global
           I64[Hp - 56] = stg_sel_2_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLgp_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLgh::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLgh::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.672311567 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.673072091 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK2_closure" {
     Data.Bifoldable.$fBifoldableK2_closure:
         const Data.Bifoldable.$fBifoldableK2_info;
 },
 Data.Bifoldable.$fBifoldableK2_entry() //  [R3]
         { info_tbl: [(cdLvM,
                       label: Data.Bifoldable.$fBifoldableK2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLvM: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.673953954 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldr_entry() //  [R2, R4, R5]
         { info_tbl: [(cdLvT,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLvT: // global
           R3 = R4;
           _sdLgx::P64 = R2;
           R2 = R5;
           R1 = _sdLgx::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.674803409 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldl_entry() //  [R2, R4, R5]
         { info_tbl: [(cdLw0,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLw0: // global
           R3 = R5;
           _sdLgB::P64 = R2;
           R2 = R4;
           R1 = _sdLgB::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.675587749 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_closure" {
     Data.Bifoldable.$fBifoldableK1_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableK2_closure+2;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.676349818 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst1_closure" {
     Data.Bifoldable.$fBifoldableConst1_closure:
         const Data.Bifoldable.$fBifoldableConst1_info;
 },
 Data.Bifoldable.$fBifoldableConst1_entry() //  [R3]
         { info_tbl: [(cdLw7,
                       label: Data.Bifoldable.$fBifoldableConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLw7: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.677197605 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldr_entry() //  [R2, R4,
                                                          R5]
         { info_tbl: [(cdLwe,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLwe: // global
           R3 = R4;
           _sdLgH::P64 = R2;
           R2 = R5;
           R1 = _sdLgH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.678130018 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldl_entry() //  [R2, R4,
                                                          R5]
         { info_tbl: [(cdLwl,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLwl: // global
           R3 = R5;
           _sdLgL::P64 = R2;
           R2 = R4;
           R1 = _sdLgL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.678882068 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_closure" {
     Data.Bifoldable.$fBifoldableConst_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableConst1_closure+2;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.679681776 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLwu,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLwu: // global
           _sdLgQ::P64 = R3;
           _sdLgP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLwv; else goto cdLww;
       cdLww: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLwy; else goto cdLwx;
       cdLwy: // global
           HpAlloc = 48;
           goto cdLwv;
       cdLwv: // global
           R3 = _sdLgQ::P64;
           R2 = _sdLgP::P64;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLwx: // global
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sdLgQ::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdLgQ::P64;
           R2 = _sdLgP::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.681031574 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldr_info;
 },
 sat_sdLhb_entry() //  [R1]
         { info_tbl: [(cdLwI,
                       label: sat_sdLhb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLwI: // global
           _sdLhb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLwJ; else goto cdLwK;
       cdLwK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLwM; else goto cdLwL;
       cdLwM: // global
           HpAlloc = 24;
           goto cdLwJ;
       cdLwJ: // global
           R1 = _sdLhb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLwL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLhb::P64;
           _sdLh0::P64 = P64[_sdLhb::P64 + 16];
           _sdLh1::P64 = P64[_sdLhb::P64 + 24];
           _sdLh2::P64 = P64[_sdLhb::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdLh2::P64;
           R3 = _sdLh1::P64;
           R2 = Hp - 16;
           R1 = _sdLh0::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldr_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdLwO,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLwO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLwS; else goto cdLwR;
       cdLwS: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLwR: // global
           I64[Hp - 56] = sat_sdLhb_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLgZ::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLgZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.683069916 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldl_info;
 },
 sat_sdLhk_entry() //  [R1]
         { info_tbl: [(cdLx3,
                       label: sat_sdLhk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLx3: // global
           _sdLhk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLx4; else goto cdLx5;
       cdLx5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLx7; else goto cdLx6;
       cdLx7: // global
           HpAlloc = 24;
           goto cdLx4;
       cdLx4: // global
           R1 = _sdLhk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLx6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLhk::P64;
           _sdLhc::P64 = P64[_sdLhk::P64 + 16];
           _sdLhe::P64 = P64[_sdLhk::P64 + 24];
           _sdLhf::P64 = P64[_sdLhk::P64 + 32];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdLhf::P64;
           R3 = Hp - 16;
           R2 = _sdLhe::P64;
           R1 = _sdLhc::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldl_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdLx8,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLx8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLxc; else goto cdLxb;
       cdLxc: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLxb: // global
           I64[Hp - 56] = stg_sel_1_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLhk_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLhd::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLhd::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.68441314 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_closure" {
     Data.Bifoldable.$fBifoldable(,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.685652194 UTC

[section ""data" . Data.Bifoldable.bifoldr'_closure" {
     Data.Bifoldable.bifoldr'_closure:
         const Data.Bifoldable.bifoldr'_info;
 },
 sat_sdLhD_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdLxo,
                       label: sat_sdLhD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLxo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLxp; else goto cdLxq;
       cdLxp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLxq: // global
           I64[Sp - 16] = block_cdLxm_info;
           _sdLhA::P64 = R3;
           R3 = R4;
           _sdLhz::P64 = R2;
           R2 = _sdLhA::P64;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLhz::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLxm() //  [R1]
         { info_tbl: [(cdLxm,
                       label: block_cdLxm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLxm: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLhy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdLxz,
                       label: sat_sdLhy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLxz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLxA; else goto cdLxB;
       cdLxA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLxB: // global
           I64[Sp - 16] = block_cdLxx_info;
           _sdLhv::P64 = R3;
           R3 = R4;
           _sdLhu::P64 = R2;
           R2 = _sdLhv::P64;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLhu::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLxx() //  [R1]
         { info_tbl: [(cdLxx,
                       label: block_cdLxx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLxx: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldr'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLxD,
                       label: Data.Bifoldable.bifoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLxD: // global
           _sdLht::P64 = R6;
           _sdLhs::P64 = R5;
           _sdLhr::P64 = R4;
           _sdLhq::P64 = R3;
           _sdLhp::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLxE; else goto cdLxF;
       cdLxF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLxH; else goto cdLxG;
       cdLxH: // global
           HpAlloc = 32;
           goto cdLxE;
       cdLxE: // global
           R6 = _sdLht::P64;
           R5 = _sdLhs::P64;
           R4 = _sdLhr::P64;
           R3 = _sdLhq::P64;
           R2 = _sdLhp::P64;
           R1 = Data.Bifoldable.bifoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLxG: // global
           I64[Hp - 24] = sat_sdLhD_info;
           P64[Hp - 16] = _sdLhr::P64;
           I64[Hp - 8] = sat_sdLhy_info;
           P64[Hp] = _sdLhq::P64;
           R2 = _sdLhp::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Hp - 5;
           P64[Sp - 32] = Hp - 21;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = _sdLht::P64;
           P64[Sp - 8] = _sdLhs::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldl_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.687547457 UTC

[section ""cstring" . lvl_rdL8s_bytes" {
     lvl_rdL8s_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.68828966 UTC

[section ""data" . lvl1_rdL8t_closure" {
     lvl1_rdL8t_closure:
         const lvl1_rdL8t_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rdL8t_entry() //  [R1]
         { info_tbl: [(cdLxO,
                       label: lvl1_rdL8t_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLxO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLxP; else goto cdLxQ;
       cdLxP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLxQ: // global
           (_cdLxL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdLxL::I64 == 0) goto cdLxN; else goto cdLxM;
       cdLxN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdLxM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdLxL::I64;
           R2 = lvl_rdL8s_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.689195317 UTC

[section ""cstring" . Data.Bifoldable.$trModule4_bytes" {
     Data.Bifoldable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.689995568 UTC

[section ""data" . lvl2_rdL8u_closure" {
     lvl2_rdL8u_closure:
         const lvl2_rdL8u_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdL8u_entry() //  [R1]
         { info_tbl: [(cdLxX,
                       label: lvl2_rdL8u_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLxX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLxY; else goto cdLxZ;
       cdLxY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLxZ: // global
           (_cdLxU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdLxU::I64 == 0) goto cdLxW; else goto cdLxV;
       cdLxW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdLxV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdLxU::I64;
           R2 = Data.Bifoldable.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.69088126 UTC

[section ""cstring" . Data.Bifoldable.$trModule2_bytes" {
     Data.Bifoldable.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,102,111,108,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.691622804 UTC

[section ""data" . lvl3_rdL8v_closure" {
     lvl3_rdL8v_closure:
         const lvl3_rdL8v_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdL8v_entry() //  [R1]
         { info_tbl: [(cdLy6,
                       label: lvl3_rdL8v_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLy6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLy7; else goto cdLy8;
       cdLy7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLy8: // global
           (_cdLy3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdLy3::I64 == 0) goto cdLy5; else goto cdLy4;
       cdLy5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdLy4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdLy3::I64;
           R2 = Data.Bifoldable.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.692494665 UTC

[section ""cstring" . lvl4_rdL8w_bytes" {
     lvl4_rdL8w_bytes:
         I8[] [46,47,68,97,116,97,47,66,105,102,111,108,100,97,98,108,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.69318302 UTC

[section ""data" . lvl5_rdL8x_closure" {
     lvl5_rdL8x_closure:
         const lvl5_rdL8x_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rdL8x_entry() //  [R1]
         { info_tbl: [(cdLyf,
                       label: lvl5_rdL8x_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLyf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLyg; else goto cdLyh;
       cdLyg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLyh: // global
           (_cdLyc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdLyc::I64 == 0) goto cdLye; else goto cdLyd;
       cdLye: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdLyd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdLyc::I64;
           R2 = lvl4_rdL8w_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.694112617 UTC

[section ""data" . lvl6_rdL8y_closure" {
     lvl6_rdL8y_closure:
         const GHC.Types.I#_con_info;
         const 188;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.694757433 UTC

[section ""data" . lvl7_rdL8z_closure" {
     lvl7_rdL8z_closure:
         const GHC.Types.I#_con_info;
         const 28;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.695397262 UTC

[section ""data" . lvl8_rdL8A_closure" {
     lvl8_rdL8A_closure:
         const GHC.Types.I#_con_info;
         const 61;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.696001837 UTC

[section ""data" . lvl9_rdL8B_closure" {
     lvl9_rdL8B_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl6_rdL8y_closure+1;
         const lvl7_rdL8z_closure+1;
         const lvl6_rdL8y_closure+1;
         const lvl8_rdL8A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.696615295 UTC

[section ""data" . lvl10_rdL8C_closure" {
     lvl10_rdL8C_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl9_rdL8B_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.697265557 UTC

[section ""cstring" . lvl11_rdL8D_bytes" {
     lvl11_rdL8D_bytes:
         I8[] [98,105,102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.698087383 UTC

[section ""data" . Data.Bifoldable.bifoldr2_closure" {
     Data.Bifoldable.bifoldr2_closure:
         const Data.Bifoldable.bifoldr2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bifoldr2_entry() //  [R1]
         { info_tbl: [(cdLyq,
                       label: Data.Bifoldable.bifoldr2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLyq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdLyr; else goto cdLys;
       cdLyr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLys: // global
           (_cdLyl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdLyl::I64 == 0) goto cdLyn; else goto cdLym;
       cdLyn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdLym: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdLyl::I64;
           I64[Sp - 24] = block_cdLyo_info;
           R2 = lvl11_rdL8D_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdLyo() //  [R1]
         { info_tbl: [(cdLyo,
                       label: block_cdLyo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLyo: // global
           R3 = R1;
           R2 = lvl10_rdL8C_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.700088753 UTC

[section ""data" . Data.Bifoldable.bifoldr1_closure" {
     Data.Bifoldable.bifoldr1_closure:
         const Data.Bifoldable.bifoldr1_info;
         const 0;
 },
 sat_sdLhN_entry() //  [R1]
         { info_tbl: [(cdLyQ,
                       label: sat_sdLhN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLyQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdLyR; else goto cdLyS;
       cdLyR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLyS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdLyJ_info;
           _sdLhG::P64 = P64[R1 + 16];
           _sdLhJ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdLhG::P64;
           P64[Sp - 24] = _sdLhJ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udLyZ; else goto cdLyK;
       udLyZ: // global
           call _cdLyJ(R1) args: 0, res: 0, upd: 0;
       cdLyK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdLyJ() //  [R1]
         { info_tbl: [(cdLyJ,
                       label: block_cdLyJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLyJ: // global
           _sdLhJ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdLyN; else goto cdLyO;
       cdLyN: // global
           R1 = _sdLhJ::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cdLyO: // global
           R3 = P64[R1 + 6];
           R2 = _sdLhJ::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLhI_entry() //  [R1, R2, R3]
         { info_tbl: [(cdLz1,
                       label: mbf_sdLhI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLz1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLz5; else goto cdLz4;
       cdLz5: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLz4: // global
           _sdLhG::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLhN_info;
           P64[Hp - 32] = _sdLhG::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldr1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLzc,
                       label: Data.Bifoldable.bifoldr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLzc: // global
           _sdLhH::P64 = R4;
           _sdLhG::P64 = R3;
           _sdLhF::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLzd; else goto cdLze;
       cdLze: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdLzg; else goto cdLzf;
       cdLzg: // global
           HpAlloc = 16;
           goto cdLzd;
       cdLzd: // global
           R4 = _sdLhH::P64;
           R3 = _sdLhG::P64;
           R2 = _sdLhF::P64;
           R1 = Data.Bifoldable.bifoldr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLzf: // global
           I64[Hp - 8] = mbf_sdLhI_info;
           P64[Hp] = _sdLhG::P64;
           I64[Sp - 8] = block_cdLz6_info;
           R2 = _sdLhF::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdLyA::P64 = Hp - 6;
           P64[Sp - 40] = _cdLyA::P64;
           P64[Sp - 32] = _cdLyA::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLhH::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdLz6() //  [R1]
         { info_tbl: [(cdLz6,
                       label: block_cdLz6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLz6: // global
           if (R1 & 7 == 1) goto cdLz9; else goto cdLza;
       cdLz9: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdLza: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.704433645 UTC

[section ""data" . Data.Bifoldable.bimaximumBy_closure" {
     Data.Bifoldable.bimaximumBy_closure:
         const Data.Bifoldable.bimaximumBy_info;
         const 0;
 },
 sat_sdLhZ_entry() //  [R1]
         { info_tbl: [(cdLzH,
                       label: sat_sdLhZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLzH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdLzI; else goto cdLzJ;
       cdLzI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLzJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdLzA_info;
           _sdLhR::P64 = P64[R1 + 16];
           _sdLhU::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdLhR::P64;
           P64[Sp - 24] = _sdLhU::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udLA5; else goto cdLzB;
       udLA5: // global
           call _cdLzA(R1) args: 0, res: 0, upd: 0;
       cdLzB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdLzA() //  [R1]
         { info_tbl: [(cdLzA,
                       label: block_cdLzA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLzA: // global
           if (R1 & 7 == 1) goto udLA2; else goto cdLzF;
       udLA2: // global
           Sp = Sp + 16;
           call _cdLA0() args: 0, res: 0, upd: 0;
       cdLzF: // global
           I64[Sp] = block_cdLzP_info;
           _sdLhX::P64 = P64[R1 + 6];
           R3 = _sdLhX::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdLhX::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdLzP() //  [R1]
         { info_tbl: [(cdLzP,
                       label: block_cdLzP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLzP: // global
           if (R1 & 7 == 3) goto udLA3; else goto cdLzW;
       udLA3: // global
           Sp = Sp + 16;
           call _cdLA0() args: 0, res: 0, upd: 0;
       cdLzW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cdLA0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLA0: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLhT_entry() //  [R1, R2, R3]
         { info_tbl: [(cdLA8,
                       label: mbf_sdLhT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLA8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLAc; else goto cdLAb;
       cdLAc: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLAb: // global
           _sdLhR::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLhZ_info;
           P64[Hp - 32] = _sdLhR::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bimaximumBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLAj,
                       label: Data.Bifoldable.bimaximumBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLAj: // global
           _sdLhS::P64 = R4;
           _sdLhR::P64 = R3;
           _sdLhQ::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLAk; else goto cdLAl;
       cdLAl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdLAn; else goto cdLAm;
       cdLAn: // global
           HpAlloc = 16;
           goto cdLAk;
       cdLAk: // global
           R4 = _sdLhS::P64;
           R3 = _sdLhR::P64;
           R2 = _sdLhQ::P64;
           R1 = Data.Bifoldable.bimaximumBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLAm: // global
           I64[Hp - 8] = mbf_sdLhT_info;
           P64[Hp] = _sdLhR::P64;
           I64[Sp - 8] = block_cdLAd_info;
           R2 = _sdLhQ::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdLzr::P64 = Hp - 6;
           P64[Sp - 40] = _cdLzr::P64;
           P64[Sp - 32] = _cdLzr::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLhS::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdLAd() //  [R1]
         { info_tbl: [(cdLAd,
                       label: block_cdLAd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLAd: // global
           if (R1 & 7 == 1) goto cdLAg; else goto cdLAh;
       cdLAg: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdLAh: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.71102303 UTC

[section ""data" . Data.Bifoldable.biminimumBy_closure" {
     Data.Bifoldable.biminimumBy_closure:
         const Data.Bifoldable.biminimumBy_info;
         const 0;
 },
 sat_sdLib_entry() //  [R1]
         { info_tbl: [(cdLAO,
                       label: sat_sdLib_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLAO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdLAP; else goto cdLAQ;
       cdLAP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLAQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdLAH_info;
           _sdLi3::P64 = P64[R1 + 16];
           _sdLi6::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdLi3::P64;
           P64[Sp - 24] = _sdLi6::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udLBc; else goto cdLAI;
       udLBc: // global
           call _cdLAH(R1) args: 0, res: 0, upd: 0;
       cdLAI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdLAH() //  [R1]
         { info_tbl: [(cdLAH,
                       label: block_cdLAH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLAH: // global
           if (R1 & 7 == 1) goto udLB9; else goto cdLAM;
       udLB9: // global
           Sp = Sp + 16;
           call _cdLB3() args: 0, res: 0, upd: 0;
       cdLAM: // global
           I64[Sp] = block_cdLAW_info;
           _sdLi9::P64 = P64[R1 + 6];
           R3 = _sdLi9::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdLi9::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdLAW() //  [R1]
         { info_tbl: [(cdLAW,
                       label: block_cdLAW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLAW: // global
           if (R1 & 7 == 3) goto cdLB7; else goto udLBa;
       cdLB7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       udLBa: // global
           Sp = Sp + 16;
           call _cdLB3() args: 0, res: 0, upd: 0;
     }
 },
 _cdLB3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLB3: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLi5_entry() //  [R1, R2, R3]
         { info_tbl: [(cdLBf,
                       label: mbf_sdLi5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLBf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLBj; else goto cdLBi;
       cdLBj: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLBi: // global
           _sdLi3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLib_info;
           P64[Hp - 32] = _sdLi3::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biminimumBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLBq,
                       label: Data.Bifoldable.biminimumBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLBq: // global
           _sdLi4::P64 = R4;
           _sdLi3::P64 = R3;
           _sdLi2::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLBr; else goto cdLBs;
       cdLBs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdLBu; else goto cdLBt;
       cdLBu: // global
           HpAlloc = 16;
           goto cdLBr;
       cdLBr: // global
           R4 = _sdLi4::P64;
           R3 = _sdLi3::P64;
           R2 = _sdLi2::P64;
           R1 = Data.Bifoldable.biminimumBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLBt: // global
           I64[Hp - 8] = mbf_sdLi5_info;
           P64[Hp] = _sdLi3::P64;
           I64[Sp - 8] = block_cdLBk_info;
           R2 = _sdLi2::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdLAy::P64 = Hp - 6;
           P64[Sp - 40] = _cdLAy::P64;
           P64[Sp - 32] = _cdLAy::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLi4::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdLBk() //  [R1]
         { info_tbl: [(cdLBk,
                       label: block_cdLBk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLBk: // global
           if (R1 & 7 == 1) goto cdLBn; else goto cdLBo;
       cdLBn: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdLBo: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.714110657 UTC

[section ""data" . Data.Bifoldable.bifoldrM_closure" {
     Data.Bifoldable.bifoldrM_closure:
         const Data.Bifoldable.bifoldrM_info;
 },
 sat_sdLiu_entry() //  [R1]
         { info_tbl: [(cdLBJ,
                       label: sat_sdLiu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLBJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLBK; else goto cdLBL;
       cdLBK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLBL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLit_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdLBS,
                       label: sat_sdLit_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLBS: // global
           _sdLir::P64 = R4;
           _sdLiq::P64 = R3;
           _sdLip::P64 = R2;
           _sdLit::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLBT; else goto cdLBU;
       cdLBU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdLBW; else goto cdLBV;
       cdLBW: // global
           HpAlloc = 40;
           goto cdLBT;
       cdLBT: // global
           R4 = _sdLir::P64;
           R3 = _sdLiq::P64;
           R2 = _sdLip::P64;
           R1 = _sdLit::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLBV: // global
           _sdLif::P64 = P64[_sdLit::P64 + 5];
           _sdLih::P64 = P64[_sdLit::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLih::P64;
           P64[Hp - 8] = _sdLiq::P64;
           P64[Hp] = _sdLir::P64;
           R2 = _sdLif::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLip::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdLio_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdLC3,
                       label: sat_sdLio_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLC3: // global
           _sdLim::P64 = R4;
           _sdLil::P64 = R3;
           _sdLik::P64 = R2;
           _sdLio::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLC4; else goto cdLC5;
       cdLC5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdLC7; else goto cdLC6;
       cdLC7: // global
           HpAlloc = 40;
           goto cdLC4;
       cdLC4: // global
           R4 = _sdLim::P64;
           R3 = _sdLil::P64;
           R2 = _sdLik::P64;
           R1 = _sdLio::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLC6: // global
           _sdLif::P64 = P64[_sdLio::P64 + 5];
           _sdLig::P64 = P64[_sdLio::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLig::P64;
           P64[Hp - 8] = _sdLil::P64;
           P64[Hp] = _sdLim::P64;
           R2 = _sdLif::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLik::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldrM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLC8,
                       label: Data.Bifoldable.bifoldrM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLC8: // global
           _sdLii::P64 = R6;
           _sdLih::P64 = R5;
           _sdLig::P64 = R4;
           _sdLif::P64 = R3;
           _sdLie::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdLC9; else goto cdLCa;
       cdLCa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdLCc; else goto cdLCb;
       cdLCc: // global
           HpAlloc = 72;
           goto cdLC9;
       cdLC9: // global
           R6 = _sdLii::P64;
           R5 = _sdLih::P64;
           R4 = _sdLig::P64;
           R3 = _sdLif::P64;
           R2 = _sdLie::P64;
           R1 = Data.Bifoldable.bifoldrM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdLCb: // global
           I64[Hp - 64] = sat_sdLiu_info;
           P64[Hp - 48] = _sdLif::P64;
           I64[Hp - 40] = sat_sdLit_info;
           P64[Hp - 32] = _sdLif::P64;
           P64[Hp - 24] = _sdLih::P64;
           I64[Hp - 16] = sat_sdLio_info;
           P64[Hp - 8] = _sdLif::P64;
           P64[Hp] = _sdLig::P64;
           R2 = _sdLie::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = Hp - 37;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = _sdLii::P64;
           Sp = Sp - 40;
           call Data.Bifoldable.bifoldl_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.716907054 UTC

[section ""data" . Data.Bifoldable.bifoldl'_closure" {
     Data.Bifoldable.bifoldl'_closure:
         const Data.Bifoldable.bifoldl'_info;
 },
 sat_sdLiJ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdLCo,
                       label: sat_sdLiJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLCo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLCp; else goto cdLCq;
       cdLCp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLCq: // global
           I64[Sp - 16] = block_cdLCm_info;
           _sdLiG::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLiG::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLCm() //  [R1]
         { info_tbl: [(cdLCm,
                       label: block_cdLCm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLCm: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLiE_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdLCz,
                       label: sat_sdLiE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLCz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLCA; else goto cdLCB;
       cdLCA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLCB: // global
           I64[Sp - 16] = block_cdLCx_info;
           _sdLiB::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLiB::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLCx() //  [R1]
         { info_tbl: [(cdLCx,
                       label: block_cdLCx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLCx: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldl'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLCD,
                       label: Data.Bifoldable.bifoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLCD: // global
           _sdLiz::P64 = R6;
           _sdLiy::P64 = R5;
           _sdLix::P64 = R4;
           _sdLiw::P64 = R3;
           _sdLiv::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLCE; else goto cdLCF;
       cdLCF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLCH; else goto cdLCG;
       cdLCH: // global
           HpAlloc = 32;
           goto cdLCE;
       cdLCE: // global
           R6 = _sdLiz::P64;
           R5 = _sdLiy::P64;
           R4 = _sdLix::P64;
           R3 = _sdLiw::P64;
           R2 = _sdLiv::P64;
           R1 = Data.Bifoldable.bifoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLCG: // global
           I64[Hp - 24] = sat_sdLiJ_info;
           P64[Hp - 16] = _sdLix::P64;
           I64[Hp - 8] = sat_sdLiE_info;
           P64[Hp] = _sdLiw::P64;
           R2 = _sdLiv::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Hp - 5;
           P64[Sp - 32] = Hp - 21;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = _sdLiz::P64;
           P64[Sp - 8] = _sdLiy::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.719239254 UTC

[section ""data" . Data.Bifoldable.bilength2_closure" {
     Data.Bifoldable.bilength2_closure:
         const Data.Bifoldable.bilength2_info;
 },
 Data.Bifoldable.bilength2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLCP,
                       label: Data.Bifoldable.bilength2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLCP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLCW; else goto cdLCX;
       cdLCW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bilength2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLCX: // global
           I64[Sp - 16] = block_cdLCM_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udLD1; else goto cdLCN;
       udLD1: // global
           call _cdLCM(R1) args: 0, res: 0, upd: 0;
       cdLCN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLCM() //  [R1]
         { info_tbl: [(cdLCM,
                       label: block_cdLCM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLCM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdLD0; else goto cdLCZ;
       cdLD0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdLCZ: // global
           _sdLiP::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdLiP::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.720463111 UTC

[section ""data" . Data.Bifoldable.bilength1_closure" {
     Data.Bifoldable.bilength1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.721741505 UTC

[section ""data" . Data.Bifoldable.bilength_closure" {
     Data.Bifoldable.bilength_closure:
         const Data.Bifoldable.bilength_info;
 },
 Data.Bifoldable.bilength_entry() //  [R2, R3]
         { info_tbl: [(cdLD6,
                       label: Data.Bifoldable.bilength_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLD6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdLD7; else goto cdLD8;
       cdLD7: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bilength_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLD8: // global
           R2 = R2;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Bifoldable.bilength2_closure+3;
           P64[Sp - 32] = Data.Bifoldable.bilength2_closure+3;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Data.Bifoldable.bilength1_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.722668618 UTC

[section ""data" . lvl12_rdL8E_closure" {
     lvl12_rdL8E_closure:
         const GHC.Types.I#_con_info;
         const 223;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.72325421 UTC

[section ""data" . lvl13_rdL8F_closure" {
     lvl13_rdL8F_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl12_rdL8E_closure+1;
         const lvl7_rdL8z_closure+1;
         const lvl12_rdL8E_closure+1;
         const lvl8_rdL8A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.72391921 UTC

[section ""data" . lvl14_rdL8G_closure" {
     lvl14_rdL8G_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl13_rdL8F_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.724538539 UTC

[section ""cstring" . lvl15_rdL8H_bytes" {
     lvl15_rdL8H_bytes:
         I8[] [98,105,102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.725535668 UTC

[section ""data" . Data.Bifoldable.bifoldl2_closure" {
     Data.Bifoldable.bifoldl2_closure:
         const Data.Bifoldable.bifoldl2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bifoldl2_entry() //  [R1]
         { info_tbl: [(cdLDh,
                       label: Data.Bifoldable.bifoldl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLDh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdLDi; else goto cdLDj;
       cdLDi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLDj: // global
           (_cdLDc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdLDc::I64 == 0) goto cdLDe; else goto cdLDd;
       cdLDe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdLDd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdLDc::I64;
           I64[Sp - 24] = block_cdLDf_info;
           R2 = lvl15_rdL8H_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdLDf() //  [R1]
         { info_tbl: [(cdLDf,
                       label: block_cdLDf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLDf: // global
           R3 = R1;
           R2 = lvl14_rdL8G_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.727488209 UTC

[section ""data" . Data.Bifoldable.bifoldl1_closure" {
     Data.Bifoldable.bifoldl1_closure:
         const Data.Bifoldable.bifoldl1_info;
         const 0;
 },
 sat_sdLj2_entry() //  [R1]
         { info_tbl: [(cdLDH,
                       label: sat_sdLj2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLDH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdLDI; else goto cdLDJ;
       cdLDI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLDJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdLDA_info;
           _sdLiV::P64 = P64[R1 + 16];
           _sdLiZ::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdLiV::P64;
           P64[Sp - 24] = _sdLiZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udLDQ; else goto cdLDB;
       udLDQ: // global
           call _cdLDA(R1) args: 0, res: 0, upd: 0;
       cdLDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdLDA() //  [R1]
         { info_tbl: [(cdLDA,
                       label: block_cdLDA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLDA: // global
           _sdLiZ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdLDE; else goto cdLDF;
       cdLDE: // global
           R1 = _sdLiZ::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cdLDF: // global
           R3 = _sdLiZ::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLiX_entry() //  [R1, R2, R3]
         { info_tbl: [(cdLDS,
                       label: mbf_sdLiX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLDS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLDW; else goto cdLDV;
       cdLDW: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLDV: // global
           _sdLiV::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLj2_info;
           P64[Hp - 32] = _sdLiV::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldl1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLE3,
                       label: Data.Bifoldable.bifoldl1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLE3: // global
           _sdLiW::P64 = R4;
           _sdLiV::P64 = R3;
           _sdLiU::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLE4; else goto cdLE5;
       cdLE5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdLE7; else goto cdLE6;
       cdLE7: // global
           HpAlloc = 16;
           goto cdLE4;
       cdLE4: // global
           R4 = _sdLiW::P64;
           R3 = _sdLiV::P64;
           R2 = _sdLiU::P64;
           R1 = Data.Bifoldable.bifoldl1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLE6: // global
           I64[Hp - 8] = mbf_sdLiX_info;
           P64[Hp] = _sdLiV::P64;
           I64[Sp - 8] = block_cdLDX_info;
           R2 = _sdLiU::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdLDr::P64 = Hp - 6;
           P64[Sp - 40] = _cdLDr::P64;
           P64[Sp - 32] = _cdLDr::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLiW::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldl_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdLDX() //  [R1]
         { info_tbl: [(cdLDX,
                       label: block_cdLDX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLDX: // global
           if (R1 & 7 == 1) goto cdLE0; else goto cdLE1;
       cdLE0: // global
           R1 = Data.Bifoldable.bifoldl2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdLE1: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.730427857 UTC

[section ""data" . Data.Bifoldable.bifoldlM_closure" {
     Data.Bifoldable.bifoldlM_closure:
         const Data.Bifoldable.bifoldlM_info;
 },
 sat_sdLjl_entry() //  [R1]
         { info_tbl: [(cdLEm,
                       label: sat_sdLjl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLEm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLEn; else goto cdLEo;
       cdLEn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLEo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdLEv,
                       label: sat_sdLjk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLEv: // global
           _sdLji::P64 = R4;
           _sdLjh::P64 = R3;
           _sdLjg::P64 = R2;
           _sdLjk::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLEw; else goto cdLEx;
       cdLEx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdLEz; else goto cdLEy;
       cdLEz: // global
           HpAlloc = 40;
           goto cdLEw;
       cdLEw: // global
           R4 = _sdLji::P64;
           R3 = _sdLjh::P64;
           R2 = _sdLjg::P64;
           R1 = _sdLjk::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLEy: // global
           _sdLj6::P64 = P64[_sdLjk::P64 + 5];
           _sdLj8::P64 = P64[_sdLjk::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLj8::P64;
           P64[Hp - 8] = _sdLji::P64;
           P64[Hp] = _sdLjg::P64;
           R2 = _sdLj6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLjh::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdLjf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdLEG,
                       label: sat_sdLjf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLEG: // global
           _sdLjd::P64 = R4;
           _sdLjc::P64 = R3;
           _sdLjb::P64 = R2;
           _sdLjf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLEH; else goto cdLEI;
       cdLEI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdLEK; else goto cdLEJ;
       cdLEK: // global
           HpAlloc = 40;
           goto cdLEH;
       cdLEH: // global
           R4 = _sdLjd::P64;
           R3 = _sdLjc::P64;
           R2 = _sdLjb::P64;
           R1 = _sdLjf::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLEJ: // global
           _sdLj6::P64 = P64[_sdLjf::P64 + 5];
           _sdLj7::P64 = P64[_sdLjf::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLj7::P64;
           P64[Hp - 8] = _sdLjd::P64;
           P64[Hp] = _sdLjb::P64;
           R2 = _sdLj6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLjc::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldlM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLEL,
                       label: Data.Bifoldable.bifoldlM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLEL: // global
           _sdLj9::P64 = R6;
           _sdLj8::P64 = R5;
           _sdLj7::P64 = R4;
           _sdLj6::P64 = R3;
           _sdLj5::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdLEM; else goto cdLEN;
       cdLEN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdLEP; else goto cdLEO;
       cdLEP: // global
           HpAlloc = 72;
           goto cdLEM;
       cdLEM: // global
           R6 = _sdLj9::P64;
           R5 = _sdLj8::P64;
           R4 = _sdLj7::P64;
           R3 = _sdLj6::P64;
           R2 = _sdLj5::P64;
           R1 = Data.Bifoldable.bifoldlM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdLEO: // global
           I64[Hp - 64] = sat_sdLjl_info;
           P64[Hp - 48] = _sdLj6::P64;
           I64[Hp - 40] = sat_sdLjk_info;
           P64[Hp - 32] = _sdLj6::P64;
           P64[Hp - 24] = _sdLj8::P64;
           I64[Hp - 16] = sat_sdLjf_info;
           P64[Hp - 8] = _sdLj6::P64;
           P64[Hp] = _sdLj7::P64;
           R2 = _sdLj5::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = Hp - 37;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = _sdLj9::P64;
           Sp = Sp - 40;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.733474328 UTC

[section ""data" . Data.Bifoldable.bitraverse__closure" {
     Data.Bifoldable.bitraverse__closure:
         const Data.Bifoldable.bitraverse__info;
 },
 sat_sdLjw_entry() //  [R1]
         { info_tbl: [(cdLEY,
                       label: sat_sdLjw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLEY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLEZ; else goto cdLF0;
       cdLEZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLF0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sdLjv_entry() //  [R1, R2]
         { info_tbl: [(cdLF7,
                       label: sat_sdLjv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLF7: // global
           _sdLjt::P64 = R2;
           _sdLjv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLF8; else goto cdLF9;
       cdLF9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLFb; else goto cdLFa;
       cdLFb: // global
           HpAlloc = 32;
           goto cdLF8;
       cdLF8: // global
           R2 = _sdLjt::P64;
           R1 = _sdLjv::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLFa: // global
           _sdLjn::P64 = P64[_sdLjv::P64 + 7];
           _sdLjp::P64 = P64[_sdLjv::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLjp::P64;
           P64[Hp] = _sdLjt::P64;
           R2 = _sdLjn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdLjs_entry() //  [R1, R2]
         { info_tbl: [(cdLFi,
                       label: sat_sdLjs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLFi: // global
           _sdLjq::P64 = R2;
           _sdLjs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLFj; else goto cdLFk;
       cdLFk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLFm; else goto cdLFl;
       cdLFm: // global
           HpAlloc = 32;
           goto cdLFj;
       cdLFj: // global
           R2 = _sdLjq::P64;
           R1 = _sdLjs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLFl: // global
           _sdLjn::P64 = P64[_sdLjs::P64 + 7];
           _sdLjo::P64 = P64[_sdLjs::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLjo::P64;
           P64[Hp] = _sdLjq::P64;
           R2 = _sdLjn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bitraverse__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdLFn,
                       label: Data.Bifoldable.bitraverse__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLFn: // global
           _sdLjp::P64 = R5;
           _sdLjo::P64 = R4;
           _sdLjn::P64 = R3;
           _sdLjm::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdLFo; else goto cdLFp;
       cdLFp: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdLFr; else goto cdLFq;
       cdLFr: // global
           HpAlloc = 72;
           goto cdLFo;
       cdLFo: // global
           R5 = _sdLjp::P64;
           R4 = _sdLjo::P64;
           R3 = _sdLjn::P64;
           R2 = _sdLjm::P64;
           R1 = Data.Bifoldable.bitraverse__closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLFq: // global
           I64[Hp - 64] = sat_sdLjw_info;
           P64[Hp - 48] = _sdLjn::P64;
           I64[Hp - 40] = sat_sdLjv_info;
           P64[Hp - 32] = _sdLjn::P64;
           P64[Hp - 24] = _sdLjp::P64;
           I64[Hp - 16] = sat_sdLjs_info;
           P64[Hp - 8] = _sdLjn::P64;
           P64[Hp] = _sdLjo::P64;
           R2 = _sdLjm::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 15;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.735671301 UTC

[section ""data" . Data.Bifoldable.bifor__closure" {
     Data.Bifoldable.bifor__closure:
         const Data.Bifoldable.bifor__info;
 },
 Data.Bifoldable.bifor__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLFw,
                       label: Data.Bifoldable.bifor__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLFw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLFx; else goto cdLFy;
       cdLFx: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bifor__closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLFy: // global
           _sdLjA::P64 = R5;
           R5 = R6;
           _sdLjz::P64 = R4;
           R4 = _sdLjA::P64;
           R3 = R3;
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sdLjz::P64;
           Sp = Sp - 16;
           call Data.Bifoldable.bitraverse__entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.736739892 UTC

[section ""data" . Data.Bifoldable.biforM__closure" {
     Data.Bifoldable.biforM__closure:
         const Data.Bifoldable.biforM__info;
 },
 Data.Bifoldable.biforM__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLFD,
                       label: Data.Bifoldable.biforM__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLFD: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bifor__entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.737673092 UTC

[section ""data" . Data.Bifoldable.bimapM__closure" {
     Data.Bifoldable.bimapM__closure:
         const Data.Bifoldable.bimapM__info;
 },
 Data.Bifoldable.bimapM__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdLFK,
                       label: Data.Bifoldable.bimapM__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLFK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bitraverse__entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.738972578 UTC

[section ""data" . Data.Bifoldable.bisequence__closure" {
     Data.Bifoldable.bisequence__closure:
         const Data.Bifoldable.bisequence__info;
 },
 sat_sdLjG_entry() //  [R1]
         { info_tbl: [(cdLFV,
                       label: sat_sdLjG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLFV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLFW; else goto cdLFX;
       cdLFW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLFX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sdLjF_entry() //  [R1]
         { info_tbl: [(cdLG2,
                       label: sat_sdLjF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLG2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLG3; else goto cdLG4;
       cdLG3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLG4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjE_entry() //  [R1]
         { info_tbl: [(cdLG9,
                       label: sat_sdLjE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLG9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLGa; else goto cdLGb;
       cdLGa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLGb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.bisequence__entry() //  [R2, R3]
         { info_tbl: [(cdLGc,
                       label: Data.Bifoldable.bisequence__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLGc: // global
           _sdLjD::P64 = R3;
           _sdLjC::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdLGd; else goto cdLGe;
       cdLGe: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdLGg; else goto cdLGf;
       cdLGg: // global
           HpAlloc = 72;
           goto cdLGd;
       cdLGd: // global
           R3 = _sdLjD::P64;
           R2 = _sdLjC::P64;
           R1 = Data.Bifoldable.bisequence__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLGf: // global
           I64[Hp - 64] = sat_sdLjG_info;
           P64[Hp - 48] = _sdLjD::P64;
           I64[Hp - 40] = sat_sdLjF_info;
           P64[Hp - 24] = _sdLjD::P64;
           I64[Hp - 16] = sat_sdLjE_info;
           P64[Hp] = _sdLjD::P64;
           R2 = _sdLjC::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.740949601 UTC

[section ""data" . Data.Bifoldable.bisequenceA__closure" {
     Data.Bifoldable.bisequenceA__closure:
         const Data.Bifoldable.bisequenceA__info;
 },
 Data.Bifoldable.bisequenceA__entry() //  [R2, R3]
         { info_tbl: [(cdLGl,
                       label: Data.Bifoldable.bisequenceA__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLGl: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bisequence__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.742305344 UTC

[section ""data" . Data.Bifoldable.biasum_closure" {
     Data.Bifoldable.biasum_closure:
         const Data.Bifoldable.biasum_info;
 },
 sat_sdLjL_entry() //  [R1]
         { info_tbl: [(cdLGw,
                       label: sat_sdLjL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLGw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLGx; else goto cdLGy;
       cdLGx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLGy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjK_entry() //  [R1]
         { info_tbl: [(cdLGD,
                       label: sat_sdLjK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLGD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLGE; else goto cdLGF;
       cdLGE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjJ_entry() //  [R1]
         { info_tbl: [(cdLGK,
                       label: sat_sdLjJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLGK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLGL; else goto cdLGM;
       cdLGL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLGM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.biasum_entry() //  [R2, R3]
         { info_tbl: [(cdLGN,
                       label: Data.Bifoldable.biasum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLGN: // global
           _sdLjI::P64 = R3;
           _sdLjH::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdLGO; else goto cdLGP;
       cdLGP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdLGR; else goto cdLGQ;
       cdLGR: // global
           HpAlloc = 72;
           goto cdLGO;
       cdLGO: // global
           R3 = _sdLjI::P64;
           R2 = _sdLjH::P64;
           R1 = Data.Bifoldable.biasum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLGQ: // global
           I64[Hp - 64] = sat_sdLjL_info;
           P64[Hp - 48] = _sdLjI::P64;
           I64[Hp - 40] = sat_sdLjK_info;
           P64[Hp - 24] = _sdLjI::P64;
           I64[Hp - 16] = sat_sdLjJ_info;
           P64[Hp] = _sdLjI::P64;
           R2 = _sdLjH::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.744150636 UTC

[section ""data" . Data.Bifoldable.bimsum_closure" {
     Data.Bifoldable.bimsum_closure:
         const Data.Bifoldable.bimsum_info;
 },
 Data.Bifoldable.bimsum_entry() //  [R2, R3]
         { info_tbl: [(cdLGW,
                       label: Data.Bifoldable.bimsum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLGW: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biasum_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.745053214 UTC

[section ""data" . Data.Bifoldable.biList_closure" {
     Data.Bifoldable.biList_closure:
         const Data.Bifoldable.biList_info;
 },
 Data.Bifoldable.biList_entry() //  [R2]
         { info_tbl: [(cdLH3,
                       label: Data.Bifoldable.biList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLH3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLH4; else goto cdLH5;
       cdLH4: // global
           R2 = R2;
           R1 = Data.Bifoldable.biList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLH5: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = GHC.Types.:_closure+2;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.746105491 UTC

[section ""data" . Data.Bifoldable.binull1_closure" {
     Data.Bifoldable.binull1_closure:
         const Data.Bifoldable.binull1_info;
 },
 Data.Bifoldable.binull1_entry() //  []
         { info_tbl: [(cdLHa,
                       label: Data.Bifoldable.binull1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLHa: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.748430202 UTC

[section ""data" . Data.Bifoldable.binull_closure" {
     Data.Bifoldable.binull_closure:
         const Data.Bifoldable.binull_info;
 },
 Data.Bifoldable.binull_entry() //  [R2]
         { info_tbl: [(cdLHh,
                       label: Data.Bifoldable.binull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLHh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLHi; else goto cdLHj;
       cdLHi: // global
           R2 = R2;
           R1 = Data.Bifoldable.binull_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLHj: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Bifoldable.binull1_closure+2;
           P64[Sp - 16] = Data.Bifoldable.binull1_closure+2;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.749614613 UTC

[section ""data" . Data.Bifoldable.biconcat_closure" {
     Data.Bifoldable.biconcat_closure:
         const Data.Bifoldable.biconcat_info;
         const 0;
 },
 Data.Bifoldable.biconcat_entry() //  [R2]
         { info_tbl: [(cdLHo,
                       label: Data.Bifoldable.biconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLHo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLHp; else goto cdLHq;
       cdLHp: // global
           R2 = R2;
           R1 = Data.Bifoldable.biconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLHq: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.$fMonoid[]_closure;
           Sp = Sp - 16;
           call Data.Bifoldable.bifold_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.750448068 UTC

[section ""data" . lvl16_rdL8I_closure" {
     lvl16_rdL8I_closure:
         const GHC.Types.I#_con_info;
         const 334;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.750978304 UTC

[section ""data" . lvl17_rdL8J_closure" {
     lvl17_rdL8J_closure:
         const GHC.Types.I#_con_info;
         const 24;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.751497988 UTC

[section ""data" . lvl18_rdL8K_closure" {
     lvl18_rdL8K_closure:
         const GHC.Types.I#_con_info;
         const 58;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.752053786 UTC

[section ""data" . lvl19_rdL8L_closure" {
     lvl19_rdL8L_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl16_rdL8I_closure+1;
         const lvl17_rdL8J_closure+1;
         const lvl16_rdL8I_closure+1;
         const lvl18_rdL8K_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.752673139 UTC

[section ""data" . lvl20_rdL8M_closure" {
     lvl20_rdL8M_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl19_rdL8L_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.753279967 UTC

[section ""cstring" . lvl21_rdL8N_bytes" {
     lvl21_rdL8N_bytes:
         I8[] [98,105,109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.754090247 UTC

[section ""data" . Data.Bifoldable.bimaximum1_closure" {
     Data.Bifoldable.bimaximum1_closure:
         const Data.Bifoldable.bimaximum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bimaximum1_entry() //  [R1]
         { info_tbl: [(cdLHz,
                       label: Data.Bifoldable.bimaximum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLHz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdLHA; else goto cdLHB;
       cdLHA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLHB: // global
           (_cdLHu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdLHu::I64 == 0) goto cdLHw; else goto cdLHv;
       cdLHw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdLHv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdLHu::I64;
           I64[Sp - 24] = block_cdLHx_info;
           R2 = lvl21_rdL8N_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdLHx() //  [R1]
         { info_tbl: [(cdLHx,
                       label: block_cdLHx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLHx: // global
           R3 = R1;
           R2 = lvl20_rdL8M_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.755862856 UTC

[section ""data" . Data.Bifoldable.bimaximum_closure" {
     Data.Bifoldable.bimaximum_closure:
         const Data.Bifoldable.bimaximum_info;
         const 0;
 },
 sat_sdLjV_entry() //  [R1]
         { info_tbl: [(cdLHR,
                       label: sat_sdLjV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLHR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLHS; else goto cdLHT;
       cdLHS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLHT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdLjU_entry() //  [R1]
         { info_tbl: [(cdLHU,
                       label: g_sdLjU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLHU: // global
           _sdLjU::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLHV; else goto cdLHW;
       cdLHW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLHY; else goto cdLHX;
       cdLHY: // global
           HpAlloc = 24;
           goto cdLHV;
       cdLHV: // global
           R1 = _sdLjU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLHX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLjU::P64;
           _sdLjS::P64 = P64[_sdLjU::P64 + 16];
           _sdLjT::P64 = P64[_sdLjU::P64 + 24];
           I64[Hp - 16] = sat_sdLjV_info;
           P64[Hp] = _sdLjT::P64;
           R2 = _sdLjS::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = GHC.Base.Just_closure+1;
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdLjZ_entry() //  [R1, R2]
         { info_tbl: [(cdLIa,
                       label: sat_sdLjZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLIa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLIb; else goto cdLIc;
       cdLIb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLIc: // global
           I64[Sp - 8] = block_cdLI4_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLI4() //  [R1]
         { info_tbl: [(cdLI4,
                       label: block_cdLI4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLI4: // global
           if (R1 & 7 == 1) goto cdLI7; else goto cdLI8;
       cdLI7: // global
           R1 = Data.Bifoldable.bimaximum1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdLI8: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bimaximum_entry() //  [R2, R3]
         { info_tbl: [(cdLIj,
                       label: Data.Bifoldable.bimaximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLIj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLIn; else goto cdLIm;
       cdLIn: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bimaximum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLIm: // global
           I64[Hp - 40] = g_sdLjU_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdLjZ_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.75776672 UTC

[section ""data" . lvl22_rdL8O_closure" {
     lvl22_rdL8O_closure:
         const GHC.Types.I#_con_info;
         const 342;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.758293188 UTC

[section ""data" . lvl23_rdL8P_closure" {
     lvl23_rdL8P_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl22_rdL8O_closure+1;
         const lvl17_rdL8J_closure+1;
         const lvl22_rdL8O_closure+1;
         const lvl18_rdL8K_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.758892251 UTC

[section ""data" . lvl24_rdL8Q_closure" {
     lvl24_rdL8Q_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl23_rdL8P_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.759491394 UTC

[section ""cstring" . lvl25_rdL8R_bytes" {
     lvl25_rdL8R_bytes:
         I8[] [98,105,109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.760311562 UTC

[section ""data" . Data.Bifoldable.biminimum1_closure" {
     Data.Bifoldable.biminimum1_closure:
         const Data.Bifoldable.biminimum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.biminimum1_entry() //  [R1]
         { info_tbl: [(cdLIw,
                       label: Data.Bifoldable.biminimum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLIw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdLIx; else goto cdLIy;
       cdLIx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLIy: // global
           (_cdLIr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdLIr::I64 == 0) goto cdLIt; else goto cdLIs;
       cdLIt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdLIs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdLIr::I64;
           I64[Sp - 24] = block_cdLIu_info;
           R2 = lvl25_rdL8R_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdLIu() //  [R1]
         { info_tbl: [(cdLIu,
                       label: block_cdLIu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLIu: // global
           R3 = R1;
           R2 = lvl24_rdL8Q_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.762069654 UTC

[section ""data" . Data.Bifoldable.biminimum_closure" {
     Data.Bifoldable.biminimum_closure:
         const Data.Bifoldable.biminimum_info;
         const 0;
 },
 sat_sdLk4_entry() //  [R1]
         { info_tbl: [(cdLIO,
                       label: sat_sdLk4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLIO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLIP; else goto cdLIQ;
       cdLIP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLIQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdLk3_entry() //  [R1]
         { info_tbl: [(cdLIR,
                       label: g_sdLk3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLIR: // global
           _sdLk3::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLIS; else goto cdLIT;
       cdLIT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLIV; else goto cdLIU;
       cdLIV: // global
           HpAlloc = 24;
           goto cdLIS;
       cdLIS: // global
           R1 = _sdLk3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLIU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLk3::P64;
           _sdLk1::P64 = P64[_sdLk3::P64 + 16];
           _sdLk2::P64 = P64[_sdLk3::P64 + 24];
           I64[Hp - 16] = sat_sdLk4_info;
           P64[Hp] = _sdLk2::P64;
           R2 = _sdLk1::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = GHC.Base.Just_closure+1;
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdLk8_entry() //  [R1, R2]
         { info_tbl: [(cdLJ7,
                       label: sat_sdLk8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLJ7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLJ8; else goto cdLJ9;
       cdLJ8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLJ9: // global
           I64[Sp - 8] = block_cdLJ1_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLJ1() //  [R1]
         { info_tbl: [(cdLJ1,
                       label: block_cdLJ1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLJ1: // global
           if (R1 & 7 == 1) goto cdLJ4; else goto cdLJ5;
       cdLJ4: // global
           R1 = Data.Bifoldable.biminimum1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdLJ5: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biminimum_entry() //  [R2, R3]
         { info_tbl: [(cdLJg,
                       label: Data.Bifoldable.biminimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLJg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLJk; else goto cdLJj;
       cdLJk: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.biminimum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLJj: // global
           I64[Hp - 40] = g_sdLk3_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdLk8_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.764108043 UTC

[section ""data" . Data.Bifoldable.biproduct2_closure" {
     Data.Bifoldable.biproduct2_closure:
         const Data.Bifoldable.biproduct2_info;
 },
 Data.Bifoldable.biproduct2_entry() //  [R2]
         { info_tbl: [(cdLJp,
                       label: Data.Bifoldable.biproduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLJp: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.765125032 UTC

[section ""data" . Data.Bifoldable.bisum1_closure" {
     Data.Bifoldable.bisum1_closure:
         const Data.Bifoldable.bisum1_info;
         const 0;
 },
 sat_sdLkc_entry() //  [R1]
         { info_tbl: [(cdLJA,
                       label: sat_sdLkc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLJA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLJB; else goto cdLJC;
       cdLJB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLJC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.bisum1_entry() //  [R2, R3]
         { info_tbl: [(cdLJD,
                       label: Data.Bifoldable.bisum1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLJD: // global
           _sdLkb::P64 = R3;
           _sdLka::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdLJE; else goto cdLJF;
       cdLJF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLJH; else goto cdLJG;
       cdLJH: // global
           HpAlloc = 24;
           goto cdLJE;
       cdLJE: // global
           R3 = _sdLkb::P64;
           R2 = _sdLka::P64;
           R1 = Data.Bifoldable.bisum1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLJG: // global
           I64[Hp - 16] = sat_sdLkc_info;
           P64[Hp] = _sdLkb::P64;
           R2 = _sdLka::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Data.Bifoldable.biproduct2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biproduct2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.766587866 UTC

[section ""data" . Data.Bifoldable.bisum_closure" {
     Data.Bifoldable.bisum_closure:
         const Data.Bifoldable.bisum_info;
         const 0;
 },
 Data.Bifoldable.bisum_entry() //  [R2, R3]
         { info_tbl: [(cdLJM,
                       label: Data.Bifoldable.bisum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLJM: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bisum1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.76764805 UTC

[section ""data" . Data.Bifoldable.biproduct1_closure" {
     Data.Bifoldable.biproduct1_closure:
         const Data.Bifoldable.biproduct1_info;
         const 0;
 },
 sat_sdLkf_entry() //  [R1]
         { info_tbl: [(cdLJX,
                       label: sat_sdLkf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLJX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLJY; else goto cdLJZ;
       cdLJY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLJZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.biproduct1_entry() //  [R2, R3]
         { info_tbl: [(cdLK0,
                       label: Data.Bifoldable.biproduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLK0: // global
           _sdLke::P64 = R3;
           _sdLkd::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdLK1; else goto cdLK2;
       cdLK2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLK4; else goto cdLK3;
       cdLK4: // global
           HpAlloc = 24;
           goto cdLK1;
       cdLK1: // global
           R3 = _sdLke::P64;
           R2 = _sdLkd::P64;
           R1 = Data.Bifoldable.biproduct1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLK3: // global
           I64[Hp - 16] = sat_sdLkf_info;
           P64[Hp] = _sdLke::P64;
           R2 = _sdLkd::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Data.Bifoldable.biproduct2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biproduct2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.768951033 UTC

[section ""data" . Data.Bifoldable.biproduct_closure" {
     Data.Bifoldable.biproduct_closure:
         const Data.Bifoldable.biproduct_info;
         const 0;
 },
 Data.Bifoldable.biproduct_entry() //  [R2, R3]
         { info_tbl: [(cdLK9,
                       label: Data.Bifoldable.biproduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLK9: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biproduct1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.769869826 UTC

[section ""data" . Data.Bifoldable.biconcatMap_closure" {
     Data.Bifoldable.biconcatMap_closure:
         const Data.Bifoldable.biconcatMap_info;
         const 0;
 },
 Data.Bifoldable.biconcatMap_entry() //  [R2]
         { info_tbl: [(cdLKg,
                       label: Data.Bifoldable.biconcatMap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLKg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLKh; else goto cdLKi;
       cdLKh: // global
           R2 = R2;
           R1 = Data.Bifoldable.biconcatMap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLKi: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.$fMonoid[]_closure;
           Sp = Sp - 16;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.770861481 UTC

[section ""data" . Data.Bifoldable.biand2_closure" {
     Data.Bifoldable.biand2_closure:
         const Data.Bifoldable.biand2_info;
 },
 Data.Bifoldable.biand2_entry() //  [R2]
         { info_tbl: [(cdLKn,
                       label: Data.Bifoldable.biand2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLKn: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.771749913 UTC

[section ""data" . Data.Bifoldable.biand1_closure" {
     Data.Bifoldable.biand1_closure:
         const Data.Bifoldable.biand1_info;
         const 0;
 },
 Data.Bifoldable.biand1_entry() //  [R2]
         { info_tbl: [(cdLKu,
                       label: Data.Bifoldable.biand1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLKu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLKv; else goto cdLKw;
       cdLKv: // global
           R2 = R2;
           R1 = Data.Bifoldable.biand1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLKw: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAll_closure;
           P64[Sp - 16] = Data.Bifoldable.biand2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biand2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.772751602 UTC

[section ""data" . Data.Bifoldable.biand_closure" {
     Data.Bifoldable.biand_closure:
         const Data.Bifoldable.biand_info;
         const 0;
 },
 Data.Bifoldable.biand_entry() //  [R2]
         { info_tbl: [(cdLKB,
                       label: Data.Bifoldable.biand_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLKB: // global
           R2 = R2;
           call Data.Bifoldable.biand1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.77365968 UTC

[section ""data" . Data.Bifoldable.bior1_closure" {
     Data.Bifoldable.bior1_closure:
         const Data.Bifoldable.bior1_info;
         const 0;
 },
 Data.Bifoldable.bior1_entry() //  [R2]
         { info_tbl: [(cdLKI,
                       label: Data.Bifoldable.bior1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLKI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLKJ; else goto cdLKK;
       cdLKJ: // global
           R2 = R2;
           R1 = Data.Bifoldable.bior1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLKK: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Data.Bifoldable.biand2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biand2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.774641654 UTC

[section ""data" . Data.Bifoldable.bior_closure" {
     Data.Bifoldable.bior_closure:
         const Data.Bifoldable.bior_info;
         const 0;
 },
 Data.Bifoldable.bior_entry() //  [R2]
         { info_tbl: [(cdLKP,
                       label: Data.Bifoldable.bior_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLKP: // global
           R2 = R2;
           call Data.Bifoldable.bior1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.775805096 UTC

[section ""data" . Data.Bifoldable.biany1_closure" {
     Data.Bifoldable.biany1_closure:
         const Data.Bifoldable.biany1_info;
         const 0;
 },
 sat_sdLkq_entry() //  [R1, R2]
         { info_tbl: [(cdLL1,
                       label: sat_sdLkq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLL1: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLko_entry() //  [R1, R2]
         { info_tbl: [(cdLL9,
                       label: sat_sdLko_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLL9: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biany1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLLc,
                       label: Data.Bifoldable.biany1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLLc: // global
           _sdLkm::P64 = R4;
           _sdLkl::P64 = R3;
           _sdLkk::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdLLd; else goto cdLLe;
       cdLLe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLLg; else goto cdLLf;
       cdLLg: // global
           HpAlloc = 32;
           goto cdLLd;
       cdLLd: // global
           R4 = _sdLkm::P64;
           R3 = _sdLkl::P64;
           R2 = _sdLkk::P64;
           R1 = Data.Bifoldable.biany1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLLf: // global
           I64[Hp - 24] = sat_sdLkq_info;
           P64[Hp - 16] = _sdLkm::P64;
           I64[Hp - 8] = sat_sdLko_info;
           P64[Hp] = _sdLkl::P64;
           R2 = _sdLkk::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.777280688 UTC

[section ""data" . Data.Bifoldable.biany_closure" {
     Data.Bifoldable.biany_closure:
         const Data.Bifoldable.biany_info;
         const 0;
 },
 Data.Bifoldable.biany_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLLl,
                       label: Data.Bifoldable.biany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLLl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biany1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.778521384 UTC

[section ""data" . Data.Bifoldable.bielem1_closure" {
     Data.Bifoldable.bielem1_closure:
         const Data.Bifoldable.bielem1_info;
         const 0;
 },
 sat_sdLkx_entry() //  [R1, R2]
         { info_tbl: [(cdLLx,
                       label: sat_sdLkx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLLx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdLLy; else goto cdLLz;
       cdLLy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLLz: // global
           _sdLkw::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sdLkw::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdLkv_entry() //  [R1, R2]
         { info_tbl: [(cdLLF,
                       label: sat_sdLkv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLLF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdLLG; else goto cdLLH;
       cdLLG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLLH: // global
           _sdLku::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sdLku::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bielem1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLLI,
                       label: Data.Bifoldable.bielem1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLLI: // global
           _sdLkt::P64 = R4;
           _sdLks::P64 = R3;
           _sdLkr::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdLLJ; else goto cdLLK;
       cdLLK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLLM; else goto cdLLL;
       cdLLM: // global
           HpAlloc = 48;
           goto cdLLJ;
       cdLLJ: // global
           R4 = _sdLkt::P64;
           R3 = _sdLks::P64;
           R2 = _sdLkr::P64;
           R1 = Data.Bifoldable.bielem1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLLL: // global
           I64[Hp - 40] = sat_sdLkx_info;
           P64[Hp - 32] = _sdLks::P64;
           P64[Hp - 24] = _sdLkt::P64;
           I64[Hp - 16] = sat_sdLkv_info;
           P64[Hp - 8] = _sdLks::P64;
           P64[Hp] = _sdLkt::P64;
           R2 = _sdLkr::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Hp - 15;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.780197896 UTC

[section ""data" . Data.Bifoldable.bielem_closure" {
     Data.Bifoldable.bielem_closure:
         const Data.Bifoldable.bielem_info;
         const 0;
 },
 Data.Bifoldable.bielem_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLLR,
                       label: Data.Bifoldable.bielem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLLR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bielem1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.781645703 UTC

[section ""data" . Data.Bifoldable.binotElem_closure" {
     Data.Bifoldable.binotElem_closure:
         const Data.Bifoldable.binotElem_info;
         const 0;
 },
 g_sdLkB_entry() //  [R1]
         { info_tbl: [(cdLM2,
                       label: g_sdLkB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLM2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLM3; else goto cdLM4;
       cdLM3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLM4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bifoldable.bielem1_entry(R4,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLkE_entry() //  [R1, R2]
         { info_tbl: [(cdLMg,
                       label: sat_sdLkE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLMg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLMh; else goto cdLMi;
       cdLMh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLMi: // global
           I64[Sp - 8] = block_cdLMa_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLMa() //  [R1]
         { info_tbl: [(cdLMa,
                       label: block_cdLMa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLMa: // global
           if (R1 & 7 == 1) goto cdLMd; else goto cdLMe;
       cdLMd: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdLMe: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.binotElem_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLMp,
                       label: Data.Bifoldable.binotElem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLMp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLMt; else goto cdLMs;
       cdLMt: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.binotElem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLMs: // global
           I64[Hp - 48] = g_sdLkB_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdLkE_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.783790143 UTC

[section ""data" . Data.Bifoldable.biall1_closure" {
     Data.Bifoldable.biall1_closure:
         const Data.Bifoldable.biall1_info;
         const 0;
 },
 sat_sdLkL_entry() //  [R1, R2]
         { info_tbl: [(cdLMD,
                       label: sat_sdLkL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLMD: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLkJ_entry() //  [R1, R2]
         { info_tbl: [(cdLML,
                       label: sat_sdLkJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLML: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biall1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLMO,
                       label: Data.Bifoldable.biall1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLMO: // global
           _sdLkH::P64 = R4;
           _sdLkG::P64 = R3;
           _sdLkF::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdLMP; else goto cdLMQ;
       cdLMQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLMS; else goto cdLMR;
       cdLMS: // global
           HpAlloc = 32;
           goto cdLMP;
       cdLMP: // global
           R4 = _sdLkH::P64;
           R3 = _sdLkG::P64;
           R2 = _sdLkF::P64;
           R1 = Data.Bifoldable.biall1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLMR: // global
           I64[Hp - 24] = sat_sdLkL_info;
           P64[Hp - 16] = _sdLkH::P64;
           I64[Hp - 8] = sat_sdLkJ_info;
           P64[Hp] = _sdLkG::P64;
           R2 = _sdLkF::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAll_closure;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.785308361 UTC

[section ""data" . Data.Bifoldable.biall_closure" {
     Data.Bifoldable.biall_closure:
         const Data.Bifoldable.biall_info;
         const 0;
 },
 Data.Bifoldable.biall_entry() //  [R2, R3, R4]
         { info_tbl: [(cdLMX,
                       label: Data.Bifoldable.biall_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLMX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biall1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.786940797 UTC

[section ""data" . Data.Bifoldable.bifind_closure" {
     Data.Bifoldable.bifind_closure:
         const Data.Bifoldable.bifind_info;
         const 0;
 },
 finder_sdLkP_entry() //  [R1, R2]
         { info_tbl: [(cdLNj,
                       label: finder_sdLkP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLNj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLNk; else goto cdLNl;
       cdLNk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLNl: // global
           I64[Sp - 16] = block_cdLNd_info;
           _sdLkQ::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdLkQ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLNd() //  [R1]
         { info_tbl: [(cdLNd,
                       label: block_cdLNd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLNd: // global
           if (R1 & 7 == 1) goto cdLNg; else goto cdLNh;
       cdLNg: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdLNh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdLNu; else goto cdLNt;
       cdLNu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdLNt: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdLkO_entry() //  [R1]
         { info_tbl: [(cdLNv,
                       label: g_sdLkO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLNv: // global
           _sdLkO::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLNw; else goto cdLNx;
       cdLNx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdLNz; else goto cdLNy;
       cdLNz: // global
           HpAlloc = 16;
           goto cdLNw;
       cdLNw: // global
           R1 = _sdLkO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLNy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLkO::P64;
           _sdLkM::P64 = P64[_sdLkO::P64 + 16];
           _sdLkN::P64 = P64[_sdLkO::P64 + 24];
           I64[Hp - 8] = finder_sdLkP_info;
           P64[Hp] = _sdLkN::P64;
           R2 = _sdLkM::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Monoid.$fMonoidFirst_closure;
           _cdLN8::P64 = Hp - 7;
           P64[Sp - 32] = _cdLN8::P64;
           P64[Sp - 24] = _cdLN8::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdLkT_entry() //  [R1, R2]
         { info_tbl: [(cdLNF,
                       label: sat_sdLkT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLNF: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifind_entry() //  [R2, R3]
         { info_tbl: [(cdLNI,
                       label: Data.Bifoldable.bifind_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLNI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLNM; else goto cdLNL;
       cdLNM: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bifind_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLNL: // global
           I64[Hp - 40] = g_sdLkO_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdLkT_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.79055072 UTC

[section ""data" . Data.Bifoldable.$trModule3_closure" {
     Data.Bifoldable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.791136714 UTC

[section ""data" . Data.Bifoldable.$trModule1_closure" {
     Data.Bifoldable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.791705208 UTC

[section ""data" . Data.Bifoldable.$trModule_closure" {
     Data.Bifoldable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bifoldable.$trModule3_closure+1;
         const Data.Bifoldable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.79231369 UTC

[section ""data" . $krep_rdL8S_closure" {
     $krep_rdL8S_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.792904807 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable1_closure" {
     Data.Bifoldable.$tcBifoldable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdL8S_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.793831771 UTC

[section ""cstring" . Data.Bifoldable.$tcBifoldable3_bytes" {
     Data.Bifoldable.$tcBifoldable3_bytes:
         I8[] [66,105,102,111,108,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.794402906 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable2_closure" {
     Data.Bifoldable.$tcBifoldable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$tcBifoldable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.794971162 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable_closure" {
     Data.Bifoldable.$tcBifoldable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bifoldable.$trModule_closure+1;
         const Data.Bifoldable.$tcBifoldable2_closure+1;
         const Data.Bifoldable.$tcBifoldable1_closure+4;
         const 13881323671910883383;
         const 7079945659398195047;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.795929415 UTC

[section ""data" . Data.Bifoldable.C:Bifoldable_closure" {
     Data.Bifoldable.C:Bifoldable_closure:
         const Data.Bifoldable.C:Bifoldable_info;
 },
 Data.Bifoldable.C:Bifoldable_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdLNS,
                       label: Data.Bifoldable.C:Bifoldable_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLNS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdLNW; else goto cdLNV;
       cdLNW: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.C:Bifoldable_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLNV: // global
           I64[Hp - 32] = Data.Bifoldable.C:Bifoldable_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.796887671 UTC

[Data.Bifoldable.C:Bifoldable_con_entry() //  [R1]
         { info_tbl: [(cdLNX,
                       label: Data.Bifoldable.C:Bifoldable_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,102,111,108,100,97,98,108,101,46,67,58,66,105,102,111,108,100,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLNX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.79760621 UTC

[section ""relreadonly" . SdLpk_srt" {
     SdLpk_srt:
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Bifoldable.$dmbifoldl_closure;
         const poly_$dMonoid_rdL8r_closure;
         const Data.Bifoldable.$dmbifoldr_closure;
         const GHC.Err.error_closure;
         const lvl10_rdL8C_closure;
         const Data.Bifoldable.bifoldr1_closure;
         const Data.Bifoldable.bifoldr2_closure;
         const Data.Bifoldable.bimaximumBy_closure;
         const Data.Bifoldable.biminimumBy_closure;
         const lvl14_rdL8G_closure;
         const Data.Bifoldable.bifoldl1_closure;
         const Data.Bifoldable.bifoldl2_closure;
         const GHC.Base.$fMonoid[]_closure;
         const Data.Bifoldable.biconcat_closure;
         const lvl20_rdL8M_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Bifoldable.bimaximum1_closure;
         const Data.Bifoldable.bimaximum_closure;
         const lvl24_rdL8Q_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Bifoldable.biminimum1_closure;
         const Data.Bifoldable.biminimum_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Bifoldable.bisum1_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Bifoldable.biproduct1_closure;
         const Data.Bifoldable.biconcatMap_closure;
         const Data.Semigroup.Internal.$fMonoidAll_closure;
         const Data.Bifoldable.biand1_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Bifoldable.bior1_closure;
         const Data.Bifoldable.biany1_closure;
         const Data.Bifoldable.bielem1_closure;
         const Data.Bifoldable.binotElem_closure;
         const Data.Bifoldable.biall1_closure;
         const Data.Monoid.$fMonoidFirst_closure;
         const Data.Bifoldable.bifind_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.798376197 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:58.799093315 UTC

[section ""data" . Data.Bifoldable.bifold_closure" {
     Data.Bifoldable.bifold_closure:
         const Data.Bifoldable.bifold_info;
 },
 Data.Bifoldable.bifold_entry() //  [R2]
         { info_tbl: [(cdLO5,
                       label: Data.Bifoldable.bifold_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLO5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLO6; else goto cdLO7;
       cdLO6: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifold_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLO7: // global
           I64[Sp - 8] = block_cdLO2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udLOb; else goto cdLO3;
       udLOb: // global
           call _cdLO2(R1) args: 0, res: 0, upd: 0;
       cdLO3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLO2() //  [R1]
         { info_tbl: [(cdLO2,
                       label: block_cdLO2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLO2: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.800247879 UTC

[section ""data" . Data.Bifoldable.bifoldMap_closure" {
     Data.Bifoldable.bifoldMap_closure:
         const Data.Bifoldable.bifoldMap_info;
 },
 Data.Bifoldable.bifoldMap_entry() //  [R2]
         { info_tbl: [(cdLOj,
                       label: Data.Bifoldable.bifoldMap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLOj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLOk; else goto cdLOl;
       cdLOk: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldMap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLOl: // global
           I64[Sp - 8] = block_cdLOg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udLOp; else goto cdLOh;
       udLOp: // global
           call _cdLOg(R1) args: 0, res: 0, upd: 0;
       cdLOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLOg() //  [R1]
         { info_tbl: [(cdLOg,
                       label: block_cdLOg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLOg: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.801410236 UTC

[section ""data" . Data.Bifoldable.bifoldr_closure" {
     Data.Bifoldable.bifoldr_closure:
         const Data.Bifoldable.bifoldr_info;
 },
 Data.Bifoldable.bifoldr_entry() //  [R2]
         { info_tbl: [(cdLOx,
                       label: Data.Bifoldable.bifoldr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLOx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLOy; else goto cdLOz;
       cdLOy: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLOz: // global
           I64[Sp - 8] = block_cdLOu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udLOD; else goto cdLOv;
       udLOD: // global
           call _cdLOu(R1) args: 0, res: 0, upd: 0;
       cdLOv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLOu() //  [R1]
         { info_tbl: [(cdLOu,
                       label: block_cdLOu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLOu: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.802520544 UTC

[section ""data" . Data.Bifoldable.bifoldl_closure" {
     Data.Bifoldable.bifoldl_closure:
         const Data.Bifoldable.bifoldl_info;
 },
 Data.Bifoldable.bifoldl_entry() //  [R2]
         { info_tbl: [(cdLOL,
                       label: Data.Bifoldable.bifoldl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLOL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLOM; else goto cdLON;
       cdLOM: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLON: // global
           I64[Sp - 8] = block_cdLOI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udLOR; else goto cdLOJ;
       udLOR: // global
           call _cdLOI(R1) args: 0, res: 0, upd: 0;
       cdLOJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLOI() //  [R1]
         { info_tbl: [(cdLOI,
                       label: block_cdLOI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLOI: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.80397429 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_info;
 },
 sat_sdL9v_entry() //  [R1]
         { info_tbl: [(cdLP1,
                       label: sat_sdL9v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLP1: // global
           _sdL9v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLP2; else goto cdLP3;
       cdLP3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLP5; else goto cdLP4;
       cdLP5: // global
           HpAlloc = 24;
           goto cdLP2;
       cdLP2: // global
           R1 = _sdL9v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLP4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9v::P64;
           _sdL9k::P64 = P64[_sdL9v::P64 + 16];
           _sdL9l::P64 = P64[_sdL9v::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdL9l::P64;
           R2 = Hp - 16;
           R1 = _sdL9k::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdL9q_entry() //  [R1]
         { info_tbl: [(cdLPb,
                       label: sat_sdL9q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLPb: // global
           _sdL9q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLPc; else goto cdLPd;
       cdLPd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLPf; else goto cdLPe;
       cdLPf: // global
           HpAlloc = 24;
           goto cdLPc;
       cdLPc: // global
           R1 = _sdL9q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLPe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9q::P64;
           _sdL9j::P64 = P64[_sdL9q::P64 + 16];
           _sdL9l::P64 = P64[_sdL9q::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdL9l::P64;
           R2 = Hp - 16;
           R1 = _sdL9j::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdLPg,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLPg: // global
           _sdL9l::P64 = R5;
           _sdL9k::P64 = R4;
           _sdL9j::P64 = R3;
           _sdL9i::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLPh; else goto cdLPi;
       cdLPi: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLPk; else goto cdLPj;
       cdLPk: // global
           HpAlloc = 64;
           goto cdLPh;
       cdLPh: // global
           R5 = _sdL9l::P64;
           R4 = _sdL9k::P64;
           R3 = _sdL9j::P64;
           R2 = _sdL9i::P64;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLPj: // global
           I64[Hp - 56] = sat_sdL9v_info;
           P64[Hp - 40] = _sdL9k::P64;
           P64[Hp - 32] = _sdL9l::P64;
           I64[Hp - 24] = sat_sdL9q_info;
           P64[Hp - 8] = _sdL9j::P64;
           P64[Hp] = _sdL9l::P64;
           R2 = _sdL9i::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.80584463 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldMap_entry() //  [R3, R5]
         { info_tbl: [(cdLPp,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLPp: // global
           R2 = R5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.806750371 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldMap_entry() //  [R3, R5]
         { info_tbl: [(cdLPw,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLPw: // global
           R2 = R5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.808026263 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_info;
 },
 sat_sdL9T_entry() //  [R1]
         { info_tbl: [(cdLPI,
                       label: sat_sdL9T_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLPI: // global
           _sdL9T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLPJ; else goto cdLPK;
       cdLPK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLPM; else goto cdLPL;
       cdLPM: // global
           HpAlloc = 24;
           goto cdLPJ;
       cdLPJ: // global
           R1 = _sdL9T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLPL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9T::P64;
           _sdL9G::P64 = P64[_sdL9T::P64 + 16];
           _sdL9H::P64 = P64[_sdL9T::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdL9H::P64;
           R2 = Hp - 16;
           R1 = _sdL9G::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdL9N_entry() //  [R1]
         { info_tbl: [(cdLPS,
                       label: sat_sdL9N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLPS: // global
           _sdL9N::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLPT; else goto cdLPU;
       cdLPU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLPW; else goto cdLPV;
       cdLPW: // global
           HpAlloc = 24;
           goto cdLPT;
       cdLPT: // global
           R1 = _sdL9N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLPV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9N::P64;
           _sdL9F::P64 = P64[_sdL9N::P64 + 16];
           _sdL9H::P64 = P64[_sdL9N::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdL9H::P64;
           R2 = Hp - 16;
           R1 = _sdL9F::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdLPX,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLPX: // global
           _sdL9H::P64 = R5;
           _sdL9G::P64 = R4;
           _sdL9F::P64 = R3;
           _sdL9E::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLPY; else goto cdLPZ;
       cdLPZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLQ1; else goto cdLQ0;
       cdLQ1: // global
           HpAlloc = 64;
           goto cdLPY;
       cdLPY: // global
           R5 = _sdL9H::P64;
           R4 = _sdL9G::P64;
           R3 = _sdL9F::P64;
           R2 = _sdL9E::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLQ0: // global
           I64[Hp - 56] = sat_sdL9T_info;
           P64[Hp - 40] = _sdL9G::P64;
           P64[Hp - 32] = _sdL9H::P64;
           I64[Hp - 24] = sat_sdL9N_info;
           P64[Hp - 8] = _sdL9F::P64;
           P64[Hp] = _sdL9H::P64;
           R2 = _sdL9E::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.810500875 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_info;
 },
 sat_sdLab_entry() //  [R1]
         { info_tbl: [(cdLQb,
                       label: sat_sdLab_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLQb: // global
           _sdLab::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLQc; else goto cdLQd;
       cdLQd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLQf; else goto cdLQe;
       cdLQf: // global
           HpAlloc = 24;
           goto cdLQc;
       cdLQc: // global
           R1 = _sdLab::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLQe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLab::P64;
           _sdL9W::P64 = P64[_sdLab::P64 + 16];
           _sdL9X::P64 = P64[_sdLab::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdL9X::P64;
           R2 = Hp - 16;
           R1 = _sdL9W::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLa4_entry() //  [R1]
         { info_tbl: [(cdLQl,
                       label: sat_sdLa4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLQl: // global
           _sdLa4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLQm; else goto cdLQn;
       cdLQn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLQp; else goto cdLQo;
       cdLQp: // global
           HpAlloc = 24;
           goto cdLQm;
       cdLQm: // global
           R1 = _sdLa4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLQo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLa4::P64;
           _sdL9V::P64 = P64[_sdLa4::P64 + 16];
           _sdL9X::P64 = P64[_sdLa4::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdL9X::P64;
           R2 = Hp - 16;
           R1 = _sdL9V::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdLQq,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLQq: // global
           _sdL9X::P64 = R5;
           _sdL9W::P64 = R4;
           _sdL9V::P64 = R3;
           _sdL9U::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLQr; else goto cdLQs;
       cdLQs: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLQu; else goto cdLQt;
       cdLQu: // global
           HpAlloc = 64;
           goto cdLQr;
       cdLQr: // global
           R5 = _sdL9X::P64;
           R4 = _sdL9W::P64;
           R3 = _sdL9V::P64;
           R2 = _sdL9U::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLQt: // global
           I64[Hp - 56] = sat_sdLab_info;
           P64[Hp - 40] = _sdL9W::P64;
           P64[Hp - 32] = _sdL9X::P64;
           I64[Hp - 24] = sat_sdLa4_info;
           P64[Hp - 8] = _sdL9V::P64;
           P64[Hp] = _sdL9X::P64;
           R2 = _sdL9U::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.812706985 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_info;
 },
 sat_sdLav_entry() //  [R1]
         { info_tbl: [(cdLQE,
                       label: sat_sdLav_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLQE: // global
           _sdLav::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLQF; else goto cdLQG;
       cdLQG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLQI; else goto cdLQH;
       cdLQI: // global
           HpAlloc = 24;
           goto cdLQF;
       cdLQF: // global
           R1 = _sdLav::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLQH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLav::P64;
           _sdLae::P64 = P64[_sdLav::P64 + 16];
           _sdLaf::P64 = P64[_sdLav::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLaf::P64;
           R2 = Hp - 16;
           R1 = _sdLae::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLan_entry() //  [R1]
         { info_tbl: [(cdLQO,
                       label: sat_sdLan_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLQO: // global
           _sdLan::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLQP; else goto cdLQQ;
       cdLQQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLQS; else goto cdLQR;
       cdLQS: // global
           HpAlloc = 24;
           goto cdLQP;
       cdLQP: // global
           R1 = _sdLan::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLQR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLan::P64;
           _sdLad::P64 = P64[_sdLan::P64 + 16];
           _sdLaf::P64 = P64[_sdLan::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLaf::P64;
           R2 = Hp - 16;
           R1 = _sdLad::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdLQT,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLQT: // global
           _sdLaf::P64 = R5;
           _sdLae::P64 = R4;
           _sdLad::P64 = R3;
           _sdLac::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLQU; else goto cdLQV;
       cdLQV: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLQX; else goto cdLQW;
       cdLQX: // global
           HpAlloc = 64;
           goto cdLQU;
       cdLQU: // global
           R5 = _sdLaf::P64;
           R4 = _sdLae::P64;
           R3 = _sdLad::P64;
           R2 = _sdLac::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLQW: // global
           I64[Hp - 56] = sat_sdLav_info;
           P64[Hp - 40] = _sdLae::P64;
           P64[Hp - 32] = _sdLaf::P64;
           I64[Hp - 24] = sat_sdLan_info;
           P64[Hp - 8] = _sdLad::P64;
           P64[Hp] = _sdLaf::P64;
           R2 = _sdLac::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.814945389 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_info;
 },
 sat_sdLaR_entry() //  [R1]
         { info_tbl: [(cdLR7,
                       label: sat_sdLaR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLR7: // global
           _sdLaR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLR8; else goto cdLR9;
       cdLR9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLRb; else goto cdLRa;
       cdLRb: // global
           HpAlloc = 24;
           goto cdLR8;
       cdLR8: // global
           R1 = _sdLaR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLRa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLaR::P64;
           _sdLay::P64 = P64[_sdLaR::P64 + 16];
           _sdLaz::P64 = P64[_sdLaR::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLaz::P64;
           R2 = Hp - 16;
           R1 = _sdLay::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLaI_entry() //  [R1]
         { info_tbl: [(cdLRh,
                       label: sat_sdLaI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLRh: // global
           _sdLaI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLRi; else goto cdLRj;
       cdLRj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLRl; else goto cdLRk;
       cdLRl: // global
           HpAlloc = 24;
           goto cdLRi;
       cdLRi: // global
           R1 = _sdLaI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLRk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLaI::P64;
           _sdLax::P64 = P64[_sdLaI::P64 + 16];
           _sdLaz::P64 = P64[_sdLaI::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLaz::P64;
           R2 = Hp - 16;
           R1 = _sdLax::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdLRm,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLRm: // global
           _sdLaz::P64 = R5;
           _sdLay::P64 = R4;
           _sdLax::P64 = R3;
           _sdLaw::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLRn; else goto cdLRo;
       cdLRo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLRq; else goto cdLRp;
       cdLRq: // global
           HpAlloc = 64;
           goto cdLRn;
       cdLRn: // global
           R5 = _sdLaz::P64;
           R4 = _sdLay::P64;
           R3 = _sdLax::P64;
           R2 = _sdLaw::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLRp: // global
           I64[Hp - 56] = sat_sdLaR_info;
           P64[Hp - 40] = _sdLay::P64;
           P64[Hp - 32] = _sdLaz::P64;
           I64[Hp - 24] = sat_sdLaI_info;
           P64[Hp - 8] = _sdLax::P64;
           P64[Hp] = _sdLaz::P64;
           R2 = _sdLaw::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.817176871 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_info;
 },
 sat_sdLbf_entry() //  [R1]
         { info_tbl: [(cdLRA,
                       label: sat_sdLbf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLRA: // global
           _sdLbf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLRB; else goto cdLRC;
       cdLRC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLRE; else goto cdLRD;
       cdLRE: // global
           HpAlloc = 24;
           goto cdLRB;
       cdLRB: // global
           R1 = _sdLbf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLRD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLbf::P64;
           _sdLaU::P64 = P64[_sdLbf::P64 + 16];
           _sdLaV::P64 = P64[_sdLbf::P64 + 24];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdLaV::P64;
           R2 = Hp - 16;
           R1 = _sdLaU::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLb5_entry() //  [R1]
         { info_tbl: [(cdLRK,
                       label: sat_sdLb5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLRK: // global
           _sdLb5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLRL; else goto cdLRM;
       cdLRM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLRO; else goto cdLRN;
       cdLRO: // global
           HpAlloc = 24;
           goto cdLRL;
       cdLRL: // global
           R1 = _sdLb5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLRN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLb5::P64;
           _sdLaT::P64 = P64[_sdLb5::P64 + 16];
           _sdLaV::P64 = P64[_sdLb5::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLaV::P64;
           R2 = Hp - 16;
           R1 = _sdLaT::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_entry() //  [R2,
                                                               R3, R4, R5]
         { info_tbl: [(cdLRP,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLRP: // global
           _sdLaV::P64 = R5;
           _sdLaU::P64 = R4;
           _sdLaT::P64 = R3;
           _sdLaS::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLRQ; else goto cdLRR;
       cdLRR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLRT; else goto cdLRS;
       cdLRT: // global
           HpAlloc = 64;
           goto cdLRQ;
       cdLRQ: // global
           R5 = _sdLaV::P64;
           R4 = _sdLaU::P64;
           R3 = _sdLaT::P64;
           R2 = _sdLaS::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLRS: // global
           I64[Hp - 56] = sat_sdLbf_info;
           P64[Hp - 40] = _sdLaU::P64;
           P64[Hp - 32] = _sdLaV::P64;
           I64[Hp - 24] = sat_sdLb5_info;
           P64[Hp - 8] = _sdLaT::P64;
           P64[Hp] = _sdLaV::P64;
           R2 = _sdLaS::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.819272826 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldMap_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdLS5,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLS5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdLS6; else goto cdLS7;
       cdLS6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLS7: // global
           I64[Sp - 24] = block_cdLRY_info;
           R1 = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udLSe; else goto cdLRZ;
       udLSe: // global
           call _cdLRY(R1) args: 0, res: 0, upd: 0;
       cdLRZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLRY() //  [R1]
         { info_tbl: [(cdLRY,
                       label: block_cdLRY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLRY: // global
           if (R1 & 7 == 1) goto cdLS2; else goto cdLS3;
       cdLS2: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdLS3: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.820605856 UTC

[section ""data" . poly_$dMonoid_rdL8r_closure" {
     poly_$dMonoid_rdL8r_closure:
         const poly_$dMonoid_rdL8r_info;
         const 0;
         const 0;
         const 0;
 },
 poly_$dMonoid_rdL8r_entry() //  [R1]
         { info_tbl: [(cdLSl,
                       label: poly_$dMonoid_rdL8r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLSl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLSm; else goto cdLSn;
       cdLSm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLSn: // global
           (_cdLSi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdLSi::I64 == 0) goto cdLSk; else goto cdLSj;
       cdLSk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdLSj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdLSi::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.822007224 UTC

[section ""data" . Data.Bifoldable.$dmbifoldl_closure" {
     Data.Bifoldable.$dmbifoldl_closure:
         const Data.Bifoldable.$dmbifoldl_info;
         const 0;
 },
 sat_sdLbx_entry() //  [R1, R2, R3]
         { info_tbl: [(cdLSx,
                       label: sat_sdLbx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLSx: // global
           _sdLbw::P64 = R3;
           R3 = R2;
           R2 = _sdLbw::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLbu_entry() //  [R1, R2, R3]
         { info_tbl: [(cdLSF,
                       label: sat_sdLbu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLSF: // global
           _sdLbt::P64 = R3;
           R3 = R2;
           R2 = _sdLbt::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.$dmbifoldl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLSI,
                       label: Data.Bifoldable.$dmbifoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLSI: // global
           _sdLbr::P64 = R6;
           _sdLbq::P64 = R5;
           _sdLbp::P64 = R4;
           _sdLbo::P64 = R3;
           _sdLbn::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdLSJ; else goto cdLSK;
       cdLSK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLSM; else goto cdLSL;
       cdLSM: // global
           HpAlloc = 32;
           goto cdLSJ;
       cdLSJ: // global
           R6 = _sdLbr::P64;
           R5 = _sdLbq::P64;
           R4 = _sdLbp::P64;
           R3 = _sdLbo::P64;
           R2 = _sdLbn::P64;
           R1 = Data.Bifoldable.$dmbifoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLSL: // global
           I64[Hp - 24] = sat_sdLbx_info;
           P64[Hp - 16] = _sdLbp::P64;
           I64[Hp - 8] = sat_sdLbu_info;
           P64[Hp] = _sdLbo::P64;
           R2 = _sdLbn::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = poly_$dMonoid_rdL8r_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdLbr::P64;
           P64[Sp - 8] = _sdLbq::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.823654398 UTC

[section ""data" . Data.Bifoldable.$dmbifoldr_closure" {
     Data.Bifoldable.$dmbifoldr_closure:
         const Data.Bifoldable.$dmbifoldr_info;
         const 0;
 },
 Data.Bifoldable.$dmbifoldr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLSR,
                       label: Data.Bifoldable.$dmbifoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLSR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdLSS; else goto cdLST;
       cdLSS: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$dmbifoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLST: // global
           R2 = R2;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R6;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.825314946 UTC

[section ""data" . Data.Bifoldable.$dmbifoldMap_closure" {
     Data.Bifoldable.$dmbifoldMap_closure:
         const Data.Bifoldable.$dmbifoldMap_info;
 },
 sat_sdLbN_entry() //  [R1]
         { info_tbl: [(cdLT2,
                       label: sat_sdLbN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLT2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdLT3; else goto cdLT4;
       cdLT3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLT4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLbM_entry() //  [R1, R2]
         { info_tbl: [(cdLTb,
                       label: sat_sdLbM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLTb: // global
           _sdLbK::P64 = R2;
           _sdLbM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLTc; else goto cdLTd;
       cdLTd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLTf; else goto cdLTe;
       cdLTf: // global
           HpAlloc = 32;
           goto cdLTc;
       cdLTc: // global
           R2 = _sdLbK::P64;
           R1 = _sdLbM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLTe: // global
           _sdLbE::P64 = P64[_sdLbM::P64 + 7];
           _sdLbG::P64 = P64[_sdLbM::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLbG::P64;
           P64[Hp] = _sdLbK::P64;
           R2 = _sdLbE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdLbJ_entry() //  [R1, R2]
         { info_tbl: [(cdLTm,
                       label: sat_sdLbJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLTm: // global
           _sdLbH::P64 = R2;
           _sdLbJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLTn; else goto cdLTo;
       cdLTo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdLTq; else goto cdLTp;
       cdLTq: // global
           HpAlloc = 32;
           goto cdLTn;
       cdLTn: // global
           R2 = _sdLbH::P64;
           R1 = _sdLbJ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLTp: // global
           _sdLbE::P64 = P64[_sdLbJ::P64 + 7];
           _sdLbF::P64 = P64[_sdLbJ::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLbF::P64;
           P64[Hp] = _sdLbH::P64;
           R2 = _sdLbE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.$dmbifoldMap_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdLTr,
                       label: Data.Bifoldable.$dmbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLTr: // global
           _sdLbG::P64 = R5;
           _sdLbF::P64 = R4;
           _sdLbE::P64 = R3;
           _sdLbD::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdLTs; else goto cdLTt;
       cdLTt: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdLTv; else goto cdLTu;
       cdLTv: // global
           HpAlloc = 72;
           goto cdLTs;
       cdLTs: // global
           R5 = _sdLbG::P64;
           R4 = _sdLbF::P64;
           R3 = _sdLbE::P64;
           R2 = _sdLbD::P64;
           R1 = Data.Bifoldable.$dmbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLTu: // global
           I64[Hp - 64] = sat_sdLbN_info;
           P64[Hp - 48] = _sdLbE::P64;
           I64[Hp - 40] = sat_sdLbM_info;
           P64[Hp - 32] = _sdLbE::P64;
           P64[Hp - 24] = _sdLbG::P64;
           I64[Hp - 16] = sat_sdLbJ_info;
           P64[Hp - 8] = _sdLbE::P64;
           P64[Hp] = _sdLbF::P64;
           R2 = _sdLbD::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 15;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.827606698 UTC

[section ""data" . Data.Bifoldable.$dmbifold_closure" {
     Data.Bifoldable.$dmbifold_closure:
         const Data.Bifoldable.$dmbifold_info;
 },
 Data.Bifoldable.$dmbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLTA,
                       label: Data.Bifoldable.$dmbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLTA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLTB; else goto cdLTC;
       cdLTB: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$dmbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLTC: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.828825881 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifold_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifold_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLTO,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLTO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdLTP; else goto cdLTQ;
       cdLTP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLTQ: // global
           I64[Sp - 8] = block_cdLTH_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udLTX; else goto cdLTI;
       udLTX: // global
           call _cdLTH(R1) args: 0, res: 0, upd: 0;
       cdLTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLTH() //  [R1]
         { info_tbl: [(cdLTH,
                       label: block_cdLTH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLTH: // global
           if (R1 & 7 == 1) goto cdLTL; else goto cdLTM;
       cdLTL: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdLTM: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.830617586 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldr_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdLU9,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLU9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLUa; else goto cdLUb;
       cdLUa: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLUb: // global
           I64[Sp - 32] = block_cdLU2_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udLUi; else goto cdLU3;
       udLUi: // global
           call _cdLU2(R1) args: 0, res: 0, upd: 0;
       cdLU3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLU2() //  [R1]
         { info_tbl: [(cdLU2,
                       label: block_cdLU2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLU2: // global
           _sdLbX::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdLU6; else goto cdLU7;
       cdLU6: // global
           R3 = _sdLbX::P64;
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLU7: // global
           R3 = _sdLbX::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.833572697 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldl_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdLUu,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLUu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdLUv; else goto cdLUw;
       cdLUv: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLUw: // global
           I64[Sp - 32] = block_cdLUn_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udLUD; else goto cdLUo;
       udLUD: // global
           call _cdLUn(R1) args: 0, res: 0, upd: 0;
       cdLUo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdLUn() //  [R1]
         { info_tbl: [(cdLUn,
                       label: block_cdLUn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLUn: // global
           _sdLc4::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdLUr; else goto cdLUs;
       cdLUr: // global
           R3 = P64[R1 + 7];
           R2 = _sdLc4::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLUs: // global
           R3 = P64[R1 + 6];
           R2 = _sdLc4::P64;
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.834767169 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_closure" {
     Data.Bifoldable.$fBifoldableEither_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableEither_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.83559685 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLUK,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLUK: // global
           _sdLca::P64 = R3;
           _sdLc9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLUL; else goto cdLUM;
       cdLUM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLUO; else goto cdLUN;
       cdLUO: // global
           HpAlloc = 48;
           goto cdLUL;
       cdLUL: // global
           R3 = _sdLca::P64;
           R2 = _sdLc9::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLUN: // global
           I64[Hp - 40] = stg_sel_6_upd_info;
           P64[Hp - 24] = _sdLca::P64;
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLca::P64;
           R2 = _sdLc9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.836933788 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_info;
 },
 sat_sdLcP_entry() //  [R1]
         { info_tbl: [(cdLUY,
                       label: sat_sdLcP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLUY: // global
           _sdLcP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLUZ; else goto cdLV0;
       cdLV0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLV2; else goto cdLV1;
       cdLV2: // global
           HpAlloc = 24;
           goto cdLUZ;
       cdLUZ: // global
           R1 = _sdLcP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLV1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLcP::P64;
           _sdLcu::P64 = P64[_sdLcP::P64 + 16];
           _sdLcv::P64 = P64[_sdLcP::P64 + 24];
           _sdLcw::P64 = P64[_sdLcP::P64 + 32];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdLcw::P64;
           R3 = _sdLcv::P64;
           R2 = Hp - 16;
           R1 = _sdLcu::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdLV4,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLV4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLV8; else goto cdLV7;
       cdLV8: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLV7: // global
           I64[Hp - 56] = sat_sdLcP_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLct::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLct::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.838695398 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_info;
 },
 sat_sdLd3_entry() //  [R1]
         { info_tbl: [(cdLVj,
                       label: sat_sdLd3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLVj: // global
           _sdLd3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLVk; else goto cdLVl;
       cdLVl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLVn; else goto cdLVm;
       cdLVn: // global
           HpAlloc = 24;
           goto cdLVk;
       cdLVk: // global
           R1 = _sdLd3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLVm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLd3::P64;
           _sdLcQ::P64 = P64[_sdLd3::P64 + 16];
           _sdLcS::P64 = P64[_sdLd3::P64 + 24];
           _sdLcT::P64 = P64[_sdLd3::P64 + 32];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLcT::P64;
           R3 = Hp - 16;
           R2 = _sdLcS::P64;
           R1 = _sdLcQ::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdLVo,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLVo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLVs; else goto cdLVr;
       cdLVs: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLVr: // global
           I64[Hp - 56] = stg_sel_6_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLd3_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLcR::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLcR::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.839974453 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.840813042 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLVz,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLVz: // global
           _sdLde::P64 = R3;
           _sdLdd::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLVA; else goto cdLVB;
       cdLVB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLVD; else goto cdLVC;
       cdLVD: // global
           HpAlloc = 48;
           goto cdLVA;
       cdLVA: // global
           R3 = _sdLde::P64;
           R2 = _sdLdd::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLVC: // global
           I64[Hp - 40] = stg_sel_5_upd_info;
           P64[Hp - 24] = _sdLde::P64;
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLde::P64;
           R2 = _sdLdd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.842194602 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_info;
 },
 sat_sdLdP_entry() //  [R1]
         { info_tbl: [(cdLVN,
                       label: sat_sdLdP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLVN: // global
           _sdLdP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLVO; else goto cdLVP;
       cdLVP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLVR; else goto cdLVQ;
       cdLVR: // global
           HpAlloc = 24;
           goto cdLVO;
       cdLVO: // global
           R1 = _sdLdP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLVQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLdP::P64;
           _sdLdw::P64 = P64[_sdLdP::P64 + 16];
           _sdLdx::P64 = P64[_sdLdP::P64 + 24];
           _sdLdy::P64 = P64[_sdLdP::P64 + 32];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLdy::P64;
           R3 = _sdLdx::P64;
           R2 = Hp - 16;
           R1 = _sdLdw::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdLVT,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLVT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLVX; else goto cdLVW;
       cdLVX: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLVW: // global
           I64[Hp - 56] = sat_sdLdP_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLdv::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLdv::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.843898986 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_info;
 },
 sat_sdLe2_entry() //  [R1]
         { info_tbl: [(cdLW8,
                       label: sat_sdLe2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLW8: // global
           _sdLe2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLW9; else goto cdLWa;
       cdLWa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLWc; else goto cdLWb;
       cdLWc: // global
           HpAlloc = 24;
           goto cdLW9;
       cdLW9: // global
           R1 = _sdLe2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLWb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLe2::P64;
           _sdLdQ::P64 = P64[_sdLe2::P64 + 16];
           _sdLdS::P64 = P64[_sdLe2::P64 + 24];
           _sdLdT::P64 = P64[_sdLe2::P64 + 32];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLdT::P64;
           R3 = Hp - 16;
           R2 = _sdLdS::P64;
           R1 = _sdLdQ::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdLWd,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLWd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLWh; else goto cdLWg;
       cdLWh: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLWg: // global
           I64[Hp - 56] = stg_sel_5_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLe2_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLdR::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLdR::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.845215512 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.846068626 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLWo,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLWo: // global
           _sdLec::P64 = R3;
           _sdLeb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLWp; else goto cdLWq;
       cdLWq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLWs; else goto cdLWr;
       cdLWs: // global
           HpAlloc = 48;
           goto cdLWp;
       cdLWp: // global
           R3 = _sdLec::P64;
           R2 = _sdLeb::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLWr: // global
           I64[Hp - 40] = stg_sel_4_upd_info;
           P64[Hp - 24] = _sdLec::P64;
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLec::P64;
           R2 = _sdLeb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.847396583 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_info;
 },
 sat_sdLeJ_entry() //  [R1]
         { info_tbl: [(cdLWC,
                       label: sat_sdLeJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLWC: // global
           _sdLeJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLWD; else goto cdLWE;
       cdLWE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLWG; else goto cdLWF;
       cdLWG: // global
           HpAlloc = 24;
           goto cdLWD;
       cdLWD: // global
           R1 = _sdLeJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLWF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLeJ::P64;
           _sdLes::P64 = P64[_sdLeJ::P64 + 16];
           _sdLet::P64 = P64[_sdLeJ::P64 + 24];
           _sdLeu::P64 = P64[_sdLeJ::P64 + 32];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLeu::P64;
           R3 = _sdLet::P64;
           R2 = Hp - 16;
           R1 = _sdLes::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdLWI,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLWI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLWM; else goto cdLWL;
       cdLWM: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLWL: // global
           I64[Hp - 56] = sat_sdLeJ_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLer::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLer::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.849108903 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_info;
 },
 sat_sdLeV_entry() //  [R1]
         { info_tbl: [(cdLWX,
                       label: sat_sdLeV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLWX: // global
           _sdLeV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLWY; else goto cdLWZ;
       cdLWZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLX1; else goto cdLX0;
       cdLX1: // global
           HpAlloc = 24;
           goto cdLWY;
       cdLWY: // global
           R1 = _sdLeV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLX0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLeV::P64;
           _sdLeK::P64 = P64[_sdLeV::P64 + 16];
           _sdLeM::P64 = P64[_sdLeV::P64 + 24];
           _sdLeN::P64 = P64[_sdLeV::P64 + 32];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLeN::P64;
           R3 = Hp - 16;
           R2 = _sdLeM::P64;
           R1 = _sdLeK::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdLX2,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLX2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLX6; else goto cdLX5;
       cdLX6: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLX5: // global
           I64[Hp - 56] = stg_sel_4_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLeV_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLeL::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLeL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.850744659 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.851586535 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLXd,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLXd: // global
           _sdLf4::P64 = R3;
           _sdLf3::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLXe; else goto cdLXf;
       cdLXf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLXh; else goto cdLXg;
       cdLXh: // global
           HpAlloc = 48;
           goto cdLXe;
       cdLXe: // global
           R3 = _sdLf4::P64;
           R2 = _sdLf3::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLXg: // global
           I64[Hp - 40] = stg_sel_3_upd_info;
           P64[Hp - 24] = _sdLf4::P64;
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdLf4::P64;
           R2 = _sdLf3::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.852938875 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_info;
 },
 sat_sdLfx_entry() //  [R1]
         { info_tbl: [(cdLXr,
                       label: sat_sdLfx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLXr: // global
           _sdLfx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLXs; else goto cdLXt;
       cdLXt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLXv; else goto cdLXu;
       cdLXv: // global
           HpAlloc = 24;
           goto cdLXs;
       cdLXs: // global
           R1 = _sdLfx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLXu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLfx::P64;
           _sdLfi::P64 = P64[_sdLfx::P64 + 16];
           _sdLfj::P64 = P64[_sdLfx::P64 + 24];
           _sdLfk::P64 = P64[_sdLfx::P64 + 32];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLfk::P64;
           R3 = _sdLfj::P64;
           R2 = Hp - 16;
           R1 = _sdLfi::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdLXx,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLXx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLXB; else goto cdLXA;
       cdLXB: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLXA: // global
           I64[Hp - 56] = sat_sdLfx_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLfh::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLfh::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.854640374 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_info;
 },
 sat_sdLfI_entry() //  [R1]
         { info_tbl: [(cdLXM,
                       label: sat_sdLfI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLXM: // global
           _sdLfI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLXN; else goto cdLXO;
       cdLXO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLXQ; else goto cdLXP;
       cdLXQ: // global
           HpAlloc = 24;
           goto cdLXN;
       cdLXN: // global
           R1 = _sdLfI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLXP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLfI::P64;
           _sdLfy::P64 = P64[_sdLfI::P64 + 16];
           _sdLfA::P64 = P64[_sdLfI::P64 + 24];
           _sdLfB::P64 = P64[_sdLfI::P64 + 32];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdLfB::P64;
           R3 = Hp - 16;
           R2 = _sdLfA::P64;
           R1 = _sdLfy::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdLXR,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLXR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLXV; else goto cdLXU;
       cdLXV: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLXU: // global
           I64[Hp - 56] = stg_sel_3_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLfI_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLfz::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLfz::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.855977738 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.85675822 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLY2,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLY2: // global
           _sdLfQ::P64 = R3;
           _sdLfP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLY3; else goto cdLY4;
       cdLY4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLY6; else goto cdLY5;
       cdLY6: // global
           HpAlloc = 48;
           goto cdLY3;
       cdLY3: // global
           R3 = _sdLfQ::P64;
           R2 = _sdLfP::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLY5: // global
           I64[Hp - 40] = stg_sel_2_upd_info;
           P64[Hp - 24] = _sdLfQ::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdLfQ::P64;
           R2 = _sdLfP::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.858112848 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_info;
 },
 sat_sdLgf_entry() //  [R1]
         { info_tbl: [(cdLYg,
                       label: sat_sdLgf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLYg: // global
           _sdLgf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLYh; else goto cdLYi;
       cdLYi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLYk; else goto cdLYj;
       cdLYk: // global
           HpAlloc = 24;
           goto cdLYh;
       cdLYh: // global
           R1 = _sdLgf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLYj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLgf::P64;
           _sdLg2::P64 = P64[_sdLgf::P64 + 16];
           _sdLg3::P64 = P64[_sdLgf::P64 + 24];
           _sdLg4::P64 = P64[_sdLgf::P64 + 32];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdLg4::P64;
           R3 = _sdLg3::P64;
           R2 = Hp - 16;
           R1 = _sdLg2::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdLYm,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLYm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLYq; else goto cdLYp;
       cdLYq: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLYp: // global
           I64[Hp - 56] = sat_sdLgf_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLg1::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLg1::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.859796522 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_info;
 },
 sat_sdLgp_entry() //  [R1]
         { info_tbl: [(cdLYB,
                       label: sat_sdLgp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLYB: // global
           _sdLgp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLYC; else goto cdLYD;
       cdLYD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLYF; else goto cdLYE;
       cdLYF: // global
           HpAlloc = 24;
           goto cdLYC;
       cdLYC: // global
           R1 = _sdLgp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLYE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLgp::P64;
           _sdLgg::P64 = P64[_sdLgp::P64 + 16];
           _sdLgi::P64 = P64[_sdLgp::P64 + 24];
           _sdLgj::P64 = P64[_sdLgp::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdLgj::P64;
           R3 = Hp - 16;
           R2 = _sdLgi::P64;
           R1 = _sdLgg::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdLYG,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLYG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLYK; else goto cdLYJ;
       cdLYK: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLYJ: // global
           I64[Hp - 56] = stg_sel_2_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLgp_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLgh::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLgh::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.861131757 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.861925301 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK2_closure" {
     Data.Bifoldable.$fBifoldableK2_closure:
         const Data.Bifoldable.$fBifoldableK2_info;
 },
 Data.Bifoldable.$fBifoldableK2_entry() //  [R3]
         { info_tbl: [(cdLYP,
                       label: Data.Bifoldable.$fBifoldableK2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLYP: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.862790123 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldr_entry() //  [R2, R4, R5]
         { info_tbl: [(cdLYW,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLYW: // global
           R3 = R4;
           _sdLgx::P64 = R2;
           R2 = R5;
           R1 = _sdLgx::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.863675748 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldl_entry() //  [R2, R4, R5]
         { info_tbl: [(cdLZ3,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLZ3: // global
           R3 = R5;
           _sdLgB::P64 = R2;
           R2 = R4;
           R1 = _sdLgB::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.86443312 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_closure" {
     Data.Bifoldable.$fBifoldableK1_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableK2_closure+2;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.8651543 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst1_closure" {
     Data.Bifoldable.$fBifoldableConst1_closure:
         const Data.Bifoldable.$fBifoldableConst1_info;
 },
 Data.Bifoldable.$fBifoldableConst1_entry() //  [R3]
         { info_tbl: [(cdLZa,
                       label: Data.Bifoldable.$fBifoldableConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLZa: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.866397581 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldr_entry() //  [R2, R4,
                                                          R5]
         { info_tbl: [(cdLZh,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLZh: // global
           R3 = R4;
           _sdLgH::P64 = R2;
           R2 = R5;
           R1 = _sdLgH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.867323442 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldl_entry() //  [R2, R4,
                                                          R5]
         { info_tbl: [(cdLZo,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLZo: // global
           R3 = R5;
           _sdLgL::P64 = R2;
           R2 = R4;
           R1 = _sdLgL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.868135539 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_closure" {
     Data.Bifoldable.$fBifoldableConst_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableConst1_closure+2;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.86899005 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdLZx,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLZx: // global
           _sdLgQ::P64 = R3;
           _sdLgP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLZy; else goto cdLZz;
       cdLZz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdLZB; else goto cdLZA;
       cdLZB: // global
           HpAlloc = 48;
           goto cdLZy;
       cdLZy: // global
           R3 = _sdLgQ::P64;
           R2 = _sdLgP::P64;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLZA: // global
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sdLgQ::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdLgQ::P64;
           R2 = _sdLgP::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.870469911 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldr_info;
 },
 sat_sdLhb_entry() //  [R1]
         { info_tbl: [(cdLZL,
                       label: sat_sdLhb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLZL: // global
           _sdLhb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLZM; else goto cdLZN;
       cdLZN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdLZP; else goto cdLZO;
       cdLZP: // global
           HpAlloc = 24;
           goto cdLZM;
       cdLZM: // global
           R1 = _sdLhb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdLZO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLhb::P64;
           _sdLh0::P64 = P64[_sdLhb::P64 + 16];
           _sdLh1::P64 = P64[_sdLhb::P64 + 24];
           _sdLh2::P64 = P64[_sdLhb::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdLh2::P64;
           R3 = _sdLh1::P64;
           R2 = Hp - 16;
           R1 = _sdLh0::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldr_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdLZR,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLZR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLZV; else goto cdLZU;
       cdLZV: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdLZU: // global
           I64[Hp - 56] = sat_sdLhb_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLgZ::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLgZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.872307728 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldl_info;
 },
 sat_sdLhk_entry() //  [R1]
         { info_tbl: [(cdM06,
                       label: sat_sdLhk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM06: // global
           _sdLhk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdM07; else goto cdM08;
       cdM08: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdM0a; else goto cdM09;
       cdM0a: // global
           HpAlloc = 24;
           goto cdM07;
       cdM07: // global
           R1 = _sdLhk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM09: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLhk::P64;
           _sdLhc::P64 = P64[_sdLhk::P64 + 16];
           _sdLhe::P64 = P64[_sdLhk::P64 + 24];
           _sdLhf::P64 = P64[_sdLhk::P64 + 32];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdLhf::P64;
           R3 = Hp - 16;
           R2 = _sdLhe::P64;
           R1 = _sdLhc::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldl_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdM0b,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM0b: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdM0f; else goto cdM0e;
       cdM0f: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM0e: // global
           I64[Hp - 56] = stg_sel_1_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLhk_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLhd::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLhd::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.875121528 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_closure" {
     Data.Bifoldable.$fBifoldable(,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.876409613 UTC

[section ""data" . Data.Bifoldable.bifoldr'_closure" {
     Data.Bifoldable.bifoldr'_closure:
         const Data.Bifoldable.bifoldr'_info;
 },
 sat_sdLhD_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdM0r,
                       label: sat_sdLhD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM0r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM0s; else goto cdM0t;
       cdM0s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM0t: // global
           I64[Sp - 16] = block_cdM0p_info;
           _sdLhA::P64 = R3;
           R3 = R4;
           _sdLhz::P64 = R2;
           R2 = _sdLhA::P64;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLhz::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdM0p() //  [R1]
         { info_tbl: [(cdM0p,
                       label: block_cdM0p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM0p: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLhy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdM0C,
                       label: sat_sdLhy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM0C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM0D; else goto cdM0E;
       cdM0D: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM0E: // global
           I64[Sp - 16] = block_cdM0A_info;
           _sdLhv::P64 = R3;
           R3 = R4;
           _sdLhu::P64 = R2;
           R2 = _sdLhv::P64;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLhu::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdM0A() //  [R1]
         { info_tbl: [(cdM0A,
                       label: block_cdM0A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM0A: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldr'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdM0G,
                       label: Data.Bifoldable.bifoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM0G: // global
           _sdLht::P64 = R6;
           _sdLhs::P64 = R5;
           _sdLhr::P64 = R4;
           _sdLhq::P64 = R3;
           _sdLhp::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdM0H; else goto cdM0I;
       cdM0I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdM0K; else goto cdM0J;
       cdM0K: // global
           HpAlloc = 32;
           goto cdM0H;
       cdM0H: // global
           R6 = _sdLht::P64;
           R5 = _sdLhs::P64;
           R4 = _sdLhr::P64;
           R3 = _sdLhq::P64;
           R2 = _sdLhp::P64;
           R1 = Data.Bifoldable.bifoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM0J: // global
           I64[Hp - 24] = sat_sdLhD_info;
           P64[Hp - 16] = _sdLhr::P64;
           I64[Hp - 8] = sat_sdLhy_info;
           P64[Hp] = _sdLhq::P64;
           R2 = _sdLhp::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Hp - 5;
           P64[Sp - 32] = Hp - 21;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = _sdLht::P64;
           P64[Sp - 8] = _sdLhs::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldl_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.878340299 UTC

[section ""cstring" . lvl_rdL8s_bytes" {
     lvl_rdL8s_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.879124419 UTC

[section ""data" . lvl1_rdL8t_closure" {
     lvl1_rdL8t_closure:
         const lvl1_rdL8t_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rdL8t_entry() //  [R1]
         { info_tbl: [(cdM0R,
                       label: lvl1_rdL8t_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM0R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM0S; else goto cdM0T;
       cdM0S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM0T: // global
           (_cdM0O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdM0O::I64 == 0) goto cdM0Q; else goto cdM0P;
       cdM0Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdM0P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdM0O::I64;
           R2 = lvl_rdL8s_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.880055671 UTC

[section ""cstring" . Data.Bifoldable.$trModule4_bytes" {
     Data.Bifoldable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.88081978 UTC

[section ""data" . lvl2_rdL8u_closure" {
     lvl2_rdL8u_closure:
         const lvl2_rdL8u_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdL8u_entry() //  [R1]
         { info_tbl: [(cdM10,
                       label: lvl2_rdL8u_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM10: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM11; else goto cdM12;
       cdM11: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM12: // global
           (_cdM0X::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdM0X::I64 == 0) goto cdM0Z; else goto cdM0Y;
       cdM0Z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdM0Y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdM0X::I64;
           R2 = Data.Bifoldable.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.881765287 UTC

[section ""cstring" . Data.Bifoldable.$trModule2_bytes" {
     Data.Bifoldable.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,102,111,108,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.882499098 UTC

[section ""data" . lvl3_rdL8v_closure" {
     lvl3_rdL8v_closure:
         const lvl3_rdL8v_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdL8v_entry() //  [R1]
         { info_tbl: [(cdM19,
                       label: lvl3_rdL8v_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM19: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM1a; else goto cdM1b;
       cdM1a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM1b: // global
           (_cdM16::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdM16::I64 == 0) goto cdM18; else goto cdM17;
       cdM18: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdM17: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdM16::I64;
           R2 = Data.Bifoldable.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.883382187 UTC

[section ""cstring" . lvl4_rdL8w_bytes" {
     lvl4_rdL8w_bytes:
         I8[] [46,47,68,97,116,97,47,66,105,102,111,108,100,97,98,108,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.884127372 UTC

[section ""data" . lvl5_rdL8x_closure" {
     lvl5_rdL8x_closure:
         const lvl5_rdL8x_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rdL8x_entry() //  [R1]
         { info_tbl: [(cdM1i,
                       label: lvl5_rdL8x_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM1i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM1j; else goto cdM1k;
       cdM1j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM1k: // global
           (_cdM1f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdM1f::I64 == 0) goto cdM1h; else goto cdM1g;
       cdM1h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdM1g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdM1f::I64;
           R2 = lvl4_rdL8w_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.885053495 UTC

[section ""data" . lvl6_rdL8y_closure" {
     lvl6_rdL8y_closure:
         const GHC.Types.I#_con_info;
         const 188;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.885987328 UTC

[section ""data" . lvl7_rdL8z_closure" {
     lvl7_rdL8z_closure:
         const GHC.Types.I#_con_info;
         const 28;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.886489348 UTC

[section ""data" . lvl8_rdL8A_closure" {
     lvl8_rdL8A_closure:
         const GHC.Types.I#_con_info;
         const 61;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.887051144 UTC

[section ""data" . lvl9_rdL8B_closure" {
     lvl9_rdL8B_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl6_rdL8y_closure+1;
         const lvl7_rdL8z_closure+1;
         const lvl6_rdL8y_closure+1;
         const lvl8_rdL8A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.88766052 UTC

[section ""data" . lvl10_rdL8C_closure" {
     lvl10_rdL8C_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl9_rdL8B_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.888258403 UTC

[section ""cstring" . lvl11_rdL8D_bytes" {
     lvl11_rdL8D_bytes:
         I8[] [98,105,102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.889173228 UTC

[section ""data" . Data.Bifoldable.bifoldr2_closure" {
     Data.Bifoldable.bifoldr2_closure:
         const Data.Bifoldable.bifoldr2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bifoldr2_entry() //  [R1]
         { info_tbl: [(cdM1t,
                       label: Data.Bifoldable.bifoldr2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM1t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdM1u; else goto cdM1v;
       cdM1u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM1v: // global
           (_cdM1o::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdM1o::I64 == 0) goto cdM1q; else goto cdM1p;
       cdM1q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdM1p: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdM1o::I64;
           I64[Sp - 24] = block_cdM1r_info;
           R2 = lvl11_rdL8D_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdM1r() //  [R1]
         { info_tbl: [(cdM1r,
                       label: block_cdM1r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM1r: // global
           R3 = R1;
           R2 = lvl10_rdL8C_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.891269534 UTC

[section ""data" . Data.Bifoldable.bifoldr1_closure" {
     Data.Bifoldable.bifoldr1_closure:
         const Data.Bifoldable.bifoldr1_info;
         const 0;
 },
 sat_sdLhN_entry() //  [R1]
         { info_tbl: [(cdM1T,
                       label: sat_sdLhN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM1T: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdM1U; else goto cdM1V;
       cdM1U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM1V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdM1M_info;
           _sdLhG::P64 = P64[R1 + 16];
           _sdLhJ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdLhG::P64;
           P64[Sp - 24] = _sdLhJ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udM22; else goto cdM1N;
       udM22: // global
           call _cdM1M(R1) args: 0, res: 0, upd: 0;
       cdM1N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdM1M() //  [R1]
         { info_tbl: [(cdM1M,
                       label: block_cdM1M_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM1M: // global
           _sdLhJ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdM1Q; else goto cdM1R;
       cdM1Q: // global
           R1 = _sdLhJ::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cdM1R: // global
           R3 = P64[R1 + 6];
           R2 = _sdLhJ::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLhI_entry() //  [R1, R2, R3]
         { info_tbl: [(cdM24,
                       label: mbf_sdLhI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM24: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdM28; else goto cdM27;
       cdM28: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM27: // global
           _sdLhG::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLhN_info;
           P64[Hp - 32] = _sdLhG::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldr1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdM2f,
                       label: Data.Bifoldable.bifoldr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM2f: // global
           _sdLhH::P64 = R4;
           _sdLhG::P64 = R3;
           _sdLhF::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdM2g; else goto cdM2h;
       cdM2h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdM2j; else goto cdM2i;
       cdM2j: // global
           HpAlloc = 16;
           goto cdM2g;
       cdM2g: // global
           R4 = _sdLhH::P64;
           R3 = _sdLhG::P64;
           R2 = _sdLhF::P64;
           R1 = Data.Bifoldable.bifoldr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM2i: // global
           I64[Hp - 8] = mbf_sdLhI_info;
           P64[Hp] = _sdLhG::P64;
           I64[Sp - 8] = block_cdM29_info;
           R2 = _sdLhF::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdM1D::P64 = Hp - 6;
           P64[Sp - 40] = _cdM1D::P64;
           P64[Sp - 32] = _cdM1D::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLhH::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdM29() //  [R1]
         { info_tbl: [(cdM29,
                       label: block_cdM29_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM29: // global
           if (R1 & 7 == 1) goto cdM2c; else goto cdM2d;
       cdM2c: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdM2d: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.894528272 UTC

[section ""data" . Data.Bifoldable.bimaximumBy_closure" {
     Data.Bifoldable.bimaximumBy_closure:
         const Data.Bifoldable.bimaximumBy_info;
         const 0;
 },
 sat_sdLhZ_entry() //  [R1]
         { info_tbl: [(cdM2K,
                       label: sat_sdLhZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM2K: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdM2L; else goto cdM2M;
       cdM2L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM2M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdM2D_info;
           _sdLhR::P64 = P64[R1 + 16];
           _sdLhU::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdLhR::P64;
           P64[Sp - 24] = _sdLhU::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udM38; else goto cdM2E;
       udM38: // global
           call _cdM2D(R1) args: 0, res: 0, upd: 0;
       cdM2E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdM2D() //  [R1]
         { info_tbl: [(cdM2D,
                       label: block_cdM2D_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM2D: // global
           if (R1 & 7 == 1) goto udM35; else goto cdM2I;
       udM35: // global
           Sp = Sp + 16;
           call _cdM33() args: 0, res: 0, upd: 0;
       cdM2I: // global
           I64[Sp] = block_cdM2S_info;
           _sdLhX::P64 = P64[R1 + 6];
           R3 = _sdLhX::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdLhX::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdM2S() //  [R1]
         { info_tbl: [(cdM2S,
                       label: block_cdM2S_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM2S: // global
           if (R1 & 7 == 3) goto udM36; else goto cdM2Z;
       udM36: // global
           Sp = Sp + 16;
           call _cdM33() args: 0, res: 0, upd: 0;
       cdM2Z: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cdM33() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM33: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLhT_entry() //  [R1, R2, R3]
         { info_tbl: [(cdM3b,
                       label: mbf_sdLhT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM3b: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdM3f; else goto cdM3e;
       cdM3f: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM3e: // global
           _sdLhR::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLhZ_info;
           P64[Hp - 32] = _sdLhR::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bimaximumBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdM3m,
                       label: Data.Bifoldable.bimaximumBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM3m: // global
           _sdLhS::P64 = R4;
           _sdLhR::P64 = R3;
           _sdLhQ::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdM3n; else goto cdM3o;
       cdM3o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdM3q; else goto cdM3p;
       cdM3q: // global
           HpAlloc = 16;
           goto cdM3n;
       cdM3n: // global
           R4 = _sdLhS::P64;
           R3 = _sdLhR::P64;
           R2 = _sdLhQ::P64;
           R1 = Data.Bifoldable.bimaximumBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM3p: // global
           I64[Hp - 8] = mbf_sdLhT_info;
           P64[Hp] = _sdLhR::P64;
           I64[Sp - 8] = block_cdM3g_info;
           R2 = _sdLhQ::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdM2u::P64 = Hp - 6;
           P64[Sp - 40] = _cdM2u::P64;
           P64[Sp - 32] = _cdM2u::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLhS::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdM3g() //  [R1]
         { info_tbl: [(cdM3g,
                       label: block_cdM3g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM3g: // global
           if (R1 & 7 == 1) goto cdM3j; else goto cdM3k;
       cdM3j: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdM3k: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.898142561 UTC

[section ""data" . Data.Bifoldable.biminimumBy_closure" {
     Data.Bifoldable.biminimumBy_closure:
         const Data.Bifoldable.biminimumBy_info;
         const 0;
 },
 sat_sdLib_entry() //  [R1]
         { info_tbl: [(cdM3R,
                       label: sat_sdLib_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM3R: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdM3S; else goto cdM3T;
       cdM3S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM3T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdM3K_info;
           _sdLi3::P64 = P64[R1 + 16];
           _sdLi6::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdLi3::P64;
           P64[Sp - 24] = _sdLi6::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udM4f; else goto cdM3L;
       udM4f: // global
           call _cdM3K(R1) args: 0, res: 0, upd: 0;
       cdM3L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdM3K() //  [R1]
         { info_tbl: [(cdM3K,
                       label: block_cdM3K_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM3K: // global
           if (R1 & 7 == 1) goto udM4c; else goto cdM3P;
       udM4c: // global
           Sp = Sp + 16;
           call _cdM46() args: 0, res: 0, upd: 0;
       cdM3P: // global
           I64[Sp] = block_cdM3Z_info;
           _sdLi9::P64 = P64[R1 + 6];
           R3 = _sdLi9::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdLi9::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdM3Z() //  [R1]
         { info_tbl: [(cdM3Z,
                       label: block_cdM3Z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM3Z: // global
           if (R1 & 7 == 3) goto cdM4a; else goto udM4d;
       cdM4a: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       udM4d: // global
           Sp = Sp + 16;
           call _cdM46() args: 0, res: 0, upd: 0;
     }
 },
 _cdM46() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM46: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLi5_entry() //  [R1, R2, R3]
         { info_tbl: [(cdM4i,
                       label: mbf_sdLi5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM4i: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdM4m; else goto cdM4l;
       cdM4m: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM4l: // global
           _sdLi3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLib_info;
           P64[Hp - 32] = _sdLi3::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biminimumBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdM4t,
                       label: Data.Bifoldable.biminimumBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM4t: // global
           _sdLi4::P64 = R4;
           _sdLi3::P64 = R3;
           _sdLi2::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdM4u; else goto cdM4v;
       cdM4v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdM4x; else goto cdM4w;
       cdM4x: // global
           HpAlloc = 16;
           goto cdM4u;
       cdM4u: // global
           R4 = _sdLi4::P64;
           R3 = _sdLi3::P64;
           R2 = _sdLi2::P64;
           R1 = Data.Bifoldable.biminimumBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM4w: // global
           I64[Hp - 8] = mbf_sdLi5_info;
           P64[Hp] = _sdLi3::P64;
           I64[Sp - 8] = block_cdM4n_info;
           R2 = _sdLi2::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdM3B::P64 = Hp - 6;
           P64[Sp - 40] = _cdM3B::P64;
           P64[Sp - 32] = _cdM3B::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLi4::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdM4n() //  [R1]
         { info_tbl: [(cdM4n,
                       label: block_cdM4n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM4n: // global
           if (R1 & 7 == 1) goto cdM4q; else goto cdM4r;
       cdM4q: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdM4r: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.90167141 UTC

[section ""data" . Data.Bifoldable.bifoldrM_closure" {
     Data.Bifoldable.bifoldrM_closure:
         const Data.Bifoldable.bifoldrM_info;
 },
 sat_sdLiu_entry() //  [R1]
         { info_tbl: [(cdM4M,
                       label: sat_sdLiu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM4M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM4N; else goto cdM4O;
       cdM4N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM4O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLit_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdM4V,
                       label: sat_sdLit_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM4V: // global
           _sdLir::P64 = R4;
           _sdLiq::P64 = R3;
           _sdLip::P64 = R2;
           _sdLit::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdM4W; else goto cdM4X;
       cdM4X: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdM4Z; else goto cdM4Y;
       cdM4Z: // global
           HpAlloc = 40;
           goto cdM4W;
       cdM4W: // global
           R4 = _sdLir::P64;
           R3 = _sdLiq::P64;
           R2 = _sdLip::P64;
           R1 = _sdLit::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM4Y: // global
           _sdLif::P64 = P64[_sdLit::P64 + 5];
           _sdLih::P64 = P64[_sdLit::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLih::P64;
           P64[Hp - 8] = _sdLiq::P64;
           P64[Hp] = _sdLir::P64;
           R2 = _sdLif::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLip::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdLio_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdM56,
                       label: sat_sdLio_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM56: // global
           _sdLim::P64 = R4;
           _sdLil::P64 = R3;
           _sdLik::P64 = R2;
           _sdLio::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdM57; else goto cdM58;
       cdM58: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdM5a; else goto cdM59;
       cdM5a: // global
           HpAlloc = 40;
           goto cdM57;
       cdM57: // global
           R4 = _sdLim::P64;
           R3 = _sdLil::P64;
           R2 = _sdLik::P64;
           R1 = _sdLio::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM59: // global
           _sdLif::P64 = P64[_sdLio::P64 + 5];
           _sdLig::P64 = P64[_sdLio::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLig::P64;
           P64[Hp - 8] = _sdLil::P64;
           P64[Hp] = _sdLim::P64;
           R2 = _sdLif::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLik::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldrM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdM5b,
                       label: Data.Bifoldable.bifoldrM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM5b: // global
           _sdLii::P64 = R6;
           _sdLih::P64 = R5;
           _sdLig::P64 = R4;
           _sdLif::P64 = R3;
           _sdLie::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdM5c; else goto cdM5d;
       cdM5d: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdM5f; else goto cdM5e;
       cdM5f: // global
           HpAlloc = 72;
           goto cdM5c;
       cdM5c: // global
           R6 = _sdLii::P64;
           R5 = _sdLih::P64;
           R4 = _sdLig::P64;
           R3 = _sdLif::P64;
           R2 = _sdLie::P64;
           R1 = Data.Bifoldable.bifoldrM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdM5e: // global
           I64[Hp - 64] = sat_sdLiu_info;
           P64[Hp - 48] = _sdLif::P64;
           I64[Hp - 40] = sat_sdLit_info;
           P64[Hp - 32] = _sdLif::P64;
           P64[Hp - 24] = _sdLih::P64;
           I64[Hp - 16] = sat_sdLio_info;
           P64[Hp - 8] = _sdLif::P64;
           P64[Hp] = _sdLig::P64;
           R2 = _sdLie::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = Hp - 37;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = _sdLii::P64;
           Sp = Sp - 40;
           call Data.Bifoldable.bifoldl_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.904766975 UTC

[section ""data" . Data.Bifoldable.bifoldl'_closure" {
     Data.Bifoldable.bifoldl'_closure:
         const Data.Bifoldable.bifoldl'_info;
 },
 sat_sdLiJ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdM5r,
                       label: sat_sdLiJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM5r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM5s; else goto cdM5t;
       cdM5s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM5t: // global
           I64[Sp - 16] = block_cdM5p_info;
           _sdLiG::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLiG::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdM5p() //  [R1]
         { info_tbl: [(cdM5p,
                       label: block_cdM5p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM5p: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLiE_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdM5C,
                       label: sat_sdLiE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM5C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM5D; else goto cdM5E;
       cdM5D: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM5E: // global
           I64[Sp - 16] = block_cdM5A_info;
           _sdLiB::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLiB::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdM5A() //  [R1]
         { info_tbl: [(cdM5A,
                       label: block_cdM5A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM5A: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldl'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdM5G,
                       label: Data.Bifoldable.bifoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM5G: // global
           _sdLiz::P64 = R6;
           _sdLiy::P64 = R5;
           _sdLix::P64 = R4;
           _sdLiw::P64 = R3;
           _sdLiv::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdM5H; else goto cdM5I;
       cdM5I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdM5K; else goto cdM5J;
       cdM5K: // global
           HpAlloc = 32;
           goto cdM5H;
       cdM5H: // global
           R6 = _sdLiz::P64;
           R5 = _sdLiy::P64;
           R4 = _sdLix::P64;
           R3 = _sdLiw::P64;
           R2 = _sdLiv::P64;
           R1 = Data.Bifoldable.bifoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM5J: // global
           I64[Hp - 24] = sat_sdLiJ_info;
           P64[Hp - 16] = _sdLix::P64;
           I64[Hp - 8] = sat_sdLiE_info;
           P64[Hp] = _sdLiw::P64;
           R2 = _sdLiv::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Hp - 5;
           P64[Sp - 32] = Hp - 21;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = _sdLiz::P64;
           P64[Sp - 8] = _sdLiy::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.907679787 UTC

[section ""data" . Data.Bifoldable.bilength2_closure" {
     Data.Bifoldable.bilength2_closure:
         const Data.Bifoldable.bilength2_info;
 },
 Data.Bifoldable.bilength2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdM5S,
                       label: Data.Bifoldable.bilength2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM5S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM5Z; else goto cdM60;
       cdM5Z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bilength2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM60: // global
           I64[Sp - 16] = block_cdM5P_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udM64; else goto cdM5Q;
       udM64: // global
           call _cdM5P(R1) args: 0, res: 0, upd: 0;
       cdM5Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdM5P() //  [R1]
         { info_tbl: [(cdM5P,
                       label: block_cdM5P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM5P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdM63; else goto cdM62;
       cdM63: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdM62: // global
           _sdLiP::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdLiP::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.90891362 UTC

[section ""data" . Data.Bifoldable.bilength1_closure" {
     Data.Bifoldable.bilength1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.909782437 UTC

[section ""data" . Data.Bifoldable.bilength_closure" {
     Data.Bifoldable.bilength_closure:
         const Data.Bifoldable.bilength_info;
 },
 Data.Bifoldable.bilength_entry() //  [R2, R3]
         { info_tbl: [(cdM69,
                       label: Data.Bifoldable.bilength_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM69: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdM6a; else goto cdM6b;
       cdM6a: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bilength_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM6b: // global
           R2 = R2;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Bifoldable.bilength2_closure+3;
           P64[Sp - 32] = Data.Bifoldable.bilength2_closure+3;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Data.Bifoldable.bilength1_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.910795598 UTC

[section ""data" . lvl12_rdL8E_closure" {
     lvl12_rdL8E_closure:
         const GHC.Types.I#_con_info;
         const 223;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.911468996 UTC

[section ""data" . lvl13_rdL8F_closure" {
     lvl13_rdL8F_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl12_rdL8E_closure+1;
         const lvl7_rdL8z_closure+1;
         const lvl12_rdL8E_closure+1;
         const lvl8_rdL8A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.912124084 UTC

[section ""data" . lvl14_rdL8G_closure" {
     lvl14_rdL8G_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl13_rdL8F_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.912772351 UTC

[section ""cstring" . lvl15_rdL8H_bytes" {
     lvl15_rdL8H_bytes:
         I8[] [98,105,102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.913761623 UTC

[section ""data" . Data.Bifoldable.bifoldl2_closure" {
     Data.Bifoldable.bifoldl2_closure:
         const Data.Bifoldable.bifoldl2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bifoldl2_entry() //  [R1]
         { info_tbl: [(cdM6k,
                       label: Data.Bifoldable.bifoldl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM6k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdM6l; else goto cdM6m;
       cdM6l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM6m: // global
           (_cdM6f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdM6f::I64 == 0) goto cdM6h; else goto cdM6g;
       cdM6h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdM6g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdM6f::I64;
           I64[Sp - 24] = block_cdM6i_info;
           R2 = lvl15_rdL8H_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdM6i() //  [R1]
         { info_tbl: [(cdM6i,
                       label: block_cdM6i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM6i: // global
           R3 = R1;
           R2 = lvl14_rdL8G_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.915882978 UTC

[section ""data" . Data.Bifoldable.bifoldl1_closure" {
     Data.Bifoldable.bifoldl1_closure:
         const Data.Bifoldable.bifoldl1_info;
         const 0;
 },
 sat_sdLj2_entry() //  [R1]
         { info_tbl: [(cdM6K,
                       label: sat_sdLj2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM6K: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdM6L; else goto cdM6M;
       cdM6L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM6M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdM6D_info;
           _sdLiV::P64 = P64[R1 + 16];
           _sdLiZ::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdLiV::P64;
           P64[Sp - 24] = _sdLiZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udM6T; else goto cdM6E;
       udM6T: // global
           call _cdM6D(R1) args: 0, res: 0, upd: 0;
       cdM6E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdM6D() //  [R1]
         { info_tbl: [(cdM6D,
                       label: block_cdM6D_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM6D: // global
           _sdLiZ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdM6H; else goto cdM6I;
       cdM6H: // global
           R1 = _sdLiZ::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cdM6I: // global
           R3 = _sdLiZ::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLiX_entry() //  [R1, R2, R3]
         { info_tbl: [(cdM6V,
                       label: mbf_sdLiX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM6V: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdM6Z; else goto cdM6Y;
       cdM6Z: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM6Y: // global
           _sdLiV::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLj2_info;
           P64[Hp - 32] = _sdLiV::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldl1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdM76,
                       label: Data.Bifoldable.bifoldl1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM76: // global
           _sdLiW::P64 = R4;
           _sdLiV::P64 = R3;
           _sdLiU::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdM77; else goto cdM78;
       cdM78: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdM7a; else goto cdM79;
       cdM7a: // global
           HpAlloc = 16;
           goto cdM77;
       cdM77: // global
           R4 = _sdLiW::P64;
           R3 = _sdLiV::P64;
           R2 = _sdLiU::P64;
           R1 = Data.Bifoldable.bifoldl1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM79: // global
           I64[Hp - 8] = mbf_sdLiX_info;
           P64[Hp] = _sdLiV::P64;
           I64[Sp - 8] = block_cdM70_info;
           R2 = _sdLiU::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdM6u::P64 = Hp - 6;
           P64[Sp - 40] = _cdM6u::P64;
           P64[Sp - 32] = _cdM6u::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLiW::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldl_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdM70() //  [R1]
         { info_tbl: [(cdM70,
                       label: block_cdM70_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM70: // global
           if (R1 & 7 == 1) goto cdM73; else goto cdM74;
       cdM73: // global
           R1 = Data.Bifoldable.bifoldl2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdM74: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.922508552 UTC

[section ""data" . Data.Bifoldable.bifoldlM_closure" {
     Data.Bifoldable.bifoldlM_closure:
         const Data.Bifoldable.bifoldlM_info;
 },
 sat_sdLjl_entry() //  [R1]
         { info_tbl: [(cdM7p,
                       label: sat_sdLjl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM7p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM7q; else goto cdM7r;
       cdM7q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM7r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdM7y,
                       label: sat_sdLjk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM7y: // global
           _sdLji::P64 = R4;
           _sdLjh::P64 = R3;
           _sdLjg::P64 = R2;
           _sdLjk::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdM7z; else goto cdM7A;
       cdM7A: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdM7C; else goto cdM7B;
       cdM7C: // global
           HpAlloc = 40;
           goto cdM7z;
       cdM7z: // global
           R4 = _sdLji::P64;
           R3 = _sdLjh::P64;
           R2 = _sdLjg::P64;
           R1 = _sdLjk::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM7B: // global
           _sdLj6::P64 = P64[_sdLjk::P64 + 5];
           _sdLj8::P64 = P64[_sdLjk::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLj8::P64;
           P64[Hp - 8] = _sdLji::P64;
           P64[Hp] = _sdLjg::P64;
           R2 = _sdLj6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLjh::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdLjf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdM7J,
                       label: sat_sdLjf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM7J: // global
           _sdLjd::P64 = R4;
           _sdLjc::P64 = R3;
           _sdLjb::P64 = R2;
           _sdLjf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdM7K; else goto cdM7L;
       cdM7L: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdM7N; else goto cdM7M;
       cdM7N: // global
           HpAlloc = 40;
           goto cdM7K;
       cdM7K: // global
           R4 = _sdLjd::P64;
           R3 = _sdLjc::P64;
           R2 = _sdLjb::P64;
           R1 = _sdLjf::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM7M: // global
           _sdLj6::P64 = P64[_sdLjf::P64 + 5];
           _sdLj7::P64 = P64[_sdLjf::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLj7::P64;
           P64[Hp - 8] = _sdLjd::P64;
           P64[Hp] = _sdLjb::P64;
           R2 = _sdLj6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLjc::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldlM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdM7O,
                       label: Data.Bifoldable.bifoldlM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM7O: // global
           _sdLj9::P64 = R6;
           _sdLj8::P64 = R5;
           _sdLj7::P64 = R4;
           _sdLj6::P64 = R3;
           _sdLj5::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdM7P; else goto cdM7Q;
       cdM7Q: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdM7S; else goto cdM7R;
       cdM7S: // global
           HpAlloc = 72;
           goto cdM7P;
       cdM7P: // global
           R6 = _sdLj9::P64;
           R5 = _sdLj8::P64;
           R4 = _sdLj7::P64;
           R3 = _sdLj6::P64;
           R2 = _sdLj5::P64;
           R1 = Data.Bifoldable.bifoldlM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdM7R: // global
           I64[Hp - 64] = sat_sdLjl_info;
           P64[Hp - 48] = _sdLj6::P64;
           I64[Hp - 40] = sat_sdLjk_info;
           P64[Hp - 32] = _sdLj6::P64;
           P64[Hp - 24] = _sdLj8::P64;
           I64[Hp - 16] = sat_sdLjf_info;
           P64[Hp - 8] = _sdLj6::P64;
           P64[Hp] = _sdLj7::P64;
           R2 = _sdLj5::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = Hp - 37;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = _sdLj9::P64;
           Sp = Sp - 40;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.925874696 UTC

[section ""data" . Data.Bifoldable.bitraverse__closure" {
     Data.Bifoldable.bitraverse__closure:
         const Data.Bifoldable.bitraverse__info;
 },
 sat_sdLjw_entry() //  [R1]
         { info_tbl: [(cdM81,
                       label: sat_sdLjw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM81: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdM82; else goto cdM83;
       cdM82: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM83: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sdLjv_entry() //  [R1, R2]
         { info_tbl: [(cdM8a,
                       label: sat_sdLjv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM8a: // global
           _sdLjt::P64 = R2;
           _sdLjv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdM8b; else goto cdM8c;
       cdM8c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdM8e; else goto cdM8d;
       cdM8e: // global
           HpAlloc = 32;
           goto cdM8b;
       cdM8b: // global
           R2 = _sdLjt::P64;
           R1 = _sdLjv::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdM8d: // global
           _sdLjn::P64 = P64[_sdLjv::P64 + 7];
           _sdLjp::P64 = P64[_sdLjv::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLjp::P64;
           P64[Hp] = _sdLjt::P64;
           R2 = _sdLjn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdLjs_entry() //  [R1, R2]
         { info_tbl: [(cdM8l,
                       label: sat_sdLjs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM8l: // global
           _sdLjq::P64 = R2;
           _sdLjs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdM8m; else goto cdM8n;
       cdM8n: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdM8p; else goto cdM8o;
       cdM8p: // global
           HpAlloc = 32;
           goto cdM8m;
       cdM8m: // global
           R2 = _sdLjq::P64;
           R1 = _sdLjs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdM8o: // global
           _sdLjn::P64 = P64[_sdLjs::P64 + 7];
           _sdLjo::P64 = P64[_sdLjs::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLjo::P64;
           P64[Hp] = _sdLjq::P64;
           R2 = _sdLjn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bitraverse__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdM8q,
                       label: Data.Bifoldable.bitraverse__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM8q: // global
           _sdLjp::P64 = R5;
           _sdLjo::P64 = R4;
           _sdLjn::P64 = R3;
           _sdLjm::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdM8r; else goto cdM8s;
       cdM8s: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdM8u; else goto cdM8t;
       cdM8u: // global
           HpAlloc = 72;
           goto cdM8r;
       cdM8r: // global
           R5 = _sdLjp::P64;
           R4 = _sdLjo::P64;
           R3 = _sdLjn::P64;
           R2 = _sdLjm::P64;
           R1 = Data.Bifoldable.bitraverse__closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM8t: // global
           I64[Hp - 64] = sat_sdLjw_info;
           P64[Hp - 48] = _sdLjn::P64;
           I64[Hp - 40] = sat_sdLjv_info;
           P64[Hp - 32] = _sdLjn::P64;
           P64[Hp - 24] = _sdLjp::P64;
           I64[Hp - 16] = sat_sdLjs_info;
           P64[Hp - 8] = _sdLjn::P64;
           P64[Hp] = _sdLjo::P64;
           R2 = _sdLjm::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 15;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.928282154 UTC

[section ""data" . Data.Bifoldable.bifor__closure" {
     Data.Bifoldable.bifor__closure:
         const Data.Bifoldable.bifor__info;
 },
 Data.Bifoldable.bifor__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdM8z,
                       label: Data.Bifoldable.bifor__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM8z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM8A; else goto cdM8B;
       cdM8A: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bifor__closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM8B: // global
           _sdLjA::P64 = R5;
           R5 = R6;
           _sdLjz::P64 = R4;
           R4 = _sdLjA::P64;
           R3 = R3;
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sdLjz::P64;
           Sp = Sp - 16;
           call Data.Bifoldable.bitraverse__entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.929397267 UTC

[section ""data" . Data.Bifoldable.biforM__closure" {
     Data.Bifoldable.biforM__closure:
         const Data.Bifoldable.biforM__info;
 },
 Data.Bifoldable.biforM__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdM8G,
                       label: Data.Bifoldable.biforM__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM8G: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bifor__entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.93032097 UTC

[section ""data" . Data.Bifoldable.bimapM__closure" {
     Data.Bifoldable.bimapM__closure:
         const Data.Bifoldable.bimapM__info;
 },
 Data.Bifoldable.bimapM__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdM8N,
                       label: Data.Bifoldable.bimapM__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM8N: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bitraverse__entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.93165184 UTC

[section ""data" . Data.Bifoldable.bisequence__closure" {
     Data.Bifoldable.bisequence__closure:
         const Data.Bifoldable.bisequence__info;
 },
 sat_sdLjG_entry() //  [R1]
         { info_tbl: [(cdM8Y,
                       label: sat_sdLjG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM8Y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdM8Z; else goto cdM90;
       cdM8Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM90: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sdLjF_entry() //  [R1]
         { info_tbl: [(cdM95,
                       label: sat_sdLjF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM95: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM96; else goto cdM97;
       cdM96: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM97: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjE_entry() //  [R1]
         { info_tbl: [(cdM9c,
                       label: sat_sdLjE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM9c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM9d; else goto cdM9e;
       cdM9d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM9e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.bisequence__entry() //  [R2, R3]
         { info_tbl: [(cdM9f,
                       label: Data.Bifoldable.bisequence__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM9f: // global
           _sdLjD::P64 = R3;
           _sdLjC::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdM9g; else goto cdM9h;
       cdM9h: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdM9j; else goto cdM9i;
       cdM9j: // global
           HpAlloc = 72;
           goto cdM9g;
       cdM9g: // global
           R3 = _sdLjD::P64;
           R2 = _sdLjC::P64;
           R1 = Data.Bifoldable.bisequence__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM9i: // global
           I64[Hp - 64] = sat_sdLjG_info;
           P64[Hp - 48] = _sdLjD::P64;
           I64[Hp - 40] = sat_sdLjF_info;
           P64[Hp - 24] = _sdLjD::P64;
           I64[Hp - 16] = sat_sdLjE_info;
           P64[Hp] = _sdLjD::P64;
           R2 = _sdLjC::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.933536135 UTC

[section ""data" . Data.Bifoldable.bisequenceA__closure" {
     Data.Bifoldable.bisequenceA__closure:
         const Data.Bifoldable.bisequenceA__info;
 },
 Data.Bifoldable.bisequenceA__entry() //  [R2, R3]
         { info_tbl: [(cdM9o,
                       label: Data.Bifoldable.bisequenceA__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM9o: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bisequence__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.934770014 UTC

[section ""data" . Data.Bifoldable.biasum_closure" {
     Data.Bifoldable.biasum_closure:
         const Data.Bifoldable.biasum_info;
 },
 sat_sdLjL_entry() //  [R1]
         { info_tbl: [(cdM9z,
                       label: sat_sdLjL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM9z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM9A; else goto cdM9B;
       cdM9A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM9B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjK_entry() //  [R1]
         { info_tbl: [(cdM9G,
                       label: sat_sdLjK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM9G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM9H; else goto cdM9I;
       cdM9H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM9I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjJ_entry() //  [R1]
         { info_tbl: [(cdM9N,
                       label: sat_sdLjJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM9N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdM9O; else goto cdM9P;
       cdM9O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdM9P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.biasum_entry() //  [R2, R3]
         { info_tbl: [(cdM9Q,
                       label: Data.Bifoldable.biasum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM9Q: // global
           _sdLjI::P64 = R3;
           _sdLjH::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdM9R; else goto cdM9S;
       cdM9S: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdM9U; else goto cdM9T;
       cdM9U: // global
           HpAlloc = 72;
           goto cdM9R;
       cdM9R: // global
           R3 = _sdLjI::P64;
           R2 = _sdLjH::P64;
           R1 = Data.Bifoldable.biasum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdM9T: // global
           I64[Hp - 64] = sat_sdLjL_info;
           P64[Hp - 48] = _sdLjI::P64;
           I64[Hp - 40] = sat_sdLjK_info;
           P64[Hp - 24] = _sdLjI::P64;
           I64[Hp - 16] = sat_sdLjJ_info;
           P64[Hp] = _sdLjI::P64;
           R2 = _sdLjH::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.936550524 UTC

[section ""data" . Data.Bifoldable.bimsum_closure" {
     Data.Bifoldable.bimsum_closure:
         const Data.Bifoldable.bimsum_info;
 },
 Data.Bifoldable.bimsum_entry() //  [R2, R3]
         { info_tbl: [(cdM9Z,
                       label: Data.Bifoldable.bimsum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdM9Z: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biasum_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.937514351 UTC

[section ""data" . Data.Bifoldable.biList_closure" {
     Data.Bifoldable.biList_closure:
         const Data.Bifoldable.biList_info;
 },
 Data.Bifoldable.biList_entry() //  [R2]
         { info_tbl: [(cdMa6,
                       label: Data.Bifoldable.biList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMa6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMa7; else goto cdMa8;
       cdMa7: // global
           R2 = R2;
           R1 = Data.Bifoldable.biList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMa8: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = GHC.Types.:_closure+2;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.938492189 UTC

[section ""data" . Data.Bifoldable.binull1_closure" {
     Data.Bifoldable.binull1_closure:
         const Data.Bifoldable.binull1_info;
 },
 Data.Bifoldable.binull1_entry() //  []
         { info_tbl: [(cdMad,
                       label: Data.Bifoldable.binull1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMad: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.939353122 UTC

[section ""data" . Data.Bifoldable.binull_closure" {
     Data.Bifoldable.binull_closure:
         const Data.Bifoldable.binull_info;
 },
 Data.Bifoldable.binull_entry() //  [R2]
         { info_tbl: [(cdMak,
                       label: Data.Bifoldable.binull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMak: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMal; else goto cdMam;
       cdMal: // global
           R2 = R2;
           R1 = Data.Bifoldable.binull_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMam: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Bifoldable.binull1_closure+2;
           P64[Sp - 16] = Data.Bifoldable.binull1_closure+2;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.940318892 UTC

[section ""data" . Data.Bifoldable.biconcat_closure" {
     Data.Bifoldable.biconcat_closure:
         const Data.Bifoldable.biconcat_info;
         const 0;
 },
 Data.Bifoldable.biconcat_entry() //  [R2]
         { info_tbl: [(cdMar,
                       label: Data.Bifoldable.biconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMar: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMas; else goto cdMat;
       cdMas: // global
           R2 = R2;
           R1 = Data.Bifoldable.biconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMat: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.$fMonoid[]_closure;
           Sp = Sp - 16;
           call Data.Bifoldable.bifold_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.941223092 UTC

[section ""data" . lvl16_rdL8I_closure" {
     lvl16_rdL8I_closure:
         const GHC.Types.I#_con_info;
         const 334;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.94203944 UTC

[section ""data" . lvl17_rdL8J_closure" {
     lvl17_rdL8J_closure:
         const GHC.Types.I#_con_info;
         const 24;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.942585038 UTC

[section ""data" . lvl18_rdL8K_closure" {
     lvl18_rdL8K_closure:
         const GHC.Types.I#_con_info;
         const 58;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.94320991 UTC

[section ""data" . lvl19_rdL8L_closure" {
     lvl19_rdL8L_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl16_rdL8I_closure+1;
         const lvl17_rdL8J_closure+1;
         const lvl16_rdL8I_closure+1;
         const lvl18_rdL8K_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.943830597 UTC

[section ""data" . lvl20_rdL8M_closure" {
     lvl20_rdL8M_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl19_rdL8L_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.944452228 UTC

[section ""cstring" . lvl21_rdL8N_bytes" {
     lvl21_rdL8N_bytes:
         I8[] [98,105,109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.945379752 UTC

[section ""data" . Data.Bifoldable.bimaximum1_closure" {
     Data.Bifoldable.bimaximum1_closure:
         const Data.Bifoldable.bimaximum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bimaximum1_entry() //  [R1]
         { info_tbl: [(cdMaC,
                       label: Data.Bifoldable.bimaximum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMaC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMaD; else goto cdMaE;
       cdMaD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMaE: // global
           (_cdMax::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMax::I64 == 0) goto cdMaz; else goto cdMay;
       cdMaz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMay: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMax::I64;
           I64[Sp - 24] = block_cdMaA_info;
           R2 = lvl21_rdL8N_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdMaA() //  [R1]
         { info_tbl: [(cdMaA,
                       label: block_cdMaA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMaA: // global
           R3 = R1;
           R2 = lvl20_rdL8M_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.947244335 UTC

[section ""data" . Data.Bifoldable.bimaximum_closure" {
     Data.Bifoldable.bimaximum_closure:
         const Data.Bifoldable.bimaximum_info;
         const 0;
 },
 sat_sdLjV_entry() //  [R1]
         { info_tbl: [(cdMaU,
                       label: sat_sdLjV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMaU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMaV; else goto cdMaW;
       cdMaV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMaW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdLjU_entry() //  [R1]
         { info_tbl: [(cdMaX,
                       label: g_sdLjU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMaX: // global
           _sdLjU::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMaY; else goto cdMaZ;
       cdMaZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMb1; else goto cdMb0;
       cdMb1: // global
           HpAlloc = 24;
           goto cdMaY;
       cdMaY: // global
           R1 = _sdLjU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMb0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLjU::P64;
           _sdLjS::P64 = P64[_sdLjU::P64 + 16];
           _sdLjT::P64 = P64[_sdLjU::P64 + 24];
           I64[Hp - 16] = sat_sdLjV_info;
           P64[Hp] = _sdLjT::P64;
           R2 = _sdLjS::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = GHC.Base.Just_closure+1;
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdLjZ_entry() //  [R1, R2]
         { info_tbl: [(cdMbd,
                       label: sat_sdLjZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMbd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMbe; else goto cdMbf;
       cdMbe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMbf: // global
           I64[Sp - 8] = block_cdMb7_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMb7() //  [R1]
         { info_tbl: [(cdMb7,
                       label: block_cdMb7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMb7: // global
           if (R1 & 7 == 1) goto cdMba; else goto cdMbb;
       cdMba: // global
           R1 = Data.Bifoldable.bimaximum1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdMbb: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bimaximum_entry() //  [R2, R3]
         { info_tbl: [(cdMbm,
                       label: Data.Bifoldable.bimaximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMbm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMbq; else goto cdMbp;
       cdMbq: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bimaximum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMbp: // global
           I64[Hp - 40] = g_sdLjU_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdLjZ_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.949215981 UTC

[section ""data" . lvl22_rdL8O_closure" {
     lvl22_rdL8O_closure:
         const GHC.Types.I#_con_info;
         const 342;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.94987093 UTC

[section ""data" . lvl23_rdL8P_closure" {
     lvl23_rdL8P_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl22_rdL8O_closure+1;
         const lvl17_rdL8J_closure+1;
         const lvl22_rdL8O_closure+1;
         const lvl18_rdL8K_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.950501702 UTC

[section ""data" . lvl24_rdL8Q_closure" {
     lvl24_rdL8Q_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl23_rdL8P_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.951097853 UTC

[section ""cstring" . lvl25_rdL8R_bytes" {
     lvl25_rdL8R_bytes:
         I8[] [98,105,109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.951925786 UTC

[section ""data" . Data.Bifoldable.biminimum1_closure" {
     Data.Bifoldable.biminimum1_closure:
         const Data.Bifoldable.biminimum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.biminimum1_entry() //  [R1]
         { info_tbl: [(cdMbz,
                       label: Data.Bifoldable.biminimum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMbz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMbA; else goto cdMbB;
       cdMbA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMbB: // global
           (_cdMbu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMbu::I64 == 0) goto cdMbw; else goto cdMbv;
       cdMbw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMbv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMbu::I64;
           I64[Sp - 24] = block_cdMbx_info;
           R2 = lvl25_rdL8R_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdMbx() //  [R1]
         { info_tbl: [(cdMbx,
                       label: block_cdMbx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMbx: // global
           R3 = R1;
           R2 = lvl24_rdL8Q_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.953820474 UTC

[section ""data" . Data.Bifoldable.biminimum_closure" {
     Data.Bifoldable.biminimum_closure:
         const Data.Bifoldable.biminimum_info;
         const 0;
 },
 sat_sdLk4_entry() //  [R1]
         { info_tbl: [(cdMbR,
                       label: sat_sdLk4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMbR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMbS; else goto cdMbT;
       cdMbS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMbT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdLk3_entry() //  [R1]
         { info_tbl: [(cdMbU,
                       label: g_sdLk3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMbU: // global
           _sdLk3::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMbV; else goto cdMbW;
       cdMbW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMbY; else goto cdMbX;
       cdMbY: // global
           HpAlloc = 24;
           goto cdMbV;
       cdMbV: // global
           R1 = _sdLk3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMbX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLk3::P64;
           _sdLk1::P64 = P64[_sdLk3::P64 + 16];
           _sdLk2::P64 = P64[_sdLk3::P64 + 24];
           I64[Hp - 16] = sat_sdLk4_info;
           P64[Hp] = _sdLk2::P64;
           R2 = _sdLk1::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = GHC.Base.Just_closure+1;
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdLk8_entry() //  [R1, R2]
         { info_tbl: [(cdMca,
                       label: sat_sdLk8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMca: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMcb; else goto cdMcc;
       cdMcb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMcc: // global
           I64[Sp - 8] = block_cdMc4_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMc4() //  [R1]
         { info_tbl: [(cdMc4,
                       label: block_cdMc4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMc4: // global
           if (R1 & 7 == 1) goto cdMc7; else goto cdMc8;
       cdMc7: // global
           R1 = Data.Bifoldable.biminimum1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdMc8: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biminimum_entry() //  [R2, R3]
         { info_tbl: [(cdMcj,
                       label: Data.Bifoldable.biminimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMcj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMcn; else goto cdMcm;
       cdMcn: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.biminimum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMcm: // global
           I64[Hp - 40] = g_sdLk3_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdLk8_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.955935874 UTC

[section ""data" . Data.Bifoldable.biproduct2_closure" {
     Data.Bifoldable.biproduct2_closure:
         const Data.Bifoldable.biproduct2_info;
 },
 Data.Bifoldable.biproduct2_entry() //  [R2]
         { info_tbl: [(cdMcs,
                       label: Data.Bifoldable.biproduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMcs: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.95700579 UTC

[section ""data" . Data.Bifoldable.bisum1_closure" {
     Data.Bifoldable.bisum1_closure:
         const Data.Bifoldable.bisum1_info;
         const 0;
 },
 sat_sdLkc_entry() //  [R1]
         { info_tbl: [(cdMcD,
                       label: sat_sdLkc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMcD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMcE; else goto cdMcF;
       cdMcE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMcF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.bisum1_entry() //  [R2, R3]
         { info_tbl: [(cdMcG,
                       label: Data.Bifoldable.bisum1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMcG: // global
           _sdLkb::P64 = R3;
           _sdLka::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMcH; else goto cdMcI;
       cdMcI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMcK; else goto cdMcJ;
       cdMcK: // global
           HpAlloc = 24;
           goto cdMcH;
       cdMcH: // global
           R3 = _sdLkb::P64;
           R2 = _sdLka::P64;
           R1 = Data.Bifoldable.bisum1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMcJ: // global
           I64[Hp - 16] = sat_sdLkc_info;
           P64[Hp] = _sdLkb::P64;
           R2 = _sdLka::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Data.Bifoldable.biproduct2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biproduct2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.95873679 UTC

[section ""data" . Data.Bifoldable.bisum_closure" {
     Data.Bifoldable.bisum_closure:
         const Data.Bifoldable.bisum_info;
         const 0;
 },
 Data.Bifoldable.bisum_entry() //  [R2, R3]
         { info_tbl: [(cdMcP,
                       label: Data.Bifoldable.bisum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMcP: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bisum1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.959825494 UTC

[section ""data" . Data.Bifoldable.biproduct1_closure" {
     Data.Bifoldable.biproduct1_closure:
         const Data.Bifoldable.biproduct1_info;
         const 0;
 },
 sat_sdLkf_entry() //  [R1]
         { info_tbl: [(cdMd0,
                       label: sat_sdLkf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMd0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMd1; else goto cdMd2;
       cdMd1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMd2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.biproduct1_entry() //  [R2, R3]
         { info_tbl: [(cdMd3,
                       label: Data.Bifoldable.biproduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMd3: // global
           _sdLke::P64 = R3;
           _sdLkd::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMd4; else goto cdMd5;
       cdMd5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMd7; else goto cdMd6;
       cdMd7: // global
           HpAlloc = 24;
           goto cdMd4;
       cdMd4: // global
           R3 = _sdLke::P64;
           R2 = _sdLkd::P64;
           R1 = Data.Bifoldable.biproduct1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMd6: // global
           I64[Hp - 16] = sat_sdLkf_info;
           P64[Hp] = _sdLke::P64;
           R2 = _sdLkd::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Data.Bifoldable.biproduct2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biproduct2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.961274043 UTC

[section ""data" . Data.Bifoldable.biproduct_closure" {
     Data.Bifoldable.biproduct_closure:
         const Data.Bifoldable.biproduct_info;
         const 0;
 },
 Data.Bifoldable.biproduct_entry() //  [R2, R3]
         { info_tbl: [(cdMdc,
                       label: Data.Bifoldable.biproduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMdc: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biproduct1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.962259192 UTC

[section ""data" . Data.Bifoldable.biconcatMap_closure" {
     Data.Bifoldable.biconcatMap_closure:
         const Data.Bifoldable.biconcatMap_info;
         const 0;
 },
 Data.Bifoldable.biconcatMap_entry() //  [R2]
         { info_tbl: [(cdMdj,
                       label: Data.Bifoldable.biconcatMap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMdj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMdk; else goto cdMdl;
       cdMdk: // global
           R2 = R2;
           R1 = Data.Bifoldable.biconcatMap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMdl: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.$fMonoid[]_closure;
           Sp = Sp - 16;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.964699702 UTC

[section ""data" . Data.Bifoldable.biand2_closure" {
     Data.Bifoldable.biand2_closure:
         const Data.Bifoldable.biand2_info;
 },
 Data.Bifoldable.biand2_entry() //  [R2]
         { info_tbl: [(cdMdq,
                       label: Data.Bifoldable.biand2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMdq: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.96552319 UTC

[section ""data" . Data.Bifoldable.biand1_closure" {
     Data.Bifoldable.biand1_closure:
         const Data.Bifoldable.biand1_info;
         const 0;
 },
 Data.Bifoldable.biand1_entry() //  [R2]
         { info_tbl: [(cdMdx,
                       label: Data.Bifoldable.biand1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMdx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMdy; else goto cdMdz;
       cdMdy: // global
           R2 = R2;
           R1 = Data.Bifoldable.biand1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMdz: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAll_closure;
           P64[Sp - 16] = Data.Bifoldable.biand2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biand2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.966440126 UTC

[section ""data" . Data.Bifoldable.biand_closure" {
     Data.Bifoldable.biand_closure:
         const Data.Bifoldable.biand_info;
         const 0;
 },
 Data.Bifoldable.biand_entry() //  [R2]
         { info_tbl: [(cdMdE,
                       label: Data.Bifoldable.biand_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMdE: // global
           R2 = R2;
           call Data.Bifoldable.biand1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.967295522 UTC

[section ""data" . Data.Bifoldable.bior1_closure" {
     Data.Bifoldable.bior1_closure:
         const Data.Bifoldable.bior1_info;
         const 0;
 },
 Data.Bifoldable.bior1_entry() //  [R2]
         { info_tbl: [(cdMdL,
                       label: Data.Bifoldable.bior1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMdL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMdM; else goto cdMdN;
       cdMdM: // global
           R2 = R2;
           R1 = Data.Bifoldable.bior1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMdN: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Data.Bifoldable.biand2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biand2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.968232469 UTC

[section ""data" . Data.Bifoldable.bior_closure" {
     Data.Bifoldable.bior_closure:
         const Data.Bifoldable.bior_info;
         const 0;
 },
 Data.Bifoldable.bior_entry() //  [R2]
         { info_tbl: [(cdMdS,
                       label: Data.Bifoldable.bior_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMdS: // global
           R2 = R2;
           call Data.Bifoldable.bior1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.969375513 UTC

[section ""data" . Data.Bifoldable.biany1_closure" {
     Data.Bifoldable.biany1_closure:
         const Data.Bifoldable.biany1_info;
         const 0;
 },
 sat_sdLkq_entry() //  [R1, R2]
         { info_tbl: [(cdMe4,
                       label: sat_sdLkq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMe4: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLko_entry() //  [R1, R2]
         { info_tbl: [(cdMec,
                       label: sat_sdLko_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMec: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biany1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMef,
                       label: Data.Bifoldable.biany1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMef: // global
           _sdLkm::P64 = R4;
           _sdLkl::P64 = R3;
           _sdLkk::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMeg; else goto cdMeh;
       cdMeh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMej; else goto cdMei;
       cdMej: // global
           HpAlloc = 32;
           goto cdMeg;
       cdMeg: // global
           R4 = _sdLkm::P64;
           R3 = _sdLkl::P64;
           R2 = _sdLkk::P64;
           R1 = Data.Bifoldable.biany1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMei: // global
           I64[Hp - 24] = sat_sdLkq_info;
           P64[Hp - 16] = _sdLkm::P64;
           I64[Hp - 8] = sat_sdLko_info;
           P64[Hp] = _sdLkl::P64;
           R2 = _sdLkk::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.970813851 UTC

[section ""data" . Data.Bifoldable.biany_closure" {
     Data.Bifoldable.biany_closure:
         const Data.Bifoldable.biany_info;
         const 0;
 },
 Data.Bifoldable.biany_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMeo,
                       label: Data.Bifoldable.biany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMeo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biany1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.972012726 UTC

[section ""data" . Data.Bifoldable.bielem1_closure" {
     Data.Bifoldable.bielem1_closure:
         const Data.Bifoldable.bielem1_info;
         const 0;
 },
 sat_sdLkx_entry() //  [R1, R2]
         { info_tbl: [(cdMeA,
                       label: sat_sdLkx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMeA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMeB; else goto cdMeC;
       cdMeB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMeC: // global
           _sdLkw::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sdLkw::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdLkv_entry() //  [R1, R2]
         { info_tbl: [(cdMeI,
                       label: sat_sdLkv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMeI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMeJ; else goto cdMeK;
       cdMeJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMeK: // global
           _sdLku::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sdLku::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bielem1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMeL,
                       label: Data.Bifoldable.bielem1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMeL: // global
           _sdLkt::P64 = R4;
           _sdLks::P64 = R3;
           _sdLkr::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMeM; else goto cdMeN;
       cdMeN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMeP; else goto cdMeO;
       cdMeP: // global
           HpAlloc = 48;
           goto cdMeM;
       cdMeM: // global
           R4 = _sdLkt::P64;
           R3 = _sdLks::P64;
           R2 = _sdLkr::P64;
           R1 = Data.Bifoldable.bielem1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMeO: // global
           I64[Hp - 40] = sat_sdLkx_info;
           P64[Hp - 32] = _sdLks::P64;
           P64[Hp - 24] = _sdLkt::P64;
           I64[Hp - 16] = sat_sdLkv_info;
           P64[Hp - 8] = _sdLks::P64;
           P64[Hp] = _sdLkt::P64;
           R2 = _sdLkr::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Hp - 15;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.97406381 UTC

[section ""data" . Data.Bifoldable.bielem_closure" {
     Data.Bifoldable.bielem_closure:
         const Data.Bifoldable.bielem_info;
         const 0;
 },
 Data.Bifoldable.bielem_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMeU,
                       label: Data.Bifoldable.bielem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMeU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bielem1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.975379452 UTC

[section ""data" . Data.Bifoldable.binotElem_closure" {
     Data.Bifoldable.binotElem_closure:
         const Data.Bifoldable.binotElem_info;
         const 0;
 },
 g_sdLkB_entry() //  [R1]
         { info_tbl: [(cdMf5,
                       label: g_sdLkB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMf5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMf6; else goto cdMf7;
       cdMf6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMf7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bifoldable.bielem1_entry(R4,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLkE_entry() //  [R1, R2]
         { info_tbl: [(cdMfj,
                       label: sat_sdLkE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMfj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMfk; else goto cdMfl;
       cdMfk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMfl: // global
           I64[Sp - 8] = block_cdMfd_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMfd() //  [R1]
         { info_tbl: [(cdMfd,
                       label: block_cdMfd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMfd: // global
           if (R1 & 7 == 1) goto cdMfg; else goto cdMfh;
       cdMfg: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdMfh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.binotElem_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMfs,
                       label: Data.Bifoldable.binotElem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMfs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdMfw; else goto cdMfv;
       cdMfw: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.binotElem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMfv: // global
           I64[Hp - 48] = g_sdLkB_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdLkE_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.977420411 UTC

[section ""data" . Data.Bifoldable.biall1_closure" {
     Data.Bifoldable.biall1_closure:
         const Data.Bifoldable.biall1_info;
         const 0;
 },
 sat_sdLkL_entry() //  [R1, R2]
         { info_tbl: [(cdMfG,
                       label: sat_sdLkL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMfG: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLkJ_entry() //  [R1, R2]
         { info_tbl: [(cdMfO,
                       label: sat_sdLkJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMfO: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biall1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMfR,
                       label: Data.Bifoldable.biall1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMfR: // global
           _sdLkH::P64 = R4;
           _sdLkG::P64 = R3;
           _sdLkF::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMfS; else goto cdMfT;
       cdMfT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMfV; else goto cdMfU;
       cdMfV: // global
           HpAlloc = 32;
           goto cdMfS;
       cdMfS: // global
           R4 = _sdLkH::P64;
           R3 = _sdLkG::P64;
           R2 = _sdLkF::P64;
           R1 = Data.Bifoldable.biall1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMfU: // global
           I64[Hp - 24] = sat_sdLkL_info;
           P64[Hp - 16] = _sdLkH::P64;
           I64[Hp - 8] = sat_sdLkJ_info;
           P64[Hp] = _sdLkG::P64;
           R2 = _sdLkF::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAll_closure;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.978832651 UTC

[section ""data" . Data.Bifoldable.biall_closure" {
     Data.Bifoldable.biall_closure:
         const Data.Bifoldable.biall_info;
         const 0;
 },
 Data.Bifoldable.biall_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMg0,
                       label: Data.Bifoldable.biall_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMg0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biall1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.980347336 UTC

[section ""data" . Data.Bifoldable.bifind_closure" {
     Data.Bifoldable.bifind_closure:
         const Data.Bifoldable.bifind_info;
         const 0;
 },
 finder_sdLkP_entry() //  [R1, R2]
         { info_tbl: [(cdMgm,
                       label: finder_sdLkP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMgm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMgn; else goto cdMgo;
       cdMgn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMgo: // global
           I64[Sp - 16] = block_cdMgg_info;
           _sdLkQ::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdLkQ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMgg() //  [R1]
         { info_tbl: [(cdMgg,
                       label: block_cdMgg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMgg: // global
           if (R1 & 7 == 1) goto cdMgj; else goto cdMgk;
       cdMgj: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdMgk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdMgx; else goto cdMgw;
       cdMgx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdMgw: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdLkO_entry() //  [R1]
         { info_tbl: [(cdMgy,
                       label: g_sdLkO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMgy: // global
           _sdLkO::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMgz; else goto cdMgA;
       cdMgA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdMgC; else goto cdMgB;
       cdMgC: // global
           HpAlloc = 16;
           goto cdMgz;
       cdMgz: // global
           R1 = _sdLkO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMgB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLkO::P64;
           _sdLkM::P64 = P64[_sdLkO::P64 + 16];
           _sdLkN::P64 = P64[_sdLkO::P64 + 24];
           I64[Hp - 8] = finder_sdLkP_info;
           P64[Hp] = _sdLkN::P64;
           R2 = _sdLkM::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Monoid.$fMonoidFirst_closure;
           _cdMgb::P64 = Hp - 7;
           P64[Sp - 32] = _cdMgb::P64;
           P64[Sp - 24] = _cdMgb::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdLkT_entry() //  [R1, R2]
         { info_tbl: [(cdMgI,
                       label: sat_sdLkT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMgI: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifind_entry() //  [R2, R3]
         { info_tbl: [(cdMgL,
                       label: Data.Bifoldable.bifind_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMgL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMgP; else goto cdMgO;
       cdMgP: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bifind_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMgO: // global
           I64[Hp - 40] = g_sdLkO_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdLkT_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.982366057 UTC

[section ""data" . Data.Bifoldable.$trModule3_closure" {
     Data.Bifoldable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.982973078 UTC

[section ""data" . Data.Bifoldable.$trModule1_closure" {
     Data.Bifoldable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.98354312 UTC

[section ""data" . Data.Bifoldable.$trModule_closure" {
     Data.Bifoldable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bifoldable.$trModule3_closure+1;
         const Data.Bifoldable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.984062071 UTC

[section ""data" . $krep_rdL8S_closure" {
     $krep_rdL8S_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.98463083 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable1_closure" {
     Data.Bifoldable.$tcBifoldable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdL8S_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.985183389 UTC

[section ""cstring" . Data.Bifoldable.$tcBifoldable3_bytes" {
     Data.Bifoldable.$tcBifoldable3_bytes:
         I8[] [66,105,102,111,108,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.986027567 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable2_closure" {
     Data.Bifoldable.$tcBifoldable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$tcBifoldable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.98664787 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable_closure" {
     Data.Bifoldable.$tcBifoldable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bifoldable.$trModule_closure+1;
         const Data.Bifoldable.$tcBifoldable2_closure+1;
         const Data.Bifoldable.$tcBifoldable1_closure+4;
         const 13881323671910883383;
         const 7079945659398195047;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.987507019 UTC

[section ""data" . Data.Bifoldable.C:Bifoldable_closure" {
     Data.Bifoldable.C:Bifoldable_closure:
         const Data.Bifoldable.C:Bifoldable_info;
 },
 Data.Bifoldable.C:Bifoldable_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdMgV,
                       label: Data.Bifoldable.C:Bifoldable_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMgV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdMgZ; else goto cdMgY;
       cdMgZ: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.C:Bifoldable_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMgY: // global
           I64[Hp - 32] = Data.Bifoldable.C:Bifoldable_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.988454899 UTC

[Data.Bifoldable.C:Bifoldable_con_entry() //  [R1]
         { info_tbl: [(cdMh0,
                       label: Data.Bifoldable.C:Bifoldable_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,102,111,108,100,97,98,108,101,46,67,58,66,105,102,111,108,100,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMh0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.989138189 UTC

[section ""relreadonly" . SdLpk_srt" {
     SdLpk_srt:
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Bifoldable.$dmbifoldl_closure;
         const poly_$dMonoid_rdL8r_closure;
         const Data.Bifoldable.$dmbifoldr_closure;
         const GHC.Err.error_closure;
         const lvl10_rdL8C_closure;
         const Data.Bifoldable.bifoldr1_closure;
         const Data.Bifoldable.bifoldr2_closure;
         const Data.Bifoldable.bimaximumBy_closure;
         const Data.Bifoldable.biminimumBy_closure;
         const lvl14_rdL8G_closure;
         const Data.Bifoldable.bifoldl1_closure;
         const Data.Bifoldable.bifoldl2_closure;
         const GHC.Base.$fMonoid[]_closure;
         const Data.Bifoldable.biconcat_closure;
         const lvl20_rdL8M_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Bifoldable.bimaximum1_closure;
         const Data.Bifoldable.bimaximum_closure;
         const lvl24_rdL8Q_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Bifoldable.biminimum1_closure;
         const Data.Bifoldable.biminimum_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Bifoldable.bisum1_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Bifoldable.biproduct1_closure;
         const Data.Bifoldable.biconcatMap_closure;
         const Data.Semigroup.Internal.$fMonoidAll_closure;
         const Data.Bifoldable.biand1_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Bifoldable.bior1_closure;
         const Data.Bifoldable.biany1_closure;
         const Data.Bifoldable.bielem1_closure;
         const Data.Bifoldable.binotElem_closure;
         const Data.Bifoldable.biall1_closure;
         const Data.Monoid.$fMonoidFirst_closure;
         const Data.Bifoldable.bifind_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.990247334 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:58.991577186 UTC

[section ""data" . Data.Bifoldable.bifold_closure" {
     Data.Bifoldable.bifold_closure:
         const Data.Bifoldable.bifold_info;
 },
 Data.Bifoldable.bifold_entry() //  [R2]
         { info_tbl: [(cdMh9,
                       label: Data.Bifoldable.bifold_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMh9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMha; else goto cdMhb;
       cdMha: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifold_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMhb: // global
           I64[Sp - 8] = block_cdMh6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udMhf; else goto cdMh7;
       udMhf: // global
           call _cdMh6(R1) args: 0, res: 0, upd: 0;
       cdMh7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMh6() //  [R1]
         { info_tbl: [(cdMh6,
                       label: block_cdMh6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMh6: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:58.997183367 UTC

[section ""data" . Data.Bifoldable.bifoldMap_closure" {
     Data.Bifoldable.bifoldMap_closure:
         const Data.Bifoldable.bifoldMap_info;
 },
 Data.Bifoldable.bifoldMap_entry() //  [R2]
         { info_tbl: [(cdMhw,
                       label: Data.Bifoldable.bifoldMap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMhw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMhx; else goto cdMhy;
       cdMhx: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldMap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMhy: // global
           I64[Sp - 8] = block_cdMht_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udMhC; else goto cdMhu;
       udMhC: // global
           call _cdMht(R1) args: 0, res: 0, upd: 0;
       cdMhu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMht() //  [R1]
         { info_tbl: [(cdMht,
                       label: block_cdMht_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMht: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.00270619 UTC

[section ""data" . Data.Bifoldable.bifoldr_closure" {
     Data.Bifoldable.bifoldr_closure:
         const Data.Bifoldable.bifoldr_info;
 },
 Data.Bifoldable.bifoldr_entry() //  [R2]
         { info_tbl: [(cdMhT,
                       label: Data.Bifoldable.bifoldr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMhT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMhU; else goto cdMhV;
       cdMhU: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMhV: // global
           I64[Sp - 8] = block_cdMhQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udMhZ; else goto cdMhR;
       udMhZ: // global
           call _cdMhQ(R1) args: 0, res: 0, upd: 0;
       cdMhR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMhQ() //  [R1]
         { info_tbl: [(cdMhQ,
                       label: block_cdMhQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMhQ: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.009081104 UTC

[section ""data" . Data.Bifoldable.bifoldl_closure" {
     Data.Bifoldable.bifoldl_closure:
         const Data.Bifoldable.bifoldl_info;
 },
 Data.Bifoldable.bifoldl_entry() //  [R2]
         { info_tbl: [(cdMig,
                       label: Data.Bifoldable.bifoldl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMig: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMih; else goto cdMii;
       cdMih: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMii: // global
           I64[Sp - 8] = block_cdMid_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udMim; else goto cdMie;
       udMim: // global
           call _cdMid(R1) args: 0, res: 0, upd: 0;
       cdMie: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMid() //  [R1]
         { info_tbl: [(cdMid,
                       label: block_cdMid_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMid: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.01455963 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_info;
 },
 sat_sdL9v_entry() //  [R1]
         { info_tbl: [(cdMiF,
                       label: sat_sdL9v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMiF: // global
           _sdL9v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMiG; else goto cdMiH;
       cdMiH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMiJ; else goto cdMiI;
       cdMiJ: // global
           HpAlloc = 24;
           goto cdMiG;
       cdMiG: // global
           R1 = _sdL9v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMiI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9v::P64;
           _sdL9k::P64 = P64[_sdL9v::P64 + 16];
           _sdL9l::P64 = P64[_sdL9v::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdL9l::P64;
           R2 = Hp - 16;
           R1 = _sdL9k::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdL9q_entry() //  [R1]
         { info_tbl: [(cdMiP,
                       label: sat_sdL9q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMiP: // global
           _sdL9q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMiQ; else goto cdMiR;
       cdMiR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMiT; else goto cdMiS;
       cdMiT: // global
           HpAlloc = 24;
           goto cdMiQ;
       cdMiQ: // global
           R1 = _sdL9q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMiS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9q::P64;
           _sdL9j::P64 = P64[_sdL9q::P64 + 16];
           _sdL9l::P64 = P64[_sdL9q::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdL9l::P64;
           R2 = Hp - 16;
           R1 = _sdL9j::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdMiU,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMiU: // global
           _sdL9l::P64 = R5;
           _sdL9k::P64 = R4;
           _sdL9j::P64 = R3;
           _sdL9i::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMiV; else goto cdMiW;
       cdMiW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMiY; else goto cdMiX;
       cdMiY: // global
           HpAlloc = 64;
           goto cdMiV;
       cdMiV: // global
           R5 = _sdL9l::P64;
           R4 = _sdL9k::P64;
           R3 = _sdL9j::P64;
           R2 = _sdL9i::P64;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMiX: // global
           I64[Hp - 56] = sat_sdL9v_info;
           P64[Hp - 40] = _sdL9k::P64;
           P64[Hp - 32] = _sdL9l::P64;
           I64[Hp - 24] = sat_sdL9q_info;
           P64[Hp - 8] = _sdL9j::P64;
           P64[Hp] = _sdL9l::P64;
           R2 = _sdL9i::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.023314191 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldMap_entry() //  [R3, R5]
         { info_tbl: [(cdMji,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMji: // global
           R2 = R5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.02670646 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldMap_entry() //  [R3, R5]
         { info_tbl: [(cdMjt,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMjt: // global
           R2 = R5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.030493069 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_info;
 },
 sat_sdL9T_entry() //  [R1]
         { info_tbl: [(cdMjJ,
                       label: sat_sdL9T_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMjJ: // global
           _sdL9T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMjK; else goto cdMjL;
       cdMjL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMjN; else goto cdMjM;
       cdMjN: // global
           HpAlloc = 24;
           goto cdMjK;
       cdMjK: // global
           R1 = _sdL9T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMjM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9T::P64;
           _sdL9G::P64 = P64[_sdL9T::P64 + 16];
           _sdL9H::P64 = P64[_sdL9T::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdL9H::P64;
           R2 = Hp - 16;
           R1 = _sdL9G::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdL9N_entry() //  [R1]
         { info_tbl: [(cdMjT,
                       label: sat_sdL9N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMjT: // global
           _sdL9N::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMjU; else goto cdMjV;
       cdMjV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMjX; else goto cdMjW;
       cdMjX: // global
           HpAlloc = 24;
           goto cdMjU;
       cdMjU: // global
           R1 = _sdL9N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMjW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdL9N::P64;
           _sdL9F::P64 = P64[_sdL9N::P64 + 16];
           _sdL9H::P64 = P64[_sdL9N::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdL9H::P64;
           R2 = Hp - 16;
           R1 = _sdL9F::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdMjY,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMjY: // global
           _sdL9H::P64 = R5;
           _sdL9G::P64 = R4;
           _sdL9F::P64 = R3;
           _sdL9E::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMjZ; else goto cdMk0;
       cdMk0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMk2; else goto cdMk1;
       cdMk2: // global
           HpAlloc = 64;
           goto cdMjZ;
       cdMjZ: // global
           R5 = _sdL9H::P64;
           R4 = _sdL9G::P64;
           R3 = _sdL9F::P64;
           R2 = _sdL9E::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMk1: // global
           I64[Hp - 56] = sat_sdL9T_info;
           P64[Hp - 40] = _sdL9G::P64;
           P64[Hp - 32] = _sdL9H::P64;
           I64[Hp - 24] = sat_sdL9N_info;
           P64[Hp - 8] = _sdL9F::P64;
           P64[Hp] = _sdL9H::P64;
           R2 = _sdL9E::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.040448046 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_info;
 },
 sat_sdLab_entry() //  [R1]
         { info_tbl: [(cdMkr,
                       label: sat_sdLab_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMkr: // global
           _sdLab::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMks; else goto cdMkt;
       cdMkt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMkv; else goto cdMku;
       cdMkv: // global
           HpAlloc = 24;
           goto cdMks;
       cdMks: // global
           R1 = _sdLab::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMku: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLab::P64;
           _sdL9W::P64 = P64[_sdLab::P64 + 16];
           _sdL9X::P64 = P64[_sdLab::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdL9X::P64;
           R2 = Hp - 16;
           R1 = _sdL9W::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLa4_entry() //  [R1]
         { info_tbl: [(cdMkB,
                       label: sat_sdLa4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMkB: // global
           _sdLa4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMkC; else goto cdMkD;
       cdMkD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMkF; else goto cdMkE;
       cdMkF: // global
           HpAlloc = 24;
           goto cdMkC;
       cdMkC: // global
           R1 = _sdLa4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMkE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLa4::P64;
           _sdL9V::P64 = P64[_sdLa4::P64 + 16];
           _sdL9X::P64 = P64[_sdLa4::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdL9X::P64;
           R2 = Hp - 16;
           R1 = _sdL9V::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdMkG,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMkG: // global
           _sdL9X::P64 = R5;
           _sdL9W::P64 = R4;
           _sdL9V::P64 = R3;
           _sdL9U::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMkH; else goto cdMkI;
       cdMkI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMkK; else goto cdMkJ;
       cdMkK: // global
           HpAlloc = 64;
           goto cdMkH;
       cdMkH: // global
           R5 = _sdL9X::P64;
           R4 = _sdL9W::P64;
           R3 = _sdL9V::P64;
           R2 = _sdL9U::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMkJ: // global
           I64[Hp - 56] = sat_sdLab_info;
           P64[Hp - 40] = _sdL9W::P64;
           P64[Hp - 32] = _sdL9X::P64;
           I64[Hp - 24] = sat_sdLa4_info;
           P64[Hp - 8] = _sdL9V::P64;
           P64[Hp] = _sdL9X::P64;
           R2 = _sdL9U::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.050518775 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_info;
 },
 sat_sdLav_entry() //  [R1]
         { info_tbl: [(cdMl9,
                       label: sat_sdLav_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMl9: // global
           _sdLav::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMla; else goto cdMlb;
       cdMlb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMld; else goto cdMlc;
       cdMld: // global
           HpAlloc = 24;
           goto cdMla;
       cdMla: // global
           R1 = _sdLav::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMlc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLav::P64;
           _sdLae::P64 = P64[_sdLav::P64 + 16];
           _sdLaf::P64 = P64[_sdLav::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLaf::P64;
           R2 = Hp - 16;
           R1 = _sdLae::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLan_entry() //  [R1]
         { info_tbl: [(cdMlj,
                       label: sat_sdLan_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMlj: // global
           _sdLan::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMlk; else goto cdMll;
       cdMll: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMln; else goto cdMlm;
       cdMln: // global
           HpAlloc = 24;
           goto cdMlk;
       cdMlk: // global
           R1 = _sdLan::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMlm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLan::P64;
           _sdLad::P64 = P64[_sdLan::P64 + 16];
           _sdLaf::P64 = P64[_sdLan::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLaf::P64;
           R2 = Hp - 16;
           R1 = _sdLad::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdMlo,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMlo: // global
           _sdLaf::P64 = R5;
           _sdLae::P64 = R4;
           _sdLad::P64 = R3;
           _sdLac::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMlp; else goto cdMlq;
       cdMlq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMls; else goto cdMlr;
       cdMls: // global
           HpAlloc = 64;
           goto cdMlp;
       cdMlp: // global
           R5 = _sdLaf::P64;
           R4 = _sdLae::P64;
           R3 = _sdLad::P64;
           R2 = _sdLac::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMlr: // global
           I64[Hp - 56] = sat_sdLav_info;
           P64[Hp - 40] = _sdLae::P64;
           P64[Hp - 32] = _sdLaf::P64;
           I64[Hp - 24] = sat_sdLan_info;
           P64[Hp - 8] = _sdLad::P64;
           P64[Hp] = _sdLaf::P64;
           R2 = _sdLac::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.059567278 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_info;
 },
 sat_sdLaR_entry() //  [R1]
         { info_tbl: [(cdMlR,
                       label: sat_sdLaR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMlR: // global
           _sdLaR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMlS; else goto cdMlT;
       cdMlT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMlV; else goto cdMlU;
       cdMlV: // global
           HpAlloc = 24;
           goto cdMlS;
       cdMlS: // global
           R1 = _sdLaR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMlU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLaR::P64;
           _sdLay::P64 = P64[_sdLaR::P64 + 16];
           _sdLaz::P64 = P64[_sdLaR::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLaz::P64;
           R2 = Hp - 16;
           R1 = _sdLay::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLaI_entry() //  [R1]
         { info_tbl: [(cdMm1,
                       label: sat_sdLaI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMm1: // global
           _sdLaI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMm2; else goto cdMm3;
       cdMm3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMm5; else goto cdMm4;
       cdMm5: // global
           HpAlloc = 24;
           goto cdMm2;
       cdMm2: // global
           R1 = _sdLaI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMm4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLaI::P64;
           _sdLax::P64 = P64[_sdLaI::P64 + 16];
           _sdLaz::P64 = P64[_sdLaI::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLaz::P64;
           R2 = Hp - 16;
           R1 = _sdLax::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdMm6,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMm6: // global
           _sdLaz::P64 = R5;
           _sdLay::P64 = R4;
           _sdLax::P64 = R3;
           _sdLaw::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMm7; else goto cdMm8;
       cdMm8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMma; else goto cdMm9;
       cdMma: // global
           HpAlloc = 64;
           goto cdMm7;
       cdMm7: // global
           R5 = _sdLaz::P64;
           R4 = _sdLay::P64;
           R3 = _sdLax::P64;
           R2 = _sdLaw::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMm9: // global
           I64[Hp - 56] = sat_sdLaR_info;
           P64[Hp - 40] = _sdLay::P64;
           P64[Hp - 32] = _sdLaz::P64;
           I64[Hp - 24] = sat_sdLaI_info;
           P64[Hp - 8] = _sdLax::P64;
           P64[Hp] = _sdLaz::P64;
           R2 = _sdLaw::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.068493765 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_info;
 },
 sat_sdLbf_entry() //  [R1]
         { info_tbl: [(cdMmz,
                       label: sat_sdLbf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMmz: // global
           _sdLbf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMmA; else goto cdMmB;
       cdMmB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMmD; else goto cdMmC;
       cdMmD: // global
           HpAlloc = 24;
           goto cdMmA;
       cdMmA: // global
           R1 = _sdLbf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMmC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLbf::P64;
           _sdLaU::P64 = P64[_sdLbf::P64 + 16];
           _sdLaV::P64 = P64[_sdLbf::P64 + 24];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdLaV::P64;
           R2 = Hp - 16;
           R1 = _sdLaU::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLb5_entry() //  [R1]
         { info_tbl: [(cdMmJ,
                       label: sat_sdLb5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMmJ: // global
           _sdLb5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMmK; else goto cdMmL;
       cdMmL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMmN; else goto cdMmM;
       cdMmN: // global
           HpAlloc = 24;
           goto cdMmK;
       cdMmK: // global
           R1 = _sdLb5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMmM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLb5::P64;
           _sdLaT::P64 = P64[_sdLb5::P64 + 16];
           _sdLaV::P64 = P64[_sdLb5::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLaV::P64;
           R2 = Hp - 16;
           R1 = _sdLaT::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_entry() //  [R2,
                                                               R3, R4, R5]
         { info_tbl: [(cdMmO,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMmO: // global
           _sdLaV::P64 = R5;
           _sdLaU::P64 = R4;
           _sdLaT::P64 = R3;
           _sdLaS::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMmP; else goto cdMmQ;
       cdMmQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMmS; else goto cdMmR;
       cdMmS: // global
           HpAlloc = 64;
           goto cdMmP;
       cdMmP: // global
           R5 = _sdLaV::P64;
           R4 = _sdLaU::P64;
           R3 = _sdLaT::P64;
           R2 = _sdLaS::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMmR: // global
           I64[Hp - 56] = sat_sdLbf_info;
           P64[Hp - 40] = _sdLaU::P64;
           P64[Hp - 32] = _sdLaV::P64;
           I64[Hp - 24] = sat_sdLb5_info;
           P64[Hp - 8] = _sdLaT::P64;
           P64[Hp] = _sdLaV::P64;
           R2 = _sdLaS::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.077761094 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldMap_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdMnj,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMnj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMnk; else goto cdMnl;
       cdMnk: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMnl: // global
           I64[Sp - 24] = block_cdMnc_info;
           R1 = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udMns; else goto cdMnd;
       udMns: // global
           call _cdMnc(R1) args: 0, res: 0, upd: 0;
       cdMnd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMnc() //  [R1]
         { info_tbl: [(cdMnc,
                       label: block_cdMnc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMnc: // global
           if (R1 & 7 == 1) goto cdMng; else goto cdMnh;
       cdMng: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdMnh: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.084237674 UTC

[section ""data" . poly_$dMonoid_rdL8r_closure" {
     poly_$dMonoid_rdL8r_closure:
         const poly_$dMonoid_rdL8r_info;
         const 0;
         const 0;
         const 0;
 },
 poly_$dMonoid_rdL8r_entry() //  [R1]
         { info_tbl: [(cdMnK,
                       label: poly_$dMonoid_rdL8r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMnK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMnL; else goto cdMnM;
       cdMnL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMnM: // global
           (_cdMnH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMnH::I64 == 0) goto cdMnJ; else goto cdMnI;
       cdMnJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMnI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMnH::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.08857973 UTC

[section ""data" . Data.Bifoldable.$dmbifoldl_closure" {
     Data.Bifoldable.$dmbifoldl_closure:
         const Data.Bifoldable.$dmbifoldl_info;
         const 0;
 },
 sat_sdLbx_entry() //  [R1, R2, R3]
         { info_tbl: [(cdMo3,
                       label: sat_sdLbx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMo3: // global
           _sdLbw::P64 = R3;
           R3 = R2;
           R2 = _sdLbw::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLbu_entry() //  [R1, R2, R3]
         { info_tbl: [(cdMob,
                       label: sat_sdLbu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMob: // global
           _sdLbt::P64 = R3;
           R3 = R2;
           R2 = _sdLbt::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.$dmbifoldl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdMoe,
                       label: Data.Bifoldable.$dmbifoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMoe: // global
           _sdLbr::P64 = R6;
           _sdLbq::P64 = R5;
           _sdLbp::P64 = R4;
           _sdLbo::P64 = R3;
           _sdLbn::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMof; else goto cdMog;
       cdMog: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMoi; else goto cdMoh;
       cdMoi: // global
           HpAlloc = 32;
           goto cdMof;
       cdMof: // global
           R6 = _sdLbr::P64;
           R5 = _sdLbq::P64;
           R4 = _sdLbp::P64;
           R3 = _sdLbo::P64;
           R2 = _sdLbn::P64;
           R1 = Data.Bifoldable.$dmbifoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMoh: // global
           I64[Hp - 24] = sat_sdLbx_info;
           P64[Hp - 16] = _sdLbp::P64;
           I64[Hp - 8] = sat_sdLbu_info;
           P64[Hp] = _sdLbo::P64;
           R2 = _sdLbn::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = poly_$dMonoid_rdL8r_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdLbr::P64;
           P64[Sp - 8] = _sdLbq::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.095990068 UTC

[section ""data" . Data.Bifoldable.$dmbifoldr_closure" {
     Data.Bifoldable.$dmbifoldr_closure:
         const Data.Bifoldable.$dmbifoldr_info;
         const 0;
 },
 Data.Bifoldable.$dmbifoldr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdMoA,
                       label: Data.Bifoldable.$dmbifoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMoA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdMoB; else goto cdMoC;
       cdMoB: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$dmbifoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMoC: // global
           R2 = R2;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R6;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.100827007 UTC

[section ""data" . Data.Bifoldable.$dmbifoldMap_closure" {
     Data.Bifoldable.$dmbifoldMap_closure:
         const Data.Bifoldable.$dmbifoldMap_info;
 },
 sat_sdLbN_entry() //  [R1]
         { info_tbl: [(cdMoQ,
                       label: sat_sdLbN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMoQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMoR; else goto cdMoS;
       cdMoR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMoS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLbM_entry() //  [R1, R2]
         { info_tbl: [(cdMoZ,
                       label: sat_sdLbM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMoZ: // global
           _sdLbK::P64 = R2;
           _sdLbM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMp0; else goto cdMp1;
       cdMp1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMp3; else goto cdMp2;
       cdMp3: // global
           HpAlloc = 32;
           goto cdMp0;
       cdMp0: // global
           R2 = _sdLbK::P64;
           R1 = _sdLbM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMp2: // global
           _sdLbE::P64 = P64[_sdLbM::P64 + 7];
           _sdLbG::P64 = P64[_sdLbM::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLbG::P64;
           P64[Hp] = _sdLbK::P64;
           R2 = _sdLbE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdLbJ_entry() //  [R1, R2]
         { info_tbl: [(cdMpa,
                       label: sat_sdLbJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMpa: // global
           _sdLbH::P64 = R2;
           _sdLbJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMpb; else goto cdMpc;
       cdMpc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMpe; else goto cdMpd;
       cdMpe: // global
           HpAlloc = 32;
           goto cdMpb;
       cdMpb: // global
           R2 = _sdLbH::P64;
           R1 = _sdLbJ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMpd: // global
           _sdLbE::P64 = P64[_sdLbJ::P64 + 7];
           _sdLbF::P64 = P64[_sdLbJ::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLbF::P64;
           P64[Hp] = _sdLbH::P64;
           R2 = _sdLbE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.$dmbifoldMap_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdMpf,
                       label: Data.Bifoldable.$dmbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMpf: // global
           _sdLbG::P64 = R5;
           _sdLbF::P64 = R4;
           _sdLbE::P64 = R3;
           _sdLbD::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMpg; else goto cdMph;
       cdMph: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdMpj; else goto cdMpi;
       cdMpj: // global
           HpAlloc = 72;
           goto cdMpg;
       cdMpg: // global
           R5 = _sdLbG::P64;
           R4 = _sdLbF::P64;
           R3 = _sdLbE::P64;
           R2 = _sdLbD::P64;
           R1 = Data.Bifoldable.$dmbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMpi: // global
           I64[Hp - 64] = sat_sdLbN_info;
           P64[Hp - 48] = _sdLbE::P64;
           I64[Hp - 40] = sat_sdLbM_info;
           P64[Hp - 32] = _sdLbE::P64;
           P64[Hp - 24] = _sdLbG::P64;
           I64[Hp - 16] = sat_sdLbJ_info;
           P64[Hp - 8] = _sdLbE::P64;
           P64[Hp] = _sdLbF::P64;
           R2 = _sdLbD::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 15;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.111655681 UTC

[section ""data" . Data.Bifoldable.$dmbifold_closure" {
     Data.Bifoldable.$dmbifold_closure:
         const Data.Bifoldable.$dmbifold_info;
 },
 Data.Bifoldable.$dmbifold_entry() //  [R2, R3]
         { info_tbl: [(cdMpK,
                       label: Data.Bifoldable.$dmbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMpK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMpL; else goto cdMpM;
       cdMpL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$dmbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMpM: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.115965894 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifold_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifold_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdMq3,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMq3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMq4; else goto cdMq5;
       cdMq4: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMq5: // global
           I64[Sp - 8] = block_cdMpW_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udMqc; else goto cdMpX;
       udMqc: // global
           call _cdMpW(R1) args: 0, res: 0, upd: 0;
       cdMpX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMpW() //  [R1]
         { info_tbl: [(cdMpW,
                       label: block_cdMpW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMpW: // global
           if (R1 & 7 == 1) goto cdMq0; else goto cdMq1;
       cdMq0: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdMq1: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.122828388 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldr_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdMqz,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMqz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMqA; else goto cdMqB;
       cdMqA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMqB: // global
           I64[Sp - 32] = block_cdMqs_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udMqI; else goto cdMqt;
       udMqI: // global
           call _cdMqs(R1) args: 0, res: 0, upd: 0;
       cdMqt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMqs() //  [R1]
         { info_tbl: [(cdMqs,
                       label: block_cdMqs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMqs: // global
           _sdLbX::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdMqw; else goto cdMqx;
       cdMqw: // global
           R3 = _sdLbX::P64;
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMqx: // global
           R3 = _sdLbX::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.129872314 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldl_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdMr5,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMr5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMr6; else goto cdMr7;
       cdMr6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMr7: // global
           I64[Sp - 32] = block_cdMqY_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udMre; else goto cdMqZ;
       udMre: // global
           call _cdMqY(R1) args: 0, res: 0, upd: 0;
       cdMqZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMqY() //  [R1]
         { info_tbl: [(cdMqY,
                       label: block_cdMqY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMqY: // global
           _sdLc4::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdMr2; else goto cdMr3;
       cdMr2: // global
           R3 = P64[R1 + 7];
           R2 = _sdLc4::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMr3: // global
           R3 = P64[R1 + 6];
           R2 = _sdLc4::P64;
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.135450175 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_closure" {
     Data.Bifoldable.$fBifoldableEither_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableEither_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.137691779 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdMrx,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMrx: // global
           _sdLca::P64 = R3;
           _sdLc9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMry; else goto cdMrz;
       cdMrz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMrB; else goto cdMrA;
       cdMrB: // global
           HpAlloc = 48;
           goto cdMry;
       cdMry: // global
           R3 = _sdLca::P64;
           R2 = _sdLc9::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMrA: // global
           I64[Hp - 40] = stg_sel_6_upd_info;
           P64[Hp - 24] = _sdLca::P64;
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLca::P64;
           R2 = _sdLc9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.14235786 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_info;
 },
 sat_sdLcP_entry() //  [R1]
         { info_tbl: [(cdMrS,
                       label: sat_sdLcP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMrS: // global
           _sdLcP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMrT; else goto cdMrU;
       cdMrU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMrW; else goto cdMrV;
       cdMrW: // global
           HpAlloc = 24;
           goto cdMrT;
       cdMrT: // global
           R1 = _sdLcP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMrV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLcP::P64;
           _sdLcu::P64 = P64[_sdLcP::P64 + 16];
           _sdLcv::P64 = P64[_sdLcP::P64 + 24];
           _sdLcw::P64 = P64[_sdLcP::P64 + 32];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdLcw::P64;
           R3 = _sdLcv::P64;
           R2 = Hp - 16;
           R1 = _sdLcu::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdMrY,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMrY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMs2; else goto cdMs1;
       cdMs2: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMs1: // global
           I64[Hp - 56] = sat_sdLcP_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLct::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLct::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.149191512 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_info;
 },
 sat_sdLd3_entry() //  [R1]
         { info_tbl: [(cdMsl,
                       label: sat_sdLd3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMsl: // global
           _sdLd3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMsm; else goto cdMsn;
       cdMsn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMsp; else goto cdMso;
       cdMsp: // global
           HpAlloc = 24;
           goto cdMsm;
       cdMsm: // global
           R1 = _sdLd3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMso: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLd3::P64;
           _sdLcQ::P64 = P64[_sdLd3::P64 + 16];
           _sdLcS::P64 = P64[_sdLd3::P64 + 24];
           _sdLcT::P64 = P64[_sdLd3::P64 + 32];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLcT::P64;
           R3 = Hp - 16;
           R2 = _sdLcS::P64;
           R1 = _sdLcQ::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdMsq,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMsq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMsu; else goto cdMst;
       cdMsu: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMst: // global
           I64[Hp - 56] = stg_sel_6_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLd3_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLcR::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLcR::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.155626708 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.157796216 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdMsK,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMsK: // global
           _sdLde::P64 = R3;
           _sdLdd::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMsL; else goto cdMsM;
       cdMsM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMsO; else goto cdMsN;
       cdMsO: // global
           HpAlloc = 48;
           goto cdMsL;
       cdMsL: // global
           R3 = _sdLde::P64;
           R2 = _sdLdd::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMsN: // global
           I64[Hp - 40] = stg_sel_5_upd_info;
           P64[Hp - 24] = _sdLde::P64;
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLde::P64;
           R2 = _sdLdd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.163071785 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_info;
 },
 sat_sdLdP_entry() //  [R1]
         { info_tbl: [(cdMt5,
                       label: sat_sdLdP_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMt5: // global
           _sdLdP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMt6; else goto cdMt7;
       cdMt7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMt9; else goto cdMt8;
       cdMt9: // global
           HpAlloc = 24;
           goto cdMt6;
       cdMt6: // global
           R1 = _sdLdP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMt8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLdP::P64;
           _sdLdw::P64 = P64[_sdLdP::P64 + 16];
           _sdLdx::P64 = P64[_sdLdP::P64 + 24];
           _sdLdy::P64 = P64[_sdLdP::P64 + 32];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdLdy::P64;
           R3 = _sdLdx::P64;
           R2 = Hp - 16;
           R1 = _sdLdw::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdMtb,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMtb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMtf; else goto cdMte;
       cdMtf: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMte: // global
           I64[Hp - 56] = sat_sdLdP_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLdv::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLdv::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.169528158 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_info;
 },
 sat_sdLe2_entry() //  [R1]
         { info_tbl: [(cdMty,
                       label: sat_sdLe2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMty: // global
           _sdLe2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMtz; else goto cdMtA;
       cdMtA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMtC; else goto cdMtB;
       cdMtC: // global
           HpAlloc = 24;
           goto cdMtz;
       cdMtz: // global
           R1 = _sdLe2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMtB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLe2::P64;
           _sdLdQ::P64 = P64[_sdLe2::P64 + 16];
           _sdLdS::P64 = P64[_sdLe2::P64 + 24];
           _sdLdT::P64 = P64[_sdLe2::P64 + 32];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLdT::P64;
           R3 = Hp - 16;
           R2 = _sdLdS::P64;
           R1 = _sdLdQ::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdMtD,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMtD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMtH; else goto cdMtG;
       cdMtH: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMtG: // global
           I64[Hp - 56] = stg_sel_5_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLe2_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLdR::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLdR::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.176053963 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.178216749 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdMtX,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMtX: // global
           _sdLec::P64 = R3;
           _sdLeb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMtY; else goto cdMtZ;
       cdMtZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMu1; else goto cdMu0;
       cdMu1: // global
           HpAlloc = 48;
           goto cdMtY;
       cdMtY: // global
           R3 = _sdLec::P64;
           R2 = _sdLeb::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMu0: // global
           I64[Hp - 40] = stg_sel_4_upd_info;
           P64[Hp - 24] = _sdLec::P64;
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLec::P64;
           R2 = _sdLeb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.182775607 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_info;
 },
 sat_sdLeJ_entry() //  [R1]
         { info_tbl: [(cdMui,
                       label: sat_sdLeJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMui: // global
           _sdLeJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMuj; else goto cdMuk;
       cdMuk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMum; else goto cdMul;
       cdMum: // global
           HpAlloc = 24;
           goto cdMuj;
       cdMuj: // global
           R1 = _sdLeJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMul: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLeJ::P64;
           _sdLes::P64 = P64[_sdLeJ::P64 + 16];
           _sdLet::P64 = P64[_sdLeJ::P64 + 24];
           _sdLeu::P64 = P64[_sdLeJ::P64 + 32];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdLeu::P64;
           R3 = _sdLet::P64;
           R2 = Hp - 16;
           R1 = _sdLes::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdMuo,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMuo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMus; else goto cdMur;
       cdMus: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMur: // global
           I64[Hp - 56] = sat_sdLeJ_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLer::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLer::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.189579863 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_info;
 },
 sat_sdLeV_entry() //  [R1]
         { info_tbl: [(cdMuL,
                       label: sat_sdLeV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMuL: // global
           _sdLeV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMuM; else goto cdMuN;
       cdMuN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMuP; else goto cdMuO;
       cdMuP: // global
           HpAlloc = 24;
           goto cdMuM;
       cdMuM: // global
           R1 = _sdLeV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMuO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLeV::P64;
           _sdLeK::P64 = P64[_sdLeV::P64 + 16];
           _sdLeM::P64 = P64[_sdLeV::P64 + 24];
           _sdLeN::P64 = P64[_sdLeV::P64 + 32];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLeN::P64;
           R3 = Hp - 16;
           R2 = _sdLeM::P64;
           R1 = _sdLeK::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdMuQ,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMuQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMuU; else goto cdMuT;
       cdMuU: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMuT: // global
           I64[Hp - 56] = stg_sel_4_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLeV_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLeL::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLeL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.196070627 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.198708164 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdMva,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMva: // global
           _sdLf4::P64 = R3;
           _sdLf3::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMvb; else goto cdMvc;
       cdMvc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMve; else goto cdMvd;
       cdMve: // global
           HpAlloc = 48;
           goto cdMvb;
       cdMvb: // global
           R3 = _sdLf4::P64;
           R2 = _sdLf3::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMvd: // global
           I64[Hp - 40] = stg_sel_3_upd_info;
           P64[Hp - 24] = _sdLf4::P64;
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdLf4::P64;
           R2 = _sdLf3::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.203044454 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_info;
 },
 sat_sdLfx_entry() //  [R1]
         { info_tbl: [(cdMvv,
                       label: sat_sdLfx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMvv: // global
           _sdLfx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMvw; else goto cdMvx;
       cdMvx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMvz; else goto cdMvy;
       cdMvz: // global
           HpAlloc = 24;
           goto cdMvw;
       cdMvw: // global
           R1 = _sdLfx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMvy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLfx::P64;
           _sdLfi::P64 = P64[_sdLfx::P64 + 16];
           _sdLfj::P64 = P64[_sdLfx::P64 + 24];
           _sdLfk::P64 = P64[_sdLfx::P64 + 32];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdLfk::P64;
           R3 = _sdLfj::P64;
           R2 = Hp - 16;
           R1 = _sdLfi::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdMvB,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMvB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMvF; else goto cdMvE;
       cdMvF: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMvE: // global
           I64[Hp - 56] = sat_sdLfx_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLfh::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLfh::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.209860175 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_info;
 },
 sat_sdLfI_entry() //  [R1]
         { info_tbl: [(cdMvY,
                       label: sat_sdLfI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMvY: // global
           _sdLfI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMvZ; else goto cdMw0;
       cdMw0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMw2; else goto cdMw1;
       cdMw2: // global
           HpAlloc = 24;
           goto cdMvZ;
       cdMvZ: // global
           R1 = _sdLfI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMw1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLfI::P64;
           _sdLfy::P64 = P64[_sdLfI::P64 + 16];
           _sdLfA::P64 = P64[_sdLfI::P64 + 24];
           _sdLfB::P64 = P64[_sdLfI::P64 + 32];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdLfB::P64;
           R3 = Hp - 16;
           R2 = _sdLfA::P64;
           R1 = _sdLfy::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdMw3,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMw3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMw7; else goto cdMw6;
       cdMw7: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMw6: // global
           I64[Hp - 56] = stg_sel_3_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLfI_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLfz::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLfz::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.216042536 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.2184703 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdMwn,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMwn: // global
           _sdLfQ::P64 = R3;
           _sdLfP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMwo; else goto cdMwp;
       cdMwp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMwr; else goto cdMwq;
       cdMwr: // global
           HpAlloc = 48;
           goto cdMwo;
       cdMwo: // global
           R3 = _sdLfQ::P64;
           R2 = _sdLfP::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMwq: // global
           I64[Hp - 40] = stg_sel_2_upd_info;
           P64[Hp - 24] = _sdLfQ::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdLfQ::P64;
           R2 = _sdLfP::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.222964381 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_info;
 },
 sat_sdLgf_entry() //  [R1]
         { info_tbl: [(cdMwI,
                       label: sat_sdLgf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMwI: // global
           _sdLgf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMwJ; else goto cdMwK;
       cdMwK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMwM; else goto cdMwL;
       cdMwM: // global
           HpAlloc = 24;
           goto cdMwJ;
       cdMwJ: // global
           R1 = _sdLgf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMwL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLgf::P64;
           _sdLg2::P64 = P64[_sdLgf::P64 + 16];
           _sdLg3::P64 = P64[_sdLgf::P64 + 24];
           _sdLg4::P64 = P64[_sdLgf::P64 + 32];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdLg4::P64;
           R3 = _sdLg3::P64;
           R2 = Hp - 16;
           R1 = _sdLg2::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdMwO,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMwO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMwS; else goto cdMwR;
       cdMwS: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMwR: // global
           I64[Hp - 56] = sat_sdLgf_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLg1::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLg1::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.229608619 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_info;
 },
 sat_sdLgp_entry() //  [R1]
         { info_tbl: [(cdMxb,
                       label: sat_sdLgp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMxb: // global
           _sdLgp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMxc; else goto cdMxd;
       cdMxd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMxf; else goto cdMxe;
       cdMxf: // global
           HpAlloc = 24;
           goto cdMxc;
       cdMxc: // global
           R1 = _sdLgp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMxe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLgp::P64;
           _sdLgg::P64 = P64[_sdLgp::P64 + 16];
           _sdLgi::P64 = P64[_sdLgp::P64 + 24];
           _sdLgj::P64 = P64[_sdLgp::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdLgj::P64;
           R3 = Hp - 16;
           R2 = _sdLgi::P64;
           R1 = _sdLgg::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdMxg,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMxg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMxk; else goto cdMxj;
       cdMxk: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMxj: // global
           I64[Hp - 56] = stg_sel_2_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLgp_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLgh::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLgh::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.236648336 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.238588676 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK2_closure" {
     Data.Bifoldable.$fBifoldableK2_closure:
         const Data.Bifoldable.$fBifoldableK2_info;
 },
 Data.Bifoldable.$fBifoldableK2_entry() //  [R3]
         { info_tbl: [(cdMxy,
                       label: Data.Bifoldable.$fBifoldableK2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMxy: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.242033926 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldr_entry() //  [R2, R4, R5]
         { info_tbl: [(cdMxJ,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMxJ: // global
           R3 = R4;
           _sdLgx::P64 = R2;
           R2 = R5;
           R1 = _sdLgx::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.245456603 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldl_entry() //  [R2, R4, R5]
         { info_tbl: [(cdMxU,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMxU: // global
           R3 = R5;
           _sdLgB::P64 = R2;
           R2 = R4;
           R1 = _sdLgB::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.248689554 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_closure" {
     Data.Bifoldable.$fBifoldableK1_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableK2_closure+2;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.250550178 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst1_closure" {
     Data.Bifoldable.$fBifoldableConst1_closure:
         const Data.Bifoldable.$fBifoldableConst1_info;
 },
 Data.Bifoldable.$fBifoldableConst1_entry() //  [R3]
         { info_tbl: [(cdMy6,
                       label: Data.Bifoldable.$fBifoldableConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMy6: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.253848036 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldr_entry() //  [R2, R4,
                                                          R5]
         { info_tbl: [(cdMyh,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMyh: // global
           R3 = R4;
           _sdLgH::P64 = R2;
           R2 = R5;
           R1 = _sdLgH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.25754722 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldl_entry() //  [R2, R4,
                                                          R5]
         { info_tbl: [(cdMys,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMys: // global
           R3 = R5;
           _sdLgL::P64 = R2;
           R2 = R4;
           R1 = _sdLgL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.260796807 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_closure" {
     Data.Bifoldable.$fBifoldableConst_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableConst1_closure+2;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.262876784 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdMyG,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMyG: // global
           _sdLgQ::P64 = R3;
           _sdLgP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMyH; else goto cdMyI;
       cdMyI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMyK; else goto cdMyJ;
       cdMyK: // global
           HpAlloc = 48;
           goto cdMyH;
       cdMyH: // global
           R3 = _sdLgQ::P64;
           R2 = _sdLgP::P64;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMyJ: // global
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sdLgQ::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdLgQ::P64;
           R2 = _sdLgP::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.268179845 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldr_info;
 },
 sat_sdLhb_entry() //  [R1]
         { info_tbl: [(cdMz1,
                       label: sat_sdLhb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMz1: // global
           _sdLhb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMz2; else goto cdMz3;
       cdMz3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMz5; else goto cdMz4;
       cdMz5: // global
           HpAlloc = 24;
           goto cdMz2;
       cdMz2: // global
           R1 = _sdLhb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMz4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLhb::P64;
           _sdLh0::P64 = P64[_sdLhb::P64 + 16];
           _sdLh1::P64 = P64[_sdLhb::P64 + 24];
           _sdLh2::P64 = P64[_sdLhb::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdLh2::P64;
           R3 = _sdLh1::P64;
           R2 = Hp - 16;
           R1 = _sdLh0::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldr_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdMz7,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMz7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMzb; else goto cdMza;
       cdMzb: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMza: // global
           I64[Hp - 56] = sat_sdLhb_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdLgZ::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdLgZ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.274516458 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldl_info;
 },
 sat_sdLhk_entry() //  [R1]
         { info_tbl: [(cdMzu,
                       label: sat_sdLhk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMzu: // global
           _sdLhk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMzv; else goto cdMzw;
       cdMzw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMzy; else goto cdMzx;
       cdMzy: // global
           HpAlloc = 24;
           goto cdMzv;
       cdMzv: // global
           R1 = _sdLhk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMzx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLhk::P64;
           _sdLhc::P64 = P64[_sdLhk::P64 + 16];
           _sdLhe::P64 = P64[_sdLhk::P64 + 24];
           _sdLhf::P64 = P64[_sdLhk::P64 + 32];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdLhf::P64;
           R3 = Hp - 16;
           R2 = _sdLhe::P64;
           R1 = _sdLhc::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldl_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdMzz,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMzz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdMzD; else goto cdMzC;
       cdMzD: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMzC: // global
           I64[Hp - 56] = stg_sel_1_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdLhk_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdLhd::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdLhd::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.280802182 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_closure" {
     Data.Bifoldable.$fBifoldable(,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.283296987 UTC

[section ""data" . Data.Bifoldable.bifoldr'_closure" {
     Data.Bifoldable.bifoldr'_closure:
         const Data.Bifoldable.bifoldr'_info;
 },
 sat_sdLhD_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdMzY,
                       label: sat_sdLhD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMzY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMzZ; else goto cdMA0;
       cdMzZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMA0: // global
           I64[Sp - 16] = block_cdMzW_info;
           _sdLhA::P64 = R3;
           R3 = R4;
           _sdLhz::P64 = R2;
           R2 = _sdLhA::P64;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLhz::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMzW() //  [R1]
         { info_tbl: [(cdMzW,
                       label: block_cdMzW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMzW: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLhy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdMA9,
                       label: sat_sdLhy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMA9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMAa; else goto cdMAb;
       cdMAa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMAb: // global
           I64[Sp - 16] = block_cdMA7_info;
           _sdLhv::P64 = R3;
           R3 = R4;
           _sdLhu::P64 = R2;
           R2 = _sdLhv::P64;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLhu::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMA7() //  [R1]
         { info_tbl: [(cdMA7,
                       label: block_cdMA7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMA7: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldr'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdMAd,
                       label: Data.Bifoldable.bifoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMAd: // global
           _sdLht::P64 = R6;
           _sdLhs::P64 = R5;
           _sdLhr::P64 = R4;
           _sdLhq::P64 = R3;
           _sdLhp::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMAe; else goto cdMAf;
       cdMAf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMAh; else goto cdMAg;
       cdMAh: // global
           HpAlloc = 32;
           goto cdMAe;
       cdMAe: // global
           R6 = _sdLht::P64;
           R5 = _sdLhs::P64;
           R4 = _sdLhr::P64;
           R3 = _sdLhq::P64;
           R2 = _sdLhp::P64;
           R1 = Data.Bifoldable.bifoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMAg: // global
           I64[Hp - 24] = sat_sdLhD_info;
           P64[Hp - 16] = _sdLhr::P64;
           I64[Hp - 8] = sat_sdLhy_info;
           P64[Hp] = _sdLhq::P64;
           R2 = _sdLhp::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Hp - 5;
           P64[Sp - 32] = Hp - 21;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = _sdLht::P64;
           P64[Sp - 8] = _sdLhs::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldl_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.295191284 UTC

[section ""cstring" . lvl_rdL8s_bytes" {
     lvl_rdL8s_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.297799028 UTC

[section ""data" . lvl1_rdL8t_closure" {
     lvl1_rdL8t_closure:
         const lvl1_rdL8t_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rdL8t_entry() //  [R1]
         { info_tbl: [(cdMAK,
                       label: lvl1_rdL8t_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMAK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMAL; else goto cdMAM;
       cdMAL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMAM: // global
           (_cdMAH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMAH::I64 == 0) goto cdMAJ; else goto cdMAI;
       cdMAJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMAI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMAH::I64;
           R2 = lvl_rdL8s_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.302377451 UTC

[section ""cstring" . Data.Bifoldable.$trModule4_bytes" {
     Data.Bifoldable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.304961199 UTC

[section ""data" . lvl2_rdL8u_closure" {
     lvl2_rdL8u_closure:
         const lvl2_rdL8u_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdL8u_entry() //  [R1]
         { info_tbl: [(cdMB1,
                       label: lvl2_rdL8u_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMB1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMB2; else goto cdMB3;
       cdMB2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMB3: // global
           (_cdMAY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMAY::I64 == 0) goto cdMB0; else goto cdMAZ;
       cdMB0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMAZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMAY::I64;
           R2 = Data.Bifoldable.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.308812643 UTC

[section ""cstring" . Data.Bifoldable.$trModule2_bytes" {
     Data.Bifoldable.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,102,111,108,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.310621095 UTC

[section ""data" . lvl3_rdL8v_closure" {
     lvl3_rdL8v_closure:
         const lvl3_rdL8v_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdL8v_entry() //  [R1]
         { info_tbl: [(cdMBi,
                       label: lvl3_rdL8v_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMBi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMBj; else goto cdMBk;
       cdMBj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMBk: // global
           (_cdMBf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMBf::I64 == 0) goto cdMBh; else goto cdMBg;
       cdMBh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMBg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMBf::I64;
           R2 = Data.Bifoldable.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.314384309 UTC

[section ""cstring" . lvl4_rdL8w_bytes" {
     lvl4_rdL8w_bytes:
         I8[] [46,47,68,97,116,97,47,66,105,102,111,108,100,97,98,108,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.316275028 UTC

[section ""data" . lvl5_rdL8x_closure" {
     lvl5_rdL8x_closure:
         const lvl5_rdL8x_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rdL8x_entry() //  [R1]
         { info_tbl: [(cdMBz,
                       label: lvl5_rdL8x_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMBz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMBA; else goto cdMBB;
       cdMBA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMBB: // global
           (_cdMBw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMBw::I64 == 0) goto cdMBy; else goto cdMBx;
       cdMBy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMBx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMBw::I64;
           R2 = lvl4_rdL8w_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.320220112 UTC

[section ""data" . lvl6_rdL8y_closure" {
     lvl6_rdL8y_closure:
         const GHC.Types.I#_con_info;
         const 188;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.321917876 UTC

[section ""data" . lvl7_rdL8z_closure" {
     lvl7_rdL8z_closure:
         const GHC.Types.I#_con_info;
         const 28;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.323544502 UTC

[section ""data" . lvl8_rdL8A_closure" {
     lvl8_rdL8A_closure:
         const GHC.Types.I#_con_info;
         const 61;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.325256953 UTC

[section ""data" . lvl9_rdL8B_closure" {
     lvl9_rdL8B_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl6_rdL8y_closure+1;
         const lvl7_rdL8z_closure+1;
         const lvl6_rdL8y_closure+1;
         const lvl8_rdL8A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.327005302 UTC

[section ""data" . lvl10_rdL8C_closure" {
     lvl10_rdL8C_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl9_rdL8B_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.328763802 UTC

[section ""cstring" . lvl11_rdL8D_bytes" {
     lvl11_rdL8D_bytes:
         I8[] [98,105,102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.330847098 UTC

[section ""data" . Data.Bifoldable.bifoldr2_closure" {
     Data.Bifoldable.bifoldr2_closure:
         const Data.Bifoldable.bifoldr2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bifoldr2_entry() //  [R1]
         { info_tbl: [(cdMBX,
                       label: Data.Bifoldable.bifoldr2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMBX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMBY; else goto cdMBZ;
       cdMBY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMBZ: // global
           (_cdMBS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMBS::I64 == 0) goto cdMBU; else goto cdMBT;
       cdMBU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMBT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMBS::I64;
           I64[Sp - 24] = block_cdMBV_info;
           R2 = lvl11_rdL8D_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdMBV() //  [R1]
         { info_tbl: [(cdMBV,
                       label: block_cdMBV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMBV: // global
           R3 = R1;
           R2 = lvl10_rdL8C_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.34035418 UTC

[section ""data" . Data.Bifoldable.bifoldr1_closure" {
     Data.Bifoldable.bifoldr1_closure:
         const Data.Bifoldable.bifoldr1_info;
         const 0;
 },
 sat_sdLhN_entry() //  [R1]
         { info_tbl: [(cdMCx,
                       label: sat_sdLhN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMCx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdMCy; else goto cdMCz;
       cdMCy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMCz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdMCq_info;
           _sdLhG::P64 = P64[R1 + 16];
           _sdLhJ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdLhG::P64;
           P64[Sp - 24] = _sdLhJ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udMCG; else goto cdMCr;
       udMCG: // global
           call _cdMCq(R1) args: 0, res: 0, upd: 0;
       cdMCr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdMCq() //  [R1]
         { info_tbl: [(cdMCq,
                       label: block_cdMCq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMCq: // global
           _sdLhJ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdMCu; else goto cdMCv;
       cdMCu: // global
           R1 = _sdLhJ::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cdMCv: // global
           R3 = P64[R1 + 6];
           R2 = _sdLhJ::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLhI_entry() //  [R1, R2, R3]
         { info_tbl: [(cdMCI,
                       label: mbf_sdLhI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMCI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdMCM; else goto cdMCL;
       cdMCM: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMCL: // global
           _sdLhG::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLhN_info;
           P64[Hp - 32] = _sdLhG::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldr1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMCT,
                       label: Data.Bifoldable.bifoldr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMCT: // global
           _sdLhH::P64 = R4;
           _sdLhG::P64 = R3;
           _sdLhF::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMCU; else goto cdMCV;
       cdMCV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdMCX; else goto cdMCW;
       cdMCX: // global
           HpAlloc = 16;
           goto cdMCU;
       cdMCU: // global
           R4 = _sdLhH::P64;
           R3 = _sdLhG::P64;
           R2 = _sdLhF::P64;
           R1 = Data.Bifoldable.bifoldr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMCW: // global
           I64[Hp - 8] = mbf_sdLhI_info;
           P64[Hp] = _sdLhG::P64;
           I64[Sp - 8] = block_cdMCN_info;
           R2 = _sdLhF::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdMCh::P64 = Hp - 6;
           P64[Sp - 40] = _cdMCh::P64;
           P64[Sp - 32] = _cdMCh::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLhH::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdMCN() //  [R1]
         { info_tbl: [(cdMCN,
                       label: block_cdMCN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMCN: // global
           if (R1 & 7 == 1) goto cdMCQ; else goto cdMCR;
       cdMCQ: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdMCR: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.353679954 UTC

[section ""data" . Data.Bifoldable.bimaximumBy_closure" {
     Data.Bifoldable.bimaximumBy_closure:
         const Data.Bifoldable.bimaximumBy_info;
         const 0;
 },
 sat_sdLhZ_entry() //  [R1]
         { info_tbl: [(cdMDN,
                       label: sat_sdLhZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMDN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdMDO; else goto cdMDP;
       cdMDO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMDP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdMDG_info;
           _sdLhR::P64 = P64[R1 + 16];
           _sdLhU::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdLhR::P64;
           P64[Sp - 24] = _sdLhU::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udMEb; else goto cdMDH;
       udMEb: // global
           call _cdMDG(R1) args: 0, res: 0, upd: 0;
       cdMDH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdMDG() //  [R1]
         { info_tbl: [(cdMDG,
                       label: block_cdMDG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMDG: // global
           if (R1 & 7 == 1) goto udME8; else goto cdMDL;
       udME8: // global
           Sp = Sp + 16;
           call _cdME6() args: 0, res: 0, upd: 0;
       cdMDL: // global
           I64[Sp] = block_cdMDV_info;
           _sdLhX::P64 = P64[R1 + 6];
           R3 = _sdLhX::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdLhX::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdMDV() //  [R1]
         { info_tbl: [(cdMDV,
                       label: block_cdMDV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMDV: // global
           if (R1 & 7 == 3) goto udME9; else goto cdME2;
       udME9: // global
           Sp = Sp + 16;
           call _cdME6() args: 0, res: 0, upd: 0;
       cdME2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cdME6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdME6: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLhT_entry() //  [R1, R2, R3]
         { info_tbl: [(cdMEe,
                       label: mbf_sdLhT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMEe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdMEi; else goto cdMEh;
       cdMEi: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMEh: // global
           _sdLhR::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLhZ_info;
           P64[Hp - 32] = _sdLhR::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bimaximumBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMEp,
                       label: Data.Bifoldable.bimaximumBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMEp: // global
           _sdLhS::P64 = R4;
           _sdLhR::P64 = R3;
           _sdLhQ::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMEq; else goto cdMEr;
       cdMEr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdMEt; else goto cdMEs;
       cdMEt: // global
           HpAlloc = 16;
           goto cdMEq;
       cdMEq: // global
           R4 = _sdLhS::P64;
           R3 = _sdLhR::P64;
           R2 = _sdLhQ::P64;
           R1 = Data.Bifoldable.bimaximumBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMEs: // global
           I64[Hp - 8] = mbf_sdLhT_info;
           P64[Hp] = _sdLhR::P64;
           I64[Sp - 8] = block_cdMEj_info;
           R2 = _sdLhQ::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdMDx::P64 = Hp - 6;
           P64[Sp - 40] = _cdMDx::P64;
           P64[Sp - 32] = _cdMDx::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLhS::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdMEj() //  [R1]
         { info_tbl: [(cdMEj,
                       label: block_cdMEj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMEj: // global
           if (R1 & 7 == 1) goto cdMEm; else goto cdMEn;
       cdMEm: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdMEn: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.369970781 UTC

[section ""data" . Data.Bifoldable.biminimumBy_closure" {
     Data.Bifoldable.biminimumBy_closure:
         const Data.Bifoldable.biminimumBy_info;
         const 0;
 },
 sat_sdLib_entry() //  [R1]
         { info_tbl: [(cdMFq,
                       label: sat_sdLib_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMFq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdMFr; else goto cdMFs;
       cdMFr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMFs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdMFj_info;
           _sdLi3::P64 = P64[R1 + 16];
           _sdLi6::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdLi3::P64;
           P64[Sp - 24] = _sdLi6::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udMFO; else goto cdMFk;
       udMFO: // global
           call _cdMFj(R1) args: 0, res: 0, upd: 0;
       cdMFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdMFj() //  [R1]
         { info_tbl: [(cdMFj,
                       label: block_cdMFj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMFj: // global
           if (R1 & 7 == 1) goto udMFL; else goto cdMFo;
       udMFL: // global
           Sp = Sp + 16;
           call _cdMFF() args: 0, res: 0, upd: 0;
       cdMFo: // global
           I64[Sp] = block_cdMFy_info;
           _sdLi9::P64 = P64[R1 + 6];
           R3 = _sdLi9::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdLi9::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdMFy() //  [R1]
         { info_tbl: [(cdMFy,
                       label: block_cdMFy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMFy: // global
           if (R1 & 7 == 3) goto cdMFJ; else goto udMFM;
       cdMFJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       udMFM: // global
           Sp = Sp + 16;
           call _cdMFF() args: 0, res: 0, upd: 0;
     }
 },
 _cdMFF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMFF: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLi5_entry() //  [R1, R2, R3]
         { info_tbl: [(cdMFR,
                       label: mbf_sdLi5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMFR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdMFV; else goto cdMFU;
       cdMFV: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMFU: // global
           _sdLi3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLib_info;
           P64[Hp - 32] = _sdLi3::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biminimumBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMG2,
                       label: Data.Bifoldable.biminimumBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMG2: // global
           _sdLi4::P64 = R4;
           _sdLi3::P64 = R3;
           _sdLi2::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMG3; else goto cdMG4;
       cdMG4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdMG6; else goto cdMG5;
       cdMG6: // global
           HpAlloc = 16;
           goto cdMG3;
       cdMG3: // global
           R4 = _sdLi4::P64;
           R3 = _sdLi3::P64;
           R2 = _sdLi2::P64;
           R1 = Data.Bifoldable.biminimumBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMG5: // global
           I64[Hp - 8] = mbf_sdLi5_info;
           P64[Hp] = _sdLi3::P64;
           I64[Sp - 8] = block_cdMFW_info;
           R2 = _sdLi2::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdMFa::P64 = Hp - 6;
           P64[Sp - 40] = _cdMFa::P64;
           P64[Sp - 32] = _cdMFa::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLi4::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdMFW() //  [R1]
         { info_tbl: [(cdMFW,
                       label: block_cdMFW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMFW: // global
           if (R1 & 7 == 1) goto cdMFZ; else goto cdMG0;
       cdMFZ: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdMG0: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.386387311 UTC

[section ""data" . Data.Bifoldable.bifoldrM_closure" {
     Data.Bifoldable.bifoldrM_closure:
         const Data.Bifoldable.bifoldrM_info;
 },
 sat_sdLiu_entry() //  [R1]
         { info_tbl: [(cdMGR,
                       label: sat_sdLiu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMGR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMGS; else goto cdMGT;
       cdMGS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMGT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLit_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdMH0,
                       label: sat_sdLit_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMH0: // global
           _sdLir::P64 = R4;
           _sdLiq::P64 = R3;
           _sdLip::P64 = R2;
           _sdLit::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMH1; else goto cdMH2;
       cdMH2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdMH4; else goto cdMH3;
       cdMH4: // global
           HpAlloc = 40;
           goto cdMH1;
       cdMH1: // global
           R4 = _sdLir::P64;
           R3 = _sdLiq::P64;
           R2 = _sdLip::P64;
           R1 = _sdLit::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMH3: // global
           _sdLif::P64 = P64[_sdLit::P64 + 5];
           _sdLih::P64 = P64[_sdLit::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLih::P64;
           P64[Hp - 8] = _sdLiq::P64;
           P64[Hp] = _sdLir::P64;
           R2 = _sdLif::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLip::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdLio_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdMHb,
                       label: sat_sdLio_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMHb: // global
           _sdLim::P64 = R4;
           _sdLil::P64 = R3;
           _sdLik::P64 = R2;
           _sdLio::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMHc; else goto cdMHd;
       cdMHd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdMHf; else goto cdMHe;
       cdMHf: // global
           HpAlloc = 40;
           goto cdMHc;
       cdMHc: // global
           R4 = _sdLim::P64;
           R3 = _sdLil::P64;
           R2 = _sdLik::P64;
           R1 = _sdLio::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMHe: // global
           _sdLif::P64 = P64[_sdLio::P64 + 5];
           _sdLig::P64 = P64[_sdLio::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLig::P64;
           P64[Hp - 8] = _sdLil::P64;
           P64[Hp] = _sdLim::P64;
           R2 = _sdLif::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLik::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldrM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdMHg,
                       label: Data.Bifoldable.bifoldrM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMHg: // global
           _sdLii::P64 = R6;
           _sdLih::P64 = R5;
           _sdLig::P64 = R4;
           _sdLif::P64 = R3;
           _sdLie::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdMHh; else goto cdMHi;
       cdMHi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdMHk; else goto cdMHj;
       cdMHk: // global
           HpAlloc = 72;
           goto cdMHh;
       cdMHh: // global
           R6 = _sdLii::P64;
           R5 = _sdLih::P64;
           R4 = _sdLig::P64;
           R3 = _sdLif::P64;
           R2 = _sdLie::P64;
           R1 = Data.Bifoldable.bifoldrM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdMHj: // global
           I64[Hp - 64] = sat_sdLiu_info;
           P64[Hp - 48] = _sdLif::P64;
           I64[Hp - 40] = sat_sdLit_info;
           P64[Hp - 32] = _sdLif::P64;
           P64[Hp - 24] = _sdLih::P64;
           I64[Hp - 16] = sat_sdLio_info;
           P64[Hp - 8] = _sdLif::P64;
           P64[Hp] = _sdLig::P64;
           R2 = _sdLie::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = Hp - 37;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = _sdLii::P64;
           Sp = Sp - 40;
           call Data.Bifoldable.bifoldl_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.398526107 UTC

[section ""data" . Data.Bifoldable.bifoldl'_closure" {
     Data.Bifoldable.bifoldl'_closure:
         const Data.Bifoldable.bifoldl'_info;
 },
 sat_sdLiJ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdMHT,
                       label: sat_sdLiJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMHT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMHU; else goto cdMHV;
       cdMHU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMHV: // global
           I64[Sp - 16] = block_cdMHR_info;
           _sdLiG::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLiG::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMHR() //  [R1]
         { info_tbl: [(cdMHR,
                       label: block_cdMHR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMHR: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLiE_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdMI4,
                       label: sat_sdLiE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMI5; else goto cdMI6;
       cdMI5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMI6: // global
           I64[Sp - 16] = block_cdMI2_info;
           _sdLiB::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdLiB::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMI2() //  [R1]
         { info_tbl: [(cdMI2,
                       label: block_cdMI2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMI2: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldl'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdMI8,
                       label: Data.Bifoldable.bifoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMI8: // global
           _sdLiz::P64 = R6;
           _sdLiy::P64 = R5;
           _sdLix::P64 = R4;
           _sdLiw::P64 = R3;
           _sdLiv::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMI9; else goto cdMIa;
       cdMIa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMIc; else goto cdMIb;
       cdMIc: // global
           HpAlloc = 32;
           goto cdMI9;
       cdMI9: // global
           R6 = _sdLiz::P64;
           R5 = _sdLiy::P64;
           R4 = _sdLix::P64;
           R3 = _sdLiw::P64;
           R2 = _sdLiv::P64;
           R1 = Data.Bifoldable.bifoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMIb: // global
           I64[Hp - 24] = sat_sdLiJ_info;
           P64[Hp - 16] = _sdLix::P64;
           I64[Hp - 8] = sat_sdLiE_info;
           P64[Hp] = _sdLiw::P64;
           R2 = _sdLiv::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Hp - 5;
           P64[Sp - 32] = Hp - 21;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = _sdLiz::P64;
           P64[Sp - 8] = _sdLiy::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.41071401 UTC

[section ""data" . Data.Bifoldable.bilength2_closure" {
     Data.Bifoldable.bilength2_closure:
         const Data.Bifoldable.bilength2_info;
 },
 Data.Bifoldable.bilength2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMIF,
                       label: Data.Bifoldable.bilength2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMIF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMIM; else goto cdMIN;
       cdMIM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bilength2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMIN: // global
           I64[Sp - 16] = block_cdMIC_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udMIR; else goto cdMID;
       udMIR: // global
           call _cdMIC(R1) args: 0, res: 0, upd: 0;
       cdMID: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMIC() //  [R1]
         { info_tbl: [(cdMIC,
                       label: block_cdMIC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMIC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdMIQ; else goto cdMIP;
       cdMIQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdMIP: // global
           _sdLiP::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdLiP::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.416923979 UTC

[section ""data" . Data.Bifoldable.bilength1_closure" {
     Data.Bifoldable.bilength1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.419052157 UTC

[section ""data" . Data.Bifoldable.bilength_closure" {
     Data.Bifoldable.bilength_closure:
         const Data.Bifoldable.bilength_info;
 },
 Data.Bifoldable.bilength_entry() //  [R2, R3]
         { info_tbl: [(cdMJ7,
                       label: Data.Bifoldable.bilength_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMJ7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdMJ8; else goto cdMJ9;
       cdMJ8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bilength_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMJ9: // global
           R2 = R2;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Bifoldable.bilength2_closure+3;
           P64[Sp - 32] = Data.Bifoldable.bilength2_closure+3;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Data.Bifoldable.bilength1_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.422841842 UTC

[section ""data" . lvl12_rdL8E_closure" {
     lvl12_rdL8E_closure:
         const GHC.Types.I#_con_info;
         const 223;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.424553896 UTC

[section ""data" . lvl13_rdL8F_closure" {
     lvl13_rdL8F_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl12_rdL8E_closure+1;
         const lvl7_rdL8z_closure+1;
         const lvl12_rdL8E_closure+1;
         const lvl8_rdL8A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.426344351 UTC

[section ""data" . lvl14_rdL8G_closure" {
     lvl14_rdL8G_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl13_rdL8F_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.428110493 UTC

[section ""cstring" . lvl15_rdL8H_bytes" {
     lvl15_rdL8H_bytes:
         I8[] [98,105,102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.430918948 UTC

[section ""data" . Data.Bifoldable.bifoldl2_closure" {
     Data.Bifoldable.bifoldl2_closure:
         const Data.Bifoldable.bifoldl2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bifoldl2_entry() //  [R1]
         { info_tbl: [(cdMJr,
                       label: Data.Bifoldable.bifoldl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMJr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMJs; else goto cdMJt;
       cdMJs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMJt: // global
           (_cdMJm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMJm::I64 == 0) goto cdMJo; else goto cdMJn;
       cdMJo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMJn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMJm::I64;
           I64[Sp - 24] = block_cdMJp_info;
           R2 = lvl15_rdL8H_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdMJp() //  [R1]
         { info_tbl: [(cdMJp,
                       label: block_cdMJp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMJp: // global
           R3 = R1;
           R2 = lvl14_rdL8G_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.439623388 UTC

[section ""data" . Data.Bifoldable.bifoldl1_closure" {
     Data.Bifoldable.bifoldl1_closure:
         const Data.Bifoldable.bifoldl1_info;
         const 0;
 },
 sat_sdLj2_entry() //  [R1]
         { info_tbl: [(cdMK1,
                       label: sat_sdLj2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMK1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdMK2; else goto cdMK3;
       cdMK2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMK3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdMJU_info;
           _sdLiV::P64 = P64[R1 + 16];
           _sdLiZ::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdLiV::P64;
           P64[Sp - 24] = _sdLiZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udMKa; else goto cdMJV;
       udMKa: // global
           call _cdMJU(R1) args: 0, res: 0, upd: 0;
       cdMJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdMJU() //  [R1]
         { info_tbl: [(cdMJU,
                       label: block_cdMJU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMJU: // global
           _sdLiZ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdMJY; else goto cdMJZ;
       cdMJY: // global
           R1 = _sdLiZ::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cdMJZ: // global
           R3 = _sdLiZ::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdLiX_entry() //  [R1, R2, R3]
         { info_tbl: [(cdMKc,
                       label: mbf_sdLiX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMKc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdMKg; else goto cdMKf;
       cdMKg: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMKf: // global
           _sdLiV::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdLj2_info;
           P64[Hp - 32] = _sdLiV::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldl1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMKn,
                       label: Data.Bifoldable.bifoldl1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMKn: // global
           _sdLiW::P64 = R4;
           _sdLiV::P64 = R3;
           _sdLiU::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMKo; else goto cdMKp;
       cdMKp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdMKr; else goto cdMKq;
       cdMKr: // global
           HpAlloc = 16;
           goto cdMKo;
       cdMKo: // global
           R4 = _sdLiW::P64;
           R3 = _sdLiV::P64;
           R2 = _sdLiU::P64;
           R1 = Data.Bifoldable.bifoldl1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMKq: // global
           I64[Hp - 8] = mbf_sdLiX_info;
           P64[Hp] = _sdLiV::P64;
           I64[Sp - 8] = block_cdMKh_info;
           R2 = _sdLiU::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdMJL::P64 = Hp - 6;
           P64[Sp - 40] = _cdMJL::P64;
           P64[Sp - 32] = _cdMJL::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdLiW::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldl_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdMKh() //  [R1]
         { info_tbl: [(cdMKh,
                       label: block_cdMKh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMKh: // global
           if (R1 & 7 == 1) goto cdMKk; else goto cdMKl;
       cdMKk: // global
           R1 = Data.Bifoldable.bifoldl2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdMKl: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.454887986 UTC

[section ""data" . Data.Bifoldable.bifoldlM_closure" {
     Data.Bifoldable.bifoldlM_closure:
         const Data.Bifoldable.bifoldlM_info;
 },
 sat_sdLjl_entry() //  [R1]
         { info_tbl: [(cdML5,
                       label: sat_sdLjl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdML5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdML6; else goto cdML7;
       cdML6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdML7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdMLe,
                       label: sat_sdLjk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMLe: // global
           _sdLji::P64 = R4;
           _sdLjh::P64 = R3;
           _sdLjg::P64 = R2;
           _sdLjk::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMLf; else goto cdMLg;
       cdMLg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdMLi; else goto cdMLh;
       cdMLi: // global
           HpAlloc = 40;
           goto cdMLf;
       cdMLf: // global
           R4 = _sdLji::P64;
           R3 = _sdLjh::P64;
           R2 = _sdLjg::P64;
           R1 = _sdLjk::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMLh: // global
           _sdLj6::P64 = P64[_sdLjk::P64 + 5];
           _sdLj8::P64 = P64[_sdLjk::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLj8::P64;
           P64[Hp - 8] = _sdLji::P64;
           P64[Hp] = _sdLjg::P64;
           R2 = _sdLj6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLjh::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdLjf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdMLp,
                       label: sat_sdLjf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMLp: // global
           _sdLjd::P64 = R4;
           _sdLjc::P64 = R3;
           _sdLjb::P64 = R2;
           _sdLjf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdMLq; else goto cdMLr;
       cdMLr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdMLt; else goto cdMLs;
       cdMLt: // global
           HpAlloc = 40;
           goto cdMLq;
       cdMLq: // global
           R4 = _sdLjd::P64;
           R3 = _sdLjc::P64;
           R2 = _sdLjb::P64;
           R1 = _sdLjf::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMLs: // global
           _sdLj6::P64 = P64[_sdLjf::P64 + 5];
           _sdLj7::P64 = P64[_sdLjf::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdLj7::P64;
           P64[Hp - 8] = _sdLjd::P64;
           P64[Hp] = _sdLjb::P64;
           R2 = _sdLj6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdLjc::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldlM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdMLu,
                       label: Data.Bifoldable.bifoldlM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMLu: // global
           _sdLj9::P64 = R6;
           _sdLj8::P64 = R5;
           _sdLj7::P64 = R4;
           _sdLj6::P64 = R3;
           _sdLj5::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdMLv; else goto cdMLw;
       cdMLw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdMLy; else goto cdMLx;
       cdMLy: // global
           HpAlloc = 72;
           goto cdMLv;
       cdMLv: // global
           R6 = _sdLj9::P64;
           R5 = _sdLj8::P64;
           R4 = _sdLj7::P64;
           R3 = _sdLj6::P64;
           R2 = _sdLj5::P64;
           R1 = Data.Bifoldable.bifoldlM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdMLx: // global
           I64[Hp - 64] = sat_sdLjl_info;
           P64[Hp - 48] = _sdLj6::P64;
           I64[Hp - 40] = sat_sdLjk_info;
           P64[Hp - 32] = _sdLj6::P64;
           P64[Hp - 24] = _sdLj8::P64;
           I64[Hp - 16] = sat_sdLjf_info;
           P64[Hp - 8] = _sdLj6::P64;
           P64[Hp] = _sdLj7::P64;
           R2 = _sdLj5::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = Hp - 37;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = _sdLj9::P64;
           Sp = Sp - 40;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.467981679 UTC

[section ""data" . Data.Bifoldable.bitraverse__closure" {
     Data.Bifoldable.bitraverse__closure:
         const Data.Bifoldable.bitraverse__info;
 },
 sat_sdLjw_entry() //  [R1]
         { info_tbl: [(cdMM4,
                       label: sat_sdLjw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMM4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMM5; else goto cdMM6;
       cdMM5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMM6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sdLjv_entry() //  [R1, R2]
         { info_tbl: [(cdMMd,
                       label: sat_sdLjv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMMd: // global
           _sdLjt::P64 = R2;
           _sdLjv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMMe; else goto cdMMf;
       cdMMf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMMh; else goto cdMMg;
       cdMMh: // global
           HpAlloc = 32;
           goto cdMMe;
       cdMMe: // global
           R2 = _sdLjt::P64;
           R1 = _sdLjv::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMMg: // global
           _sdLjn::P64 = P64[_sdLjv::P64 + 7];
           _sdLjp::P64 = P64[_sdLjv::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLjp::P64;
           P64[Hp] = _sdLjt::P64;
           R2 = _sdLjn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdLjs_entry() //  [R1, R2]
         { info_tbl: [(cdMMo,
                       label: sat_sdLjs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMMo: // global
           _sdLjq::P64 = R2;
           _sdLjs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdMMp; else goto cdMMq;
       cdMMq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMMs; else goto cdMMr;
       cdMMs: // global
           HpAlloc = 32;
           goto cdMMp;
       cdMMp: // global
           R2 = _sdLjq::P64;
           R1 = _sdLjs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMMr: // global
           _sdLjn::P64 = P64[_sdLjs::P64 + 7];
           _sdLjo::P64 = P64[_sdLjs::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdLjo::P64;
           P64[Hp] = _sdLjq::P64;
           R2 = _sdLjn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bitraverse__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdMMt,
                       label: Data.Bifoldable.bitraverse__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMMt: // global
           _sdLjp::P64 = R5;
           _sdLjo::P64 = R4;
           _sdLjn::P64 = R3;
           _sdLjm::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMMu; else goto cdMMv;
       cdMMv: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdMMx; else goto cdMMw;
       cdMMx: // global
           HpAlloc = 72;
           goto cdMMu;
       cdMMu: // global
           R5 = _sdLjp::P64;
           R4 = _sdLjo::P64;
           R3 = _sdLjn::P64;
           R2 = _sdLjm::P64;
           R1 = Data.Bifoldable.bitraverse__closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMMw: // global
           I64[Hp - 64] = sat_sdLjw_info;
           P64[Hp - 48] = _sdLjn::P64;
           I64[Hp - 40] = sat_sdLjv_info;
           P64[Hp - 32] = _sdLjn::P64;
           P64[Hp - 24] = _sdLjp::P64;
           I64[Hp - 16] = sat_sdLjs_info;
           P64[Hp - 8] = _sdLjn::P64;
           P64[Hp] = _sdLjo::P64;
           R2 = _sdLjm::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 15;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.480809103 UTC

[section ""data" . Data.Bifoldable.bifor__closure" {
     Data.Bifoldable.bifor__closure:
         const Data.Bifoldable.bifor__info;
 },
 Data.Bifoldable.bifor__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdMMY,
                       label: Data.Bifoldable.bifor__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMMY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMMZ; else goto cdMN0;
       cdMMZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bifor__closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMN0: // global
           _sdLjA::P64 = R5;
           R5 = R6;
           _sdLjz::P64 = R4;
           R4 = _sdLjA::P64;
           R3 = R3;
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sdLjz::P64;
           Sp = Sp - 16;
           call Data.Bifoldable.bitraverse__entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.48550677 UTC

[section ""data" . Data.Bifoldable.biforM__closure" {
     Data.Bifoldable.biforM__closure:
         const Data.Bifoldable.biforM__info;
 },
 Data.Bifoldable.biforM__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdMNa,
                       label: Data.Bifoldable.biforM__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMNa: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bifor__entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.489344881 UTC

[section ""data" . Data.Bifoldable.bimapM__closure" {
     Data.Bifoldable.bimapM__closure:
         const Data.Bifoldable.bimapM__info;
 },
 Data.Bifoldable.bimapM__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdMNl,
                       label: Data.Bifoldable.bimapM__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMNl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bitraverse__entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.493844168 UTC

[section ""data" . Data.Bifoldable.bisequence__closure" {
     Data.Bifoldable.bisequence__closure:
         const Data.Bifoldable.bisequence__info;
 },
 sat_sdLjG_entry() //  [R1]
         { info_tbl: [(cdMNA,
                       label: sat_sdLjG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMNA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMNB; else goto cdMNC;
       cdMNB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMNC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sdLjF_entry() //  [R1]
         { info_tbl: [(cdMNH,
                       label: sat_sdLjF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMNH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMNI; else goto cdMNJ;
       cdMNI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMNJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjE_entry() //  [R1]
         { info_tbl: [(cdMNO,
                       label: sat_sdLjE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMNO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMNP; else goto cdMNQ;
       cdMNP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMNQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.bisequence__entry() //  [R2, R3]
         { info_tbl: [(cdMNR,
                       label: Data.Bifoldable.bisequence__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMNR: // global
           _sdLjD::P64 = R3;
           _sdLjC::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMNS; else goto cdMNT;
       cdMNT: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdMNV; else goto cdMNU;
       cdMNV: // global
           HpAlloc = 72;
           goto cdMNS;
       cdMNS: // global
           R3 = _sdLjD::P64;
           R2 = _sdLjC::P64;
           R1 = Data.Bifoldable.bisequence__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMNU: // global
           I64[Hp - 64] = sat_sdLjG_info;
           P64[Hp - 48] = _sdLjD::P64;
           I64[Hp - 40] = sat_sdLjF_info;
           P64[Hp - 24] = _sdLjD::P64;
           I64[Hp - 16] = sat_sdLjE_info;
           P64[Hp] = _sdLjD::P64;
           R2 = _sdLjC::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.505053822 UTC

[section ""data" . Data.Bifoldable.bisequenceA__closure" {
     Data.Bifoldable.bisequenceA__closure:
         const Data.Bifoldable.bisequenceA__info;
 },
 Data.Bifoldable.bisequenceA__entry() //  [R2, R3]
         { info_tbl: [(cdMOk,
                       label: Data.Bifoldable.bisequenceA__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMOk: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bisequence__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.509639141 UTC

[section ""data" . Data.Bifoldable.biasum_closure" {
     Data.Bifoldable.biasum_closure:
         const Data.Bifoldable.biasum_info;
 },
 sat_sdLjL_entry() //  [R1]
         { info_tbl: [(cdMOz,
                       label: sat_sdLjL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMOz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMOA; else goto cdMOB;
       cdMOA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMOB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjK_entry() //  [R1]
         { info_tbl: [(cdMOG,
                       label: sat_sdLjK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMOG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMOH; else goto cdMOI;
       cdMOH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMOI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLjJ_entry() //  [R1]
         { info_tbl: [(cdMON,
                       label: sat_sdLjJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMON: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMOO; else goto cdMOP;
       cdMOO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMOP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.biasum_entry() //  [R2, R3]
         { info_tbl: [(cdMOQ,
                       label: Data.Bifoldable.biasum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMOQ: // global
           _sdLjI::P64 = R3;
           _sdLjH::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMOR; else goto cdMOS;
       cdMOS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdMOU; else goto cdMOT;
       cdMOU: // global
           HpAlloc = 72;
           goto cdMOR;
       cdMOR: // global
           R3 = _sdLjI::P64;
           R2 = _sdLjH::P64;
           R1 = Data.Bifoldable.biasum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMOT: // global
           I64[Hp - 64] = sat_sdLjL_info;
           P64[Hp - 48] = _sdLjI::P64;
           I64[Hp - 40] = sat_sdLjK_info;
           P64[Hp - 24] = _sdLjI::P64;
           I64[Hp - 16] = sat_sdLjJ_info;
           P64[Hp] = _sdLjI::P64;
           R2 = _sdLjH::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.520263743 UTC

[section ""data" . Data.Bifoldable.bimsum_closure" {
     Data.Bifoldable.bimsum_closure:
         const Data.Bifoldable.bimsum_info;
 },
 Data.Bifoldable.bimsum_entry() //  [R2, R3]
         { info_tbl: [(cdMPj,
                       label: Data.Bifoldable.bimsum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMPj: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biasum_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.524074433 UTC

[section ""data" . Data.Bifoldable.biList_closure" {
     Data.Bifoldable.biList_closure:
         const Data.Bifoldable.biList_info;
 },
 Data.Bifoldable.biList_entry() //  [R2]
         { info_tbl: [(cdMPu,
                       label: Data.Bifoldable.biList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMPu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMPv; else goto cdMPw;
       cdMPv: // global
           R2 = R2;
           R1 = Data.Bifoldable.biList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMPw: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = GHC.Types.:_closure+2;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.528482933 UTC

[section ""data" . Data.Bifoldable.binull1_closure" {
     Data.Bifoldable.binull1_closure:
         const Data.Bifoldable.binull1_info;
 },
 Data.Bifoldable.binull1_entry() //  []
         { info_tbl: [(cdMPG,
                       label: Data.Bifoldable.binull1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMPG: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.532501831 UTC

[section ""data" . Data.Bifoldable.binull_closure" {
     Data.Bifoldable.binull_closure:
         const Data.Bifoldable.binull_info;
 },
 Data.Bifoldable.binull_entry() //  [R2]
         { info_tbl: [(cdMPS,
                       label: Data.Bifoldable.binull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMPS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMPT; else goto cdMPU;
       cdMPT: // global
           R2 = R2;
           R1 = Data.Bifoldable.binull_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMPU: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Bifoldable.binull1_closure+2;
           P64[Sp - 16] = Data.Bifoldable.binull1_closure+2;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.538696066 UTC

[section ""data" . Data.Bifoldable.biconcat_closure" {
     Data.Bifoldable.biconcat_closure:
         const Data.Bifoldable.biconcat_info;
         const 0;
 },
 Data.Bifoldable.biconcat_entry() //  [R2]
         { info_tbl: [(cdMQ4,
                       label: Data.Bifoldable.biconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMQ4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMQ5; else goto cdMQ6;
       cdMQ5: // global
           R2 = R2;
           R1 = Data.Bifoldable.biconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMQ6: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.$fMonoid[]_closure;
           Sp = Sp - 16;
           call Data.Bifoldable.bifold_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.544486971 UTC

[section ""data" . lvl16_rdL8I_closure" {
     lvl16_rdL8I_closure:
         const GHC.Types.I#_con_info;
         const 334;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.54715992 UTC

[section ""data" . lvl17_rdL8J_closure" {
     lvl17_rdL8J_closure:
         const GHC.Types.I#_con_info;
         const 24;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.549833559 UTC

[section ""data" . lvl18_rdL8K_closure" {
     lvl18_rdL8K_closure:
         const GHC.Types.I#_con_info;
         const 58;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.552638472 UTC

[section ""data" . lvl19_rdL8L_closure" {
     lvl19_rdL8L_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl16_rdL8I_closure+1;
         const lvl17_rdL8J_closure+1;
         const lvl16_rdL8I_closure+1;
         const lvl18_rdL8K_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.55570332 UTC

[section ""data" . lvl20_rdL8M_closure" {
     lvl20_rdL8M_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl19_rdL8L_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.558724122 UTC

[section ""cstring" . lvl21_rdL8N_bytes" {
     lvl21_rdL8N_bytes:
         I8[] [98,105,109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.562037587 UTC

[section ""data" . Data.Bifoldable.bimaximum1_closure" {
     Data.Bifoldable.bimaximum1_closure:
         const Data.Bifoldable.bimaximum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bimaximum1_entry() //  [R1]
         { info_tbl: [(cdMQq,
                       label: Data.Bifoldable.bimaximum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMQq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMQr; else goto cdMQs;
       cdMQr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMQs: // global
           (_cdMQl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMQl::I64 == 0) goto cdMQn; else goto cdMQm;
       cdMQn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMQm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMQl::I64;
           I64[Sp - 24] = block_cdMQo_info;
           R2 = lvl21_rdL8N_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdMQo() //  [R1]
         { info_tbl: [(cdMQo,
                       label: block_cdMQo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMQo: // global
           R3 = R1;
           R2 = lvl20_rdL8M_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.570036336 UTC

[section ""data" . Data.Bifoldable.bimaximum_closure" {
     Data.Bifoldable.bimaximum_closure:
         const Data.Bifoldable.bimaximum_info;
         const 0;
 },
 sat_sdLjV_entry() //  [R1]
         { info_tbl: [(cdMQS,
                       label: sat_sdLjV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMQS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMQT; else goto cdMQU;
       cdMQT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMQU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdLjU_entry() //  [R1]
         { info_tbl: [(cdMQV,
                       label: g_sdLjU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMQV: // global
           _sdLjU::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMQW; else goto cdMQX;
       cdMQX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMQZ; else goto cdMQY;
       cdMQZ: // global
           HpAlloc = 24;
           goto cdMQW;
       cdMQW: // global
           R1 = _sdLjU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMQY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLjU::P64;
           _sdLjS::P64 = P64[_sdLjU::P64 + 16];
           _sdLjT::P64 = P64[_sdLjU::P64 + 24];
           I64[Hp - 16] = sat_sdLjV_info;
           P64[Hp] = _sdLjT::P64;
           R2 = _sdLjS::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = GHC.Base.Just_closure+1;
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdLjZ_entry() //  [R1, R2]
         { info_tbl: [(cdMRb,
                       label: sat_sdLjZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMRb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMRc; else goto cdMRd;
       cdMRc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMRd: // global
           I64[Sp - 8] = block_cdMR5_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMR5() //  [R1]
         { info_tbl: [(cdMR5,
                       label: block_cdMR5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMR5: // global
           if (R1 & 7 == 1) goto cdMR8; else goto cdMR9;
       cdMR8: // global
           R1 = Data.Bifoldable.bimaximum1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdMR9: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bimaximum_entry() //  [R2, R3]
         { info_tbl: [(cdMRk,
                       label: Data.Bifoldable.bimaximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMRk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMRo; else goto cdMRn;
       cdMRo: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bimaximum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMRn: // global
           I64[Hp - 40] = g_sdLjU_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdLjZ_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.582399615 UTC

[section ""data" . lvl22_rdL8O_closure" {
     lvl22_rdL8O_closure:
         const GHC.Types.I#_con_info;
         const 342;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.584068679 UTC

[section ""data" . lvl23_rdL8P_closure" {
     lvl23_rdL8P_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl22_rdL8O_closure+1;
         const lvl17_rdL8J_closure+1;
         const lvl22_rdL8O_closure+1;
         const lvl18_rdL8K_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.585853224 UTC

[section ""data" . lvl24_rdL8Q_closure" {
     lvl24_rdL8Q_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl23_rdL8P_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.587584255 UTC

[section ""cstring" . lvl25_rdL8R_bytes" {
     lvl25_rdL8R_bytes:
         I8[] [98,105,109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.589768924 UTC

[section ""data" . Data.Bifoldable.biminimum1_closure" {
     Data.Bifoldable.biminimum1_closure:
         const Data.Bifoldable.biminimum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.biminimum1_entry() //  [R1]
         { info_tbl: [(cdMRZ,
                       label: Data.Bifoldable.biminimum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMRZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMS0; else goto cdMS1;
       cdMS0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMS1: // global
           (_cdMRU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdMRU::I64 == 0) goto cdMRW; else goto cdMRV;
       cdMRW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdMRV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdMRU::I64;
           I64[Sp - 24] = block_cdMRX_info;
           R2 = lvl25_rdL8R_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdMRX() //  [R1]
         { info_tbl: [(cdMRX,
                       label: block_cdMRX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMRX: // global
           R3 = R1;
           R2 = lvl24_rdL8Q_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.596350835 UTC

[section ""data" . Data.Bifoldable.biminimum_closure" {
     Data.Bifoldable.biminimum_closure:
         const Data.Bifoldable.biminimum_info;
         const 0;
 },
 sat_sdLk4_entry() //  [R1]
         { info_tbl: [(cdMSr,
                       label: sat_sdLk4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMSr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMSs; else goto cdMSt;
       cdMSs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMSt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdLk3_entry() //  [R1]
         { info_tbl: [(cdMSu,
                       label: g_sdLk3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMSu: // global
           _sdLk3::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMSv; else goto cdMSw;
       cdMSw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMSy; else goto cdMSx;
       cdMSy: // global
           HpAlloc = 24;
           goto cdMSv;
       cdMSv: // global
           R1 = _sdLk3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMSx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLk3::P64;
           _sdLk1::P64 = P64[_sdLk3::P64 + 16];
           _sdLk2::P64 = P64[_sdLk3::P64 + 24];
           I64[Hp - 16] = sat_sdLk4_info;
           P64[Hp] = _sdLk2::P64;
           R2 = _sdLk1::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = GHC.Base.Just_closure+1;
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdLk8_entry() //  [R1, R2]
         { info_tbl: [(cdMSK,
                       label: sat_sdLk8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMSK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMSL; else goto cdMSM;
       cdMSL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMSM: // global
           I64[Sp - 8] = block_cdMSE_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMSE() //  [R1]
         { info_tbl: [(cdMSE,
                       label: block_cdMSE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMSE: // global
           if (R1 & 7 == 1) goto cdMSH; else goto cdMSI;
       cdMSH: // global
           R1 = Data.Bifoldable.biminimum1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdMSI: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biminimum_entry() //  [R2, R3]
         { info_tbl: [(cdMST,
                       label: Data.Bifoldable.biminimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMST: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMSX; else goto cdMSW;
       cdMSX: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.biminimum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMSW: // global
           I64[Hp - 40] = g_sdLk3_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdLk8_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.608568156 UTC

[section ""data" . Data.Bifoldable.biproduct2_closure" {
     Data.Bifoldable.biproduct2_closure:
         const Data.Bifoldable.biproduct2_info;
 },
 Data.Bifoldable.biproduct2_entry() //  [R2]
         { info_tbl: [(cdMTq,
                       label: Data.Bifoldable.biproduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMTq: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.612384353 UTC

[section ""data" . Data.Bifoldable.bisum1_closure" {
     Data.Bifoldable.bisum1_closure:
         const Data.Bifoldable.bisum1_info;
         const 0;
 },
 sat_sdLkc_entry() //  [R1]
         { info_tbl: [(cdMTF,
                       label: sat_sdLkc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMTF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMTG; else goto cdMTH;
       cdMTG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMTH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.bisum1_entry() //  [R2, R3]
         { info_tbl: [(cdMTI,
                       label: Data.Bifoldable.bisum1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMTI: // global
           _sdLkb::P64 = R3;
           _sdLka::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMTJ; else goto cdMTK;
       cdMTK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMTM; else goto cdMTL;
       cdMTM: // global
           HpAlloc = 24;
           goto cdMTJ;
       cdMTJ: // global
           R3 = _sdLkb::P64;
           R2 = _sdLka::P64;
           R1 = Data.Bifoldable.bisum1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMTL: // global
           I64[Hp - 16] = sat_sdLkc_info;
           P64[Hp] = _sdLkb::P64;
           R2 = _sdLka::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Data.Bifoldable.biproduct2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biproduct2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.619922079 UTC

[section ""data" . Data.Bifoldable.bisum_closure" {
     Data.Bifoldable.bisum_closure:
         const Data.Bifoldable.bisum_info;
         const 0;
 },
 Data.Bifoldable.bisum_entry() //  [R2, R3]
         { info_tbl: [(cdMU1,
                       label: Data.Bifoldable.bisum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMU1: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bisum1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.624197119 UTC

[section ""data" . Data.Bifoldable.biproduct1_closure" {
     Data.Bifoldable.biproduct1_closure:
         const Data.Bifoldable.biproduct1_info;
         const 0;
 },
 sat_sdLkf_entry() //  [R1]
         { info_tbl: [(cdMUg,
                       label: sat_sdLkf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMUg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMUh; else goto cdMUi;
       cdMUh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMUi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.biproduct1_entry() //  [R2, R3]
         { info_tbl: [(cdMUj,
                       label: Data.Bifoldable.biproduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMUj: // global
           _sdLke::P64 = R3;
           _sdLkd::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMUk; else goto cdMUl;
       cdMUl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdMUn; else goto cdMUm;
       cdMUn: // global
           HpAlloc = 24;
           goto cdMUk;
       cdMUk: // global
           R3 = _sdLke::P64;
           R2 = _sdLkd::P64;
           R1 = Data.Bifoldable.biproduct1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMUm: // global
           I64[Hp - 16] = sat_sdLkf_info;
           P64[Hp] = _sdLke::P64;
           R2 = _sdLkd::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Data.Bifoldable.biproduct2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biproduct2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.630504511 UTC

[section ""data" . Data.Bifoldable.biproduct_closure" {
     Data.Bifoldable.biproduct_closure:
         const Data.Bifoldable.biproduct_info;
         const 0;
 },
 Data.Bifoldable.biproduct_entry() //  [R2, R3]
         { info_tbl: [(cdMUC,
                       label: Data.Bifoldable.biproduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMUC: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biproduct1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.635174564 UTC

[section ""data" . Data.Bifoldable.biconcatMap_closure" {
     Data.Bifoldable.biconcatMap_closure:
         const Data.Bifoldable.biconcatMap_info;
         const 0;
 },
 Data.Bifoldable.biconcatMap_entry() //  [R2]
         { info_tbl: [(cdMUN,
                       label: Data.Bifoldable.biconcatMap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMUN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMUO; else goto cdMUP;
       cdMUO: // global
           R2 = R2;
           R1 = Data.Bifoldable.biconcatMap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMUP: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.$fMonoid[]_closure;
           Sp = Sp - 16;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.64034547 UTC

[section ""data" . Data.Bifoldable.biand2_closure" {
     Data.Bifoldable.biand2_closure:
         const Data.Bifoldable.biand2_info;
 },
 Data.Bifoldable.biand2_entry() //  [R2]
         { info_tbl: [(cdMUZ,
                       label: Data.Bifoldable.biand2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMUZ: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.643792044 UTC

[section ""data" . Data.Bifoldable.biand1_closure" {
     Data.Bifoldable.biand1_closure:
         const Data.Bifoldable.biand1_info;
         const 0;
 },
 Data.Bifoldable.biand1_entry() //  [R2]
         { info_tbl: [(cdMVc,
                       label: Data.Bifoldable.biand1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMVc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMVd; else goto cdMVe;
       cdMVd: // global
           R2 = R2;
           R1 = Data.Bifoldable.biand1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMVe: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAll_closure;
           P64[Sp - 16] = Data.Bifoldable.biand2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biand2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.647927178 UTC

[section ""data" . Data.Bifoldable.biand_closure" {
     Data.Bifoldable.biand_closure:
         const Data.Bifoldable.biand_info;
         const 0;
 },
 Data.Bifoldable.biand_entry() //  [R2]
         { info_tbl: [(cdMVo,
                       label: Data.Bifoldable.biand_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMVo: // global
           R2 = R2;
           call Data.Bifoldable.biand1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.652021032 UTC

[section ""data" . Data.Bifoldable.bior1_closure" {
     Data.Bifoldable.bior1_closure:
         const Data.Bifoldable.bior1_info;
         const 0;
 },
 Data.Bifoldable.bior1_entry() //  [R2]
         { info_tbl: [(cdMVz,
                       label: Data.Bifoldable.bior1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMVz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdMVA; else goto cdMVB;
       cdMVA: // global
           R2 = R2;
           R1 = Data.Bifoldable.bior1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMVB: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Data.Bifoldable.biand2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biand2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.655805482 UTC

[section ""data" . Data.Bifoldable.bior_closure" {
     Data.Bifoldable.bior_closure:
         const Data.Bifoldable.bior_info;
         const 0;
 },
 Data.Bifoldable.bior_entry() //  [R2]
         { info_tbl: [(cdMVL,
                       label: Data.Bifoldable.bior_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMVL: // global
           R2 = R2;
           call Data.Bifoldable.bior1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.659713272 UTC

[section ""data" . Data.Bifoldable.biany1_closure" {
     Data.Bifoldable.biany1_closure:
         const Data.Bifoldable.biany1_info;
         const 0;
 },
 sat_sdLkq_entry() //  [R1, R2]
         { info_tbl: [(cdMW1,
                       label: sat_sdLkq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMW1: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLko_entry() //  [R1, R2]
         { info_tbl: [(cdMW9,
                       label: sat_sdLko_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMW9: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biany1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMWc,
                       label: Data.Bifoldable.biany1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMWc: // global
           _sdLkm::P64 = R4;
           _sdLkl::P64 = R3;
           _sdLkk::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMWd; else goto cdMWe;
       cdMWe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMWg; else goto cdMWf;
       cdMWg: // global
           HpAlloc = 32;
           goto cdMWd;
       cdMWd: // global
           R4 = _sdLkm::P64;
           R3 = _sdLkl::P64;
           R2 = _sdLkk::P64;
           R1 = Data.Bifoldable.biany1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMWf: // global
           I64[Hp - 24] = sat_sdLkq_info;
           P64[Hp - 16] = _sdLkm::P64;
           I64[Hp - 8] = sat_sdLko_info;
           P64[Hp] = _sdLkl::P64;
           R2 = _sdLkk::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.666959642 UTC

[section ""data" . Data.Bifoldable.biany_closure" {
     Data.Bifoldable.biany_closure:
         const Data.Bifoldable.biany_info;
         const 0;
 },
 Data.Bifoldable.biany_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMWy,
                       label: Data.Bifoldable.biany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMWy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biany1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.671247124 UTC

[section ""data" . Data.Bifoldable.bielem1_closure" {
     Data.Bifoldable.bielem1_closure:
         const Data.Bifoldable.bielem1_info;
         const 0;
 },
 sat_sdLkx_entry() //  [R1, R2]
         { info_tbl: [(cdMWO,
                       label: sat_sdLkx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMWO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMWP; else goto cdMWQ;
       cdMWP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMWQ: // global
           _sdLkw::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sdLkw::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdLkv_entry() //  [R1, R2]
         { info_tbl: [(cdMWW,
                       label: sat_sdLkv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMWW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdMWX; else goto cdMWY;
       cdMWX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMWY: // global
           _sdLku::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sdLku::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bielem1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMWZ,
                       label: Data.Bifoldable.bielem1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMWZ: // global
           _sdLkt::P64 = R4;
           _sdLks::P64 = R3;
           _sdLkr::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMX0; else goto cdMX1;
       cdMX1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdMX3; else goto cdMX2;
       cdMX3: // global
           HpAlloc = 48;
           goto cdMX0;
       cdMX0: // global
           R4 = _sdLkt::P64;
           R3 = _sdLks::P64;
           R2 = _sdLkr::P64;
           R1 = Data.Bifoldable.bielem1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMX2: // global
           I64[Hp - 40] = sat_sdLkx_info;
           P64[Hp - 32] = _sdLks::P64;
           P64[Hp - 24] = _sdLkt::P64;
           I64[Hp - 16] = sat_sdLkv_info;
           P64[Hp - 8] = _sdLks::P64;
           P64[Hp] = _sdLkt::P64;
           R2 = _sdLkr::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Hp - 15;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.679918787 UTC

[section ""data" . Data.Bifoldable.bielem_closure" {
     Data.Bifoldable.bielem_closure:
         const Data.Bifoldable.bielem_info;
         const 0;
 },
 Data.Bifoldable.bielem_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMXp,
                       label: Data.Bifoldable.bielem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMXp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bielem1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.684028783 UTC

[section ""data" . Data.Bifoldable.binotElem_closure" {
     Data.Bifoldable.binotElem_closure:
         const Data.Bifoldable.binotElem_info;
         const 0;
 },
 g_sdLkB_entry() //  [R1]
         { info_tbl: [(cdMXE,
                       label: g_sdLkB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMXE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMXF; else goto cdMXG;
       cdMXF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMXG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bifoldable.bielem1_entry(R4,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdLkE_entry() //  [R1, R2]
         { info_tbl: [(cdMXS,
                       label: sat_sdLkE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMXS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdMXT; else goto cdMXU;
       cdMXT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMXU: // global
           I64[Sp - 8] = block_cdMXM_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMXM() //  [R1]
         { info_tbl: [(cdMXM,
                       label: block_cdMXM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMXM: // global
           if (R1 & 7 == 1) goto cdMXP; else goto cdMXQ;
       cdMXP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdMXQ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.binotElem_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMY1,
                       label: Data.Bifoldable.binotElem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMY1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdMY5; else goto cdMY4;
       cdMY5: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.binotElem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMY4: // global
           I64[Hp - 48] = g_sdLkB_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdLkE_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.695125137 UTC

[section ""data" . Data.Bifoldable.biall1_closure" {
     Data.Bifoldable.biall1_closure:
         const Data.Bifoldable.biall1_info;
         const 0;
 },
 sat_sdLkL_entry() //  [R1, R2]
         { info_tbl: [(cdMYA,
                       label: sat_sdLkL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMYA: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdLkJ_entry() //  [R1, R2]
         { info_tbl: [(cdMYI,
                       label: sat_sdLkJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMYI: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biall1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMYL,
                       label: Data.Bifoldable.biall1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMYL: // global
           _sdLkH::P64 = R4;
           _sdLkG::P64 = R3;
           _sdLkF::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdMYM; else goto cdMYN;
       cdMYN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdMYP; else goto cdMYO;
       cdMYP: // global
           HpAlloc = 32;
           goto cdMYM;
       cdMYM: // global
           R4 = _sdLkH::P64;
           R3 = _sdLkG::P64;
           R2 = _sdLkF::P64;
           R1 = Data.Bifoldable.biall1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMYO: // global
           I64[Hp - 24] = sat_sdLkL_info;
           P64[Hp - 16] = _sdLkH::P64;
           I64[Hp - 8] = sat_sdLkJ_info;
           P64[Hp] = _sdLkG::P64;
           R2 = _sdLkF::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAll_closure;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.702725264 UTC

[section ""data" . Data.Bifoldable.biall_closure" {
     Data.Bifoldable.biall_closure:
         const Data.Bifoldable.biall_info;
         const 0;
 },
 Data.Bifoldable.biall_entry() //  [R2, R3, R4]
         { info_tbl: [(cdMZ7,
                       label: Data.Bifoldable.biall_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMZ7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biall1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.706915304 UTC

[section ""data" . Data.Bifoldable.bifind_closure" {
     Data.Bifoldable.bifind_closure:
         const Data.Bifoldable.bifind_info;
         const 0;
 },
 finder_sdLkP_entry() //  [R1, R2]
         { info_tbl: [(cdMZx,
                       label: finder_sdLkP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMZx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdMZy; else goto cdMZz;
       cdMZy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdMZz: // global
           I64[Sp - 16] = block_cdMZr_info;
           _sdLkQ::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdLkQ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMZr() //  [R1]
         { info_tbl: [(cdMZr,
                       label: block_cdMZr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMZr: // global
           if (R1 & 7 == 1) goto cdMZu; else goto cdMZv;
       cdMZu: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdMZv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdMZI; else goto cdMZH;
       cdMZI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdMZH: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdLkO_entry() //  [R1]
         { info_tbl: [(cdMZJ,
                       label: g_sdLkO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMZJ: // global
           _sdLkO::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdMZK; else goto cdMZL;
       cdMZL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdMZN; else goto cdMZM;
       cdMZN: // global
           HpAlloc = 16;
           goto cdMZK;
       cdMZK: // global
           R1 = _sdLkO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdMZM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdLkO::P64;
           _sdLkM::P64 = P64[_sdLkO::P64 + 16];
           _sdLkN::P64 = P64[_sdLkO::P64 + 24];
           I64[Hp - 8] = finder_sdLkP_info;
           P64[Hp] = _sdLkN::P64;
           R2 = _sdLkM::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Monoid.$fMonoidFirst_closure;
           _cdMZm::P64 = Hp - 7;
           P64[Sp - 32] = _cdMZm::P64;
           P64[Sp - 24] = _cdMZm::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdLkT_entry() //  [R1, R2]
         { info_tbl: [(cdMZT,
                       label: sat_sdLkT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMZT: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifind_entry() //  [R2, R3]
         { info_tbl: [(cdMZW,
                       label: Data.Bifoldable.bifind_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMZW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdN00; else goto cdMZZ;
       cdN00: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bifind_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMZZ: // global
           I64[Hp - 40] = g_sdLkO_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdLkT_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.718897663 UTC

[section ""data" . Data.Bifoldable.$trModule3_closure" {
     Data.Bifoldable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.720653671 UTC

[section ""data" . Data.Bifoldable.$trModule1_closure" {
     Data.Bifoldable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.722505209 UTC

[section ""data" . Data.Bifoldable.$trModule_closure" {
     Data.Bifoldable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bifoldable.$trModule3_closure+1;
         const Data.Bifoldable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.724494076 UTC

[section ""data" . $krep_rdL8S_closure" {
     $krep_rdL8S_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.727341582 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable1_closure" {
     Data.Bifoldable.$tcBifoldable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdL8S_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.728970885 UTC

[section ""cstring" . Data.Bifoldable.$tcBifoldable3_bytes" {
     Data.Bifoldable.$tcBifoldable3_bytes:
         I8[] [66,105,102,111,108,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.73069315 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable2_closure" {
     Data.Bifoldable.$tcBifoldable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$tcBifoldable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.73240872 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable_closure" {
     Data.Bifoldable.$tcBifoldable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bifoldable.$trModule_closure+1;
         const Data.Bifoldable.$tcBifoldable2_closure+1;
         const Data.Bifoldable.$tcBifoldable1_closure+4;
         const 13881323671910883383;
         const 7079945659398195047;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.734593132 UTC

[section ""data" . Data.Bifoldable.C:Bifoldable_closure" {
     Data.Bifoldable.C:Bifoldable_closure:
         const Data.Bifoldable.C:Bifoldable_info;
 },
 Data.Bifoldable.C:Bifoldable_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdN0D,
                       label: Data.Bifoldable.C:Bifoldable_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdN0D: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdN0H; else goto cdN0G;
       cdN0H: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.C:Bifoldable_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdN0G: // global
           I64[Hp - 32] = Data.Bifoldable.C:Bifoldable_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.738901511 UTC

[Data.Bifoldable.C:Bifoldable_con_entry() //  [R1]
         { info_tbl: [(cdN0N,
                       label: Data.Bifoldable.C:Bifoldable_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,102,111,108,100,97,98,108,101,46,67,58,66,105,102,111,108,100,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdN0N: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:59.742116006 UTC

[section ""relreadonly" . SdLpk_srt" {
     SdLpk_srt:
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Bifoldable.$dmbifoldl_closure;
         const poly_$dMonoid_rdL8r_closure;
         const Data.Bifoldable.$dmbifoldr_closure;
         const GHC.Err.error_closure;
         const lvl10_rdL8C_closure;
         const Data.Bifoldable.bifoldr1_closure;
         const Data.Bifoldable.bifoldr2_closure;
         const Data.Bifoldable.bimaximumBy_closure;
         const Data.Bifoldable.biminimumBy_closure;
         const lvl14_rdL8G_closure;
         const Data.Bifoldable.bifoldl1_closure;
         const Data.Bifoldable.bifoldl2_closure;
         const GHC.Base.$fMonoid[]_closure;
         const Data.Bifoldable.biconcat_closure;
         const lvl20_rdL8M_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Bifoldable.bimaximum1_closure;
         const Data.Bifoldable.bimaximum_closure;
         const lvl24_rdL8Q_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Bifoldable.biminimum1_closure;
         const Data.Bifoldable.biminimum_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Bifoldable.bisum1_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Bifoldable.biproduct1_closure;
         const Data.Bifoldable.biconcatMap_closure;
         const Data.Semigroup.Internal.$fMonoidAll_closure;
         const Data.Bifoldable.biand1_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Bifoldable.bior1_closure;
         const Data.Bifoldable.biany1_closure;
         const Data.Bifoldable.bielem1_closure;
         const Data.Bifoldable.binotElem_closure;
         const Data.Bifoldable.biall1_closure;
         const Data.Monoid.$fMonoidFirst_closure;
         const Data.Bifoldable.bifind_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.26136089 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:02.262888171 UTC

[section ""data" . Data.Bifoldable.bifold_closure" {
     Data.Bifoldable.bifold_closure:
         const Data.Bifoldable.bifold_info;
 },
 Data.Bifoldable.bifold_entry() //  [R2]
         { info_tbl: [(cdNd1,
                       label: Data.Bifoldable.bifold_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNd1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdNd2; else goto cdNd3;
       cdNd2: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifold_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNd3: // global
           I64[Sp - 8] = block_cdNcY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udNd7; else goto cdNcZ;
       udNd7: // global
           call _cdNcY(R1) args: 0, res: 0, upd: 0;
       cdNcZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNcY() //  [R1]
         { info_tbl: [(cdNcY,
                       label: block_cdNcY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNcY: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.269475419 UTC

[section ""data" . Data.Bifoldable.bifoldMap_closure" {
     Data.Bifoldable.bifoldMap_closure:
         const Data.Bifoldable.bifoldMap_info;
 },
 Data.Bifoldable.bifoldMap_entry() //  [R2]
         { info_tbl: [(cdNdp,
                       label: Data.Bifoldable.bifoldMap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNdp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdNdq; else goto cdNdr;
       cdNdq: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldMap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNdr: // global
           I64[Sp - 8] = block_cdNdm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udNdv; else goto cdNdn;
       udNdv: // global
           call _cdNdm(R1) args: 0, res: 0, upd: 0;
       cdNdn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNdm() //  [R1]
         { info_tbl: [(cdNdm,
                       label: block_cdNdm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNdm: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.275818313 UTC

[section ""data" . Data.Bifoldable.bifoldr_closure" {
     Data.Bifoldable.bifoldr_closure:
         const Data.Bifoldable.bifoldr_info;
 },
 Data.Bifoldable.bifoldr_entry() //  [R2]
         { info_tbl: [(cdNdN,
                       label: Data.Bifoldable.bifoldr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNdN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdNdO; else goto cdNdP;
       cdNdO: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNdP: // global
           I64[Sp - 8] = block_cdNdK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udNdT; else goto cdNdL;
       udNdT: // global
           call _cdNdK(R1) args: 0, res: 0, upd: 0;
       cdNdL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNdK() //  [R1]
         { info_tbl: [(cdNdK,
                       label: block_cdNdK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNdK: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.283567507 UTC

[section ""data" . Data.Bifoldable.bifoldl_closure" {
     Data.Bifoldable.bifoldl_closure:
         const Data.Bifoldable.bifoldl_info;
 },
 Data.Bifoldable.bifoldl_entry() //  [R2]
         { info_tbl: [(cdNeb,
                       label: Data.Bifoldable.bifoldl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNeb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdNec; else goto cdNed;
       cdNec: // global
           R2 = R2;
           R1 = Data.Bifoldable.bifoldl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNed: // global
           I64[Sp - 8] = block_cdNe8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udNeh; else goto cdNe9;
       udNeh: // global
           call _cdNe8(R1) args: 0, res: 0, upd: 0;
       cdNe9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNe8() //  [R1]
         { info_tbl: [(cdNe8,
                       label: block_cdNe8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNe8: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.292868668 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_info;
 },
 sat_sdN1v_entry() //  [R1]
         { info_tbl: [(cdNeB,
                       label: sat_sdN1v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNeB: // global
           _sdN1v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNeC; else goto cdNeD;
       cdNeD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNeF; else goto cdNeE;
       cdNeF: // global
           HpAlloc = 24;
           goto cdNeC;
       cdNeC: // global
           R1 = _sdN1v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNeE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN1v::P64;
           _sdN1k::P64 = P64[_sdN1v::P64 + 16];
           _sdN1l::P64 = P64[_sdN1v::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdN1l::P64;
           R2 = Hp - 16;
           R1 = _sdN1k::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdN1q_entry() //  [R1]
         { info_tbl: [(cdNeL,
                       label: sat_sdN1q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNeL: // global
           _sdN1q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNeM; else goto cdNeN;
       cdNeN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNeP; else goto cdNeO;
       cdNeP: // global
           HpAlloc = 24;
           goto cdNeM;
       cdNeM: // global
           R1 = _sdN1q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNeO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN1q::P64;
           _sdN1j::P64 = P64[_sdN1q::P64 + 16];
           _sdN1l::P64 = P64[_sdN1q::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdN1l::P64;
           R2 = Hp - 16;
           R1 = _sdN1j::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdNeQ,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNeQ: // global
           _sdN1l::P64 = R5;
           _sdN1k::P64 = R4;
           _sdN1j::P64 = R3;
           _sdN1i::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNeR; else goto cdNeS;
       cdNeS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNeU; else goto cdNeT;
       cdNeU: // global
           HpAlloc = 64;
           goto cdNeR;
       cdNeR: // global
           R5 = _sdN1l::P64;
           R4 = _sdN1k::P64;
           R3 = _sdN1j::P64;
           R2 = _sdN1i::P64;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNeT: // global
           I64[Hp - 56] = sat_sdN1v_info;
           P64[Hp - 40] = _sdN1k::P64;
           P64[Hp - 32] = _sdN1l::P64;
           I64[Hp - 24] = sat_sdN1q_info;
           P64[Hp - 8] = _sdN1j::P64;
           P64[Hp] = _sdN1l::P64;
           R2 = _sdN1i::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.302774404 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldMap_entry() //  [R3, R5]
         { info_tbl: [(cdNfl,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNfl: // global
           R2 = R5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.306256843 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldMap_entry() //  [R3, R5]
         { info_tbl: [(cdNfw,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNfw: // global
           R2 = R5;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.310068962 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_info;
 },
 sat_sdN1T_entry() //  [R1]
         { info_tbl: [(cdNfM,
                       label: sat_sdN1T_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNfM: // global
           _sdN1T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNfN; else goto cdNfO;
       cdNfO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNfQ; else goto cdNfP;
       cdNfQ: // global
           HpAlloc = 24;
           goto cdNfN;
       cdNfN: // global
           R1 = _sdN1T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNfP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN1T::P64;
           _sdN1G::P64 = P64[_sdN1T::P64 + 16];
           _sdN1H::P64 = P64[_sdN1T::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdN1H::P64;
           R2 = Hp - 16;
           R1 = _sdN1G::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdN1N_entry() //  [R1]
         { info_tbl: [(cdNfW,
                       label: sat_sdN1N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNfW: // global
           _sdN1N::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNfX; else goto cdNfY;
       cdNfY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNg0; else goto cdNfZ;
       cdNg0: // global
           HpAlloc = 24;
           goto cdNfX;
       cdNfX: // global
           R1 = _sdN1N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNfZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN1N::P64;
           _sdN1F::P64 = P64[_sdN1N::P64 + 16];
           _sdN1H::P64 = P64[_sdN1N::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdN1H::P64;
           R2 = Hp - 16;
           R1 = _sdN1F::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdNg1,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNg1: // global
           _sdN1H::P64 = R5;
           _sdN1G::P64 = R4;
           _sdN1F::P64 = R3;
           _sdN1E::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNg2; else goto cdNg3;
       cdNg3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNg5; else goto cdNg4;
       cdNg5: // global
           HpAlloc = 64;
           goto cdNg2;
       cdNg2: // global
           R5 = _sdN1H::P64;
           R4 = _sdN1G::P64;
           R3 = _sdN1F::P64;
           R2 = _sdN1E::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNg4: // global
           I64[Hp - 56] = sat_sdN1T_info;
           P64[Hp - 40] = _sdN1G::P64;
           P64[Hp - 32] = _sdN1H::P64;
           I64[Hp - 24] = sat_sdN1N_info;
           P64[Hp - 8] = _sdN1F::P64;
           P64[Hp] = _sdN1H::P64;
           R2 = _sdN1E::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.320145278 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_info;
 },
 sat_sdN2b_entry() //  [R1]
         { info_tbl: [(cdNgB,
                       label: sat_sdN2b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNgB: // global
           _sdN2b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNgC; else goto cdNgD;
       cdNgD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNgF; else goto cdNgE;
       cdNgF: // global
           HpAlloc = 24;
           goto cdNgC;
       cdNgC: // global
           R1 = _sdN2b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNgE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN2b::P64;
           _sdN1W::P64 = P64[_sdN2b::P64 + 16];
           _sdN1X::P64 = P64[_sdN2b::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdN1X::P64;
           R2 = Hp - 16;
           R1 = _sdN1W::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdN24_entry() //  [R1]
         { info_tbl: [(cdNgL,
                       label: sat_sdN24_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNgL: // global
           _sdN24::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNgM; else goto cdNgN;
       cdNgN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNgP; else goto cdNgO;
       cdNgP: // global
           HpAlloc = 24;
           goto cdNgM;
       cdNgM: // global
           R1 = _sdN24::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNgO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN24::P64;
           _sdN1V::P64 = P64[_sdN24::P64 + 16];
           _sdN1X::P64 = P64[_sdN24::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdN1X::P64;
           R2 = Hp - 16;
           R1 = _sdN1V::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdNgQ,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNgQ: // global
           _sdN1X::P64 = R5;
           _sdN1W::P64 = R4;
           _sdN1V::P64 = R3;
           _sdN1U::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNgR; else goto cdNgS;
       cdNgS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNgU; else goto cdNgT;
       cdNgU: // global
           HpAlloc = 64;
           goto cdNgR;
       cdNgR: // global
           R5 = _sdN1X::P64;
           R4 = _sdN1W::P64;
           R3 = _sdN1V::P64;
           R2 = _sdN1U::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNgT: // global
           I64[Hp - 56] = sat_sdN2b_info;
           P64[Hp - 40] = _sdN1W::P64;
           P64[Hp - 32] = _sdN1X::P64;
           I64[Hp - 24] = sat_sdN24_info;
           P64[Hp - 8] = _sdN1V::P64;
           P64[Hp] = _sdN1X::P64;
           R2 = _sdN1U::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.33134251 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_info;
 },
 sat_sdN2v_entry() //  [R1]
         { info_tbl: [(cdNhq,
                       label: sat_sdN2v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNhq: // global
           _sdN2v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNhr; else goto cdNhs;
       cdNhs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNhu; else goto cdNht;
       cdNhu: // global
           HpAlloc = 24;
           goto cdNhr;
       cdNhr: // global
           R1 = _sdN2v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNht: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN2v::P64;
           _sdN2e::P64 = P64[_sdN2v::P64 + 16];
           _sdN2f::P64 = P64[_sdN2v::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdN2f::P64;
           R2 = Hp - 16;
           R1 = _sdN2e::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdN2n_entry() //  [R1]
         { info_tbl: [(cdNhA,
                       label: sat_sdN2n_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNhA: // global
           _sdN2n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNhB; else goto cdNhC;
       cdNhC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNhE; else goto cdNhD;
       cdNhE: // global
           HpAlloc = 24;
           goto cdNhB;
       cdNhB: // global
           R1 = _sdN2n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNhD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN2n::P64;
           _sdN2d::P64 = P64[_sdN2n::P64 + 16];
           _sdN2f::P64 = P64[_sdN2n::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdN2f::P64;
           R2 = Hp - 16;
           R1 = _sdN2d::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdNhF,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNhF: // global
           _sdN2f::P64 = R5;
           _sdN2e::P64 = R4;
           _sdN2d::P64 = R3;
           _sdN2c::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNhG; else goto cdNhH;
       cdNhH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNhJ; else goto cdNhI;
       cdNhJ: // global
           HpAlloc = 64;
           goto cdNhG;
       cdNhG: // global
           R5 = _sdN2f::P64;
           R4 = _sdN2e::P64;
           R3 = _sdN2d::P64;
           R2 = _sdN2c::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNhI: // global
           I64[Hp - 56] = sat_sdN2v_info;
           P64[Hp - 40] = _sdN2e::P64;
           P64[Hp - 32] = _sdN2f::P64;
           I64[Hp - 24] = sat_sdN2n_info;
           P64[Hp - 8] = _sdN2d::P64;
           P64[Hp] = _sdN2f::P64;
           R2 = _sdN2c::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.347470034 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_info;
 },
 sat_sdN2R_entry() //  [R1]
         { info_tbl: [(cdNif,
                       label: sat_sdN2R_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNif: // global
           _sdN2R::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNig; else goto cdNih;
       cdNih: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNij; else goto cdNii;
       cdNij: // global
           HpAlloc = 24;
           goto cdNig;
       cdNig: // global
           R1 = _sdN2R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNii: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN2R::P64;
           _sdN2y::P64 = P64[_sdN2R::P64 + 16];
           _sdN2z::P64 = P64[_sdN2R::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdN2z::P64;
           R2 = Hp - 16;
           R1 = _sdN2y::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdN2I_entry() //  [R1]
         { info_tbl: [(cdNip,
                       label: sat_sdN2I_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNip: // global
           _sdN2I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNiq; else goto cdNir;
       cdNir: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNit; else goto cdNis;
       cdNit: // global
           HpAlloc = 24;
           goto cdNiq;
       cdNiq: // global
           R1 = _sdN2I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNis: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN2I::P64;
           _sdN2x::P64 = P64[_sdN2I::P64 + 16];
           _sdN2z::P64 = P64[_sdN2I::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdN2z::P64;
           R2 = Hp - 16;
           R1 = _sdN2x::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_entry() //  [R2,
                                                              R3, R4, R5]
         { info_tbl: [(cdNiu,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNiu: // global
           _sdN2z::P64 = R5;
           _sdN2y::P64 = R4;
           _sdN2x::P64 = R3;
           _sdN2w::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNiv; else goto cdNiw;
       cdNiw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNiy; else goto cdNix;
       cdNiy: // global
           HpAlloc = 64;
           goto cdNiv;
       cdNiv: // global
           R5 = _sdN2z::P64;
           R4 = _sdN2y::P64;
           R3 = _sdN2x::P64;
           R2 = _sdN2w::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNix: // global
           I64[Hp - 56] = sat_sdN2R_info;
           P64[Hp - 40] = _sdN2y::P64;
           P64[Hp - 32] = _sdN2z::P64;
           I64[Hp - 24] = sat_sdN2I_info;
           P64[Hp - 8] = _sdN2x::P64;
           P64[Hp] = _sdN2z::P64;
           R2 = _sdN2w::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.363282949 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_info;
 },
 sat_sdN3f_entry() //  [R1]
         { info_tbl: [(cdNj4,
                       label: sat_sdN3f_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNj4: // global
           _sdN3f::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNj5; else goto cdNj6;
       cdNj6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNj8; else goto cdNj7;
       cdNj8: // global
           HpAlloc = 24;
           goto cdNj5;
       cdNj5: // global
           R1 = _sdN3f::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNj7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN3f::P64;
           _sdN2U::P64 = P64[_sdN3f::P64 + 16];
           _sdN2V::P64 = P64[_sdN3f::P64 + 24];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdN2V::P64;
           R2 = Hp - 16;
           R1 = _sdN2U::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdN35_entry() //  [R1]
         { info_tbl: [(cdNje,
                       label: sat_sdN35_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNje: // global
           _sdN35::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNjf; else goto cdNjg;
       cdNjg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNji; else goto cdNjh;
       cdNji: // global
           HpAlloc = 24;
           goto cdNjf;
       cdNjf: // global
           R1 = _sdN35::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNjh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN35::P64;
           _sdN2T::P64 = P64[_sdN35::P64 + 16];
           _sdN2V::P64 = P64[_sdN35::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdN2V::P64;
           R2 = Hp - 16;
           R1 = _sdN2T::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_entry() //  [R2,
                                                               R3, R4, R5]
         { info_tbl: [(cdNjj,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNjj: // global
           _sdN2V::P64 = R5;
           _sdN2U::P64 = R4;
           _sdN2T::P64 = R3;
           _sdN2S::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNjk; else goto cdNjl;
       cdNjl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNjn; else goto cdNjm;
       cdNjn: // global
           HpAlloc = 64;
           goto cdNjk;
       cdNjk: // global
           R5 = _sdN2V::P64;
           R4 = _sdN2U::P64;
           R3 = _sdN2T::P64;
           R2 = _sdN2S::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNjm: // global
           I64[Hp - 56] = sat_sdN3f_info;
           P64[Hp - 40] = _sdN2U::P64;
           P64[Hp - 32] = _sdN2V::P64;
           I64[Hp - 24] = sat_sdN35_info;
           P64[Hp - 8] = _sdN2T::P64;
           P64[Hp] = _sdN2V::P64;
           R2 = _sdN2S::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.378511532 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldMap_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldMap_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdNjV,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNjV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdNjW; else goto cdNjX;
       cdNjW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNjX: // global
           I64[Sp - 24] = block_cdNjO_info;
           R1 = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udNk4; else goto cdNjP;
       udNk4: // global
           call _cdNjO(R1) args: 0, res: 0, upd: 0;
       cdNjP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNjO() //  [R1]
         { info_tbl: [(cdNjO,
                       label: block_cdNjO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNjO: // global
           if (R1 & 7 == 1) goto cdNjS; else goto cdNjT;
       cdNjS: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdNjT: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.385287005 UTC

[section ""data" . poly_$dMonoid_rdL8r_closure" {
     poly_$dMonoid_rdL8r_closure:
         const poly_$dMonoid_rdL8r_info;
         const 0;
         const 0;
         const 0;
 },
 poly_$dMonoid_rdL8r_entry() //  [R1]
         { info_tbl: [(cdNkn,
                       label: poly_$dMonoid_rdL8r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNkn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNko; else goto cdNkp;
       cdNko: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNkp: // global
           (_cdNkk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdNkk::I64 == 0) goto cdNkm; else goto cdNkl;
       cdNkm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdNkl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdNkk::I64;
           R2 = Data.Semigroup.Internal.$fMonoidEndo_closure;
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.389786684 UTC

[section ""data" . Data.Bifoldable.$dmbifoldl_closure" {
     Data.Bifoldable.$dmbifoldl_closure:
         const Data.Bifoldable.$dmbifoldl_info;
         const 0;
 },
 sat_sdN3x_entry() //  [R1, R2, R3]
         { info_tbl: [(cdNkI,
                       label: sat_sdN3x_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNkI: // global
           _sdN3w::P64 = R3;
           R3 = R2;
           R2 = _sdN3w::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdN3u_entry() //  [R1, R2, R3]
         { info_tbl: [(cdNkQ,
                       label: sat_sdN3u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNkQ: // global
           _sdN3t::P64 = R3;
           R3 = R2;
           R2 = _sdN3t::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.$dmbifoldl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdNkT,
                       label: Data.Bifoldable.$dmbifoldl_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNkT: // global
           _sdN3r::P64 = R6;
           _sdN3q::P64 = R5;
           _sdN3p::P64 = R4;
           _sdN3o::P64 = R3;
           _sdN3n::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdNkU; else goto cdNkV;
       cdNkV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdNkX; else goto cdNkW;
       cdNkX: // global
           HpAlloc = 32;
           goto cdNkU;
       cdNkU: // global
           R6 = _sdN3r::P64;
           R5 = _sdN3q::P64;
           R4 = _sdN3p::P64;
           R3 = _sdN3o::P64;
           R2 = _sdN3n::P64;
           R1 = Data.Bifoldable.$dmbifoldl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNkW: // global
           I64[Hp - 24] = sat_sdN3x_info;
           P64[Hp - 16] = _sdN3p::P64;
           I64[Hp - 8] = sat_sdN3u_info;
           P64[Hp] = _sdN3o::P64;
           R2 = _sdN3n::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = poly_$dMonoid_rdL8r_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdN3r::P64;
           P64[Sp - 8] = _sdN3q::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.398251791 UTC

[section ""data" . Data.Bifoldable.$dmbifoldr_closure" {
     Data.Bifoldable.$dmbifoldr_closure:
         const Data.Bifoldable.$dmbifoldr_info;
         const 0;
 },
 Data.Bifoldable.$dmbifoldr_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdNlj,
                       label: Data.Bifoldable.$dmbifoldr_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNlj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdNlk; else goto cdNll;
       cdNlk: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$dmbifoldr_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNll: // global
           R2 = R2;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fMonoidEndo_closure;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R6;
           P64[Sp - 8] = R5;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.403609662 UTC

[section ""data" . Data.Bifoldable.$dmbifoldMap_closure" {
     Data.Bifoldable.$dmbifoldMap_closure:
         const Data.Bifoldable.$dmbifoldMap_info;
 },
 sat_sdN3N_entry() //  [R1]
         { info_tbl: [(cdNlB,
                       label: sat_sdN3N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNlB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNlC; else goto cdNlD;
       cdNlC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNlD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdN3M_entry() //  [R1, R2]
         { info_tbl: [(cdNlK,
                       label: sat_sdN3M_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNlK: // global
           _sdN3K::P64 = R2;
           _sdN3M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNlL; else goto cdNlM;
       cdNlM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdNlO; else goto cdNlN;
       cdNlO: // global
           HpAlloc = 32;
           goto cdNlL;
       cdNlL: // global
           R2 = _sdN3K::P64;
           R1 = _sdN3M::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNlN: // global
           _sdN3E::P64 = P64[_sdN3M::P64 + 7];
           _sdN3G::P64 = P64[_sdN3M::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdN3G::P64;
           P64[Hp] = _sdN3K::P64;
           R2 = _sdN3E::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdN3J_entry() //  [R1, R2]
         { info_tbl: [(cdNlV,
                       label: sat_sdN3J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNlV: // global
           _sdN3H::P64 = R2;
           _sdN3J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNlW; else goto cdNlX;
       cdNlX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdNlZ; else goto cdNlY;
       cdNlZ: // global
           HpAlloc = 32;
           goto cdNlW;
       cdNlW: // global
           R2 = _sdN3H::P64;
           R1 = _sdN3J::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNlY: // global
           _sdN3E::P64 = P64[_sdN3J::P64 + 7];
           _sdN3F::P64 = P64[_sdN3J::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdN3F::P64;
           P64[Hp] = _sdN3H::P64;
           R2 = _sdN3E::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.mappend_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.$dmbifoldMap_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdNm0,
                       label: Data.Bifoldable.$dmbifoldMap_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNm0: // global
           _sdN3G::P64 = R5;
           _sdN3F::P64 = R4;
           _sdN3E::P64 = R3;
           _sdN3D::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdNm1; else goto cdNm2;
       cdNm2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdNm4; else goto cdNm3;
       cdNm4: // global
           HpAlloc = 72;
           goto cdNm1;
       cdNm1: // global
           R5 = _sdN3G::P64;
           R4 = _sdN3F::P64;
           R3 = _sdN3E::P64;
           R2 = _sdN3D::P64;
           R1 = Data.Bifoldable.$dmbifoldMap_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNm3: // global
           I64[Hp - 64] = sat_sdN3N_info;
           P64[Hp - 48] = _sdN3E::P64;
           I64[Hp - 40] = sat_sdN3M_info;
           P64[Hp - 32] = _sdN3E::P64;
           P64[Hp - 24] = _sdN3G::P64;
           I64[Hp - 16] = sat_sdN3J_info;
           P64[Hp - 8] = _sdN3E::P64;
           P64[Hp] = _sdN3F::P64;
           R2 = _sdN3D::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 15;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.419538624 UTC

[section ""data" . Data.Bifoldable.$dmbifold_closure" {
     Data.Bifoldable.$dmbifold_closure:
         const Data.Bifoldable.$dmbifold_info;
 },
 Data.Bifoldable.$dmbifold_entry() //  [R2, R3]
         { info_tbl: [(cdNmE,
                       label: Data.Bifoldable.$dmbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNmE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdNmF; else goto cdNmG;
       cdNmF: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$dmbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNmG: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.426593947 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifold_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifold_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdNn2,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNn2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdNn3; else goto cdNn4;
       cdNn3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNn4: // global
           I64[Sp - 8] = block_cdNmV_info;
           R1 = R3;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udNnb; else goto cdNmW;
       udNnb: // global
           call _cdNmV(R1) args: 0, res: 0, upd: 0;
       cdNmW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNmV() //  [R1]
         { info_tbl: [(cdNmV,
                       label: block_cdNmV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNmV: // global
           if (R1 & 7 == 1) goto cdNmZ; else goto cdNn0;
       cdNmZ: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdNn0: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.437038821 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldr_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdNnz,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNnz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdNnA; else goto cdNnB;
       cdNnA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNnB: // global
           I64[Sp - 32] = block_cdNns_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udNnI; else goto cdNnt;
       udNnI: // global
           call _cdNns(R1) args: 0, res: 0, upd: 0;
       cdNnt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNns() //  [R1]
         { info_tbl: [(cdNns,
                       label: block_cdNns_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNns: // global
           _sdN3X::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdNnw; else goto cdNnx;
       cdNnw: // global
           R3 = _sdN3X::P64;
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNnx: // global
           R3 = _sdN3X::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.448455378 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableEither_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableEither_$cbifoldl_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdNo6,
                       label: Data.Bifoldable.$fBifoldableEither_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNo6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdNo7; else goto cdNo8;
       cdNo7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNo8: // global
           I64[Sp - 32] = block_cdNnZ_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udNof; else goto cdNo0;
       udNof: // global
           call _cdNnZ(R1) args: 0, res: 0, upd: 0;
       cdNo0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNnZ() //  [R1]
         { info_tbl: [(cdNnZ,
                       label: block_cdNnZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNnZ: // global
           _sdN44::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdNo3; else goto cdNo4;
       cdNo3: // global
           R3 = P64[R1 + 7];
           R2 = _sdN44::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNo4: // global
           R3 = P64[R1 + 6];
           R2 = _sdN44::P64;
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.459626108 UTC

[section ""data" . Data.Bifoldable.$fBifoldableEither_closure" {
     Data.Bifoldable.$fBifoldableEither_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableEither_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableEither_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.463335861 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdNoz,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNoz: // global
           _sdN4a::P64 = R3;
           _sdN49::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNoA; else goto cdNoB;
       cdNoB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNoD; else goto cdNoC;
       cdNoD: // global
           HpAlloc = 48;
           goto cdNoA;
       cdNoA: // global
           R3 = _sdN4a::P64;
           R2 = _sdN49::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNoC: // global
           I64[Hp - 40] = stg_sel_6_upd_info;
           P64[Hp - 24] = _sdN4a::P64;
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdN4a::P64;
           R2 = _sdN49::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.471133304 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_info;
 },
 sat_sdN4P_entry() //  [R1]
         { info_tbl: [(cdNoX,
                       label: sat_sdN4P_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNoX: // global
           _sdN4P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNoY; else goto cdNoZ;
       cdNoZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNp1; else goto cdNp0;
       cdNp1: // global
           HpAlloc = 24;
           goto cdNoY;
       cdNoY: // global
           R1 = _sdN4P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNp0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN4P::P64;
           _sdN4u::P64 = P64[_sdN4P::P64 + 16];
           _sdN4v::P64 = P64[_sdN4P::P64 + 24];
           _sdN4w::P64 = P64[_sdN4P::P64 + 32];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdN4w::P64;
           R3 = _sdN4v::P64;
           R2 = Hp - 16;
           R1 = _sdN4u::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdNp3,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNp3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNp7; else goto cdNp6;
       cdNp7: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNp6: // global
           I64[Hp - 56] = sat_sdN4P_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdN4t::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdN4t::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.482663759 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_info;
 },
 sat_sdN53_entry() //  [R1]
         { info_tbl: [(cdNpu,
                       label: sat_sdN53_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNpu: // global
           _sdN53::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNpv; else goto cdNpw;
       cdNpw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNpy; else goto cdNpx;
       cdNpy: // global
           HpAlloc = 24;
           goto cdNpv;
       cdNpv: // global
           R1 = _sdN53::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNpx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN53::P64;
           _sdN4Q::P64 = P64[_sdN53::P64 + 16];
           _sdN4S::P64 = P64[_sdN53::P64 + 24];
           _sdN4T::P64 = P64[_sdN53::P64 + 32];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdN4T::P64;
           R3 = Hp - 16;
           R2 = _sdN4S::P64;
           R1 = _sdN4Q::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cdNpz,
                       label: Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNpz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNpD; else goto cdNpC;
       cdNpD: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNpC: // global
           I64[Hp - 56] = stg_sel_6_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdN53_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdN4R::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdN4R::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.490189908 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.49242767 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdNpX,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNpX: // global
           _sdN5e::P64 = R3;
           _sdN5d::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNpY; else goto cdNpZ;
       cdNpZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNq1; else goto cdNq0;
       cdNq1: // global
           HpAlloc = 48;
           goto cdNpY;
       cdNpY: // global
           R3 = _sdN5e::P64;
           R2 = _sdN5d::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNq0: // global
           I64[Hp - 40] = stg_sel_5_upd_info;
           P64[Hp - 24] = _sdN5e::P64;
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdN5e::P64;
           R2 = _sdN5d::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.497905846 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_info;
 },
 sat_sdN5P_entry() //  [R1]
         { info_tbl: [(cdNql,
                       label: sat_sdN5P_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNql: // global
           _sdN5P::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNqm; else goto cdNqn;
       cdNqn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNqp; else goto cdNqo;
       cdNqp: // global
           HpAlloc = 24;
           goto cdNqm;
       cdNqm: // global
           R1 = _sdN5P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNqo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN5P::P64;
           _sdN5w::P64 = P64[_sdN5P::P64 + 16];
           _sdN5x::P64 = P64[_sdN5P::P64 + 24];
           _sdN5y::P64 = P64[_sdN5P::P64 + 32];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdN5y::P64;
           R3 = _sdN5x::P64;
           R2 = Hp - 16;
           R1 = _sdN5w::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdNqr,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNqr: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNqv; else goto cdNqu;
       cdNqv: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNqu: // global
           I64[Hp - 56] = sat_sdN5P_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdN5v::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdN5v::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.505838013 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_info;
 },
 sat_sdN62_entry() //  [R1]
         { info_tbl: [(cdNqS,
                       label: sat_sdN62_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNqS: // global
           _sdN62::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNqT; else goto cdNqU;
       cdNqU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNqW; else goto cdNqV;
       cdNqW: // global
           HpAlloc = 24;
           goto cdNqT;
       cdNqT: // global
           R1 = _sdN62::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNqV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN62::P64;
           _sdN5Q::P64 = P64[_sdN62::P64 + 16];
           _sdN5S::P64 = P64[_sdN62::P64 + 24];
           _sdN5T::P64 = P64[_sdN62::P64 + 32];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdN5T::P64;
           R3 = Hp - 16;
           R2 = _sdN5S::P64;
           R1 = _sdN5Q::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cdNqX,
                       label: Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNqX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNr1; else goto cdNr0;
       cdNr1: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNr0: // global
           I64[Hp - 56] = stg_sel_5_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdN62_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdN5R::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdN5R::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.512971889 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.515645157 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdNrl,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNrl: // global
           _sdN6c::P64 = R3;
           _sdN6b::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNrm; else goto cdNrn;
       cdNrn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNrp; else goto cdNro;
       cdNrp: // global
           HpAlloc = 48;
           goto cdNrm;
       cdNrm: // global
           R3 = _sdN6c::P64;
           R2 = _sdN6b::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNro: // global
           I64[Hp - 40] = stg_sel_4_upd_info;
           P64[Hp - 24] = _sdN6c::P64;
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdN6c::P64;
           R2 = _sdN6b::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.521285161 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_info;
 },
 sat_sdN6J_entry() //  [R1]
         { info_tbl: [(cdNrJ,
                       label: sat_sdN6J_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNrJ: // global
           _sdN6J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNrK; else goto cdNrL;
       cdNrL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNrN; else goto cdNrM;
       cdNrN: // global
           HpAlloc = 24;
           goto cdNrK;
       cdNrK: // global
           R1 = _sdN6J::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNrM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN6J::P64;
           _sdN6s::P64 = P64[_sdN6J::P64 + 16];
           _sdN6t::P64 = P64[_sdN6J::P64 + 24];
           _sdN6u::P64 = P64[_sdN6J::P64 + 32];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdN6u::P64;
           R3 = _sdN6t::P64;
           R2 = Hp - 16;
           R1 = _sdN6s::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdNrP,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNrP: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNrT; else goto cdNrS;
       cdNrT: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNrS: // global
           I64[Hp - 56] = sat_sdN6J_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdN6r::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdN6r::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.52986938 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_info;
 },
 sat_sdN6V_entry() //  [R1]
         { info_tbl: [(cdNsg,
                       label: sat_sdN6V_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNsg: // global
           _sdN6V::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNsh; else goto cdNsi;
       cdNsi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNsk; else goto cdNsj;
       cdNsk: // global
           HpAlloc = 24;
           goto cdNsh;
       cdNsh: // global
           R1 = _sdN6V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNsj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN6V::P64;
           _sdN6K::P64 = P64[_sdN6V::P64 + 16];
           _sdN6M::P64 = P64[_sdN6V::P64 + 24];
           _sdN6N::P64 = P64[_sdN6V::P64 + 32];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdN6N::P64;
           R3 = Hp - 16;
           R2 = _sdN6M::P64;
           R1 = _sdN6K::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cdNsl,
                       label: Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNsl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNsp; else goto cdNso;
       cdNsp: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNso: // global
           I64[Hp - 56] = stg_sel_4_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdN6V_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdN6L::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdN6L::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.539500119 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.543345639 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdNsJ,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNsJ: // global
           _sdN74::P64 = R3;
           _sdN73::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNsK; else goto cdNsL;
       cdNsL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNsN; else goto cdNsM;
       cdNsN: // global
           HpAlloc = 48;
           goto cdNsK;
       cdNsK: // global
           R3 = _sdN74::P64;
           R2 = _sdN73::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNsM: // global
           I64[Hp - 40] = stg_sel_3_upd_info;
           P64[Hp - 24] = _sdN74::P64;
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdN74::P64;
           R2 = _sdN73::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.548996473 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_info;
 },
 sat_sdN7x_entry() //  [R1]
         { info_tbl: [(cdNt7,
                       label: sat_sdN7x_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNt7: // global
           _sdN7x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNt8; else goto cdNt9;
       cdNt9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNtb; else goto cdNta;
       cdNtb: // global
           HpAlloc = 24;
           goto cdNt8;
       cdNt8: // global
           R1 = _sdN7x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNta: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN7x::P64;
           _sdN7i::P64 = P64[_sdN7x::P64 + 16];
           _sdN7j::P64 = P64[_sdN7x::P64 + 24];
           _sdN7k::P64 = P64[_sdN7x::P64 + 32];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdN7k::P64;
           R3 = _sdN7j::P64;
           R2 = Hp - 16;
           R1 = _sdN7i::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdNtd,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNtd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNth; else goto cdNtg;
       cdNth: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNtg: // global
           I64[Hp - 56] = sat_sdN7x_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdN7h::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdN7h::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.557598795 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_info;
 },
 sat_sdN7I_entry() //  [R1]
         { info_tbl: [(cdNtE,
                       label: sat_sdN7I_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNtE: // global
           _sdN7I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNtF; else goto cdNtG;
       cdNtG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNtI; else goto cdNtH;
       cdNtI: // global
           HpAlloc = 24;
           goto cdNtF;
       cdNtF: // global
           R1 = _sdN7I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNtH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN7I::P64;
           _sdN7y::P64 = P64[_sdN7I::P64 + 16];
           _sdN7A::P64 = P64[_sdN7I::P64 + 24];
           _sdN7B::P64 = P64[_sdN7I::P64 + 32];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdN7B::P64;
           R3 = Hp - 16;
           R2 = _sdN7A::P64;
           R1 = _sdN7y::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cdNtJ,
                       label: Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNtJ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNtN; else goto cdNtM;
       cdNtN: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNtM: // global
           I64[Hp - 56] = stg_sel_3_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdN7I_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdN7z::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdN7z::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.565846372 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.56861095 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdNu7,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNu7: // global
           _sdN7Q::P64 = R3;
           _sdN7P::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNu8; else goto cdNu9;
       cdNu9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNub; else goto cdNua;
       cdNub: // global
           HpAlloc = 48;
           goto cdNu8;
       cdNu8: // global
           R3 = _sdN7Q::P64;
           R2 = _sdN7P::P64;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNua: // global
           I64[Hp - 40] = stg_sel_2_upd_info;
           P64[Hp - 24] = _sdN7Q::P64;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdN7Q::P64;
           R2 = _sdN7P::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.574424558 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_info;
 },
 sat_sdN8f_entry() //  [R1]
         { info_tbl: [(cdNuv,
                       label: sat_sdN8f_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNuv: // global
           _sdN8f::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNuw; else goto cdNux;
       cdNux: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNuz; else goto cdNuy;
       cdNuz: // global
           HpAlloc = 24;
           goto cdNuw;
       cdNuw: // global
           R1 = _sdN8f::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNuy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN8f::P64;
           _sdN82::P64 = P64[_sdN8f::P64 + 16];
           _sdN83::P64 = P64[_sdN8f::P64 + 24];
           _sdN84::P64 = P64[_sdN8f::P64 + 32];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdN84::P64;
           R3 = _sdN83::P64;
           R2 = Hp - 16;
           R1 = _sdN82::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdNuB,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNuB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNuF; else goto cdNuE;
       cdNuF: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNuE: // global
           I64[Hp - 56] = sat_sdN8f_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdN81::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdN81::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.583266752 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_info;
 },
 sat_sdN8p_entry() //  [R1]
         { info_tbl: [(cdNv2,
                       label: sat_sdN8p_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNv2: // global
           _sdN8p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNv3; else goto cdNv4;
       cdNv4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNv6; else goto cdNv5;
       cdNv6: // global
           HpAlloc = 24;
           goto cdNv3;
       cdNv3: // global
           R1 = _sdN8p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNv5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN8p::P64;
           _sdN8g::P64 = P64[_sdN8p::P64 + 16];
           _sdN8i::P64 = P64[_sdN8p::P64 + 24];
           _sdN8j::P64 = P64[_sdN8p::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdN8j::P64;
           R3 = Hp - 16;
           R2 = _sdN8i::P64;
           R1 = _sdN8g::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cdNv7,
                       label: Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNv7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNvb; else goto cdNva;
       cdNvb: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNva: // global
           I64[Hp - 56] = stg_sel_2_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdN8p_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdN8h::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdN8h::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.589632228 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,,)_closure" {
     Data.Bifoldable.$fBifoldable(,,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.591723269 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK2_closure" {
     Data.Bifoldable.$fBifoldableK2_closure:
         const Data.Bifoldable.$fBifoldableK2_info;
 },
 Data.Bifoldable.$fBifoldableK2_entry() //  [R3]
         { info_tbl: [(cdNvt,
                       label: Data.Bifoldable.$fBifoldableK2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNvt: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.595210471 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldr_entry() //  [R2, R4, R5]
         { info_tbl: [(cdNvE,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNvE: // global
           R3 = R4;
           _sdN8x::P64 = R2;
           R2 = R5;
           R1 = _sdN8x::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.598837128 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableK1_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableK1_$cbifoldl_entry() //  [R2, R4, R5]
         { info_tbl: [(cdNvP,
                       label: Data.Bifoldable.$fBifoldableK1_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNvP: // global
           R3 = R5;
           _sdN8B::P64 = R2;
           R2 = R4;
           R1 = _sdN8B::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.602175924 UTC

[section ""data" . Data.Bifoldable.$fBifoldableK1_closure" {
     Data.Bifoldable.$fBifoldableK1_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableK2_closure+2;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableK1_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.604101755 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst1_closure" {
     Data.Bifoldable.$fBifoldableConst1_closure:
         const Data.Bifoldable.$fBifoldableConst1_info;
 },
 Data.Bifoldable.$fBifoldableConst1_entry() //  [R3]
         { info_tbl: [(cdNw1,
                       label: Data.Bifoldable.$fBifoldableConst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNw1: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.607785442 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldr_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldr_entry() //  [R2, R4,
                                                          R5]
         { info_tbl: [(cdNwc,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNwc: // global
           R3 = R4;
           _sdN8H::P64 = R2;
           R2 = R5;
           R1 = _sdN8H::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.611354738 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldableConst_$cbifoldl_info;
 },
 Data.Bifoldable.$fBifoldableConst_$cbifoldl_entry() //  [R2, R4,
                                                          R5]
         { info_tbl: [(cdNwn,
                       label: Data.Bifoldable.$fBifoldableConst_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNwn: // global
           R3 = R5;
           _sdN8L::P64 = R2;
           R2 = R4;
           R1 = _sdN8L::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.615834034 UTC

[section ""data" . Data.Bifoldable.$fBifoldableConst_closure" {
     Data.Bifoldable.$fBifoldableConst_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldableConst1_closure+2;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldableConst_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.617946015 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifold_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifold_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifold_info;
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifold_entry() //  [R2, R3]
         { info_tbl: [(cdNwB,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNwB: // global
           _sdN8Q::P64 = R3;
           _sdN8P::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNwC; else goto cdNwD;
       cdNwD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNwF; else goto cdNwE;
       cdNwF: // global
           HpAlloc = 48;
           goto cdNwC;
       cdNwC: // global
           R3 = _sdN8Q::P64;
           R2 = _sdN8P::P64;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNwE: // global
           I64[Hp - 40] = stg_sel_1_upd_info;
           P64[Hp - 24] = _sdN8Q::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdN8Q::P64;
           R2 = _sdN8P::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 24;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.624879465 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldr_info;
 },
 sat_sdN9b_entry() //  [R1]
         { info_tbl: [(cdNwZ,
                       label: sat_sdN9b_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNwZ: // global
           _sdN9b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNx0; else goto cdNx1;
       cdNx1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNx3; else goto cdNx2;
       cdNx3: // global
           HpAlloc = 24;
           goto cdNx0;
       cdNx0: // global
           R1 = _sdN9b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNx2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN9b::P64;
           _sdN90::P64 = P64[_sdN9b::P64 + 16];
           _sdN91::P64 = P64[_sdN9b::P64 + 24];
           _sdN92::P64 = P64[_sdN9b::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdN92::P64;
           R3 = _sdN91::P64;
           R2 = Hp - 16;
           R1 = _sdN90::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldr_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdNx5,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNx5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNx9; else goto cdNx8;
       cdNx9: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNx8: // global
           I64[Hp - 56] = sat_sdN9b_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _sdN8Z::P64 = R2;
           R2 = Hp - 16;
           R1 = _sdN8Z::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.635538459 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure" {
     Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure:
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldl_info;
 },
 sat_sdN9k_entry() //  [R1]
         { info_tbl: [(cdNxw,
                       label: sat_sdN9k_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNxw: // global
           _sdN9k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNxx; else goto cdNxy;
       cdNxy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNxA; else goto cdNxz;
       cdNxA: // global
           HpAlloc = 24;
           goto cdNxx;
       cdNxx: // global
           R1 = _sdN9k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNxz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdN9k::P64;
           _sdN9c::P64 = P64[_sdN9k::P64 + 16];
           _sdN9e::P64 = P64[_sdN9k::P64 + 24];
           _sdN9f::P64 = P64[_sdN9k::P64 + 32];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdN9f::P64;
           R3 = Hp - 16;
           R2 = _sdN9e::P64;
           R1 = _sdN9c::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.$fBifoldable(,)_$cbifoldl_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cdNxB,
                       label: Data.Bifoldable.$fBifoldable(,)_$cbifoldl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNxB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdNxF; else goto cdNxE;
       cdNxF: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNxE: // global
           I64[Hp - 56] = stg_sel_1_upd_info;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = sat_sdN9k_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _sdN9d::P64 = R3;
           R3 = Hp - 56;
           R2 = Hp - 32;
           R1 = _sdN9d::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.644616412 UTC

[section ""data" . Data.Bifoldable.$fBifoldable(,)_closure" {
     Data.Bifoldable.$fBifoldable(,)_closure:
         const Data.Bifoldable.C:Bifoldable_con_info;
         const Data.Bifoldable.$fBifoldable(,)_$cbifold_closure+2;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldMap_closure+4;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldr_closure+4;
         const Data.Bifoldable.$fBifoldable(,)_$cbifoldl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.648213852 UTC

[section ""data" . Data.Bifoldable.bifoldr'_closure" {
     Data.Bifoldable.bifoldr'_closure:
         const Data.Bifoldable.bifoldr'_info;
 },
 sat_sdN9D_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdNy4,
                       label: sat_sdN9D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNy4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNy5; else goto cdNy6;
       cdNy5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNy6: // global
           I64[Sp - 16] = block_cdNy2_info;
           _sdN9A::P64 = R3;
           R3 = R4;
           _sdN9z::P64 = R2;
           R2 = _sdN9A::P64;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdN9z::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNy2() //  [R1]
         { info_tbl: [(cdNy2,
                       label: block_cdNy2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNy2: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdN9y_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdNyf,
                       label: sat_sdN9y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNyf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNyg; else goto cdNyh;
       cdNyg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNyh: // global
           I64[Sp - 16] = block_cdNyd_info;
           _sdN9v::P64 = R3;
           R3 = R4;
           _sdN9u::P64 = R2;
           R2 = _sdN9v::P64;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdN9u::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNyd() //  [R1]
         { info_tbl: [(cdNyd,
                       label: block_cdNyd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNyd: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldr'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdNyj,
                       label: Data.Bifoldable.bifoldr'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNyj: // global
           _sdN9t::P64 = R6;
           _sdN9s::P64 = R5;
           _sdN9r::P64 = R4;
           _sdN9q::P64 = R3;
           _sdN9p::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdNyk; else goto cdNyl;
       cdNyl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdNyn; else goto cdNym;
       cdNyn: // global
           HpAlloc = 32;
           goto cdNyk;
       cdNyk: // global
           R6 = _sdN9t::P64;
           R5 = _sdN9s::P64;
           R4 = _sdN9r::P64;
           R3 = _sdN9q::P64;
           R2 = _sdN9p::P64;
           R1 = Data.Bifoldable.bifoldr'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNym: // global
           I64[Hp - 24] = sat_sdN9D_info;
           P64[Hp - 16] = _sdN9r::P64;
           I64[Hp - 8] = sat_sdN9y_info;
           P64[Hp] = _sdN9q::P64;
           R2 = _sdN9p::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Hp - 5;
           P64[Sp - 32] = Hp - 21;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = _sdN9t::P64;
           P64[Sp - 8] = _sdN9s::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldl_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.664981651 UTC

[section ""cstring" . lvl_rdL8s_bytes" {
     lvl_rdL8s_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.66716593 UTC

[section ""data" . lvl1_rdL8t_closure" {
     lvl1_rdL8t_closure:
         const lvl1_rdL8t_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rdL8t_entry() //  [R1]
         { info_tbl: [(cdNyX,
                       label: lvl1_rdL8t_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNyX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNyY; else goto cdNyZ;
       cdNyY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNyZ: // global
           (_cdNyU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdNyU::I64 == 0) goto cdNyW; else goto cdNyV;
       cdNyW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdNyV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdNyU::I64;
           R2 = lvl_rdL8s_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.671742662 UTC

[section ""cstring" . Data.Bifoldable.$trModule4_bytes" {
     Data.Bifoldable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.673963733 UTC

[section ""data" . lvl2_rdL8u_closure" {
     lvl2_rdL8u_closure:
         const lvl2_rdL8u_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdL8u_entry() //  [R1]
         { info_tbl: [(cdNzf,
                       label: lvl2_rdL8u_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNzf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNzg; else goto cdNzh;
       cdNzg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNzh: // global
           (_cdNzc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdNzc::I64 == 0) goto cdNze; else goto cdNzd;
       cdNze: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdNzd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdNzc::I64;
           R2 = Data.Bifoldable.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.678250703 UTC

[section ""cstring" . Data.Bifoldable.$trModule2_bytes" {
     Data.Bifoldable.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,102,111,108,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.680359182 UTC

[section ""data" . lvl3_rdL8v_closure" {
     lvl3_rdL8v_closure:
         const lvl3_rdL8v_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdL8v_entry() //  [R1]
         { info_tbl: [(cdNzx,
                       label: lvl3_rdL8v_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNzx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNzy; else goto cdNzz;
       cdNzy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNzz: // global
           (_cdNzu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdNzu::I64 == 0) goto cdNzw; else goto cdNzv;
       cdNzw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdNzv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdNzu::I64;
           R2 = Data.Bifoldable.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.684712176 UTC

[section ""cstring" . lvl4_rdL8w_bytes" {
     lvl4_rdL8w_bytes:
         I8[] [46,47,68,97,116,97,47,66,105,102,111,108,100,97,98,108,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.686878 UTC

[section ""data" . lvl5_rdL8x_closure" {
     lvl5_rdL8x_closure:
         const lvl5_rdL8x_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rdL8x_entry() //  [R1]
         { info_tbl: [(cdNzP,
                       label: lvl5_rdL8x_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNzP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNzQ; else goto cdNzR;
       cdNzQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNzR: // global
           (_cdNzM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdNzM::I64 == 0) goto cdNzO; else goto cdNzN;
       cdNzO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdNzN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdNzM::I64;
           R2 = lvl4_rdL8w_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.691869441 UTC

[section ""data" . lvl6_rdL8y_closure" {
     lvl6_rdL8y_closure:
         const GHC.Types.I#_con_info;
         const 188;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.693665594 UTC

[section ""data" . lvl7_rdL8z_closure" {
     lvl7_rdL8z_closure:
         const GHC.Types.I#_con_info;
         const 28;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.69536817 UTC

[section ""data" . lvl8_rdL8A_closure" {
     lvl8_rdL8A_closure:
         const GHC.Types.I#_con_info;
         const 61;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.697110206 UTC

[section ""data" . lvl9_rdL8B_closure" {
     lvl9_rdL8B_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl6_rdL8y_closure+1;
         const lvl7_rdL8z_closure+1;
         const lvl6_rdL8y_closure+1;
         const lvl8_rdL8A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.700140162 UTC

[section ""data" . lvl10_rdL8C_closure" {
     lvl10_rdL8C_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl9_rdL8B_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.702925719 UTC

[section ""cstring" . lvl11_rdL8D_bytes" {
     lvl11_rdL8D_bytes:
         I8[] [98,105,102,111,108,100,114,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.706070902 UTC

[section ""data" . Data.Bifoldable.bifoldr2_closure" {
     Data.Bifoldable.bifoldr2_closure:
         const Data.Bifoldable.bifoldr2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bifoldr2_entry() //  [R1]
         { info_tbl: [(cdNAe,
                       label: Data.Bifoldable.bifoldr2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNAe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdNAf; else goto cdNAg;
       cdNAf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNAg: // global
           (_cdNA9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdNA9::I64 == 0) goto cdNAb; else goto cdNAa;
       cdNAb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdNAa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdNA9::I64;
           I64[Sp - 24] = block_cdNAc_info;
           R2 = lvl11_rdL8D_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdNAc() //  [R1]
         { info_tbl: [(cdNAc,
                       label: block_cdNAc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNAc: // global
           R3 = R1;
           R2 = lvl10_rdL8C_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.716238222 UTC

[section ""data" . Data.Bifoldable.bifoldr1_closure" {
     Data.Bifoldable.bifoldr1_closure:
         const Data.Bifoldable.bifoldr1_info;
         const 0;
 },
 sat_sdN9N_entry() //  [R1]
         { info_tbl: [(cdNAQ,
                       label: sat_sdN9N_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNAQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdNAR; else goto cdNAS;
       cdNAR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNAS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdNAJ_info;
           _sdN9G::P64 = P64[R1 + 16];
           _sdN9J::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdN9G::P64;
           P64[Sp - 24] = _sdN9J::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udNAZ; else goto cdNAK;
       udNAZ: // global
           call _cdNAJ(R1) args: 0, res: 0, upd: 0;
       cdNAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdNAJ() //  [R1]
         { info_tbl: [(cdNAJ,
                       label: block_cdNAJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNAJ: // global
           _sdN9J::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdNAN; else goto cdNAO;
       cdNAN: // global
           R1 = _sdN9J::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cdNAO: // global
           R3 = P64[R1 + 6];
           R2 = _sdN9J::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdN9I_entry() //  [R1, R2, R3]
         { info_tbl: [(cdNB1,
                       label: mbf_sdN9I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNB1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdNB5; else goto cdNB4;
       cdNB5: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNB4: // global
           _sdN9G::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdN9N_info;
           P64[Hp - 32] = _sdN9G::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldr1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNBc,
                       label: Data.Bifoldable.bifoldr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNBc: // global
           _sdN9H::P64 = R4;
           _sdN9G::P64 = R3;
           _sdN9F::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdNBd; else goto cdNBe;
       cdNBe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdNBg; else goto cdNBf;
       cdNBg: // global
           HpAlloc = 16;
           goto cdNBd;
       cdNBd: // global
           R4 = _sdN9H::P64;
           R3 = _sdN9G::P64;
           R2 = _sdN9F::P64;
           R1 = Data.Bifoldable.bifoldr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNBf: // global
           I64[Hp - 8] = mbf_sdN9I_info;
           P64[Hp] = _sdN9G::P64;
           I64[Sp - 8] = block_cdNB6_info;
           R2 = _sdN9F::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdNAA::P64 = Hp - 6;
           P64[Sp - 40] = _cdNAA::P64;
           P64[Sp - 32] = _cdNAA::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdN9H::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdNB6() //  [R1]
         { info_tbl: [(cdNB6,
                       label: block_cdNB6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNB6: // global
           if (R1 & 7 == 1) goto cdNB9; else goto cdNBa;
       cdNB9: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdNBa: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.736113389 UTC

[section ""data" . Data.Bifoldable.bimaximumBy_closure" {
     Data.Bifoldable.bimaximumBy_closure:
         const Data.Bifoldable.bimaximumBy_info;
         const 0;
 },
 sat_sdN9Z_entry() //  [R1]
         { info_tbl: [(cdNCf,
                       label: sat_sdN9Z_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNCf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdNCg; else goto cdNCh;
       cdNCg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNCh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdNC8_info;
           _sdN9R::P64 = P64[R1 + 16];
           _sdN9U::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdN9R::P64;
           P64[Sp - 24] = _sdN9U::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udNCD; else goto cdNC9;
       udNCD: // global
           call _cdNC8(R1) args: 0, res: 0, upd: 0;
       cdNC9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdNC8() //  [R1]
         { info_tbl: [(cdNC8,
                       label: block_cdNC8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNC8: // global
           if (R1 & 7 == 1) goto udNCA; else goto cdNCd;
       udNCA: // global
           Sp = Sp + 16;
           call _cdNCy() args: 0, res: 0, upd: 0;
       cdNCd: // global
           I64[Sp] = block_cdNCn_info;
           _sdN9X::P64 = P64[R1 + 6];
           R3 = _sdN9X::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdN9X::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdNCn() //  [R1]
         { info_tbl: [(cdNCn,
                       label: block_cdNCn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNCn: // global
           if (R1 & 7 == 3) goto udNCB; else goto cdNCu;
       udNCB: // global
           Sp = Sp + 16;
           call _cdNCy() args: 0, res: 0, upd: 0;
       cdNCu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cdNCy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNCy: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdN9T_entry() //  [R1, R2, R3]
         { info_tbl: [(cdNCG,
                       label: mbf_sdN9T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNCG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdNCK; else goto cdNCJ;
       cdNCK: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNCJ: // global
           _sdN9R::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdN9Z_info;
           P64[Hp - 32] = _sdN9R::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bimaximumBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNCR,
                       label: Data.Bifoldable.bimaximumBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNCR: // global
           _sdN9S::P64 = R4;
           _sdN9R::P64 = R3;
           _sdN9Q::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdNCS; else goto cdNCT;
       cdNCT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdNCV; else goto cdNCU;
       cdNCV: // global
           HpAlloc = 16;
           goto cdNCS;
       cdNCS: // global
           R4 = _sdN9S::P64;
           R3 = _sdN9R::P64;
           R2 = _sdN9Q::P64;
           R1 = Data.Bifoldable.bimaximumBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNCU: // global
           I64[Hp - 8] = mbf_sdN9T_info;
           P64[Hp] = _sdN9R::P64;
           I64[Sp - 8] = block_cdNCL_info;
           R2 = _sdN9Q::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdNBZ::P64 = Hp - 6;
           P64[Sp - 40] = _cdNBZ::P64;
           P64[Sp - 32] = _cdNBZ::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdN9S::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdNCL() //  [R1]
         { info_tbl: [(cdNCL,
                       label: block_cdNCL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNCL: // global
           if (R1 & 7 == 1) goto cdNCO; else goto cdNCP;
       cdNCO: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdNCP: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.7578282 UTC

[section ""data" . Data.Bifoldable.biminimumBy_closure" {
     Data.Bifoldable.biminimumBy_closure:
         const Data.Bifoldable.biminimumBy_info;
         const 0;
 },
 sat_sdNab_entry() //  [R1]
         { info_tbl: [(cdNE2,
                       label: sat_sdNab_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNE2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdNE3; else goto cdNE4;
       cdNE3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNE4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdNDV_info;
           _sdNa3::P64 = P64[R1 + 16];
           _sdNa6::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sdNa3::P64;
           P64[Sp - 24] = _sdNa6::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udNEq; else goto cdNDW;
       udNEq: // global
           call _cdNDV(R1) args: 0, res: 0, upd: 0;
       cdNDW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdNDV() //  [R1]
         { info_tbl: [(cdNDV,
                       label: block_cdNDV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNDV: // global
           if (R1 & 7 == 1) goto udNEn; else goto cdNE0;
       udNEn: // global
           Sp = Sp + 16;
           call _cdNEh() args: 0, res: 0, upd: 0;
       cdNE0: // global
           I64[Sp] = block_cdNEa_info;
           _sdNa9::P64 = P64[R1 + 6];
           R3 = _sdNa9::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdNa9::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdNEa() //  [R1]
         { info_tbl: [(cdNEa,
                       label: block_cdNEa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNEa: // global
           if (R1 & 7 == 3) goto cdNEl; else goto udNEo;
       cdNEl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       udNEo: // global
           Sp = Sp + 16;
           call _cdNEh() args: 0, res: 0, upd: 0;
     }
 },
 _cdNEh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNEh: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdNa5_entry() //  [R1, R2, R3]
         { info_tbl: [(cdNEt,
                       label: mbf_sdNa5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNEt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdNEx; else goto cdNEw;
       cdNEx: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNEw: // global
           _sdNa3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdNab_info;
           P64[Hp - 32] = _sdNa3::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biminimumBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNEE,
                       label: Data.Bifoldable.biminimumBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNEE: // global
           _sdNa4::P64 = R4;
           _sdNa3::P64 = R3;
           _sdNa2::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdNEF; else goto cdNEG;
       cdNEG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdNEI; else goto cdNEH;
       cdNEI: // global
           HpAlloc = 16;
           goto cdNEF;
       cdNEF: // global
           R4 = _sdNa4::P64;
           R3 = _sdNa3::P64;
           R2 = _sdNa2::P64;
           R1 = Data.Bifoldable.biminimumBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNEH: // global
           I64[Hp - 8] = mbf_sdNa5_info;
           P64[Hp] = _sdNa3::P64;
           I64[Sp - 8] = block_cdNEy_info;
           R2 = _sdNa2::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdNDM::P64 = Hp - 6;
           P64[Sp - 40] = _cdNDM::P64;
           P64[Sp - 32] = _cdNDM::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdNa4::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdNEy() //  [R1]
         { info_tbl: [(cdNEy,
                       label: block_cdNEy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNEy: // global
           if (R1 & 7 == 1) goto cdNEB; else goto cdNEC;
       cdNEB: // global
           R1 = Data.Bifoldable.bifoldr2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdNEC: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.775753605 UTC

[section ""data" . Data.Bifoldable.bifoldrM_closure" {
     Data.Bifoldable.bifoldrM_closure:
         const Data.Bifoldable.bifoldrM_info;
 },
 sat_sdNau_entry() //  [R1]
         { info_tbl: [(cdNFD,
                       label: sat_sdNau_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNFD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNFE; else goto cdNFF;
       cdNFE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNFF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdNat_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdNFM,
                       label: sat_sdNat_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNFM: // global
           _sdNar::P64 = R4;
           _sdNaq::P64 = R3;
           _sdNap::P64 = R2;
           _sdNat::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNFN; else goto cdNFO;
       cdNFO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdNFQ; else goto cdNFP;
       cdNFQ: // global
           HpAlloc = 40;
           goto cdNFN;
       cdNFN: // global
           R4 = _sdNar::P64;
           R3 = _sdNaq::P64;
           R2 = _sdNap::P64;
           R1 = _sdNat::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNFP: // global
           _sdNaf::P64 = P64[_sdNat::P64 + 5];
           _sdNah::P64 = P64[_sdNat::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdNah::P64;
           P64[Hp - 8] = _sdNaq::P64;
           P64[Hp] = _sdNar::P64;
           R2 = _sdNaf::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdNap::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdNao_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdNFX,
                       label: sat_sdNao_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNFX: // global
           _sdNam::P64 = R4;
           _sdNal::P64 = R3;
           _sdNak::P64 = R2;
           _sdNao::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNFY; else goto cdNFZ;
       cdNFZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdNG1; else goto cdNG0;
       cdNG1: // global
           HpAlloc = 40;
           goto cdNFY;
       cdNFY: // global
           R4 = _sdNam::P64;
           R3 = _sdNal::P64;
           R2 = _sdNak::P64;
           R1 = _sdNao::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNG0: // global
           _sdNaf::P64 = P64[_sdNao::P64 + 5];
           _sdNag::P64 = P64[_sdNao::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdNag::P64;
           P64[Hp - 8] = _sdNal::P64;
           P64[Hp] = _sdNam::P64;
           R2 = _sdNaf::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdNak::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldrM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdNG2,
                       label: Data.Bifoldable.bifoldrM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNG2: // global
           _sdNai::P64 = R6;
           _sdNah::P64 = R5;
           _sdNag::P64 = R4;
           _sdNaf::P64 = R3;
           _sdNae::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdNG3; else goto cdNG4;
       cdNG4: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdNG6; else goto cdNG5;
       cdNG6: // global
           HpAlloc = 72;
           goto cdNG3;
       cdNG3: // global
           R6 = _sdNai::P64;
           R5 = _sdNah::P64;
           R4 = _sdNag::P64;
           R3 = _sdNaf::P64;
           R2 = _sdNae::P64;
           R1 = Data.Bifoldable.bifoldrM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdNG5: // global
           I64[Hp - 64] = sat_sdNau_info;
           P64[Hp - 48] = _sdNaf::P64;
           I64[Hp - 40] = sat_sdNat_info;
           P64[Hp - 32] = _sdNaf::P64;
           P64[Hp - 24] = _sdNah::P64;
           I64[Hp - 16] = sat_sdNao_info;
           P64[Hp - 8] = _sdNaf::P64;
           P64[Hp] = _sdNag::P64;
           R2 = _sdNae::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = Hp - 37;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = _sdNai::P64;
           Sp = Sp - 40;
           call Data.Bifoldable.bifoldl_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.789034423 UTC

[section ""data" . Data.Bifoldable.bifoldl'_closure" {
     Data.Bifoldable.bifoldl'_closure:
         const Data.Bifoldable.bifoldl'_info;
 },
 sat_sdNaJ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdNGO,
                       label: sat_sdNaJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNGO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNGP; else goto cdNGQ;
       cdNGP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNGQ: // global
           I64[Sp - 16] = block_cdNGM_info;
           _sdNaG::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdNaG::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNGM() //  [R1]
         { info_tbl: [(cdNGM,
                       label: block_cdNGM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNGM: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdNaE_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdNGZ,
                       label: sat_sdNaE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNGZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNH0; else goto cdNH1;
       cdNH0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNH1: // global
           I64[Sp - 16] = block_cdNGX_info;
           _sdNaB::P64 = R3;
           R3 = R2;
           R2 = R4;
           R1 = P64[R1 + 5];
           P64[Sp - 8] = _sdNaB::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNGX() //  [R1]
         { info_tbl: [(cdNGX,
                       label: block_cdNGX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNGX: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldl'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdNH3,
                       label: Data.Bifoldable.bifoldl'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNH3: // global
           _sdNaz::P64 = R6;
           _sdNay::P64 = R5;
           _sdNax::P64 = R4;
           _sdNaw::P64 = R3;
           _sdNav::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdNH4; else goto cdNH5;
       cdNH5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdNH7; else goto cdNH6;
       cdNH7: // global
           HpAlloc = 32;
           goto cdNH4;
       cdNH4: // global
           R6 = _sdNaz::P64;
           R5 = _sdNay::P64;
           R4 = _sdNax::P64;
           R3 = _sdNaw::P64;
           R2 = _sdNav::P64;
           R1 = Data.Bifoldable.bifoldl'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNH6: // global
           I64[Hp - 24] = sat_sdNaJ_info;
           P64[Hp - 16] = _sdNax::P64;
           I64[Hp - 8] = sat_sdNaE_info;
           P64[Hp] = _sdNaw::P64;
           R2 = _sdNav::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Hp - 5;
           P64[Sp - 32] = Hp - 21;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = _sdNaz::P64;
           P64[Sp - 8] = _sdNay::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.805064961 UTC

[section ""data" . Data.Bifoldable.bilength2_closure" {
     Data.Bifoldable.bilength2_closure:
         const Data.Bifoldable.bilength2_info;
 },
 Data.Bifoldable.bilength2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNHH,
                       label: Data.Bifoldable.bilength2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNHH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNHO; else goto cdNHP;
       cdNHO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bilength2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNHP: // global
           I64[Sp - 16] = block_cdNHE_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udNHT; else goto cdNHF;
       udNHT: // global
           call _cdNHE(R1) args: 0, res: 0, upd: 0;
       cdNHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNHE() //  [R1]
         { info_tbl: [(cdNHE,
                       label: block_cdNHE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNHE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdNHS; else goto cdNHR;
       cdNHS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdNHR: // global
           _sdNaP::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sdNaP::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.81647653 UTC

[section ""data" . Data.Bifoldable.bilength1_closure" {
     Data.Bifoldable.bilength1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.81953233 UTC

[section ""data" . Data.Bifoldable.bilength_closure" {
     Data.Bifoldable.bilength_closure:
         const Data.Bifoldable.bilength_info;
 },
 Data.Bifoldable.bilength_entry() //  [R2, R3]
         { info_tbl: [(cdNIb,
                       label: Data.Bifoldable.bilength_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNIb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdNIc; else goto cdNId;
       cdNIc: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bilength_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNId: // global
           R2 = R2;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Bifoldable.bilength2_closure+3;
           P64[Sp - 32] = Data.Bifoldable.bilength2_closure+3;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Data.Bifoldable.bilength1_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.824581937 UTC

[section ""data" . lvl12_rdL8E_closure" {
     lvl12_rdL8E_closure:
         const GHC.Types.I#_con_info;
         const 223;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.826483935 UTC

[section ""data" . lvl13_rdL8F_closure" {
     lvl13_rdL8F_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl12_rdL8E_closure+1;
         const lvl7_rdL8z_closure+1;
         const lvl12_rdL8E_closure+1;
         const lvl8_rdL8A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.828417116 UTC

[section ""data" . lvl14_rdL8G_closure" {
     lvl14_rdL8G_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl13_rdL8F_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.830466869 UTC

[section ""cstring" . lvl15_rdL8H_bytes" {
     lvl15_rdL8H_bytes:
         I8[] [98,105,102,111,108,100,108,49,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.83263112 UTC

[section ""data" . Data.Bifoldable.bifoldl2_closure" {
     Data.Bifoldable.bifoldl2_closure:
         const Data.Bifoldable.bifoldl2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bifoldl2_entry() //  [R1]
         { info_tbl: [(cdNIB,
                       label: Data.Bifoldable.bifoldl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNIB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdNIC; else goto cdNID;
       cdNIC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNID: // global
           (_cdNIw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdNIw::I64 == 0) goto cdNIy; else goto cdNIx;
       cdNIy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdNIx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdNIw::I64;
           I64[Sp - 24] = block_cdNIz_info;
           R2 = lvl15_rdL8H_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdNIz() //  [R1]
         { info_tbl: [(cdNIz,
                       label: block_cdNIz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNIz: // global
           R3 = R1;
           R2 = lvl14_rdL8G_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.842611672 UTC

[section ""data" . Data.Bifoldable.bifoldl1_closure" {
     Data.Bifoldable.bifoldl1_closure:
         const Data.Bifoldable.bifoldl1_info;
         const 0;
 },
 sat_sdNb2_entry() //  [R1]
         { info_tbl: [(cdNJd,
                       label: sat_sdNb2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNJd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdNJe; else goto cdNJf;
       cdNJe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNJf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdNJ6_info;
           _sdNaV::P64 = P64[R1 + 16];
           _sdNaZ::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdNaV::P64;
           P64[Sp - 24] = _sdNaZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udNJm; else goto cdNJ7;
       udNJm: // global
           call _cdNJ6(R1) args: 0, res: 0, upd: 0;
       cdNJ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdNJ6() //  [R1]
         { info_tbl: [(cdNJ6,
                       label: block_cdNJ6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNJ6: // global
           _sdNaZ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdNJa; else goto cdNJb;
       cdNJa: // global
           R1 = _sdNaZ::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cdNJb: // global
           R3 = _sdNaZ::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 mbf_sdNaX_entry() //  [R1, R2, R3]
         { info_tbl: [(cdNJo,
                       label: mbf_sdNaX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNJo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdNJs; else goto cdNJr;
       cdNJs: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNJr: // global
           _sdNaV::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sdNb2_info;
           P64[Hp - 32] = _sdNaV::P64;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldl1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNJz,
                       label: Data.Bifoldable.bifoldl1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNJz: // global
           _sdNaW::P64 = R4;
           _sdNaV::P64 = R3;
           _sdNaU::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdNJA; else goto cdNJB;
       cdNJB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdNJD; else goto cdNJC;
       cdNJD: // global
           HpAlloc = 16;
           goto cdNJA;
       cdNJA: // global
           R4 = _sdNaW::P64;
           R3 = _sdNaV::P64;
           R2 = _sdNaU::P64;
           R1 = Data.Bifoldable.bifoldl1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNJC: // global
           I64[Hp - 8] = mbf_sdNaX_info;
           P64[Hp] = _sdNaV::P64;
           I64[Sp - 8] = block_cdNJt_info;
           R2 = _sdNaU::P64;
           I64[Sp - 48] = stg_ap_pppp_info;
           _cdNIX::P64 = Hp - 6;
           P64[Sp - 40] = _cdNIX::P64;
           P64[Sp - 32] = _cdNIX::P64;
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 16] = _sdNaW::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldl_entry(R2) args: 48, res: 8, upd: 8;
     }
 },
 _cdNJt() //  [R1]
         { info_tbl: [(cdNJt,
                       label: block_cdNJt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNJt: // global
           if (R1 & 7 == 1) goto cdNJw; else goto cdNJx;
       cdNJw: // global
           R1 = Data.Bifoldable.bifoldl2_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdNJx: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.859347904 UTC

[section ""data" . Data.Bifoldable.bifoldlM_closure" {
     Data.Bifoldable.bifoldlM_closure:
         const Data.Bifoldable.bifoldlM_info;
 },
 sat_sdNbl_entry() //  [R1]
         { info_tbl: [(cdNKq,
                       label: sat_sdNbl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNKq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNKr; else goto cdNKs;
       cdNKr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNKs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdNbk_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdNKz,
                       label: sat_sdNbk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNKz: // global
           _sdNbi::P64 = R4;
           _sdNbh::P64 = R3;
           _sdNbg::P64 = R2;
           _sdNbk::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNKA; else goto cdNKB;
       cdNKB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdNKD; else goto cdNKC;
       cdNKD: // global
           HpAlloc = 40;
           goto cdNKA;
       cdNKA: // global
           R4 = _sdNbi::P64;
           R3 = _sdNbh::P64;
           R2 = _sdNbg::P64;
           R1 = _sdNbk::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNKC: // global
           _sdNb6::P64 = P64[_sdNbk::P64 + 5];
           _sdNb8::P64 = P64[_sdNbk::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdNb8::P64;
           P64[Hp - 8] = _sdNbi::P64;
           P64[Hp] = _sdNbg::P64;
           R2 = _sdNb6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdNbh::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdNbf_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cdNKK,
                       label: sat_sdNbf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNKK: // global
           _sdNbd::P64 = R4;
           _sdNbc::P64 = R3;
           _sdNbb::P64 = R2;
           _sdNbf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNKL; else goto cdNKM;
       cdNKM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdNKO; else goto cdNKN;
       cdNKO: // global
           HpAlloc = 40;
           goto cdNKL;
       cdNKL: // global
           R4 = _sdNbd::P64;
           R3 = _sdNbc::P64;
           R2 = _sdNbb::P64;
           R1 = _sdNbf::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNKN: // global
           _sdNb6::P64 = P64[_sdNbf::P64 + 5];
           _sdNb7::P64 = P64[_sdNbf::P64 + 13];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sdNb7::P64;
           P64[Hp - 8] = _sdNbd::P64;
           P64[Hp] = _sdNbb::P64;
           R2 = _sdNb6::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _sdNbc::P64;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifoldlM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdNKP,
                       label: Data.Bifoldable.bifoldlM_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNKP: // global
           _sdNb9::P64 = R6;
           _sdNb8::P64 = R5;
           _sdNb7::P64 = R4;
           _sdNb6::P64 = R3;
           _sdNb5::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cdNKQ; else goto cdNKR;
       cdNKR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdNKT; else goto cdNKS;
       cdNKT: // global
           HpAlloc = 72;
           goto cdNKQ;
       cdNKQ: // global
           R6 = _sdNb9::P64;
           R5 = _sdNb8::P64;
           R4 = _sdNb7::P64;
           R3 = _sdNb6::P64;
           R2 = _sdNb5::P64;
           R1 = Data.Bifoldable.bifoldlM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdNKS: // global
           I64[Hp - 64] = sat_sdNbl_info;
           P64[Hp - 48] = _sdNb6::P64;
           I64[Hp - 40] = sat_sdNbk_info;
           P64[Hp - 32] = _sdNb6::P64;
           P64[Hp - 24] = _sdNb8::P64;
           I64[Hp - 16] = sat_sdNbf_info;
           P64[Hp - 8] = _sdNb6::P64;
           P64[Hp] = _sdNb7::P64;
           R2 = _sdNb5::P64;
           I64[Sp - 40] = stg_ap_ppppp_info;
           P64[Sp - 32] = Hp - 13;
           P64[Sp - 24] = Hp - 37;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = P64[Sp];
           P64[Sp] = _sdNb9::P64;
           Sp = Sp - 40;
           call Data.Bifoldable.bifoldr_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.882894651 UTC

[section ""data" . Data.Bifoldable.bitraverse__closure" {
     Data.Bifoldable.bitraverse__closure:
         const Data.Bifoldable.bitraverse__info;
 },
 sat_sdNbw_entry() //  [R1]
         { info_tbl: [(cdNLy,
                       label: sat_sdNbw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNLy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdNLz; else goto cdNLA;
       cdNLz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNLA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sdNbv_entry() //  [R1, R2]
         { info_tbl: [(cdNLH,
                       label: sat_sdNbv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNLH: // global
           _sdNbt::P64 = R2;
           _sdNbv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNLI; else goto cdNLJ;
       cdNLJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdNLL; else goto cdNLK;
       cdNLL: // global
           HpAlloc = 32;
           goto cdNLI;
       cdNLI: // global
           R2 = _sdNbt::P64;
           R1 = _sdNbv::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNLK: // global
           _sdNbn::P64 = P64[_sdNbv::P64 + 7];
           _sdNbp::P64 = P64[_sdNbv::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdNbp::P64;
           P64[Hp] = _sdNbt::P64;
           R2 = _sdNbn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdNbs_entry() //  [R1, R2]
         { info_tbl: [(cdNLS,
                       label: sat_sdNbs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNLS: // global
           _sdNbq::P64 = R2;
           _sdNbs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNLT; else goto cdNLU;
       cdNLU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdNLW; else goto cdNLV;
       cdNLW: // global
           HpAlloc = 32;
           goto cdNLT;
       cdNLT: // global
           R2 = _sdNbq::P64;
           R1 = _sdNbs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNLV: // global
           _sdNbn::P64 = P64[_sdNbs::P64 + 7];
           _sdNbo::P64 = P64[_sdNbs::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdNbo::P64;
           P64[Hp] = _sdNbq::P64;
           R2 = _sdNbn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bitraverse__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdNLX,
                       label: Data.Bifoldable.bitraverse__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNLX: // global
           _sdNbp::P64 = R5;
           _sdNbo::P64 = R4;
           _sdNbn::P64 = R3;
           _sdNbm::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdNLY; else goto cdNLZ;
       cdNLZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdNM1; else goto cdNM0;
       cdNM1: // global
           HpAlloc = 72;
           goto cdNLY;
       cdNLY: // global
           R5 = _sdNbp::P64;
           R4 = _sdNbo::P64;
           R3 = _sdNbn::P64;
           R2 = _sdNbm::P64;
           R1 = Data.Bifoldable.bitraverse__closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNM0: // global
           I64[Hp - 64] = sat_sdNbw_info;
           P64[Hp - 48] = _sdNbn::P64;
           I64[Hp - 40] = sat_sdNbv_info;
           P64[Hp - 32] = _sdNbn::P64;
           P64[Hp - 24] = _sdNbp::P64;
           I64[Hp - 16] = sat_sdNbs_info;
           P64[Hp - 8] = _sdNbn::P64;
           P64[Hp] = _sdNbo::P64;
           R2 = _sdNbm::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 15;
           P64[Sp - 16] = Hp - 39;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.901233627 UTC

[section ""data" . Data.Bifoldable.bifor__closure" {
     Data.Bifoldable.bifor__closure:
         const Data.Bifoldable.bifor__info;
 },
 Data.Bifoldable.bifor__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdNME,
                       label: Data.Bifoldable.bifor__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNME: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNMF; else goto cdNMG;
       cdNMF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bifor__closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNMG: // global
           _sdNbA::P64 = R5;
           R5 = R6;
           _sdNbz::P64 = R4;
           R4 = _sdNbA::P64;
           R3 = R3;
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = _sdNbz::P64;
           Sp = Sp - 16;
           call Data.Bifoldable.bitraverse__entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.908066002 UTC

[section ""data" . Data.Bifoldable.biforM__closure" {
     Data.Bifoldable.biforM__closure:
         const Data.Bifoldable.biforM__info;
 },
 Data.Bifoldable.biforM__entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdNMR,
                       label: Data.Bifoldable.biforM__info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNMR: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bifor__entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.912182285 UTC

[section ""data" . Data.Bifoldable.bimapM__closure" {
     Data.Bifoldable.bimapM__closure:
         const Data.Bifoldable.bimapM__info;
 },
 Data.Bifoldable.bimapM__entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdNN2,
                       label: Data.Bifoldable.bimapM__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNN2: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bitraverse__entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.918961897 UTC

[section ""data" . Data.Bifoldable.bisequence__closure" {
     Data.Bifoldable.bisequence__closure:
         const Data.Bifoldable.bisequence__info;
 },
 sat_sdNbG_entry() //  [R1]
         { info_tbl: [(cdNNh,
                       label: sat_sdNbG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNNh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdNNi; else goto cdNNj;
       cdNNi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNNj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sdNbF_entry() //  [R1]
         { info_tbl: [(cdNNo,
                       label: sat_sdNbF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNNo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNNp; else goto cdNNq;
       cdNNp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNNq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdNbE_entry() //  [R1]
         { info_tbl: [(cdNNv,
                       label: sat_sdNbE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNNv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNNw; else goto cdNNx;
       cdNNw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNNx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.bisequence__entry() //  [R2, R3]
         { info_tbl: [(cdNNy,
                       label: Data.Bifoldable.bisequence__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNNy: // global
           _sdNbD::P64 = R3;
           _sdNbC::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdNNz; else goto cdNNA;
       cdNNA: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdNNC; else goto cdNNB;
       cdNNC: // global
           HpAlloc = 72;
           goto cdNNz;
       cdNNz: // global
           R3 = _sdNbD::P64;
           R2 = _sdNbC::P64;
           R1 = Data.Bifoldable.bisequence__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNNB: // global
           I64[Hp - 64] = sat_sdNbG_info;
           P64[Hp - 48] = _sdNbD::P64;
           I64[Hp - 40] = sat_sdNbF_info;
           P64[Hp - 24] = _sdNbD::P64;
           I64[Hp - 16] = sat_sdNbE_info;
           P64[Hp] = _sdNbD::P64;
           R2 = _sdNbC::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.93659408 UTC

[section ""data" . Data.Bifoldable.bisequenceA__closure" {
     Data.Bifoldable.bisequenceA__closure:
         const Data.Bifoldable.bisequenceA__info;
 },
 Data.Bifoldable.bisequenceA__entry() //  [R2, R3]
         { info_tbl: [(cdNOb,
                       label: Data.Bifoldable.bisequenceA__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNOb: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bisequence__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.943556422 UTC

[section ""data" . Data.Bifoldable.biasum_closure" {
     Data.Bifoldable.biasum_closure:
         const Data.Bifoldable.biasum_info;
 },
 sat_sdNbL_entry() //  [R1]
         { info_tbl: [(cdNOq,
                       label: sat_sdNbL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNOq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNOr; else goto cdNOs;
       cdNOr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNOs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdNbK_entry() //  [R1]
         { info_tbl: [(cdNOx,
                       label: sat_sdNbK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNOx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNOy; else goto cdNOz;
       cdNOy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNOz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdNbJ_entry() //  [R1]
         { info_tbl: [(cdNOE,
                       label: sat_sdNbJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNOE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNOF; else goto cdNOG;
       cdNOF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNOG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.biasum_entry() //  [R2, R3]
         { info_tbl: [(cdNOH,
                       label: Data.Bifoldable.biasum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNOH: // global
           _sdNbI::P64 = R3;
           _sdNbH::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdNOI; else goto cdNOJ;
       cdNOJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdNOL; else goto cdNOK;
       cdNOL: // global
           HpAlloc = 72;
           goto cdNOI;
       cdNOI: // global
           R3 = _sdNbI::P64;
           R2 = _sdNbH::P64;
           R1 = Data.Bifoldable.biasum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNOK: // global
           I64[Hp - 64] = sat_sdNbL_info;
           P64[Hp - 48] = _sdNbI::P64;
           I64[Hp - 40] = sat_sdNbK_info;
           P64[Hp - 24] = _sdNbI::P64;
           I64[Hp - 16] = sat_sdNbJ_info;
           P64[Hp] = _sdNbI::P64;
           R2 = _sdNbH::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.959304023 UTC

[section ""data" . Data.Bifoldable.bimsum_closure" {
     Data.Bifoldable.bimsum_closure:
         const Data.Bifoldable.bimsum_info;
 },
 Data.Bifoldable.bimsum_entry() //  [R2, R3]
         { info_tbl: [(cdNPh,
                       label: Data.Bifoldable.bimsum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNPh: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biasum_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.965069215 UTC

[section ""data" . Data.Bifoldable.biList_closure" {
     Data.Bifoldable.biList_closure:
         const Data.Bifoldable.biList_info;
 },
 Data.Bifoldable.biList_entry() //  [R2]
         { info_tbl: [(cdNPs,
                       label: Data.Bifoldable.biList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNPs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdNPt; else goto cdNPu;
       cdNPt: // global
           R2 = R2;
           R1 = Data.Bifoldable.biList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNPu: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = GHC.Types.:_closure+2;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.972336107 UTC

[section ""data" . Data.Bifoldable.binull1_closure" {
     Data.Bifoldable.binull1_closure:
         const Data.Bifoldable.binull1_info;
 },
 Data.Bifoldable.binull1_entry() //  []
         { info_tbl: [(cdNPL,
                       label: Data.Bifoldable.binull1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNPL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.978704149 UTC

[section ""data" . Data.Bifoldable.binull_closure" {
     Data.Bifoldable.binull_closure:
         const Data.Bifoldable.binull_info;
 },
 Data.Bifoldable.binull_entry() //  [R2]
         { info_tbl: [(cdNPY,
                       label: Data.Bifoldable.binull_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNPY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdNPZ; else goto cdNQ0;
       cdNPZ: // global
           R2 = R2;
           R1 = Data.Bifoldable.binull_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNQ0: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Bifoldable.binull1_closure+2;
           P64[Sp - 16] = Data.Bifoldable.binull1_closure+2;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldr_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.985715258 UTC

[section ""data" . Data.Bifoldable.biconcat_closure" {
     Data.Bifoldable.biconcat_closure:
         const Data.Bifoldable.biconcat_info;
         const 0;
 },
 Data.Bifoldable.biconcat_entry() //  [R2]
         { info_tbl: [(cdNQf,
                       label: Data.Bifoldable.biconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNQf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNQg; else goto cdNQh;
       cdNQg: // global
           R2 = R2;
           R1 = Data.Bifoldable.biconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNQh: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.$fMonoid[]_closure;
           Sp = Sp - 16;
           call Data.Bifoldable.bifold_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.990326027 UTC

[section ""data" . lvl16_rdL8I_closure" {
     lvl16_rdL8I_closure:
         const GHC.Types.I#_con_info;
         const 334;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.992264219 UTC

[section ""data" . lvl17_rdL8J_closure" {
     lvl17_rdL8J_closure:
         const GHC.Types.I#_con_info;
         const 24;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.994083342 UTC

[section ""data" . lvl18_rdL8K_closure" {
     lvl18_rdL8K_closure:
         const GHC.Types.I#_con_info;
         const 58;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.995998423 UTC

[section ""data" . lvl19_rdL8L_closure" {
     lvl19_rdL8L_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl16_rdL8I_closure+1;
         const lvl17_rdL8J_closure+1;
         const lvl16_rdL8I_closure+1;
         const lvl18_rdL8K_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:02.998179945 UTC

[section ""data" . lvl20_rdL8M_closure" {
     lvl20_rdL8M_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl19_rdL8L_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.00019159 UTC

[section ""cstring" . lvl21_rdL8N_bytes" {
     lvl21_rdL8N_bytes:
         I8[] [98,105,109,97,120,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.003449238 UTC

[section ""data" . Data.Bifoldable.bimaximum1_closure" {
     Data.Bifoldable.bimaximum1_closure:
         const Data.Bifoldable.bimaximum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.bimaximum1_entry() //  [R1]
         { info_tbl: [(cdNQD,
                       label: Data.Bifoldable.bimaximum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNQD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdNQE; else goto cdNQF;
       cdNQE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNQF: // global
           (_cdNQy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdNQy::I64 == 0) goto cdNQA; else goto cdNQz;
       cdNQA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdNQz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdNQy::I64;
           I64[Sp - 24] = block_cdNQB_info;
           R2 = lvl21_rdL8N_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdNQB() //  [R1]
         { info_tbl: [(cdNQB,
                       label: block_cdNQB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNQB: // global
           R3 = R1;
           R2 = lvl20_rdL8M_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.010847426 UTC

[section ""data" . Data.Bifoldable.bimaximum_closure" {
     Data.Bifoldable.bimaximum_closure:
         const Data.Bifoldable.bimaximum_info;
         const 0;
 },
 sat_sdNbV_entry() //  [R1]
         { info_tbl: [(cdNR7,
                       label: sat_sdNbV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNR7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNR8; else goto cdNR9;
       cdNR8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNR9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMax_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdNbU_entry() //  [R1]
         { info_tbl: [(cdNRa,
                       label: g_sdNbU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNRa: // global
           _sdNbU::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdNRb; else goto cdNRc;
       cdNRc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNRe; else goto cdNRd;
       cdNRe: // global
           HpAlloc = 24;
           goto cdNRb;
       cdNRb: // global
           R1 = _sdNbU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNRd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdNbU::P64;
           _sdNbS::P64 = P64[_sdNbU::P64 + 16];
           _sdNbT::P64 = P64[_sdNbU::P64 + 24];
           I64[Hp - 16] = sat_sdNbV_info;
           P64[Hp] = _sdNbT::P64;
           R2 = _sdNbS::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = GHC.Base.Just_closure+1;
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdNbZ_entry() //  [R1, R2]
         { info_tbl: [(cdNRq,
                       label: sat_sdNbZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNRq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdNRr; else goto cdNRs;
       cdNRr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNRs: // global
           I64[Sp - 8] = block_cdNRk_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNRk() //  [R1]
         { info_tbl: [(cdNRk,
                       label: block_cdNRk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNRk: // global
           if (R1 & 7 == 1) goto cdNRn; else goto cdNRo;
       cdNRn: // global
           R1 = Data.Bifoldable.bimaximum1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdNRo: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bimaximum_entry() //  [R2, R3]
         { info_tbl: [(cdNRz,
                       label: Data.Bifoldable.bimaximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNRz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNRD; else goto cdNRC;
       cdNRD: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bimaximum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNRC: // global
           I64[Hp - 40] = g_sdNbU_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdNbZ_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.024159305 UTC

[section ""data" . lvl22_rdL8O_closure" {
     lvl22_rdL8O_closure:
         const GHC.Types.I#_con_info;
         const 342;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.026054565 UTC

[section ""data" . lvl23_rdL8P_closure" {
     lvl23_rdL8P_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_rdL8u_closure;
         const lvl3_rdL8v_closure;
         const lvl5_rdL8x_closure;
         const lvl22_rdL8O_closure+1;
         const lvl17_rdL8J_closure+1;
         const lvl22_rdL8O_closure+1;
         const lvl18_rdL8K_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.028113376 UTC

[section ""data" . lvl24_rdL8Q_closure" {
     lvl24_rdL8Q_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_rdL8t_closure;
         const lvl23_rdL8P_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.030677531 UTC

[section ""cstring" . lvl25_rdL8R_bytes" {
     lvl25_rdL8R_bytes:
         I8[] [98,105,109,105,110,105,109,117,109,58,32,101,109,112,116,121,32,115,116,114,117,99,116,117,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.033230583 UTC

[section ""data" . Data.Bifoldable.biminimum1_closure" {
     Data.Bifoldable.biminimum1_closure:
         const Data.Bifoldable.biminimum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bifoldable.biminimum1_entry() //  [R1]
         { info_tbl: [(cdNSp,
                       label: Data.Bifoldable.biminimum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNSp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdNSq; else goto cdNSr;
       cdNSq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNSr: // global
           (_cdNSk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdNSk::I64 == 0) goto cdNSm; else goto cdNSl;
       cdNSm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdNSl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdNSk::I64;
           I64[Sp - 24] = block_cdNSn_info;
           R2 = lvl25_rdL8R_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdNSn() //  [R1]
         { info_tbl: [(cdNSn,
                       label: block_cdNSn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNSn: // global
           R3 = R1;
           R2 = lvl24_rdL8Q_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.042093675 UTC

[section ""data" . Data.Bifoldable.biminimum_closure" {
     Data.Bifoldable.biminimum_closure:
         const Data.Bifoldable.biminimum_info;
         const 0;
 },
 sat_sdNc4_entry() //  [R1]
         { info_tbl: [(cdNST,
                       label: sat_sdNc4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNST: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNSU; else goto cdNSV;
       cdNSU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNSV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Utils.$fMonoidMin_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 g_sdNc3_entry() //  [R1]
         { info_tbl: [(cdNSW,
                       label: g_sdNc3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNSW: // global
           _sdNc3::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdNSX; else goto cdNSY;
       cdNSY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNT0; else goto cdNSZ;
       cdNT0: // global
           HpAlloc = 24;
           goto cdNSX;
       cdNSX: // global
           R1 = _sdNc3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNSZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdNc3::P64;
           _sdNc1::P64 = P64[_sdNc3::P64 + 16];
           _sdNc2::P64 = P64[_sdNc3::P64 + 24];
           I64[Hp - 16] = sat_sdNc4_info;
           P64[Hp] = _sdNc2::P64;
           R2 = _sdNc1::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Hp - 16;
           P64[Sp - 32] = GHC.Base.Just_closure+1;
           P64[Sp - 24] = GHC.Base.Just_closure+1;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdNc8_entry() //  [R1, R2]
         { info_tbl: [(cdNTc,
                       label: sat_sdNc8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNTc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdNTd; else goto cdNTe;
       cdNTd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNTe: // global
           I64[Sp - 8] = block_cdNT6_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNT6() //  [R1]
         { info_tbl: [(cdNT6,
                       label: block_cdNT6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNT6: // global
           if (R1 & 7 == 1) goto cdNT9; else goto cdNTa;
       cdNT9: // global
           R1 = Data.Bifoldable.biminimum1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdNTa: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biminimum_entry() //  [R2, R3]
         { info_tbl: [(cdNTl,
                       label: Data.Bifoldable.biminimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNTl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNTp; else goto cdNTo;
       cdNTp: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.biminimum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNTo: // global
           I64[Hp - 40] = g_sdNc3_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdNc8_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.055750632 UTC

[section ""data" . Data.Bifoldable.biproduct2_closure" {
     Data.Bifoldable.biproduct2_closure:
         const Data.Bifoldable.biproduct2_info;
 },
 Data.Bifoldable.biproduct2_entry() //  [R2]
         { info_tbl: [(cdNU3,
                       label: Data.Bifoldable.biproduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNU3: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.060011113 UTC

[section ""data" . Data.Bifoldable.bisum1_closure" {
     Data.Bifoldable.bisum1_closure:
         const Data.Bifoldable.bisum1_info;
         const 0;
 },
 sat_sdNcc_entry() //  [R1]
         { info_tbl: [(cdNUi,
                       label: sat_sdNcc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNUi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNUj; else goto cdNUk;
       cdNUj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNUk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.bisum1_entry() //  [R2, R3]
         { info_tbl: [(cdNUl,
                       label: Data.Bifoldable.bisum1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNUl: // global
           _sdNcb::P64 = R3;
           _sdNca::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdNUm; else goto cdNUn;
       cdNUn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNUp; else goto cdNUo;
       cdNUp: // global
           HpAlloc = 24;
           goto cdNUm;
       cdNUm: // global
           R3 = _sdNcb::P64;
           R2 = _sdNca::P64;
           R1 = Data.Bifoldable.bisum1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNUo: // global
           I64[Hp - 16] = sat_sdNcc_info;
           P64[Hp] = _sdNcb::P64;
           R2 = _sdNca::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Data.Bifoldable.biproduct2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biproduct2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.067309087 UTC

[section ""data" . Data.Bifoldable.bisum_closure" {
     Data.Bifoldable.bisum_closure:
         const Data.Bifoldable.bisum_info;
         const 0;
 },
 Data.Bifoldable.bisum_entry() //  [R2, R3]
         { info_tbl: [(cdNUJ,
                       label: Data.Bifoldable.bisum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNUJ: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bisum1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.071930797 UTC

[section ""data" . Data.Bifoldable.biproduct1_closure" {
     Data.Bifoldable.biproduct1_closure:
         const Data.Bifoldable.biproduct1_info;
         const 0;
 },
 sat_sdNcf_entry() //  [R1]
         { info_tbl: [(cdNUY,
                       label: sat_sdNcf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNUY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNUZ; else goto cdNV0;
       cdNUZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNV0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bifoldable.biproduct1_entry() //  [R2, R3]
         { info_tbl: [(cdNV1,
                       label: Data.Bifoldable.biproduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNV1: // global
           _sdNce::P64 = R3;
           _sdNcd::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdNV2; else goto cdNV3;
       cdNV3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdNV5; else goto cdNV4;
       cdNV5: // global
           HpAlloc = 24;
           goto cdNV2;
       cdNV2: // global
           R3 = _sdNce::P64;
           R2 = _sdNcd::P64;
           R1 = Data.Bifoldable.biproduct1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNV4: // global
           I64[Hp - 16] = sat_sdNcf_info;
           P64[Hp] = _sdNce::P64;
           R2 = _sdNcd::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 16;
           P64[Sp - 16] = Data.Bifoldable.biproduct2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biproduct2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.081172162 UTC

[section ""data" . Data.Bifoldable.biproduct_closure" {
     Data.Bifoldable.biproduct_closure:
         const Data.Bifoldable.biproduct_info;
         const 0;
 },
 Data.Bifoldable.biproduct_entry() //  [R2, R3]
         { info_tbl: [(cdNVp,
                       label: Data.Bifoldable.biproduct_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNVp: // global
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biproduct1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.085127934 UTC

[section ""data" . Data.Bifoldable.biconcatMap_closure" {
     Data.Bifoldable.biconcatMap_closure:
         const Data.Bifoldable.biconcatMap_info;
         const 0;
 },
 Data.Bifoldable.biconcatMap_entry() //  [R2]
         { info_tbl: [(cdNVA,
                       label: Data.Bifoldable.biconcatMap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNVA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNVB; else goto cdNVC;
       cdNVB: // global
           R2 = R2;
           R1 = Data.Bifoldable.biconcatMap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNVC: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.$fMonoid[]_closure;
           Sp = Sp - 16;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.089823491 UTC

[section ""data" . Data.Bifoldable.biand2_closure" {
     Data.Bifoldable.biand2_closure:
         const Data.Bifoldable.biand2_info;
 },
 Data.Bifoldable.biand2_entry() //  [R2]
         { info_tbl: [(cdNVO,
                       label: Data.Bifoldable.biand2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNVO: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.093950452 UTC

[section ""data" . Data.Bifoldable.biand1_closure" {
     Data.Bifoldable.biand1_closure:
         const Data.Bifoldable.biand1_info;
         const 0;
 },
 Data.Bifoldable.biand1_entry() //  [R2]
         { info_tbl: [(cdNW1,
                       label: Data.Bifoldable.biand1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNW1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdNW2; else goto cdNW3;
       cdNW2: // global
           R2 = R2;
           R1 = Data.Bifoldable.biand1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNW3: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAll_closure;
           P64[Sp - 16] = Data.Bifoldable.biand2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biand2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.098871906 UTC

[section ""data" . Data.Bifoldable.biand_closure" {
     Data.Bifoldable.biand_closure:
         const Data.Bifoldable.biand_info;
         const 0;
 },
 Data.Bifoldable.biand_entry() //  [R2]
         { info_tbl: [(cdNWh,
                       label: Data.Bifoldable.biand_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNWh: // global
           R2 = R2;
           call Data.Bifoldable.biand1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.103507679 UTC

[section ""data" . Data.Bifoldable.bior1_closure" {
     Data.Bifoldable.bior1_closure:
         const Data.Bifoldable.bior1_info;
         const 0;
 },
 Data.Bifoldable.bior1_entry() //  [R2]
         { info_tbl: [(cdNWs,
                       label: Data.Bifoldable.bior1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNWs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdNWt; else goto cdNWu;
       cdNWt: // global
           R2 = R2;
           R1 = Data.Bifoldable.bior1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNWu: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Data.Bifoldable.biand2_closure+1;
           P64[Sp - 8] = Data.Bifoldable.biand2_closure+1;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.108609216 UTC

[section ""data" . Data.Bifoldable.bior_closure" {
     Data.Bifoldable.bior_closure:
         const Data.Bifoldable.bior_info;
         const 0;
 },
 Data.Bifoldable.bior_entry() //  [R2]
         { info_tbl: [(cdNWI,
                       label: Data.Bifoldable.bior_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNWI: // global
           R2 = R2;
           call Data.Bifoldable.bior1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.113332769 UTC

[section ""data" . Data.Bifoldable.biany1_closure" {
     Data.Bifoldable.biany1_closure:
         const Data.Bifoldable.biany1_info;
         const 0;
 },
 sat_sdNcq_entry() //  [R1, R2]
         { info_tbl: [(cdNWY,
                       label: sat_sdNcq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNWY: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdNco_entry() //  [R1, R2]
         { info_tbl: [(cdNX6,
                       label: sat_sdNco_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNX6: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biany1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNX9,
                       label: Data.Bifoldable.biany1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNX9: // global
           _sdNcm::P64 = R4;
           _sdNcl::P64 = R3;
           _sdNck::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdNXa; else goto cdNXb;
       cdNXb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdNXd; else goto cdNXc;
       cdNXd: // global
           HpAlloc = 32;
           goto cdNXa;
       cdNXa: // global
           R4 = _sdNcm::P64;
           R3 = _sdNcl::P64;
           R2 = _sdNck::P64;
           R1 = Data.Bifoldable.biany1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNXc: // global
           I64[Hp - 24] = sat_sdNcq_info;
           P64[Hp - 16] = _sdNcm::P64;
           I64[Hp - 8] = sat_sdNco_info;
           P64[Hp] = _sdNcl::P64;
           R2 = _sdNck::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.124051407 UTC

[section ""data" . Data.Bifoldable.biany_closure" {
     Data.Bifoldable.biany_closure:
         const Data.Bifoldable.biany_info;
         const 0;
 },
 Data.Bifoldable.biany_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNXz,
                       label: Data.Bifoldable.biany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNXz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biany1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.128403462 UTC

[section ""data" . Data.Bifoldable.bielem1_closure" {
     Data.Bifoldable.bielem1_closure:
         const Data.Bifoldable.bielem1_info;
         const 0;
 },
 sat_sdNcx_entry() //  [R1, R2]
         { info_tbl: [(cdNXP,
                       label: sat_sdNcx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNXP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdNXQ; else goto cdNXR;
       cdNXQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNXR: // global
           _sdNcw::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sdNcw::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdNcv_entry() //  [R1, R2]
         { info_tbl: [(cdNXX,
                       label: sat_sdNcv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNXX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdNXY; else goto cdNXZ;
       cdNXY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNXZ: // global
           _sdNcu::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sdNcu::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bielem1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNY0,
                       label: Data.Bifoldable.bielem1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNY0: // global
           _sdNct::P64 = R4;
           _sdNcs::P64 = R3;
           _sdNcr::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdNY1; else goto cdNY2;
       cdNY2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNY4; else goto cdNY3;
       cdNY4: // global
           HpAlloc = 48;
           goto cdNY1;
       cdNY1: // global
           R4 = _sdNct::P64;
           R3 = _sdNcs::P64;
           R2 = _sdNcr::P64;
           R1 = Data.Bifoldable.bielem1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNY3: // global
           I64[Hp - 40] = sat_sdNcx_info;
           P64[Hp - 32] = _sdNcs::P64;
           P64[Hp - 24] = _sdNct::P64;
           I64[Hp - 16] = sat_sdNcv_info;
           P64[Hp - 8] = _sdNcs::P64;
           P64[Hp] = _sdNct::P64;
           R2 = _sdNcr::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAny_closure;
           P64[Sp - 16] = Hp - 15;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.138165521 UTC

[section ""data" . Data.Bifoldable.bielem_closure" {
     Data.Bifoldable.bielem_closure:
         const Data.Bifoldable.bielem_info;
         const 0;
 },
 Data.Bifoldable.bielem_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNYw,
                       label: Data.Bifoldable.bielem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNYw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.bielem1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.143259122 UTC

[section ""data" . Data.Bifoldable.binotElem_closure" {
     Data.Bifoldable.binotElem_closure:
         const Data.Bifoldable.binotElem_info;
         const 0;
 },
 g_sdNcB_entry() //  [R1]
         { info_tbl: [(cdNYL,
                       label: g_sdNcB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNYL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdNYM; else goto cdNYN;
       cdNYM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdNYN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bifoldable.bielem1_entry(R4,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdNcE_entry() //  [R1, R2]
         { info_tbl: [(cdNYZ,
                       label: sat_sdNcE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNYZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdNZ0; else goto cdNZ1;
       cdNZ0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNZ1: // global
           I64[Sp - 8] = block_cdNYT_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdNYT() //  [R1]
         { info_tbl: [(cdNYT,
                       label: block_cdNYT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNYT: // global
           if (R1 & 7 == 1) goto cdNYW; else goto cdNYX;
       cdNYW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdNYX: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.binotElem_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNZ8,
                       label: Data.Bifoldable.binotElem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNZ8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdNZc; else goto cdNZb;
       cdNZc: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.binotElem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdNZb: // global
           I64[Hp - 48] = g_sdNcB_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           I64[Hp - 8] = sat_sdNcE_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.155899234 UTC

[section ""data" . Data.Bifoldable.biall1_closure" {
     Data.Bifoldable.biall1_closure:
         const Data.Bifoldable.biall1_info;
         const 0;
 },
 sat_sdNcL_entry() //  [R1, R2]
         { info_tbl: [(cdNZN,
                       label: sat_sdNcL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNZN: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdNcJ_entry() //  [R1, R2]
         { info_tbl: [(cdNZV,
                       label: sat_sdNcJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNZV: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.biall1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdNZY,
                       label: Data.Bifoldable.biall1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNZY: // global
           _sdNcH::P64 = R4;
           _sdNcG::P64 = R3;
           _sdNcF::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdNZZ; else goto cdO00;
       cdO00: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdO02; else goto cdO01;
       cdO02: // global
           HpAlloc = 32;
           goto cdNZZ;
       cdNZZ: // global
           R4 = _sdNcH::P64;
           R3 = _sdNcG::P64;
           R2 = _sdNcF::P64;
           R1 = Data.Bifoldable.biall1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdO01: // global
           I64[Hp - 24] = sat_sdNcL_info;
           P64[Hp - 16] = _sdNcH::P64;
           I64[Hp - 8] = sat_sdNcJ_info;
           P64[Hp] = _sdNcG::P64;
           R2 = _sdNcF::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidAll_closure;
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 32;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.164337947 UTC

[section ""data" . Data.Bifoldable.biall_closure" {
     Data.Bifoldable.biall_closure:
         const Data.Bifoldable.biall_info;
         const 0;
 },
 Data.Bifoldable.biall_entry() //  [R2, R3, R4]
         { info_tbl: [(cdO0o,
                       label: Data.Bifoldable.biall_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdO0o: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bifoldable.biall1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.168588941 UTC

[section ""data" . Data.Bifoldable.bifind_closure" {
     Data.Bifoldable.bifind_closure:
         const Data.Bifoldable.bifind_info;
         const 0;
 },
 finder_sdNcP_entry() //  [R1, R2]
         { info_tbl: [(cdO0O,
                       label: finder_sdNcP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdO0O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdO0P; else goto cdO0Q;
       cdO0P: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdO0Q: // global
           I64[Sp - 16] = block_cdO0I_info;
           _sdNcQ::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdNcQ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdO0I() //  [R1]
         { info_tbl: [(cdO0I,
                       label: block_cdO0I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdO0I: // global
           if (R1 & 7 == 1) goto cdO0L; else goto cdO0M;
       cdO0L: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdO0M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdO0Z; else goto cdO0Y;
       cdO0Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdO0Y: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 g_sdNcO_entry() //  [R1]
         { info_tbl: [(cdO10,
                       label: g_sdNcO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdO10: // global
           _sdNcO::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cdO11; else goto cdO12;
       cdO12: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdO14; else goto cdO13;
       cdO14: // global
           HpAlloc = 16;
           goto cdO11;
       cdO11: // global
           R1 = _sdNcO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdO13: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdNcO::P64;
           _sdNcM::P64 = P64[_sdNcO::P64 + 16];
           _sdNcN::P64 = P64[_sdNcO::P64 + 24];
           I64[Hp - 8] = finder_sdNcP_info;
           P64[Hp] = _sdNcN::P64;
           R2 = _sdNcM::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Monoid.$fMonoidFirst_closure;
           _cdO0D::P64 = Hp - 7;
           P64[Sp - 32] = _cdO0D::P64;
           P64[Sp - 24] = _cdO0D::P64;
           Sp = Sp - 48;
           call Data.Bifoldable.bifoldMap_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sdNcT_entry() //  [R1, R2]
         { info_tbl: [(cdO1a,
                       label: sat_sdNcT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdO1a: // global
           R2 = R2;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bifoldable.bifind_entry() //  [R2, R3]
         { info_tbl: [(cdO1d,
                       label: Data.Bifoldable.bifind_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdO1d: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdO1h; else goto cdO1g;
       cdO1h: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.bifind_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdO1g: // global
           I64[Hp - 40] = g_sdNcO_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sdNcT_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.18059478 UTC

[section ""data" . Data.Bifoldable.$trModule3_closure" {
     Data.Bifoldable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.182422821 UTC

[section ""data" . Data.Bifoldable.$trModule1_closure" {
     Data.Bifoldable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.184293242 UTC

[section ""data" . Data.Bifoldable.$trModule_closure" {
     Data.Bifoldable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bifoldable.$trModule3_closure+1;
         const Data.Bifoldable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.186542705 UTC

[section ""data" . $krep_rdL8S_closure" {
     $krep_rdL8S_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.189002376 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable1_closure" {
     Data.Bifoldable.$tcBifoldable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdL8S_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.190709357 UTC

[section ""cstring" . Data.Bifoldable.$tcBifoldable3_bytes" {
     Data.Bifoldable.$tcBifoldable3_bytes:
         I8[] [66,105,102,111,108,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.192373644 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable2_closure" {
     Data.Bifoldable.$tcBifoldable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bifoldable.$tcBifoldable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.194144498 UTC

[section ""data" . Data.Bifoldable.$tcBifoldable_closure" {
     Data.Bifoldable.$tcBifoldable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bifoldable.$trModule_closure+1;
         const Data.Bifoldable.$tcBifoldable2_closure+1;
         const Data.Bifoldable.$tcBifoldable1_closure+4;
         const 13881323671910883383;
         const 7079945659398195047;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.196447244 UTC

[section ""data" . Data.Bifoldable.C:Bifoldable_closure" {
     Data.Bifoldable.C:Bifoldable_closure:
         const Data.Bifoldable.C:Bifoldable_info;
 },
 Data.Bifoldable.C:Bifoldable_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdO23,
                       label: Data.Bifoldable.C:Bifoldable_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdO23: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdO27; else goto cdO26;
       cdO27: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bifoldable.C:Bifoldable_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdO26: // global
           I64[Hp - 32] = Data.Bifoldable.C:Bifoldable_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.200470724 UTC

[Data.Bifoldable.C:Bifoldable_con_entry() //  [R1]
         { info_tbl: [(cdO2e,
                       label: Data.Bifoldable.C:Bifoldable_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,102,111,108,100,97,98,108,101,46,67,58,66,105,102,111,108,100,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdO2e: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.203831868 UTC

[section ""relreadonly" . SdNkq_srt" {
     SdNkq_srt:
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Bifoldable.$dmbifoldl_closure;
         const poly_$dMonoid_rdL8r_closure;
         const Data.Bifoldable.$dmbifoldr_closure;
         const GHC.Err.error_closure;
         const lvl10_rdL8C_closure;
         const Data.Bifoldable.bifoldr1_closure;
         const Data.Bifoldable.bifoldr2_closure;
         const Data.Bifoldable.bimaximumBy_closure;
         const Data.Bifoldable.biminimumBy_closure;
         const lvl14_rdL8G_closure;
         const Data.Bifoldable.bifoldl1_closure;
         const Data.Bifoldable.bifoldl2_closure;
         const GHC.Base.$fMonoid[]_closure;
         const Data.Bifoldable.biconcat_closure;
         const lvl20_rdL8M_closure;
         const Data.Functor.Utils.$fMonoidMax_closure;
         const Data.Bifoldable.bimaximum1_closure;
         const Data.Bifoldable.bimaximum_closure;
         const lvl24_rdL8Q_closure;
         const Data.Functor.Utils.$fMonoidMin_closure;
         const Data.Bifoldable.biminimum1_closure;
         const Data.Bifoldable.biminimum_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const Data.Bifoldable.bisum1_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Bifoldable.biproduct1_closure;
         const Data.Bifoldable.biconcatMap_closure;
         const Data.Semigroup.Internal.$fMonoidAll_closure;
         const Data.Bifoldable.biand1_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Bifoldable.bior1_closure;
         const Data.Bifoldable.biany1_closure;
         const Data.Bifoldable.bielem1_closure;
         const Data.Bifoldable.binotElem_closure;
         const Data.Bifoldable.biall1_closure;
         const Data.Monoid.$fMonoidFirst_closure;
         const Data.Bifoldable.bifind_closure;
 }]

