
==================== Tidy Core ====================
2018-03-16 16:09:03.316127078 UTC

Result size of Tidy Core
  = {terms: 545, types: 2,052, coercions: 151, joins: 0/2}

-- RHS size: {terms: 6, types: 41, coercions: 0, joins: 0/0}
Data.Bitraversable.$p1Bitraversable
  :: forall (t :: * -> * -> *). Bitraversable t => Bifunctor t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLL),U(U,A,A)>,
 RULES: Built in rule for Data.Bitraversable.$p1Bitraversable: "Class op $p1Bitraversable"]
Data.Bitraversable.$p1Bitraversable
  = \ (@ (t_adO2x :: * -> * -> *)) (v_B1 :: Bitraversable t_adO2x) ->
      case v_B1 of v_B1
      { Data.Bitraversable.C:Bitraversable v_B2 v_B3 v_B4 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 41, coercions: 0, joins: 0/0}
Data.Bitraversable.$p2Bitraversable
  :: forall (t :: * -> * -> *). Bitraversable t => Bifoldable t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSL),U(A,U,A)>,
 RULES: Built in rule for Data.Bitraversable.$p2Bitraversable: "Class op $p2Bitraversable"]
Data.Bitraversable.$p2Bitraversable
  = \ (@ (t_adO2x :: * -> * -> *)) (v_B1 :: Bitraversable t_adO2x) ->
      case v_B1 of v_B1
      { Data.Bitraversable.C:Bitraversable v_B2 v_B3 v_B4 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 41, coercions: 0, joins: 0/0}
bitraverse
  :: forall (t :: * -> * -> *).
     Bitraversable t =>
     forall (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLS),U(A,A,U)>,
 RULES: Built in rule for bitraverse: "Class op bitraverse"]
bitraverse
  = \ (@ (t_adO2x :: * -> * -> *)) (v_B1 :: Bitraversable t_adO2x) ->
      case v_B1 of v_B1
      { Data.Bitraversable.C:Bitraversable v_B2 v_B3 v_B4 ->
      v_B4
      }

-- RHS size: {terms: 22, types: 41, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,)_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> (a, b) -> f (c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adOkV :: * -> *))
                 (@ a_adOkW)
                 (@ c_adOkX)
                 (@ b_adOkY)
                 (@ d_adOkZ)
                 ($dApplicative_adOl1 [Occ=Once] :: Applicative f_adOkV)
                 (f1_adO3C [Occ=Once!] :: a_adOkW -> f_adOkV c_adOkX)
                 (g_adO3D [Occ=Once!] :: b_adOkY -> f_adOkV d_adOkZ)
                 (ds_ddOqR :: (a_adOkW, b_adOkY)) ->
                 liftA2
                   @ f_adOkV
                   $dApplicative_adOl1
                   @ c_adOkX
                   @ d_adOkZ
                   @ (c_adOkX, d_adOkZ)
                   (GHC.Tuple.(,) @ c_adOkX @ d_adOkZ)
                   (f1_adO3C
                      (case ds_ddOqR of { (a1_adO3E [Occ=Once], _ [Occ=Dead]) ->
                       a1_adO3E
                       }))
                   (g_adO3D
                      (case ds_ddOqR of { (_ [Occ=Dead], b1_adO3F [Occ=Once]) ->
                       b1_adO3F
                       }))}]
Data.Bitraversable.$fBitraversable(,)_$cbitraverse
  = \ (@ (f_adOkV :: * -> *))
      (@ a_adOkW)
      (@ c_adOkX)
      (@ b_adOkY)
      (@ d_adOkZ)
      ($dApplicative_adOl1 :: Applicative f_adOkV)
      (f1_adO3C :: a_adOkW -> f_adOkV c_adOkX)
      (g_adO3D :: b_adOkY -> f_adOkV d_adOkZ)
      (ds_ddOqR :: (a_adOkW, b_adOkY)) ->
      liftA2
        @ f_adOkV
        $dApplicative_adOl1
        @ c_adOkX
        @ d_adOkZ
        @ (c_adOkX, d_adOkZ)
        (GHC.Tuple.(,) @ c_adOkX @ d_adOkZ)
        (f1_adO3C (case ds_ddOqR of { (a1_adO3E, b1_adO3F) -> a1_adO3E }))
        (g_adO3D (case ds_ddOqR of { (a1_adO3E, b1_adO3F) -> b1_adO3F }))

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Bitraversable (,)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bitraversable.C:Bitraversable TYPE: (,)
                                          Data.Bifunctor.$fBifunctor(,)
                                          Data.Bifoldable.$fBifoldable(,)
                                          Data.Bitraversable.$fBitraversable(,)_$cbitraverse]
Data.Bitraversable.$fBitraversable(,)
  = Data.Bitraversable.C:Bitraversable
      @ (,)
      Data.Bifunctor.$fBifunctor(,)
      Data.Bifoldable.$fBifoldable(,)
      Data.Bitraversable.$fBitraversable(,)_$cbitraverse

-- RHS size: {terms: 27, types: 57, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,,)_$cbitraverse
  :: forall x (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, a, b) -> f (x, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 60 60] 130 0}]
Data.Bitraversable.$fBitraversable(,,)_$cbitraverse
  = \ (@ x_adOkg)
      (@ (f_adOks :: * -> *))
      (@ a_adOkt)
      (@ c_adOku)
      (@ b_adOkv)
      (@ d_adOkw)
      ($dApplicative_adOky :: Applicative f_adOks)
      (f1_adO3x :: a_adOkt -> f_adOks c_adOku)
      (g_adO3y :: b_adOkv -> f_adOks d_adOkw)
      (ds_ddOqu :: (x_adOkg, a_adOkt, b_adOkv)) ->
      liftA2
        @ f_adOks
        $dApplicative_adOky
        @ c_adOku
        @ d_adOkw
        @ (x_adOkg, c_adOku, d_adOkw)
        (GHC.Tuple.(,,)
           @ x_adOkg
           @ c_adOku
           @ d_adOkw
           (case ds_ddOqu of { (x1_adO3z, a1_adO3A, b1_adO3B) -> x1_adO3z }))
        (f1_adO3x
           (case ds_ddOqu of { (x1_adO3z, a1_adO3A, b1_adO3B) -> a1_adO3A }))
        (g_adO3y
           (case ds_ddOqu of { (x1_adO3z, a1_adO3A, b1_adO3B) -> b1_adO3B }))

-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x. Bitraversable ((,,) x)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ x_adO3w) ->
       Data.Bitraversable.C:Bitraversable TYPE: (,,) x_adO3w
                                          Data.Bifunctor.$fBifunctor(,,) @ x_adO3w
                                          Data.Bifoldable.$fBifoldable(,,) @ x_adO3w
                                          Data.Bitraversable.$fBitraversable(,,)_$cbitraverse
                                            @ x_adO3w]
Data.Bitraversable.$fBitraversable(,,)
  = \ (@ x_adOkg) ->
      Data.Bitraversable.C:Bitraversable
        @ ((,,) x_adOkg)
        (Data.Bifunctor.$fBifunctor(,,) @ x_adOkg)
        (Data.Bifoldable.$fBifoldable(,,) @ x_adOkg)
        (Data.Bitraversable.$fBitraversable(,,)_$cbitraverse @ x_adOkg)

-- RHS size: {terms: 32, types: 77, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse
  :: forall x y (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, y, a, b) -> f (x, y, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 60 80] 140 0}]
Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse
  = \ (@ x_adOjK)
      (@ y_adOjL)
      (@ (f_adOjX :: * -> *))
      (@ a_adOjY)
      (@ c_adOjZ)
      (@ b_adOk0)
      (@ d_adOk1)
      ($dApplicative_adOk3 :: Applicative f_adOjX)
      (f1_adO3q :: a_adOjY -> f_adOjX c_adOjZ)
      (g_adO3r :: b_adOk0 -> f_adOjX d_adOk1)
      (ds_ddOpX :: (x_adOjK, y_adOjL, a_adOjY, b_adOk0)) ->
      liftA2
        @ f_adOjX
        $dApplicative_adOk3
        @ c_adOjZ
        @ d_adOk1
        @ (x_adOjK, y_adOjL, c_adOjZ, d_adOk1)
        (GHC.Tuple.(,,,)
           @ x_adOjK
           @ y_adOjL
           @ c_adOjZ
           @ d_adOk1
           (case ds_ddOpX of { (x1_adO3s, y1_adO3t, a1_adO3u, b1_adO3v) ->
            x1_adO3s
            })
           (case ds_ddOpX of { (x1_adO3s, y1_adO3t, a1_adO3u, b1_adO3v) ->
            y1_adO3t
            }))
        (f1_adO3q
           (case ds_ddOpX of { (x1_adO3s, y1_adO3t, a1_adO3u, b1_adO3v) ->
            a1_adO3u
            }))
        (g_adO3r
           (case ds_ddOpX of { (x1_adO3s, y1_adO3t, a1_adO3u, b1_adO3v) ->
            b1_adO3v
            }))

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y. Bitraversable ((,,,) x y)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ x_adO3o) (@ y_adO3p) ->
       Data.Bitraversable.C:Bitraversable TYPE: (,,,) x_adO3o y_adO3p
                                          Data.Bifunctor.$fBifunctor(,,,) @ x_adO3o @ y_adO3p
                                          Data.Bifoldable.$fBifoldable(,,,) @ x_adO3o @ y_adO3p
                                          Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse
                                            @ x_adO3o @ y_adO3p]
Data.Bitraversable.$fBitraversable(,,,)
  = \ (@ x_adOjK) (@ y_adOjL) ->
      Data.Bitraversable.C:Bitraversable
        @ ((,,,) x_adOjK y_adOjL)
        (Data.Bifunctor.$fBifunctor(,,,) @ x_adOjK @ y_adOjL)
        (Data.Bifoldable.$fBifoldable(,,,) @ x_adOjK @ y_adOjL)
        (Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse
           @ x_adOjK @ y_adOjL)

-- RHS size: {terms: 37, types: 101, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse
  :: forall x y z (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> (x, y, z, a, b) -> f (x, y, z, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 60 100] 150 0}]
Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse
  = \ (@ x_adOjc)
      (@ y_adOjd)
      (@ z_adOje)
      (@ (f_adOjq :: * -> *))
      (@ a_adOjr)
      (@ c_adOjs)
      (@ b_adOjt)
      (@ d_adOju)
      ($dApplicative_adOjw :: Applicative f_adOjq)
      (f1_adO3h :: a_adOjr -> f_adOjq c_adOjs)
      (g_adO3i :: b_adOjt -> f_adOjq d_adOju)
      (ds_ddOpe :: (x_adOjc, y_adOjd, z_adOje, a_adOjr, b_adOjt)) ->
      liftA2
        @ f_adOjq
        $dApplicative_adOjw
        @ c_adOjs
        @ d_adOju
        @ (x_adOjc, y_adOjd, z_adOje, c_adOjs, d_adOju)
        (GHC.Tuple.(,,,,)
           @ x_adOjc
           @ y_adOjd
           @ z_adOje
           @ c_adOjs
           @ d_adOju
           (case ds_ddOpe of
            { (x1_adO3j, y1_adO3k, z1_adO3l, a1_adO3m, b1_adO3n) ->
            x1_adO3j
            })
           (case ds_ddOpe of
            { (x1_adO3j, y1_adO3k, z1_adO3l, a1_adO3m, b1_adO3n) ->
            y1_adO3k
            })
           (case ds_ddOpe of
            { (x1_adO3j, y1_adO3k, z1_adO3l, a1_adO3m, b1_adO3n) ->
            z1_adO3l
            }))
        (f1_adO3h
           (case ds_ddOpe of
            { (x1_adO3j, y1_adO3k, z1_adO3l, a1_adO3m, b1_adO3n) ->
            a1_adO3m
            }))
        (g_adO3i
           (case ds_ddOpe of
            { (x1_adO3j, y1_adO3k, z1_adO3l, a1_adO3m, b1_adO3n) ->
            b1_adO3n
            }))

-- RHS size: {terms: 7, types: 19, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z. Bitraversable ((,,,,) x y z)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ x_adO3e) (@ y_adO3f) (@ z_adO3g) ->
       Data.Bitraversable.C:Bitraversable TYPE: (,,,,)
                                                  x_adO3e y_adO3f z_adO3g
                                          Data.Bifunctor.$fBifunctor(,,,,)
                                            @ x_adO3e @ y_adO3f @ z_adO3g
                                          Data.Bifoldable.$fBifoldable(,,,,)
                                            @ x_adO3e @ y_adO3f @ z_adO3g
                                          Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse
                                            @ x_adO3e @ y_adO3f @ z_adO3g]
Data.Bitraversable.$fBitraversable(,,,,)
  = \ (@ x_adOjc) (@ y_adOjd) (@ z_adOje) ->
      Data.Bitraversable.C:Bitraversable
        @ ((,,,,) x_adOjc y_adOjd z_adOje)
        (Data.Bifunctor.$fBifunctor(,,,,) @ x_adOjc @ y_adOjd @ z_adOje)
        (Data.Bifoldable.$fBifoldable(,,,,) @ x_adOjc @ y_adOjd @ z_adOje)
        (Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse
           @ x_adOjc @ y_adOjd @ z_adOje)

-- RHS size: {terms: 42, types: 129, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse
  :: forall x y z w (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c)
     -> (b -> f d) -> (x, y, z, w, a, b) -> f (x, y, z, w, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 60 120] 160 0}]
Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse
  = \ (@ x_adOiC)
      (@ y_adOiD)
      (@ z_adOiE)
      (@ w_adOiF)
      (@ (f_adOiR :: * -> *))
      (@ a_adOiS)
      (@ c_adOiT)
      (@ b_adOiU)
      (@ d_adOiV)
      ($dApplicative_adOiX :: Applicative f_adOiR)
      (f1_adO36 :: a_adOiS -> f_adOiR c_adOiT)
      (g_adO37 :: b_adOiU -> f_adOiR d_adOiV)
      (ds_ddOoh
         :: (x_adOiC, y_adOiD, z_adOiE, w_adOiF, a_adOiS, b_adOiU)) ->
      liftA2
        @ f_adOiR
        $dApplicative_adOiX
        @ c_adOiT
        @ d_adOiV
        @ (x_adOiC, y_adOiD, z_adOiE, w_adOiF, c_adOiT, d_adOiV)
        (GHC.Tuple.(,,,,,)
           @ x_adOiC
           @ y_adOiD
           @ z_adOiE
           @ w_adOiF
           @ c_adOiT
           @ d_adOiV
           (case ds_ddOoh of
            { (x1_adO38, y1_adO39, z1_adO3a, w1_adO3b, a1_adO3c, b1_adO3d) ->
            x1_adO38
            })
           (case ds_ddOoh of
            { (x1_adO38, y1_adO39, z1_adO3a, w1_adO3b, a1_adO3c, b1_adO3d) ->
            y1_adO39
            })
           (case ds_ddOoh of
            { (x1_adO38, y1_adO39, z1_adO3a, w1_adO3b, a1_adO3c, b1_adO3d) ->
            z1_adO3a
            })
           (case ds_ddOoh of
            { (x1_adO38, y1_adO39, z1_adO3a, w1_adO3b, a1_adO3c, b1_adO3d) ->
            w1_adO3b
            }))
        (f1_adO36
           (case ds_ddOoh of
            { (x1_adO38, y1_adO39, z1_adO3a, w1_adO3b, a1_adO3c, b1_adO3d) ->
            a1_adO3c
            }))
        (g_adO37
           (case ds_ddOoh of
            { (x1_adO38, y1_adO39, z1_adO3a, w1_adO3b, a1_adO3c, b1_adO3d) ->
            b1_adO3d
            }))

-- RHS size: {terms: 8, types: 25, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w. Bitraversable ((,,,,,) x y z w)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ x_adO32) (@ y_adO33) (@ z_adO34) (@ w_adO35) ->
       Data.Bitraversable.C:Bitraversable TYPE: (,,,,,)
                                                  x_adO32 y_adO33 z_adO34 w_adO35
                                          Data.Bifunctor.$fBifunctor(,,,,,)
                                            @ x_adO32 @ y_adO33 @ z_adO34 @ w_adO35
                                          Data.Bifoldable.$fBifoldable(,,,,,)
                                            @ x_adO32 @ y_adO33 @ z_adO34 @ w_adO35
                                          Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse
                                            @ x_adO32 @ y_adO33 @ z_adO34 @ w_adO35]
Data.Bitraversable.$fBitraversable(,,,,,)
  = \ (@ x_adOiC) (@ y_adOiD) (@ z_adOiE) (@ w_adOiF) ->
      Data.Bitraversable.C:Bitraversable
        @ ((,,,,,) x_adOiC y_adOiD z_adOiE w_adOiF)
        (Data.Bifunctor.$fBifunctor(,,,,,)
           @ x_adOiC @ y_adOiD @ z_adOiE @ w_adOiF)
        (Data.Bifoldable.$fBifoldable(,,,,,)
           @ x_adOiC @ y_adOiD @ z_adOiE @ w_adOiF)
        (Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse
           @ x_adOiC @ y_adOiD @ z_adOiE @ w_adOiF)

-- RHS size: {terms: 47, types: 161, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse
  :: forall x y z w v (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c)
     -> (b -> f d) -> (x, y, z, w, v, a, b) -> f (x, y, z, w, v, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 60 140] 170 0}]
Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse
  = \ (@ x_adOi0)
      (@ y_adOi1)
      (@ z_adOi2)
      (@ w_adOi3)
      (@ v_adOi4)
      (@ (f_adOig :: * -> *))
      (@ a_adOih)
      (@ c_adOii)
      (@ b_adOij)
      (@ d_adOik)
      ($dApplicative_adOim :: Applicative f_adOig)
      (f1_adO2T :: a_adOih -> f_adOig c_adOii)
      (g_adO2U :: b_adOij -> f_adOig d_adOik)
      (ds_ddOn4
         :: (x_adOi0, y_adOi1, z_adOi2, w_adOi3, v_adOi4, a_adOih,
             b_adOij)) ->
      liftA2
        @ f_adOig
        $dApplicative_adOim
        @ c_adOii
        @ d_adOik
        @ (x_adOi0, y_adOi1, z_adOi2, w_adOi3, v_adOi4, c_adOii, d_adOik)
        (GHC.Tuple.(,,,,,,)
           @ x_adOi0
           @ y_adOi1
           @ z_adOi2
           @ w_adOi3
           @ v_adOi4
           @ c_adOii
           @ d_adOik
           (case ds_ddOn4 of
            { (x1_adO2V, y1_adO2W, z1_adO2X, w1_adO2Y, v1_adO2Z, a1_adO30,
               b1_adO31) ->
            x1_adO2V
            })
           (case ds_ddOn4 of
            { (x1_adO2V, y1_adO2W, z1_adO2X, w1_adO2Y, v1_adO2Z, a1_adO30,
               b1_adO31) ->
            y1_adO2W
            })
           (case ds_ddOn4 of
            { (x1_adO2V, y1_adO2W, z1_adO2X, w1_adO2Y, v1_adO2Z, a1_adO30,
               b1_adO31) ->
            z1_adO2X
            })
           (case ds_ddOn4 of
            { (x1_adO2V, y1_adO2W, z1_adO2X, w1_adO2Y, v1_adO2Z, a1_adO30,
               b1_adO31) ->
            w1_adO2Y
            })
           (case ds_ddOn4 of
            { (x1_adO2V, y1_adO2W, z1_adO2X, w1_adO2Y, v1_adO2Z, a1_adO30,
               b1_adO31) ->
            v1_adO2Z
            }))
        (f1_adO2T
           (case ds_ddOn4 of
            { (x1_adO2V, y1_adO2W, z1_adO2X, w1_adO2Y, v1_adO2Z, a1_adO30,
               b1_adO31) ->
            a1_adO30
            }))
        (g_adO2U
           (case ds_ddOn4 of
            { (x1_adO2V, y1_adO2W, z1_adO2X, w1_adO2Y, v1_adO2Z, a1_adO30,
               b1_adO31) ->
            b1_adO31
            }))

-- RHS size: {terms: 9, types: 31, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversable(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w v. Bitraversable ((,,,,,,) x y z w v)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ x_adO2O)
             (@ y_adO2P)
             (@ z_adO2Q)
             (@ w_adO2R)
             (@ v_adO2S) ->
       Data.Bitraversable.C:Bitraversable TYPE: (,,,,,,)
                                                  x_adO2O y_adO2P z_adO2Q w_adO2R v_adO2S
                                          Data.Bifunctor.$fBifunctor(,,,,,,)
                                            @ x_adO2O @ y_adO2P @ z_adO2Q @ w_adO2R @ v_adO2S
                                          Data.Bifoldable.$fBifoldable(,,,,,,)
                                            @ x_adO2O @ y_adO2P @ z_adO2Q @ w_adO2R @ v_adO2S
                                          Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse
                                            @ x_adO2O @ y_adO2P @ z_adO2Q @ w_adO2R @ v_adO2S]
Data.Bitraversable.$fBitraversable(,,,,,,)
  = \ (@ x_adOi0) (@ y_adOi1) (@ z_adOi2) (@ w_adOi3) (@ v_adOi4) ->
      Data.Bitraversable.C:Bitraversable
        @ ((,,,,,,) x_adOi0 y_adOi1 z_adOi2 w_adOi3 v_adOi4)
        (Data.Bifunctor.$fBifunctor(,,,,,,)
           @ x_adOi0 @ y_adOi1 @ z_adOi2 @ w_adOi3 @ v_adOi4)
        (Data.Bifoldable.$fBifoldable(,,,,,,)
           @ x_adOi0 @ y_adOi1 @ z_adOi2 @ w_adOi3 @ v_adOi4)
        (Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse
           @ x_adOi0 @ y_adOi1 @ z_adOi2 @ w_adOi3 @ v_adOi4)

-- RHS size: {terms: 25, types: 44, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversableEither_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> Either a b -> f (Either c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 60 110] 180 0}]
Data.Bitraversable.$fBitraversableEither_$cbitraverse
  = \ (@ (f_adOhE :: * -> *))
      (@ a_adOhF)
      (@ c_adOhG)
      (@ b_adOhH)
      (@ d_adOhI)
      ($dApplicative_adOhK :: Applicative f_adOhE)
      (eta_B3 :: a_adOhF -> f_adOhE c_adOhG)
      (eta1_B2 :: b_adOhH -> f_adOhE d_adOhI)
      (eta2_B1 :: Either a_adOhF b_adOhH) ->
      case eta2_B1 of {
        Left a1_adO2L ->
          fmap
            @ f_adOhE
            (GHC.Base.$p1Applicative @ f_adOhE $dApplicative_adOhK)
            @ c_adOhG
            @ (Either c_adOhG d_adOhI)
            (Data.Either.Left @ c_adOhG @ d_adOhI)
            (eta_B3 a1_adO2L);
        Right b1_adO2N ->
          fmap
            @ f_adOhE
            (GHC.Base.$p1Applicative @ f_adOhE $dApplicative_adOhK)
            @ d_adOhI
            @ (Either c_adOhG d_adOhI)
            (Data.Either.Right @ c_adOhG @ d_adOhI)
            (eta1_B2 b1_adO2N)
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Bitraversable Either
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bitraversable.C:Bitraversable TYPE: Either
                                          Data.Bifunctor.$fBifunctorEither
                                          Data.Bifoldable.$fBifoldableEither
                                          Data.Bitraversable.$fBitraversableEither_$cbitraverse]
Data.Bitraversable.$fBitraversableEither
  = Data.Bitraversable.C:Bitraversable
      @ Either
      Data.Bifunctor.$fBifunctorEither
      Data.Bifoldable.$fBifoldableEither
      Data.Bitraversable.$fBitraversableEither_$cbitraverse

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversableConst1 :: forall c. c -> c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ c_adOhe) (v_X6 [Occ=Once] :: c_adOhe) -> v_X6}]
Data.Bitraversable.$fBitraversableConst1
  = \ (@ c_adOhe) (v_X6 :: c_adOhe) -> v_X6

-- RHS size: {terms: 15, types: 34, coercions: 13, joins: 0/0}
Data.Bitraversable.$fBitraversableConst_$cbitraverse
  :: forall (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> Const a b -> f (Const c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_adOhc :: * -> *))
                 (@ a_adOhd)
                 (@ c_adOhe)
                 (@ b_adOhf)
                 (@ d_adOhg)
                 ($dApplicative_adOhi [Occ=Once] :: Applicative f_adOhc)
                 (eta_B3 [Occ=Once!] :: a_adOhd -> f_adOhc c_adOhe)
                 _ [Occ=Dead]
                 (eta2_B1 [Occ=Once] :: Const a_adOhd b_adOhf) ->
                 fmap
                   @ f_adOhc
                   (GHC.Base.$p1Applicative @ f_adOhc $dApplicative_adOhi)
                   @ c_adOhe
                   @ (Const c_adOhe d_adOhg)
                   ((Data.Bitraversable.$fBitraversableConst1 @ c_adOhe)
                    `cast` (<c_adOhe>_R
                            ->_R Sym (Data.Functor.Const.N:Const[0]
                                          <*>_N <c_adOhe>_R <d_adOhg>_P)
                            :: (c_adOhe -> c_adOhe :: *)
                               ~R# (c_adOhe -> Const c_adOhe d_adOhg :: *)))
                   (eta_B3
                      (eta2_B1
                       `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adOhd>_R <b_adOhf>_P
                               :: (Const a_adOhd b_adOhf :: *) ~R# (a_adOhd :: *))))}]
Data.Bitraversable.$fBitraversableConst_$cbitraverse
  = \ (@ (f_adOhc :: * -> *))
      (@ a_adOhd)
      (@ c_adOhe)
      (@ b_adOhf)
      (@ d_adOhg)
      ($dApplicative_adOhi :: Applicative f_adOhc)
      (eta_B3 :: a_adOhd -> f_adOhc c_adOhe)
      _ [Occ=Dead]
      (eta2_B1 :: Const a_adOhd b_adOhf) ->
      fmap
        @ f_adOhc
        (GHC.Base.$p1Applicative @ f_adOhc $dApplicative_adOhi)
        @ c_adOhe
        @ (Const c_adOhe d_adOhg)
        ((Data.Bitraversable.$fBitraversableConst1 @ c_adOhe)
         `cast` (<c_adOhe>_R
                 ->_R Sym (Data.Functor.Const.N:Const[0]
                               <*>_N <c_adOhe>_R <d_adOhg>_P)
                 :: (c_adOhe -> c_adOhe :: *)
                    ~R# (c_adOhe -> Const c_adOhe d_adOhg :: *)))
        (eta_B3
           (eta2_B1
            `cast` (Data.Functor.Const.N:Const[0] <*>_N <a_adOhd>_R <b_adOhf>_P
                    :: (Const a_adOhd b_adOhf :: *) ~R# (a_adOhd :: *))))

-- RHS size: {terms: 4, types: 3, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Bitraversable Const
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Bitraversable.C:Bitraversable TYPE: Const
                                          Data.Bifunctor.$fBifunctorConst
                                          Data.Bifoldable.$fBifoldableConst
                                          Data.Bitraversable.$fBitraversableConst_$cbitraverse]
Data.Bitraversable.$fBitraversableConst
  = Data.Bitraversable.C:Bitraversable
      @ Const
      Data.Bifunctor.$fBifunctorConst
      Data.Bifoldable.$fBifoldableConst
      Data.Bitraversable.$fBitraversableConst_$cbitraverse

-- RHS size: {terms: 16, types: 37, coercions: 15, joins: 0/0}
Data.Bitraversable.$fBitraversableK1_$cbitraverse
  :: forall i (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> K1 i a b -> f (K1 i c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ i_adOgx)
                 (@ (f_adOgJ :: * -> *))
                 (@ a_adOgK)
                 (@ c_adOgL)
                 (@ b_adOgM)
                 (@ d_adOgN)
                 ($dApplicative_adOgP [Occ=Once] :: Applicative f_adOgJ)
                 (eta_B3 [Occ=Once!] :: a_adOgK -> f_adOgJ c_adOgL)
                 _ [Occ=Dead]
                 (eta2_B1 [Occ=Once] :: K1 i_adOgx a_adOgK b_adOgM) ->
                 fmap
                   @ f_adOgJ
                   (GHC.Base.$p1Applicative @ f_adOgJ $dApplicative_adOgP)
                   @ c_adOgL
                   @ (K1 i_adOgx c_adOgL d_adOgN)
                   ((Data.Bitraversable.$fBitraversableConst1 @ c_adOgL)
                    `cast` (<c_adOgL>_R
                            ->_R Sym (GHC.Generics.N:K1[0]
                                          <*>_N <i_adOgx>_P <c_adOgL>_R <d_adOgN>_P)
                            :: (c_adOgL -> c_adOgL :: *)
                               ~R# (c_adOgL -> K1 i_adOgx c_adOgL d_adOgN :: *)))
                   (eta_B3
                      (eta2_B1
                       `cast` (GHC.Generics.N:K1[0]
                                   <*>_N <i_adOgx>_P <a_adOgK>_R <b_adOgM>_P
                               :: (K1 i_adOgx a_adOgK b_adOgM :: *) ~R# (a_adOgK :: *))))}]
Data.Bitraversable.$fBitraversableK1_$cbitraverse
  = \ (@ i_adOgx)
      (@ (f_adOgJ :: * -> *))
      (@ a_adOgK)
      (@ c_adOgL)
      (@ b_adOgM)
      (@ d_adOgN)
      ($dApplicative_adOgP :: Applicative f_adOgJ)
      (eta_B3 :: a_adOgK -> f_adOgJ c_adOgL)
      _ [Occ=Dead]
      (eta2_B1 :: K1 i_adOgx a_adOgK b_adOgM) ->
      fmap
        @ f_adOgJ
        (GHC.Base.$p1Applicative @ f_adOgJ $dApplicative_adOgP)
        @ c_adOgL
        @ (K1 i_adOgx c_adOgL d_adOgN)
        ((Data.Bitraversable.$fBitraversableConst1 @ c_adOgL)
         `cast` (<c_adOgL>_R
                 ->_R Sym (GHC.Generics.N:K1[0]
                               <*>_N <i_adOgx>_P <c_adOgL>_R <d_adOgN>_P)
                 :: (c_adOgL -> c_adOgL :: *)
                    ~R# (c_adOgL -> K1 i_adOgx c_adOgL d_adOgN :: *)))
        (eta_B3
           (eta2_B1
            `cast` (GHC.Generics.N:K1[0]
                        <*>_N <i_adOgx>_P <a_adOgK>_R <b_adOgM>_P
                    :: (K1 i_adOgx a_adOgK b_adOgM :: *) ~R# (a_adOgK :: *))))

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Bitraversable.$fBitraversableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Bitraversable (K1 i)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ i_adO2F) ->
       Data.Bitraversable.C:Bitraversable TYPE: K1 i_adO2F
                                          Data.Bifunctor.$fBifunctorK1 @ i_adO2F
                                          Data.Bifoldable.$fBifoldableK1 @ i_adO2F
                                          Data.Bitraversable.$fBitraversableK1_$cbitraverse
                                            @ i_adO2F]
Data.Bitraversable.$fBitraversableK1
  = \ (@ i_adOgx) ->
      Data.Bitraversable.C:Bitraversable
        @ (K1 i_adOgx)
        (Data.Bifunctor.$fBifunctorK1 @ i_adOgx)
        (Data.Bifoldable.$fBifoldableK1 @ i_adOgx)
        (Data.Bitraversable.$fBitraversableK1_$cbitraverse @ i_adOgx)

-- RHS size: {terms: 11, types: 28, coercions: 0, joins: 0/0}
bimapM
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Bitraversable t, Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_adOfB :: * -> * -> *))
                 (@ (f_adOfC :: * -> *))
                 (@ a_adOfD)
                 (@ c_adOfE)
                 (@ b_adOfF)
                 (@ d_adOfG)
                 ($dBitraversable_adOfI [Occ=Once] :: Bitraversable t_adOfB)
                 ($dApplicative_adOfJ [Occ=Once] :: Applicative f_adOfC) ->
                 bitraverse
                   @ t_adOfB
                   $dBitraversable_adOfI
                   @ f_adOfC
                   @ a_adOfD
                   @ c_adOfE
                   @ b_adOfF
                   @ d_adOfG
                   $dApplicative_adOfJ}]
bimapM
  = \ (@ (t_adOfB :: * -> * -> *))
      (@ (f_adOfC :: * -> *))
      (@ a_adOfD)
      (@ c_adOfE)
      (@ b_adOfF)
      (@ d_adOfG)
      ($dBitraversable_adOfI :: Bitraversable t_adOfB)
      ($dApplicative_adOfJ :: Applicative f_adOfC) ->
      bitraverse
        @ t_adOfB
        $dBitraversable_adOfI
        @ f_adOfC
        @ a_adOfD
        @ c_adOfE
        @ b_adOfF
        @ d_adOfG
        $dApplicative_adOfJ

-- RHS size: {terms: 11, types: 30, coercions: 0, joins: 0/0}
bisequence
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Bitraversable t, Applicative f) =>
     t (f a) (f b) -> f (t a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_adOfj :: * -> * -> *))
                 (@ (f_adOfk :: * -> *))
                 (@ a_adOfl)
                 (@ b_adOfm)
                 ($dBitraversable_adOfo [Occ=Once] :: Bitraversable t_adOfj)
                 ($dApplicative_adOfp [Occ=Once] :: Applicative f_adOfk) ->
                 bitraverse
                   @ t_adOfj
                   $dBitraversable_adOfo
                   @ f_adOfk
                   @ (f_adOfk a_adOfl)
                   @ a_adOfl
                   @ (f_adOfk b_adOfm)
                   @ b_adOfm
                   $dApplicative_adOfp
                   (id @ (f_adOfk a_adOfl))
                   (id @ (f_adOfk b_adOfm))}]
bisequence
  = \ (@ (t_adOfj :: * -> * -> *))
      (@ (f_adOfk :: * -> *))
      (@ a_adOfl)
      (@ b_adOfm)
      ($dBitraversable_adOfo :: Bitraversable t_adOfj)
      ($dApplicative_adOfp :: Applicative f_adOfk) ->
      bitraverse
        @ t_adOfj
        $dBitraversable_adOfo
        @ f_adOfk
        @ (f_adOfk a_adOfl)
        @ a_adOfl
        @ (f_adOfk b_adOfm)
        @ b_adOfm
        $dApplicative_adOfp
        (id @ (f_adOfk a_adOfl))
        (id @ (f_adOfk b_adOfm))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
bisequenceA
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Bitraversable t, Applicative f) =>
     t (f a) (f b) -> f (t a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= bisequence}]
bisequenceA = bisequence

-- RHS size: {terms: 26, types: 68, coercions: 0, joins: 0/2}
Data.Bitraversable.$dmbitraverse
  :: forall (t :: * -> * -> *).
     Bitraversable t =>
     forall (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C1(C(U))),A,A),A,1*C1(C1(C1(C(U)))))><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_adO2x :: * -> * -> *))
                 ($dBitraversable_adOg7 :: Bitraversable t_adO2x) ->
                 let {
                   $dBifunctor_adOlP [Occ=OnceL] :: Bifunctor t_adO2x
                   [LclId]
                   $dBifunctor_adOlP
                     = Data.Bitraversable.$p1Bitraversable
                         @ t_adO2x $dBitraversable_adOg7 } in
                 \ (@ (f_adOg9 :: * -> *))
                   (@ a_adOga)
                   (@ c_adOgb)
                   (@ b_adOgc)
                   (@ d_adOgd)
                   ($dApplicative_adOgf [Occ=Once] :: Applicative f_adOg9)
                   (f1_adO2D [Occ=Once] :: a_adOga -> f_adOg9 c_adOgb)
                   (g_adO2E [Occ=Once] :: b_adOgc -> f_adOg9 d_adOgd) ->
                   let {
                     f2_i7Rxg [Occ=OnceL!]
                       :: t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
                          -> f_adOg9 (t_adO2x c_adOgb d_adOgd)
                     [LclId]
                     f2_i7Rxg
                       = bitraverse
                           @ t_adO2x
                           $dBitraversable_adOg7
                           @ f_adOg9
                           @ (f_adOg9 c_adOgb)
                           @ c_adOgb
                           @ (f_adOg9 d_adOgd)
                           @ d_adOgd
                           $dApplicative_adOgf
                           (id @ (f_adOg9 c_adOgb))
                           (id @ (f_adOg9 d_adOgd)) } in
                   let {
                     g1_i7Rxh [Occ=OnceL!]
                       :: t_adO2x a_adOga b_adOgc
                          -> t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
                     [LclId]
                     g1_i7Rxh
                       = bimap
                           @ t_adO2x
                           $dBifunctor_adOlP
                           @ a_adOga
                           @ (f_adOg9 c_adOgb)
                           @ b_adOgc
                           @ (f_adOg9 d_adOgd)
                           f1_adO2D
                           g_adO2E } in
                   \ (x_i7Rxi [Occ=Once] :: t_adO2x a_adOga b_adOgc) ->
                     f2_i7Rxg (g1_i7Rxh x_i7Rxi)}]
Data.Bitraversable.$dmbitraverse
  = \ (@ (t_adO2x :: * -> * -> *))
      ($dBitraversable_adOg7 :: Bitraversable t_adO2x)
      (@ (f_adOg9 :: * -> *))
      (@ a_adOga)
      (@ c_adOgb)
      (@ b_adOgc)
      (@ d_adOgd)
      (eta_B3 :: Applicative f_adOg9)
      (eta1_B2 :: a_adOga -> f_adOg9 c_adOgb)
      (eta2_B1 :: b_adOgc -> f_adOg9 d_adOgd) ->
      let {
        f1_sdOsI [Dmd=<L,C(U)>]
          :: t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
             -> f_adOg9 (t_adO2x c_adOgb d_adOgd)
        [LclId]
        f1_sdOsI
          = bitraverse
              @ t_adO2x
              $dBitraversable_adOg7
              @ f_adOg9
              @ (f_adOg9 c_adOgb)
              @ c_adOgb
              @ (f_adOg9 d_adOgd)
              @ d_adOgd
              eta_B3
              (id @ (f_adOg9 c_adOgb))
              (id @ (f_adOg9 d_adOgd)) } in
      let {
        g_sdOsH [Dmd=<L,C(U)>]
          :: t_adO2x a_adOga b_adOgc
             -> t_adO2x (f_adOg9 c_adOgb) (f_adOg9 d_adOgd)
        [LclId]
        g_sdOsH
          = bimap
              @ t_adO2x
              (Data.Bitraversable.$p1Bitraversable
                 @ t_adO2x $dBitraversable_adOg7)
              @ a_adOga
              @ (f_adOg9 c_adOgb)
              @ b_adOgc
              @ (f_adOg9 d_adOgd)
              eta1_B2
              eta2_B1 } in
      \ (x_i7Rxi :: t_adO2x a_adOga b_adOgc) ->
        f1_sdOsI (g_sdOsH x_i7Rxi)

-- RHS size: {terms: 17, types: 37, coercions: 0, joins: 0/0}
bifor
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Bitraversable t, Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_adOeJ :: * -> * -> *))
                 (@ (f_adOeK :: * -> *))
                 (@ a_adOeL)
                 (@ b_adOeM)
                 (@ c_adOeN)
                 (@ d_adOeO)
                 ($dBitraversable_adOeQ [Occ=Once] :: Bitraversable t_adOeJ)
                 ($dApplicative_adOeR [Occ=Once] :: Applicative f_adOeK)
                 (t1_adO4r [Occ=Once] :: t_adOeJ a_adOeL b_adOeM)
                 (f1_adO4s [Occ=Once] :: a_adOeL -> f_adOeK c_adOeN)
                 (g_adO4t [Occ=Once] :: b_adOeM -> f_adOeK d_adOeO) ->
                 bitraverse
                   @ t_adOeJ
                   $dBitraversable_adOeQ
                   @ f_adOeK
                   @ a_adOeL
                   @ c_adOeN
                   @ b_adOeM
                   @ d_adOeO
                   $dApplicative_adOeR
                   f1_adO4s
                   g_adO4t
                   t1_adO4r}]
bifor
  = \ (@ (t_adOeJ :: * -> * -> *))
      (@ (f_adOeK :: * -> *))
      (@ a_adOeL)
      (@ b_adOeM)
      (@ c_adOeN)
      (@ d_adOeO)
      ($dBitraversable_adOeQ :: Bitraversable t_adOeJ)
      ($dApplicative_adOeR :: Applicative f_adOeK)
      (t1_adO4r :: t_adOeJ a_adOeL b_adOeM)
      (f1_adO4s :: a_adOeL -> f_adOeK c_adOeN)
      (g_adO4t :: b_adOeM -> f_adOeK d_adOeO) ->
      bitraverse
        @ t_adOeJ
        $dBitraversable_adOeQ
        @ f_adOeK
        @ a_adOeL
        @ c_adOeN
        @ b_adOeM
        @ d_adOeO
        $dApplicative_adOeR
        f1_adO4s
        g_adO4t
        t1_adO4r

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
biforM
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Bitraversable t, Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= bifor}]
biforM = bifor

-- RHS size: {terms: 26, types: 44, coercions: 17, joins: 0/0}
bimapAccumL
  :: forall (t :: * -> * -> *) a b c d e.
     Bitraversable t =>
     (a -> b -> (a, c))
     -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 60 0 0] 170 0}]
bimapAccumL
  = \ (@ (t_adOea :: * -> * -> *))
      (@ a_adOeb)
      (@ b_adOec)
      (@ c_adOed)
      (@ d_adOee)
      (@ e_adOef)
      ($dBitraversable_adOeh :: Bitraversable t_adOea)
      (f_adO4u :: a_adOeb -> b_adOec -> (a_adOeb, c_adOed))
      (g_adO4v :: a_adOeb -> d_adOee -> (a_adOeb, e_adOef))
      (s_adO4w :: a_adOeb)
      (t1_adO4x :: t_adOea b_adOec d_adOee) ->
      ((bitraverse
          @ t_adOea
          $dBitraversable_adOeh
          @ (StateL a_adOeb)
          @ b_adOec
          @ c_adOed
          @ d_adOee
          @ e_adOef
          (Data.Functor.Utils.$fApplicativeStateL @ a_adOeb)
          ((\ (x_i7Rxi :: b_adOec) (y_i8X9Y :: a_adOeb) ->
              f_adO4u y_i8X9Y x_i7Rxi)
           `cast` (<b_adOec>_R
                   ->_R Sym (Data.Functor.Utils.N:StateL[0] <a_adOeb>_R <c_adOed>_R)
                   :: (b_adOec -> a_adOeb -> (a_adOeb, c_adOed) :: *)
                      ~R# (b_adOec -> StateL a_adOeb c_adOed :: *)))
          ((\ (x_i7Rxi :: d_adOee) (y_i8X9Y :: a_adOeb) ->
              g_adO4v y_i8X9Y x_i7Rxi)
           `cast` (<d_adOee>_R
                   ->_R Sym (Data.Functor.Utils.N:StateL[0] <a_adOeb>_R <e_adOef>_R)
                   :: (d_adOee -> a_adOeb -> (a_adOeb, e_adOef) :: *)
                      ~R# (d_adOee -> StateL a_adOeb e_adOef :: *)))
          t1_adO4x)
       `cast` (Data.Functor.Utils.N:StateL[0]
                   <a_adOeb>_R <t_adOea c_adOed e_adOef>_R
               :: (StateL a_adOeb (t_adOea c_adOed e_adOef) :: *)
                  ~R# (a_adOeb -> (a_adOeb, t_adOea c_adOed e_adOef) :: *)))
        s_adO4w

-- RHS size: {terms: 26, types: 44, coercions: 17, joins: 0/0}
bimapAccumR
  :: forall (t :: * -> * -> *) a b c d e.
     Bitraversable t =>
     (a -> b -> (a, c))
     -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(C(S))))),1*U(A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 60 0 0] 170 0}]
bimapAccumR
  = \ (@ (t_adOdB :: * -> * -> *))
      (@ a_adOdC)
      (@ b_adOdD)
      (@ c_adOdE)
      (@ d_adOdF)
      (@ e_adOdG)
      ($dBitraversable_adOdI :: Bitraversable t_adOdB)
      (f_adO4y :: a_adOdC -> b_adOdD -> (a_adOdC, c_adOdE))
      (g_adO4z :: a_adOdC -> d_adOdF -> (a_adOdC, e_adOdG))
      (s_adO4A :: a_adOdC)
      (t1_adO4B :: t_adOdB b_adOdD d_adOdF) ->
      ((bitraverse
          @ t_adOdB
          $dBitraversable_adOdI
          @ (StateR a_adOdC)
          @ b_adOdD
          @ c_adOdE
          @ d_adOdF
          @ e_adOdG
          (Data.Functor.Utils.$fApplicativeStateR @ a_adOdC)
          ((\ (x_i7Rxi :: b_adOdD) (y_i8X9Y :: a_adOdC) ->
              f_adO4y y_i8X9Y x_i7Rxi)
           `cast` (<b_adOdD>_R
                   ->_R Sym (Data.Functor.Utils.N:StateR[0] <a_adOdC>_R <c_adOdE>_R)
                   :: (b_adOdD -> a_adOdC -> (a_adOdC, c_adOdE) :: *)
                      ~R# (b_adOdD -> StateR a_adOdC c_adOdE :: *)))
          ((\ (x_i7Rxi :: d_adOdF) (y_i8X9Y :: a_adOdC) ->
              g_adO4z y_i8X9Y x_i7Rxi)
           `cast` (<d_adOdF>_R
                   ->_R Sym (Data.Functor.Utils.N:StateR[0] <a_adOdC>_R <e_adOdG>_R)
                   :: (d_adOdF -> a_adOdC -> (a_adOdC, e_adOdG) :: *)
                      ~R# (d_adOdF -> StateR a_adOdC e_adOdG :: *)))
          t1_adO4B)
       `cast` (Data.Functor.Utils.N:StateR[0]
                   <a_adOdC>_R <t_adOdB c_adOdE e_adOdG>_R
               :: (StateR a_adOdC (t_adOdB c_adOdE e_adOdG) :: *)
                  ~R# (a_adOdC -> (a_adOdC, t_adOdB c_adOdE e_adOdG) :: *)))
        s_adO4A

-- RHS size: {terms: 9, types: 22, coercions: 0, joins: 0/0}
bimapDefault1_rdOxw
  :: forall (t :: * -> * -> *) a b c d.
     Bitraversable t =>
     (a -> Identity b) -> (c -> Identity d) -> t a c -> Identity (t b d)
[GblId, Arity=1, Str=<S(LLC(S)),1*U(A,A,1*C1(U))>, Unf=OtherCon []]
bimapDefault1_rdOxw
  = \ (@ (t_adOd3 :: * -> * -> *))
      (@ a_adOd4)
      (@ b_adOd5)
      (@ c_adOd6)
      (@ d_adOd7)
      ($dBitraversable_adOd9 :: Bitraversable t_adOd3) ->
      bitraverse
        @ t_adOd3
        $dBitraversable_adOd9
        @ Identity
        @ a_adOd4
        @ b_adOd5
        @ c_adOd6
        @ d_adOd7
        Data.Functor.Identity.$fApplicativeIdentity

-- RHS size: {terms: 1, types: 0, coercions: 40, joins: 0/0}
bimapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> * -> *) a b c d.
     Bitraversable t =>
     (a -> b) -> (c -> d) -> t a c -> t b d
[GblId,
 Arity=1,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= (\ (@ (t_XdOe7 :: * -> * -> *))
                  (@ a_XdOe9)
                  (@ b_XdOeb)
                  (@ c_XdOed)
                  (@ d_XdOef)
                  ($dBitraversable_XdOei [Occ=Once] :: Bitraversable t_XdOe7) ->
                  bitraverse
                    @ t_XdOe7
                    $dBitraversable_XdOei
                    @ Identity
                    @ a_XdOe9
                    @ b_XdOeb
                    @ c_XdOed
                    @ d_XdOef
                    Data.Functor.Identity.$fApplicativeIdentity)
               `cast` (forall (t :: <*
                                     -> *
                                     -> *>_N) (a :: <*>_N) (b :: <*>_N) (c :: <*>_N) (d :: <*>_N).
                       <Bitraversable t>_R
                       ->_R (<a>_R ->_R Data.Functor.Identity.N:Identity[0] <b>_R)
                       ->_R (<c>_R ->_R Data.Functor.Identity.N:Identity[0] <d>_R)
                       ->_R <t a c>_R
                       ->_R Data.Functor.Identity.N:Identity[0] <t b d>_R
                       :: (forall (t :: * -> * -> *) a b c d.
                           Bitraversable t =>
                           (a -> Identity b)
                           -> (c -> Identity d) -> t a c -> Identity (t b d) :: *)
                          ~R# (forall (t :: * -> * -> *) a b c d.
                               Bitraversable t =>
                               (a -> b) -> (c -> d) -> t a c -> t b d :: *))}]
bimapDefault
  = bimapDefault1_rdOxw
    `cast` (forall (t :: <*
                          -> * -> *>_N) (a :: <*>_N) (b :: <*>_N) (c :: <*>_N) (d :: <*>_N).
            <Bitraversable t>_R
            ->_R (<a>_R ->_R Data.Functor.Identity.N:Identity[0] <b>_R)
            ->_R (<c>_R ->_R Data.Functor.Identity.N:Identity[0] <d>_R)
            ->_R <t a c>_R
            ->_R Data.Functor.Identity.N:Identity[0] <t b d>_R
            :: (forall (t :: * -> * -> *) a b c d.
                Bitraversable t =>
                (a -> Identity b)
                -> (c -> Identity d) -> t a c -> Identity (t b d) :: *)
               ~R# (forall (t :: * -> * -> *) a b c d.
                    Bitraversable t =>
                    (a -> b) -> (c -> d) -> t a c -> t b d :: *))

-- RHS size: {terms: 10, types: 26, coercions: 0, joins: 0/0}
bifoldMapDefault1_rdOxx
  :: forall (t :: * -> * -> *) m a b.
     (Bitraversable t, Monoid m) =>
     (a -> Const m ())
     -> (b -> Const m ()) -> t a b -> Const m (t () ())
[GblId,
 Arity=2,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U(A,U,U,A)>,
 Unf=OtherCon []]
bifoldMapDefault1_rdOxx
  = \ (@ (t_adOcs :: * -> * -> *))
      (@ m_adOct)
      (@ a_adOcu)
      (@ b_adOcv)
      ($dBitraversable_adOcx :: Bitraversable t_adOcs)
      ($dMonoid_adOcy :: Monoid m_adOct) ->
      bitraverse
        @ t_adOcs
        $dBitraversable_adOcx
        @ (Const m_adOct)
        @ a_adOcu
        @ ()
        @ b_adOcv
        @ ()
        (Data.Functor.Const.$fApplicativeConst @ m_adOct $dMonoid_adOcy)

-- RHS size: {terms: 1, types: 0, coercions: 49, joins: 0/0}
bifoldMapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> * -> *) m a b.
     (Bitraversable t, Monoid m) =>
     (a -> m) -> (b -> m) -> t a b -> m
[GblId,
 Arity=2,
 Str=<S(LLC(S)),1*U(A,A,1*C1(U))><L,U(A,U,U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= (\ (@ (t_XdOdE :: * -> * -> *))
                  (@ m_XdOdG)
                  (@ a_XdOdI)
                  (@ b_XdOdK)
                  ($dBitraversable_XdOdN [Occ=Once] :: Bitraversable t_XdOdE)
                  ($dMonoid_XdOdP [Occ=Once] :: Monoid m_XdOdG) ->
                  bitraverse
                    @ t_XdOdE
                    $dBitraversable_XdOdN
                    @ (Const m_XdOdG)
                    @ a_XdOdI
                    @ ()
                    @ b_XdOdK
                    @ ()
                    (Data.Functor.Const.$fApplicativeConst @ m_XdOdG $dMonoid_XdOdP))
               `cast` (forall (t :: <*
                                     -> * -> *>_N) (m :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                       <Bitraversable t>_R
                       ->_R <Monoid m>_R
                       ->_R (<a>_R ->_R Data.Functor.Const.N:Const[0] <*>_N <m>_R <()>_P)
                       ->_R (<b>_R ->_R Data.Functor.Const.N:Const[0] <*>_N <m>_R <()>_P)
                       ->_R <t a b>_R
                       ->_R Data.Functor.Const.N:Const[0] <*>_N <m>_R <t () ()>_P
                       :: (forall (t :: * -> * -> *) m a b.
                           (Bitraversable t, Monoid m) =>
                           (a -> Const m ())
                           -> (b -> Const m ()) -> t a b -> Const m (t () ()) :: *)
                          ~R# (forall (t :: * -> * -> *) m a b.
                               (Bitraversable t, Monoid m) =>
                               (a -> m) -> (b -> m) -> t a b -> m :: *))}]
bifoldMapDefault
  = bifoldMapDefault1_rdOxx
    `cast` (forall (t :: <*
                          -> * -> *>_N) (m :: <*>_N) (a :: <*>_N) (b :: <*>_N).
            <Bitraversable t>_R
            ->_R <Monoid m>_R
            ->_R (<a>_R ->_R Data.Functor.Const.N:Const[0] <*>_N <m>_R <()>_P)
            ->_R (<b>_R ->_R Data.Functor.Const.N:Const[0] <*>_N <m>_R <()>_P)
            ->_R <t a b>_R
            ->_R Data.Functor.Const.N:Const[0] <*>_N <m>_R <t () ()>_P
            :: (forall (t :: * -> * -> *) m a b.
                (Bitraversable t, Monoid m) =>
                (a -> Const m ())
                -> (b -> Const m ()) -> t a b -> Const m (t () ()) :: *)
               ~R# (forall (t :: * -> * -> *) m a b.
                    (Bitraversable t, Monoid m) =>
                    (a -> m) -> (b -> m) -> t a b -> m :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bitraversable.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Bitraversable.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bitraversable.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bitraversable.$trModule3
  = GHC.Types.TrNameS Data.Bitraversable.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bitraversable.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
Data.Bitraversable.$trModule2 = "Data.Bitraversable"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bitraversable.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bitraversable.$trModule1
  = GHC.Types.TrNameS Data.Bitraversable.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Bitraversable.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Bitraversable.$trModule
  = GHC.Types.Module
      Data.Bitraversable.$trModule3 Data.Bitraversable.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_rdOxy :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_rdOxy
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Bitraversable.$tcBitraversable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Bitraversable.$tcBitraversable1
  = GHC.Types.KindRepFun GHC.Types.krep$*->*->* $krep_rdOxy

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bitraversable.$tcBitraversable3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Bitraversable.$tcBitraversable3 = "Bitraversable"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bitraversable.$tcBitraversable2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bitraversable.$tcBitraversable2
  = GHC.Types.TrNameS Data.Bitraversable.$tcBitraversable3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Bitraversable.$tcBitraversable :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Bitraversable.$tcBitraversable
  = GHC.Types.TyCon
      1654555613294690493##
      8030854156262073676##
      Data.Bitraversable.$trModule
      Data.Bitraversable.$tcBitraversable2
      0#
      Data.Bitraversable.$tcBitraversable1


