
==================== Pre unarise: ====================
2018-03-16 16:08:56.35208429 UTC

Data.Bifunctor.bimap
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sdIrL]
        case v_sdIrL of {
          Data.Bifunctor.C:Bifunctor v_sdIrN [Occ=Once]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead] ->
              v_sdIrN;
        };

Data.Bifunctor.first
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c. (a -> b) -> p a c -> p b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sdIrQ]
        case v_sdIrQ of {
          Data.Bifunctor.C:Bifunctor _ [Occ=Dead]
                                     v_sdIrT [Occ=Once]
                                     _ [Occ=Dead] ->
              v_sdIrT;
        };

Data.Bifunctor.second
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall b c a. (b -> c) -> p a b -> p a c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sdIrV]
        case v_sdIrV of {
          Data.Bifunctor.C:Bifunctor _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     v_sdIrZ [Occ=Once] ->
              v_sdIrZ;
        };

Data.Bifunctor.$fBifunctor(,)_$cbimap
  :: forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIs0 g_sdIs1 ds_sdIs2]
        let {
          sat_sdIsc [Occ=Once] :: d_adHX4
          [LclId] =
              [g_sdIs1 ds_sdIs2] \u []
                  let {
                    sat_sdIsb [Occ=Once] :: c_adHX3
                    [LclId] =
                        [ds_sdIs2] \u []
                            case ds_sdIs2 of {
                              (,) _ [Occ=Dead] b1_sdIsa [Occ=Once] -> b1_sdIsa;
                            };
                  } in  g_sdIs1 sat_sdIsb; } in
        let {
          sat_sdIs7 [Occ=Once] :: b_adHX2
          [LclId] =
              [f_sdIs0 ds_sdIs2] \u []
                  let {
                    sat_sdIs6 [Occ=Once] :: a_adHX1
                    [LclId] =
                        [ds_sdIs2] \u []
                            case ds_sdIs2 of {
                              (,) a1_sdIs4 [Occ=Once] _ [Occ=Dead] -> a1_sdIs4;
                            };
                  } in  f_sdIs0 sat_sdIs6;
        } in  (,) [sat_sdIs7 sat_sdIsc];

Data.Bifunctor.$fBifunctor(,,)_$cbimap
  :: forall x1 a b c d.
     (a -> b) -> (c -> d) -> (x1, a, c) -> (x1, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIsd g_sdIse ds_sdIsf]
        let {
          sat_sdIsw [Occ=Once] :: d_adHWw
          [LclId] =
              [g_sdIse ds_sdIsf] \u []
                  let {
                    sat_sdIsv [Occ=Once] :: c_adHWv
                    [LclId] =
                        [ds_sdIsf] \u []
                            case ds_sdIsf of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdIsu [Occ=Once] -> b1_sdIsu;
                            };
                  } in  g_sdIse sat_sdIsv; } in
        let {
          sat_sdIsq [Occ=Once] :: b_adHWu
          [LclId] =
              [f_sdIsd ds_sdIsf] \u []
                  let {
                    sat_sdIsp [Occ=Once] :: a_adHWt
                    [LclId] =
                        [ds_sdIsf] \u []
                            case ds_sdIsf of {
                              (,,) _ [Occ=Dead] a1_sdIsn [Occ=Once] _ [Occ=Dead] -> a1_sdIsn;
                            };
                  } in  f_sdIsd sat_sdIsp; } in
        let {
          sat_sdIsk [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdIsf] \u []
                  case ds_sdIsf of {
                    (,,) x2_sdIsh [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdIsh;
                  };
        } in  (,,) [sat_sdIsk sat_sdIsq sat_sdIsw];

Data.Bifunctor.$fBifunctor(,,,)_$cbimap
  :: forall x1 x2 a b c d.
     (a -> b) -> (c -> d) -> (x1, x2, a, c) -> (x1, x2, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIsx g_sdIsy ds_sdIsz]
        let {
          sat_sdIsZ [Occ=Once] :: d_adHVX
          [LclId] =
              [g_sdIsy ds_sdIsz] \u []
                  let {
                    sat_sdIsY [Occ=Once] :: c_adHVW
                    [LclId] =
                        [ds_sdIsz] \u []
                            case ds_sdIsz of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdIsX [Occ=Once] ->
                                  b1_sdIsX;
                            };
                  } in  g_sdIsy sat_sdIsY; } in
        let {
          sat_sdIsS [Occ=Once] :: b_adHVV
          [LclId] =
              [f_sdIsx ds_sdIsz] \u []
                  let {
                    sat_sdIsR [Occ=Once] :: a_adHVU
                    [LclId] =
                        [ds_sdIsz] \u []
                            case ds_sdIsz of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdIsP [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdIsP;
                            };
                  } in  f_sdIsx sat_sdIsR; } in
        let {
          sat_sdIsL [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdIsz] \u []
                  case ds_sdIsz of {
                    (,,,) _ [Occ=Dead] x5_sdIsI [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdIsI;
                  }; } in
        let {
          sat_sdIsF [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdIsz] \u []
                  case ds_sdIsz of {
                    (,,,) x4_sdIsB [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdIsB;
                  };
        } in  (,,,) [sat_sdIsF sat_sdIsL sat_sdIsS sat_sdIsZ];

Data.Bifunctor.$fBifunctor(,,,,)_$cbimap
  :: forall x1 x2 x3 a b c d.
     (a -> b) -> (c -> d) -> (x1, x2, x3, a, c) -> (x1, x2, x3, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIt0 g_sdIt1 ds_sdIt2]
        let {
          sat_sdItD [Occ=Once] :: d_adHVn
          [LclId] =
              [g_sdIt1 ds_sdIt2] \u []
                  let {
                    sat_sdItC [Occ=Once] :: c_adHVm
                    [LclId] =
                        [ds_sdIt2] \u []
                            case ds_sdIt2 of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdItB [Occ=Once] ->
                                  b1_sdItB;
                            };
                  } in  g_sdIt1 sat_sdItC; } in
        let {
          sat_sdItv [Occ=Once] :: b_adHVl
          [LclId] =
              [f_sdIt0 ds_sdIt2] \u []
                  let {
                    sat_sdItu [Occ=Once] :: a_adHVk
                    [LclId] =
                        [ds_sdIt2] \u []
                            case ds_sdIt2 of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdIts [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdIts;
                            };
                  } in  f_sdIt0 sat_sdItu; } in
        let {
          sat_sdItn [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdIt2] \u []
                  case ds_sdIt2 of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdItk [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdItk;
                  }; } in
        let {
          sat_sdItg [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdIt2] \u []
                  case ds_sdIt2 of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdItc [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdItc;
                  }; } in
        let {
          sat_sdIt9 [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdIt2] \u []
                  case ds_sdIt2 of {
                    (,,,,) x4_sdIt4 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdIt4;
                  };
        } in  (,,,,) [sat_sdIt9 sat_sdItg sat_sdItn sat_sdItv sat_sdItD];

Data.Bifunctor.$fBifunctor(,,,,,)_$cbimap [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 a b c d.
     (a -> b)
     -> (c -> d) -> (x1, x2, x3, x4, a, c) -> (x1, x2, x3, x4, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdItE w1_sdItF w2_sdItG]
        let {
          sat_sdIuu [Occ=Once] :: d_sdId6
          [LclId] =
              [w1_sdItF w2_sdItG] \u []
                  let {
                    sat_sdIut [Occ=Once] :: c_sdId5
                    [LclId] =
                        [w2_sdItG] \u []
                            case w2_sdItG of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdIus [Occ=Once] ->
                                  b1_sdIus;
                            };
                  } in  w1_sdItF sat_sdIut; } in
        let {
          sat_sdIul [Occ=Once] :: b_sdId4
          [LclId] =
              [w_sdItE w2_sdItG] \u []
                  let {
                    sat_sdIuk [Occ=Once] :: a_sdId3
                    [LclId] =
                        [w2_sdItG] \u []
                            case w2_sdItG of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdIui [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdIui;
                            };
                  } in  w_sdItE sat_sdIuk; } in
        let {
          sat_sdIuc [Occ=Once] :: x4_sdId2
          [LclId] =
              [w2_sdItG] \u []
                  case w2_sdItG of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdIu9 [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdIu9;
                  }; } in
        let {
          sat_sdIu4 [Occ=Once] :: x3_sdId1
          [LclId] =
              [w2_sdItG] \u []
                  case w2_sdItG of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdIu0 [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdIu0;
                  }; } in
        let {
          sat_sdItW [Occ=Once] :: x2_sdId0
          [LclId] =
              [w2_sdItG] \u []
                  case w2_sdItG of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdItR [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdItR;
                  }; } in
        let {
          sat_sdItO [Occ=Once] :: x1_sdIcZ
          [LclId] =
              [w2_sdItG] \u []
                  case w2_sdItG of {
                    (,,,,,) x7_sdItI [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdItI;
                  };
        } in 
          (,,,,,) [sat_sdItO
                   sat_sdItW
                   sat_sdIu4
                   sat_sdIuc
                   sat_sdIul
                   sat_sdIuu];

Data.Bifunctor.$fBifunctor(,,,,,,)_$cbimap [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 a b c d.
     (a -> b)
     -> (c -> d)
     -> (x1, x2, x3, x4, x5, a, c)
     -> (x1, x2, x3, x4, x5, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdIuv w1_sdIuw w2_sdIux]
        let {
          sat_sdIvA [Occ=Once] :: d_sdIdm
          [LclId] =
              [w1_sdIuw w2_sdIux] \u []
                  let {
                    sat_sdIvz [Occ=Once] :: c_sdIdl
                    [LclId] =
                        [w2_sdIux] \u []
                            case w2_sdIux of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdIvy [Occ=Once] ->
                                  b1_sdIvy;
                            };
                  } in  w1_sdIuw sat_sdIvz; } in
        let {
          sat_sdIvq [Occ=Once] :: b_sdIdk
          [LclId] =
              [w_sdIuv w2_sdIux] \u []
                  let {
                    sat_sdIvp [Occ=Once] :: a_sdIdj
                    [LclId] =
                        [w2_sdIux] \u []
                            case w2_sdIux of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdIvn [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdIvn;
                            };
                  } in  w_sdIuv sat_sdIvp; } in
        let {
          sat_sdIvg [Occ=Once] :: x5_sdIdi
          [LclId] =
              [w2_sdIux] \u []
                  case w2_sdIux of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdIvd [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdIvd;
                  }; } in
        let {
          sat_sdIv7 [Occ=Once] :: x4_sdIdh
          [LclId] =
              [w2_sdIux] \u []
                  case w2_sdIux of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdIv3 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdIv3;
                  }; } in
        let {
          sat_sdIuY [Occ=Once] :: x3_sdIdg
          [LclId] =
              [w2_sdIux] \u []
                  case w2_sdIux of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdIuT [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdIuT;
                  }; } in
        let {
          sat_sdIuP [Occ=Once] :: x2_sdIdf
          [LclId] =
              [w2_sdIux] \u []
                  case w2_sdIux of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdIuJ [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdIuJ;
                  }; } in
        let {
          sat_sdIuG [Occ=Once] :: x1_sdIde
          [LclId] =
              [w2_sdIux] \u []
                  case w2_sdIux of {
                    (,,,,,,) x7_sdIuz [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdIuz;
                  };
        } in 
          (,,,,,,) [sat_sdIuG
                    sat_sdIuP
                    sat_sdIuY
                    sat_sdIv7
                    sat_sdIvg
                    sat_sdIvq
                    sat_sdIvA];

Data.Bifunctor.$fBifunctorEither_$cbimap
  :: forall a b c d.
     (a -> b)
     -> (c -> d) -> Data.Either.Either a c -> Data.Either.Either b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdIvB ds_sdIvC ds1_sdIvD]
        case ds1_sdIvD of {
          Data.Either.Left a1_sdIvF [Occ=Once] ->
              let {
                sat_sdIvG [Occ=Once] :: b_adHTr
                [LclId] =
                    [f_sdIvB a1_sdIvF] \u [] f_sdIvB a1_sdIvF;
              } in  Data.Either.Left [sat_sdIvG];
          Data.Either.Right b1_sdIvH [Occ=Once] ->
              let {
                sat_sdIvI [Occ=Once] :: d_adHTt
                [LclId] =
                    [ds_sdIvC b1_sdIvH] \u [] ds_sdIvC b1_sdIvH;
              } in  Data.Either.Right [sat_sdIvI];
        };

Data.Bifunctor.$fBifunctorConst3
  :: forall a b c d.
     (a -> b) -> (c -> d) -> Data.Functor.Const.Const a c -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdIvJ ds_sdIvK ds1_sdIvL] f_sdIvJ ds1_sdIvL;

Data.Bifunctor.$fBifunctorK4
  :: forall i a b c d.
     (a -> b) -> (c -> d) -> GHC.Generics.K1 i a c -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdIvM ds_sdIvN ds1_sdIvO] f_sdIvM ds1_sdIvO;

Data.Bifunctor.$dmsecond
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall b c a. (b -> c) -> p a b -> p a c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdIvP]
        Data.Bifunctor.bimap $dBifunctor_sdIvP GHC.Base.id;

Data.Bifunctor.$dmfirst
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c. (a -> b) -> p a c -> p b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdIvQ f_sdIvR]
        Data.Bifunctor.bimap $dBifunctor_sdIvQ f_sdIvR GHC.Base.id;

Data.Bifunctor.$fBifunctorK3
  :: forall c a i b. (a -> b) -> GHC.Generics.K1 i a c -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdIvS ds_sdIvT] f_sdIvS ds_sdIvT;

Data.Bifunctor.$fBifunctorK2
  :: forall b a i c.
     (b -> c) -> GHC.Generics.K1 i a b -> GHC.Generics.K1 i a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdIvU ds1_sdIvV] ds1_sdIvV;

Data.Bifunctor.$fBifunctorK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bifunctor.Bifunctor (GHC.Generics.K1 i)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorK4
                                               Data.Bifunctor.$fBifunctorK3
                                               Data.Bifunctor.$fBifunctorK2];

Data.Bifunctor.$fBifunctorConst2
  :: forall c a b. (a -> b) -> Data.Functor.Const.Const a c -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdIvW ds_sdIvX] f_sdIvW ds_sdIvX;

Data.Bifunctor.$fBifunctorConst1
  :: forall b a c.
     (b -> c)
     -> Data.Functor.Const.Const a b -> Data.Functor.Const.Const a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdIvY ds1_sdIvZ] ds1_sdIvZ;

Data.Bifunctor.$fBifunctorConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorConst3
                                               Data.Bifunctor.$fBifunctorConst2
                                               Data.Bifunctor.$fBifunctorConst1];

Data.Bifunctor.$fBifunctorEither_$cfirst
  :: forall a b c.
     (a -> b) -> Data.Either.Either a c -> Data.Either.Either b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdIw0 ds_sdIw1]
        case ds_sdIw1 of {
          Data.Either.Left a1_sdIw3 [Occ=Once] ->
              let {
                sat_sdIw4 [Occ=Once] :: b_adHTD
                [LclId] =
                    [f_sdIw0 a1_sdIw3] \u [] f_sdIw0 a1_sdIw3;
              } in  Data.Either.Left [sat_sdIw4];
          Data.Either.Right b1_sdIw5 [Occ=Once] -> wild_sdIw2;
        };

Data.Bifunctor.$fBifunctorEither_$csecond
  :: forall b c a.
     (b -> c) -> Data.Either.Either a b -> Data.Either.Either a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdIw6 ds1_sdIw7]
        case ds1_sdIw7 of {
          Data.Either.Left a1_sdIw9 [Occ=Once] -> wild_sdIw8;
          Data.Either.Right b1_sdIwa [Occ=Once] ->
              let {
                sat_sdIwb [Occ=Once] :: c_adHTP
                [LclId] =
                    [ds_sdIw6 b1_sdIwa] \u [] ds_sdIw6 b1_sdIwa;
              } in  Data.Either.Right [sat_sdIwb];
        };

Data.Bifunctor.$fBifunctorEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorEither_$cbimap
                                               Data.Bifunctor.$fBifunctorEither_$cfirst
                                               Data.Bifunctor.$fBifunctorEither_$csecond];

Data.Bifunctor.$fBifunctor(,,,,,,)_$cfirst [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 a b c.
     (a -> b)
     -> (x1, x2, x3, x4, x5, a, c) -> (x1, x2, x3, x4, x5, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdIwc w1_sdIwd]
        let {
          sat_sdIxf [Occ=Once] :: c_sdIdB
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b1_sdIxe [Occ=Once] ->
                        b1_sdIxe;
                  }; } in
        let {
          sat_sdIx6 [Occ=Once] :: b_sdIdA
          [LclId] =
              [w_sdIwc w1_sdIwd] \u []
                  let {
                    sat_sdIx5 [Occ=Once] :: a_sdIdz
                    [LclId] =
                        [w1_sdIwd] \u []
                            case w1_sdIwd of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdIx3 [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdIx3;
                            };
                  } in  w_sdIwc sat_sdIx5; } in
        let {
          sat_sdIwW [Occ=Once] :: x5_sdIdy
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdIwT [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdIwT;
                  }; } in
        let {
          sat_sdIwN [Occ=Once] :: x4_sdIdx
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdIwJ [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdIwJ;
                  }; } in
        let {
          sat_sdIwE [Occ=Once] :: x3_sdIdw
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdIwz [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdIwz;
                  }; } in
        let {
          sat_sdIwv [Occ=Once] :: x2_sdIdv
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdIwp [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdIwp;
                  }; } in
        let {
          sat_sdIwm [Occ=Once] :: x1_sdIdu
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) x7_sdIwf [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdIwf;
                  };
        } in 
          (,,,,,,) [sat_sdIwm
                    sat_sdIwv
                    sat_sdIwE
                    sat_sdIwN
                    sat_sdIwW
                    sat_sdIx6
                    sat_sdIxf];

Data.Bifunctor.$fBifunctor(,,,,,,)_$csecond [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 b c a.
     (b -> c)
     -> (x1, x2, x3, x4, x5, a, b) -> (x1, x2, x3, x4, x5, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdIxg w1_sdIxh]
        let {
          sat_sdIyj [Occ=Once] :: c_sdIdO
          [LclId] =
              [w_sdIxg w1_sdIxh] \u []
                  let {
                    sat_sdIyi [Occ=Once] :: b_sdIdN
                    [LclId] =
                        [w1_sdIxh] \u []
                            case w1_sdIxh of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdIyh [Occ=Once] ->
                                  b1_sdIyh;
                            };
                  } in  w_sdIxg sat_sdIyi; } in
        let {
          sat_sdIy9 [Occ=Once] :: a_sdIdP
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a1_sdIy7 [Occ=Once]
                             _ [Occ=Dead] ->
                        a1_sdIy7;
                  }; } in
        let {
          sat_sdIy0 [Occ=Once] :: x5_sdIdM
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdIxX [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdIxX;
                  }; } in
        let {
          sat_sdIxR [Occ=Once] :: x4_sdIdL
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdIxN [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdIxN;
                  }; } in
        let {
          sat_sdIxI [Occ=Once] :: x3_sdIdK
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdIxD [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdIxD;
                  }; } in
        let {
          sat_sdIxz [Occ=Once] :: x2_sdIdJ
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdIxt [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdIxt;
                  }; } in
        let {
          sat_sdIxq [Occ=Once] :: x1_sdIdI
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) x7_sdIxj [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdIxj;
                  };
        } in 
          (,,,,,,) [sat_sdIxq
                    sat_sdIxz
                    sat_sdIxI
                    sat_sdIxR
                    sat_sdIy0
                    sat_sdIy9
                    sat_sdIyj];

Data.Bifunctor.$fBifunctor(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3 x4 x5.
     Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,,,)_$cfirst
  :: forall x1 x2 x3 x4 a b c.
     (a -> b) -> (x1, x2, x3, x4, a, c) -> (x1, x2, x3, x4, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIyk ds_sdIyl]
        let {
          sat_sdIz8 [Occ=Once] :: c_adHUT
          [LclId] =
              [ds_sdIyl] \u []
                  case ds_sdIyl of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b1_sdIz7 [Occ=Once] ->
                        b1_sdIz7;
                  }; } in
        let {
          sat_sdIz0 [Occ=Once] :: b_adHUS
          [LclId] =
              [f_sdIyk ds_sdIyl] \u []
                  let {
                    sat_sdIyZ [Occ=Once] :: a_adHUR
                    [LclId] =
                        [ds_sdIyl] \u []
                            case ds_sdIyl of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdIyX [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdIyX;
                            };
                  } in  f_sdIyk sat_sdIyZ; } in
        let {
          sat_sdIyR [Occ=Once] :: x4_adHUF
          [LclId] =
              [ds_sdIyl] \u []
                  case ds_sdIyl of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdIyO [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdIyO;
                  }; } in
        let {
          sat_sdIyJ [Occ=Once] :: x3_adHUE
          [LclId] =
              [ds_sdIyl] \u []
                  case ds_sdIyl of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdIyF [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdIyF;
                  }; } in
        let {
          sat_sdIyB [Occ=Once] :: x2_adHUD
          [LclId] =
              [ds_sdIyl] \u []
                  case ds_sdIyl of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdIyw [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdIyw;
                  }; } in
        let {
          sat_sdIyt [Occ=Once] :: x1_adHUC
          [LclId] =
              [ds_sdIyl] \u []
                  case ds_sdIyl of {
                    (,,,,,) x7_sdIyn [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdIyn;
                  };
        } in 
          (,,,,,) [sat_sdIyt
                   sat_sdIyB
                   sat_sdIyJ
                   sat_sdIyR
                   sat_sdIz0
                   sat_sdIz8];

Data.Bifunctor.$fBifunctor(,,,,,)_$csecond
  :: forall x1 x2 x3 x4 b c a.
     (b -> c) -> (x1, x2, x3, x4, a, b) -> (x1, x2, x3, x4, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdIz9 ds_sdIza]
        let {
          sat_sdIzX [Occ=Once] :: c_adHV4
          [LclId] =
              [g_sdIz9 ds_sdIza] \u []
                  let {
                    sat_sdIzW [Occ=Once] :: b_adHV3
                    [LclId] =
                        [ds_sdIza] \u []
                            case ds_sdIza of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdIzV [Occ=Once] ->
                                  b1_sdIzV;
                            };
                  } in  g_sdIz9 sat_sdIzW; } in
        let {
          sat_sdIzO [Occ=Once] :: a_adHV5
          [LclId] =
              [ds_sdIza] \u []
                  case ds_sdIza of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a1_sdIzM [Occ=Once]
                            _ [Occ=Dead] ->
                        a1_sdIzM;
                  }; } in
        let {
          sat_sdIzG [Occ=Once] :: x4_adHUF
          [LclId] =
              [ds_sdIza] \u []
                  case ds_sdIza of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdIzD [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdIzD;
                  }; } in
        let {
          sat_sdIzy [Occ=Once] :: x3_adHUE
          [LclId] =
              [ds_sdIza] \u []
                  case ds_sdIza of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdIzu [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdIzu;
                  }; } in
        let {
          sat_sdIzq [Occ=Once] :: x2_adHUD
          [LclId] =
              [ds_sdIza] \u []
                  case ds_sdIza of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdIzl [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdIzl;
                  }; } in
        let {
          sat_sdIzi [Occ=Once] :: x1_adHUC
          [LclId] =
              [ds_sdIza] \u []
                  case ds_sdIza of {
                    (,,,,,) x7_sdIzc [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdIzc;
                  };
        } in 
          (,,,,,) [sat_sdIzi
                   sat_sdIzq
                   sat_sdIzy
                   sat_sdIzG
                   sat_sdIzO
                   sat_sdIzX];

Data.Bifunctor.$fBifunctor(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3 x4.
     Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,,)_$cfirst
  :: forall x1 x2 x3 a b c.
     (a -> b) -> (x1, x2, x3, a, c) -> (x1, x2, x3, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIzY ds_sdIzZ]
        let {
          sat_sdIAz [Occ=Once] :: c_adHVu
          [LclId] =
              [ds_sdIzZ] \u []
                  case ds_sdIzZ of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b1_sdIAy [Occ=Once] ->
                        b1_sdIAy;
                  }; } in
        let {
          sat_sdIAs [Occ=Once] :: b_adHVt
          [LclId] =
              [f_sdIzY ds_sdIzZ] \u []
                  let {
                    sat_sdIAr [Occ=Once] :: a_adHVs
                    [LclId] =
                        [ds_sdIzZ] \u []
                            case ds_sdIzZ of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdIAp [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdIAp;
                            };
                  } in  f_sdIzY sat_sdIAr; } in
        let {
          sat_sdIAk [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdIzZ] \u []
                  case ds_sdIzZ of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdIAh [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdIAh;
                  }; } in
        let {
          sat_sdIAd [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdIzZ] \u []
                  case ds_sdIzZ of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdIA9 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdIA9;
                  }; } in
        let {
          sat_sdIA6 [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdIzZ] \u []
                  case ds_sdIzZ of {
                    (,,,,) x4_sdIA1 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdIA1;
                  };
        } in  (,,,,) [sat_sdIA6 sat_sdIAd sat_sdIAk sat_sdIAs sat_sdIAz];

Data.Bifunctor.$fBifunctor(,,,,)_$csecond
  :: forall x1 x2 x3 b c a.
     (b -> c) -> (x1, x2, x3, a, b) -> (x1, x2, x3, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdIAA ds_sdIAB]
        let {
          sat_sdIBb [Occ=Once] :: c_adHVF
          [LclId] =
              [g_sdIAA ds_sdIAB] \u []
                  let {
                    sat_sdIBa [Occ=Once] :: b_adHVE
                    [LclId] =
                        [ds_sdIAB] \u []
                            case ds_sdIAB of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdIB9 [Occ=Once] ->
                                  b1_sdIB9;
                            };
                  } in  g_sdIAA sat_sdIBa; } in
        let {
          sat_sdIB3 [Occ=Once] :: a_adHVG
          [LclId] =
              [ds_sdIAB] \u []
                  case ds_sdIAB of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a1_sdIB1 [Occ=Once]
                           _ [Occ=Dead] ->
                        a1_sdIB1;
                  }; } in
        let {
          sat_sdIAW [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdIAB] \u []
                  case ds_sdIAB of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdIAT [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdIAT;
                  }; } in
        let {
          sat_sdIAP [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdIAB] \u []
                  case ds_sdIAB of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdIAL [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdIAL;
                  }; } in
        let {
          sat_sdIAI [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdIAB] \u []
                  case ds_sdIAB of {
                    (,,,,) x4_sdIAD [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdIAD;
                  };
        } in  (,,,,) [sat_sdIAI sat_sdIAP sat_sdIAW sat_sdIB3 sat_sdIBb];

Data.Bifunctor.$fBifunctor(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3. Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,)_$cfirst
  :: forall x1 x2 a b c. (a -> b) -> (x1, x2, a, c) -> (x1, x2, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIBc ds_sdIBd]
        let {
          sat_sdIBC [Occ=Once] :: c_adHW4
          [LclId] =
              [ds_sdIBd] \u []
                  case ds_sdIBd of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdIBB [Occ=Once] ->
                        b1_sdIBB;
                  }; } in
        let {
          sat_sdIBw [Occ=Once] :: b_adHW3
          [LclId] =
              [f_sdIBc ds_sdIBd] \u []
                  let {
                    sat_sdIBv [Occ=Once] :: a_adHW2
                    [LclId] =
                        [ds_sdIBd] \u []
                            case ds_sdIBd of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdIBt [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdIBt;
                            };
                  } in  f_sdIBc sat_sdIBv; } in
        let {
          sat_sdIBp [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdIBd] \u []
                  case ds_sdIBd of {
                    (,,,) _ [Occ=Dead] x5_sdIBm [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdIBm;
                  }; } in
        let {
          sat_sdIBj [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdIBd] \u []
                  case ds_sdIBd of {
                    (,,,) x4_sdIBf [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdIBf;
                  };
        } in  (,,,) [sat_sdIBj sat_sdIBp sat_sdIBw sat_sdIBC];

Data.Bifunctor.$fBifunctor(,,,)_$csecond
  :: forall x1 x2 b c a. (b -> c) -> (x1, x2, a, b) -> (x1, x2, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdIBD ds_sdIBE]
        let {
          sat_sdIC3 [Occ=Once] :: c_adHWf
          [LclId] =
              [g_sdIBD ds_sdIBE] \u []
                  let {
                    sat_sdIC2 [Occ=Once] :: b_adHWe
                    [LclId] =
                        [ds_sdIBE] \u []
                            case ds_sdIBE of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdIC1 [Occ=Once] ->
                                  b1_sdIC1;
                            };
                  } in  g_sdIBD sat_sdIC2; } in
        let {
          sat_sdIBW [Occ=Once] :: a_adHWg
          [LclId] =
              [ds_sdIBE] \u []
                  case ds_sdIBE of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdIBU [Occ=Once] _ [Occ=Dead] ->
                        a1_sdIBU;
                  }; } in
        let {
          sat_sdIBQ [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdIBE] \u []
                  case ds_sdIBE of {
                    (,,,) _ [Occ=Dead] x5_sdIBN [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdIBN;
                  }; } in
        let {
          sat_sdIBK [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdIBE] \u []
                  case ds_sdIBE of {
                    (,,,) x4_sdIBG [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdIBG;
                  };
        } in  (,,,) [sat_sdIBK sat_sdIBQ sat_sdIBW sat_sdIC3];

Data.Bifunctor.$fBifunctor(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2. Data.Bifunctor.Bifunctor ((,,,) x1 x2)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,)_$cfirst
  :: forall x1 a b c. (a -> b) -> (x1, a, c) -> (x1, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIC4 ds_sdIC5]
        let {
          sat_sdICl [Occ=Once] :: c_adHWD
          [LclId] =
              [ds_sdIC5] \u []
                  case ds_sdIC5 of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdICk [Occ=Once] -> b1_sdICk;
                  }; } in
        let {
          sat_sdICg [Occ=Once] :: b_adHWC
          [LclId] =
              [f_sdIC4 ds_sdIC5] \u []
                  let {
                    sat_sdICf [Occ=Once] :: a_adHWB
                    [LclId] =
                        [ds_sdIC5] \u []
                            case ds_sdIC5 of {
                              (,,) _ [Occ=Dead] a1_sdICd [Occ=Once] _ [Occ=Dead] -> a1_sdICd;
                            };
                  } in  f_sdIC4 sat_sdICf; } in
        let {
          sat_sdICa [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdIC5] \u []
                  case ds_sdIC5 of {
                    (,,) x2_sdIC7 [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdIC7;
                  };
        } in  (,,) [sat_sdICa sat_sdICg sat_sdICl];

Data.Bifunctor.$fBifunctor(,,)_$csecond
  :: forall x1 b c a. (b -> c) -> (x1, a, b) -> (x1, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdICm ds_sdICn]
        let {
          sat_sdICD [Occ=Once] :: c_adHWO
          [LclId] =
              [g_sdICm ds_sdICn] \u []
                  let {
                    sat_sdICC [Occ=Once] :: b_adHWN
                    [LclId] =
                        [ds_sdICn] \u []
                            case ds_sdICn of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdICB [Occ=Once] -> b1_sdICB;
                            };
                  } in  g_sdICm sat_sdICC; } in
        let {
          sat_sdICx [Occ=Once] :: a_adHWP
          [LclId] =
              [ds_sdICn] \u []
                  case ds_sdICn of {
                    (,,) _ [Occ=Dead] a1_sdICv [Occ=Once] _ [Occ=Dead] -> a1_sdICv;
                  }; } in
        let {
          sat_sdICs [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdICn] \u []
                  case ds_sdICn of {
                    (,,) x2_sdICp [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdICp;
                  };
        } in  (,,) [sat_sdICs sat_sdICx sat_sdICD];

Data.Bifunctor.$fBifunctor(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1. Data.Bifunctor.Bifunctor ((,,) x1)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,)_$csecond];

Data.Bifunctor.$fBifunctor(,)_$cfirst
  :: forall a b c. (a -> b) -> (a, c) -> (b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdICE ds_sdICF]
        let {
          sat_sdICO [Occ=Once] :: c_adHXb
          [LclId] =
              [ds_sdICF] \u []
                  case ds_sdICF of {
                    (,) _ [Occ=Dead] b1_sdICN [Occ=Once] -> b1_sdICN;
                  }; } in
        let {
          sat_sdICK [Occ=Once] :: b_adHXa
          [LclId] =
              [f_sdICE ds_sdICF] \u []
                  let {
                    sat_sdICJ [Occ=Once] :: a_adHX9
                    [LclId] =
                        [ds_sdICF] \u []
                            case ds_sdICF of {
                              (,) a1_sdICH [Occ=Once] _ [Occ=Dead] -> a1_sdICH;
                            };
                  } in  f_sdICE sat_sdICJ;
        } in  (,) [sat_sdICK sat_sdICO];

Data.Bifunctor.$fBifunctor(,)_$csecond
  :: forall b c a. (b -> c) -> (a, b) -> (a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdICP ds_sdICQ]
        let {
          sat_sdICZ [Occ=Once] :: c_adHXm
          [LclId] =
              [g_sdICP ds_sdICQ] \u []
                  let {
                    sat_sdICY [Occ=Once] :: b_adHXl
                    [LclId] =
                        [ds_sdICQ] \u []
                            case ds_sdICQ of {
                              (,) _ [Occ=Dead] b1_sdICX [Occ=Once] -> b1_sdICX;
                            };
                  } in  g_sdICP sat_sdICY; } in
        let {
          sat_sdICU [Occ=Once] :: a_adHXn
          [LclId] =
              [ds_sdICQ] \u []
                  case ds_sdICQ of {
                    (,) a1_sdICS [Occ=Once] _ [Occ=Dead] -> a1_sdICS;
                  };
        } in  (,) [sat_sdICU sat_sdICZ];

Data.Bifunctor.$fBifunctor(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,)_$csecond];

Data.Bifunctor.$dmbimap
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(C(U)),1*C1(C(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdID0 f_sdID1 g_sdID2]
        let {
          f1_sdID3 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: p_adHMW a_adHRn d_adHRq -> p_adHMW b_adHRo d_adHRq
          [LclId] =
              [$dBifunctor_sdID0 f_sdID1] \u []
                  Data.Bifunctor.first $dBifunctor_sdID0 f_sdID1; } in
        let {
          g1_sdID4 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: p_adHMW a_adHRn c_adHRp -> p_adHMW a_adHRn d_adHRq
          [LclId] =
              [$dBifunctor_sdID0 g_sdID2] \u []
                  Data.Bifunctor.second $dBifunctor_sdID0 g_sdID2; } in
        let {
          sat_sdID7 [Occ=OnceT[0]]
            :: p_adHMW a_adHRn c_adHRp -> p_adHMW b_adHRo d_adHRq
          [LclId] =
              [f1_sdID3 g1_sdID4] \r [x_sdID5]
                  let {
                    sat_sdID6 [Occ=Once] :: p_adHMW a_adHRn d_adHRq
                    [LclId] =
                        [g1_sdID4 x_sdID5] \u [] g1_sdID4 x_sdID5;
                  } in  f1_sdID3 sat_sdID6;
        } in  sat_sdID7;

Data.Bifunctor.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bifunctor.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$trModule4];

Data.Bifunctor.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bifunctor"#;

Data.Bifunctor.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$trModule2];

Data.Bifunctor.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bifunctor.$trModule3
                                     Data.Bifunctor.$trModule1];

$krep_rdIrJ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bifunctor.$tcBifunctor1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdIrJ];

Data.Bifunctor.$tcBifunctor3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bifunctor"#;

Data.Bifunctor.$tcBifunctor2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$tcBifunctor3];

Data.Bifunctor.$tcBifunctor :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15833243383698227199##
                                    9927729778853233711##
                                    Data.Bifunctor.$trModule
                                    Data.Bifunctor.$tcBifunctor2
                                    0#
                                    Data.Bifunctor.$tcBifunctor1];

Data.Bifunctor.C:Bifunctor
  :: forall (p :: * -> * -> *).
     (forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d)
     -> (forall a b c. (a -> b) -> p a c -> p b c)
     -> (forall b c a. (b -> c) -> p a b -> p a c)
     -> Data.Bifunctor.Bifunctor p
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifunctor.C:Bifunctor [eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:08:56.379281321 UTC

Data.Bifunctor.bimap
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sdIrL]
        case v_sdIrL of {
          Data.Bifunctor.C:Bifunctor v_sdIrN [Occ=Once]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead] ->
              v_sdIrN;
        };

Data.Bifunctor.first
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c. (a -> b) -> p a c -> p b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sdIrQ]
        case v_sdIrQ of {
          Data.Bifunctor.C:Bifunctor _ [Occ=Dead]
                                     v_sdIrT [Occ=Once]
                                     _ [Occ=Dead] ->
              v_sdIrT;
        };

Data.Bifunctor.second
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall b c a. (b -> c) -> p a b -> p a c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sdIrV]
        case v_sdIrV of {
          Data.Bifunctor.C:Bifunctor _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     v_sdIrZ [Occ=Once] ->
              v_sdIrZ;
        };

Data.Bifunctor.$fBifunctor(,)_$cbimap
  :: forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIs0 g_sdIs1 ds_sdIs2]
        let {
          sat_sdIsc [Occ=Once] :: d_adHX4
          [LclId] =
              [g_sdIs1 ds_sdIs2] \u []
                  let {
                    sat_sdIsb [Occ=Once] :: c_adHX3
                    [LclId] =
                        [ds_sdIs2] \u []
                            case ds_sdIs2 of {
                              (,) _ [Occ=Dead] b1_sdIsa [Occ=Once] -> b1_sdIsa;
                            };
                  } in  g_sdIs1 sat_sdIsb; } in
        let {
          sat_sdIs7 [Occ=Once] :: b_adHX2
          [LclId] =
              [f_sdIs0 ds_sdIs2] \u []
                  let {
                    sat_sdIs6 [Occ=Once] :: a_adHX1
                    [LclId] =
                        [ds_sdIs2] \u []
                            case ds_sdIs2 of {
                              (,) a1_sdIs4 [Occ=Once] _ [Occ=Dead] -> a1_sdIs4;
                            };
                  } in  f_sdIs0 sat_sdIs6;
        } in  (,) [sat_sdIs7 sat_sdIsc];

Data.Bifunctor.$fBifunctor(,,)_$cbimap
  :: forall x1 a b c d.
     (a -> b) -> (c -> d) -> (x1, a, c) -> (x1, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIsd g_sdIse ds_sdIsf]
        let {
          sat_sdIsw [Occ=Once] :: d_adHWw
          [LclId] =
              [g_sdIse ds_sdIsf] \u []
                  let {
                    sat_sdIsv [Occ=Once] :: c_adHWv
                    [LclId] =
                        [ds_sdIsf] \u []
                            case ds_sdIsf of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdIsu [Occ=Once] -> b1_sdIsu;
                            };
                  } in  g_sdIse sat_sdIsv; } in
        let {
          sat_sdIsq [Occ=Once] :: b_adHWu
          [LclId] =
              [f_sdIsd ds_sdIsf] \u []
                  let {
                    sat_sdIsp [Occ=Once] :: a_adHWt
                    [LclId] =
                        [ds_sdIsf] \u []
                            case ds_sdIsf of {
                              (,,) _ [Occ=Dead] a1_sdIsn [Occ=Once] _ [Occ=Dead] -> a1_sdIsn;
                            };
                  } in  f_sdIsd sat_sdIsp; } in
        let {
          sat_sdIsk [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdIsf] \u []
                  case ds_sdIsf of {
                    (,,) x2_sdIsh [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdIsh;
                  };
        } in  (,,) [sat_sdIsk sat_sdIsq sat_sdIsw];

Data.Bifunctor.$fBifunctor(,,,)_$cbimap
  :: forall x1 x2 a b c d.
     (a -> b) -> (c -> d) -> (x1, x2, a, c) -> (x1, x2, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIsx g_sdIsy ds_sdIsz]
        let {
          sat_sdIsZ [Occ=Once] :: d_adHVX
          [LclId] =
              [g_sdIsy ds_sdIsz] \u []
                  let {
                    sat_sdIsY [Occ=Once] :: c_adHVW
                    [LclId] =
                        [ds_sdIsz] \u []
                            case ds_sdIsz of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdIsX [Occ=Once] ->
                                  b1_sdIsX;
                            };
                  } in  g_sdIsy sat_sdIsY; } in
        let {
          sat_sdIsS [Occ=Once] :: b_adHVV
          [LclId] =
              [f_sdIsx ds_sdIsz] \u []
                  let {
                    sat_sdIsR [Occ=Once] :: a_adHVU
                    [LclId] =
                        [ds_sdIsz] \u []
                            case ds_sdIsz of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdIsP [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdIsP;
                            };
                  } in  f_sdIsx sat_sdIsR; } in
        let {
          sat_sdIsL [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdIsz] \u []
                  case ds_sdIsz of {
                    (,,,) _ [Occ=Dead] x5_sdIsI [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdIsI;
                  }; } in
        let {
          sat_sdIsF [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdIsz] \u []
                  case ds_sdIsz of {
                    (,,,) x4_sdIsB [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdIsB;
                  };
        } in  (,,,) [sat_sdIsF sat_sdIsL sat_sdIsS sat_sdIsZ];

Data.Bifunctor.$fBifunctor(,,,,)_$cbimap
  :: forall x1 x2 x3 a b c d.
     (a -> b) -> (c -> d) -> (x1, x2, x3, a, c) -> (x1, x2, x3, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIt0 g_sdIt1 ds_sdIt2]
        let {
          sat_sdItD [Occ=Once] :: d_adHVn
          [LclId] =
              [g_sdIt1 ds_sdIt2] \u []
                  let {
                    sat_sdItC [Occ=Once] :: c_adHVm
                    [LclId] =
                        [ds_sdIt2] \u []
                            case ds_sdIt2 of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdItB [Occ=Once] ->
                                  b1_sdItB;
                            };
                  } in  g_sdIt1 sat_sdItC; } in
        let {
          sat_sdItv [Occ=Once] :: b_adHVl
          [LclId] =
              [f_sdIt0 ds_sdIt2] \u []
                  let {
                    sat_sdItu [Occ=Once] :: a_adHVk
                    [LclId] =
                        [ds_sdIt2] \u []
                            case ds_sdIt2 of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdIts [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdIts;
                            };
                  } in  f_sdIt0 sat_sdItu; } in
        let {
          sat_sdItn [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdIt2] \u []
                  case ds_sdIt2 of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdItk [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdItk;
                  }; } in
        let {
          sat_sdItg [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdIt2] \u []
                  case ds_sdIt2 of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdItc [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdItc;
                  }; } in
        let {
          sat_sdIt9 [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdIt2] \u []
                  case ds_sdIt2 of {
                    (,,,,) x4_sdIt4 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdIt4;
                  };
        } in  (,,,,) [sat_sdIt9 sat_sdItg sat_sdItn sat_sdItv sat_sdItD];

Data.Bifunctor.$fBifunctor(,,,,,)_$cbimap [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 a b c d.
     (a -> b)
     -> (c -> d) -> (x1, x2, x3, x4, a, c) -> (x1, x2, x3, x4, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdItE w1_sdItF w2_sdItG]
        let {
          sat_sdIuu [Occ=Once] :: d_sdId6
          [LclId] =
              [w1_sdItF w2_sdItG] \u []
                  let {
                    sat_sdIut [Occ=Once] :: c_sdId5
                    [LclId] =
                        [w2_sdItG] \u []
                            case w2_sdItG of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdIus [Occ=Once] ->
                                  b1_sdIus;
                            };
                  } in  w1_sdItF sat_sdIut; } in
        let {
          sat_sdIul [Occ=Once] :: b_sdId4
          [LclId] =
              [w_sdItE w2_sdItG] \u []
                  let {
                    sat_sdIuk [Occ=Once] :: a_sdId3
                    [LclId] =
                        [w2_sdItG] \u []
                            case w2_sdItG of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdIui [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdIui;
                            };
                  } in  w_sdItE sat_sdIuk; } in
        let {
          sat_sdIuc [Occ=Once] :: x4_sdId2
          [LclId] =
              [w2_sdItG] \u []
                  case w2_sdItG of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdIu9 [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdIu9;
                  }; } in
        let {
          sat_sdIu4 [Occ=Once] :: x3_sdId1
          [LclId] =
              [w2_sdItG] \u []
                  case w2_sdItG of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdIu0 [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdIu0;
                  }; } in
        let {
          sat_sdItW [Occ=Once] :: x2_sdId0
          [LclId] =
              [w2_sdItG] \u []
                  case w2_sdItG of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdItR [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdItR;
                  }; } in
        let {
          sat_sdItO [Occ=Once] :: x1_sdIcZ
          [LclId] =
              [w2_sdItG] \u []
                  case w2_sdItG of {
                    (,,,,,) x7_sdItI [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdItI;
                  };
        } in 
          (,,,,,) [sat_sdItO
                   sat_sdItW
                   sat_sdIu4
                   sat_sdIuc
                   sat_sdIul
                   sat_sdIuu];

Data.Bifunctor.$fBifunctor(,,,,,,)_$cbimap [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 a b c d.
     (a -> b)
     -> (c -> d)
     -> (x1, x2, x3, x4, x5, a, c)
     -> (x1, x2, x3, x4, x5, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdIuv w1_sdIuw w2_sdIux]
        let {
          sat_sdIvA [Occ=Once] :: d_sdIdm
          [LclId] =
              [w1_sdIuw w2_sdIux] \u []
                  let {
                    sat_sdIvz [Occ=Once] :: c_sdIdl
                    [LclId] =
                        [w2_sdIux] \u []
                            case w2_sdIux of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdIvy [Occ=Once] ->
                                  b1_sdIvy;
                            };
                  } in  w1_sdIuw sat_sdIvz; } in
        let {
          sat_sdIvq [Occ=Once] :: b_sdIdk
          [LclId] =
              [w_sdIuv w2_sdIux] \u []
                  let {
                    sat_sdIvp [Occ=Once] :: a_sdIdj
                    [LclId] =
                        [w2_sdIux] \u []
                            case w2_sdIux of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdIvn [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdIvn;
                            };
                  } in  w_sdIuv sat_sdIvp; } in
        let {
          sat_sdIvg [Occ=Once] :: x5_sdIdi
          [LclId] =
              [w2_sdIux] \u []
                  case w2_sdIux of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdIvd [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdIvd;
                  }; } in
        let {
          sat_sdIv7 [Occ=Once] :: x4_sdIdh
          [LclId] =
              [w2_sdIux] \u []
                  case w2_sdIux of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdIv3 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdIv3;
                  }; } in
        let {
          sat_sdIuY [Occ=Once] :: x3_sdIdg
          [LclId] =
              [w2_sdIux] \u []
                  case w2_sdIux of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdIuT [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdIuT;
                  }; } in
        let {
          sat_sdIuP [Occ=Once] :: x2_sdIdf
          [LclId] =
              [w2_sdIux] \u []
                  case w2_sdIux of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdIuJ [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdIuJ;
                  }; } in
        let {
          sat_sdIuG [Occ=Once] :: x1_sdIde
          [LclId] =
              [w2_sdIux] \u []
                  case w2_sdIux of {
                    (,,,,,,) x7_sdIuz [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdIuz;
                  };
        } in 
          (,,,,,,) [sat_sdIuG
                    sat_sdIuP
                    sat_sdIuY
                    sat_sdIv7
                    sat_sdIvg
                    sat_sdIvq
                    sat_sdIvA];

Data.Bifunctor.$fBifunctorEither_$cbimap
  :: forall a b c d.
     (a -> b)
     -> (c -> d) -> Data.Either.Either a c -> Data.Either.Either b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdIvB ds_sdIvC ds1_sdIvD]
        case ds1_sdIvD of {
          Data.Either.Left a1_sdIvF [Occ=Once] ->
              let {
                sat_sdIvG [Occ=Once] :: b_adHTr
                [LclId] =
                    [f_sdIvB a1_sdIvF] \u [] f_sdIvB a1_sdIvF;
              } in  Data.Either.Left [sat_sdIvG];
          Data.Either.Right b1_sdIvH [Occ=Once] ->
              let {
                sat_sdIvI [Occ=Once] :: d_adHTt
                [LclId] =
                    [ds_sdIvC b1_sdIvH] \u [] ds_sdIvC b1_sdIvH;
              } in  Data.Either.Right [sat_sdIvI];
        };

Data.Bifunctor.$fBifunctorConst3
  :: forall a b c d.
     (a -> b) -> (c -> d) -> Data.Functor.Const.Const a c -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdIvJ ds_sdIvK ds1_sdIvL] f_sdIvJ ds1_sdIvL;

Data.Bifunctor.$fBifunctorK4
  :: forall i a b c d.
     (a -> b) -> (c -> d) -> GHC.Generics.K1 i a c -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdIvM ds_sdIvN ds1_sdIvO] f_sdIvM ds1_sdIvO;

Data.Bifunctor.$dmsecond
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall b c a. (b -> c) -> p a b -> p a c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdIvP]
        Data.Bifunctor.bimap $dBifunctor_sdIvP GHC.Base.id;

Data.Bifunctor.$dmfirst
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c. (a -> b) -> p a c -> p b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdIvQ f_sdIvR]
        Data.Bifunctor.bimap $dBifunctor_sdIvQ f_sdIvR GHC.Base.id;

Data.Bifunctor.$fBifunctorK3
  :: forall c a i b. (a -> b) -> GHC.Generics.K1 i a c -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdIvS ds_sdIvT] f_sdIvS ds_sdIvT;

Data.Bifunctor.$fBifunctorK2
  :: forall b a i c.
     (b -> c) -> GHC.Generics.K1 i a b -> GHC.Generics.K1 i a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdIvU ds1_sdIvV] ds1_sdIvV;

Data.Bifunctor.$fBifunctorK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bifunctor.Bifunctor (GHC.Generics.K1 i)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorK4
                                               Data.Bifunctor.$fBifunctorK3
                                               Data.Bifunctor.$fBifunctorK2];

Data.Bifunctor.$fBifunctorConst2
  :: forall c a b. (a -> b) -> Data.Functor.Const.Const a c -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdIvW ds_sdIvX] f_sdIvW ds_sdIvX;

Data.Bifunctor.$fBifunctorConst1
  :: forall b a c.
     (b -> c)
     -> Data.Functor.Const.Const a b -> Data.Functor.Const.Const a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdIvY ds1_sdIvZ] ds1_sdIvZ;

Data.Bifunctor.$fBifunctorConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorConst3
                                               Data.Bifunctor.$fBifunctorConst2
                                               Data.Bifunctor.$fBifunctorConst1];

Data.Bifunctor.$fBifunctorEither_$cfirst
  :: forall a b c.
     (a -> b) -> Data.Either.Either a c -> Data.Either.Either b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdIw0 ds_sdIw1]
        case ds_sdIw1 of {
          Data.Either.Left a1_sdIw3 [Occ=Once] ->
              let {
                sat_sdIw4 [Occ=Once] :: b_adHTD
                [LclId] =
                    [f_sdIw0 a1_sdIw3] \u [] f_sdIw0 a1_sdIw3;
              } in  Data.Either.Left [sat_sdIw4];
          Data.Either.Right b1_sdIw5 [Occ=Once] -> wild_sdIw2;
        };

Data.Bifunctor.$fBifunctorEither_$csecond
  :: forall b c a.
     (b -> c) -> Data.Either.Either a b -> Data.Either.Either a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdIw6 ds1_sdIw7]
        case ds1_sdIw7 of {
          Data.Either.Left a1_sdIw9 [Occ=Once] -> wild_sdIw8;
          Data.Either.Right b1_sdIwa [Occ=Once] ->
              let {
                sat_sdIwb [Occ=Once] :: c_adHTP
                [LclId] =
                    [ds_sdIw6 b1_sdIwa] \u [] ds_sdIw6 b1_sdIwa;
              } in  Data.Either.Right [sat_sdIwb];
        };

Data.Bifunctor.$fBifunctorEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorEither_$cbimap
                                               Data.Bifunctor.$fBifunctorEither_$cfirst
                                               Data.Bifunctor.$fBifunctorEither_$csecond];

Data.Bifunctor.$fBifunctor(,,,,,,)_$cfirst [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 a b c.
     (a -> b)
     -> (x1, x2, x3, x4, x5, a, c) -> (x1, x2, x3, x4, x5, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdIwc w1_sdIwd]
        let {
          sat_sdIxf [Occ=Once] :: c_sdIdB
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b1_sdIxe [Occ=Once] ->
                        b1_sdIxe;
                  }; } in
        let {
          sat_sdIx6 [Occ=Once] :: b_sdIdA
          [LclId] =
              [w_sdIwc w1_sdIwd] \u []
                  let {
                    sat_sdIx5 [Occ=Once] :: a_sdIdz
                    [LclId] =
                        [w1_sdIwd] \u []
                            case w1_sdIwd of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdIx3 [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdIx3;
                            };
                  } in  w_sdIwc sat_sdIx5; } in
        let {
          sat_sdIwW [Occ=Once] :: x5_sdIdy
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdIwT [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdIwT;
                  }; } in
        let {
          sat_sdIwN [Occ=Once] :: x4_sdIdx
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdIwJ [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdIwJ;
                  }; } in
        let {
          sat_sdIwE [Occ=Once] :: x3_sdIdw
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdIwz [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdIwz;
                  }; } in
        let {
          sat_sdIwv [Occ=Once] :: x2_sdIdv
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdIwp [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdIwp;
                  }; } in
        let {
          sat_sdIwm [Occ=Once] :: x1_sdIdu
          [LclId] =
              [w1_sdIwd] \u []
                  case w1_sdIwd of {
                    (,,,,,,) x7_sdIwf [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdIwf;
                  };
        } in 
          (,,,,,,) [sat_sdIwm
                    sat_sdIwv
                    sat_sdIwE
                    sat_sdIwN
                    sat_sdIwW
                    sat_sdIx6
                    sat_sdIxf];

Data.Bifunctor.$fBifunctor(,,,,,,)_$csecond [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 b c a.
     (b -> c)
     -> (x1, x2, x3, x4, x5, a, b) -> (x1, x2, x3, x4, x5, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdIxg w1_sdIxh]
        let {
          sat_sdIyj [Occ=Once] :: c_sdIdO
          [LclId] =
              [w_sdIxg w1_sdIxh] \u []
                  let {
                    sat_sdIyi [Occ=Once] :: b_sdIdN
                    [LclId] =
                        [w1_sdIxh] \u []
                            case w1_sdIxh of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdIyh [Occ=Once] ->
                                  b1_sdIyh;
                            };
                  } in  w_sdIxg sat_sdIyi; } in
        let {
          sat_sdIy9 [Occ=Once] :: a_sdIdP
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a1_sdIy7 [Occ=Once]
                             _ [Occ=Dead] ->
                        a1_sdIy7;
                  }; } in
        let {
          sat_sdIy0 [Occ=Once] :: x5_sdIdM
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdIxX [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdIxX;
                  }; } in
        let {
          sat_sdIxR [Occ=Once] :: x4_sdIdL
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdIxN [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdIxN;
                  }; } in
        let {
          sat_sdIxI [Occ=Once] :: x3_sdIdK
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdIxD [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdIxD;
                  }; } in
        let {
          sat_sdIxz [Occ=Once] :: x2_sdIdJ
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdIxt [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdIxt;
                  }; } in
        let {
          sat_sdIxq [Occ=Once] :: x1_sdIdI
          [LclId] =
              [w1_sdIxh] \u []
                  case w1_sdIxh of {
                    (,,,,,,) x7_sdIxj [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdIxj;
                  };
        } in 
          (,,,,,,) [sat_sdIxq
                    sat_sdIxz
                    sat_sdIxI
                    sat_sdIxR
                    sat_sdIy0
                    sat_sdIy9
                    sat_sdIyj];

Data.Bifunctor.$fBifunctor(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3 x4 x5.
     Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,,,)_$cfirst
  :: forall x1 x2 x3 x4 a b c.
     (a -> b) -> (x1, x2, x3, x4, a, c) -> (x1, x2, x3, x4, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIyk ds_sdIyl]
        let {
          sat_sdIz8 [Occ=Once] :: c_adHUT
          [LclId] =
              [ds_sdIyl] \u []
                  case ds_sdIyl of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b1_sdIz7 [Occ=Once] ->
                        b1_sdIz7;
                  }; } in
        let {
          sat_sdIz0 [Occ=Once] :: b_adHUS
          [LclId] =
              [f_sdIyk ds_sdIyl] \u []
                  let {
                    sat_sdIyZ [Occ=Once] :: a_adHUR
                    [LclId] =
                        [ds_sdIyl] \u []
                            case ds_sdIyl of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdIyX [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdIyX;
                            };
                  } in  f_sdIyk sat_sdIyZ; } in
        let {
          sat_sdIyR [Occ=Once] :: x4_adHUF
          [LclId] =
              [ds_sdIyl] \u []
                  case ds_sdIyl of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdIyO [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdIyO;
                  }; } in
        let {
          sat_sdIyJ [Occ=Once] :: x3_adHUE
          [LclId] =
              [ds_sdIyl] \u []
                  case ds_sdIyl of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdIyF [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdIyF;
                  }; } in
        let {
          sat_sdIyB [Occ=Once] :: x2_adHUD
          [LclId] =
              [ds_sdIyl] \u []
                  case ds_sdIyl of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdIyw [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdIyw;
                  }; } in
        let {
          sat_sdIyt [Occ=Once] :: x1_adHUC
          [LclId] =
              [ds_sdIyl] \u []
                  case ds_sdIyl of {
                    (,,,,,) x7_sdIyn [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdIyn;
                  };
        } in 
          (,,,,,) [sat_sdIyt
                   sat_sdIyB
                   sat_sdIyJ
                   sat_sdIyR
                   sat_sdIz0
                   sat_sdIz8];

Data.Bifunctor.$fBifunctor(,,,,,)_$csecond
  :: forall x1 x2 x3 x4 b c a.
     (b -> c) -> (x1, x2, x3, x4, a, b) -> (x1, x2, x3, x4, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdIz9 ds_sdIza]
        let {
          sat_sdIzX [Occ=Once] :: c_adHV4
          [LclId] =
              [g_sdIz9 ds_sdIza] \u []
                  let {
                    sat_sdIzW [Occ=Once] :: b_adHV3
                    [LclId] =
                        [ds_sdIza] \u []
                            case ds_sdIza of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdIzV [Occ=Once] ->
                                  b1_sdIzV;
                            };
                  } in  g_sdIz9 sat_sdIzW; } in
        let {
          sat_sdIzO [Occ=Once] :: a_adHV5
          [LclId] =
              [ds_sdIza] \u []
                  case ds_sdIza of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a1_sdIzM [Occ=Once]
                            _ [Occ=Dead] ->
                        a1_sdIzM;
                  }; } in
        let {
          sat_sdIzG [Occ=Once] :: x4_adHUF
          [LclId] =
              [ds_sdIza] \u []
                  case ds_sdIza of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdIzD [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdIzD;
                  }; } in
        let {
          sat_sdIzy [Occ=Once] :: x3_adHUE
          [LclId] =
              [ds_sdIza] \u []
                  case ds_sdIza of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdIzu [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdIzu;
                  }; } in
        let {
          sat_sdIzq [Occ=Once] :: x2_adHUD
          [LclId] =
              [ds_sdIza] \u []
                  case ds_sdIza of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdIzl [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdIzl;
                  }; } in
        let {
          sat_sdIzi [Occ=Once] :: x1_adHUC
          [LclId] =
              [ds_sdIza] \u []
                  case ds_sdIza of {
                    (,,,,,) x7_sdIzc [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdIzc;
                  };
        } in 
          (,,,,,) [sat_sdIzi
                   sat_sdIzq
                   sat_sdIzy
                   sat_sdIzG
                   sat_sdIzO
                   sat_sdIzX];

Data.Bifunctor.$fBifunctor(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3 x4.
     Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,,)_$cfirst
  :: forall x1 x2 x3 a b c.
     (a -> b) -> (x1, x2, x3, a, c) -> (x1, x2, x3, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIzY ds_sdIzZ]
        let {
          sat_sdIAz [Occ=Once] :: c_adHVu
          [LclId] =
              [ds_sdIzZ] \u []
                  case ds_sdIzZ of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b1_sdIAy [Occ=Once] ->
                        b1_sdIAy;
                  }; } in
        let {
          sat_sdIAs [Occ=Once] :: b_adHVt
          [LclId] =
              [f_sdIzY ds_sdIzZ] \u []
                  let {
                    sat_sdIAr [Occ=Once] :: a_adHVs
                    [LclId] =
                        [ds_sdIzZ] \u []
                            case ds_sdIzZ of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdIAp [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdIAp;
                            };
                  } in  f_sdIzY sat_sdIAr; } in
        let {
          sat_sdIAk [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdIzZ] \u []
                  case ds_sdIzZ of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdIAh [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdIAh;
                  }; } in
        let {
          sat_sdIAd [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdIzZ] \u []
                  case ds_sdIzZ of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdIA9 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdIA9;
                  }; } in
        let {
          sat_sdIA6 [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdIzZ] \u []
                  case ds_sdIzZ of {
                    (,,,,) x4_sdIA1 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdIA1;
                  };
        } in  (,,,,) [sat_sdIA6 sat_sdIAd sat_sdIAk sat_sdIAs sat_sdIAz];

Data.Bifunctor.$fBifunctor(,,,,)_$csecond
  :: forall x1 x2 x3 b c a.
     (b -> c) -> (x1, x2, x3, a, b) -> (x1, x2, x3, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdIAA ds_sdIAB]
        let {
          sat_sdIBb [Occ=Once] :: c_adHVF
          [LclId] =
              [g_sdIAA ds_sdIAB] \u []
                  let {
                    sat_sdIBa [Occ=Once] :: b_adHVE
                    [LclId] =
                        [ds_sdIAB] \u []
                            case ds_sdIAB of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdIB9 [Occ=Once] ->
                                  b1_sdIB9;
                            };
                  } in  g_sdIAA sat_sdIBa; } in
        let {
          sat_sdIB3 [Occ=Once] :: a_adHVG
          [LclId] =
              [ds_sdIAB] \u []
                  case ds_sdIAB of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a1_sdIB1 [Occ=Once]
                           _ [Occ=Dead] ->
                        a1_sdIB1;
                  }; } in
        let {
          sat_sdIAW [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdIAB] \u []
                  case ds_sdIAB of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdIAT [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdIAT;
                  }; } in
        let {
          sat_sdIAP [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdIAB] \u []
                  case ds_sdIAB of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdIAL [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdIAL;
                  }; } in
        let {
          sat_sdIAI [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdIAB] \u []
                  case ds_sdIAB of {
                    (,,,,) x4_sdIAD [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdIAD;
                  };
        } in  (,,,,) [sat_sdIAI sat_sdIAP sat_sdIAW sat_sdIB3 sat_sdIBb];

Data.Bifunctor.$fBifunctor(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3. Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,)_$cfirst
  :: forall x1 x2 a b c. (a -> b) -> (x1, x2, a, c) -> (x1, x2, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIBc ds_sdIBd]
        let {
          sat_sdIBC [Occ=Once] :: c_adHW4
          [LclId] =
              [ds_sdIBd] \u []
                  case ds_sdIBd of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdIBB [Occ=Once] ->
                        b1_sdIBB;
                  }; } in
        let {
          sat_sdIBw [Occ=Once] :: b_adHW3
          [LclId] =
              [f_sdIBc ds_sdIBd] \u []
                  let {
                    sat_sdIBv [Occ=Once] :: a_adHW2
                    [LclId] =
                        [ds_sdIBd] \u []
                            case ds_sdIBd of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdIBt [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdIBt;
                            };
                  } in  f_sdIBc sat_sdIBv; } in
        let {
          sat_sdIBp [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdIBd] \u []
                  case ds_sdIBd of {
                    (,,,) _ [Occ=Dead] x5_sdIBm [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdIBm;
                  }; } in
        let {
          sat_sdIBj [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdIBd] \u []
                  case ds_sdIBd of {
                    (,,,) x4_sdIBf [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdIBf;
                  };
        } in  (,,,) [sat_sdIBj sat_sdIBp sat_sdIBw sat_sdIBC];

Data.Bifunctor.$fBifunctor(,,,)_$csecond
  :: forall x1 x2 b c a. (b -> c) -> (x1, x2, a, b) -> (x1, x2, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdIBD ds_sdIBE]
        let {
          sat_sdIC3 [Occ=Once] :: c_adHWf
          [LclId] =
              [g_sdIBD ds_sdIBE] \u []
                  let {
                    sat_sdIC2 [Occ=Once] :: b_adHWe
                    [LclId] =
                        [ds_sdIBE] \u []
                            case ds_sdIBE of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdIC1 [Occ=Once] ->
                                  b1_sdIC1;
                            };
                  } in  g_sdIBD sat_sdIC2; } in
        let {
          sat_sdIBW [Occ=Once] :: a_adHWg
          [LclId] =
              [ds_sdIBE] \u []
                  case ds_sdIBE of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdIBU [Occ=Once] _ [Occ=Dead] ->
                        a1_sdIBU;
                  }; } in
        let {
          sat_sdIBQ [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdIBE] \u []
                  case ds_sdIBE of {
                    (,,,) _ [Occ=Dead] x5_sdIBN [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdIBN;
                  }; } in
        let {
          sat_sdIBK [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdIBE] \u []
                  case ds_sdIBE of {
                    (,,,) x4_sdIBG [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdIBG;
                  };
        } in  (,,,) [sat_sdIBK sat_sdIBQ sat_sdIBW sat_sdIC3];

Data.Bifunctor.$fBifunctor(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2. Data.Bifunctor.Bifunctor ((,,,) x1 x2)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,)_$cfirst
  :: forall x1 a b c. (a -> b) -> (x1, a, c) -> (x1, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdIC4 ds_sdIC5]
        let {
          sat_sdICl [Occ=Once] :: c_adHWD
          [LclId] =
              [ds_sdIC5] \u []
                  case ds_sdIC5 of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdICk [Occ=Once] -> b1_sdICk;
                  }; } in
        let {
          sat_sdICg [Occ=Once] :: b_adHWC
          [LclId] =
              [f_sdIC4 ds_sdIC5] \u []
                  let {
                    sat_sdICf [Occ=Once] :: a_adHWB
                    [LclId] =
                        [ds_sdIC5] \u []
                            case ds_sdIC5 of {
                              (,,) _ [Occ=Dead] a1_sdICd [Occ=Once] _ [Occ=Dead] -> a1_sdICd;
                            };
                  } in  f_sdIC4 sat_sdICf; } in
        let {
          sat_sdICa [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdIC5] \u []
                  case ds_sdIC5 of {
                    (,,) x2_sdIC7 [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdIC7;
                  };
        } in  (,,) [sat_sdICa sat_sdICg sat_sdICl];

Data.Bifunctor.$fBifunctor(,,)_$csecond
  :: forall x1 b c a. (b -> c) -> (x1, a, b) -> (x1, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdICm ds_sdICn]
        let {
          sat_sdICD [Occ=Once] :: c_adHWO
          [LclId] =
              [g_sdICm ds_sdICn] \u []
                  let {
                    sat_sdICC [Occ=Once] :: b_adHWN
                    [LclId] =
                        [ds_sdICn] \u []
                            case ds_sdICn of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdICB [Occ=Once] -> b1_sdICB;
                            };
                  } in  g_sdICm sat_sdICC; } in
        let {
          sat_sdICx [Occ=Once] :: a_adHWP
          [LclId] =
              [ds_sdICn] \u []
                  case ds_sdICn of {
                    (,,) _ [Occ=Dead] a1_sdICv [Occ=Once] _ [Occ=Dead] -> a1_sdICv;
                  }; } in
        let {
          sat_sdICs [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdICn] \u []
                  case ds_sdICn of {
                    (,,) x2_sdICp [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdICp;
                  };
        } in  (,,) [sat_sdICs sat_sdICx sat_sdICD];

Data.Bifunctor.$fBifunctor(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1. Data.Bifunctor.Bifunctor ((,,) x1)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,)_$csecond];

Data.Bifunctor.$fBifunctor(,)_$cfirst
  :: forall a b c. (a -> b) -> (a, c) -> (b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdICE ds_sdICF]
        let {
          sat_sdICO [Occ=Once] :: c_adHXb
          [LclId] =
              [ds_sdICF] \u []
                  case ds_sdICF of {
                    (,) _ [Occ=Dead] b1_sdICN [Occ=Once] -> b1_sdICN;
                  }; } in
        let {
          sat_sdICK [Occ=Once] :: b_adHXa
          [LclId] =
              [f_sdICE ds_sdICF] \u []
                  let {
                    sat_sdICJ [Occ=Once] :: a_adHX9
                    [LclId] =
                        [ds_sdICF] \u []
                            case ds_sdICF of {
                              (,) a1_sdICH [Occ=Once] _ [Occ=Dead] -> a1_sdICH;
                            };
                  } in  f_sdICE sat_sdICJ;
        } in  (,) [sat_sdICK sat_sdICO];

Data.Bifunctor.$fBifunctor(,)_$csecond
  :: forall b c a. (b -> c) -> (a, b) -> (a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdICP ds_sdICQ]
        let {
          sat_sdICZ [Occ=Once] :: c_adHXm
          [LclId] =
              [g_sdICP ds_sdICQ] \u []
                  let {
                    sat_sdICY [Occ=Once] :: b_adHXl
                    [LclId] =
                        [ds_sdICQ] \u []
                            case ds_sdICQ of {
                              (,) _ [Occ=Dead] b1_sdICX [Occ=Once] -> b1_sdICX;
                            };
                  } in  g_sdICP sat_sdICY; } in
        let {
          sat_sdICU [Occ=Once] :: a_adHXn
          [LclId] =
              [ds_sdICQ] \u []
                  case ds_sdICQ of {
                    (,) a1_sdICS [Occ=Once] _ [Occ=Dead] -> a1_sdICS;
                  };
        } in  (,) [sat_sdICU sat_sdICZ];

Data.Bifunctor.$fBifunctor(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,)_$csecond];

Data.Bifunctor.$dmbimap
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(C(U)),1*C1(C(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdID0 f_sdID1 g_sdID2]
        let {
          f1_sdID3 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: p_adHMW a_adHRn d_adHRq -> p_adHMW b_adHRo d_adHRq
          [LclId] =
              [$dBifunctor_sdID0 f_sdID1] \u []
                  Data.Bifunctor.first $dBifunctor_sdID0 f_sdID1; } in
        let {
          g1_sdID4 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: p_adHMW a_adHRn c_adHRp -> p_adHMW a_adHRn d_adHRq
          [LclId] =
              [$dBifunctor_sdID0 g_sdID2] \u []
                  Data.Bifunctor.second $dBifunctor_sdID0 g_sdID2; } in
        let {
          sat_sdID7 [Occ=OnceT[0]]
            :: p_adHMW a_adHRn c_adHRp -> p_adHMW b_adHRo d_adHRq
          [LclId] =
              [f1_sdID3 g1_sdID4] \r [x_sdID5]
                  let {
                    sat_sdID6 [Occ=Once] :: p_adHMW a_adHRn d_adHRq
                    [LclId] =
                        [g1_sdID4 x_sdID5] \u [] g1_sdID4 x_sdID5;
                  } in  f1_sdID3 sat_sdID6;
        } in  sat_sdID7;

Data.Bifunctor.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bifunctor.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$trModule4];

Data.Bifunctor.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bifunctor"#;

Data.Bifunctor.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$trModule2];

Data.Bifunctor.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bifunctor.$trModule3
                                     Data.Bifunctor.$trModule1];

$krep_rdIrJ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bifunctor.$tcBifunctor1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdIrJ];

Data.Bifunctor.$tcBifunctor3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bifunctor"#;

Data.Bifunctor.$tcBifunctor2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$tcBifunctor3];

Data.Bifunctor.$tcBifunctor :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15833243383698227199##
                                    9927729778853233711##
                                    Data.Bifunctor.$trModule
                                    Data.Bifunctor.$tcBifunctor2
                                    0#
                                    Data.Bifunctor.$tcBifunctor1];

Data.Bifunctor.C:Bifunctor
  :: forall (p :: * -> * -> *).
     (forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d)
     -> (forall a b c. (a -> b) -> p a c -> p b c)
     -> (forall b c a. (b -> c) -> p a b -> p a c)
     -> Data.Bifunctor.Bifunctor p
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifunctor.C:Bifunctor [eta_B3 eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:08:57.695572734 UTC

Data.Bifunctor.bimap
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sdJhS]
        case v_sdJhS of {
          Data.Bifunctor.C:Bifunctor v_sdJhU [Occ=Once]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead] ->
              v_sdJhU;
        };

Data.Bifunctor.first
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c. (a -> b) -> p a c -> p b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sdJhX]
        case v_sdJhX of {
          Data.Bifunctor.C:Bifunctor _ [Occ=Dead]
                                     v_sdJi0 [Occ=Once]
                                     _ [Occ=Dead] ->
              v_sdJi0;
        };

Data.Bifunctor.second
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall b c a. (b -> c) -> p a b -> p a c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sdJi2]
        case v_sdJi2 of {
          Data.Bifunctor.C:Bifunctor _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     v_sdJi6 [Occ=Once] ->
              v_sdJi6;
        };

Data.Bifunctor.$fBifunctor(,)_$cbimap
  :: forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJi7 g_sdJi8 ds_sdJi9]
        let {
          sat_sdJij [Occ=Once] :: d_adHX4
          [LclId] =
              [g_sdJi8 ds_sdJi9] \u []
                  let {
                    sat_sdJii [Occ=Once] :: c_adHX3
                    [LclId] =
                        [ds_sdJi9] \u []
                            case ds_sdJi9 of {
                              (,) _ [Occ=Dead] b1_sdJih [Occ=Once] -> b1_sdJih;
                            };
                  } in  g_sdJi8 sat_sdJii; } in
        let {
          sat_sdJie [Occ=Once] :: b_adHX2
          [LclId] =
              [f_sdJi7 ds_sdJi9] \u []
                  let {
                    sat_sdJid [Occ=Once] :: a_adHX1
                    [LclId] =
                        [ds_sdJi9] \u []
                            case ds_sdJi9 of {
                              (,) a1_sdJib [Occ=Once] _ [Occ=Dead] -> a1_sdJib;
                            };
                  } in  f_sdJi7 sat_sdJid;
        } in  (,) [sat_sdJie sat_sdJij];

Data.Bifunctor.$fBifunctor(,,)_$cbimap
  :: forall x1 a b c d.
     (a -> b) -> (c -> d) -> (x1, a, c) -> (x1, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJik g_sdJil ds_sdJim]
        let {
          sat_sdJiD [Occ=Once] :: d_adHWw
          [LclId] =
              [g_sdJil ds_sdJim] \u []
                  let {
                    sat_sdJiC [Occ=Once] :: c_adHWv
                    [LclId] =
                        [ds_sdJim] \u []
                            case ds_sdJim of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdJiB [Occ=Once] -> b1_sdJiB;
                            };
                  } in  g_sdJil sat_sdJiC; } in
        let {
          sat_sdJix [Occ=Once] :: b_adHWu
          [LclId] =
              [f_sdJik ds_sdJim] \u []
                  let {
                    sat_sdJiw [Occ=Once] :: a_adHWt
                    [LclId] =
                        [ds_sdJim] \u []
                            case ds_sdJim of {
                              (,,) _ [Occ=Dead] a1_sdJiu [Occ=Once] _ [Occ=Dead] -> a1_sdJiu;
                            };
                  } in  f_sdJik sat_sdJiw; } in
        let {
          sat_sdJir [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdJim] \u []
                  case ds_sdJim of {
                    (,,) x2_sdJio [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdJio;
                  };
        } in  (,,) [sat_sdJir sat_sdJix sat_sdJiD];

Data.Bifunctor.$fBifunctor(,,,)_$cbimap
  :: forall x1 x2 a b c d.
     (a -> b) -> (c -> d) -> (x1, x2, a, c) -> (x1, x2, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJiE g_sdJiF ds_sdJiG]
        let {
          sat_sdJj6 [Occ=Once] :: d_adHVX
          [LclId] =
              [g_sdJiF ds_sdJiG] \u []
                  let {
                    sat_sdJj5 [Occ=Once] :: c_adHVW
                    [LclId] =
                        [ds_sdJiG] \u []
                            case ds_sdJiG of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdJj4 [Occ=Once] ->
                                  b1_sdJj4;
                            };
                  } in  g_sdJiF sat_sdJj5; } in
        let {
          sat_sdJiZ [Occ=Once] :: b_adHVV
          [LclId] =
              [f_sdJiE ds_sdJiG] \u []
                  let {
                    sat_sdJiY [Occ=Once] :: a_adHVU
                    [LclId] =
                        [ds_sdJiG] \u []
                            case ds_sdJiG of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdJiW [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdJiW;
                            };
                  } in  f_sdJiE sat_sdJiY; } in
        let {
          sat_sdJiS [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdJiG] \u []
                  case ds_sdJiG of {
                    (,,,) _ [Occ=Dead] x5_sdJiP [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdJiP;
                  }; } in
        let {
          sat_sdJiM [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdJiG] \u []
                  case ds_sdJiG of {
                    (,,,) x4_sdJiI [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdJiI;
                  };
        } in  (,,,) [sat_sdJiM sat_sdJiS sat_sdJiZ sat_sdJj6];

Data.Bifunctor.$fBifunctor(,,,,)_$cbimap
  :: forall x1 x2 x3 a b c d.
     (a -> b) -> (c -> d) -> (x1, x2, x3, a, c) -> (x1, x2, x3, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJj7 g_sdJj8 ds_sdJj9]
        let {
          sat_sdJjK [Occ=Once] :: d_adHVn
          [LclId] =
              [g_sdJj8 ds_sdJj9] \u []
                  let {
                    sat_sdJjJ [Occ=Once] :: c_adHVm
                    [LclId] =
                        [ds_sdJj9] \u []
                            case ds_sdJj9 of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdJjI [Occ=Once] ->
                                  b1_sdJjI;
                            };
                  } in  g_sdJj8 sat_sdJjJ; } in
        let {
          sat_sdJjC [Occ=Once] :: b_adHVl
          [LclId] =
              [f_sdJj7 ds_sdJj9] \u []
                  let {
                    sat_sdJjB [Occ=Once] :: a_adHVk
                    [LclId] =
                        [ds_sdJj9] \u []
                            case ds_sdJj9 of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdJjz [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdJjz;
                            };
                  } in  f_sdJj7 sat_sdJjB; } in
        let {
          sat_sdJju [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdJj9] \u []
                  case ds_sdJj9 of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdJjr [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdJjr;
                  }; } in
        let {
          sat_sdJjn [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdJj9] \u []
                  case ds_sdJj9 of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdJjj [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdJjj;
                  }; } in
        let {
          sat_sdJjg [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdJj9] \u []
                  case ds_sdJj9 of {
                    (,,,,) x4_sdJjb [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdJjb;
                  };
        } in  (,,,,) [sat_sdJjg sat_sdJjn sat_sdJju sat_sdJjC sat_sdJjK];

Data.Bifunctor.$fBifunctor(,,,,,)_$cbimap [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 a b c d.
     (a -> b)
     -> (c -> d) -> (x1, x2, x3, x4, a, c) -> (x1, x2, x3, x4, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdJjL w1_sdJjM w2_sdJjN]
        let {
          sat_sdJkB [Occ=Once] :: d_sdId6
          [LclId] =
              [w1_sdJjM w2_sdJjN] \u []
                  let {
                    sat_sdJkA [Occ=Once] :: c_sdId5
                    [LclId] =
                        [w2_sdJjN] \u []
                            case w2_sdJjN of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdJkz [Occ=Once] ->
                                  b1_sdJkz;
                            };
                  } in  w1_sdJjM sat_sdJkA; } in
        let {
          sat_sdJks [Occ=Once] :: b_sdId4
          [LclId] =
              [w_sdJjL w2_sdJjN] \u []
                  let {
                    sat_sdJkr [Occ=Once] :: a_sdId3
                    [LclId] =
                        [w2_sdJjN] \u []
                            case w2_sdJjN of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdJkp [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdJkp;
                            };
                  } in  w_sdJjL sat_sdJkr; } in
        let {
          sat_sdJkj [Occ=Once] :: x4_sdId2
          [LclId] =
              [w2_sdJjN] \u []
                  case w2_sdJjN of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdJkg [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdJkg;
                  }; } in
        let {
          sat_sdJkb [Occ=Once] :: x3_sdId1
          [LclId] =
              [w2_sdJjN] \u []
                  case w2_sdJjN of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdJk7 [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdJk7;
                  }; } in
        let {
          sat_sdJk3 [Occ=Once] :: x2_sdId0
          [LclId] =
              [w2_sdJjN] \u []
                  case w2_sdJjN of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdJjY [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdJjY;
                  }; } in
        let {
          sat_sdJjV [Occ=Once] :: x1_sdIcZ
          [LclId] =
              [w2_sdJjN] \u []
                  case w2_sdJjN of {
                    (,,,,,) x7_sdJjP [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdJjP;
                  };
        } in 
          (,,,,,) [sat_sdJjV
                   sat_sdJk3
                   sat_sdJkb
                   sat_sdJkj
                   sat_sdJks
                   sat_sdJkB];

Data.Bifunctor.$fBifunctor(,,,,,,)_$cbimap [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 a b c d.
     (a -> b)
     -> (c -> d)
     -> (x1, x2, x3, x4, x5, a, c)
     -> (x1, x2, x3, x4, x5, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdJkC w1_sdJkD w2_sdJkE]
        let {
          sat_sdJlH [Occ=Once] :: d_sdIdm
          [LclId] =
              [w1_sdJkD w2_sdJkE] \u []
                  let {
                    sat_sdJlG [Occ=Once] :: c_sdIdl
                    [LclId] =
                        [w2_sdJkE] \u []
                            case w2_sdJkE of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdJlF [Occ=Once] ->
                                  b1_sdJlF;
                            };
                  } in  w1_sdJkD sat_sdJlG; } in
        let {
          sat_sdJlx [Occ=Once] :: b_sdIdk
          [LclId] =
              [w_sdJkC w2_sdJkE] \u []
                  let {
                    sat_sdJlw [Occ=Once] :: a_sdIdj
                    [LclId] =
                        [w2_sdJkE] \u []
                            case w2_sdJkE of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdJlu [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdJlu;
                            };
                  } in  w_sdJkC sat_sdJlw; } in
        let {
          sat_sdJln [Occ=Once] :: x5_sdIdi
          [LclId] =
              [w2_sdJkE] \u []
                  case w2_sdJkE of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdJlk [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdJlk;
                  }; } in
        let {
          sat_sdJle [Occ=Once] :: x4_sdIdh
          [LclId] =
              [w2_sdJkE] \u []
                  case w2_sdJkE of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdJla [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdJla;
                  }; } in
        let {
          sat_sdJl5 [Occ=Once] :: x3_sdIdg
          [LclId] =
              [w2_sdJkE] \u []
                  case w2_sdJkE of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdJl0 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdJl0;
                  }; } in
        let {
          sat_sdJkW [Occ=Once] :: x2_sdIdf
          [LclId] =
              [w2_sdJkE] \u []
                  case w2_sdJkE of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdJkQ [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdJkQ;
                  }; } in
        let {
          sat_sdJkN [Occ=Once] :: x1_sdIde
          [LclId] =
              [w2_sdJkE] \u []
                  case w2_sdJkE of {
                    (,,,,,,) x7_sdJkG [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdJkG;
                  };
        } in 
          (,,,,,,) [sat_sdJkN
                    sat_sdJkW
                    sat_sdJl5
                    sat_sdJle
                    sat_sdJln
                    sat_sdJlx
                    sat_sdJlH];

Data.Bifunctor.$fBifunctorEither_$cbimap
  :: forall a b c d.
     (a -> b)
     -> (c -> d) -> Data.Either.Either a c -> Data.Either.Either b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdJlI ds_sdJlJ ds1_sdJlK]
        case ds1_sdJlK of {
          Data.Either.Left a1_sdJlM [Occ=Once] ->
              let {
                sat_sdJlN [Occ=Once] :: b_adHTr
                [LclId] =
                    [f_sdJlI a1_sdJlM] \u [] f_sdJlI a1_sdJlM;
              } in  Data.Either.Left [sat_sdJlN];
          Data.Either.Right b1_sdJlO [Occ=Once] ->
              let {
                sat_sdJlP [Occ=Once] :: d_adHTt
                [LclId] =
                    [ds_sdJlJ b1_sdJlO] \u [] ds_sdJlJ b1_sdJlO;
              } in  Data.Either.Right [sat_sdJlP];
        };

Data.Bifunctor.$fBifunctorConst3
  :: forall a b c d.
     (a -> b) -> (c -> d) -> Data.Functor.Const.Const a c -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdJlQ ds_sdJlR ds1_sdJlS] f_sdJlQ ds1_sdJlS;

Data.Bifunctor.$fBifunctorK4
  :: forall i a b c d.
     (a -> b) -> (c -> d) -> GHC.Generics.K1 i a c -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdJlT ds_sdJlU ds1_sdJlV] f_sdJlT ds1_sdJlV;

Data.Bifunctor.$dmsecond
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall b c a. (b -> c) -> p a b -> p a c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdJlW]
        Data.Bifunctor.bimap $dBifunctor_sdJlW GHC.Base.id;

Data.Bifunctor.$dmfirst
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c. (a -> b) -> p a c -> p b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdJlX f_sdJlY]
        Data.Bifunctor.bimap $dBifunctor_sdJlX f_sdJlY GHC.Base.id;

Data.Bifunctor.$fBifunctorK3
  :: forall c a i b. (a -> b) -> GHC.Generics.K1 i a c -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdJlZ ds_sdJm0] f_sdJlZ ds_sdJm0;

Data.Bifunctor.$fBifunctorK2
  :: forall b a i c.
     (b -> c) -> GHC.Generics.K1 i a b -> GHC.Generics.K1 i a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdJm1 ds1_sdJm2] ds1_sdJm2;

Data.Bifunctor.$fBifunctorK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bifunctor.Bifunctor (GHC.Generics.K1 i)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorK4
                                               Data.Bifunctor.$fBifunctorK3
                                               Data.Bifunctor.$fBifunctorK2];

Data.Bifunctor.$fBifunctorConst2
  :: forall c a b. (a -> b) -> Data.Functor.Const.Const a c -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdJm3 ds_sdJm4] f_sdJm3 ds_sdJm4;

Data.Bifunctor.$fBifunctorConst1
  :: forall b a c.
     (b -> c)
     -> Data.Functor.Const.Const a b -> Data.Functor.Const.Const a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdJm5 ds1_sdJm6] ds1_sdJm6;

Data.Bifunctor.$fBifunctorConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorConst3
                                               Data.Bifunctor.$fBifunctorConst2
                                               Data.Bifunctor.$fBifunctorConst1];

Data.Bifunctor.$fBifunctorEither_$cfirst
  :: forall a b c.
     (a -> b) -> Data.Either.Either a c -> Data.Either.Either b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdJm7 ds_sdJm8]
        case ds_sdJm8 of {
          Data.Either.Left a1_sdJma [Occ=Once] ->
              let {
                sat_sdJmb [Occ=Once] :: b_adHTD
                [LclId] =
                    [f_sdJm7 a1_sdJma] \u [] f_sdJm7 a1_sdJma;
              } in  Data.Either.Left [sat_sdJmb];
          Data.Either.Right b1_sdJmc [Occ=Once] -> wild_sdJm9;
        };

Data.Bifunctor.$fBifunctorEither_$csecond
  :: forall b c a.
     (b -> c) -> Data.Either.Either a b -> Data.Either.Either a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdJmd ds1_sdJme]
        case ds1_sdJme of {
          Data.Either.Left a1_sdJmg [Occ=Once] -> wild_sdJmf;
          Data.Either.Right b1_sdJmh [Occ=Once] ->
              let {
                sat_sdJmi [Occ=Once] :: c_adHTP
                [LclId] =
                    [ds_sdJmd b1_sdJmh] \u [] ds_sdJmd b1_sdJmh;
              } in  Data.Either.Right [sat_sdJmi];
        };

Data.Bifunctor.$fBifunctorEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorEither_$cbimap
                                               Data.Bifunctor.$fBifunctorEither_$cfirst
                                               Data.Bifunctor.$fBifunctorEither_$csecond];

Data.Bifunctor.$fBifunctor(,,,,,,)_$cfirst [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 a b c.
     (a -> b)
     -> (x1, x2, x3, x4, x5, a, c) -> (x1, x2, x3, x4, x5, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdJmj w1_sdJmk]
        let {
          sat_sdJnm [Occ=Once] :: c_sdIdB
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b1_sdJnl [Occ=Once] ->
                        b1_sdJnl;
                  }; } in
        let {
          sat_sdJnd [Occ=Once] :: b_sdIdA
          [LclId] =
              [w_sdJmj w1_sdJmk] \u []
                  let {
                    sat_sdJnc [Occ=Once] :: a_sdIdz
                    [LclId] =
                        [w1_sdJmk] \u []
                            case w1_sdJmk of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdJna [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdJna;
                            };
                  } in  w_sdJmj sat_sdJnc; } in
        let {
          sat_sdJn3 [Occ=Once] :: x5_sdIdy
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdJn0 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdJn0;
                  }; } in
        let {
          sat_sdJmU [Occ=Once] :: x4_sdIdx
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdJmQ [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdJmQ;
                  }; } in
        let {
          sat_sdJmL [Occ=Once] :: x3_sdIdw
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdJmG [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdJmG;
                  }; } in
        let {
          sat_sdJmC [Occ=Once] :: x2_sdIdv
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdJmw [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdJmw;
                  }; } in
        let {
          sat_sdJmt [Occ=Once] :: x1_sdIdu
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) x7_sdJmm [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdJmm;
                  };
        } in 
          (,,,,,,) [sat_sdJmt
                    sat_sdJmC
                    sat_sdJmL
                    sat_sdJmU
                    sat_sdJn3
                    sat_sdJnd
                    sat_sdJnm];

Data.Bifunctor.$fBifunctor(,,,,,,)_$csecond [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 b c a.
     (b -> c)
     -> (x1, x2, x3, x4, x5, a, b) -> (x1, x2, x3, x4, x5, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdJnn w1_sdJno]
        let {
          sat_sdJoq [Occ=Once] :: c_sdIdO
          [LclId] =
              [w_sdJnn w1_sdJno] \u []
                  let {
                    sat_sdJop [Occ=Once] :: b_sdIdN
                    [LclId] =
                        [w1_sdJno] \u []
                            case w1_sdJno of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdJoo [Occ=Once] ->
                                  b1_sdJoo;
                            };
                  } in  w_sdJnn sat_sdJop; } in
        let {
          sat_sdJog [Occ=Once] :: a_sdIdP
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a1_sdJoe [Occ=Once]
                             _ [Occ=Dead] ->
                        a1_sdJoe;
                  }; } in
        let {
          sat_sdJo7 [Occ=Once] :: x5_sdIdM
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdJo4 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdJo4;
                  }; } in
        let {
          sat_sdJnY [Occ=Once] :: x4_sdIdL
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdJnU [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdJnU;
                  }; } in
        let {
          sat_sdJnP [Occ=Once] :: x3_sdIdK
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdJnK [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdJnK;
                  }; } in
        let {
          sat_sdJnG [Occ=Once] :: x2_sdIdJ
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdJnA [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdJnA;
                  }; } in
        let {
          sat_sdJnx [Occ=Once] :: x1_sdIdI
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) x7_sdJnq [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdJnq;
                  };
        } in 
          (,,,,,,) [sat_sdJnx
                    sat_sdJnG
                    sat_sdJnP
                    sat_sdJnY
                    sat_sdJo7
                    sat_sdJog
                    sat_sdJoq];

Data.Bifunctor.$fBifunctor(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3 x4 x5.
     Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,,,)_$cfirst
  :: forall x1 x2 x3 x4 a b c.
     (a -> b) -> (x1, x2, x3, x4, a, c) -> (x1, x2, x3, x4, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJor ds_sdJos]
        let {
          sat_sdJpf [Occ=Once] :: c_adHUT
          [LclId] =
              [ds_sdJos] \u []
                  case ds_sdJos of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b1_sdJpe [Occ=Once] ->
                        b1_sdJpe;
                  }; } in
        let {
          sat_sdJp7 [Occ=Once] :: b_adHUS
          [LclId] =
              [f_sdJor ds_sdJos] \u []
                  let {
                    sat_sdJp6 [Occ=Once] :: a_adHUR
                    [LclId] =
                        [ds_sdJos] \u []
                            case ds_sdJos of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdJp4 [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdJp4;
                            };
                  } in  f_sdJor sat_sdJp6; } in
        let {
          sat_sdJoY [Occ=Once] :: x4_adHUF
          [LclId] =
              [ds_sdJos] \u []
                  case ds_sdJos of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdJoV [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdJoV;
                  }; } in
        let {
          sat_sdJoQ [Occ=Once] :: x3_adHUE
          [LclId] =
              [ds_sdJos] \u []
                  case ds_sdJos of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdJoM [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdJoM;
                  }; } in
        let {
          sat_sdJoI [Occ=Once] :: x2_adHUD
          [LclId] =
              [ds_sdJos] \u []
                  case ds_sdJos of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdJoD [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdJoD;
                  }; } in
        let {
          sat_sdJoA [Occ=Once] :: x1_adHUC
          [LclId] =
              [ds_sdJos] \u []
                  case ds_sdJos of {
                    (,,,,,) x7_sdJou [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdJou;
                  };
        } in 
          (,,,,,) [sat_sdJoA
                   sat_sdJoI
                   sat_sdJoQ
                   sat_sdJoY
                   sat_sdJp7
                   sat_sdJpf];

Data.Bifunctor.$fBifunctor(,,,,,)_$csecond
  :: forall x1 x2 x3 x4 b c a.
     (b -> c) -> (x1, x2, x3, x4, a, b) -> (x1, x2, x3, x4, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdJpg ds_sdJph]
        let {
          sat_sdJq4 [Occ=Once] :: c_adHV4
          [LclId] =
              [g_sdJpg ds_sdJph] \u []
                  let {
                    sat_sdJq3 [Occ=Once] :: b_adHV3
                    [LclId] =
                        [ds_sdJph] \u []
                            case ds_sdJph of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdJq2 [Occ=Once] ->
                                  b1_sdJq2;
                            };
                  } in  g_sdJpg sat_sdJq3; } in
        let {
          sat_sdJpV [Occ=Once] :: a_adHV5
          [LclId] =
              [ds_sdJph] \u []
                  case ds_sdJph of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a1_sdJpT [Occ=Once]
                            _ [Occ=Dead] ->
                        a1_sdJpT;
                  }; } in
        let {
          sat_sdJpN [Occ=Once] :: x4_adHUF
          [LclId] =
              [ds_sdJph] \u []
                  case ds_sdJph of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdJpK [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdJpK;
                  }; } in
        let {
          sat_sdJpF [Occ=Once] :: x3_adHUE
          [LclId] =
              [ds_sdJph] \u []
                  case ds_sdJph of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdJpB [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdJpB;
                  }; } in
        let {
          sat_sdJpx [Occ=Once] :: x2_adHUD
          [LclId] =
              [ds_sdJph] \u []
                  case ds_sdJph of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdJps [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdJps;
                  }; } in
        let {
          sat_sdJpp [Occ=Once] :: x1_adHUC
          [LclId] =
              [ds_sdJph] \u []
                  case ds_sdJph of {
                    (,,,,,) x7_sdJpj [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdJpj;
                  };
        } in 
          (,,,,,) [sat_sdJpp
                   sat_sdJpx
                   sat_sdJpF
                   sat_sdJpN
                   sat_sdJpV
                   sat_sdJq4];

Data.Bifunctor.$fBifunctor(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3 x4.
     Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,,)_$cfirst
  :: forall x1 x2 x3 a b c.
     (a -> b) -> (x1, x2, x3, a, c) -> (x1, x2, x3, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJq5 ds_sdJq6]
        let {
          sat_sdJqG [Occ=Once] :: c_adHVu
          [LclId] =
              [ds_sdJq6] \u []
                  case ds_sdJq6 of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b1_sdJqF [Occ=Once] ->
                        b1_sdJqF;
                  }; } in
        let {
          sat_sdJqz [Occ=Once] :: b_adHVt
          [LclId] =
              [f_sdJq5 ds_sdJq6] \u []
                  let {
                    sat_sdJqy [Occ=Once] :: a_adHVs
                    [LclId] =
                        [ds_sdJq6] \u []
                            case ds_sdJq6 of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdJqw [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdJqw;
                            };
                  } in  f_sdJq5 sat_sdJqy; } in
        let {
          sat_sdJqr [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdJq6] \u []
                  case ds_sdJq6 of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdJqo [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdJqo;
                  }; } in
        let {
          sat_sdJqk [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdJq6] \u []
                  case ds_sdJq6 of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdJqg [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdJqg;
                  }; } in
        let {
          sat_sdJqd [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdJq6] \u []
                  case ds_sdJq6 of {
                    (,,,,) x4_sdJq8 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdJq8;
                  };
        } in  (,,,,) [sat_sdJqd sat_sdJqk sat_sdJqr sat_sdJqz sat_sdJqG];

Data.Bifunctor.$fBifunctor(,,,,)_$csecond
  :: forall x1 x2 x3 b c a.
     (b -> c) -> (x1, x2, x3, a, b) -> (x1, x2, x3, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdJqH ds_sdJqI]
        let {
          sat_sdJri [Occ=Once] :: c_adHVF
          [LclId] =
              [g_sdJqH ds_sdJqI] \u []
                  let {
                    sat_sdJrh [Occ=Once] :: b_adHVE
                    [LclId] =
                        [ds_sdJqI] \u []
                            case ds_sdJqI of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdJrg [Occ=Once] ->
                                  b1_sdJrg;
                            };
                  } in  g_sdJqH sat_sdJrh; } in
        let {
          sat_sdJra [Occ=Once] :: a_adHVG
          [LclId] =
              [ds_sdJqI] \u []
                  case ds_sdJqI of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a1_sdJr8 [Occ=Once]
                           _ [Occ=Dead] ->
                        a1_sdJr8;
                  }; } in
        let {
          sat_sdJr3 [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdJqI] \u []
                  case ds_sdJqI of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdJr0 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdJr0;
                  }; } in
        let {
          sat_sdJqW [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdJqI] \u []
                  case ds_sdJqI of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdJqS [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdJqS;
                  }; } in
        let {
          sat_sdJqP [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdJqI] \u []
                  case ds_sdJqI of {
                    (,,,,) x4_sdJqK [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdJqK;
                  };
        } in  (,,,,) [sat_sdJqP sat_sdJqW sat_sdJr3 sat_sdJra sat_sdJri];

Data.Bifunctor.$fBifunctor(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3. Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,)_$cfirst
  :: forall x1 x2 a b c. (a -> b) -> (x1, x2, a, c) -> (x1, x2, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJrj ds_sdJrk]
        let {
          sat_sdJrJ [Occ=Once] :: c_adHW4
          [LclId] =
              [ds_sdJrk] \u []
                  case ds_sdJrk of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdJrI [Occ=Once] ->
                        b1_sdJrI;
                  }; } in
        let {
          sat_sdJrD [Occ=Once] :: b_adHW3
          [LclId] =
              [f_sdJrj ds_sdJrk] \u []
                  let {
                    sat_sdJrC [Occ=Once] :: a_adHW2
                    [LclId] =
                        [ds_sdJrk] \u []
                            case ds_sdJrk of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdJrA [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdJrA;
                            };
                  } in  f_sdJrj sat_sdJrC; } in
        let {
          sat_sdJrw [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdJrk] \u []
                  case ds_sdJrk of {
                    (,,,) _ [Occ=Dead] x5_sdJrt [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdJrt;
                  }; } in
        let {
          sat_sdJrq [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdJrk] \u []
                  case ds_sdJrk of {
                    (,,,) x4_sdJrm [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdJrm;
                  };
        } in  (,,,) [sat_sdJrq sat_sdJrw sat_sdJrD sat_sdJrJ];

Data.Bifunctor.$fBifunctor(,,,)_$csecond
  :: forall x1 x2 b c a. (b -> c) -> (x1, x2, a, b) -> (x1, x2, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdJrK ds_sdJrL]
        let {
          sat_sdJsa [Occ=Once] :: c_adHWf
          [LclId] =
              [g_sdJrK ds_sdJrL] \u []
                  let {
                    sat_sdJs9 [Occ=Once] :: b_adHWe
                    [LclId] =
                        [ds_sdJrL] \u []
                            case ds_sdJrL of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdJs8 [Occ=Once] ->
                                  b1_sdJs8;
                            };
                  } in  g_sdJrK sat_sdJs9; } in
        let {
          sat_sdJs3 [Occ=Once] :: a_adHWg
          [LclId] =
              [ds_sdJrL] \u []
                  case ds_sdJrL of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdJs1 [Occ=Once] _ [Occ=Dead] ->
                        a1_sdJs1;
                  }; } in
        let {
          sat_sdJrX [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdJrL] \u []
                  case ds_sdJrL of {
                    (,,,) _ [Occ=Dead] x5_sdJrU [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdJrU;
                  }; } in
        let {
          sat_sdJrR [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdJrL] \u []
                  case ds_sdJrL of {
                    (,,,) x4_sdJrN [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdJrN;
                  };
        } in  (,,,) [sat_sdJrR sat_sdJrX sat_sdJs3 sat_sdJsa];

Data.Bifunctor.$fBifunctor(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2. Data.Bifunctor.Bifunctor ((,,,) x1 x2)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,)_$cfirst
  :: forall x1 a b c. (a -> b) -> (x1, a, c) -> (x1, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJsb ds_sdJsc]
        let {
          sat_sdJss [Occ=Once] :: c_adHWD
          [LclId] =
              [ds_sdJsc] \u []
                  case ds_sdJsc of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdJsr [Occ=Once] -> b1_sdJsr;
                  }; } in
        let {
          sat_sdJsn [Occ=Once] :: b_adHWC
          [LclId] =
              [f_sdJsb ds_sdJsc] \u []
                  let {
                    sat_sdJsm [Occ=Once] :: a_adHWB
                    [LclId] =
                        [ds_sdJsc] \u []
                            case ds_sdJsc of {
                              (,,) _ [Occ=Dead] a1_sdJsk [Occ=Once] _ [Occ=Dead] -> a1_sdJsk;
                            };
                  } in  f_sdJsb sat_sdJsm; } in
        let {
          sat_sdJsh [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdJsc] \u []
                  case ds_sdJsc of {
                    (,,) x2_sdJse [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdJse;
                  };
        } in  (,,) [sat_sdJsh sat_sdJsn sat_sdJss];

Data.Bifunctor.$fBifunctor(,,)_$csecond
  :: forall x1 b c a. (b -> c) -> (x1, a, b) -> (x1, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdJst ds_sdJsu]
        let {
          sat_sdJsK [Occ=Once] :: c_adHWO
          [LclId] =
              [g_sdJst ds_sdJsu] \u []
                  let {
                    sat_sdJsJ [Occ=Once] :: b_adHWN
                    [LclId] =
                        [ds_sdJsu] \u []
                            case ds_sdJsu of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdJsI [Occ=Once] -> b1_sdJsI;
                            };
                  } in  g_sdJst sat_sdJsJ; } in
        let {
          sat_sdJsE [Occ=Once] :: a_adHWP
          [LclId] =
              [ds_sdJsu] \u []
                  case ds_sdJsu of {
                    (,,) _ [Occ=Dead] a1_sdJsC [Occ=Once] _ [Occ=Dead] -> a1_sdJsC;
                  }; } in
        let {
          sat_sdJsz [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdJsu] \u []
                  case ds_sdJsu of {
                    (,,) x2_sdJsw [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdJsw;
                  };
        } in  (,,) [sat_sdJsz sat_sdJsE sat_sdJsK];

Data.Bifunctor.$fBifunctor(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1. Data.Bifunctor.Bifunctor ((,,) x1)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,)_$csecond];

Data.Bifunctor.$fBifunctor(,)_$cfirst
  :: forall a b c. (a -> b) -> (a, c) -> (b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJsL ds_sdJsM]
        let {
          sat_sdJsV [Occ=Once] :: c_adHXb
          [LclId] =
              [ds_sdJsM] \u []
                  case ds_sdJsM of {
                    (,) _ [Occ=Dead] b1_sdJsU [Occ=Once] -> b1_sdJsU;
                  }; } in
        let {
          sat_sdJsR [Occ=Once] :: b_adHXa
          [LclId] =
              [f_sdJsL ds_sdJsM] \u []
                  let {
                    sat_sdJsQ [Occ=Once] :: a_adHX9
                    [LclId] =
                        [ds_sdJsM] \u []
                            case ds_sdJsM of {
                              (,) a1_sdJsO [Occ=Once] _ [Occ=Dead] -> a1_sdJsO;
                            };
                  } in  f_sdJsL sat_sdJsQ;
        } in  (,) [sat_sdJsR sat_sdJsV];

Data.Bifunctor.$fBifunctor(,)_$csecond
  :: forall b c a. (b -> c) -> (a, b) -> (a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdJsW ds_sdJsX]
        let {
          sat_sdJt6 [Occ=Once] :: c_adHXm
          [LclId] =
              [g_sdJsW ds_sdJsX] \u []
                  let {
                    sat_sdJt5 [Occ=Once] :: b_adHXl
                    [LclId] =
                        [ds_sdJsX] \u []
                            case ds_sdJsX of {
                              (,) _ [Occ=Dead] b1_sdJt4 [Occ=Once] -> b1_sdJt4;
                            };
                  } in  g_sdJsW sat_sdJt5; } in
        let {
          sat_sdJt1 [Occ=Once] :: a_adHXn
          [LclId] =
              [ds_sdJsX] \u []
                  case ds_sdJsX of {
                    (,) a1_sdJsZ [Occ=Once] _ [Occ=Dead] -> a1_sdJsZ;
                  };
        } in  (,) [sat_sdJt1 sat_sdJt6];

Data.Bifunctor.$fBifunctor(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,)_$csecond];

Data.Bifunctor.$dmbimap
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(C(U)),1*C1(C(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdJt7 f_sdJt8 g_sdJt9]
        let {
          f1_sdJta [Occ=OnceL!, Dmd=<L,C(U)>]
            :: p_adHMW a_adHRn d_adHRq -> p_adHMW b_adHRo d_adHRq
          [LclId] =
              [$dBifunctor_sdJt7 f_sdJt8] \u []
                  Data.Bifunctor.first $dBifunctor_sdJt7 f_sdJt8; } in
        let {
          g1_sdJtb [Occ=OnceL!, Dmd=<L,C(U)>]
            :: p_adHMW a_adHRn c_adHRp -> p_adHMW a_adHRn d_adHRq
          [LclId] =
              [$dBifunctor_sdJt7 g_sdJt9] \u []
                  Data.Bifunctor.second $dBifunctor_sdJt7 g_sdJt9; } in
        let {
          sat_sdJte [Occ=OnceT[0]]
            :: p_adHMW a_adHRn c_adHRp -> p_adHMW b_adHRo d_adHRq
          [LclId] =
              [f1_sdJta g1_sdJtb] \r [x_sdJtc]
                  let {
                    sat_sdJtd [Occ=Once] :: p_adHMW a_adHRn d_adHRq
                    [LclId] =
                        [g1_sdJtb x_sdJtc] \u [] g1_sdJtb x_sdJtc;
                  } in  f1_sdJta sat_sdJtd;
        } in  sat_sdJte;

Data.Bifunctor.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bifunctor.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$trModule4];

Data.Bifunctor.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bifunctor"#;

Data.Bifunctor.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$trModule2];

Data.Bifunctor.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bifunctor.$trModule3
                                     Data.Bifunctor.$trModule1];

$krep_rdIrJ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bifunctor.$tcBifunctor1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdIrJ];

Data.Bifunctor.$tcBifunctor3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bifunctor"#;

Data.Bifunctor.$tcBifunctor2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$tcBifunctor3];

Data.Bifunctor.$tcBifunctor :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15833243383698227199##
                                    9927729778853233711##
                                    Data.Bifunctor.$trModule
                                    Data.Bifunctor.$tcBifunctor2
                                    0#
                                    Data.Bifunctor.$tcBifunctor1];

Data.Bifunctor.C:Bifunctor
  :: forall (p :: * -> * -> *).
     (forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d)
     -> (forall a b c. (a -> b) -> p a c -> p b c)
     -> (forall b c a. (b -> c) -> p a b -> p a c)
     -> Data.Bifunctor.Bifunctor p
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifunctor.C:Bifunctor [eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:08:57.733912538 UTC

Data.Bifunctor.bimap
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sdJhS]
        case v_sdJhS of {
          Data.Bifunctor.C:Bifunctor v_sdJhU [Occ=Once]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead] ->
              v_sdJhU;
        };

Data.Bifunctor.first
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c. (a -> b) -> p a c -> p b c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sdJhX]
        case v_sdJhX of {
          Data.Bifunctor.C:Bifunctor _ [Occ=Dead]
                                     v_sdJi0 [Occ=Once]
                                     _ [Occ=Dead] ->
              v_sdJi0;
        };

Data.Bifunctor.second
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall b c a. (b -> c) -> p a b -> p a c
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sdJi2]
        case v_sdJi2 of {
          Data.Bifunctor.C:Bifunctor _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     v_sdJi6 [Occ=Once] ->
              v_sdJi6;
        };

Data.Bifunctor.$fBifunctor(,)_$cbimap
  :: forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJi7 g_sdJi8 ds_sdJi9]
        let {
          sat_sdJij [Occ=Once] :: d_adHX4
          [LclId] =
              [g_sdJi8 ds_sdJi9] \u []
                  let {
                    sat_sdJii [Occ=Once] :: c_adHX3
                    [LclId] =
                        [ds_sdJi9] \u []
                            case ds_sdJi9 of {
                              (,) _ [Occ=Dead] b1_sdJih [Occ=Once] -> b1_sdJih;
                            };
                  } in  g_sdJi8 sat_sdJii; } in
        let {
          sat_sdJie [Occ=Once] :: b_adHX2
          [LclId] =
              [f_sdJi7 ds_sdJi9] \u []
                  let {
                    sat_sdJid [Occ=Once] :: a_adHX1
                    [LclId] =
                        [ds_sdJi9] \u []
                            case ds_sdJi9 of {
                              (,) a1_sdJib [Occ=Once] _ [Occ=Dead] -> a1_sdJib;
                            };
                  } in  f_sdJi7 sat_sdJid;
        } in  (,) [sat_sdJie sat_sdJij];

Data.Bifunctor.$fBifunctor(,,)_$cbimap
  :: forall x1 a b c d.
     (a -> b) -> (c -> d) -> (x1, a, c) -> (x1, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJik g_sdJil ds_sdJim]
        let {
          sat_sdJiD [Occ=Once] :: d_adHWw
          [LclId] =
              [g_sdJil ds_sdJim] \u []
                  let {
                    sat_sdJiC [Occ=Once] :: c_adHWv
                    [LclId] =
                        [ds_sdJim] \u []
                            case ds_sdJim of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdJiB [Occ=Once] -> b1_sdJiB;
                            };
                  } in  g_sdJil sat_sdJiC; } in
        let {
          sat_sdJix [Occ=Once] :: b_adHWu
          [LclId] =
              [f_sdJik ds_sdJim] \u []
                  let {
                    sat_sdJiw [Occ=Once] :: a_adHWt
                    [LclId] =
                        [ds_sdJim] \u []
                            case ds_sdJim of {
                              (,,) _ [Occ=Dead] a1_sdJiu [Occ=Once] _ [Occ=Dead] -> a1_sdJiu;
                            };
                  } in  f_sdJik sat_sdJiw; } in
        let {
          sat_sdJir [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdJim] \u []
                  case ds_sdJim of {
                    (,,) x2_sdJio [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdJio;
                  };
        } in  (,,) [sat_sdJir sat_sdJix sat_sdJiD];

Data.Bifunctor.$fBifunctor(,,,)_$cbimap
  :: forall x1 x2 a b c d.
     (a -> b) -> (c -> d) -> (x1, x2, a, c) -> (x1, x2, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJiE g_sdJiF ds_sdJiG]
        let {
          sat_sdJj6 [Occ=Once] :: d_adHVX
          [LclId] =
              [g_sdJiF ds_sdJiG] \u []
                  let {
                    sat_sdJj5 [Occ=Once] :: c_adHVW
                    [LclId] =
                        [ds_sdJiG] \u []
                            case ds_sdJiG of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdJj4 [Occ=Once] ->
                                  b1_sdJj4;
                            };
                  } in  g_sdJiF sat_sdJj5; } in
        let {
          sat_sdJiZ [Occ=Once] :: b_adHVV
          [LclId] =
              [f_sdJiE ds_sdJiG] \u []
                  let {
                    sat_sdJiY [Occ=Once] :: a_adHVU
                    [LclId] =
                        [ds_sdJiG] \u []
                            case ds_sdJiG of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdJiW [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdJiW;
                            };
                  } in  f_sdJiE sat_sdJiY; } in
        let {
          sat_sdJiS [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdJiG] \u []
                  case ds_sdJiG of {
                    (,,,) _ [Occ=Dead] x5_sdJiP [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdJiP;
                  }; } in
        let {
          sat_sdJiM [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdJiG] \u []
                  case ds_sdJiG of {
                    (,,,) x4_sdJiI [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdJiI;
                  };
        } in  (,,,) [sat_sdJiM sat_sdJiS sat_sdJiZ sat_sdJj6];

Data.Bifunctor.$fBifunctor(,,,,)_$cbimap
  :: forall x1 x2 x3 a b c d.
     (a -> b) -> (c -> d) -> (x1, x2, x3, a, c) -> (x1, x2, x3, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJj7 g_sdJj8 ds_sdJj9]
        let {
          sat_sdJjK [Occ=Once] :: d_adHVn
          [LclId] =
              [g_sdJj8 ds_sdJj9] \u []
                  let {
                    sat_sdJjJ [Occ=Once] :: c_adHVm
                    [LclId] =
                        [ds_sdJj9] \u []
                            case ds_sdJj9 of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdJjI [Occ=Once] ->
                                  b1_sdJjI;
                            };
                  } in  g_sdJj8 sat_sdJjJ; } in
        let {
          sat_sdJjC [Occ=Once] :: b_adHVl
          [LclId] =
              [f_sdJj7 ds_sdJj9] \u []
                  let {
                    sat_sdJjB [Occ=Once] :: a_adHVk
                    [LclId] =
                        [ds_sdJj9] \u []
                            case ds_sdJj9 of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdJjz [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdJjz;
                            };
                  } in  f_sdJj7 sat_sdJjB; } in
        let {
          sat_sdJju [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdJj9] \u []
                  case ds_sdJj9 of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdJjr [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdJjr;
                  }; } in
        let {
          sat_sdJjn [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdJj9] \u []
                  case ds_sdJj9 of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdJjj [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdJjj;
                  }; } in
        let {
          sat_sdJjg [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdJj9] \u []
                  case ds_sdJj9 of {
                    (,,,,) x4_sdJjb [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdJjb;
                  };
        } in  (,,,,) [sat_sdJjg sat_sdJjn sat_sdJju sat_sdJjC sat_sdJjK];

Data.Bifunctor.$fBifunctor(,,,,,)_$cbimap [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 a b c d.
     (a -> b)
     -> (c -> d) -> (x1, x2, x3, x4, a, c) -> (x1, x2, x3, x4, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdJjL w1_sdJjM w2_sdJjN]
        let {
          sat_sdJkB [Occ=Once] :: d_sdId6
          [LclId] =
              [w1_sdJjM w2_sdJjN] \u []
                  let {
                    sat_sdJkA [Occ=Once] :: c_sdId5
                    [LclId] =
                        [w2_sdJjN] \u []
                            case w2_sdJjN of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdJkz [Occ=Once] ->
                                  b1_sdJkz;
                            };
                  } in  w1_sdJjM sat_sdJkA; } in
        let {
          sat_sdJks [Occ=Once] :: b_sdId4
          [LclId] =
              [w_sdJjL w2_sdJjN] \u []
                  let {
                    sat_sdJkr [Occ=Once] :: a_sdId3
                    [LclId] =
                        [w2_sdJjN] \u []
                            case w2_sdJjN of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdJkp [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdJkp;
                            };
                  } in  w_sdJjL sat_sdJkr; } in
        let {
          sat_sdJkj [Occ=Once] :: x4_sdId2
          [LclId] =
              [w2_sdJjN] \u []
                  case w2_sdJjN of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdJkg [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdJkg;
                  }; } in
        let {
          sat_sdJkb [Occ=Once] :: x3_sdId1
          [LclId] =
              [w2_sdJjN] \u []
                  case w2_sdJjN of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdJk7 [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdJk7;
                  }; } in
        let {
          sat_sdJk3 [Occ=Once] :: x2_sdId0
          [LclId] =
              [w2_sdJjN] \u []
                  case w2_sdJjN of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdJjY [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdJjY;
                  }; } in
        let {
          sat_sdJjV [Occ=Once] :: x1_sdIcZ
          [LclId] =
              [w2_sdJjN] \u []
                  case w2_sdJjN of {
                    (,,,,,) x7_sdJjP [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdJjP;
                  };
        } in 
          (,,,,,) [sat_sdJjV
                   sat_sdJk3
                   sat_sdJkb
                   sat_sdJkj
                   sat_sdJks
                   sat_sdJkB];

Data.Bifunctor.$fBifunctor(,,,,,,)_$cbimap [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 a b c d.
     (a -> b)
     -> (c -> d)
     -> (x1, x2, x3, x4, x5, a, c)
     -> (x1, x2, x3, x4, x5, b, d)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdJkC w1_sdJkD w2_sdJkE]
        let {
          sat_sdJlH [Occ=Once] :: d_sdIdm
          [LclId] =
              [w1_sdJkD w2_sdJkE] \u []
                  let {
                    sat_sdJlG [Occ=Once] :: c_sdIdl
                    [LclId] =
                        [w2_sdJkE] \u []
                            case w2_sdJkE of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdJlF [Occ=Once] ->
                                  b1_sdJlF;
                            };
                  } in  w1_sdJkD sat_sdJlG; } in
        let {
          sat_sdJlx [Occ=Once] :: b_sdIdk
          [LclId] =
              [w_sdJkC w2_sdJkE] \u []
                  let {
                    sat_sdJlw [Occ=Once] :: a_sdIdj
                    [LclId] =
                        [w2_sdJkE] \u []
                            case w2_sdJkE of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdJlu [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdJlu;
                            };
                  } in  w_sdJkC sat_sdJlw; } in
        let {
          sat_sdJln [Occ=Once] :: x5_sdIdi
          [LclId] =
              [w2_sdJkE] \u []
                  case w2_sdJkE of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdJlk [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdJlk;
                  }; } in
        let {
          sat_sdJle [Occ=Once] :: x4_sdIdh
          [LclId] =
              [w2_sdJkE] \u []
                  case w2_sdJkE of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdJla [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdJla;
                  }; } in
        let {
          sat_sdJl5 [Occ=Once] :: x3_sdIdg
          [LclId] =
              [w2_sdJkE] \u []
                  case w2_sdJkE of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdJl0 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdJl0;
                  }; } in
        let {
          sat_sdJkW [Occ=Once] :: x2_sdIdf
          [LclId] =
              [w2_sdJkE] \u []
                  case w2_sdJkE of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdJkQ [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdJkQ;
                  }; } in
        let {
          sat_sdJkN [Occ=Once] :: x1_sdIde
          [LclId] =
              [w2_sdJkE] \u []
                  case w2_sdJkE of {
                    (,,,,,,) x7_sdJkG [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdJkG;
                  };
        } in 
          (,,,,,,) [sat_sdJkN
                    sat_sdJkW
                    sat_sdJl5
                    sat_sdJle
                    sat_sdJln
                    sat_sdJlx
                    sat_sdJlH];

Data.Bifunctor.$fBifunctorEither_$cbimap
  :: forall a b c d.
     (a -> b)
     -> (c -> d) -> Data.Either.Either a c -> Data.Either.Either b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdJlI ds_sdJlJ ds1_sdJlK]
        case ds1_sdJlK of {
          Data.Either.Left a1_sdJlM [Occ=Once] ->
              let {
                sat_sdJlN [Occ=Once] :: b_adHTr
                [LclId] =
                    [f_sdJlI a1_sdJlM] \u [] f_sdJlI a1_sdJlM;
              } in  Data.Either.Left [sat_sdJlN];
          Data.Either.Right b1_sdJlO [Occ=Once] ->
              let {
                sat_sdJlP [Occ=Once] :: d_adHTt
                [LclId] =
                    [ds_sdJlJ b1_sdJlO] \u [] ds_sdJlJ b1_sdJlO;
              } in  Data.Either.Right [sat_sdJlP];
        };

Data.Bifunctor.$fBifunctorConst3
  :: forall a b c d.
     (a -> b) -> (c -> d) -> Data.Functor.Const.Const a c -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdJlQ ds_sdJlR ds1_sdJlS] f_sdJlQ ds1_sdJlS;

Data.Bifunctor.$fBifunctorK4
  :: forall i a b c d.
     (a -> b) -> (c -> d) -> GHC.Generics.K1 i a c -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdJlT ds_sdJlU ds1_sdJlV] f_sdJlT ds1_sdJlV;

Data.Bifunctor.$dmsecond
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall b c a. (b -> c) -> p a b -> p a c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdJlW]
        Data.Bifunctor.bimap $dBifunctor_sdJlW GHC.Base.id;

Data.Bifunctor.$dmfirst
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c. (a -> b) -> p a c -> p b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdJlX f_sdJlY]
        Data.Bifunctor.bimap $dBifunctor_sdJlX f_sdJlY GHC.Base.id;

Data.Bifunctor.$fBifunctorK3
  :: forall c a i b. (a -> b) -> GHC.Generics.K1 i a c -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdJlZ ds_sdJm0] f_sdJlZ ds_sdJm0;

Data.Bifunctor.$fBifunctorK2
  :: forall b a i c.
     (b -> c) -> GHC.Generics.K1 i a b -> GHC.Generics.K1 i a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdJm1 ds1_sdJm2] ds1_sdJm2;

Data.Bifunctor.$fBifunctorK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bifunctor.Bifunctor (GHC.Generics.K1 i)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorK4
                                               Data.Bifunctor.$fBifunctorK3
                                               Data.Bifunctor.$fBifunctorK2];

Data.Bifunctor.$fBifunctorConst2
  :: forall c a b. (a -> b) -> Data.Functor.Const.Const a c -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdJm3 ds_sdJm4] f_sdJm3 ds_sdJm4;

Data.Bifunctor.$fBifunctorConst1
  :: forall b a c.
     (b -> c)
     -> Data.Functor.Const.Const a b -> Data.Functor.Const.Const a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdJm5 ds1_sdJm6] ds1_sdJm6;

Data.Bifunctor.$fBifunctorConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorConst3
                                               Data.Bifunctor.$fBifunctorConst2
                                               Data.Bifunctor.$fBifunctorConst1];

Data.Bifunctor.$fBifunctorEither_$cfirst
  :: forall a b c.
     (a -> b) -> Data.Either.Either a c -> Data.Either.Either b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdJm7 ds_sdJm8]
        case ds_sdJm8 of {
          Data.Either.Left a1_sdJma [Occ=Once] ->
              let {
                sat_sdJmb [Occ=Once] :: b_adHTD
                [LclId] =
                    [f_sdJm7 a1_sdJma] \u [] f_sdJm7 a1_sdJma;
              } in  Data.Either.Left [sat_sdJmb];
          Data.Either.Right b1_sdJmc [Occ=Once] -> wild_sdJm9;
        };

Data.Bifunctor.$fBifunctorEither_$csecond
  :: forall b c a.
     (b -> c) -> Data.Either.Either a b -> Data.Either.Either a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdJmd ds1_sdJme]
        case ds1_sdJme of {
          Data.Either.Left a1_sdJmg [Occ=Once] -> wild_sdJmf;
          Data.Either.Right b1_sdJmh [Occ=Once] ->
              let {
                sat_sdJmi [Occ=Once] :: c_adHTP
                [LclId] =
                    [ds_sdJmd b1_sdJmh] \u [] ds_sdJmd b1_sdJmh;
              } in  Data.Either.Right [sat_sdJmi];
        };

Data.Bifunctor.$fBifunctorEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctorEither_$cbimap
                                               Data.Bifunctor.$fBifunctorEither_$cfirst
                                               Data.Bifunctor.$fBifunctorEither_$csecond];

Data.Bifunctor.$fBifunctor(,,,,,,)_$cfirst [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 a b c.
     (a -> b)
     -> (x1, x2, x3, x4, x5, a, c) -> (x1, x2, x3, x4, x5, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdJmj w1_sdJmk]
        let {
          sat_sdJnm [Occ=Once] :: c_sdIdB
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b1_sdJnl [Occ=Once] ->
                        b1_sdJnl;
                  }; } in
        let {
          sat_sdJnd [Occ=Once] :: b_sdIdA
          [LclId] =
              [w_sdJmj w1_sdJmk] \u []
                  let {
                    sat_sdJnc [Occ=Once] :: a_sdIdz
                    [LclId] =
                        [w1_sdJmk] \u []
                            case w1_sdJmk of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdJna [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdJna;
                            };
                  } in  w_sdJmj sat_sdJnc; } in
        let {
          sat_sdJn3 [Occ=Once] :: x5_sdIdy
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdJn0 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdJn0;
                  }; } in
        let {
          sat_sdJmU [Occ=Once] :: x4_sdIdx
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdJmQ [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdJmQ;
                  }; } in
        let {
          sat_sdJmL [Occ=Once] :: x3_sdIdw
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdJmG [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdJmG;
                  }; } in
        let {
          sat_sdJmC [Occ=Once] :: x2_sdIdv
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdJmw [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdJmw;
                  }; } in
        let {
          sat_sdJmt [Occ=Once] :: x1_sdIdu
          [LclId] =
              [w1_sdJmk] \u []
                  case w1_sdJmk of {
                    (,,,,,,) x7_sdJmm [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdJmm;
                  };
        } in 
          (,,,,,,) [sat_sdJmt
                    sat_sdJmC
                    sat_sdJmL
                    sat_sdJmU
                    sat_sdJn3
                    sat_sdJnd
                    sat_sdJnm];

Data.Bifunctor.$fBifunctor(,,,,,,)_$csecond [InlPrag=NOUSERINLINE[0]]
  :: forall x1 x2 x3 x4 x5 b c a.
     (b -> c)
     -> (x1, x2, x3, x4, x5, a, b) -> (x1, x2, x3, x4, x5, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdJnn w1_sdJno]
        let {
          sat_sdJoq [Occ=Once] :: c_sdIdO
          [LclId] =
              [w_sdJnn w1_sdJno] \u []
                  let {
                    sat_sdJop [Occ=Once] :: b_sdIdN
                    [LclId] =
                        [w1_sdJno] \u []
                            case w1_sdJno of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdJoo [Occ=Once] ->
                                  b1_sdJoo;
                            };
                  } in  w_sdJnn sat_sdJop; } in
        let {
          sat_sdJog [Occ=Once] :: a_sdIdP
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a1_sdJoe [Occ=Once]
                             _ [Occ=Dead] ->
                        a1_sdJoe;
                  }; } in
        let {
          sat_sdJo7 [Occ=Once] :: x5_sdIdM
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x11_sdJo4 [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x11_sdJo4;
                  }; } in
        let {
          sat_sdJnY [Occ=Once] :: x4_sdIdL
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             x10_sdJnU [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x10_sdJnU;
                  }; } in
        let {
          sat_sdJnP [Occ=Once] :: x3_sdIdK
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             x9_sdJnK [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x9_sdJnK;
                  }; } in
        let {
          sat_sdJnG [Occ=Once] :: x2_sdIdJ
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) _ [Occ=Dead]
                             x8_sdJnA [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x8_sdJnA;
                  }; } in
        let {
          sat_sdJnx [Occ=Once] :: x1_sdIdI
          [LclId] =
              [w1_sdJno] \u []
                  case w1_sdJno of {
                    (,,,,,,) x7_sdJnq [Occ=Once]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead] ->
                        x7_sdJnq;
                  };
        } in 
          (,,,,,,) [sat_sdJnx
                    sat_sdJnG
                    sat_sdJnP
                    sat_sdJnY
                    sat_sdJo7
                    sat_sdJog
                    sat_sdJoq];

Data.Bifunctor.$fBifunctor(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3 x4 x5.
     Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,,,)_$cfirst
  :: forall x1 x2 x3 x4 a b c.
     (a -> b) -> (x1, x2, x3, x4, a, c) -> (x1, x2, x3, x4, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJor ds_sdJos]
        let {
          sat_sdJpf [Occ=Once] :: c_adHUT
          [LclId] =
              [ds_sdJos] \u []
                  case ds_sdJos of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b1_sdJpe [Occ=Once] ->
                        b1_sdJpe;
                  }; } in
        let {
          sat_sdJp7 [Occ=Once] :: b_adHUS
          [LclId] =
              [f_sdJor ds_sdJos] \u []
                  let {
                    sat_sdJp6 [Occ=Once] :: a_adHUR
                    [LclId] =
                        [ds_sdJos] \u []
                            case ds_sdJos of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdJp4 [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdJp4;
                            };
                  } in  f_sdJor sat_sdJp6; } in
        let {
          sat_sdJoY [Occ=Once] :: x4_adHUF
          [LclId] =
              [ds_sdJos] \u []
                  case ds_sdJos of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdJoV [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdJoV;
                  }; } in
        let {
          sat_sdJoQ [Occ=Once] :: x3_adHUE
          [LclId] =
              [ds_sdJos] \u []
                  case ds_sdJos of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdJoM [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdJoM;
                  }; } in
        let {
          sat_sdJoI [Occ=Once] :: x2_adHUD
          [LclId] =
              [ds_sdJos] \u []
                  case ds_sdJos of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdJoD [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdJoD;
                  }; } in
        let {
          sat_sdJoA [Occ=Once] :: x1_adHUC
          [LclId] =
              [ds_sdJos] \u []
                  case ds_sdJos of {
                    (,,,,,) x7_sdJou [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdJou;
                  };
        } in 
          (,,,,,) [sat_sdJoA
                   sat_sdJoI
                   sat_sdJoQ
                   sat_sdJoY
                   sat_sdJp7
                   sat_sdJpf];

Data.Bifunctor.$fBifunctor(,,,,,)_$csecond
  :: forall x1 x2 x3 x4 b c a.
     (b -> c) -> (x1, x2, x3, x4, a, b) -> (x1, x2, x3, x4, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdJpg ds_sdJph]
        let {
          sat_sdJq4 [Occ=Once] :: c_adHV4
          [LclId] =
              [g_sdJpg ds_sdJph] \u []
                  let {
                    sat_sdJq3 [Occ=Once] :: b_adHV3
                    [LclId] =
                        [ds_sdJph] \u []
                            case ds_sdJph of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdJq2 [Occ=Once] ->
                                  b1_sdJq2;
                            };
                  } in  g_sdJpg sat_sdJq3; } in
        let {
          sat_sdJpV [Occ=Once] :: a_adHV5
          [LclId] =
              [ds_sdJph] \u []
                  case ds_sdJph of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a1_sdJpT [Occ=Once]
                            _ [Occ=Dead] ->
                        a1_sdJpT;
                  }; } in
        let {
          sat_sdJpN [Occ=Once] :: x4_adHUF
          [LclId] =
              [ds_sdJph] \u []
                  case ds_sdJph of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            x10_sdJpK [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x10_sdJpK;
                  }; } in
        let {
          sat_sdJpF [Occ=Once] :: x3_adHUE
          [LclId] =
              [ds_sdJph] \u []
                  case ds_sdJph of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            x9_sdJpB [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x9_sdJpB;
                  }; } in
        let {
          sat_sdJpx [Occ=Once] :: x2_adHUD
          [LclId] =
              [ds_sdJph] \u []
                  case ds_sdJph of {
                    (,,,,,) _ [Occ=Dead]
                            x8_sdJps [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x8_sdJps;
                  }; } in
        let {
          sat_sdJpp [Occ=Once] :: x1_adHUC
          [LclId] =
              [ds_sdJph] \u []
                  case ds_sdJph of {
                    (,,,,,) x7_sdJpj [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
                        x7_sdJpj;
                  };
        } in 
          (,,,,,) [sat_sdJpp
                   sat_sdJpx
                   sat_sdJpF
                   sat_sdJpN
                   sat_sdJpV
                   sat_sdJq4];

Data.Bifunctor.$fBifunctor(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3 x4.
     Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,,)_$cfirst
  :: forall x1 x2 x3 a b c.
     (a -> b) -> (x1, x2, x3, a, c) -> (x1, x2, x3, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJq5 ds_sdJq6]
        let {
          sat_sdJqG [Occ=Once] :: c_adHVu
          [LclId] =
              [ds_sdJq6] \u []
                  case ds_sdJq6 of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b1_sdJqF [Occ=Once] ->
                        b1_sdJqF;
                  }; } in
        let {
          sat_sdJqz [Occ=Once] :: b_adHVt
          [LclId] =
              [f_sdJq5 ds_sdJq6] \u []
                  let {
                    sat_sdJqy [Occ=Once] :: a_adHVs
                    [LclId] =
                        [ds_sdJq6] \u []
                            case ds_sdJq6 of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdJqw [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdJqw;
                            };
                  } in  f_sdJq5 sat_sdJqy; } in
        let {
          sat_sdJqr [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdJq6] \u []
                  case ds_sdJq6 of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdJqo [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdJqo;
                  }; } in
        let {
          sat_sdJqk [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdJq6] \u []
                  case ds_sdJq6 of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdJqg [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdJqg;
                  }; } in
        let {
          sat_sdJqd [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdJq6] \u []
                  case ds_sdJq6 of {
                    (,,,,) x4_sdJq8 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdJq8;
                  };
        } in  (,,,,) [sat_sdJqd sat_sdJqk sat_sdJqr sat_sdJqz sat_sdJqG];

Data.Bifunctor.$fBifunctor(,,,,)_$csecond
  :: forall x1 x2 x3 b c a.
     (b -> c) -> (x1, x2, x3, a, b) -> (x1, x2, x3, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdJqH ds_sdJqI]
        let {
          sat_sdJri [Occ=Once] :: c_adHVF
          [LclId] =
              [g_sdJqH ds_sdJqI] \u []
                  let {
                    sat_sdJrh [Occ=Once] :: b_adHVE
                    [LclId] =
                        [ds_sdJqI] \u []
                            case ds_sdJqI of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdJrg [Occ=Once] ->
                                  b1_sdJrg;
                            };
                  } in  g_sdJqH sat_sdJrh; } in
        let {
          sat_sdJra [Occ=Once] :: a_adHVG
          [LclId] =
              [ds_sdJqI] \u []
                  case ds_sdJqI of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a1_sdJr8 [Occ=Once]
                           _ [Occ=Dead] ->
                        a1_sdJr8;
                  }; } in
        let {
          sat_sdJr3 [Occ=Once] :: x3_adHVg
          [LclId] =
              [ds_sdJqI] \u []
                  case ds_sdJqI of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           x6_sdJr0 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x6_sdJr0;
                  }; } in
        let {
          sat_sdJqW [Occ=Once] :: x2_adHVf
          [LclId] =
              [ds_sdJqI] \u []
                  case ds_sdJqI of {
                    (,,,,) _ [Occ=Dead]
                           x5_sdJqS [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x5_sdJqS;
                  }; } in
        let {
          sat_sdJqP [Occ=Once] :: x1_adHVe
          [LclId] =
              [ds_sdJqI] \u []
                  case ds_sdJqI of {
                    (,,,,) x4_sdJqK [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
                        x4_sdJqK;
                  };
        } in  (,,,,) [sat_sdJqP sat_sdJqW sat_sdJr3 sat_sdJra sat_sdJri];

Data.Bifunctor.$fBifunctor(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2 x3. Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,,)_$cfirst
  :: forall x1 x2 a b c. (a -> b) -> (x1, x2, a, c) -> (x1, x2, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJrj ds_sdJrk]
        let {
          sat_sdJrJ [Occ=Once] :: c_adHW4
          [LclId] =
              [ds_sdJrk] \u []
                  case ds_sdJrk of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdJrI [Occ=Once] ->
                        b1_sdJrI;
                  }; } in
        let {
          sat_sdJrD [Occ=Once] :: b_adHW3
          [LclId] =
              [f_sdJrj ds_sdJrk] \u []
                  let {
                    sat_sdJrC [Occ=Once] :: a_adHW2
                    [LclId] =
                        [ds_sdJrk] \u []
                            case ds_sdJrk of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdJrA [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdJrA;
                            };
                  } in  f_sdJrj sat_sdJrC; } in
        let {
          sat_sdJrw [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdJrk] \u []
                  case ds_sdJrk of {
                    (,,,) _ [Occ=Dead] x5_sdJrt [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdJrt;
                  }; } in
        let {
          sat_sdJrq [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdJrk] \u []
                  case ds_sdJrk of {
                    (,,,) x4_sdJrm [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdJrm;
                  };
        } in  (,,,) [sat_sdJrq sat_sdJrw sat_sdJrD sat_sdJrJ];

Data.Bifunctor.$fBifunctor(,,,)_$csecond
  :: forall x1 x2 b c a. (b -> c) -> (x1, x2, a, b) -> (x1, x2, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdJrK ds_sdJrL]
        let {
          sat_sdJsa [Occ=Once] :: c_adHWf
          [LclId] =
              [g_sdJrK ds_sdJrL] \u []
                  let {
                    sat_sdJs9 [Occ=Once] :: b_adHWe
                    [LclId] =
                        [ds_sdJrL] \u []
                            case ds_sdJrL of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdJs8 [Occ=Once] ->
                                  b1_sdJs8;
                            };
                  } in  g_sdJrK sat_sdJs9; } in
        let {
          sat_sdJs3 [Occ=Once] :: a_adHWg
          [LclId] =
              [ds_sdJrL] \u []
                  case ds_sdJrL of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdJs1 [Occ=Once] _ [Occ=Dead] ->
                        a1_sdJs1;
                  }; } in
        let {
          sat_sdJrX [Occ=Once] :: x2_adHVQ
          [LclId] =
              [ds_sdJrL] \u []
                  case ds_sdJrL of {
                    (,,,) _ [Occ=Dead] x5_sdJrU [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
                        x5_sdJrU;
                  }; } in
        let {
          sat_sdJrR [Occ=Once] :: x1_adHVP
          [LclId] =
              [ds_sdJrL] \u []
                  case ds_sdJrL of {
                    (,,,) x4_sdJrN [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                        x4_sdJrN;
                  };
        } in  (,,,) [sat_sdJrR sat_sdJrX sat_sdJs3 sat_sdJsa];

Data.Bifunctor.$fBifunctor(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1 x2. Data.Bifunctor.Bifunctor ((,,,) x1 x2)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,,)_$csecond];

Data.Bifunctor.$fBifunctor(,,)_$cfirst
  :: forall x1 a b c. (a -> b) -> (x1, a, c) -> (x1, b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJsb ds_sdJsc]
        let {
          sat_sdJss [Occ=Once] :: c_adHWD
          [LclId] =
              [ds_sdJsc] \u []
                  case ds_sdJsc of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdJsr [Occ=Once] -> b1_sdJsr;
                  }; } in
        let {
          sat_sdJsn [Occ=Once] :: b_adHWC
          [LclId] =
              [f_sdJsb ds_sdJsc] \u []
                  let {
                    sat_sdJsm [Occ=Once] :: a_adHWB
                    [LclId] =
                        [ds_sdJsc] \u []
                            case ds_sdJsc of {
                              (,,) _ [Occ=Dead] a1_sdJsk [Occ=Once] _ [Occ=Dead] -> a1_sdJsk;
                            };
                  } in  f_sdJsb sat_sdJsm; } in
        let {
          sat_sdJsh [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdJsc] \u []
                  case ds_sdJsc of {
                    (,,) x2_sdJse [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdJse;
                  };
        } in  (,,) [sat_sdJsh sat_sdJsn sat_sdJss];

Data.Bifunctor.$fBifunctor(,,)_$csecond
  :: forall x1 b c a. (b -> c) -> (x1, a, b) -> (x1, a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdJst ds_sdJsu]
        let {
          sat_sdJsK [Occ=Once] :: c_adHWO
          [LclId] =
              [g_sdJst ds_sdJsu] \u []
                  let {
                    sat_sdJsJ [Occ=Once] :: b_adHWN
                    [LclId] =
                        [ds_sdJsu] \u []
                            case ds_sdJsu of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdJsI [Occ=Once] -> b1_sdJsI;
                            };
                  } in  g_sdJst sat_sdJsJ; } in
        let {
          sat_sdJsE [Occ=Once] :: a_adHWP
          [LclId] =
              [ds_sdJsu] \u []
                  case ds_sdJsu of {
                    (,,) _ [Occ=Dead] a1_sdJsC [Occ=Once] _ [Occ=Dead] -> a1_sdJsC;
                  }; } in
        let {
          sat_sdJsz [Occ=Once] :: x1_adHWp
          [LclId] =
              [ds_sdJsu] \u []
                  case ds_sdJsu of {
                    (,,) x2_sdJsw [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> x2_sdJsw;
                  };
        } in  (,,) [sat_sdJsz sat_sdJsE sat_sdJsK];

Data.Bifunctor.$fBifunctor(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x1. Data.Bifunctor.Bifunctor ((,,) x1)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,,)_$csecond];

Data.Bifunctor.$fBifunctor(,)_$cfirst
  :: forall a b c. (a -> b) -> (a, c) -> (b, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdJsL ds_sdJsM]
        let {
          sat_sdJsV [Occ=Once] :: c_adHXb
          [LclId] =
              [ds_sdJsM] \u []
                  case ds_sdJsM of {
                    (,) _ [Occ=Dead] b1_sdJsU [Occ=Once] -> b1_sdJsU;
                  }; } in
        let {
          sat_sdJsR [Occ=Once] :: b_adHXa
          [LclId] =
              [f_sdJsL ds_sdJsM] \u []
                  let {
                    sat_sdJsQ [Occ=Once] :: a_adHX9
                    [LclId] =
                        [ds_sdJsM] \u []
                            case ds_sdJsM of {
                              (,) a1_sdJsO [Occ=Once] _ [Occ=Dead] -> a1_sdJsO;
                            };
                  } in  f_sdJsL sat_sdJsQ;
        } in  (,) [sat_sdJsR sat_sdJsV];

Data.Bifunctor.$fBifunctor(,)_$csecond
  :: forall b c a. (b -> c) -> (a, b) -> (a, c)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [g_sdJsW ds_sdJsX]
        let {
          sat_sdJt6 [Occ=Once] :: c_adHXm
          [LclId] =
              [g_sdJsW ds_sdJsX] \u []
                  let {
                    sat_sdJt5 [Occ=Once] :: b_adHXl
                    [LclId] =
                        [ds_sdJsX] \u []
                            case ds_sdJsX of {
                              (,) _ [Occ=Dead] b1_sdJt4 [Occ=Once] -> b1_sdJt4;
                            };
                  } in  g_sdJsW sat_sdJt5; } in
        let {
          sat_sdJt1 [Occ=Once] :: a_adHXn
          [LclId] =
              [ds_sdJsX] \u []
                  case ds_sdJsX of {
                    (,) a1_sdJsZ [Occ=Once] _ [Occ=Dead] -> a1_sdJsZ;
                  };
        } in  (,) [sat_sdJt1 sat_sdJt6];

Data.Bifunctor.$fBifunctor(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Bifunctor.$fBifunctor(,)_$cbimap
                                               Data.Bifunctor.$fBifunctor(,)_$cfirst
                                               Data.Bifunctor.$fBifunctor(,)_$csecond];

Data.Bifunctor.$dmbimap
  :: forall (p :: * -> * -> *).
     Data.Bifunctor.Bifunctor p =>
     forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(C(U)),1*C1(C(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifunctor_sdJt7 f_sdJt8 g_sdJt9]
        let {
          f1_sdJta [Occ=OnceL!, Dmd=<L,C(U)>]
            :: p_adHMW a_adHRn d_adHRq -> p_adHMW b_adHRo d_adHRq
          [LclId] =
              [$dBifunctor_sdJt7 f_sdJt8] \u []
                  Data.Bifunctor.first $dBifunctor_sdJt7 f_sdJt8; } in
        let {
          g1_sdJtb [Occ=OnceL!, Dmd=<L,C(U)>]
            :: p_adHMW a_adHRn c_adHRp -> p_adHMW a_adHRn d_adHRq
          [LclId] =
              [$dBifunctor_sdJt7 g_sdJt9] \u []
                  Data.Bifunctor.second $dBifunctor_sdJt7 g_sdJt9; } in
        let {
          sat_sdJte [Occ=OnceT[0]]
            :: p_adHMW a_adHRn c_adHRp -> p_adHMW b_adHRo d_adHRq
          [LclId] =
              [f1_sdJta g1_sdJtb] \r [x_sdJtc]
                  let {
                    sat_sdJtd [Occ=Once] :: p_adHMW a_adHRn d_adHRq
                    [LclId] =
                        [g1_sdJtb x_sdJtc] \u [] g1_sdJtb x_sdJtc;
                  } in  f1_sdJta sat_sdJtd;
        } in  sat_sdJte;

Data.Bifunctor.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bifunctor.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$trModule4];

Data.Bifunctor.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bifunctor"#;

Data.Bifunctor.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$trModule2];

Data.Bifunctor.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bifunctor.$trModule3
                                     Data.Bifunctor.$trModule1];

$krep_rdIrJ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bifunctor.$tcBifunctor1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdIrJ];

Data.Bifunctor.$tcBifunctor3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bifunctor"#;

Data.Bifunctor.$tcBifunctor2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifunctor.$tcBifunctor3];

Data.Bifunctor.$tcBifunctor :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15833243383698227199##
                                    9927729778853233711##
                                    Data.Bifunctor.$trModule
                                    Data.Bifunctor.$tcBifunctor2
                                    0#
                                    Data.Bifunctor.$tcBifunctor1];

Data.Bifunctor.C:Bifunctor
  :: forall (p :: * -> * -> *).
     (forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d)
     -> (forall a b c. (a -> b) -> p a c -> p b c)
     -> (forall b c a. (b -> c) -> p a b -> p a c)
     -> Data.Bifunctor.Bifunctor p
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifunctor.C:Bifunctor [eta_B3 eta_B2 eta_B1];

