
==================== Pre unarise: ====================
2018-03-16 16:02:01.825538706 UTC

Data.Foldable.fold
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m. GHC.Base.Monoid m => t m -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OSZ]
        case v_s6OSZ of {
          Data.Foldable.C:Foldable v_s6OT1 [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OT1;
        };

Data.Foldable.foldMap
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OTh]
        case v_s6OTh of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   v_s6OTk [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OTk;
        };

Data.Foldable.foldr
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OTz]
        case v_s6OTz of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OTD [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OTD;
        };

Data.Foldable.foldr'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OTR]
        case v_s6OTR of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OTW [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OTW;
        };

Data.Foldable.foldl
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OU9]
        case v_s6OU9 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OUf [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OUf;
        };

Data.Foldable.foldl'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OUr]
        case v_s6OUr of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OUy [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OUy;
        };

Data.Foldable.foldr1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OUJ]
        case v_s6OUJ of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OUR [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OUR;
        };

Data.Foldable.foldl1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OV1]
        case v_s6OV1 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OVa [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OVa;
        };

Data.Foldable.toList
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OVj]
        case v_s6OVj of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OVt [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OVt;
        };

Data.Foldable.null
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s6OVB]
        case v_s6OVB of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OVM [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OVM;
        };

Data.Foldable.length
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s6OVT]
        case v_s6OVT of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OW5 [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OW5;
        };

Data.Foldable.elem
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s6OWb]
        case v_s6OWb of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OWo [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OWo;
        };

Data.Foldable.maximum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s6OWt]
        case v_s6OWt of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OWH [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OWH;
        };

Data.Foldable.minimum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s6OWL]
        case v_s6OWL of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OX0 [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OX0;
        };

Data.Foldable.sum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s6OX3]
        case v_s6OX3 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OXj [Occ=Once]
                                   _ [Occ=Dead] ->
              v_s6OXj;
        };

Data.Foldable.product
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s6OXl]
        case v_s6OXl of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OXC [Occ=Once] ->
              v_s6OXC;
        };

Data.Foldable.$fFoldableMaybe_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.Maybe a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6OXD z_s6OXE ds1_s6OXF]
        case ds1_s6OXF of {
          GHC.Base.Nothing -> z_s6OXE;
          GHC.Base.Just x_s6OXH [Occ=Once] -> ds_s6OXD z_s6OXE x_s6OXH;
        };

Data.Foldable.$fFoldableMaybe_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.Maybe a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6OXI z_s6OXJ ds1_s6OXK]
        case ds1_s6OXK of {
          GHC.Base.Nothing -> z_s6OXJ;
          GHC.Base.Just x_s6OXM [Occ=Once] -> ds_s6OXI x_s6OXM z_s6OXJ;
        };

Data.Foldable.$fFoldableMaybe_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Base.Maybe a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6OXN eta_s6OXO eta1_s6OXP]
        case eta1_s6OXP of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6OXN;
          GHC.Base.Just x_s6OXR [Occ=Once] -> eta_s6OXO x_s6OXR;
        };

Data.Foldable.$fFoldableNonEmpty_$clength
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s6OXS]
        case ds_s6OXS of {
          GHC.Base.:| _ [Occ=Dead] as_s6OXV [Occ=Once] ->
              case GHC.List.$wlenAcc as_s6OXV 0# of ww2_s6OXW {
                __DEFAULT ->
                    case +# [1# ww2_s6OXW] of sat_s6OXX {
                      __DEFAULT -> GHC.Types.I# [sat_s6OXX];
                    };
              };
        };

Data.Foldable.$fFoldableNonEmpty_$ctoList
  :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s6OXY]
        let {
          sat_s6OY6 [Occ=Once] :: [a_a6LPN]
          [LclId] =
              [ds_s6OXY] \u []
                  case ds_s6OXY of {
                    GHC.Base.:| _ [Occ=Dead] as_s6OY5 [Occ=Once] -> as_s6OY5;
                  }; } in
        let {
          sat_s6OY2 [Occ=Once] :: a_a6LPN
          [LclId] =
              [ds_s6OXY] \u []
                  case ds_s6OXY of {
                    GHC.Base.:| a1_s6OY0 [Occ=Once] _ [Occ=Dead] -> a1_s6OY0;
                  };
        } in  : [sat_s6OY2 sat_s6OY6];

Data.Foldable.$fFoldableNonEmpty_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6OY7 ds_s6OY8]
        case ds_s6OY8 of {
          GHC.Base.:| a1_s6OYa [Occ=Once] as_s6OYb [Occ=Once] ->
              let-no-escape {
                go_s6OYc [Occ=LoopBreakerT[2]] :: [a_a6LPG] -> a_a6LPG -> a_a6LPG
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [f_s6OY7 go_s6OYc] \r [ds1_s6OYd eta_s6OYe]
                        case ds1_s6OYd of {
                          [] -> eta_s6OYe;
                          : y_s6OYg [Occ=Once] ys_s6OYh [Occ=Once] ->
                              let {
                                sat_s6OYi [Occ=Once] :: a_a6LPG
                                [LclId] =
                                    [f_s6OY7 eta_s6OYe y_s6OYg] \u [] f_s6OY7 eta_s6OYe y_s6OYg;
                              } in  go_s6OYc ys_s6OYh sat_s6OYi;
                        };
              } in  go_s6OYc as_s6OYb a1_s6OYa;
        };

Data.Foldable.$w$cfoldl2 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6OYj w1_s6OYk ww_s6OYl ww1_s6OYm]
        let {
          sat_s6OYu [Occ=Once] :: b_s6NRS
          [LclId] =
              [w_s6OYj w1_s6OYk ww_s6OYl] \u [] w_s6OYj w1_s6OYk ww_s6OYl;
        } in 
          let-no-escape {
            go_s6OYn [Occ=LoopBreakerT[2]] :: [a_s6NRT] -> b_s6NRS -> b_s6NRS
            [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                sat-only [w_s6OYj go_s6OYn] \r [ds_s6OYo eta_s6OYp]
                    case ds_s6OYo of {
                      [] -> eta_s6OYp;
                      : y_s6OYr [Occ=Once] ys_s6OYs [Occ=Once] ->
                          let {
                            sat_s6OYt [Occ=Once] :: b_s6NRS
                            [LclId] =
                                [w_s6OYj eta_s6OYp y_s6OYr] \u [] w_s6OYj eta_s6OYp y_s6OYr;
                          } in  go_s6OYn ys_s6OYs sat_s6OYt;
                    };
          } in  go_s6OYn ww1_s6OYm sat_s6OYu;

Data.Foldable.$fFoldableNonEmpty_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6OYv w1_s6OYw w2_s6OYx]
        case w2_s6OYx of {
          GHC.Base.:| ww1_s6OYz [Occ=Once] ww2_s6OYA [Occ=Once] ->
              Data.Foldable.$w$cfoldl2 w_s6OYv w1_s6OYw ww1_s6OYz ww2_s6OYA;
        };

Data.Foldable.$fFoldableNonEmpty_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6OYB z_s6OYC ds_s6OYD]
        let {
          sat_s6OYR [Occ=Once] :: b_a6LOW
          [LclId] =
              [f_s6OYB z_s6OYC ds_s6OYD] \u []
                  case ds_s6OYD of {
                    GHC.Base.:| _ [Occ=Dead] as_s6OYK [Occ=Once] ->
                        let {
                          go_s6OYL [Occ=LoopBreaker] :: [a_a6LOV] -> b_a6LOW
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [f_s6OYB z_s6OYC go_s6OYL] \r [ds1_s6OYM]
                                  case ds1_s6OYM of {
                                    [] -> z_s6OYC;
                                    : y_s6OYO [Occ=Once] ys_s6OYP [Occ=Once] ->
                                        let {
                                          sat_s6OYQ [Occ=Once] :: b_a6LOW
                                          [LclId] =
                                              [go_s6OYL ys_s6OYP] \u [] go_s6OYL ys_s6OYP;
                                        } in  f_s6OYB y_s6OYO sat_s6OYQ;
                                  };
                        } in  go_s6OYL as_s6OYK;
                  }; } in
        let {
          sat_s6OYH [Occ=Once] :: a_a6LOV
          [LclId] =
              [ds_s6OYD] \u []
                  case ds_s6OYD of {
                    GHC.Base.:| a1_s6OYF [Occ=Once] _ [Occ=Dead] -> a1_s6OYF;
                  };
        } in  f_s6OYB sat_s6OYH sat_s6OYR;

Data.Foldable.$fFoldable:*:4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Foldable.$fFoldableDual3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Foldable.$fFoldableEither_$clength
  :: forall a1 a2. Data.Either.Either a1 a2 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_s6OYS]
        case ds_s6OYS of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
          Data.Either.Right _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableEither_$cfoldr
  :: forall a1 a2 b.
     (a2 -> b -> b) -> b -> Data.Either.Either a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6OYW z_s6OYX ds1_s6OYY]
        case ds1_s6OYY of {
          Data.Either.Left _ [Occ=Dead] -> z_s6OYX;
          Data.Either.Right y_s6OZ1 [Occ=Once] -> ds_s6OYW y_s6OZ1 z_s6OYX;
        };

Data.Foldable.$fFoldableEither_$cfoldMap
  :: forall a1 m a2.
     GHC.Base.Monoid m =>
     (a2 -> m) -> Data.Either.Either a1 a2 -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6OZ2 ds_s6OZ3 ds1_s6OZ4]
        case ds1_s6OZ4 of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6OZ2;
          Data.Either.Right y_s6OZ7 [Occ=Once] -> ds_s6OZ3 y_s6OZ7;
        };

Data.Foldable.$fFoldable(,)_$cfoldr
  :: forall a1 a2 b. (a2 -> b -> b) -> b -> (a1, a2) -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_s6OZ8 z_s6OZ9 ds_s6OZa]
        case ds_s6OZa of {
          (,) _ [Occ=Dead] y_s6OZd [Occ=Once] -> f_s6OZ8 y_s6OZd z_s6OZ9;
        };

Data.Foldable.$fFoldable(,)_$cfoldMap
  :: forall a1 m a2. GHC.Base.Monoid m => (a2 -> m) -> (a1, a2) -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6OZe f_s6OZf ds_s6OZg]
        case ds_s6OZg of {
          (,) _ [Occ=Dead] y_s6OZj [Occ=Once] -> f_s6OZf y_s6OZj;
        };

Data.Foldable.$fFoldableArray_$cnull
  :: forall i a. GHC.Arr.Array i a -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),1*U(A,A,1*U,A)>,
 Unf=OtherCon []] =
    [] \r [a1_s6OZk]
        case a1_s6OZk of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        dt_s6OZo [Occ=Once!]
                        _ [Occ=Dead] ->
              case dt_s6OZo of {
                __DEFAULT -> GHC.Types.False [];
                0# -> GHC.Types.True [];
              };
        };

sat_s6OZr :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s6OZs :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6OZr GHC.Types.[]];

Data.Foldable.$fFoldableProxy1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6OZs;

Data.Foldable.$fFoldableProxy_$cproduct
  :: forall a. GHC.Num.Num a => Data.Proxy.Proxy a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6OZt ds_s6OZu]
        GHC.Num.fromInteger $dNum_s6OZt Data.Foldable.$fFoldableProxy1;

Data.Foldable.$fFoldableProxy2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Foldable.$fFoldableProxy_$csum
  :: forall a. GHC.Num.Num a => Data.Proxy.Proxy a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6OZv ds_s6OZw]
        GHC.Num.fromInteger $dNum_s6OZv Data.Foldable.$fFoldableProxy2;

Data.Foldable.$fFoldableProxy_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Proxy.Proxy a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6OZx ds_s6OZy ds1_s6OZz] GHC.Types.False [];

Data.Foldable.$fFoldableProxy_$clength
  :: forall a. Data.Proxy.Proxy a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6OZA] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableProxy_$cnull
  :: forall a. Data.Proxy.Proxy a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6OZB] GHC.Types.True [];

Data.Foldable.$fFoldableProxy4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: Proxy"#;

Data.Foldable.$fFoldableProxy3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableProxy4;

Data.Foldable.$fFoldableProxy_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6OZC ds1_s6OZD]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableProxy3;

Data.Foldable.$fFoldableProxy6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: Proxy"#;

Data.Foldable.$fFoldableProxy5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableProxy6;

Data.Foldable.$fFoldableProxy_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6OZE ds1_s6OZF]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableProxy5;

Data.Foldable.$fFoldableProxy_$cfoldl [InlPrag=INLINE (sat-args=3)]
  :: forall b a. (b -> a -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6OZG z_s6OZH ds1_s6OZI] z_s6OZH;

Data.Foldable.$fFoldableProxy_$cfoldr [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (a -> b -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6OZJ z_s6OZK ds1_s6OZL] z_s6OZK;

Data.Foldable.$fFoldableProxy_$cfoldMap [InlPrag=INLINE (sat-args=2)]
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Proxy.Proxy a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6OZM eta_s6OZN ds_s6OZO]
        GHC.Base.mempty $dMonoid_s6OZM;

Data.Foldable.$fFoldableProxy_$cfold [InlPrag=INLINE (sat-args=1)]
  :: forall m. GHC.Base.Monoid m => Data.Proxy.Proxy m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6OZP ds_s6OZQ] GHC.Base.mempty $dMonoid_s6OZP;

Data.Foldable.$fFoldableDual1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6OZR eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6OZS eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual_$clength
  :: forall a. Data.Semigroup.Internal.Dual a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6OZT] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableDual_$cnull
  :: forall a. Data.Semigroup.Internal.Dual a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6OZU] GHC.Types.False [];

Data.Foldable.$fFoldableDual_$ctoList
  :: forall a. Data.Semigroup.Internal.Dual a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6OZV] : [ds_s6OZV GHC.Types.[]];

Data.Foldable.$fFoldableDual4
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6OZW eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual5
  :: forall b a. (b -> a -> b) -> b -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6OZX] v_s6OZX;

Data.Foldable.$fFoldableDual_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Dual a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6OZY z_s6OZZ ds_s6P00] f_s6OZY ds_s6P00 z_s6OZZ;

Data.Foldable.$fFoldableDual6
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> a -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P01 v_s6P02] v_s6P02;

Data.Foldable.$fFoldableSum1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6P03 eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6P04 eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum_$clength
  :: forall a. Data.Semigroup.Internal.Sum a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6P05] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableSum_$cnull
  :: forall a. Data.Semigroup.Internal.Sum a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P06] GHC.Types.False [];

Data.Foldable.$fFoldableSum_$ctoList
  :: forall a. Data.Semigroup.Internal.Sum a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6P07] : [ds_s6P07 GHC.Types.[]];

Data.Foldable.$fFoldableSum3
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P08 eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Sum a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6P09 z_s6P0a ds_s6P0b] f_s6P09 ds_s6P0b z_s6P0a;

Data.Foldable.$fFoldableProduct1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6P0c eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6P0d eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct_$clength
  :: forall a. Data.Semigroup.Internal.Product a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6P0e] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableProduct_$cnull
  :: forall a. Data.Semigroup.Internal.Product a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P0f] GHC.Types.False [];

Data.Foldable.$fFoldableProduct_$ctoList
  :: forall a. Data.Semigroup.Internal.Product a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6P0g] : [ds_s6P0g GHC.Types.[]];

Data.Foldable.$fFoldableProduct3
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P0h eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Product a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6P0i z_s6P0j ds_s6P0k] f_s6P0i ds_s6P0k z_s6P0j;

Data.Foldable.$fFoldableU1_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Generics.U1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P0l ds_s6P0m]
        GHC.Num.fromInteger $dNum_s6P0l Data.Foldable.$fFoldableProxy1;

Data.Foldable.$fFoldableU1_$csum
  :: forall a. GHC.Num.Num a => GHC.Generics.U1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P0n ds_s6P0o]
        GHC.Num.fromInteger $dNum_s6P0n Data.Foldable.$fFoldableProxy2;

Data.Foldable.$fFoldableU1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.U1 a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P0p ds_s6P0q ds1_s6P0r] GHC.Types.False [];

Data.Foldable.$fFoldableU1_$clength
  :: forall a. GHC.Generics.U1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6P0s] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableU1_$cnull
  :: forall a. GHC.Generics.U1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P0t] GHC.Types.True [];

Data.Foldable.$fFoldableU3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: U1"#;

Data.Foldable.$fFoldableU2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableU3;

Data.Foldable.$fFoldableU1_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6P0u ds1_s6P0v]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableU2;

Data.Foldable.$fFoldableU5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: U1"#;

Data.Foldable.$fFoldableU4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableU5;

Data.Foldable.$fFoldableU1_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6P0w ds1_s6P0x]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableU4;

Data.Foldable.$fFoldableU1_$cfoldl [InlPrag=INLINE (sat-args=3)]
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6P0y z_s6P0z ds1_s6P0A] z_s6P0z;

Data.Foldable.$fFoldableU1_$cfoldr [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6P0B z_s6P0C ds1_s6P0D] z_s6P0C;

Data.Foldable.$fFoldableU1_$cfoldMap [InlPrag=INLINE (sat-args=2)]
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.U1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P0E eta_s6P0F ds_s6P0G]
        GHC.Base.mempty $dMonoid_s6P0E;

Data.Foldable.$fFoldableU1_$cfold [InlPrag=INLINE (sat-args=1)]
  :: forall m. GHC.Base.Monoid m => GHC.Generics.U1 m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P0H ds_s6P0I] GHC.Base.mempty $dMonoid_s6P0H;

Data.Foldable.$fFoldableV1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.V1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P0J ds_s6P0K ds1_s6P0L]
        GHC.Base.mempty $dMonoid_s6P0J;

Data.Foldable.$fFoldablePar1_$cnull
  :: forall a. GHC.Generics.Par1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P0M] GHC.Types.False [];

Data.Foldable.$fFoldablePar1_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.Par1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6P0N z_s6P0O ds_s6P0P] f_s6P0N ds_s6P0P z_s6P0O;

Data.Foldable.$fFoldablePar1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.Par1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P0Q f_s6P0R ds_s6P0S] f_s6P0R ds_s6P0S;

Data.Foldable.$fFoldableK1_$cfoldMap
  :: forall i c m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.K1 i c a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P0T ds_s6P0U ds1_s6P0V]
        GHC.Base.mempty $dMonoid_s6P0T;

Data.Foldable.$fFoldable:+:_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P0W $dFoldable1_s6P0X ds_s6P0Y]
        case ds_s6P0Y of {
          GHC.Generics.L1 a1_s6P10 [Occ=Once] ->
              Data.Foldable.null $dFoldable_s6P0W a1_s6P10;
          GHC.Generics.R1 a1_s6P11 [Occ=Once] ->
              Data.Foldable.null $dFoldable1_s6P0X a1_s6P11;
        };

Data.Foldable.$fFoldable:+:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P12
           $dFoldable1_s6P13
           f1_s6P14
           z_s6P15
           ds_s6P16]
        case ds_s6P16 of {
          GHC.Generics.L1 a1_s6P18 [Occ=Once] ->
              Data.Foldable.foldr $dFoldable_s6P12 f1_s6P14 z_s6P15 a1_s6P18;
          GHC.Generics.R1 a1_s6P19 [Occ=Once] ->
              Data.Foldable.foldr $dFoldable1_s6P13 f1_s6P14 z_s6P15 a1_s6P19;
        };

Data.Foldable.$fFoldable:+:_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:+:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P1a
           $dFoldable1_s6P1b
           $dMonoid_s6P1c
           f1_s6P1d
           ds_s6P1e]
        case ds_s6P1e of {
          GHC.Generics.L1 a1_s6P1g [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_s6P1a $dMonoid_s6P1c f1_s6P1d a1_s6P1g;
          GHC.Generics.R1 a1_s6P1h [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_s6P1b $dMonoid_s6P1c f1_s6P1d a1_s6P1h;
        };

Data.Foldable.$fFoldable:*:_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(S)LLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P1i $dFoldable1_s6P1j ds_s6P1k]
        case ds_s6P1k of {
          GHC.Generics.:*: a1_s6P1m [Occ=Once] a2_s6P1n [Occ=Once] ->
              case Data.Foldable.null $dFoldable_s6P1i a1_s6P1m of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> Data.Foldable.null $dFoldable1_s6P1j a2_s6P1n;
              };
        };

Data.Foldable.$fFoldable:*:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P1p
           $dFoldable1_s6P1q
           f1_s6P1r
           z_s6P1s
           ds_s6P1t]
        case ds_s6P1t of {
          GHC.Generics.:*: a1_s6P1v [Occ=Once] a2_s6P1w [Occ=Once] ->
              let {
                sat_s6P1x [Occ=Once] :: b_a6L8t
                [LclId] =
                    [$dFoldable1_s6P1q f1_s6P1r z_s6P1s a2_s6P1w] \u []
                        Data.Foldable.foldr $dFoldable1_s6P1q f1_s6P1r z_s6P1s a2_s6P1w;
              } in 
                Data.Foldable.foldr $dFoldable_s6P1p f1_s6P1r sat_s6P1x a1_s6P1v;
        };

Data.Foldable.$w$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> f a -> g a -> m
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6P1y w1_s6P1z w2_s6P1A w3_s6P1B ww_s6P1C ww1_s6P1D]
        let {
          sat_s6P1F [Occ=Once] :: m_s6NSd
          [LclId] =
              [w1_s6P1z w2_s6P1A w3_s6P1B ww1_s6P1D] \u []
                  Data.Foldable.foldMap w1_s6P1z w2_s6P1A w3_s6P1B ww1_s6P1D; } in
        let {
          sat_s6P1E [Occ=Once] :: m_s6NSd
          [LclId] =
              [w_s6P1y w2_s6P1A w3_s6P1B ww_s6P1C] \u []
                  Data.Foldable.foldMap w_s6P1y w2_s6P1A w3_s6P1B ww_s6P1C;
        } in  GHC.Base.mappend w2_s6P1A sat_s6P1E sat_s6P1F;

Data.Foldable.$fFoldable:*:_$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:*:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6P1G w1_s6P1H w2_s6P1I w3_s6P1J w4_s6P1K]
        case w4_s6P1K of {
          GHC.Generics.:*: ww1_s6P1M [Occ=Once] ww2_s6P1N [Occ=Once] ->
              Data.Foldable.$w$cfoldMap
                  w_s6P1G w1_s6P1H w2_s6P1I w3_s6P1J ww1_s6P1M ww2_s6P1N;
        };

Data.Foldable.$fFoldable:.:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P1O
           $dFoldable1_s6P1P
           f1_s6P1Q
           z_s6P1R
           ds_s6P1S]
        let {
          sat_s6P1V [Occ=Once] :: g_a6L4V a_a6L5t -> b_a6L5u -> b_a6L5u
          [LclId] =
              [$dFoldable1_s6P1P f1_s6P1Q] \r [b1_s6P1T b2_s6P1U]
                  Data.Foldable.foldr $dFoldable1_s6P1P f1_s6P1Q b2_s6P1U b1_s6P1T;
        } in 
          Data.Foldable.foldr $dFoldable_s6P1O sat_s6P1V z_s6P1R ds_s6P1S;

Data.Foldable.$fFoldable:.:_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:.:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P1W
           $dFoldable1_s6P1X
           $dMonoid_s6P1Y
           f1_s6P1Z
           ds_s6P20]
        let {
          sat_s6P21 [Occ=Once] :: g_a6L4V a_a6L5c -> m_a6L5b
          [LclId] =
              [$dFoldable1_s6P1X $dMonoid_s6P1Y f1_s6P1Z] \u []
                  Data.Foldable.foldMap $dFoldable1_s6P1X $dMonoid_s6P1Y f1_s6P1Z;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6P1W $dMonoid_s6P1Y sat_s6P21 ds_s6P20;

Data.Foldable.$fFoldableURec4_$cnull
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P22]
        case ds_s6P22 of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec4_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P25 z_s6P26 ds_s6P27]
        case ds_s6P27 of { GHC.Generics.UAddr _ [Occ=Dead] -> z_s6P26; };

Data.Foldable.$fFoldableURec4_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P2a f_s6P2b ds_s6P2c]
        case ds_s6P2c of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P2a;
        };

Data.Foldable.$fFoldableURec3_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P2f]
        case ds_s6P2f of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec3_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Char a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P2i z_s6P2j ds_s6P2k]
        case ds_s6P2k of { GHC.Generics.UChar _ [Occ=Dead] -> z_s6P2j; };

Data.Foldable.$fFoldableURec3_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Char a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P2n f_s6P2o ds_s6P2p]
        case ds_s6P2p of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P2n;
        };

Data.Foldable.$fFoldableURec2_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P2s]
        case ds_s6P2s of {
          GHC.Generics.UDouble _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec2_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Double a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P2v z_s6P2w ds_s6P2x]
        case ds_s6P2x of { GHC.Generics.UDouble _ [Occ=Dead] -> z_s6P2w; };

Data.Foldable.$fFoldableURec2_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Double a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P2A f_s6P2B ds_s6P2C]
        case ds_s6P2C of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              GHC.Base.mempty $dMonoid_s6P2A;
        };

Data.Foldable.$fFoldableURec1_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P2F]
        case ds_s6P2F of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec1_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Float a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P2I z_s6P2J ds_s6P2K]
        case ds_s6P2K of { GHC.Generics.UFloat _ [Occ=Dead] -> z_s6P2J; };

Data.Foldable.$fFoldableURec1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Float a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P2N f_s6P2O ds_s6P2P]
        case ds_s6P2P of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P2N;
        };

Data.Foldable.$fFoldableURec0_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P2S]
        case ds_s6P2S of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec0_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Int a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P2V z_s6P2W ds_s6P2X]
        case ds_s6P2X of { GHC.Generics.UInt _ [Occ=Dead] -> z_s6P2W; };

Data.Foldable.$fFoldableURec0_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Int a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P30 f_s6P31 ds_s6P32]
        case ds_s6P32 of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P30;
        };

Data.Foldable.$fFoldableURec_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P35]
        case ds_s6P35 of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Word a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P38 z_s6P39 ds_s6P3a]
        case ds_s6P3a of { GHC.Generics.UWord _ [Occ=Dead] -> z_s6P39; };

Data.Foldable.$fFoldableURec_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Word a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P3d f_s6P3e ds_s6P3f]
        case ds_s6P3f of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P3d;
        };

Data.Foldable.$fFoldable:*:1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6P3i] v_s6P3i;

$dmproduct1_r6OSR
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6P3j $dNum_s6P3k]
        let {
          sat_s6P3l [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6KPT)
          [LclId] =
              [$dNum_s6P3k] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6P3k;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6P3j sat_s6P3l Data.Foldable.$fFoldable:*:1;

Data.Foldable.$dmproduct
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] $dmproduct1_r6OSR eta_B2 eta_B1;

$dmsum1_r6OSS
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6P3m $dNum_s6P3n]
        let {
          sat_s6P3o [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6KPz)
          [LclId] =
              [$dNum_s6P3n] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6P3n;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6P3m sat_s6P3o Data.Foldable.$fFoldable:*:1;

Data.Foldable.$dmsum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] $dmsum1_r6OSS eta_B2 eta_B1;

Data.Foldable.$fFoldableK3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

poly_d_r6OST :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK3
        of
        sat_s6P3p
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6P3p;
        };

Data.Foldable.$dmminimum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3q $dOrd_s6P3r]
        let {
          g_s6P3s [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_X6Kii a_a6KOY -> Data.Functor.Utils.Min a_a6KOY
          [LclId] =
              [$dFoldable_s6P3q $dOrd_s6P3r] \u []
                  let {
                    sat_s6P3t [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6KOY)
                    [LclId] =
                        [$dOrd_s6P3r] \u [] Data.Functor.Utils.$fMonoidMin $dOrd_s6P3r;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6P3q sat_s6P3t GHC.Base.Just; } in
        let {
          sat_s6P3x [Occ=OnceT[0]] :: t_X6Kii a_a6KOY -> a_a6KOY
          [LclId] =
              [g_s6P3s] \r [x_s6P3u]
                  case g_s6P3s x_s6P3u of {
                    GHC.Base.Nothing -> poly_d_r6OST;
                    GHC.Base.Just v_s6P3w [Occ=Once] -> v_s6P3w;
                  };
        } in  sat_s6P3x;

Data.Foldable.$fFoldableK5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

poly_d1_r6OSU :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK5
        of
        sat_s6P3y
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6P3y;
        };

Data.Foldable.$dmmaximum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3z $dOrd_s6P3A]
        let {
          g_s6P3B [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_X6Kij a_a6KOn -> Data.Functor.Utils.Max a_a6KOn
          [LclId] =
              [$dFoldable_s6P3z $dOrd_s6P3A] \u []
                  let {
                    sat_s6P3C [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6KOn)
                    [LclId] =
                        [$dOrd_s6P3A] \u [] Data.Functor.Utils.$fMonoidMax $dOrd_s6P3A;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6P3z sat_s6P3C GHC.Base.Just; } in
        let {
          sat_s6P3G [Occ=OnceT[0]] :: t_X6Kij a_a6KOn -> a_a6KOn
          [LclId] =
              [g_s6P3B] \r [x_s6P3D]
                  case g_s6P3B x_s6P3D of {
                    GHC.Base.Nothing -> poly_d1_r6OSU;
                    GHC.Base.Just v_s6P3F [Occ=Once] -> v_s6P3F;
                  };
        } in  sat_s6P3G;

Data.Foldable.$fFoldable:*:5
  :: forall a. GHC.Types.Int -> a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,A>m,
 Unf=OtherCon []] =
    [] \r [c_s6P3H ds_s6P3I]
        case c_s6P3H of {
          GHC.Types.I# x_s6P3K [Occ=Once] ->
              case +# [x_s6P3K 1#] of sat_s6P3L {
                __DEFAULT -> GHC.Types.I# [sat_s6P3L];
              };
        };

Data.Foldable.$dmlength
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3M]
        Data.Foldable.foldl'
            $dFoldable_s6P3M
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4;

lvl_r6OSV :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P3N ds1_s6P3O] GHC.Types.False [];

Data.Foldable.$dmnull
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3P]
        Data.Foldable.foldr $dFoldable_s6P3P lvl_r6OSV GHC.Types.True;

Data.Foldable.$dmtoList [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3Q t1_s6P3R]
        Data.Foldable.foldr
            $dFoldable_s6P3Q GHC.Types.: GHC.Types.[] t1_s6P3R;

Data.Foldable.$fFoldableK7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Foldable.$fFoldable:*:6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK7
        of
        sat_s6P3S
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6P3S;
        };

Data.Foldable.$dmfoldl1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId,
 Arity=3,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3T f_s6P3U xs_s6P3V]
        let {
          sat_s6P41 [Occ=Once]
            :: GHC.Base.Maybe a_a6KN3 -> a_a6KN3 -> GHC.Base.Maybe a_a6KN3
          [LclId] =
              [f_s6P3U] \r [m_s6P3W y_s6P3X]
                  let {
                    sat_s6P40 [Occ=Once] :: a_a6KN3
                    [LclId] =
                        [f_s6P3U m_s6P3W y_s6P3X] \u []
                            case m_s6P3W of {
                              GHC.Base.Nothing -> y_s6P3X;
                              GHC.Base.Just x_s6P3Z [Occ=Once] -> f_s6P3U x_s6P3Z y_s6P3X;
                            };
                  } in  GHC.Base.Just [sat_s6P40];
        } in 
          case
              Data.Foldable.foldl
                  $dFoldable_s6P3T sat_s6P41 GHC.Base.Nothing xs_s6P3V
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6P43 [Occ=Once] -> v_s6P43;
          };

Data.Foldable.$fFoldableK9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Foldable.$fFoldable:*:8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK9
        of
        sat_s6P44
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6P44;
        };

Data.Foldable.$dmfoldr1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P45 f_s6P46 xs_s6P47]
        let {
          sat_s6P4d [Occ=Once]
            :: a_a6KMx -> GHC.Base.Maybe a_a6KMx -> GHC.Base.Maybe a_a6KMx
          [LclId] =
              [f_s6P46] \r [x_s6P48 m_s6P49]
                  let {
                    sat_s6P4c [Occ=Once] :: a_a6KMx
                    [LclId] =
                        [f_s6P46 x_s6P48 m_s6P49] \u []
                            case m_s6P49 of {
                              GHC.Base.Nothing -> x_s6P48;
                              GHC.Base.Just y_s6P4b [Occ=Once] -> f_s6P46 x_s6P48 y_s6P4b;
                            };
                  } in  GHC.Base.Just [sat_s6P4c];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6P45 sat_s6P4d GHC.Base.Nothing xs_s6P47
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6P4f [Occ=Once] -> v_s6P4f;
          };

Data.Foldable.$dmfoldl'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P4g f_s6P4h z0_s6P4i xs_s6P4j]
        let {
          sat_s6P4o [Occ=Once]
            :: a_a6KM0 -> (b_a6KLZ -> b_a6KLZ) -> b_a6KLZ -> b_a6KLZ
          [LclId] =
              [f_s6P4h] \r [x_s6P4k k_s6P4l z_s6P4m]
                  case f_s6P4h z_s6P4m x_s6P4k of vx_s6P4n {
                    __DEFAULT -> k_s6P4l vx_s6P4n;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6P4g sat_s6P4o GHC.Base.id xs_s6P4j z0_s6P4i;

Data.Foldable.$fFoldable:*:7
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$dmfoldl
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P4p f_s6P4q z_s6P4r t1_s6P4s]
        let {
          sat_s6P4v [Occ=Once]
            :: a_a6KLz
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6KLy)
          [LclId] =
              [f_s6P4q] \r [x_s6P4t y_s6P4u] f_s6P4q y_s6P4u x_s6P4t;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6P4p
              Data.Foldable.$fFoldable:*:7
              sat_s6P4v
              t1_s6P4s
              z_s6P4r;

Data.Foldable.$dmfoldr'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P4w f_s6P4x z0_s6P4y xs_s6P4z]
        let {
          sat_s6P4E [Occ=Once]
            :: (b_a6KKX -> b_a6KKX) -> a_a6KKW -> b_a6KKX -> b_a6KKX
          [LclId] =
              [f_s6P4x] \r [k_s6P4A x_s6P4B z_s6P4C]
                  case f_s6P4x x_s6P4B z_s6P4C of vx_s6P4D {
                    __DEFAULT -> k_s6P4A vx_s6P4D;
                  };
        } in 
          Data.Foldable.foldl
              $dFoldable_s6P4w sat_s6P4E GHC.Base.id xs_s6P4z z0_s6P4y;

Data.Foldable.$fFoldableU1_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6P4F z0_s6P4G xs_s6P4H] z0_s6P4G;

Data.Foldable.$fFoldableK4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK5;

Data.Foldable.$fFoldableU1_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P4I eta_s6P4J]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableU1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6P4K z0_s6P4L xs_s6P4M] z0_s6P4L;

Data.Foldable.$fFoldableK2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK3;

Data.Foldable.$fFoldableU1_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P4N eta_s6P4O]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableU1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.U1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6P4P] [] [];

Data.Foldable.$fFoldableU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.U1
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableU1_$cfold
                                             Data.Foldable.$fFoldableU1_$cfoldMap
                                             Data.Foldable.$fFoldableU1_$cfoldr
                                             Data.Foldable.$fFoldableU1_$cfoldr'
                                             Data.Foldable.$fFoldableU1_$cfoldl
                                             Data.Foldable.$fFoldableU1_$cfoldl'
                                             Data.Foldable.$fFoldableU1_$cfoldr1
                                             Data.Foldable.$fFoldableU1_$cfoldl1
                                             Data.Foldable.$fFoldableU1_$ctoList
                                             Data.Foldable.$fFoldableU1_$cnull
                                             Data.Foldable.$fFoldableU1_$clength
                                             Data.Foldable.$fFoldableU1_$celem
                                             Data.Foldable.$fFoldableU1_$cmaximum
                                             Data.Foldable.$fFoldableU1_$cminimum
                                             Data.Foldable.$fFoldableU1_$csum
                                             Data.Foldable.$fFoldableU1_$cproduct];

Data.Foldable.$fFoldableProxy_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6P4Q z0_s6P4R xs_s6P4S] z0_s6P4R;

Data.Foldable.$fFoldableProxy_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P4T eta_s6P4U]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableProxy_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6P4V z0_s6P4W xs_s6P4X] z0_s6P4W;

Data.Foldable.$fFoldableProxy_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P4Y eta_s6P4Z]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableProxy_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Proxy.Proxy a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6P50] [] [];

Data.Foldable.$fFoldableProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Proxy.Proxy
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableProxy_$cfold
                                             Data.Foldable.$fFoldableProxy_$cfoldMap
                                             Data.Foldable.$fFoldableProxy_$cfoldr
                                             Data.Foldable.$fFoldableProxy_$cfoldr'
                                             Data.Foldable.$fFoldableProxy_$cfoldl
                                             Data.Foldable.$fFoldableProxy_$cfoldl'
                                             Data.Foldable.$fFoldableProxy_$cfoldr1
                                             Data.Foldable.$fFoldableProxy_$cfoldl1
                                             Data.Foldable.$fFoldableProxy_$ctoList
                                             Data.Foldable.$fFoldableProxy_$cnull
                                             Data.Foldable.$fFoldableProxy_$clength
                                             Data.Foldable.$fFoldableProxy_$celem
                                             Data.Foldable.$fFoldableProxy_$cmaximum
                                             Data.Foldable.$fFoldableProxy_$cminimum
                                             Data.Foldable.$fFoldableProxy_$csum
                                             Data.Foldable.$fFoldableProxy_$cproduct];

Data.Foldable.$dmfoldr
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P51 f_s6P52 z_s6P53 t1_s6P54]
        Data.Foldable.foldMap
            $dFoldable_s6P51
            Data.Semigroup.Internal.$fMonoidEndo
            f_s6P52
            t1_s6P54
            z_s6P53;

Data.Foldable.$dmfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*U,C(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P55 $dMonoid_s6P56 f_s6P57]
        let {
          sat_s6P5b [Occ=Once] :: m_a6KKk
          [LclId] =
              [$dMonoid_s6P56] \u [] GHC.Base.mempty $dMonoid_s6P56; } in
        let {
          sat_s6P5a [Occ=Once] :: a_a6KKl -> m_a6KKk -> m_a6KKk
          [LclId] =
              [$dMonoid_s6P56 f_s6P57] \r [x_s6P58]
                  let {
                    sat_s6P59 [Occ=Once] :: m_a6KKk
                    [LclId] =
                        [f_s6P57 x_s6P58] \u [] f_s6P57 x_s6P58;
                  } in  GHC.Base.mappend $dMonoid_s6P56 sat_s6P59;
        } in  Data.Foldable.foldr $dFoldable_s6P55 sat_s6P5a sat_s6P5b;

Data.Foldable.$dmfold
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m. GHC.Base.Monoid m => t m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P5c $dMonoid_s6P5d]
        Data.Foldable.foldMap $dFoldable_s6P5c $dMonoid_s6P5d GHC.Base.id;

Data.Foldable.$fFoldableDual7
  :: forall m. GHC.Base.Monoid m => m -> m
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dMonoid_s6P5e eta_B1] GHC.Base.id eta_B1;

Data.Foldable.$fFoldableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Product
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableProduct_$cfoldr
                                             Data.Foldable.$fFoldableProduct_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableProduct3
                                             Data.Foldable.$fFoldableProduct3
                                             Data.Foldable.$fFoldableProduct_$ctoList
                                             Data.Foldable.$fFoldableProduct_$cnull
                                             Data.Foldable.$fFoldableProduct_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableProduct2
                                             Data.Foldable.$fFoldableProduct2
                                             Data.Foldable.$fFoldableProduct1
                                             Data.Foldable.$fFoldableProduct1];

Data.Foldable.$fFoldableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Sum
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableSum_$cfoldr
                                             Data.Foldable.$fFoldableSum_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableSum3
                                             Data.Foldable.$fFoldableSum3
                                             Data.Foldable.$fFoldableSum_$ctoList
                                             Data.Foldable.$fFoldableSum_$cnull
                                             Data.Foldable.$fFoldableSum_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableSum2
                                             Data.Foldable.$fFoldableSum2
                                             Data.Foldable.$fFoldableSum1
                                             Data.Foldable.$fFoldableSum1];

Data.Foldable.$fFoldableDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Dual
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableDual_$cfoldr
                                             Data.Foldable.$fFoldableDual_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual4
                                             Data.Foldable.$fFoldableDual4
                                             Data.Foldable.$fFoldableDual_$ctoList
                                             Data.Foldable.$fFoldableDual_$cnull
                                             Data.Foldable.$fFoldableDual_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableDual2
                                             Data.Foldable.$fFoldableDual2
                                             Data.Foldable.$fFoldableDual1
                                             Data.Foldable.$fFoldableDual1];

Data.Foldable.$fFoldable[]_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6P5f z0_s6P5g xs_s6P5h]
        let-no-escape {
          go_s6P5i [Occ=LoopBreakerT[3]]
            :: [a_a6LRy] -> (b_a6LRz -> b_a6LRz) -> b_a6LRz -> b_a6LRz
          [LclId[JoinId(3)],
           Arity=3,
           Str=<S,1*U><C(S),1*C1(U)><L,U>,
           Unf=OtherCon []] =
              sat-only [f_s6P5f go_s6P5i] \r [ds_s6P5j eta_s6P5k eta1_s6P5l]
                  case ds_s6P5j of {
                    [] -> eta_s6P5k eta1_s6P5l;
                    : y_s6P5n [Occ=Once] ys_s6P5o [Occ=Once] ->
                        let {
                          sat_s6P5r [Occ=Once] :: b_a6LRz -> b_a6LRz
                          [LclId] =
                              [f_s6P5f eta_s6P5k y_s6P5n] \r [z_s6P5p]
                                  case f_s6P5f y_s6P5n z_s6P5p of vx_s6P5q {
                                    __DEFAULT -> eta_s6P5k vx_s6P5q;
                                  };
                        } in  go_s6P5i ys_s6P5o sat_s6P5r eta1_s6P5l;
                  };
        } in  go_s6P5i xs_s6P5h GHC.Base.id z0_s6P5g;

Data.Foldable.$fFoldable[]_$cfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> [a] -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P5s f_s6P5t eta_s6P5u]
        let {
          z_s6P5v [Occ=OnceL] :: m_a6LRe
          [LclId] =
              [$dMonoid_s6P5s] \u [] GHC.Base.mempty $dMonoid_s6P5s; } in
        let {
          go_s6P5w [Occ=LoopBreaker] :: [a_a6LRf] -> m_a6LRe
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_s6P5s f_s6P5t z_s6P5v go_s6P5w] \r [ds_s6P5x]
                  case ds_s6P5x of {
                    [] -> z_s6P5v;
                    : y_s6P5z [Occ=Once] ys_s6P5A [Occ=Once] ->
                        let {
                          sat_s6P5C [Occ=Once] :: m_a6LRe
                          [LclId] =
                              [go_s6P5w ys_s6P5A] \u [] go_s6P5w ys_s6P5A; } in
                        let {
                          sat_s6P5B [Occ=Once] :: m_a6LRe
                          [LclId] =
                              [f_s6P5t y_s6P5z] \u [] f_s6P5t y_s6P5z;
                        } in  GHC.Base.mappend $dMonoid_s6P5s sat_s6P5B sat_s6P5C;
                  };
        } in  go_s6P5w eta_s6P5u;

Data.Foldable.$fFoldableNonEmpty_$cfold1
  :: forall m. GHC.Base.Monoid m => [m] -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P5D eta_s6P5E]
        let {
          z_s6P5F [Occ=OnceL] :: m_a6LR4
          [LclId] =
              [$dMonoid_s6P5D] \u [] GHC.Base.mempty $dMonoid_s6P5D; } in
        let {
          go_s6P5G [Occ=LoopBreaker] :: [m_a6LR4] -> m_a6LR4
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_s6P5D z_s6P5F go_s6P5G] \r [ds_s6P5H]
                  case ds_s6P5H of {
                    [] -> z_s6P5F;
                    : y_s6P5J [Occ=Once] ys_s6P5K [Occ=Once] ->
                        let {
                          sat_s6P5L [Occ=Once] :: m_a6LR4
                          [LclId] =
                              [go_s6P5G ys_s6P5K] \u [] go_s6P5G ys_s6P5K;
                        } in  GHC.Base.mappend $dMonoid_s6P5D y_s6P5J sat_s6P5L;
                  };
        } in  go_s6P5G eta_s6P5E;

Data.Foldable.$fFoldable[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable []
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold1
                                             Data.Foldable.$fFoldable[]_$cfoldMap
                                             GHC.Base.foldr
                                             Data.Foldable.$fFoldable[]_$cfoldr'
                                             GHC.List.foldl
                                             GHC.List.foldl'
                                             GHC.List.foldr1
                                             GHC.List.foldl1
                                             GHC.Base.id
                                             GHC.List.null
                                             GHC.List.length
                                             GHC.List.elem
                                             GHC.List.maximum
                                             GHC.List.minimum
                                             GHC.List.sum
                                             GHC.List.product];

Data.Foldable.$fFoldableNonEmpty_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Base.NonEmpty m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),U(A,U,C(C1(U)),A)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P5M ds_s6P5N]
        let {
          sat_s6P5V [Occ=Once] :: m_a6LOt
          [LclId] =
              [$dMonoid_s6P5M ds_s6P5N] \u []
                  case ds_s6P5N of {
                    GHC.Base.:| _ [Occ=Dead] ms_s6P5U [Occ=Once] ->
                        Data.Foldable.$fFoldableNonEmpty_$cfold1 $dMonoid_s6P5M ms_s6P5U;
                  }; } in
        let {
          sat_s6P5R [Occ=Once] :: m_a6LOt
          [LclId] =
              [ds_s6P5N] \u []
                  case ds_s6P5N of {
                    GHC.Base.:| m1_s6P5P [Occ=Once] _ [Occ=Dead] -> m1_s6P5P;
                  };
        } in  GHC.Base.mappend $dMonoid_s6P5M sat_s6P5R sat_s6P5V;

Data.Foldable.$fFoldableNonEmpty_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Base.NonEmpty a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),U(A,1*U,C(C1(U)),A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P5W f_s6P5X ds_s6P5Y]
        let {
          sat_s6P6f [Occ=Once] :: m_a6LOG
          [LclId] =
              [$dMonoid_s6P5W f_s6P5X ds_s6P5Y] \u []
                  case ds_s6P5Y of {
                    GHC.Base.:| _ [Occ=Dead] as_s6P66 [Occ=Once] ->
                        let {
                          z_s6P67 [Occ=OnceL] :: m_a6LOG
                          [LclId] =
                              [$dMonoid_s6P5W] \u [] GHC.Base.mempty $dMonoid_s6P5W; } in
                        let {
                          go_s6P68 [Occ=LoopBreaker] :: [a_a6LOH] -> m_a6LOG
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dMonoid_s6P5W f_s6P5X z_s6P67 go_s6P68] \r [ds1_s6P69]
                                  case ds1_s6P69 of {
                                    [] -> z_s6P67;
                                    : y_s6P6b [Occ=Once] ys_s6P6c [Occ=Once] ->
                                        let {
                                          sat_s6P6e [Occ=Once] :: m_a6LOG
                                          [LclId] =
                                              [go_s6P68 ys_s6P6c] \u [] go_s6P68 ys_s6P6c; } in
                                        let {
                                          sat_s6P6d [Occ=Once] :: m_a6LOG
                                          [LclId] =
                                              [f_s6P5X y_s6P6b] \u [] f_s6P5X y_s6P6b;
                                        } in  GHC.Base.mappend $dMonoid_s6P5W sat_s6P6d sat_s6P6e;
                                  };
                        } in  go_s6P68 as_s6P66;
                  }; } in
        let {
          sat_s6P63 [Occ=Once] :: m_a6LOG
          [LclId] =
              [f_s6P5X ds_s6P5Y] \u []
                  let {
                    sat_s6P62 [Occ=Once] :: a_a6LOH
                    [LclId] =
                        [ds_s6P5Y] \u []
                            case ds_s6P5Y of {
                              GHC.Base.:| a1_s6P60 [Occ=Once] _ [Occ=Dead] -> a1_s6P60;
                            };
                  } in  f_s6P5X sat_s6P62;
        } in  GHC.Base.mappend $dMonoid_s6P5W sat_s6P63 sat_s6P6f;

Data.Foldable.foldrM
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (a -> b -> m b) -> b -> t a -> m b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6g $dMonad_s6P6h f_s6P6i z0_s6P6j xs_s6P6k]
        let {
          sat_s6P6q [Occ=Once] :: b_a6KJt -> m_a6KJr b_a6KJt
          [LclId] =
              [$dMonad_s6P6h] \u [] GHC.Base.return $dMonad_s6P6h; } in
        let {
          sat_s6P6p [Occ=Once]
            :: (b_a6KJt -> m_a6KJr b_a6KJt)
               -> a_a6KJs -> b_a6KJt -> m_a6KJr b_a6KJt
          [LclId] =
              [$dMonad_s6P6h f_s6P6i] \r [k_s6P6l x_s6P6m z_s6P6n]
                  let {
                    sat_s6P6o [Occ=Once] :: m_a6KJr b_a6KJt
                    [LclId] =
                        [f_s6P6i x_s6P6m z_s6P6n] \u [] f_s6P6i x_s6P6m z_s6P6n;
                  } in  GHC.Base.>>= $dMonad_s6P6h sat_s6P6o k_s6P6l;
        } in 
          Data.Foldable.foldl
              $dFoldable_s6P6g sat_s6P6p sat_s6P6q xs_s6P6k z0_s6P6j;

Data.Foldable.foldlM
  :: forall (t :: * -> *) (m :: * -> *) b a.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (b -> a -> m b) -> b -> t a -> m b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6r $dMonad_s6P6s f_s6P6t z0_s6P6u xs_s6P6v]
        let {
          sat_s6P6B [Occ=Once] :: b_a6KHt -> m_a6KHs b_a6KHt
          [LclId] =
              [$dMonad_s6P6s] \u [] GHC.Base.return $dMonad_s6P6s; } in
        let {
          sat_s6P6A [Occ=Once]
            :: a_a6KHu
               -> (b_a6KHt -> m_a6KHs b_a6KHt) -> b_a6KHt -> m_a6KHs b_a6KHt
          [LclId] =
              [$dMonad_s6P6s f_s6P6t] \r [x_s6P6w k_s6P6x z_s6P6y]
                  let {
                    sat_s6P6z [Occ=Once] :: m_a6KHs b_a6KHt
                    [LclId] =
                        [f_s6P6t x_s6P6w z_s6P6y] \u [] f_s6P6t z_s6P6y x_s6P6w;
                  } in  GHC.Base.>>= $dMonad_s6P6s sat_s6P6z k_s6P6x;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6P6r sat_s6P6A sat_s6P6B xs_s6P6v z0_s6P6u;

Data.Foldable.traverse_
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     (a -> f b) -> t a -> f ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6C $dApplicative_s6P6D f1_s6P6E]
        let {
          sat_s6P6I [Occ=Once] :: f_a6KGP ()
          [LclId] =
              [$dApplicative_s6P6D] \u []
                  GHC.Base.pure $dApplicative_s6P6D GHC.Tuple.(); } in
        let {
          sat_s6P6H [Occ=Once] :: a_a6KGQ -> f_a6KGP () -> f_a6KGP ()
          [LclId] =
              [$dApplicative_s6P6D f1_s6P6E] \r [x_s6P6F]
                  let {
                    sat_s6P6G [Occ=Once] :: f_a6KGP b_a6KGR
                    [LclId] =
                        [f1_s6P6E x_s6P6F] \u [] f1_s6P6E x_s6P6F;
                  } in  GHC.Base.*> $dApplicative_s6P6D sat_s6P6G;
        } in  Data.Foldable.foldr $dFoldable_s6P6C sat_s6P6H sat_s6P6I;

Data.Foldable.for_ [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     t a -> (a -> f b) -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6J $dApplicative_s6P6K x_s6P6L y_s6P6M]
        Data.Foldable.traverse_
            $dFoldable_s6P6J $dApplicative_s6P6K y_s6P6M x_s6P6L;

Data.Foldable.mapM_
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (a -> m b) -> t a -> m ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(U),1*C1(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6N $dMonad_s6P6O f_s6P6P]
        let {
          sat_s6P6T [Occ=Once] :: m_a6KG8 ()
          [LclId] =
              [$dMonad_s6P6O] \u []
                  GHC.Base.return $dMonad_s6P6O GHC.Tuple.(); } in
        let {
          sat_s6P6S [Occ=Once] :: a_a6KG9 -> m_a6KG8 () -> m_a6KG8 ()
          [LclId] =
              [$dMonad_s6P6O f_s6P6P] \r [x_s6P6Q]
                  let {
                    sat_s6P6R [Occ=Once] :: m_a6KG8 b_a6KGa
                    [LclId] =
                        [f_s6P6P x_s6P6Q] \u [] f_s6P6P x_s6P6Q;
                  } in  GHC.Base.>> $dMonad_s6P6O sat_s6P6R;
        } in  Data.Foldable.foldr $dFoldable_s6P6N sat_s6P6S sat_s6P6T;

Data.Foldable.forM_ [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     t a -> (a -> m b) -> m ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(U),C(U),A)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6U $dMonad_s6P6V x_s6P6W y_s6P6X]
        Data.Foldable.mapM_ $dFoldable_s6P6U $dMonad_s6P6V y_s6P6X x_s6P6W;

Data.Foldable.sequenceA_
  :: forall (t :: * -> *) (f :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     t (f a) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(U),A,A,1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6Y $dApplicative_s6P6Z]
        let {
          sat_s6P71 [Occ=Once] :: f_a6KFQ ()
          [LclId] =
              [$dApplicative_s6P6Z] \u []
                  GHC.Base.pure $dApplicative_s6P6Z GHC.Tuple.(); } in
        let {
          sat_s6P70 [Occ=Once] :: f_a6KFQ a_a6KFR -> f_a6KFQ () -> f_a6KFQ ()
          [LclId] =
              [$dApplicative_s6P6Z] \u [] GHC.Base.*> $dApplicative_s6P6Z;
        } in  Data.Foldable.foldr $dFoldable_s6P6Y sat_s6P70 sat_s6P71;

Data.Foldable.sequence_
  :: forall (t :: * -> *) (m :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     t (m a) -> m ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,1*U,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P72 $dMonad_s6P73]
        let {
          sat_s6P75 [Occ=Once] :: m_a6KFy ()
          [LclId] =
              [$dMonad_s6P73] \u []
                  GHC.Base.return $dMonad_s6P73 GHC.Tuple.(); } in
        let {
          sat_s6P74 [Occ=Once] :: m_a6KFy a_a6KFz -> m_a6KFy () -> m_a6KFy ()
          [LclId] =
              [$dMonad_s6P73] \u [] GHC.Base.>> $dMonad_s6P73;
        } in  Data.Foldable.foldr $dFoldable_s6P72 sat_s6P74 sat_s6P75;

Data.Foldable.asum [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Alternative f) =>
     t (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P76 $dAlternative_s6P77]
        let {
          sat_s6P79 [Occ=Once] :: f_a6KF3 a_a6KF4
          [LclId] =
              [$dAlternative_s6P77] \u []
                  GHC.Base.empty $dAlternative_s6P77; } in
        let {
          sat_s6P78 [Occ=Once]
            :: f_a6KF3 a_a6KF4 -> f_a6KF3 a_a6KF4 -> f_a6KF3 a_a6KF4
          [LclId] =
              [$dAlternative_s6P77] \u [] GHC.Base.<|> $dAlternative_s6P77;
        } in  Data.Foldable.foldr $dFoldable_s6P76 sat_s6P78 sat_s6P79;

Data.Foldable.msum [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.MonadPlus m) =>
     t (m a) -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*U(A,1*U,1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7a $dMonadPlus_s6P7b]
        let {
          $dAlternative_s6P7c [Dmd=<L,U(A,1*U,1*U,A,A)>]
            :: GHC.Base.Alternative m_a6KFm
          [LclId] =
              [$dMonadPlus_s6P7b] \u []
                  GHC.Base.$p1MonadPlus $dMonadPlus_s6P7b; } in
        let {
          sat_s6P7e [Occ=Once] :: m_a6KFm a_a6KFn
          [LclId] =
              [$dAlternative_s6P7c] \u []
                  GHC.Base.empty $dAlternative_s6P7c; } in
        let {
          sat_s6P7d [Occ=Once]
            :: m_a6KFm a_a6KFn -> m_a6KFm a_a6KFn -> m_a6KFm a_a6KFn
          [LclId] =
              [$dAlternative_s6P7c] \u [] GHC.Base.<|> $dAlternative_s6P7c;
        } in  Data.Foldable.foldr $dFoldable_s6P7a sat_s6P7d sat_s6P7e;

Data.Foldable.concat [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *) a. Data.Foldable.Foldable t => t [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7f xs_s6P7g]
        Data.Foldable.foldr
            $dFoldable_s6P7f GHC.Base.++ GHC.Types.[] xs_s6P7g;

Data.Foldable.concatMap [InlPrag=INLINE (sat-args=2)]
  :: forall (t :: * -> *) a b.
     Data.Foldable.Foldable t =>
     (a -> [b]) -> t a -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7h f_s6P7i xs_s6P7j]
        let {
          sat_s6P7n [Occ=Once] :: a_a6KEs -> [b_a6KEt] -> [b_a6KEt]
          [LclId] =
              [f_s6P7i] \r [x_s6P7k b1_s6P7l]
                  case f_s6P7i x_s6P7k of sat_s6P7m {
                    __DEFAULT -> GHC.Base.++ sat_s6P7m b1_s6P7l;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6P7h sat_s6P7n GHC.Types.[] xs_s6P7j;

Data.Foldable.and2 :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6P7o] v_s6P7o;

Data.Foldable.and1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7p]
        Data.Foldable.foldMap
            $dFoldable_s6P7p
            Data.Semigroup.Internal.$fMonoidAll
            Data.Foldable.and2;

Data.Foldable.and
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Foldable.and1 eta_B1;

Data.Foldable.or1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7q]
        Data.Foldable.foldMap
            $dFoldable_s6P7q
            Data.Semigroup.Internal.$fMonoidAny
            Data.Foldable.and2;

Data.Foldable.or
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Foldable.or1 eta_B1;

Data.Foldable.any1
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7r p_s6P7s]
        Data.Foldable.foldMap
            $dFoldable_s6P7r Data.Semigroup.Internal.$fMonoidAny p_s6P7s;

Data.Foldable.any
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Foldable.any1 eta_B2 eta_B1;

$dmelem1_r6OSW
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a.
     GHC.Classes.Eq a =>
     a -> t a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6P7t $dEq_s6P7u eta_s6P7v]
        let {
          sat_s6P7w [Occ=Once] :: a_a6KO9 -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_s6P7u eta_s6P7v] \u [] GHC.Classes.== $dEq_s6P7u eta_s6P7v;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6P7t Data.Semigroup.Internal.$fMonoidAny sat_s6P7w;

Data.Foldable.$dmelem
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $dmelem1_r6OSW eta_B3 eta_B2 eta_B1;

Data.Foldable.$fFoldableURec11
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Word a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P7x eta_s6P7y eta1_s6P7z]
        case eta1_s6P7z of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec8
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Word a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P7C ds_s6P7D]
        case ds_s6P7D of {
          GHC.Generics.UWord _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6P7C;
        };

Data.Foldable.$fFoldable:*:2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableURec9
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P7G] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P7H eta_s6P7I]
        Data.Foldable.$fFoldableURec9 eta_s6P7I;

Data.Foldable.$fFoldable:*:3 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableURec10
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P7J] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P7K eta_s6P7L]
        Data.Foldable.$fFoldableURec10 eta_s6P7L;

Data.Foldable.$fFoldableURec_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P7M xs_s6P7N] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Word a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P7O z0_s6P7P xs_s6P7Q]
        case xs_s6P7Q of { GHC.Generics.UWord _ [Occ=Dead] -> z0_s6P7P; };

Data.Foldable.$fFoldableURec_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6P7T]
        case xs_s6P7T of {
          GHC.Generics.UWord _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P7W xs_s6P7X] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Word m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P7Y ds_s6P7Z]
        case ds_s6P7Z of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P7Y;
        };

Data.Foldable.$fFoldableURec7
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Word a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P82 ds_s6P83]
        case ds_s6P83 of {
          GHC.Generics.UWord _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6P82;
        };

Data.Foldable.$fFoldableURec_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6P86]
        case eta_s6P86 of { GHC.Generics.UWord _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Word)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec_$cfold
                                             Data.Foldable.$fFoldableURec_$cfoldMap
                                             Data.Foldable.$fFoldableURec_$cfoldr
                                             Data.Foldable.$fFoldableURec_$cfoldr
                                             Data.Foldable.$fFoldableURec_$cfoldl'
                                             Data.Foldable.$fFoldableURec_$cfoldl'
                                             Data.Foldable.$fFoldableURec_$cfoldr1
                                             Data.Foldable.$fFoldableURec_$cfoldl1
                                             Data.Foldable.$fFoldableURec_$ctoList
                                             Data.Foldable.$fFoldableURec_$cnull
                                             Data.Foldable.$fFoldableURec_$clength
                                             Data.Foldable.$fFoldableURec11
                                             Data.Foldable.$fFoldableURec_$cmaximum
                                             Data.Foldable.$fFoldableURec_$cminimum
                                             Data.Foldable.$fFoldableURec8
                                             Data.Foldable.$fFoldableURec7];

Data.Foldable.$fFoldableURec16
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Int a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P89 eta_s6P8a eta1_s6P8b]
        case eta1_s6P8b of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec13
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Int a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P8e ds_s6P8f]
        case ds_s6P8f of {
          GHC.Generics.UInt _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6P8e;
        };

Data.Foldable.$fFoldableURec14
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P8i] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec0_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P8j eta_s6P8k]
        Data.Foldable.$fFoldableURec14 eta_s6P8k;

Data.Foldable.$fFoldableURec15
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P8l] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec0_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P8m eta_s6P8n]
        Data.Foldable.$fFoldableURec15 eta_s6P8n;

Data.Foldable.$fFoldableURec0_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P8o xs_s6P8p] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec0_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Int a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P8q z0_s6P8r xs_s6P8s]
        case xs_s6P8s of { GHC.Generics.UInt _ [Occ=Dead] -> z0_s6P8r; };

Data.Foldable.$fFoldableURec0_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6P8v]
        case xs_s6P8v of {
          GHC.Generics.UInt _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec0_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P8y xs_s6P8z] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec0_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Int m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P8A ds_s6P8B]
        case ds_s6P8B of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P8A;
        };

Data.Foldable.$fFoldableURec12
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Int a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P8E ds_s6P8F]
        case ds_s6P8F of {
          GHC.Generics.UInt _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6P8E;
        };

Data.Foldable.$fFoldableURec0_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6P8I]
        case eta_s6P8I of { GHC.Generics.UInt _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec0 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Int)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec0_$cfold
                                             Data.Foldable.$fFoldableURec0_$cfoldMap
                                             Data.Foldable.$fFoldableURec0_$cfoldr
                                             Data.Foldable.$fFoldableURec0_$cfoldr
                                             Data.Foldable.$fFoldableURec0_$cfoldl'
                                             Data.Foldable.$fFoldableURec0_$cfoldl'
                                             Data.Foldable.$fFoldableURec0_$cfoldr1
                                             Data.Foldable.$fFoldableURec0_$cfoldl1
                                             Data.Foldable.$fFoldableURec0_$ctoList
                                             Data.Foldable.$fFoldableURec0_$cnull
                                             Data.Foldable.$fFoldableURec0_$clength
                                             Data.Foldable.$fFoldableURec16
                                             Data.Foldable.$fFoldableURec0_$cmaximum
                                             Data.Foldable.$fFoldableURec0_$cminimum
                                             Data.Foldable.$fFoldableURec13
                                             Data.Foldable.$fFoldableURec12];

Data.Foldable.$fFoldableURec21
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P8L eta_s6P8M eta1_s6P8N]
        case eta1_s6P8N of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec18
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P8Q ds_s6P8R]
        case ds_s6P8R of {
          GHC.Generics.UFloat _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6P8Q;
        };

Data.Foldable.$fFoldableURec19
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P8U] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec1_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P8V eta_s6P8W]
        Data.Foldable.$fFoldableURec19 eta_s6P8W;

Data.Foldable.$fFoldableURec20
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P8X] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec1_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P8Y eta_s6P8Z]
        Data.Foldable.$fFoldableURec20 eta_s6P8Z;

Data.Foldable.$fFoldableURec1_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P90 xs_s6P91] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec1_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Float a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P92 z0_s6P93 xs_s6P94]
        case xs_s6P94 of { GHC.Generics.UFloat _ [Occ=Dead] -> z0_s6P93; };

Data.Foldable.$fFoldableURec1_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6P97]
        case xs_s6P97 of {
          GHC.Generics.UFloat _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec1_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P9a xs_s6P9b] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec1_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Float m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P9c ds_s6P9d]
        case ds_s6P9d of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P9c;
        };

Data.Foldable.$fFoldableURec17
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P9g ds_s6P9h]
        case ds_s6P9h of {
          GHC.Generics.UFloat _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6P9g;
        };

Data.Foldable.$fFoldableURec1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6P9k]
        case eta_s6P9k of { GHC.Generics.UFloat _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Float)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec1_$cfold
                                             Data.Foldable.$fFoldableURec1_$cfoldMap
                                             Data.Foldable.$fFoldableURec1_$cfoldr
                                             Data.Foldable.$fFoldableURec1_$cfoldr
                                             Data.Foldable.$fFoldableURec1_$cfoldl'
                                             Data.Foldable.$fFoldableURec1_$cfoldl'
                                             Data.Foldable.$fFoldableURec1_$cfoldr1
                                             Data.Foldable.$fFoldableURec1_$cfoldl1
                                             Data.Foldable.$fFoldableURec1_$ctoList
                                             Data.Foldable.$fFoldableURec1_$cnull
                                             Data.Foldable.$fFoldableURec1_$clength
                                             Data.Foldable.$fFoldableURec21
                                             Data.Foldable.$fFoldableURec1_$cmaximum
                                             Data.Foldable.$fFoldableURec1_$cminimum
                                             Data.Foldable.$fFoldableURec18
                                             Data.Foldable.$fFoldableURec17];

Data.Foldable.$fFoldableURec26
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P9n eta_s6P9o eta1_s6P9p]
        case eta1_s6P9p of {
          GHC.Generics.UDouble _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec23
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P9s ds_s6P9t]
        case ds_s6P9t of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6P9s;
        };

Data.Foldable.$fFoldableURec24
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P9w] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec2_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P9x eta_s6P9y]
        Data.Foldable.$fFoldableURec24 eta_s6P9y;

Data.Foldable.$fFoldableURec25
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P9z] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec2_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P9A eta_s6P9B]
        Data.Foldable.$fFoldableURec25 eta_s6P9B;

Data.Foldable.$fFoldableURec2_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P9C xs_s6P9D] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec2_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Double a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P9E z0_s6P9F xs_s6P9G]
        case xs_s6P9G of {
          GHC.Generics.UDouble _ [Occ=Dead] -> z0_s6P9F;
        };

Data.Foldable.$fFoldableURec2_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6P9J]
        case xs_s6P9J of {
          GHC.Generics.UDouble _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec2_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P9M xs_s6P9N] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec2_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Double m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P9O ds_s6P9P]
        case ds_s6P9P of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              GHC.Base.mempty $dMonoid_s6P9O;
        };

Data.Foldable.$fFoldableURec22
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P9S ds_s6P9T]
        case ds_s6P9T of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6P9S;
        };

Data.Foldable.$fFoldableURec2_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6P9W]
        case eta_s6P9W of { GHC.Generics.UDouble _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec2 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Double)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec2_$cfold
                                             Data.Foldable.$fFoldableURec2_$cfoldMap
                                             Data.Foldable.$fFoldableURec2_$cfoldr
                                             Data.Foldable.$fFoldableURec2_$cfoldr
                                             Data.Foldable.$fFoldableURec2_$cfoldl'
                                             Data.Foldable.$fFoldableURec2_$cfoldl'
                                             Data.Foldable.$fFoldableURec2_$cfoldr1
                                             Data.Foldable.$fFoldableURec2_$cfoldl1
                                             Data.Foldable.$fFoldableURec2_$ctoList
                                             Data.Foldable.$fFoldableURec2_$cnull
                                             Data.Foldable.$fFoldableURec2_$clength
                                             Data.Foldable.$fFoldableURec26
                                             Data.Foldable.$fFoldableURec2_$cmaximum
                                             Data.Foldable.$fFoldableURec2_$cminimum
                                             Data.Foldable.$fFoldableURec23
                                             Data.Foldable.$fFoldableURec22];

Data.Foldable.$fFoldableURec31
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Char a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P9Z eta_s6Pa0 eta1_s6Pa1]
        case eta1_s6Pa1 of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec28
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Char a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pa4 ds_s6Pa5]
        case ds_s6Pa5 of {
          GHC.Generics.UChar _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Pa4;
        };

Data.Foldable.$fFoldableURec29
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Pa8] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec3_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Pa9 eta_s6Paa]
        Data.Foldable.$fFoldableURec29 eta_s6Paa;

Data.Foldable.$fFoldableURec30
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Pab] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec3_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Pac eta_s6Pad]
        Data.Foldable.$fFoldableURec30 eta_s6Pad;

Data.Foldable.$fFoldableURec3_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pae xs_s6Paf] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec3_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Char a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Pag z0_s6Pah xs_s6Pai]
        case xs_s6Pai of { GHC.Generics.UChar _ [Occ=Dead] -> z0_s6Pah; };

Data.Foldable.$fFoldableURec3_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6Pal]
        case xs_s6Pal of {
          GHC.Generics.UChar _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec3_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pao xs_s6Pap] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec3_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Char m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Paq ds_s6Par]
        case ds_s6Par of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Paq;
        };

Data.Foldable.$fFoldableURec27
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Char a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pau ds_s6Pav]
        case ds_s6Pav of {
          GHC.Generics.UChar _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Pau;
        };

Data.Foldable.$fFoldableURec3_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6Pay]
        case eta_s6Pay of { GHC.Generics.UChar _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec3 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Char)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec3_$cfold
                                             Data.Foldable.$fFoldableURec3_$cfoldMap
                                             Data.Foldable.$fFoldableURec3_$cfoldr
                                             Data.Foldable.$fFoldableURec3_$cfoldr
                                             Data.Foldable.$fFoldableURec3_$cfoldl'
                                             Data.Foldable.$fFoldableURec3_$cfoldl'
                                             Data.Foldable.$fFoldableURec3_$cfoldr1
                                             Data.Foldable.$fFoldableURec3_$cfoldl1
                                             Data.Foldable.$fFoldableURec3_$ctoList
                                             Data.Foldable.$fFoldableURec3_$cnull
                                             Data.Foldable.$fFoldableURec3_$clength
                                             Data.Foldable.$fFoldableURec31
                                             Data.Foldable.$fFoldableURec3_$cmaximum
                                             Data.Foldable.$fFoldableURec3_$cminimum
                                             Data.Foldable.$fFoldableURec28
                                             Data.Foldable.$fFoldableURec27];

Data.Foldable.$fFoldableURec36
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6PaB eta_s6PaC eta1_s6PaD]
        case eta1_s6PaD of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec33
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PaG ds_s6PaH]
        case ds_s6PaH of {
          GHC.Generics.UAddr _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6PaG;
        };

Data.Foldable.$fFoldableURec34
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6PaK] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec4_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6PaL eta_s6PaM]
        Data.Foldable.$fFoldableURec34 eta_s6PaM;

Data.Foldable.$fFoldableURec35
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6PaN] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec4_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6PaO eta_s6PaP]
        Data.Foldable.$fFoldableURec35 eta_s6PaP;

Data.Foldable.$fFoldableURec4_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6PaQ xs_s6PaR] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec4_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6PaS z0_s6PaT xs_s6PaU]
        case xs_s6PaU of { GHC.Generics.UAddr _ [Occ=Dead] -> z0_s6PaT; };

Data.Foldable.$fFoldableURec4_$clength
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6PaX]
        case xs_s6PaX of {
          GHC.Generics.UAddr _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec4_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pb0 xs_s6Pb1] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec4_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pb2 ds_s6Pb3]
        case ds_s6Pb3 of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Pb2;
        };

Data.Foldable.$fFoldableURec32
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pb6 ds_s6Pb7]
        case ds_s6Pb7 of {
          GHC.Generics.UAddr _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Pb6;
        };

Data.Foldable.$fFoldableURec4_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6Pba]
        case eta_s6Pba of { GHC.Generics.UAddr _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec4 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec (GHC.Ptr.Ptr ()))
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec4_$cfold
                                             Data.Foldable.$fFoldableURec4_$cfoldMap
                                             Data.Foldable.$fFoldableURec4_$cfoldr
                                             Data.Foldable.$fFoldableURec4_$cfoldr
                                             Data.Foldable.$fFoldableURec4_$cfoldl'
                                             Data.Foldable.$fFoldableURec4_$cfoldl'
                                             Data.Foldable.$fFoldableURec4_$cfoldr1
                                             Data.Foldable.$fFoldableURec4_$cfoldl1
                                             Data.Foldable.$fFoldableURec4_$ctoList
                                             Data.Foldable.$fFoldableURec4_$cnull
                                             Data.Foldable.$fFoldableURec4_$clength
                                             Data.Foldable.$fFoldableURec36
                                             Data.Foldable.$fFoldableURec4_$cmaximum
                                             Data.Foldable.$fFoldableURec4_$cminimum
                                             Data.Foldable.$fFoldableURec33
                                             Data.Foldable.$fFoldableURec32];

Data.Foldable.$fFoldable:*:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:*:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pbd $dFoldable1_s6Pbe $dEq_s6Pbf eta_s6Pbg]
        let {
          f1_s6Pbh :: a_a6Lad -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Pbf eta_s6Pbg] \u []
                  GHC.Classes.== $dEq_s6Pbf eta_s6Pbg; } in
        let {
          sat_s6Pbn [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lad
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6Pbd $dFoldable1_s6Pbe f1_s6Pbh] \r [ds_s6Pbi]
                  case ds_s6Pbi of {
                    GHC.Generics.:*: a1_s6Pbk [Occ=Once] a2_s6Pbl [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6Pbd
                                Data.Semigroup.Internal.$fMonoidAny
                                f1_s6Pbh
                                a1_s6Pbk
                        of
                        { GHC.Types.False ->
                              Data.Foldable.foldMap
                                  $dFoldable1_s6Pbe
                                  Data.Semigroup.Internal.$fMonoidAny
                                  f1_s6Pbh
                                  a2_s6Pbl;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_s6Pbn;

Data.Foldable.$fFoldable:*:_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pbo $dFoldable1_s6Pbp $dNum_s6Pbq]
        let {
          $dMonoid_s6Pbr
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LaH)
          [LclId] =
              [$dNum_s6Pbq] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6Pbq; } in
        let {
          sat_s6Pby [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6LaH
               -> Data.Semigroup.Internal.Sum a_a6LaH
          [LclId] =
              [$dFoldable_s6Pbo
               $dFoldable1_s6Pbp
               $dNum_s6Pbq
               $dMonoid_s6Pbr] \r [ds_s6Pbs]
                  case ds_s6Pbs of {
                    GHC.Generics.:*: a1_s6Pbu [Occ=Once] a2_s6Pbv [Occ=Once] ->
                        let {
                          sat_s6Pbx [Occ=Once] :: a_a6LaH
                          [LclId] =
                              [$dFoldable1_s6Pbp $dMonoid_s6Pbr a2_s6Pbv] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_s6Pbp
                                      $dMonoid_s6Pbr
                                      Data.Foldable.$fFoldable:*:1
                                      a2_s6Pbv; } in
                        let {
                          sat_s6Pbw [Occ=Once] :: a_a6LaH
                          [LclId] =
                              [$dFoldable_s6Pbo $dMonoid_s6Pbr a1_s6Pbu] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Pbo
                                      $dMonoid_s6Pbr
                                      Data.Foldable.$fFoldable:*:1
                                      a1_s6Pbu;
                        } in  GHC.Num.+ $dNum_s6Pbq sat_s6Pbw sat_s6Pbx;
                  };
        } in  sat_s6Pby;

Data.Foldable.$fFoldable:*:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pbz $dFoldable1_s6PbA $dOrd_s6PbB]
        let {
          $dMonoid_s6PbC :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6Lax)
          [LclId] =
              [$dOrd_s6PbB] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6PbB; } in
        let {
          sat_s6PbO [Occ=OnceT[0]]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lax -> a_a6Lax
          [LclId] =
              [$dFoldable_s6Pbz
               $dFoldable1_s6PbA
               $dOrd_s6PbB
               $dMonoid_s6PbC] \r [x_s6PbD]
                  case x_s6PbD of {
                    GHC.Generics.:*: a1_s6PbF [Occ=Once*] a2_s6PbG [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6PbA $dMonoid_s6PbC GHC.Base.Just a2_s6PbG
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Pbz $dMonoid_s6PbC GHC.Base.Just a1_s6PbF
                              of
                              { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                                GHC.Base.Just v_s6PbJ [Occ=Once] -> v_s6PbJ;
                              };
                          GHC.Base.Just ipv_s6PbK ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Pbz $dMonoid_s6PbC GHC.Base.Just a1_s6PbF
                              of
                              { GHC.Base.Nothing -> ipv_s6PbK;
                                GHC.Base.Just x1_s6PbM ->
                                    case GHC.Classes.<= $dOrd_s6PbB x1_s6PbM ipv_s6PbK of {
                                      GHC.Types.False -> ipv_s6PbK;
                                      GHC.Types.True -> x1_s6PbM;
                                    };
                              };
                        };
                  };
        } in  sat_s6PbO;

Data.Foldable.$fFoldable:*:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PbP $dFoldable1_s6PbQ $dOrd_s6PbR]
        let {
          $dMonoid_s6PbS :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lan)
          [LclId] =
              [$dOrd_s6PbR] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6PbR; } in
        let {
          sat_s6Pc4 [Occ=OnceT[0]]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lan -> a_a6Lan
          [LclId] =
              [$dFoldable_s6PbP
               $dFoldable1_s6PbQ
               $dOrd_s6PbR
               $dMonoid_s6PbS] \r [x_s6PbT]
                  case x_s6PbT of {
                    GHC.Generics.:*: a1_s6PbV [Occ=Once*] a2_s6PbW [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6PbQ $dMonoid_s6PbS GHC.Base.Just a2_s6PbW
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6PbP $dMonoid_s6PbS GHC.Base.Just a1_s6PbV
                              of
                              { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                                GHC.Base.Just v_s6PbZ [Occ=Once] -> v_s6PbZ;
                              };
                          GHC.Base.Just ipv_s6Pc0 ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6PbP $dMonoid_s6PbS GHC.Base.Just a1_s6PbV
                              of
                              { GHC.Base.Nothing -> ipv_s6Pc0;
                                GHC.Base.Just x1_s6Pc2 ->
                                    case GHC.Classes.>= $dOrd_s6PbR x1_s6Pc2 ipv_s6Pc0 of {
                                      GHC.Types.False -> ipv_s6Pc0;
                                      GHC.Types.True -> x1_s6Pc2;
                                    };
                              };
                        };
                  };
        } in  sat_s6Pc4;

Data.Foldable.$w$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pc5 w1_s6Pc6 w2_s6Pc7 ww_s6Pc8 ww1_s6Pc9]
        let {
          f1_s6Pca
            :: a_s6NTG -> GHC.Base.Maybe a_s6NTG -> GHC.Base.Maybe a_s6NTG
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_s6Pc7] \r [x_s6Pcb m_s6Pcc]
                  let {
                    sat_s6Pcf [Occ=Once] :: a_s6NTG
                    [LclId] =
                        [w2_s6Pc7 x_s6Pcb m_s6Pcc] \u []
                            case m_s6Pcc of {
                              GHC.Base.Nothing -> x_s6Pcb;
                              GHC.Base.Just y_s6Pce [Occ=Once] -> w2_s6Pc7 x_s6Pcb y_s6Pce;
                            };
                  } in  GHC.Base.Just [sat_s6Pcf]; } in
        let {
          sat_s6Pcg [Occ=Once] :: GHC.Base.Maybe a_s6NTG
          [LclId] =
              [w1_s6Pc6 ww1_s6Pc9 f1_s6Pca] \u []
                  Data.Foldable.foldr w1_s6Pc6 f1_s6Pca GHC.Base.Nothing ww1_s6Pc9;
        } in 
          case Data.Foldable.foldr w_s6Pc5 f1_s6Pca sat_s6Pcg ww_s6Pc8 of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6Pci [Occ=Once] -> v_s6Pci;
          };

Data.Foldable.$fFoldable:*:_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Pcj w1_s6Pck w2_s6Pcl w3_s6Pcm]
        case w3_s6Pcm of {
          GHC.Generics.:*: ww1_s6Pco [Occ=Once] ww2_s6Pcp [Occ=Once] ->
              Data.Foldable.$w$cfoldr1
                  w_s6Pcj w1_s6Pck w2_s6Pcl ww1_s6Pco ww2_s6Pcp;
        };

Data.Foldable.$w$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pcq w1_s6Pcr w2_s6Pcs w3_s6Pct ww_s6Pcu ww1_s6Pcv]
        let {
          f1_s6Pcw :: a_s6NTU -> (b_s6NTT -> b_s6NTT) -> b_s6NTT -> b_s6NTT
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_s6Pcs] \r [x_s6Pcx k_s6Pcy z_s6Pcz]
                  case w2_s6Pcs z_s6Pcz x_s6Pcx of vx_s6PcA {
                    __DEFAULT -> k_s6Pcy vx_s6PcA;
                  }; } in
        let {
          sat_s6PcB [Occ=Once] :: b_s6NTT -> b_s6NTT
          [LclId] =
              [w1_s6Pcr ww1_s6Pcv f1_s6Pcw] \u []
                  Data.Foldable.foldr w1_s6Pcr f1_s6Pcw GHC.Base.id ww1_s6Pcv;
        } in 
          Data.Foldable.foldr w_s6Pcq f1_s6Pcw sat_s6PcB ww_s6Pcu w3_s6Pct;

Data.Foldable.$fFoldable:*:_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PcC w1_s6PcD w2_s6PcE w3_s6PcF w4_s6PcG]
        case w4_s6PcG of {
          GHC.Generics.:*: ww1_s6PcI [Occ=Once] ww2_s6PcJ [Occ=Once] ->
              Data.Foldable.$w$cfoldl'
                  w_s6PcC w1_s6PcD w2_s6PcE w3_s6PcF ww1_s6PcI ww2_s6PcJ;
        };

Data.Foldable.$fFoldableM2
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s6PcK k_s6PcL z_s6PcM]
        case z_s6PcM of {
          GHC.Types.I# x1_s6PcO [Occ=Once] ->
              case +# [x1_s6PcO 1#] of sat_s6PcP {
                __DEFAULT ->
                    let {
                      sat_s6PcQ [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_s6PcP];
                    } in  k_s6PcL sat_s6PcQ;
              };
        };

Data.Foldable.$fFoldable:*:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PcR $dFoldable1_s6PcS eta_s6PcT]
        case eta_s6PcT of {
          GHC.Generics.:*: ww1_s6PcV [Occ=Once] ww2_s6PcW [Occ=Once] ->
              let {
                sat_s6PcX [Occ=Once] :: GHC.Types.Int -> GHC.Types.Int
                [LclId] =
                    [$dFoldable1_s6PcS ww2_s6PcW] \u []
                        Data.Foldable.foldr
                            $dFoldable1_s6PcS Data.Foldable.$fFoldableM2 GHC.Base.id ww2_s6PcW;
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6PcR
                    Data.Foldable.$fFoldableM2
                    sat_s6PcX
                    ww1_s6PcV
                    Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$w$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6PcY w1_s6PcZ w2_s6Pd0 w3_s6Pd1 ww_s6Pd2 ww1_s6Pd3]
        let {
          f1_s6Pd4 :: a_s6NU9 -> b_s6NU8 -> b_s6NU8
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w2_s6Pd0] \r [x_s6Pd5 y_s6Pd6] w2_s6Pd0 y_s6Pd6 x_s6Pd5; } in
        let {
          sat_s6Pd7 [Occ=Once] :: b_s6NU8
          [LclId] =
              [w_s6PcY w3_s6Pd1 ww_s6Pd2 f1_s6Pd4] \u []
                  Data.Foldable.foldMap
                      w_s6PcY Data.Foldable.$fFoldable:*:7 f1_s6Pd4 ww_s6Pd2 w3_s6Pd1;
        } in 
          Data.Foldable.foldMap
              w1_s6PcZ Data.Foldable.$fFoldable:*:7 f1_s6Pd4 ww1_s6Pd3 sat_s6Pd7;

Data.Foldable.$fFoldable:*:_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Pd8 w1_s6Pd9 w2_s6Pda w3_s6Pdb w4_s6Pdc]
        case w4_s6Pdc of {
          GHC.Generics.:*: ww1_s6Pde [Occ=Once] ww2_s6Pdf [Occ=Once] ->
              Data.Foldable.$w$cfoldl
                  w_s6Pd8 w1_s6Pd9 w2_s6Pda w3_s6Pdb ww1_s6Pde ww2_s6Pdf;
        };

Data.Foldable.$w$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pdg w1_s6Pdh w2_s6Pdi ww_s6Pdj ww1_s6Pdk]
        let {
          f1_s6Pdl
            :: a_s6NUn -> GHC.Base.Maybe a_s6NUn -> GHC.Base.Maybe a_s6NUn
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_s6Pdi] \r [x_s6Pdm y_s6Pdn]
                  let {
                    sat_s6Pdq [Occ=Once] :: a_s6NUn
                    [LclId] =
                        [w2_s6Pdi x_s6Pdm y_s6Pdn] \u []
                            case y_s6Pdn of {
                              GHC.Base.Nothing -> x_s6Pdm;
                              GHC.Base.Just x1_s6Pdp [Occ=Once] -> w2_s6Pdi x1_s6Pdp x_s6Pdm;
                            };
                  } in  GHC.Base.Just [sat_s6Pdq]; } in
        let {
          sat_s6Pdr [Occ=Once] :: GHC.Base.Maybe a_s6NUn
          [LclId] =
              [w_s6Pdg ww_s6Pdj f1_s6Pdl] \u []
                  Data.Foldable.foldMap
                      w_s6Pdg
                      Data.Foldable.$fFoldable:*:7
                      f1_s6Pdl
                      ww_s6Pdj
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w1_s6Pdh Data.Foldable.$fFoldable:*:7 f1_s6Pdl ww1_s6Pdk sat_s6Pdr
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6Pdt [Occ=Once] -> v_s6Pdt;
          };

Data.Foldable.$fFoldable:*:_$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Pdu w1_s6Pdv w2_s6Pdw w3_s6Pdx]
        case w3_s6Pdx of {
          GHC.Generics.:*: ww1_s6Pdz [Occ=Once] ww2_s6PdA [Occ=Once] ->
              Data.Foldable.$w$cfoldl1
                  w_s6Pdu w1_s6Pdv w2_s6Pdw ww1_s6Pdz ww2_s6PdA;
        };

Data.Foldable.$w$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6PdB w1_s6PdC w2_s6PdD w3_s6PdE ww_s6PdF ww1_s6PdG]
        let {
          f1_s6PdH :: a_s6NUA -> (b_s6NUB -> b_s6NUB) -> b_s6NUB -> b_s6NUB
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_s6PdD] \r [x_s6PdI y_s6PdJ z_s6PdK]
                  case w2_s6PdD x_s6PdI z_s6PdK of vx_s6PdL {
                    __DEFAULT -> y_s6PdJ vx_s6PdL;
                  }; } in
        let {
          sat_s6PdM [Occ=Once] :: b_s6NUB -> b_s6NUB
          [LclId] =
              [w_s6PdB ww_s6PdF f1_s6PdH] \u []
                  Data.Foldable.foldMap
                      w_s6PdB Data.Foldable.$fFoldable:*:7 f1_s6PdH ww_s6PdF GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w1_s6PdC
              Data.Foldable.$fFoldable:*:7
              f1_s6PdH
              ww1_s6PdG
              sat_s6PdM
              w3_s6PdE;

Data.Foldable.$fFoldable:*:_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PdN w1_s6PdO w2_s6PdP w3_s6PdQ w4_s6PdR]
        case w4_s6PdR of {
          GHC.Generics.:*: ww1_s6PdT [Occ=Once] ww2_s6PdU [Occ=Once] ->
              Data.Foldable.$w$cfoldr'
                  w_s6PdN w1_s6PdO w2_s6PdP w3_s6PdQ ww1_s6PdT ww2_s6PdU;
        };

Data.Foldable.$fFoldable:*:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:*:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PdV $dFoldable1_s6PdW $dMonoid_s6PdX w_s6PdY]
        case w_s6PdY of {
          GHC.Generics.:*: ww1_s6Pe0 [Occ=Once] ww2_s6Pe1 [Occ=Once] ->
              Data.Foldable.$w$cfoldMap
                  $dFoldable_s6PdV
                  $dFoldable1_s6PdW
                  $dMonoid_s6PdX
                  GHC.Base.id
                  ww1_s6Pe0
                  ww2_s6Pe1;
        };

Data.Foldable.$fFoldable:*:_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pe2 $dFoldable1_s6Pe3 $dNum_s6Pe4]
        let {
          $dMonoid_s6Pe5
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LaR)
          [LclId] =
              [$dNum_s6Pe4] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6Pe4; } in
        let {
          sat_s6Pec [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6LaR
               -> Data.Semigroup.Internal.Product a_a6LaR
          [LclId] =
              [$dFoldable_s6Pe2
               $dFoldable1_s6Pe3
               $dNum_s6Pe4
               $dMonoid_s6Pe5] \r [ds_s6Pe6]
                  case ds_s6Pe6 of {
                    GHC.Generics.:*: a1_s6Pe8 [Occ=Once] a2_s6Pe9 [Occ=Once] ->
                        let {
                          sat_s6Peb [Occ=Once] :: a_a6LaR
                          [LclId] =
                              [$dFoldable1_s6Pe3 $dMonoid_s6Pe5 a2_s6Pe9] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_s6Pe3
                                      $dMonoid_s6Pe5
                                      Data.Foldable.$fFoldable:*:1
                                      a2_s6Pe9; } in
                        let {
                          sat_s6Pea [Occ=Once] :: a_a6LaR
                          [LclId] =
                              [$dFoldable_s6Pe2 $dMonoid_s6Pe5 a1_s6Pe8] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Pe2
                                      $dMonoid_s6Pe5
                                      Data.Foldable.$fFoldable:*:1
                                      a1_s6Pe8;
                        } in  GHC.Num.* $dNum_s6Pe4 sat_s6Pea sat_s6Peb;
                  };
        } in  sat_s6Pec;

Data.Foldable.$fFoldable:*:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ped $dFoldable1_s6Pee eta_s6Pef]
        case eta_s6Pef of {
          GHC.Generics.:*: a1_s6Peh [Occ=Once] a2_s6Pei [Occ=Once] ->
              let {
                sat_s6Pej [Occ=Once] :: [a_a6L9L]
                [LclId] =
                    [$dFoldable1_s6Pee a2_s6Pei] \u []
                        Data.Foldable.foldr
                            $dFoldable1_s6Pee GHC.Types.: GHC.Types.[] a2_s6Pei;
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6Ped GHC.Types.: sat_s6Pej a1_s6Peh;
        };

Data.Foldable.$fFoldable:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6Pek $dFoldable1_s6Pel]
        let {
          sat_s6PeB [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cproduct
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6PeA [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$csum
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Pez [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cminimum
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Pey [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cmaximum
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Pex [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$celem
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B2 eta_B1; } in
        let {
          sat_s6Pew [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$clength
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Pev [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cnull
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Peu [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> [a]
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$ctoList
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Pet [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl1
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B2 eta_B1; } in
        let {
          sat_s6Pes [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr1
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B2 eta_B1; } in
        let {
          sat_s6Per [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl'
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Peq [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pep [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr'
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Peo [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pen [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> m
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldMap
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pem [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S m -> m
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfold
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6Pem
                                    sat_s6Pen
                                    sat_s6Peo
                                    sat_s6Pep
                                    sat_s6Peq
                                    sat_s6Per
                                    sat_s6Pes
                                    sat_s6Pet
                                    sat_s6Peu
                                    sat_s6Pev
                                    sat_s6Pew
                                    sat_s6Pex
                                    sat_s6Pey
                                    sat_s6Pez
                                    sat_s6PeA
                                    sat_s6PeB];

Data.Foldable.$fFoldable:+:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:+:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PeC $dFoldable1_s6PeD $dEq_s6PeE eta_s6PeF]
        let {
          f1_s6PeG [Occ=OnceL*] :: a_a6Ldk -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6PeE eta_s6PeF] \u []
                  GHC.Classes.== $dEq_s6PeE eta_s6PeF; } in
        let {
          sat_s6PeL [Occ=Once]
            :: (GHC.Generics.:+:) f_X6LpN g_X6LpP a_a6Ldk
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6PeC $dFoldable1_s6PeD f1_s6PeG] \r [ds_s6PeH]
                  case ds_s6PeH of {
                    GHC.Generics.L1 a1_s6PeJ [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6PeC
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_s6PeG
                            a1_s6PeJ;
                    GHC.Generics.R1 a1_s6PeK [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6PeD
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_s6PeG
                            a1_s6PeK;
                  };
        } in  sat_s6PeL;

Data.Foldable.$fFoldable:+:2
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     (GHC.Generics.:+:) f g a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PeM $dFoldable1_s6PeN $dNum_s6PeO]
        let {
          $dMonoid_s6PeP [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LdO)
          [LclId] =
              [$dNum_s6PeO] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6PeO; } in
        let {
          sat_s6PeU [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpF g_X6LpH a_a6LdO
               -> Data.Semigroup.Internal.Sum a_a6LdO
          [LclId] =
              [$dFoldable_s6PeM $dFoldable1_s6PeN $dMonoid_s6PeP] \r [ds_s6PeQ]
                  case ds_s6PeQ of {
                    GHC.Generics.L1 a1_s6PeS [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6PeM
                            $dMonoid_s6PeP
                            Data.Foldable.$fFoldable:*:1
                            a1_s6PeS;
                    GHC.Generics.R1 a1_s6PeT [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6PeN
                            $dMonoid_s6PeP
                            Data.Foldable.$fFoldable:*:1
                            a1_s6PeT;
                  };
        } in  sat_s6PeU;

Data.Foldable.$fFoldable:+:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PeV $dFoldable1_s6PeW $dOrd_s6PeX]
        let {
          g1_s6PeY [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6LdE)
          [LclId] =
              [$dOrd_s6PeX] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6PeX; } in
        let {
          sat_s6Pf7 [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpE g_X6LpG a_a6LdE -> a_a6LdE
          [LclId] =
              [$dFoldable_s6PeV $dFoldable1_s6PeW g1_s6PeY] \r [x_s6PeZ]
                  case x_s6PeZ of {
                    GHC.Generics.L1 a1_s6Pf1 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6PeV g1_s6PeY GHC.Base.Just a1_s6Pf1
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                          GHC.Base.Just v_s6Pf3 [Occ=Once] -> v_s6Pf3;
                        };
                    GHC.Generics.R1 a1_s6Pf4 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6PeW g1_s6PeY GHC.Base.Just a1_s6Pf4
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                          GHC.Base.Just v_s6Pf6 [Occ=Once] -> v_s6Pf6;
                        };
                  };
        } in  sat_s6Pf7;

Data.Foldable.$fFoldable:+:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pf8 $dFoldable1_s6Pf9 $dOrd_s6Pfa]
        let {
          g1_s6Pfb [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Ldu)
          [LclId] =
              [$dOrd_s6Pfa] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6Pfa; } in
        let {
          sat_s6Pfk [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpD g_X6LpF a_a6Ldu -> a_a6Ldu
          [LclId] =
              [$dFoldable_s6Pf8 $dFoldable1_s6Pf9 g1_s6Pfb] \r [x_s6Pfc]
                  case x_s6Pfc of {
                    GHC.Generics.L1 a1_s6Pfe [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6Pf8 g1_s6Pfb GHC.Base.Just a1_s6Pfe
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                          GHC.Base.Just v_s6Pfg [Occ=Once] -> v_s6Pfg;
                        };
                    GHC.Generics.R1 a1_s6Pfh [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6Pf9 g1_s6Pfb GHC.Base.Just a1_s6Pfh
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                          GHC.Base.Just v_s6Pfj [Occ=Once] -> v_s6Pfj;
                        };
                  };
        } in  sat_s6Pfk;

Data.Foldable.$fFoldable:+:_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pfl $dFoldable1_s6Pfm f1_s6Pfn xs_s6Pfo]
        case xs_s6Pfo of {
          GHC.Generics.L1 a1_s6Pfq [Occ=Once] ->
              let {
                sat_s6Pfw [Occ=Once]
                  :: a_a6LcC -> GHC.Base.Maybe a_a6LcC -> GHC.Base.Maybe a_a6LcC
                [LclId] =
                    [f1_s6Pfn] \r [x_s6Pfr m_s6Pfs]
                        let {
                          sat_s6Pfv [Occ=Once] :: a_a6LcC
                          [LclId] =
                              [f1_s6Pfn x_s6Pfr m_s6Pfs] \u []
                                  case m_s6Pfs of {
                                    GHC.Base.Nothing -> x_s6Pfr;
                                    GHC.Base.Just y_s6Pfu [Occ=Once] -> f1_s6Pfn x_s6Pfr y_s6Pfu;
                                  };
                        } in  GHC.Base.Just [sat_s6Pfv];
              } in 
                case
                    Data.Foldable.foldr
                        $dFoldable_s6Pfl sat_s6Pfw GHC.Base.Nothing a1_s6Pfq
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
                  GHC.Base.Just v_s6Pfy [Occ=Once] -> v_s6Pfy;
                };
          GHC.Generics.R1 a1_s6Pfz [Occ=Once] ->
              let {
                sat_s6PfF [Occ=Once]
                  :: a_a6LcC -> GHC.Base.Maybe a_a6LcC -> GHC.Base.Maybe a_a6LcC
                [LclId] =
                    [f1_s6Pfn] \r [x_s6PfA m_s6PfB]
                        let {
                          sat_s6PfE [Occ=Once] :: a_a6LcC
                          [LclId] =
                              [f1_s6Pfn x_s6PfA m_s6PfB] \u []
                                  case m_s6PfB of {
                                    GHC.Base.Nothing -> x_s6PfA;
                                    GHC.Base.Just y_s6PfD [Occ=Once] -> f1_s6Pfn x_s6PfA y_s6PfD;
                                  };
                        } in  GHC.Base.Just [sat_s6PfE];
              } in 
                case
                    Data.Foldable.foldr
                        $dFoldable1_s6Pfm sat_s6PfF GHC.Base.Nothing a1_s6Pfz
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
                  GHC.Base.Just v_s6PfH [Occ=Once] -> v_s6PfH;
                };
        };

Data.Foldable.$fFoldable:+:_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PfI
           $dFoldable1_s6PfJ
           f1_s6PfK
           z0_s6PfL
           xs_s6PfM]
        case xs_s6PfM of {
          GHC.Generics.L1 a1_s6PfO [Occ=Once] ->
              let {
                sat_s6PfT [Occ=Once]
                  :: a_a6Lct -> (b_a6Lcs -> b_a6Lcs) -> b_a6Lcs -> b_a6Lcs
                [LclId] =
                    [f1_s6PfK] \r [x_s6PfP k_s6PfQ z_s6PfR]
                        case f1_s6PfK z_s6PfR x_s6PfP of vx_s6PfS {
                          __DEFAULT -> k_s6PfQ vx_s6PfS;
                        };
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6PfI sat_s6PfT GHC.Base.id a1_s6PfO z0_s6PfL;
          GHC.Generics.R1 a1_s6PfU [Occ=Once] ->
              let {
                sat_s6PfZ [Occ=Once]
                  :: a_a6Lct -> (b_a6Lcs -> b_a6Lcs) -> b_a6Lcs -> b_a6Lcs
                [LclId] =
                    [f1_s6PfK] \r [x_s6PfV k_s6PfW z_s6PfX]
                        case f1_s6PfK z_s6PfX x_s6PfV of vx_s6PfY {
                          __DEFAULT -> k_s6PfW vx_s6PfY;
                        };
              } in 
                Data.Foldable.foldr
                    $dFoldable1_s6PfJ sat_s6PfZ GHC.Base.id a1_s6PfU z0_s6PfL;
        };

Data.Foldable.$fFoldable:+:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pg0 $dFoldable1_s6Pg1 eta_s6Pg2]
        Data.Foldable.$fFoldable:+:_$cfoldl'
            $dFoldable_s6Pg0
            $dFoldable1_s6Pg1
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4
            eta_s6Pg2;

Data.Foldable.$fFoldable:+:_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pg3 $dFoldable1_s6Pg4 f1_s6Pg5 z_s6Pg6 t_s6Pg7]
        let {
          f2_s6Pg8 [Occ=Once*] :: a_a6Lcj -> b_a6Lci -> b_a6Lci
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [f1_s6Pg5] \r [x_s6Pg9 y_s6Pga] f1_s6Pg5 y_s6Pga x_s6Pg9;
        } in 
          case t_s6Pg7 of {
            GHC.Generics.L1 a1_s6Pgc [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable_s6Pg3
                    Data.Foldable.$fFoldable:*:7
                    f2_s6Pg8
                    a1_s6Pgc
                    z_s6Pg6;
            GHC.Generics.R1 a1_s6Pgd [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable1_s6Pg4
                    Data.Foldable.$fFoldable:*:7
                    f2_s6Pg8
                    a1_s6Pgd
                    z_s6Pg6;
          };

Data.Foldable.$fFoldable:+:_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pge $dFoldable1_s6Pgf f1_s6Pgg xs_s6Pgh]
        case xs_s6Pgh of {
          GHC.Generics.L1 a1_s6Pgj [Occ=Once] ->
              let {
                sat_s6Pgp [Occ=Once]
                  :: a_a6LcK
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LcK))
                [LclId] =
                    [f1_s6Pgg] \r [x_s6Pgk y_s6Pgl]
                        let {
                          sat_s6Pgo [Occ=Once] :: a_a6LcK
                          [LclId] =
                              [f1_s6Pgg x_s6Pgk y_s6Pgl] \u []
                                  case y_s6Pgl of {
                                    GHC.Base.Nothing -> x_s6Pgk;
                                    GHC.Base.Just x1_s6Pgn [Occ=Once] -> f1_s6Pgg x1_s6Pgn x_s6Pgk;
                                  };
                        } in  GHC.Base.Just [sat_s6Pgo];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable_s6Pge
                        Data.Foldable.$fFoldable:*:7
                        sat_s6Pgp
                        a1_s6Pgj
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
                  GHC.Base.Just v_s6Pgr [Occ=Once] -> v_s6Pgr;
                };
          GHC.Generics.R1 a1_s6Pgs [Occ=Once] ->
              let {
                sat_s6Pgy [Occ=Once]
                  :: a_a6LcK
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LcK))
                [LclId] =
                    [f1_s6Pgg] \r [x_s6Pgt y_s6Pgu]
                        let {
                          sat_s6Pgx [Occ=Once] :: a_a6LcK
                          [LclId] =
                              [f1_s6Pgg x_s6Pgt y_s6Pgu] \u []
                                  case y_s6Pgu of {
                                    GHC.Base.Nothing -> x_s6Pgt;
                                    GHC.Base.Just x1_s6Pgw [Occ=Once] -> f1_s6Pgg x1_s6Pgw x_s6Pgt;
                                  };
                        } in  GHC.Base.Just [sat_s6Pgx];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable1_s6Pgf
                        Data.Foldable.$fFoldable:*:7
                        sat_s6Pgy
                        a1_s6Pgs
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
                  GHC.Base.Just v_s6PgA [Occ=Once] -> v_s6PgA;
                };
        };

Data.Foldable.$fFoldable:+:_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PgB
           $dFoldable1_s6PgC
           f1_s6PgD
           z0_s6PgE
           xs_s6PgF]
        case xs_s6PgF of {
          GHC.Generics.L1 a1_s6PgH [Occ=Once] ->
              let {
                sat_s6PgM [Occ=Once]
                  :: a_a6Lc8
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_a6Lc9 -> b_a6Lc9))
                [LclId] =
                    [f1_s6PgD] \r [x_s6PgI y_s6PgJ z_s6PgK]
                        case f1_s6PgD x_s6PgI z_s6PgK of vx_s6PgL {
                          __DEFAULT -> y_s6PgJ vx_s6PgL;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable_s6PgB
                    Data.Foldable.$fFoldable:*:7
                    sat_s6PgM
                    a1_s6PgH
                    GHC.Base.id
                    z0_s6PgE;
          GHC.Generics.R1 a1_s6PgN [Occ=Once] ->
              let {
                sat_s6PgS [Occ=Once]
                  :: a_a6Lc8
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_a6Lc9 -> b_a6Lc9))
                [LclId] =
                    [f1_s6PgD] \r [x_s6PgO y_s6PgP z_s6PgQ]
                        case f1_s6PgD x_s6PgO z_s6PgQ of vx_s6PgR {
                          __DEFAULT -> y_s6PgP vx_s6PgR;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable1_s6PgC
                    Data.Foldable.$fFoldable:*:7
                    sat_s6PgS
                    a1_s6PgN
                    GHC.Base.id
                    z0_s6PgE;
        };

Data.Foldable.$fFoldable:+:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:+:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PgT $dFoldable1_s6PgU $dMonoid_s6PgV ds_s6PgW]
        case ds_s6PgW of {
          GHC.Generics.L1 a1_s6PgY [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_s6PgT $dMonoid_s6PgV GHC.Base.id a1_s6PgY;
          GHC.Generics.R1 a1_s6PgZ [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_s6PgU $dMonoid_s6PgV GHC.Base.id a1_s6PgZ;
        };

Data.Foldable.$fFoldable:+:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     (GHC.Generics.:+:) f g a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ph0 $dFoldable1_s6Ph1 $dNum_s6Ph2]
        let {
          $dMonoid_s6Ph3 [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LdY)
          [LclId] =
              [$dNum_s6Ph2] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6Ph2; } in
        let {
          sat_s6Ph8 [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a_a6LdY
               -> Data.Semigroup.Internal.Product a_a6LdY
          [LclId] =
              [$dFoldable_s6Ph0 $dFoldable1_s6Ph1 $dMonoid_s6Ph3] \r [ds_s6Ph4]
                  case ds_s6Ph4 of {
                    GHC.Generics.L1 a1_s6Ph6 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6Ph0
                            $dMonoid_s6Ph3
                            Data.Foldable.$fFoldable:*:1
                            a1_s6Ph6;
                    GHC.Generics.R1 a1_s6Ph7 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6Ph1
                            $dMonoid_s6Ph3
                            Data.Foldable.$fFoldable:*:1
                            a1_s6Ph7;
                  };
        } in  sat_s6Ph8;

Data.Foldable.$fFoldable:+:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ph9 $dFoldable1_s6Pha eta_s6Phb]
        case eta_s6Phb of {
          GHC.Generics.L1 a1_s6Phd [Occ=Once] ->
              Data.Foldable.foldr
                  $dFoldable_s6Ph9 GHC.Types.: GHC.Types.[] a1_s6Phd;
          GHC.Generics.R1 a1_s6Phe [Occ=Once] ->
              Data.Foldable.foldr
                  $dFoldable1_s6Pha GHC.Types.: GHC.Types.[] a1_s6Phe;
        };

Data.Foldable.$fFoldable:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6Phf $dFoldable1_s6Phg]
        let {
          sat_s6Phw [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:1
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Phv [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:2
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Phu [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cminimum
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Pht [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cmaximum
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Phs [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$celem
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B2 eta_B1; } in
        let {
          sat_s6Phr [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$clength
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Phq [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cnull
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Php [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> [a]
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$ctoList
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Pho [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl1
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B2 eta_B1; } in
        let {
          sat_s6Phn [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr1
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B2 eta_B1; } in
        let {
          sat_s6Phm [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl'
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Phl [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Phk [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr'
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Phj [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Phi [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> m
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldMap
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Phh [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 m -> m
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfold
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6Phh
                                    sat_s6Phi
                                    sat_s6Phj
                                    sat_s6Phk
                                    sat_s6Phl
                                    sat_s6Phm
                                    sat_s6Phn
                                    sat_s6Pho
                                    sat_s6Php
                                    sat_s6Phq
                                    sat_s6Phr
                                    sat_s6Phs
                                    sat_s6Pht
                                    sat_s6Phu
                                    sat_s6Phv
                                    sat_s6Phw];

Data.Foldable.$fFoldableM1_$celem
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.M1 i c f a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Phx $dEq_s6Phy eta_s6Phz]
        let {
          f1_s6PhA [Occ=OnceL] :: a_a6Lg5 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Phy eta_s6Phz] \u []
                  GHC.Classes.== $dEq_s6Phy eta_s6Phz; } in
        let {
          sat_s6PhC [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6Phx f1_s6PhA] \r [ds_s6PhB]
                  Data.Foldable.foldMap
                      $dFoldable_s6Phx
                      Data.Semigroup.Internal.$fMonoidAny
                      f1_s6PhA
                      ds_s6PhB;
        } in  sat_s6PhC;

Data.Foldable.$fFoldableM1_$csum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PhD $dNum_s6PhE]
        let {
          $dMonoid_s6PhF [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6Lgz)
          [LclId] =
              [$dNum_s6PhE] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6PhE; } in
        let {
          sat_s6PhH [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz
               -> Data.Semigroup.Internal.Sum a_a6Lgz
          [LclId] =
              [$dFoldable_s6PhD $dMonoid_s6PhF] \r [ds_s6PhG]
                  Data.Foldable.foldMap
                      $dFoldable_s6PhD
                      $dMonoid_s6PhF
                      Data.Foldable.$fFoldable:*:1
                      ds_s6PhG;
        } in  sat_s6PhH;

Data.Foldable.$fFoldableM1_$cminimum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PhI $dOrd_s6PhJ]
        let {
          $dMonoid_s6PhK [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6Lgp)
          [LclId] =
              [$dOrd_s6PhJ] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6PhJ; } in
        let {
          sat_s6PhO [Occ=OnceT[0]]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgp -> a_a6Lgp
          [LclId] =
              [$dFoldable_s6PhI $dMonoid_s6PhK] \r [x_s6PhL]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6PhI $dMonoid_s6PhK GHC.Base.Just x_s6PhL
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6PhN [Occ=Once] -> v_s6PhN;
                  };
        } in  sat_s6PhO;

Data.Foldable.$fFoldableM1_$cmaximum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PhP $dOrd_s6PhQ]
        let {
          $dMonoid_s6PhR [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lgf)
          [LclId] =
              [$dOrd_s6PhQ] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6PhQ; } in
        let {
          sat_s6PhV [Occ=OnceT[0]]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgf -> a_a6Lgf
          [LclId] =
              [$dFoldable_s6PhP $dMonoid_s6PhR] \r [x_s6PhS]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6PhP $dMonoid_s6PhR GHC.Base.Just x_s6PhS
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6PhU [Occ=Once] -> v_s6PhU;
                  };
        } in  sat_s6PhV;

Data.Foldable.$fFoldableM1_$cfoldr1
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PhW f1_s6PhX xs_s6PhY]
        let {
          sat_s6Pi4 [Occ=Once]
            :: a_a6Lfq -> GHC.Base.Maybe a_a6Lfq -> GHC.Base.Maybe a_a6Lfq
          [LclId] =
              [f1_s6PhX] \r [x_s6PhZ m_s6Pi0]
                  let {
                    sat_s6Pi3 [Occ=Once] :: a_a6Lfq
                    [LclId] =
                        [f1_s6PhX x_s6PhZ m_s6Pi0] \u []
                            case m_s6Pi0 of {
                              GHC.Base.Nothing -> x_s6PhZ;
                              GHC.Base.Just y_s6Pi2 [Occ=Once] -> f1_s6PhX x_s6PhZ y_s6Pi2;
                            };
                  } in  GHC.Base.Just [sat_s6Pi3];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6PhW sat_s6Pi4 GHC.Base.Nothing xs_s6PhY
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6Pi6 [Occ=Once] -> v_s6Pi6;
          };

Data.Foldable.$fFoldableM1_$cfoldl'
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pi7 f1_s6Pi8 z0_s6Pi9 xs_s6Pia]
        let {
          sat_s6Pif [Occ=Once]
            :: a_a6Lfh -> (b_a6Lfg -> b_a6Lfg) -> b_a6Lfg -> b_a6Lfg
          [LclId] =
              [f1_s6Pi8] \r [x_s6Pib k_s6Pic z_s6Pid]
                  case f1_s6Pi8 z_s6Pid x_s6Pib of vx_s6Pie {
                    __DEFAULT -> k_s6Pic vx_s6Pie;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6Pi7 sat_s6Pif GHC.Base.id xs_s6Pia z0_s6Pi9;

Data.Foldable.$fFoldableM1_$clength
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.M1 i c f a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pig eta_s6Pih]
        Data.Foldable.foldr
            $dFoldable_s6Pig
            Data.Foldable.$fFoldableM2
            GHC.Base.id
            eta_s6Pih
            Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableM1_$cfoldl
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pii f1_s6Pij z_s6Pik t_s6Pil]
        let {
          sat_s6Pio [Occ=Once]
            :: a_a6Lf7
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6Lf6)
          [LclId] =
              [f1_s6Pij] \r [x_s6Pim y_s6Pin] f1_s6Pij y_s6Pin x_s6Pim;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pii
              Data.Foldable.$fFoldable:*:7
              sat_s6Pio
              t_s6Pil
              z_s6Pik;

Data.Foldable.$fFoldableM3
  :: forall a.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual
          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a)))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$fFoldableM1_$cfoldl1
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pip f1_s6Piq xs_s6Pir]
        let {
          sat_s6Pix [Occ=Once]
            :: a_a6Lfy
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6Lfy))
          [LclId] =
              [f1_s6Piq] \r [x_s6Pis y_s6Pit]
                  let {
                    sat_s6Piw [Occ=Once] :: a_a6Lfy
                    [LclId] =
                        [f1_s6Piq x_s6Pis y_s6Pit] \u []
                            case y_s6Pit of {
                              GHC.Base.Nothing -> x_s6Pis;
                              GHC.Base.Just x1_s6Piv [Occ=Once] -> f1_s6Piq x1_s6Piv x_s6Pis;
                            };
                  } in  GHC.Base.Just [sat_s6Piw];
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6Pip
                  Data.Foldable.$fFoldableM3
                  sat_s6Pix
                  xs_s6Pir
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6Piz [Occ=Once] -> v_s6Piz;
          };

Data.Foldable.$fFoldableM4
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual
          (Data.Semigroup.Internal.Endo (b -> b)))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$fFoldableM1_$cfoldr'
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a b. (a -> b -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PiA f1_s6PiB z0_s6PiC xs_s6PiD]
        let {
          sat_s6PiI [Occ=Once]
            :: a_a6LeW
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6LeX -> b_a6LeX))
          [LclId] =
              [f1_s6PiB] \r [x_s6PiE y_s6PiF z_s6PiG]
                  case f1_s6PiB x_s6PiE z_s6PiG of vx_s6PiH {
                    __DEFAULT -> y_s6PiF vx_s6PiH;
                  };
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6PiA
              Data.Foldable.$fFoldableM4
              sat_s6PiI
              xs_s6PiD
              GHC.Base.id
              z0_s6PiC;

Data.Foldable.$fFoldableM1_$cfold
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall m. GHC.Base.Monoid m => GHC.Generics.M1 i c f m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PiJ $dMonoid_s6PiK ds_s6PiL]
        Data.Foldable.foldMap
            $dFoldable_s6PiJ $dMonoid_s6PiK GHC.Base.id ds_s6PiL;

Data.Foldable.$fFoldableM1_$cproduct
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PiM $dNum_s6PiN]
        let {
          $dMonoid_s6PiO [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LgJ)
          [LclId] =
              [$dNum_s6PiN] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6PiN; } in
        let {
          sat_s6PiQ [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ
               -> Data.Semigroup.Internal.Product a_a6LgJ
          [LclId] =
              [$dFoldable_s6PiM $dMonoid_s6PiO] \r [ds_s6PiP]
                  Data.Foldable.foldMap
                      $dFoldable_s6PiM
                      $dMonoid_s6PiO
                      Data.Foldable.$fFoldable:*:1
                      ds_s6PiP;
        } in  sat_s6PiQ;

Data.Foldable.$fFoldableM1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.M1 i c f a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PiR eta_s6PiS]
        Data.Foldable.foldr
            $dFoldable_s6PiR GHC.Types.: GHC.Types.[] eta_s6PiS;

Data.Foldable.$fFoldableM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     Data.Foldable.Foldable (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6PiT]
        let {
          sat_s6Pjg [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cproduct $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pjf [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$csum $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pje [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cminimum $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pjd [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cmaximum $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pjc [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$celem
                      $dFoldable_s6PiT eta_B2 eta_B1; } in
        let {
          sat_s6Pjb [Occ=Once]
            :: forall a.
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$clength $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pja [Occ=Once]
            :: forall a.
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6PiT] \r [ds_s6Pj9]
                  Data.Foldable.null $dFoldable_s6PiT ds_s6Pj9; } in
        let {
          sat_s6Pj8 [Occ=Once]
            :: forall a. GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> [a]
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$ctoList $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pj7 [Occ=Once]
            :: forall a.
               (a -> a -> a) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl1
                      $dFoldable_s6PiT eta_B2 eta_B1; } in
        let {
          sat_s6Pj6 [Occ=Once]
            :: forall a.
               (a -> a -> a) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldr1
                      $dFoldable_s6PiT eta_B2 eta_B1; } in
        let {
          sat_s6Pj5 [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl'
                      $dFoldable_s6PiT eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pj4 [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl
                      $dFoldable_s6PiT eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pj3 [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldr'
                      $dFoldable_s6PiT eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pj2 [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6PiT] \r [f1_s6PiZ z_s6Pj0 ds_s6Pj1]
                  Data.Foldable.foldr
                      $dFoldable_s6PiT f1_s6PiZ z_s6Pj0 ds_s6Pj1; } in
        let {
          sat_s6PiY [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> m
          [LclId] =
              [$dFoldable_s6PiT] \r [$dMonoid_s6PiV f1_s6PiW ds_s6PiX]
                  Data.Foldable.foldMap
                      $dFoldable_s6PiT $dMonoid_s6PiV f1_s6PiW ds_s6PiX; } in
        let {
          sat_s6PiU [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 m -> m
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfold $dFoldable_s6PiT eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6PiU
                                    sat_s6PiY
                                    sat_s6Pj2
                                    sat_s6Pj3
                                    sat_s6Pj4
                                    sat_s6Pj5
                                    sat_s6Pj6
                                    sat_s6Pj7
                                    sat_s6Pj8
                                    sat_s6Pja
                                    sat_s6Pjb
                                    sat_s6Pjc
                                    sat_s6Pjd
                                    sat_s6Pje
                                    sat_s6Pjf
                                    sat_s6Pjg];

Data.Foldable.$fFoldableK1_$celem
  :: forall i c a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.K1 i c a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Pjh eta_s6Pji eta1_s6Pjj] GHC.Types.False [];

Data.Foldable.$fFoldableK1_$csum
  :: forall i c a. GHC.Num.Num a => GHC.Generics.K1 i c a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pjk ds_s6Pjl]
        Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Pjk;

Data.Foldable.$fFoldableK1_$cminimum
  :: forall i c a. GHC.Classes.Ord a => GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Pjm eta_s6Pjn]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableK1_$cmaximum
  :: forall i c a. GHC.Classes.Ord a => GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Pjo eta_s6Pjp]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableK1_$cfoldl
  :: forall i c b a. (b -> a -> b) -> b -> GHC.Generics.K1 i c a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6Pjq z_s6Pjr t_s6Pjs] z_s6Pjr;

Data.Foldable.$fFoldableK6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK7;

Data.Foldable.$fFoldableK1_$cfoldl1
  :: forall i c a. (a -> a -> a) -> GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pjt xs_s6Pju]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableK1_$cfoldr'
  :: forall i c a b. (a -> b -> b) -> b -> GHC.Generics.K1 i c a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6Pjv z0_s6Pjw xs_s6Pjx] z0_s6Pjw;

Data.Foldable.$fFoldableK1_$clength
  :: forall i c a. GHC.Generics.K1 i c a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6Pjy] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableK8 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK9;

Data.Foldable.$fFoldableK1_$cfoldr1
  :: forall i c a. (a -> a -> a) -> GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pjz xs_s6PjA]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableK1_$cnull
  :: forall i c a. GHC.Generics.K1 i c a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t_s6PjB] GHC.Types.True [];

Data.Foldable.$fFoldableK1_$cfold
  :: forall i c m. GHC.Base.Monoid m => GHC.Generics.K1 i c m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6PjC ds_s6PjD] GHC.Base.mempty $dMonoid_s6PjC;

Data.Foldable.$fFoldableK1_$cproduct
  :: forall i c a. GHC.Num.Num a => GHC.Generics.K1 i c a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PjE ds_s6PjF]
        Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6PjE;

Data.Foldable.$fFoldableK1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall i c a. GHC.Generics.K1 i c a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6PjG] [] [];

Data.Foldable.$fFoldableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Data.Foldable.Foldable (GHC.Generics.K1 i c)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableK1_$cfold
                                             Data.Foldable.$fFoldableK1_$cfoldMap
                                             Data.Foldable.$fFoldableK1_$cfoldr'
                                             Data.Foldable.$fFoldableK1_$cfoldr'
                                             Data.Foldable.$fFoldableK1_$cfoldl
                                             Data.Foldable.$fFoldableK1_$cfoldl
                                             Data.Foldable.$fFoldableK1_$cfoldr1
                                             Data.Foldable.$fFoldableK1_$cfoldl1
                                             Data.Foldable.$fFoldableK1_$ctoList
                                             Data.Foldable.$fFoldableK1_$cnull
                                             Data.Foldable.$fFoldableK1_$clength
                                             Data.Foldable.$fFoldableK1_$celem
                                             Data.Foldable.$fFoldableK1_$cmaximum
                                             Data.Foldable.$fFoldableK1_$cminimum
                                             Data.Foldable.$fFoldableK1_$csum
                                             Data.Foldable.$fFoldableK1_$cproduct];

Data.Foldable.$fFoldableRec1_$celem
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.Rec1 f a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PjH $dEq_s6PjI eta_s6PjJ]
        let {
          f1_s6PjK [Occ=OnceL] :: a_a6Lli -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6PjI eta_s6PjJ] \u []
                  GHC.Classes.== $dEq_s6PjI eta_s6PjJ; } in
        let {
          sat_s6PjM [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6Lli -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6PjH f1_s6PjK] \r [ds_s6PjL]
                  Data.Foldable.foldMap
                      $dFoldable_s6PjH
                      Data.Semigroup.Internal.$fMonoidAny
                      f1_s6PjK
                      ds_s6PjL;
        } in  sat_s6PjM;

Data.Foldable.$fFoldableRec1_$csum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PjN $dNum_s6PjO]
        let {
          $dMonoid_s6PjP [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LlM)
          [LclId] =
              [$dNum_s6PjO] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6PjO; } in
        let {
          sat_s6PjR [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlM
               -> Data.Semigroup.Internal.Sum a_a6LlM
          [LclId] =
              [$dFoldable_s6PjN $dMonoid_s6PjP] \r [ds_s6PjQ]
                  Data.Foldable.foldMap
                      $dFoldable_s6PjN
                      $dMonoid_s6PjP
                      Data.Foldable.$fFoldable:*:1
                      ds_s6PjQ;
        } in  sat_s6PjR;

Data.Foldable.$fFoldableRec1_$cminimum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PjS $dOrd_s6PjT]
        let {
          $dMonoid_s6PjU [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6LlC)
          [LclId] =
              [$dOrd_s6PjT] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6PjT; } in
        let {
          sat_s6PjY [Occ=OnceT[0]]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlC -> a_a6LlC
          [LclId] =
              [$dFoldable_s6PjS $dMonoid_s6PjU] \r [x_s6PjV]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6PjS $dMonoid_s6PjU GHC.Base.Just x_s6PjV
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6PjX [Occ=Once] -> v_s6PjX;
                  };
        } in  sat_s6PjY;

Data.Foldable.$fFoldableRec1_$cmaximum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PjZ $dOrd_s6Pk0]
        let {
          $dMonoid_s6Pk1 [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lls)
          [LclId] =
              [$dOrd_s6Pk0] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6Pk0; } in
        let {
          sat_s6Pk5 [Occ=OnceT[0]]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6Lls -> a_a6Lls
          [LclId] =
              [$dFoldable_s6PjZ $dMonoid_s6Pk1] \r [x_s6Pk2]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6PjZ $dMonoid_s6Pk1 GHC.Base.Just x_s6Pk2
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6Pk4 [Occ=Once] -> v_s6Pk4;
                  };
        } in  sat_s6Pk5;

Data.Foldable.$fFoldable:.:3 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableRec1_$cfoldr1
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pk6 f1_s6Pk7 xs_s6Pk8]
        let {
          sat_s6Pke [Occ=Once]
            :: a_a6LkD -> GHC.Base.Maybe a_a6LkD -> GHC.Base.Maybe a_a6LkD
          [LclId] =
              [f1_s6Pk7] \r [x_s6Pk9 m_s6Pka]
                  let {
                    sat_s6Pkd [Occ=Once] :: a_a6LkD
                    [LclId] =
                        [f1_s6Pk7 x_s6Pk9 m_s6Pka] \u []
                            case m_s6Pka of {
                              GHC.Base.Nothing -> x_s6Pk9;
                              GHC.Base.Just y_s6Pkc [Occ=Once] -> f1_s6Pk7 x_s6Pk9 y_s6Pkc;
                            };
                  } in  GHC.Base.Just [sat_s6Pkd];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6Pk6 sat_s6Pke GHC.Base.Nothing xs_s6Pk8
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
            GHC.Base.Just v_s6Pkg [Occ=Once] -> v_s6Pkg;
          };

Data.Foldable.$fFoldableRec1_$cfoldl'
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pkh f1_s6Pki z0_s6Pkj xs_s6Pkk]
        let {
          sat_s6Pkp [Occ=Once]
            :: a_a6Lku -> (b_a6Lkt -> b_a6Lkt) -> b_a6Lkt -> b_a6Lkt
          [LclId] =
              [f1_s6Pki] \r [x_s6Pkl k_s6Pkm z_s6Pkn]
                  case f1_s6Pki z_s6Pkn x_s6Pkl of vx_s6Pko {
                    __DEFAULT -> k_s6Pkm vx_s6Pko;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6Pkh sat_s6Pkp GHC.Base.id xs_s6Pkk z0_s6Pkj;

Data.Foldable.$fFoldableRec1_$clength
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.Rec1 f a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pkq eta_s6Pkr]
        Data.Foldable.foldr
            $dFoldable_s6Pkq
            Data.Foldable.$fFoldableM2
            GHC.Base.id
            eta_s6Pkr
            Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableRec1_$cfoldl
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pks f1_s6Pkt z_s6Pku t_s6Pkv]
        let {
          sat_s6Pky [Occ=Once]
            :: a_a6Lkk
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6Lkj)
          [LclId] =
              [f1_s6Pkt] \r [x_s6Pkw y_s6Pkx] f1_s6Pkt y_s6Pkx x_s6Pkw;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pks
              Data.Foldable.$fFoldable:*:7
              sat_s6Pky
              t_s6Pkv
              z_s6Pku;

Data.Foldable.$fFoldable:.:2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableRec1_$cfoldl1
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pkz f1_s6PkA xs_s6PkB]
        let {
          sat_s6PkH [Occ=Once]
            :: a_a6LkL
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LkL))
          [LclId] =
              [f1_s6PkA] \r [x_s6PkC y_s6PkD]
                  let {
                    sat_s6PkG [Occ=Once] :: a_a6LkL
                    [LclId] =
                        [f1_s6PkA x_s6PkC y_s6PkD] \u []
                            case y_s6PkD of {
                              GHC.Base.Nothing -> x_s6PkC;
                              GHC.Base.Just x1_s6PkF [Occ=Once] -> f1_s6PkA x1_s6PkF x_s6PkC;
                            };
                  } in  GHC.Base.Just [sat_s6PkG];
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6Pkz
                  Data.Foldable.$fFoldableM3
                  sat_s6PkH
                  xs_s6PkB
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
            GHC.Base.Just v_s6PkJ [Occ=Once] -> v_s6PkJ;
          };

Data.Foldable.$fFoldableRec1_$cfoldr'
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a b. (a -> b -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PkK f1_s6PkL z0_s6PkM xs_s6PkN]
        let {
          sat_s6PkS [Occ=Once]
            :: a_a6Lk9
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6Lka -> b_a6Lka))
          [LclId] =
              [f1_s6PkL] \r [x_s6PkO y_s6PkP z_s6PkQ]
                  case f1_s6PkL x_s6PkO z_s6PkQ of vx_s6PkR {
                    __DEFAULT -> y_s6PkP vx_s6PkR;
                  };
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6PkK
              Data.Foldable.$fFoldableM4
              sat_s6PkS
              xs_s6PkN
              GHC.Base.id
              z0_s6PkM;

Data.Foldable.$fFoldableRec1_$cfold
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall m. GHC.Base.Monoid m => GHC.Generics.Rec1 f m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PkT $dMonoid_s6PkU ds_s6PkV]
        Data.Foldable.foldMap
            $dFoldable_s6PkT $dMonoid_s6PkU GHC.Base.id ds_s6PkV;

Data.Foldable.$fFoldableRec1_$cproduct
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PkW $dNum_s6PkX]
        let {
          $dMonoid_s6PkY [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LlW)
          [LclId] =
              [$dNum_s6PkX] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6PkX; } in
        let {
          sat_s6Pl0 [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlW
               -> Data.Semigroup.Internal.Product a_a6LlW
          [LclId] =
              [$dFoldable_s6PkW $dMonoid_s6PkY] \r [ds_s6PkZ]
                  Data.Foldable.foldMap
                      $dFoldable_s6PkW
                      $dMonoid_s6PkY
                      Data.Foldable.$fFoldable:*:1
                      ds_s6PkZ;
        } in  sat_s6Pl0;

Data.Foldable.$fFoldableRec1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.Rec1 f a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pl1 eta_s6Pl2]
        Data.Foldable.foldr
            $dFoldable_s6Pl1 GHC.Types.: GHC.Types.[] eta_s6Pl2;

Data.Foldable.$fFoldableRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     Data.Foldable.Foldable (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6Pl3]
        let {
          sat_s6Plq [Occ=Once]
            :: forall a. GHC.Num.Num a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cproduct
                      $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Plp [Occ=Once]
            :: forall a. GHC.Num.Num a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$csum $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Plo [Occ=Once]
            :: forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cminimum
                      $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Pln [Occ=Once]
            :: forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cmaximum
                      $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Plm [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$celem
                      $dFoldable_s6Pl3 eta_B2 eta_B1; } in
        let {
          sat_s6Pll [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$clength $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Plk [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Pl3] \r [ds_s6Plj]
                  Data.Foldable.null $dFoldable_s6Pl3 ds_s6Plj; } in
        let {
          sat_s6Pli [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> [a]
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$ctoList $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Plh [Occ=Once]
            :: forall a. (a -> a -> a) -> GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl1
                      $dFoldable_s6Pl3 eta_B2 eta_B1; } in
        let {
          sat_s6Plg [Occ=Once]
            :: forall a. (a -> a -> a) -> GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldr1
                      $dFoldable_s6Pl3 eta_B2 eta_B1; } in
        let {
          sat_s6Plf [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl'
                      $dFoldable_s6Pl3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Ple [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl
                      $dFoldable_s6Pl3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pld [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldr'
                      $dFoldable_s6Pl3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Plc [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6Pl3] \r [f1_s6Pl9 z_s6Pla ds_s6Plb]
                  Data.Foldable.foldr
                      $dFoldable_s6Pl3 f1_s6Pl9 z_s6Pla ds_s6Plb; } in
        let {
          sat_s6Pl8 [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> GHC.Generics.Rec1 f_a6Ljm a -> m
          [LclId] =
              [$dFoldable_s6Pl3] \r [$dMonoid_s6Pl5 f1_s6Pl6 ds_s6Pl7]
                  Data.Foldable.foldMap
                      $dFoldable_s6Pl3 $dMonoid_s6Pl5 f1_s6Pl6 ds_s6Pl7; } in
        let {
          sat_s6Pl4 [Occ=Once]
            :: forall m. GHC.Base.Monoid m => GHC.Generics.Rec1 f_a6Ljm m -> m
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfold $dFoldable_s6Pl3 eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6Pl4
                                    sat_s6Pl8
                                    sat_s6Plc
                                    sat_s6Pld
                                    sat_s6Ple
                                    sat_s6Plf
                                    sat_s6Plg
                                    sat_s6Plh
                                    sat_s6Pli
                                    sat_s6Plk
                                    sat_s6Pll
                                    sat_s6Plm
                                    sat_s6Pln
                                    sat_s6Plo
                                    sat_s6Plp
                                    sat_s6Plq];

Data.Foldable.$fFoldablePar1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.Par1 a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Plr eta_s6Pls]
        let {
          f_s6Plt [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LnB -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Plr eta_s6Pls] \u []
                  GHC.Classes.== $dEq_s6Plr eta_s6Pls; } in
        let {
          sat_s6Plv [Occ=OnceT[0]]
            :: GHC.Generics.Par1 a_a6LnB -> GHC.Types.Bool
          [LclId] =
              [f_s6Plt] \r [ds_s6Plu] f_s6Plt ds_s6Plu;
        } in  sat_s6Plv;

Data.Foldable.$fFoldablePar2
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Plw eta_s6Plx] eta_s6Plx;

Data.Foldable.$fFoldablePar3
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6Ply x_s6Plz] x_s6Plz;

Data.Foldable.$fFoldablePar4
  :: forall a.
     (a -> a -> a) -> GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6PlA xs_s6PlB] xs_s6PlB;

Data.Foldable.$fFoldablePar1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.Par1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6PlC z0_s6PlD xs_s6PlE] f_s6PlC z0_s6PlD xs_s6PlE;

Data.Foldable.$fFoldablePar1_$clength
  :: forall a. GHC.Generics.Par1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6PlF] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldablePar5
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.Par1 m -> GHC.Generics.Par1 m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6PlG ds_s6PlH] ds_s6PlH;

Data.Foldable.$fFoldablePar1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.Par1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_s6PlI] : [eta_s6PlI GHC.Types.[]];

Data.Foldable.$fFoldablePar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.Par1
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldablePar5
                                             Data.Foldable.$fFoldablePar1_$cfoldMap
                                             Data.Foldable.$fFoldablePar1_$cfoldr
                                             Data.Foldable.$fFoldablePar1_$cfoldr
                                             Data.Foldable.$fFoldablePar1_$cfoldl'
                                             Data.Foldable.$fFoldablePar1_$cfoldl'
                                             Data.Foldable.$fFoldablePar4
                                             Data.Foldable.$fFoldablePar4
                                             Data.Foldable.$fFoldablePar1_$ctoList
                                             Data.Foldable.$fFoldablePar1_$cnull
                                             Data.Foldable.$fFoldablePar1_$clength
                                             Data.Foldable.$fFoldablePar1_$celem
                                             Data.Foldable.$fFoldablePar3
                                             Data.Foldable.$fFoldablePar3
                                             Data.Foldable.$fFoldablePar2
                                             Data.Foldable.$fFoldablePar2];

Data.Foldable.$fFoldableV1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.V1 a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6PlJ eta_s6PlK eta1_s6PlL] GHC.Types.False [];

Data.Foldable.$fFoldableV1_$csum
  :: forall a. GHC.Num.Num a => GHC.Generics.V1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PlM ds_s6PlN]
        Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6PlM;

Data.Foldable.$fFoldableV1_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6PlO eta_s6PlP]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableV1_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6PlQ eta_s6PlR]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableV1_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.V1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6PlS z_s6PlT t_s6PlU] z_s6PlT;

Data.Foldable.$fFoldableV1_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6PlV xs_s6PlW]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableV1_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.V1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6PlX z0_s6PlY xs_s6PlZ] z0_s6PlY;

Data.Foldable.$fFoldableV1_$clength
  :: forall a. GHC.Generics.V1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6Pm0] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableV1_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pm1 xs_s6Pm2]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableV1_$cnull
  :: forall a. GHC.Generics.V1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t_s6Pm3] GHC.Types.True [];

Data.Foldable.$fFoldableV1_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Generics.V1 m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pm4 ds_s6Pm5] GHC.Base.mempty $dMonoid_s6Pm4;

Data.Foldable.$fFoldableV1_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Generics.V1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pm6 ds_s6Pm7]
        Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Pm6;

Data.Foldable.$fFoldableV1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.V1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6Pm8] [] [];

Data.Foldable.$fFoldableV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.V1
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableV1_$cfold
                                             Data.Foldable.$fFoldableV1_$cfoldMap
                                             Data.Foldable.$fFoldableV1_$cfoldr'
                                             Data.Foldable.$fFoldableV1_$cfoldr'
                                             Data.Foldable.$fFoldableV1_$cfoldl
                                             Data.Foldable.$fFoldableV1_$cfoldl
                                             Data.Foldable.$fFoldableV1_$cfoldr1
                                             Data.Foldable.$fFoldableV1_$cfoldl1
                                             Data.Foldable.$fFoldableV1_$ctoList
                                             Data.Foldable.$fFoldableV1_$cnull
                                             Data.Foldable.$fFoldableV1_$clength
                                             Data.Foldable.$fFoldableV1_$celem
                                             Data.Foldable.$fFoldableV1_$cmaximum
                                             Data.Foldable.$fFoldableV1_$cminimum
                                             Data.Foldable.$fFoldableV1_$csum
                                             Data.Foldable.$fFoldableV1_$cproduct];

Data.Foldable.$fFoldableArray_$cfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall i m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Arr.Array i a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><L,C(U)><S(LLSL),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pm9 f_s6Pma eta_s6Pmb]
        case eta_s6Pmb of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6Pmf [Occ=OnceL]
                        ww4_s6Pmg [Occ=OnceL] ->
              let {
                w1_s6Pmh [Occ=OnceL] :: m_a6LGY
                [LclId] =
                    [$dMonoid_s6Pm9] \u [] GHC.Base.mempty $dMonoid_s6Pm9; } in
              let {
                $wgo_s6Pmi [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: GHC.Prim.Int# -> m_a6LGY
                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                    sat-only [$dMonoid_s6Pm9
                              f_s6Pma
                              ww3_s6Pmf
                              ww4_s6Pmg
                              w1_s6Pmh
                              $wgo_s6Pmi] \r [ww7_s6Pmj]
                        case ==# [ww7_s6Pmj ww3_s6Pmf] of {
                          __DEFAULT ->
                              let {
                                sat_s6Pmq [Occ=Once] :: m_a6LGY
                                [LclId] =
                                    [$wgo_s6Pmi ww7_s6Pmj] \u []
                                        case +# [ww7_s6Pmj 1#] of sat_s6Pmp {
                                          __DEFAULT -> $wgo_s6Pmi sat_s6Pmp;
                                        }; } in
                              let {
                                sat_s6Pmo [Occ=Once] :: m_a6LGY
                                [LclId] =
                                    [f_s6Pma ww4_s6Pmg ww7_s6Pmj] \u []
                                        let {
                                          sat_s6Pmn [Occ=Once] :: a_a6LGZ
                                          [LclId] =
                                              [ww4_s6Pmg ww7_s6Pmj] \u []
                                                  case indexArray# [ww4_s6Pmg ww7_s6Pmj] of {
                                                    Unit# ipv_s6Pmm [Occ=Once] -> ipv_s6Pmm;
                                                  };
                                        } in  f_s6Pma sat_s6Pmn;
                              } in  GHC.Base.mappend $dMonoid_s6Pm9 sat_s6Pmo sat_s6Pmq;
                          1# -> w1_s6Pmh;
                        };
              } in  $wgo_s6Pmi 0#;
        };

Data.Foldable.$fFoldableArray1
  :: forall i a.
     GHC.Num.Num a =>
     GHC.Arr.Array i a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pmr]
        let {
          w1_s6Pms [Occ=OnceL] :: a_a6LJu
          [LclId] =
              [$dNum_s6Pmr] \u []
                  GHC.Num.fromInteger
                      $dNum_s6Pmr Data.Semigroup.Internal.$fMonoidProduct1; } in
        let {
          sat_s6PmH [Occ=OnceT[0]]
            :: GHC.Arr.Array i_a6LGK a_a6LJu
               -> Data.Semigroup.Internal.Product a_a6LJu
          [LclId] =
              [$dNum_s6Pmr w1_s6Pms] \r [w2_s6Pmt]
                  case w2_s6Pmt of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6Pmx [Occ=OnceL]
                                  ww4_s6Pmy [Occ=OnceL] ->
                        let {
                          $wgo_s6Pmz [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Product a_a6LJu
                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6Pmr
                                        w1_s6Pms
                                        ww3_s6Pmx
                                        ww4_s6Pmy
                                        $wgo_s6Pmz] \r [ww7_s6PmA]
                                  case ==# [ww7_s6PmA ww3_s6Pmx] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6PmG [Occ=Once] :: a_a6LJu
                                          [LclId] =
                                              [$wgo_s6Pmz ww7_s6PmA] \u []
                                                  case +# [ww7_s6PmA 1#] of sat_s6PmF {
                                                    __DEFAULT -> $wgo_s6Pmz sat_s6PmF;
                                                  }; } in
                                        let {
                                          sat_s6PmE [Occ=Once] :: a_a6LJu
                                          [LclId] =
                                              [ww4_s6Pmy ww7_s6PmA] \u []
                                                  case indexArray# [ww4_s6Pmy ww7_s6PmA] of {
                                                    Unit# ipv_s6PmD [Occ=Once] -> ipv_s6PmD;
                                                  };
                                        } in  GHC.Num.* $dNum_s6Pmr sat_s6PmE sat_s6PmG;
                                    1# -> w1_s6Pms;
                                  };
                        } in  $wgo_s6Pmz 0#;
                  };
        } in  sat_s6PmH;

Data.Foldable.$w$cfold [InlPrag=NOUSERINLINE[0]]
  :: forall i m.
     GHC.Base.Monoid m =>
     GHC.Prim.Int# -> GHC.Prim.Array# m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6PmI ww_s6PmJ ww1_s6PmK]
        let {
          w1_s6PmL [Occ=OnceL] :: m_s6NXp
          [LclId] =
              [w_s6PmI] \u [] GHC.Base.mempty w_s6PmI; } in
        let {
          $wgo_s6PmM [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> m_s6NXp
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6PmI
                        ww_s6PmJ
                        ww1_s6PmK
                        w1_s6PmL
                        $wgo_s6PmM] \r [ww2_s6PmN]
                  case ==# [ww2_s6PmN ww_s6PmJ] of {
                    __DEFAULT ->
                        let {
                          sat_s6PmT [Occ=Once] :: m_s6NXp
                          [LclId] =
                              [$wgo_s6PmM ww2_s6PmN] \u []
                                  case +# [ww2_s6PmN 1#] of sat_s6PmS {
                                    __DEFAULT -> $wgo_s6PmM sat_s6PmS;
                                  }; } in
                        let {
                          sat_s6PmR [Occ=Once] :: m_s6NXp
                          [LclId] =
                              [ww1_s6PmK ww2_s6PmN] \u []
                                  case indexArray# [ww1_s6PmK ww2_s6PmN] of {
                                    Unit# ipv_s6PmQ [Occ=Once] -> ipv_s6PmQ;
                                  };
                        } in  GHC.Base.mappend w_s6PmI sat_s6PmR sat_s6PmT;
                    1# -> w1_s6PmL;
                  };
        } in  $wgo_s6PmM 0#;

Data.Foldable.$fFoldableArray_$cfold [InlPrag=NOUSERINLINE[0]]
  :: forall i m. GHC.Base.Monoid m => GHC.Arr.Array i m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,U,C(C1(U)),A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PmU w1_s6PmV]
        case w1_s6PmV of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6PmZ [Occ=Once]
                        ww4_s6Pn0 [Occ=Once] ->
              Data.Foldable.$w$cfold w_s6PmU ww3_s6PmZ ww4_s6Pn0;
        };

Data.Foldable.$w$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall i a.
     GHC.Classes.Ord a =>
     GHC.Prim.Int# -> GHC.Prim.Array# a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pn1 ww_s6Pn2 ww1_s6Pn3]
        let {
          $wgo_s6Pn4 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> Data.Functor.Utils.Max a_s6NXH
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6Pn1 ww_s6Pn2 ww1_s6Pn3 $wgo_s6Pn4] \r [ww2_s6Pn5]
                  case ==# [ww2_s6Pn5 ww_s6Pn2] of {
                    __DEFAULT ->
                        let {
                          x_s6Pn7 :: a_s6NXH
                          [LclId] =
                              [ww1_s6Pn3 ww2_s6Pn5] \u []
                                  case indexArray# [ww1_s6Pn3 ww2_s6Pn5] of {
                                    Unit# ipv_s6Pn9 [Occ=Once] -> ipv_s6Pn9;
                                  };
                        } in 
                          case +# [ww2_s6Pn5 1#] of sat_s6Pna {
                            __DEFAULT ->
                                case $wgo_s6Pn4 sat_s6Pna of wild_s6Pnb {
                                  GHC.Base.Nothing -> GHC.Base.Just [x_s6Pn7];
                                  GHC.Base.Just ipv_s6Pnc [Occ=Once] ->
                                      case GHC.Classes.>= w_s6Pn1 x_s6Pn7 ipv_s6Pnc of {
                                        GHC.Types.False -> wild_s6Pnb;
                                        GHC.Types.True -> GHC.Base.Just [x_s6Pn7];
                                      };
                                };
                          };
                    1# -> GHC.Base.Nothing [];
                  };
        } in 
          case $wgo_s6Pn4 0# of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
            GHC.Base.Just v_s6Pnf [Occ=Once] -> v_s6Pnf;
          };

Data.Foldable.$fFoldableArray_$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. GHC.Classes.Ord a => GHC.Arr.Array i a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Png w1_s6Pnh]
        case w1_s6Pnh of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6Pnl [Occ=Once]
                        ww4_s6Pnm [Occ=Once] ->
              Data.Foldable.$w$cmaximum w_s6Png ww3_s6Pnl ww4_s6Pnm;
        };

Data.Foldable.$w$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall i a.
     GHC.Classes.Ord a =>
     GHC.Prim.Int# -> GHC.Prim.Array# a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pnn ww_s6Pno ww1_s6Pnp]
        let {
          $wgo_s6Pnq [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> Data.Functor.Utils.Min a_s6NXZ
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6Pnn ww_s6Pno ww1_s6Pnp $wgo_s6Pnq] \r [ww2_s6Pnr]
                  case ==# [ww2_s6Pnr ww_s6Pno] of {
                    __DEFAULT ->
                        let {
                          x_s6Pnt :: a_s6NXZ
                          [LclId] =
                              [ww1_s6Pnp ww2_s6Pnr] \u []
                                  case indexArray# [ww1_s6Pnp ww2_s6Pnr] of {
                                    Unit# ipv_s6Pnv [Occ=Once] -> ipv_s6Pnv;
                                  };
                        } in 
                          case +# [ww2_s6Pnr 1#] of sat_s6Pnw {
                            __DEFAULT ->
                                case $wgo_s6Pnq sat_s6Pnw of wild_s6Pnx {
                                  GHC.Base.Nothing -> GHC.Base.Just [x_s6Pnt];
                                  GHC.Base.Just ipv_s6Pny [Occ=Once] ->
                                      case GHC.Classes.<= w_s6Pnn x_s6Pnt ipv_s6Pny of {
                                        GHC.Types.False -> wild_s6Pnx;
                                        GHC.Types.True -> GHC.Base.Just [x_s6Pnt];
                                      };
                                };
                          };
                    1# -> GHC.Base.Nothing [];
                  };
        } in 
          case $wgo_s6Pnq 0# of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
            GHC.Base.Just v_s6PnB [Occ=Once] -> v_s6PnB;
          };

Data.Foldable.$fFoldableArray_$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. GHC.Classes.Ord a => GHC.Arr.Array i a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PnC w1_s6PnD]
        case w1_s6PnD of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6PnH [Occ=Once]
                        ww4_s6PnI [Occ=Once] ->
              Data.Foldable.$w$cminimum w_s6PnC ww3_s6PnH ww4_s6PnI;
        };

Data.Foldable.$fFoldableArray2
  :: forall i a.
     GHC.Num.Num a =>
     GHC.Arr.Array i a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PnJ]
        let {
          w1_s6PnK [Occ=OnceL] :: a_a6LJk
          [LclId] =
              [$dNum_s6PnJ] \u []
                  GHC.Num.fromInteger
                      $dNum_s6PnJ Data.Semigroup.Internal.$fMonoidSum1; } in
        let {
          sat_s6PnZ [Occ=OnceT[0]]
            :: GHC.Arr.Array i_X6LX9 a_a6LJk
               -> Data.Semigroup.Internal.Sum a_a6LJk
          [LclId] =
              [$dNum_s6PnJ w1_s6PnK] \r [w2_s6PnL]
                  case w2_s6PnL of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6PnP [Occ=OnceL]
                                  ww4_s6PnQ [Occ=OnceL] ->
                        let {
                          $wgo_s6PnR [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Sum a_a6LJk
                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6PnJ
                                        w1_s6PnK
                                        ww3_s6PnP
                                        ww4_s6PnQ
                                        $wgo_s6PnR] \r [ww7_s6PnS]
                                  case ==# [ww7_s6PnS ww3_s6PnP] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6PnY [Occ=Once] :: a_a6LJk
                                          [LclId] =
                                              [$wgo_s6PnR ww7_s6PnS] \u []
                                                  case +# [ww7_s6PnS 1#] of sat_s6PnX {
                                                    __DEFAULT -> $wgo_s6PnR sat_s6PnX;
                                                  }; } in
                                        let {
                                          sat_s6PnW [Occ=Once] :: a_a6LJk
                                          [LclId] =
                                              [ww4_s6PnQ ww7_s6PnS] \u []
                                                  case indexArray# [ww4_s6PnQ ww7_s6PnS] of {
                                                    Unit# ipv_s6PnV [Occ=Once] -> ipv_s6PnV;
                                                  };
                                        } in  GHC.Num.+ $dNum_s6PnJ sat_s6PnW sat_s6PnY;
                                    1# -> w1_s6PnK;
                                  };
                        } in  $wgo_s6PnR 0#;
                  };
        } in  sat_s6PnZ;

Data.Foldable.$fFoldableArray_$celem
  :: forall i a.
     GHC.Classes.Eq a =>
     a -> GHC.Arr.Array i a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Po0 eta_s6Po1]
        let {
          f_s6Po2 [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LIQ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Po0 eta_s6Po1] \u []
                  GHC.Classes.== $dEq_s6Po0 eta_s6Po1; } in
        let {
          sat_s6Poh [Occ=Once]
            :: GHC.Arr.Array i_X6LXe a_a6LIQ -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6Po2] \r [w2_s6Po3]
                  case w2_s6Po3 of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6Po7 [Occ=OnceL]
                                  ww4_s6Po8 [Occ=OnceL] ->
                        let-no-escape {
                          $wgo_s6Po9 [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Any
                          [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [f_s6Po2 ww3_s6Po7 ww4_s6Po8 $wgo_s6Po9] \r [ww7_s6Poa]
                                  case ==# [ww7_s6Poa ww3_s6Po7] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6Poe [Occ=Once] :: a_a6LIQ
                                          [LclId] =
                                              [ww4_s6Po8 ww7_s6Poa] \u []
                                                  case indexArray# [ww4_s6Po8 ww7_s6Poa] of {
                                                    Unit# ipv_s6Pod [Occ=Once] -> ipv_s6Pod;
                                                  };
                                        } in 
                                          case f_s6Po2 sat_s6Poe of {
                                            GHC.Types.False ->
                                                case +# [ww7_s6Poa 1#] of sat_s6Pog {
                                                  __DEFAULT -> $wgo_s6Po9 sat_s6Pog;
                                                };
                                            GHC.Types.True -> GHC.Types.True [];
                                          };
                                    1# -> GHC.Types.False [];
                                  };
                        } in  $wgo_s6Po9 0#;
                  };
        } in  sat_s6Poh;

Data.Foldable.$fFoldableArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Foldable.Foldable (GHC.Arr.Array i)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableArray_$cfold
                                             Data.Foldable.$fFoldableArray_$cfoldMap
                                             GHC.Arr.foldrElems
                                             GHC.Arr.foldrElems'
                                             GHC.Arr.foldlElems
                                             GHC.Arr.foldlElems'
                                             GHC.Arr.foldr1Elems
                                             GHC.Arr.foldl1Elems
                                             GHC.Arr.elems
                                             Data.Foldable.$fFoldableArray_$cnull
                                             GHC.Arr.numElements
                                             Data.Foldable.$fFoldableArray_$celem
                                             Data.Foldable.$fFoldableArray_$cmaximum
                                             Data.Foldable.$fFoldableArray_$cminimum
                                             Data.Foldable.$fFoldableArray2
                                             Data.Foldable.$fFoldableArray1];

Data.Foldable.$fFoldable(,)_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> (a1, a2) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Poi eta_s6Poj]
        let {
          f_s6Pok [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_a6LLd -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Poi eta_s6Poj] \u []
                  GHC.Classes.== $dEq_s6Poi eta_s6Poj; } in
        let {
          sat_s6Pop [Occ=Once]
            :: (a_a6LJD, a1_a6LLd) -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6Pok] \r [ds_s6Pol]
                  case ds_s6Pol of {
                    (,) _ [Occ=Dead] y_s6Poo [Occ=Once] -> f_s6Pok y_s6Poo;
                  };
        } in  sat_s6Pop;

Data.Foldable.$fFoldable(,)2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     (a1, a2) -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Poq eta_s6Por]
        case eta_s6Por of {
          (,) _ [Occ=Dead] y_s6Pou [Occ=Once] -> y_s6Pou;
        };

Data.Foldable.$fFoldable(,)3 :: forall a1 a2. (a2, a1) -> a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [x_s6Pov]
        case x_s6Pov of {
          (,) _ [Occ=Dead] y_s6Poy [Occ=Once] -> y_s6Poy;
        };

Data.Foldable.$fFoldable(,)_$cminimum
  :: forall a1 a2. GHC.Classes.Ord a2 => (a1, a2) -> a2
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Poz eta_B1] Data.Foldable.$fFoldable(,)3 eta_B1;

Data.Foldable.$fFoldable(,)_$cnull
  :: forall a1 a2. (a1, a2) -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6PoA]
        case ds_s6PoA of {
          (,) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldable(,)_$cfoldr1
  :: forall a1 a2. (a2 -> a2 -> a2) -> (a1, a2) -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6PoE xs_s6PoF]
        case xs_s6PoF of {
          (,) _ [Occ=Dead] y_s6PoI [Occ=Once] -> y_s6PoI;
        };

Data.Foldable.$fFoldable(,)_$cfoldl'
  :: forall a1 b a2. (b -> a2 -> b) -> b -> (a1, a2) -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_s6PoJ z0_s6PoK xs_s6PoL]
        case xs_s6PoL of {
          (,) _ [Occ=Dead] y_s6PoO [Occ=Once] -> f_s6PoJ z0_s6PoK y_s6PoO;
        };

Data.Foldable.$fFoldable(,)_$clength
  :: forall a1 a2. (a1, a2) -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6PoP]
        case xs_s6PoP of {
          (,) _ [Occ=Dead] _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldable(,)_$cfold
  :: forall a m. GHC.Base.Monoid m => (a, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6PoT ds_s6PoU]
        case ds_s6PoU of {
          (,) _ [Occ=Dead] y_s6PoX [Occ=Once] -> y_s6PoX;
        };

Data.Foldable.$fFoldable(,)1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     (a1, a2) -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PoY eta_s6PoZ]
        case eta_s6PoZ of {
          (,) _ [Occ=Dead] y_s6Pp2 [Occ=Once] -> y_s6Pp2;
        };

Data.Foldable.$fFoldable(,)_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. (a1, a2) -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_s6Pp3]
        case eta_s6Pp3 of {
          (,) _ [Occ=Dead] y_s6Pp6 [Occ=Once] -> : [y_s6Pp6 GHC.Types.[]];
        };

Data.Foldable.$fFoldable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable ((,) a)
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldable(,)_$cfold
                                             Data.Foldable.$fFoldable(,)_$cfoldMap
                                             Data.Foldable.$fFoldable(,)_$cfoldr
                                             Data.Foldable.$fFoldable(,)_$cfoldr
                                             Data.Foldable.$fFoldable(,)_$cfoldl'
                                             Data.Foldable.$fFoldable(,)_$cfoldl'
                                             Data.Foldable.$fFoldable(,)_$cfoldr1
                                             Data.Foldable.$fFoldable(,)_$cfoldr1
                                             Data.Foldable.$fFoldable(,)_$ctoList
                                             Data.Foldable.$fFoldable(,)_$cnull
                                             Data.Foldable.$fFoldable(,)_$clength
                                             Data.Foldable.$fFoldable(,)_$celem
                                             Data.Foldable.$fFoldable(,)_$cminimum
                                             Data.Foldable.$fFoldable(,)_$cminimum
                                             Data.Foldable.$fFoldable(,)2
                                             Data.Foldable.$fFoldable(,)1];

Data.Foldable.$fFoldableEither_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> Data.Either.Either a1 a2 -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Pp7 eta_s6Pp8]
        let {
          ds_s6Pp9 [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_a6LND -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Pp7 eta_s6Pp8] \u []
                  GHC.Classes.== $dEq_s6Pp7 eta_s6Pp8; } in
        let {
          sat_s6Ppe [Occ=Once]
            :: Data.Either.Either a_a6LM0 a1_a6LND
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [ds_s6Pp9] \r [ds1_s6Ppa]
                  case ds1_s6Ppa of {
                    Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                    Data.Either.Right y_s6Ppd [Occ=Once] -> ds_s6Pp9 y_s6Ppd;
                  };
        } in  sat_s6Ppe;

Data.Foldable.$fFoldableEither2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Either.Either a1 a2 -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ppf ds_s6Ppg]
        case ds_s6Ppg of {
          Data.Either.Left _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Ppf;
          Data.Either.Right y_s6Ppj [Occ=Once] -> y_s6Ppj;
        };

Data.Foldable.$fFoldableEither3
  :: forall a1 a2. Data.Either.Either a2 a1 -> a1
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Ppk]
        case x_s6Ppk of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:2;
          Data.Either.Right y_s6Ppn [Occ=Once] -> y_s6Ppn;
        };

Data.Foldable.$fFoldableEither_$cminimum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ppo eta_B1] Data.Foldable.$fFoldableEither3 eta_B1;

Data.Foldable.$fFoldableEither4
  :: forall a1 a2. Data.Either.Either a2 a1 -> a1
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Ppp]
        case x_s6Ppp of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:3;
          Data.Either.Right y_s6Pps [Occ=Once] -> y_s6Pps;
        };

Data.Foldable.$fFoldableEither_$cmaximum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ppt eta_B1] Data.Foldable.$fFoldableEither4 eta_B1;

Data.Foldable.$fFoldableEither_$cfoldr1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6Ppu xs_s6Ppv]
        case xs_s6Ppv of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:.:3;
          Data.Either.Right y_s6Ppy [Occ=Once] -> y_s6Ppy;
        };

Data.Foldable.$fFoldableEither_$cfoldl'
  :: forall a1 b a2.
     (b -> a2 -> b) -> b -> Data.Either.Either a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6Ppz z0_s6PpA xs_s6PpB]
        case xs_s6PpB of {
          Data.Either.Left _ [Occ=Dead] -> z0_s6PpA;
          Data.Either.Right y_s6PpE [Occ=Once] -> f_s6Ppz z0_s6PpA y_s6PpE;
        };

Data.Foldable.$fFoldableEither_$cfoldl1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PpF xs_s6PpG]
        case xs_s6PpG of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:.:2;
          Data.Either.Right y_s6PpJ [Occ=Once] -> y_s6PpJ;
        };

Data.Foldable.$fFoldableEither_$cfold
  :: forall a m. GHC.Base.Monoid m => Data.Either.Either a m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6PpK ds_s6PpL]
        case ds_s6PpL of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6PpK;
          Data.Either.Right y_s6PpO [Occ=Once] -> y_s6PpO;
        };

Data.Foldable.$fFoldableEither1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Either.Either a1 a2 -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PpP ds_s6PpQ]
        case ds_s6PpQ of {
          Data.Either.Left _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6PpP;
          Data.Either.Right y_s6PpT [Occ=Once] -> y_s6PpT;
        };

Data.Foldable.$fFoldableEither_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. Data.Either.Either a1 a2 -> [a2]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6PpU]
        case eta_s6PpU of {
          Data.Either.Left _ [Occ=Dead] -> [] [];
          Data.Either.Right y_s6PpX [Occ=Once] -> : [y_s6PpX GHC.Types.[]];
        };

Data.Foldable.$fFoldableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable (Data.Either.Either a)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableEither_$cfold
                                             Data.Foldable.$fFoldableEither_$cfoldMap
                                             Data.Foldable.$fFoldableEither_$cfoldr
                                             Data.Foldable.$fFoldableEither_$cfoldr
                                             Data.Foldable.$fFoldableEither_$cfoldl'
                                             Data.Foldable.$fFoldableEither_$cfoldl'
                                             Data.Foldable.$fFoldableEither_$cfoldr1
                                             Data.Foldable.$fFoldableEither_$cfoldl1
                                             Data.Foldable.$fFoldableEither_$ctoList
                                             Data.Either.isLeft
                                             Data.Foldable.$fFoldableEither_$clength
                                             Data.Foldable.$fFoldableEither_$celem
                                             Data.Foldable.$fFoldableEither_$cmaximum
                                             Data.Foldable.$fFoldableEither_$cminimum
                                             Data.Foldable.$fFoldableEither2
                                             Data.Foldable.$fFoldableEither1];

Data.Foldable.$fFoldableNonEmpty_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6PpY eta_s6PpZ]
        let {
          f_s6Pq0 [Dmd=<L,C(U)>] :: a_a6LQe -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6PpY eta_s6PpZ] \u []
                  GHC.Classes.== $dEq_s6PpY eta_s6PpZ; } in
        let {
          sat_s6Pqg [Occ=OnceT[0]]
            :: GHC.Base.NonEmpty a_a6LQe -> GHC.Types.Bool
          [LclId] =
              [f_s6Pq0] \r [ds_s6Pq1]
                  let {
                    sat_s6Pq5 [Occ=Once] :: a_a6LQe
                    [LclId] =
                        [ds_s6Pq1] \u []
                            case ds_s6Pq1 of {
                              GHC.Base.:| a1_s6Pq3 [Occ=Once] _ [Occ=Dead] -> a1_s6Pq3;
                            };
                  } in 
                    case f_s6Pq0 sat_s6Pq5 of {
                      GHC.Types.False ->
                          case ds_s6Pq1 of {
                            GHC.Base.:| _ [Occ=Dead] as_s6Pq9 [Occ=Once] ->
                                let-no-escape {
                                  go_s6Pqa [Occ=LoopBreakerT[1]] :: [a_a6LQe] -> GHC.Types.Bool
                                  [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                      sat-only [f_s6Pq0 go_s6Pqa] \r [ds1_s6Pqb]
                                          case ds1_s6Pqb of {
                                            [] -> GHC.Types.False [];
                                            : y_s6Pqd [Occ=Once] ys_s6Pqe [Occ=Once] ->
                                                case f_s6Pq0 y_s6Pqd of {
                                                  GHC.Types.False -> go_s6Pqa ys_s6Pqe;
                                                  GHC.Types.True -> GHC.Types.True [];
                                                };
                                          };
                                } in  go_s6Pqa as_s6Pq9;
                          };
                      GHC.Types.True -> GHC.Types.True [];
                    };
        } in  sat_s6Pqg;

Data.Foldable.$fFoldableNonEmpty_$csum
  :: forall a. GHC.Num.Num a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Str=<S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,1*C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pqh ds_s6Pqi]
        let {
          sat_s6Pqx [Occ=Once] :: a_a6LQI
          [LclId] =
              [$dNum_s6Pqh ds_s6Pqi] \u []
                  case ds_s6Pqi of {
                    GHC.Base.:| _ [Occ=Dead] as_s6Pqp [Occ=Once] ->
                        let {
                          z_s6Pqq [Occ=OnceL] :: a_a6LQI
                          [LclId] =
                              [$dNum_s6Pqh] \u []
                                  GHC.Num.fromInteger
                                      $dNum_s6Pqh Data.Semigroup.Internal.$fMonoidSum1; } in
                        let {
                          go_s6Pqr [Occ=LoopBreaker]
                            :: [a_a6LQI] -> Data.Semigroup.Internal.Sum a_a6LQI
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6Pqh z_s6Pqq go_s6Pqr] \r [ds1_s6Pqs]
                                  case ds1_s6Pqs of {
                                    [] -> z_s6Pqq;
                                    : y_s6Pqu [Occ=Once] ys_s6Pqv [Occ=Once] ->
                                        let {
                                          sat_s6Pqw [Occ=Once] :: a_a6LQI
                                          [LclId] =
                                              [go_s6Pqr ys_s6Pqv] \u [] go_s6Pqr ys_s6Pqv;
                                        } in  GHC.Num.+ $dNum_s6Pqh y_s6Pqu sat_s6Pqw;
                                  };
                        } in  go_s6Pqr as_s6Pqp;
                  }; } in
        let {
          sat_s6Pqm [Occ=Once] :: a_a6LQI
          [LclId] =
              [ds_s6Pqi] \u []
                  case ds_s6Pqi of {
                    GHC.Base.:| a1_s6Pqk [Occ=Once] _ [Occ=Dead] -> a1_s6Pqk;
                  };
        } in  GHC.Num.+ $dNum_s6Pqh sat_s6Pqm sat_s6Pqx;

Data.Foldable.$w$cminimum1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pqy ww_s6Pqz ww1_s6PqA]
        let {
          go_s6PqB [Occ=LoopBreaker]
            :: [a_s6NYC] -> Data.Functor.Utils.Min a_s6NYC
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6Pqy go_s6PqB] \r [ds_s6PqC]
                  case ds_s6PqC of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6PqE ys_s6PqF [Occ=Once] ->
                        case go_s6PqB ys_s6PqF of wild1_s6PqG {
                          GHC.Base.Nothing -> GHC.Base.Just [y_s6PqE];
                          GHC.Base.Just ipv_s6PqH [Occ=Once] ->
                              case GHC.Classes.<= w_s6Pqy y_s6PqE ipv_s6PqH of {
                                GHC.Types.False -> wild1_s6PqG;
                                GHC.Types.True -> GHC.Base.Just [y_s6PqE];
                              };
                        };
                  };
        } in 
          case go_s6PqB ww1_s6PqA of {
            GHC.Base.Nothing -> ww_s6Pqz;
            GHC.Base.Just ipv_s6PqK ->
                case GHC.Classes.<= w_s6Pqy ww_s6Pqz ipv_s6PqK of {
                  GHC.Types.False -> ipv_s6PqK;
                  GHC.Types.True -> ww_s6Pqz;
                };
          };

Data.Foldable.$fFoldableNonEmpty_$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PqM w1_s6PqN]
        case w1_s6PqN of {
          GHC.Base.:| ww1_s6PqP [Occ=Once] ww2_s6PqQ [Occ=Once] ->
              Data.Foldable.$w$cminimum1 w_s6PqM ww1_s6PqP ww2_s6PqQ;
        };

Data.Foldable.$w$cmaximum1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6PqR ww_s6PqS ww1_s6PqT]
        let {
          go_s6PqU [Occ=LoopBreaker]
            :: [a_s6NYM] -> Data.Functor.Utils.Max a_s6NYM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6PqR go_s6PqU] \r [ds_s6PqV]
                  case ds_s6PqV of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6PqX ys_s6PqY [Occ=Once] ->
                        case go_s6PqU ys_s6PqY of wild1_s6PqZ {
                          GHC.Base.Nothing -> GHC.Base.Just [y_s6PqX];
                          GHC.Base.Just ipv_s6Pr0 [Occ=Once] ->
                              case GHC.Classes.>= w_s6PqR y_s6PqX ipv_s6Pr0 of {
                                GHC.Types.False -> wild1_s6PqZ;
                                GHC.Types.True -> GHC.Base.Just [y_s6PqX];
                              };
                        };
                  };
        } in 
          case go_s6PqU ww1_s6PqT of {
            GHC.Base.Nothing -> ww_s6PqS;
            GHC.Base.Just ipv_s6Pr3 ->
                case GHC.Classes.>= w_s6PqR ww_s6PqS ipv_s6Pr3 of {
                  GHC.Types.False -> ipv_s6Pr3;
                  GHC.Types.True -> ww_s6PqS;
                };
          };

Data.Foldable.$fFoldableNonEmpty_$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Pr5 w1_s6Pr6]
        case w1_s6Pr6 of {
          GHC.Base.:| ww1_s6Pr8 [Occ=Once] ww2_s6Pr9 [Occ=Once] ->
              Data.Foldable.$w$cmaximum1 w_s6Pr5 ww1_s6Pr8 ww2_s6Pr9;
        };

Data.Foldable.$fFoldableNonEmpty_$cnull
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Pra] GHC.Types.False [];

Data.Foldable.$w$cfoldr2 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> a -> a) -> a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Prb ww_s6Prc ww1_s6Prd]
        let {
          go_s6Pre [Occ=LoopBreaker] :: [a_s6NYW] -> GHC.Base.Maybe a_s6NYW
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6Prb go_s6Pre] \r [ds_s6Prf]
                  case ds_s6Prf of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6Prh [Occ=Once*] ys_s6Pri [Occ=Once] ->
                        let {
                          sat_s6Prl [Occ=Once] :: a_s6NYW
                          [LclId] =
                              [w_s6Prb go_s6Pre y_s6Prh ys_s6Pri] \u []
                                  case go_s6Pre ys_s6Pri of {
                                    GHC.Base.Nothing -> y_s6Prh;
                                    GHC.Base.Just y1_s6Prk [Occ=Once] -> w_s6Prb y_s6Prh y1_s6Prk;
                                  };
                        } in  GHC.Base.Just [sat_s6Prl];
                  };
        } in 
          case go_s6Pre ww1_s6Prd of {
            GHC.Base.Nothing -> ww_s6Prc;
            GHC.Base.Just y_s6Prn [Occ=Once] -> w_s6Prb ww_s6Prc y_s6Prn;
          };

Data.Foldable.$fFoldableNonEmpty_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> a -> a) -> GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Pro w1_s6Prp]
        case w1_s6Prp of {
          GHC.Base.:| ww1_s6Prr [Occ=Once] ww2_s6Prs [Occ=Once] ->
              Data.Foldable.$w$cfoldr2 w_s6Pro ww1_s6Prr ww2_s6Prs;
        };

Data.Foldable.$w$cfoldl'1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Prt w1_s6Pru ww_s6Prv ww1_s6Prw]
        case w_s6Prt w1_s6Pru ww_s6Prv of vx_s6Prx {
          __DEFAULT ->
              let-no-escape {
                go_s6Pry [Occ=LoopBreakerT[2]] :: [a_s6NZ8] -> b_s6NZ7 -> b_s6NZ7
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [w_s6Prt go_s6Pry] \r [ds_s6Prz eta_s6PrA]
                        case ds_s6Prz of {
                          [] -> eta_s6PrA;
                          : y_s6PrC [Occ=Once] ys_s6PrD [Occ=Once] ->
                              case w_s6Prt eta_s6PrA y_s6PrC of vx1_s6PrE {
                                __DEFAULT -> go_s6Pry ys_s6PrD vx1_s6PrE;
                              };
                        };
              } in  go_s6Pry ww1_s6Prw vx_s6Prx;
        };

Data.Foldable.$fFoldableNonEmpty_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PrF w1_s6PrG w2_s6PrH]
        case w2_s6PrH of {
          GHC.Base.:| ww1_s6PrJ [Occ=Once] ww2_s6PrK [Occ=Once] ->
              Data.Foldable.$w$cfoldl'1 w_s6PrF w1_s6PrG ww1_s6PrJ ww2_s6PrK;
        };

Data.Foldable.$w$cfoldr'1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6PrL w1_s6PrM ww_s6PrN ww1_s6PrO]
        let {
          sat_s6Ps0 [Occ=Once] :: b_s6NZm -> b_s6NZm
          [LclId] =
              [w_s6PrL ww_s6PrN] \r [z_s6PrZ] w_s6PrL ww_s6PrN z_s6PrZ;
        } in 
          let-no-escape {
            go_s6PrP [Occ=LoopBreakerT[3]]
              :: [a_s6NZl] -> (b_s6NZm -> b_s6NZm) -> b_s6NZm -> b_s6NZm
            [LclId[JoinId(3)],
             Arity=3,
             Str=<S,1*U><C(S),1*C1(U)><L,U>,
             Unf=OtherCon []] =
                sat-only [w_s6PrL go_s6PrP] \r [ds_s6PrQ eta_s6PrR eta1_s6PrS]
                    case ds_s6PrQ of {
                      [] -> eta_s6PrR eta1_s6PrS;
                      : y_s6PrU [Occ=Once] ys_s6PrV [Occ=Once] ->
                          let {
                            sat_s6PrY [Occ=Once] :: b_s6NZm -> b_s6NZm
                            [LclId] =
                                [w_s6PrL eta_s6PrR y_s6PrU] \r [z_s6PrW]
                                    case w_s6PrL y_s6PrU z_s6PrW of vx_s6PrX {
                                      __DEFAULT -> eta_s6PrR vx_s6PrX;
                                    };
                          } in  go_s6PrP ys_s6PrV sat_s6PrY eta1_s6PrS;
                    };
          } in  go_s6PrP ww1_s6PrO sat_s6Ps0 w1_s6PrM;

Data.Foldable.$fFoldableNonEmpty_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Ps1 w1_s6Ps2 w2_s6Ps3]
        case w2_s6Ps3 of {
          GHC.Base.:| ww1_s6Ps5 [Occ=Once] ww2_s6Ps6 [Occ=Once] ->
              Data.Foldable.$w$cfoldr'1 w_s6Ps1 w1_s6Ps2 ww1_s6Ps5 ww2_s6Ps6;
        };

Data.Foldable.$fFoldableNonEmpty_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Str=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,1*C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ps7 ds_s6Ps8]
        let {
          sat_s6Psn [Occ=Once] :: a_a6LQS
          [LclId] =
              [$dNum_s6Ps7 ds_s6Ps8] \u []
                  case ds_s6Ps8 of {
                    GHC.Base.:| _ [Occ=Dead] as_s6Psf [Occ=Once] ->
                        let {
                          z_s6Psg [Occ=OnceL] :: a_a6LQS
                          [LclId] =
                              [$dNum_s6Ps7] \u []
                                  GHC.Num.fromInteger
                                      $dNum_s6Ps7 Data.Semigroup.Internal.$fMonoidProduct1; } in
                        let {
                          go_s6Psh [Occ=LoopBreaker]
                            :: [a_a6LQS] -> Data.Semigroup.Internal.Product a_a6LQS
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6Ps7 z_s6Psg go_s6Psh] \r [ds1_s6Psi]
                                  case ds1_s6Psi of {
                                    [] -> z_s6Psg;
                                    : y_s6Psk [Occ=Once] ys_s6Psl [Occ=Once] ->
                                        let {
                                          sat_s6Psm [Occ=Once] :: a_a6LQS
                                          [LclId] =
                                              [go_s6Psh ys_s6Psl] \u [] go_s6Psh ys_s6Psl;
                                        } in  GHC.Num.* $dNum_s6Ps7 y_s6Psk sat_s6Psm;
                                  };
                        } in  go_s6Psh as_s6Psf;
                  }; } in
        let {
          sat_s6Psc [Occ=Once] :: a_a6LQS
          [LclId] =
              [ds_s6Ps8] \u []
                  case ds_s6Ps8 of {
                    GHC.Base.:| a1_s6Psa [Occ=Once] _ [Occ=Dead] -> a1_s6Psa;
                  };
        } in  GHC.Num.* $dNum_s6Ps7 sat_s6Psc sat_s6Psn;

Data.Foldable.$fFoldableNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Base.NonEmpty
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldMap
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr'
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl'
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr1
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl1
                                             Data.Foldable.$fFoldableNonEmpty_$ctoList
                                             Data.Foldable.$fFoldableNonEmpty_$cnull
                                             Data.Foldable.$fFoldableNonEmpty_$clength
                                             Data.Foldable.$fFoldableNonEmpty_$celem
                                             Data.Foldable.$fFoldableNonEmpty_$cmaximum
                                             Data.Foldable.$fFoldableNonEmpty_$cminimum
                                             Data.Foldable.$fFoldableNonEmpty_$csum
                                             Data.Foldable.$fFoldableNonEmpty_$cproduct];

Data.Foldable.$fFoldableMaybe_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Pso eta_s6Psp]
        let {
          eta1_s6Psq [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LV4 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Pso eta_s6Psp] \u []
                  GHC.Classes.== $dEq_s6Pso eta_s6Psp; } in
        let {
          sat_s6Psu [Occ=Once]
            :: GHC.Base.Maybe a_a6LV4 -> Data.Semigroup.Internal.Any
          [LclId] =
              [eta1_s6Psq] \r [eta2_s6Psr]
                  case eta2_s6Psr of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x_s6Pst [Occ=Once] -> eta1_s6Psq x_s6Pst;
                  };
        } in  sat_s6Psu;

Data.Foldable.$fFoldableMaybe2
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Maybe a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Psv eta_s6Psw]
        case eta_s6Psw of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Psv;
          GHC.Base.Just x_s6Psy [Occ=Once] -> x_s6Psy;
        };

Data.Foldable.$fFoldableMaybe3 :: forall a. GHC.Base.Maybe a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Psz]
        case x_s6Psz of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6PsB [Occ=Once] -> v_s6PsB;
        };

Data.Foldable.$fFoldableMaybe_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6PsC eta_B1] Data.Foldable.$fFoldableMaybe3 eta_B1;

Data.Foldable.$fFoldableMaybe4 :: forall a. GHC.Base.Maybe a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6PsD]
        case x_s6PsD of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6PsF [Occ=Once] -> v_s6PsF;
        };

Data.Foldable.$fFoldableMaybe_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6PsG eta_B1] Data.Foldable.$fFoldableMaybe4 eta_B1;

Data.Foldable.$fFoldableMaybe_$cnull
  :: forall a. GHC.Base.Maybe a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6PsH]
        case ds_s6PsH of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableMaybe_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PsK xs_s6PsL]
        case xs_s6PsL of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just v_s6PsN [Occ=Once] -> v_s6PsN;
        };

Data.Foldable.$fFoldableMaybe_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PsO xs_s6PsP]
        case xs_s6PsP of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just v_s6PsR [Occ=Once] -> v_s6PsR;
        };

Data.Foldable.$fFoldableMaybe_$clength
  :: forall a. GHC.Base.Maybe a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6PsS]
        case xs_s6PsS of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableMaybe_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Base.Maybe m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6PsV eta_s6PsW]
        case eta_s6PsW of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6PsV;
          GHC.Base.Just x_s6PsY [Occ=Once] -> x_s6PsY;
        };

Data.Foldable.$fFoldableMaybe1
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Maybe a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PsZ eta_s6Pt0]
        case eta_s6Pt0 of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6PsZ;
          GHC.Base.Just x_s6Pt2 [Occ=Once] -> x_s6Pt2;
        };

Data.Foldable.$fFoldableMaybe_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Base.Maybe a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6Pt3]
        case eta_s6Pt3 of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6Pt5 [Occ=Once] -> : [x_s6Pt5 GHC.Types.[]];
        };

Data.Foldable.$fFoldableMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Base.Maybe
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableMaybe_$cfold
                                             Data.Foldable.$fFoldableMaybe_$cfoldMap
                                             Data.Foldable.$fFoldableMaybe_$cfoldr
                                             Data.Foldable.$fFoldableMaybe_$cfoldr
                                             Data.Foldable.$fFoldableMaybe_$cfoldl
                                             Data.Foldable.$fFoldableMaybe_$cfoldl
                                             Data.Foldable.$fFoldableMaybe_$cfoldr1
                                             Data.Foldable.$fFoldableMaybe_$cfoldl1
                                             Data.Foldable.$fFoldableMaybe_$ctoList
                                             Data.Foldable.$fFoldableMaybe_$cnull
                                             Data.Foldable.$fFoldableMaybe_$clength
                                             Data.Foldable.$fFoldableMaybe_$celem
                                             Data.Foldable.$fFoldableMaybe_$cmaximum
                                             Data.Foldable.$fFoldableMaybe_$cminimum
                                             Data.Foldable.$fFoldableMaybe2
                                             Data.Foldable.$fFoldableMaybe1];

Data.Foldable.$fFoldableLast_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Monoid.Last a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pt6 f_s6Pt7 x_s6Pt8]
        case x_s6Pt8 of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6Pt6;
          GHC.Base.Just x1_s6Pta [Occ=Once] -> f_s6Pt7 x1_s6Pta;
        };

Data.Foldable.$fFoldableLast_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Monoid.Last m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ptb x_s6Ptc]
        case x_s6Ptc of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6Ptb;
          GHC.Base.Just x1_s6Pte [Occ=Once] -> x1_s6Pte;
        };

Data.Foldable.$fFoldableLast2
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.Last a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ptf x_s6Ptg]
        case x_s6Ptg of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Ptf;
          GHC.Base.Just x1_s6Pti [Occ=Once] -> x1_s6Pti;
        };

Data.Foldable.$fFoldableLast3 :: forall a. Data.Monoid.Last a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Ptj]
        case x_s6Ptj of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6Ptl [Occ=Once] -> v_s6Ptl;
        };

Data.Foldable.$fFoldableLast_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ptm eta_B1] Data.Foldable.$fFoldableLast3 eta_B1;

Data.Foldable.$fFoldableLast4 :: forall a. Data.Monoid.Last a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Ptn]
        case x_s6Ptn of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6Ptp [Occ=Once] -> v_s6Ptp;
        };

Data.Foldable.$fFoldableLast_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ptq eta_B1] Data.Foldable.$fFoldableLast4 eta_B1;

Data.Foldable.$fFoldableLast_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Monoid.Last a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Ptr eta_s6Pts]
        let {
          f_s6Ptt [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LuI -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Ptr eta_s6Pts] \u []
                  GHC.Classes.== $dEq_s6Ptr eta_s6Pts; } in
        let {
          sat_s6Ptx [Occ=Once]
            :: Data.Monoid.Last a_a6LuI -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6Ptt] \r [x_s6Ptu]
                  case x_s6Ptu of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x1_s6Ptw [Occ=Once] -> f_s6Ptt x1_s6Ptw;
                  };
        } in  sat_s6Ptx;

Data.Foldable.$fFoldableLast_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Monoid.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6Pty z_s6Ptz t_s6PtA]
        case t_s6PtA of {
          GHC.Base.Nothing -> z_s6Ptz;
          GHC.Base.Just x_s6PtC [Occ=Once] -> f_s6Pty z_s6Ptz x_s6PtC;
        };

Data.Foldable.$fFoldableLast_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PtD xs_s6PtE]
        case xs_s6PtE of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just x_s6PtG [Occ=Once] -> x_s6PtG;
        };

Data.Foldable.$fFoldableLast_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Monoid.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6PtH z0_s6PtI xs_s6PtJ]
        case xs_s6PtJ of {
          GHC.Base.Nothing -> z0_s6PtI;
          GHC.Base.Just x_s6PtL [Occ=Once] -> f_s6PtH x_s6PtL z0_s6PtI;
        };

Data.Foldable.$fFoldableLast_$clength
  :: forall a. Data.Monoid.Last a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6PtM]
        case xs_s6PtM of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableLast_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PtP xs_s6PtQ]
        case xs_s6PtQ of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just x_s6PtS [Occ=Once] -> x_s6PtS;
        };

Data.Foldable.$fFoldableLast_$cnull
  :: forall a. Data.Monoid.Last a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t_s6PtT]
        case t_s6PtT of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableLast1
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.Last a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PtW x_s6PtX]
        case x_s6PtX of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6PtW;
          GHC.Base.Just x1_s6PtZ [Occ=Once] -> x1_s6PtZ;
        };

Data.Foldable.$fFoldableLast_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Monoid.Last a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6Pu0]
        case eta_s6Pu0 of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6Pu2 [Occ=Once] -> : [x_s6Pu2 GHC.Types.[]];
        };

Data.Foldable.$fFoldableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Monoid.Last
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableLast_$cfold
                                             Data.Foldable.$fFoldableLast_$cfoldMap
                                             Data.Foldable.$fFoldableLast_$cfoldr'
                                             Data.Foldable.$fFoldableLast_$cfoldr'
                                             Data.Foldable.$fFoldableLast_$cfoldl
                                             Data.Foldable.$fFoldableLast_$cfoldl
                                             Data.Foldable.$fFoldableLast_$cfoldr1
                                             Data.Foldable.$fFoldableLast_$cfoldl1
                                             Data.Foldable.$fFoldableLast_$ctoList
                                             Data.Foldable.$fFoldableLast_$cnull
                                             Data.Foldable.$fFoldableLast_$clength
                                             Data.Foldable.$fFoldableLast_$celem
                                             Data.Foldable.$fFoldableLast_$cmaximum
                                             Data.Foldable.$fFoldableLast_$cminimum
                                             Data.Foldable.$fFoldableLast2
                                             Data.Foldable.$fFoldableLast1];

Data.Foldable.$fFoldableFirst_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Monoid.First a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pu3 f_s6Pu4 x_s6Pu5]
        case x_s6Pu5 of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6Pu3;
          GHC.Base.Just x1_s6Pu7 [Occ=Once] -> f_s6Pu4 x1_s6Pu7;
        };

Data.Foldable.$fFoldableFirst_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Monoid.First m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pu8 x_s6Pu9]
        case x_s6Pu9 of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6Pu8;
          GHC.Base.Just x1_s6Pub [Occ=Once] -> x1_s6Pub;
        };

Data.Foldable.$fFoldableFirst2
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.First a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Puc x_s6Pud]
        case x_s6Pud of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Puc;
          GHC.Base.Just x1_s6Puf [Occ=Once] -> x1_s6Puf;
        };

Data.Foldable.$fFoldableFirst3
  :: forall a. Data.Monoid.First a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Pug]
        case x_s6Pug of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6Pui [Occ=Once] -> v_s6Pui;
        };

Data.Foldable.$fFoldableFirst_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Puj eta_B1] Data.Foldable.$fFoldableFirst3 eta_B1;

Data.Foldable.$fFoldableFirst4
  :: forall a. Data.Monoid.First a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Puk]
        case x_s6Puk of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6Pum [Occ=Once] -> v_s6Pum;
        };

Data.Foldable.$fFoldableFirst_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Pun eta_B1] Data.Foldable.$fFoldableFirst4 eta_B1;

Data.Foldable.$fFoldableFirst_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Monoid.First a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Puo eta_s6Pup]
        let {
          f_s6Puq [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6Lxh -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Puo eta_s6Pup] \u []
                  GHC.Classes.== $dEq_s6Puo eta_s6Pup; } in
        let {
          sat_s6Puu [Occ=Once]
            :: Data.Monoid.First a_a6Lxh -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6Puq] \r [x_s6Pur]
                  case x_s6Pur of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x1_s6Put [Occ=Once] -> f_s6Puq x1_s6Put;
                  };
        } in  sat_s6Puu;

Data.Foldable.$fFoldableFirst_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Monoid.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6Puv z_s6Puw t_s6Pux]
        case t_s6Pux of {
          GHC.Base.Nothing -> z_s6Puw;
          GHC.Base.Just x_s6Puz [Occ=Once] -> f_s6Puv z_s6Puw x_s6Puz;
        };

Data.Foldable.$fFoldableFirst_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PuA xs_s6PuB]
        case xs_s6PuB of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just x_s6PuD [Occ=Once] -> x_s6PuD;
        };

Data.Foldable.$fFoldableFirst_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Monoid.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6PuE z0_s6PuF xs_s6PuG]
        case xs_s6PuG of {
          GHC.Base.Nothing -> z0_s6PuF;
          GHC.Base.Just x_s6PuI [Occ=Once] -> f_s6PuE x_s6PuI z0_s6PuF;
        };

Data.Foldable.$fFoldableFirst_$clength
  :: forall a. Data.Monoid.First a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6PuJ]
        case xs_s6PuJ of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableFirst_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PuM xs_s6PuN]
        case xs_s6PuN of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just x_s6PuP [Occ=Once] -> x_s6PuP;
        };

Data.Foldable.$fFoldableFirst_$cnull
  :: forall a. Data.Monoid.First a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t_s6PuQ]
        case t_s6PuQ of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableFirst1
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.First a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PuT x_s6PuU]
        case x_s6PuU of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6PuT;
          GHC.Base.Just x1_s6PuW [Occ=Once] -> x1_s6PuW;
        };

Data.Foldable.$fFoldableFirst_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Monoid.First a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6PuX]
        case eta_s6PuX of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6PuZ [Occ=Once] -> : [x_s6PuZ GHC.Types.[]];
        };

Data.Foldable.$fFoldableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Monoid.First
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableFirst_$cfold
                                             Data.Foldable.$fFoldableFirst_$cfoldMap
                                             Data.Foldable.$fFoldableFirst_$cfoldr'
                                             Data.Foldable.$fFoldableFirst_$cfoldr'
                                             Data.Foldable.$fFoldableFirst_$cfoldl
                                             Data.Foldable.$fFoldableFirst_$cfoldl
                                             Data.Foldable.$fFoldableFirst_$cfoldr1
                                             Data.Foldable.$fFoldableFirst_$cfoldl1
                                             Data.Foldable.$fFoldableFirst_$ctoList
                                             Data.Foldable.$fFoldableFirst_$cnull
                                             Data.Foldable.$fFoldableFirst_$clength
                                             Data.Foldable.$fFoldableFirst_$celem
                                             Data.Foldable.$fFoldableFirst_$cmaximum
                                             Data.Foldable.$fFoldableFirst_$cminimum
                                             Data.Foldable.$fFoldableFirst2
                                             Data.Foldable.$fFoldableFirst1];

Data.Foldable.all1
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> Data.Semigroup.Internal.All
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pv0 p_s6Pv1]
        Data.Foldable.foldMap
            $dFoldable_s6Pv0 Data.Semigroup.Internal.$fMonoidAll p_s6Pv1;

Data.Foldable.all
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Foldable.all1 eta_B2 eta_B1;

Data.Foldable.$fFoldable:.:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*U,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pv2 $dFoldable1_s6Pv3 ds_s6Pv4]
        let {
          sat_s6Pv5 [Occ=Once]
            :: g_a6L4V a_a6L6K -> Data.Semigroup.Internal.All
          [LclId] =
              [$dFoldable1_s6Pv3] \u [] Data.Foldable.null $dFoldable1_s6Pv3;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pv2
              Data.Semigroup.Internal.$fMonoidAll
              sat_s6Pv5
              ds_s6Pv4;

Data.Foldable.$fFoldable:.:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:.:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pv6 $dFoldable1_s6Pv7 $dMonoid_s6Pv8 ds_s6Pv9]
        let {
          sat_s6Pva [Occ=Once] :: g_X6Lnv m_a6L51 -> m_a6L51
          [LclId] =
              [$dFoldable1_s6Pv7 $dMonoid_s6Pv8] \u []
                  Data.Foldable.foldMap $dFoldable1_s6Pv7 $dMonoid_s6Pv8 GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pv6 $dMonoid_s6Pv8 sat_s6Pva ds_s6Pv9;

Data.Foldable.$fFoldable:.:_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pvb $dFoldable1_s6Pvc $dNum_s6Pvd]
        let {
          $dMonoid_s6Pve
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6L7y)
          [LclId] =
              [$dNum_s6Pvd] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6Pvd; } in
        let {
          lvl1_s6Pvf [Occ=OnceL]
            :: g_X6Lnu a_a6L7y -> Data.Semigroup.Internal.Sum a_a6L7y
          [LclId] =
              [$dFoldable1_s6Pvc $dMonoid_s6Pve] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6Pvc $dMonoid_s6Pve Data.Foldable.$fFoldable:*:1; } in
        let {
          sat_s6Pvh [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lns g_X6Lnu a_a6L7y
               -> Data.Semigroup.Internal.Sum a_a6L7y
          [LclId] =
              [$dFoldable_s6Pvb $dMonoid_s6Pve lvl1_s6Pvf] \r [ds_s6Pvg]
                  Data.Foldable.foldMap
                      $dFoldable_s6Pvb $dMonoid_s6Pve lvl1_s6Pvf ds_s6Pvg;
        } in  sat_s6Pvh;

Data.Foldable.$fFoldable:.:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pvi $dFoldable1_s6Pvj $dOrd_s6Pvk]
        let {
          $dMonoid_s6Pvl :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6L7o)
          [LclId] =
              [$dOrd_s6Pvk] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6Pvk; } in
        let {
          lvl1_s6Pvm [Occ=OnceL]
            :: g_X6Lnt a_a6L7o -> Data.Functor.Utils.Min a_a6L7o
          [LclId] =
              [$dFoldable1_s6Pvj $dMonoid_s6Pvl] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6Pvj $dMonoid_s6Pvl GHC.Base.Just; } in
        let {
          sat_s6Pvq [Occ=OnceT[0]]
            :: (GHC.Generics.:.:) f_X6Lnr g_X6Lnt a_a6L7o -> a_a6L7o
          [LclId] =
              [$dFoldable_s6Pvi $dMonoid_s6Pvl lvl1_s6Pvm] \r [x_s6Pvn]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6Pvi $dMonoid_s6Pvl lvl1_s6Pvm x_s6Pvn
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6Pvp [Occ=Once] -> v_s6Pvp;
                  };
        } in  sat_s6Pvq;

Data.Foldable.$fFoldable:.:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pvr $dFoldable1_s6Pvs $dOrd_s6Pvt]
        let {
          $dMonoid_s6Pvu :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6L7e)
          [LclId] =
              [$dOrd_s6Pvt] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6Pvt; } in
        let {
          lvl1_s6Pvv [Occ=OnceL]
            :: g_X6Lns a_a6L7e -> Data.Functor.Utils.Max a_a6L7e
          [LclId] =
              [$dFoldable1_s6Pvs $dMonoid_s6Pvu] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6Pvs $dMonoid_s6Pvu GHC.Base.Just; } in
        let {
          sat_s6Pvz [Occ=OnceT[0]]
            :: (GHC.Generics.:.:) f_X6Lnq g_X6Lns a_a6L7e -> a_a6L7e
          [LclId] =
              [$dFoldable_s6Pvr $dMonoid_s6Pvu lvl1_s6Pvv] \r [x_s6Pvw]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6Pvr $dMonoid_s6Pvu lvl1_s6Pvv x_s6Pvw
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6Pvy [Occ=Once] -> v_s6Pvy;
                  };
        } in  sat_s6Pvz;

Data.Foldable.$fFoldable:.:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:.:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PvA $dFoldable1_s6PvB $dEq_s6PvC eta_s6PvD]
        let {
          lvl1_s6PvE [Occ=OnceL]
            :: g_X6Lnr a_a6L74 -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable1_s6PvB $dEq_s6PvC eta_s6PvD] \u []
                  let {
                    sat_s6PvF [Occ=Once] :: a_a6L74 -> Data.Semigroup.Internal.Any
                    [LclId] =
                        [$dEq_s6PvC eta_s6PvD] \u [] GHC.Classes.== $dEq_s6PvC eta_s6PvD;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6PvB
                        Data.Semigroup.Internal.$fMonoidAny
                        sat_s6PvF; } in
        let {
          sat_s6PvH [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lnp g_X6Lnr a_a6L74
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6PvA lvl1_s6PvE] \r [ds_s6PvG]
                  Data.Foldable.foldMap
                      $dFoldable_s6PvA
                      Data.Semigroup.Internal.$fMonoidAny
                      lvl1_s6PvE
                      ds_s6PvG;
        } in  sat_s6PvH;

Data.Foldable.$fFoldable:.:_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PvI $dFoldable1_s6PvJ f1_s6PvK xs_s6PvL]
        let {
          f2_s6PvM [Occ=OnceL]
            :: a_a6L6m -> GHC.Base.Maybe a_a6L6m -> GHC.Base.Maybe a_a6L6m
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [f1_s6PvK] \r [x_s6PvN m_s6PvO]
                  let {
                    sat_s6PvR [Occ=Once] :: a_a6L6m
                    [LclId] =
                        [f1_s6PvK x_s6PvN m_s6PvO] \u []
                            case m_s6PvO of {
                              GHC.Base.Nothing -> x_s6PvN;
                              GHC.Base.Just y_s6PvQ [Occ=Once] -> f1_s6PvK x_s6PvN y_s6PvQ;
                            };
                  } in  GHC.Base.Just [sat_s6PvR]; } in
        let {
          sat_s6PvU [Occ=Once]
            :: g_X6Lno a_a6L6m
               -> GHC.Base.Maybe a_a6L6m -> GHC.Base.Maybe a_a6L6m
          [LclId] =
              [$dFoldable1_s6PvJ f2_s6PvM] \r [b1_s6PvS b2_s6PvT]
                  Data.Foldable.foldr $dFoldable1_s6PvJ f2_s6PvM b2_s6PvT b1_s6PvS;
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6PvI sat_s6PvU GHC.Base.Nothing xs_s6PvL
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
            GHC.Base.Just v_s6PvW [Occ=Once] -> v_s6PvW;
          };

Data.Foldable.$fFoldable:.:_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PvX
           $dFoldable1_s6PvY
           f1_s6PvZ
           z0_s6Pw0
           xs_s6Pw1]
        let {
          f2_s6Pw2 [Occ=OnceL]
            :: a_a6L6d -> (b_a6L6c -> b_a6L6c) -> b_a6L6c -> b_a6L6c
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [f1_s6PvZ] \r [x_s6Pw3 k_s6Pw4 z_s6Pw5]
                  case f1_s6PvZ z_s6Pw5 x_s6Pw3 of vx_s6Pw6 {
                    __DEFAULT -> k_s6Pw4 vx_s6Pw6;
                  }; } in
        let {
          sat_s6Pw9 [Occ=Once]
            :: g_X6Lnn a_a6L6d -> (b_a6L6c -> b_a6L6c) -> b_a6L6c -> b_a6L6c
          [LclId] =
              [$dFoldable1_s6PvY f2_s6Pw2] \r [b1_s6Pw7 b2_s6Pw8]
                  Data.Foldable.foldr $dFoldable1_s6PvY f2_s6Pw2 b2_s6Pw8 b1_s6Pw7;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6PvX sat_s6Pw9 GHC.Base.id xs_s6Pw1 z0_s6Pw0;

Data.Foldable.$fFoldable:.:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pwa $dFoldable1_s6Pwb eta_s6Pwc]
        Data.Foldable.$fFoldable:.:_$cfoldl'
            $dFoldable_s6Pwa
            $dFoldable1_s6Pwb
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4
            eta_s6Pwc;

Data.Foldable.$fFoldable:.:_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pwd $dFoldable1_s6Pwe f1_s6Pwf z_s6Pwg t_s6Pwh]
        let {
          sat_s6Pwl [Occ=Once]
            :: g_X6Lnm a_a6L63
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6L62)
          [LclId] =
              [$dFoldable1_s6Pwe f1_s6Pwf] \u []
                  let {
                    sat_s6Pwk [Occ=Once]
                      :: a_a6L63
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo b_a6L62)
                    [LclId] =
                        [f1_s6Pwf] \r [x_s6Pwi y_s6Pwj] f1_s6Pwf y_s6Pwj x_s6Pwi;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6Pwe Data.Foldable.$fFoldable:*:7 sat_s6Pwk;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pwd
              Data.Foldable.$fFoldable:*:7
              sat_s6Pwl
              t_s6Pwh
              z_s6Pwg;

Data.Foldable.$fFoldable:.:_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pwm $dFoldable1_s6Pwn f1_s6Pwo xs_s6Pwp]
        let {
          sat_s6Pww [Occ=Once]
            :: g_X6Lnp a_a6L6u
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6L6u))
          [LclId] =
              [$dFoldable1_s6Pwn f1_s6Pwo] \u []
                  let {
                    sat_s6Pwv [Occ=Once]
                      :: a_a6L6u
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6L6u))
                    [LclId] =
                        [f1_s6Pwo] \r [x_s6Pwq y_s6Pwr]
                            let {
                              sat_s6Pwu [Occ=Once] :: a_a6L6u
                              [LclId] =
                                  [f1_s6Pwo x_s6Pwq y_s6Pwr] \u []
                                      case y_s6Pwr of {
                                        GHC.Base.Nothing -> x_s6Pwq;
                                        GHC.Base.Just x1_s6Pwt [Occ=Once] ->
                                            f1_s6Pwo x1_s6Pwt x_s6Pwq;
                                      };
                            } in  GHC.Base.Just [sat_s6Pwu];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6Pwn Data.Foldable.$fFoldable:*:7 sat_s6Pwv;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6Pwm
                  Data.Foldable.$fFoldable:*:7
                  sat_s6Pww
                  xs_s6Pwp
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
            GHC.Base.Just v_s6Pwy [Occ=Once] -> v_s6Pwy;
          };

Data.Foldable.$fFoldable:.:_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pwz
           $dFoldable1_s6PwA
           f1_s6PwB
           z0_s6PwC
           xs_s6PwD]
        let {
          sat_s6PwJ [Occ=Once]
            :: g_X6Lnl a_a6L5S
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6L5T -> b_a6L5T))
          [LclId] =
              [$dFoldable1_s6PwA f1_s6PwB] \u []
                  let {
                    sat_s6PwI [Occ=Once]
                      :: a_a6L5S
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (b_a6L5T -> b_a6L5T))
                    [LclId] =
                        [f1_s6PwB] \r [x_s6PwE y_s6PwF z_s6PwG]
                            case f1_s6PwB x_s6PwE z_s6PwG of vx_s6PwH {
                              __DEFAULT -> y_s6PwF vx_s6PwH;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6PwA Data.Foldable.$fFoldable:*:7 sat_s6PwI;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pwz
              Data.Foldable.$fFoldable:*:7
              sat_s6PwJ
              xs_s6PwD
              GHC.Base.id
              z0_s6PwC;

Data.Foldable.$fFoldable:.:_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PwK $dFoldable1_s6PwL $dNum_s6PwM]
        let {
          $dMonoid_s6PwN
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6L7I)
          [LclId] =
              [$dNum_s6PwM] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6PwM; } in
        let {
          lvl1_s6PwO [Occ=OnceL]
            :: g_X6Lnk a_a6L7I -> Data.Semigroup.Internal.Product a_a6L7I
          [LclId] =
              [$dFoldable1_s6PwL $dMonoid_s6PwN] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6PwL $dMonoid_s6PwN Data.Foldable.$fFoldable:*:1; } in
        let {
          sat_s6PwQ [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lni g_X6Lnk a_a6L7I
               -> Data.Semigroup.Internal.Product a_a6L7I
          [LclId] =
              [$dFoldable_s6PwK $dMonoid_s6PwN lvl1_s6PwO] \r [ds_s6PwP]
                  Data.Foldable.foldMap
                      $dFoldable_s6PwK $dMonoid_s6PwN lvl1_s6PwO ds_s6PwP;
        } in  sat_s6PwQ;

Data.Foldable.$fFoldable:.:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PwR $dFoldable1_s6PwS eta_s6PwT]
        let {
          sat_s6PwW [Occ=Once] :: g_X6Lnj a_a6L6C -> [a_a6L6C] -> [a_a6L6C]
          [LclId] =
              [$dFoldable1_s6PwS] \r [b1_s6PwU b2_s6PwV]
                  Data.Foldable.foldr
                      $dFoldable1_s6PwS GHC.Types.: b2_s6PwV b1_s6PwU;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6PwR sat_s6PwW GHC.Types.[] eta_s6PwT;

Data.Foldable.$fFoldable:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6PwX $dFoldable1_s6PwY]
        let {
          sat_s6Pxe [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cproduct
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Pxd [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$csum
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Pxc [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cminimum
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Pxb [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cmaximum
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Pxa [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$celem
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B2 eta_B1; } in
        let {
          sat_s6Px9 [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$clength
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Px8 [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:1
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Px7 [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> [a]
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$ctoList
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Px6 [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl1
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B2 eta_B1; } in
        let {
          sat_s6Px5 [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr1
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B2 eta_B1; } in
        let {
          sat_s6Px4 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl'
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Px3 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Px2 [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr'
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Px1 [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Px0 [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> m
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldMap
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6PwZ [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni m -> m
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfold
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6PwZ
                                    sat_s6Px0
                                    sat_s6Px1
                                    sat_s6Px2
                                    sat_s6Px3
                                    sat_s6Px4
                                    sat_s6Px5
                                    sat_s6Px6
                                    sat_s6Px7
                                    sat_s6Px8
                                    sat_s6Px9
                                    sat_s6Pxa
                                    sat_s6Pxb
                                    sat_s6Pxc
                                    sat_s6Pxd
                                    sat_s6Pxe];

Data.Foldable.maximumBy
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pxf cmp_s6Pxg]
        let {
          sat_s6Pxk [Occ=Once] :: a_a6KCW -> a_a6KCW -> a_a6KCW
          [LclId] =
              [cmp_s6Pxg] \r [x_s6Pxh y_s6Pxi]
                  case cmp_s6Pxg x_s6Pxh y_s6Pxi of {
                    __DEFAULT -> y_s6Pxi;
                    GHC.Types.GT -> x_s6Pxh;
                  };
        } in  Data.Foldable.foldl1 $dFoldable_s6Pxf sat_s6Pxk;

Data.Foldable.minimumBy
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pxl cmp_s6Pxm]
        let {
          sat_s6Pxq [Occ=Once] :: a_a6KCy -> a_a6KCy -> a_a6KCy
          [LclId] =
              [cmp_s6Pxm] \r [x_s6Pxn y_s6Pxo]
                  case cmp_s6Pxm x_s6Pxn y_s6Pxo of {
                    __DEFAULT -> x_s6Pxn;
                    GHC.Types.GT -> y_s6Pxo;
                  };
        } in  Data.Foldable.foldl1 $dFoldable_s6Pxl sat_s6Pxq;

Data.Foldable.notElem
  :: forall (t :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Classes.Eq a) =>
     a -> t a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(C(U))),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pxr $dEq_s6Pxs x_s6Pxt]
        let {
          g_s6Pxu [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_a6KCk a_a6KCl -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Pxr $dEq_s6Pxs x_s6Pxt] \u []
                  Data.Foldable.elem $dFoldable_s6Pxr $dEq_s6Pxs x_s6Pxt; } in
        let {
          sat_s6Pxx [Occ=OnceT[0]] :: t_a6KCk a_a6KCl -> GHC.Types.Bool
          [LclId] =
              [g_s6Pxu] \r [x1_s6Pxv]
                  case g_s6Pxu x1_s6Pxv of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  sat_s6Pxx;

Data.Foldable.find
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pxy p_s6Pxz]
        let {
          g_s6PxA [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_a6KC3 a_a6KC4 -> Data.Monoid.First a_a6KC4
          [LclId] =
              [$dFoldable_s6Pxy p_s6Pxz] \u []
                  let {
                    sat_s6PxD [Occ=Once] :: a_a6KC4 -> Data.Monoid.First a_a6KC4
                    [LclId] =
                        [p_s6Pxz] \r [x_s6PxB]
                            case p_s6Pxz x_s6PxB of {
                              GHC.Types.False -> GHC.Base.Nothing [];
                              GHC.Types.True -> GHC.Base.Just [x_s6PxB];
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6Pxy Data.Monoid.$fMonoidFirst sat_s6PxD; } in
        let {
          sat_s6PxF [Occ=Once]
            :: t_a6KC3 a_a6KC4 -> Data.Monoid.First a_a6KC4
          [LclId] =
              [g_s6PxA] \r [x_s6PxE] g_s6PxA x_s6PxE;
        } in  sat_s6PxF;

Data.Foldable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Foldable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$trModule4];

Data.Foldable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Foldable"#;

Data.Foldable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$trModule2];

Data.Foldable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Foldable.$trModule3
                                     Data.Foldable.$trModule1];

$krep_r6OSX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Foldable.$tcFoldable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_r6OSX];

Data.Foldable.$tcFoldable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foldable"#;

Data.Foldable.$tcFoldable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$tcFoldable3];

Data.Foldable.$tcFoldable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1610127274683713266##
                                    5928938033451775936##
                                    Data.Foldable.$trModule
                                    Data.Foldable.$tcFoldable2
                                    0#
                                    Data.Foldable.$tcFoldable1];

Data.Foldable.C:Foldable
  :: forall (t :: * -> *).
     (forall m. GHC.Base.Monoid m => t m -> m)
     -> (forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m)
     -> (forall a b. (a -> b -> b) -> b -> t a -> b)
     -> (forall a b. (a -> b -> b) -> b -> t a -> b)
     -> (forall b a. (b -> a -> b) -> b -> t a -> b)
     -> (forall b a. (b -> a -> b) -> b -> t a -> b)
     -> (forall a. (a -> a -> a) -> t a -> a)
     -> (forall a. (a -> a -> a) -> t a -> a)
     -> (forall a. t a -> [a])
     -> (forall a. t a -> GHC.Types.Bool)
     -> (forall a. t a -> GHC.Types.Int)
     -> (forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool)
     -> (forall a. GHC.Classes.Ord a => t a -> a)
     -> (forall a. GHC.Classes.Ord a => t a -> a)
     -> (forall a. GHC.Num.Num a => t a -> a)
     -> (forall a. GHC.Num.Num a => t a -> a)
     -> Data.Foldable.Foldable t
[GblId[DataCon],
 Arity=16,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_Bg
           eta_Bf
           eta_Be
           eta_Bd
           eta_Bc
           eta_Bb
           eta_Ba
           eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        Data.Foldable.C:Foldable [eta_Bg
                                  eta_Bf
                                  eta_Be
                                  eta_Bd
                                  eta_Bc
                                  eta_Bb
                                  eta_Ba
                                  eta_B9
                                  eta_B8
                                  eta_B7
                                  eta_B6
                                  eta_B5
                                  eta_B4
                                  eta_B3
                                  eta_B2
                                  eta_B1];


==================== STG syntax: ====================
2018-03-16 16:02:02.028105082 UTC

Data.Foldable.fold
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m. GHC.Base.Monoid m => t m -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OSZ]
        case v_s6OSZ of {
          Data.Foldable.C:Foldable v_s6OT1 [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OT1;
        };

Data.Foldable.foldMap
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OTh]
        case v_s6OTh of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   v_s6OTk [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OTk;
        };

Data.Foldable.foldr
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OTz]
        case v_s6OTz of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OTD [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OTD;
        };

Data.Foldable.foldr'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OTR]
        case v_s6OTR of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OTW [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OTW;
        };

Data.Foldable.foldl
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OU9]
        case v_s6OU9 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OUf [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OUf;
        };

Data.Foldable.foldl'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OUr]
        case v_s6OUr of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OUy [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OUy;
        };

Data.Foldable.foldr1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OUJ]
        case v_s6OUJ of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OUR [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OUR;
        };

Data.Foldable.foldl1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OV1]
        case v_s6OV1 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OVa [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OVa;
        };

Data.Foldable.toList
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s6OVj]
        case v_s6OVj of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OVt [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OVt;
        };

Data.Foldable.null
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s6OVB]
        case v_s6OVB of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OVM [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OVM;
        };

Data.Foldable.length
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s6OVT]
        case v_s6OVT of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OW5 [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OW5;
        };

Data.Foldable.elem
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s6OWb]
        case v_s6OWb of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OWo [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OWo;
        };

Data.Foldable.maximum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s6OWt]
        case v_s6OWt of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OWH [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OWH;
        };

Data.Foldable.minimum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s6OWL]
        case v_s6OWL of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OX0 [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6OX0;
        };

Data.Foldable.sum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s6OX3]
        case v_s6OX3 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OXj [Occ=Once]
                                   _ [Occ=Dead] ->
              v_s6OXj;
        };

Data.Foldable.product
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s6OXl]
        case v_s6OXl of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6OXC [Occ=Once] ->
              v_s6OXC;
        };

Data.Foldable.$fFoldableMaybe_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.Maybe a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6OXD z_s6OXE ds1_s6OXF]
        case ds1_s6OXF of {
          GHC.Base.Nothing -> z_s6OXE;
          GHC.Base.Just x_s6OXH [Occ=Once] -> ds_s6OXD z_s6OXE x_s6OXH;
        };

Data.Foldable.$fFoldableMaybe_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.Maybe a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6OXI z_s6OXJ ds1_s6OXK]
        case ds1_s6OXK of {
          GHC.Base.Nothing -> z_s6OXJ;
          GHC.Base.Just x_s6OXM [Occ=Once] -> ds_s6OXI x_s6OXM z_s6OXJ;
        };

Data.Foldable.$fFoldableMaybe_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Base.Maybe a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6OXN eta_s6OXO eta1_s6OXP]
        case eta1_s6OXP of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6OXN;
          GHC.Base.Just x_s6OXR [Occ=Once] -> eta_s6OXO x_s6OXR;
        };

Data.Foldable.$fFoldableNonEmpty_$clength
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s6OXS]
        case ds_s6OXS of {
          GHC.Base.:| _ [Occ=Dead] as_s6OXV [Occ=Once] ->
              case GHC.List.$wlenAcc as_s6OXV 0# of ww2_s6OXW {
                __DEFAULT ->
                    case +# [1# ww2_s6OXW] of sat_s6OXX {
                      __DEFAULT -> GHC.Types.I# [sat_s6OXX];
                    };
              };
        };

Data.Foldable.$fFoldableNonEmpty_$ctoList
  :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s6OXY]
        let {
          sat_s6OY6 [Occ=Once] :: [a_a6LPN]
          [LclId] =
              [ds_s6OXY] \u []
                  case ds_s6OXY of {
                    GHC.Base.:| _ [Occ=Dead] as_s6OY5 [Occ=Once] -> as_s6OY5;
                  }; } in
        let {
          sat_s6OY2 [Occ=Once] :: a_a6LPN
          [LclId] =
              [ds_s6OXY] \u []
                  case ds_s6OXY of {
                    GHC.Base.:| a1_s6OY0 [Occ=Once] _ [Occ=Dead] -> a1_s6OY0;
                  };
        } in  : [sat_s6OY2 sat_s6OY6];

Data.Foldable.$fFoldableNonEmpty_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6OY7 ds_s6OY8]
        case ds_s6OY8 of {
          GHC.Base.:| a1_s6OYa [Occ=Once] as_s6OYb [Occ=Once] ->
              let-no-escape {
                go_s6OYc [Occ=LoopBreakerT[2]] :: [a_a6LPG] -> a_a6LPG -> a_a6LPG
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [f_s6OY7 go_s6OYc] \r [ds1_s6OYd eta_s6OYe]
                        case ds1_s6OYd of {
                          [] -> eta_s6OYe;
                          : y_s6OYg [Occ=Once] ys_s6OYh [Occ=Once] ->
                              let {
                                sat_s6OYi [Occ=Once] :: a_a6LPG
                                [LclId] =
                                    [f_s6OY7 eta_s6OYe y_s6OYg] \u [] f_s6OY7 eta_s6OYe y_s6OYg;
                              } in  go_s6OYc ys_s6OYh sat_s6OYi;
                        };
              } in  go_s6OYc as_s6OYb a1_s6OYa;
        };

Data.Foldable.$w$cfoldl2 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6OYj w1_s6OYk ww_s6OYl ww1_s6OYm]
        let {
          sat_s6OYu [Occ=Once] :: b_s6NRS
          [LclId] =
              [w_s6OYj w1_s6OYk ww_s6OYl] \u [] w_s6OYj w1_s6OYk ww_s6OYl;
        } in 
          let-no-escape {
            go_s6OYn [Occ=LoopBreakerT[2]] :: [a_s6NRT] -> b_s6NRS -> b_s6NRS
            [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                sat-only [w_s6OYj go_s6OYn] \r [ds_s6OYo eta_s6OYp]
                    case ds_s6OYo of {
                      [] -> eta_s6OYp;
                      : y_s6OYr [Occ=Once] ys_s6OYs [Occ=Once] ->
                          let {
                            sat_s6OYt [Occ=Once] :: b_s6NRS
                            [LclId] =
                                [w_s6OYj eta_s6OYp y_s6OYr] \u [] w_s6OYj eta_s6OYp y_s6OYr;
                          } in  go_s6OYn ys_s6OYs sat_s6OYt;
                    };
          } in  go_s6OYn ww1_s6OYm sat_s6OYu;

Data.Foldable.$fFoldableNonEmpty_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6OYv w1_s6OYw w2_s6OYx]
        case w2_s6OYx of {
          GHC.Base.:| ww1_s6OYz [Occ=Once] ww2_s6OYA [Occ=Once] ->
              Data.Foldable.$w$cfoldl2 w_s6OYv w1_s6OYw ww1_s6OYz ww2_s6OYA;
        };

Data.Foldable.$fFoldableNonEmpty_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6OYB z_s6OYC ds_s6OYD]
        let {
          sat_s6OYR [Occ=Once] :: b_a6LOW
          [LclId] =
              [f_s6OYB z_s6OYC ds_s6OYD] \u []
                  case ds_s6OYD of {
                    GHC.Base.:| _ [Occ=Dead] as_s6OYK [Occ=Once] ->
                        let {
                          go_s6OYL [Occ=LoopBreaker] :: [a_a6LOV] -> b_a6LOW
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [f_s6OYB z_s6OYC go_s6OYL] \r [ds1_s6OYM]
                                  case ds1_s6OYM of {
                                    [] -> z_s6OYC;
                                    : y_s6OYO [Occ=Once] ys_s6OYP [Occ=Once] ->
                                        let {
                                          sat_s6OYQ [Occ=Once] :: b_a6LOW
                                          [LclId] =
                                              [go_s6OYL ys_s6OYP] \u [] go_s6OYL ys_s6OYP;
                                        } in  f_s6OYB y_s6OYO sat_s6OYQ;
                                  };
                        } in  go_s6OYL as_s6OYK;
                  }; } in
        let {
          sat_s6OYH [Occ=Once] :: a_a6LOV
          [LclId] =
              [ds_s6OYD] \u []
                  case ds_s6OYD of {
                    GHC.Base.:| a1_s6OYF [Occ=Once] _ [Occ=Dead] -> a1_s6OYF;
                  };
        } in  f_s6OYB sat_s6OYH sat_s6OYR;

Data.Foldable.$fFoldable:*:4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Foldable.$fFoldableDual3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Foldable.$fFoldableEither_$clength
  :: forall a1 a2. Data.Either.Either a1 a2 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_s6OYS]
        case ds_s6OYS of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
          Data.Either.Right _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableEither_$cfoldr
  :: forall a1 a2 b.
     (a2 -> b -> b) -> b -> Data.Either.Either a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6OYW z_s6OYX ds1_s6OYY]
        case ds1_s6OYY of {
          Data.Either.Left _ [Occ=Dead] -> z_s6OYX;
          Data.Either.Right y_s6OZ1 [Occ=Once] -> ds_s6OYW y_s6OZ1 z_s6OYX;
        };

Data.Foldable.$fFoldableEither_$cfoldMap
  :: forall a1 m a2.
     GHC.Base.Monoid m =>
     (a2 -> m) -> Data.Either.Either a1 a2 -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6OZ2 ds_s6OZ3 ds1_s6OZ4]
        case ds1_s6OZ4 of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6OZ2;
          Data.Either.Right y_s6OZ7 [Occ=Once] -> ds_s6OZ3 y_s6OZ7;
        };

Data.Foldable.$fFoldable(,)_$cfoldr
  :: forall a1 a2 b. (a2 -> b -> b) -> b -> (a1, a2) -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_s6OZ8 z_s6OZ9 ds_s6OZa]
        case ds_s6OZa of {
          (,) _ [Occ=Dead] y_s6OZd [Occ=Once] -> f_s6OZ8 y_s6OZd z_s6OZ9;
        };

Data.Foldable.$fFoldable(,)_$cfoldMap
  :: forall a1 m a2. GHC.Base.Monoid m => (a2 -> m) -> (a1, a2) -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6OZe f_s6OZf ds_s6OZg]
        case ds_s6OZg of {
          (,) _ [Occ=Dead] y_s6OZj [Occ=Once] -> f_s6OZf y_s6OZj;
        };

Data.Foldable.$fFoldableArray_$cnull
  :: forall i a. GHC.Arr.Array i a -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),1*U(A,A,1*U,A)>,
 Unf=OtherCon []] =
    [] \r [a1_s6OZk]
        case a1_s6OZk of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        dt_s6OZo [Occ=Once!]
                        _ [Occ=Dead] ->
              case dt_s6OZo of {
                __DEFAULT -> GHC.Types.False [];
                0# -> GHC.Types.True [];
              };
        };

sat_s6OZr :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s6OZs :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6OZr GHC.Types.[]];

Data.Foldable.$fFoldableProxy1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6OZs;

Data.Foldable.$fFoldableProxy_$cproduct
  :: forall a. GHC.Num.Num a => Data.Proxy.Proxy a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6OZt ds_s6OZu]
        GHC.Num.fromInteger $dNum_s6OZt Data.Foldable.$fFoldableProxy1;

Data.Foldable.$fFoldableProxy2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Foldable.$fFoldableProxy_$csum
  :: forall a. GHC.Num.Num a => Data.Proxy.Proxy a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6OZv ds_s6OZw]
        GHC.Num.fromInteger $dNum_s6OZv Data.Foldable.$fFoldableProxy2;

Data.Foldable.$fFoldableProxy_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Proxy.Proxy a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6OZx ds_s6OZy ds1_s6OZz] GHC.Types.False [];

Data.Foldable.$fFoldableProxy_$clength
  :: forall a. Data.Proxy.Proxy a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6OZA] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableProxy_$cnull
  :: forall a. Data.Proxy.Proxy a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6OZB] GHC.Types.True [];

Data.Foldable.$fFoldableProxy4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: Proxy"#;

Data.Foldable.$fFoldableProxy3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableProxy4;

Data.Foldable.$fFoldableProxy_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6OZC ds1_s6OZD]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableProxy3;

Data.Foldable.$fFoldableProxy6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: Proxy"#;

Data.Foldable.$fFoldableProxy5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableProxy6;

Data.Foldable.$fFoldableProxy_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6OZE ds1_s6OZF]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableProxy5;

Data.Foldable.$fFoldableProxy_$cfoldl [InlPrag=INLINE (sat-args=3)]
  :: forall b a. (b -> a -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6OZG z_s6OZH ds1_s6OZI] z_s6OZH;

Data.Foldable.$fFoldableProxy_$cfoldr [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (a -> b -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6OZJ z_s6OZK ds1_s6OZL] z_s6OZK;

Data.Foldable.$fFoldableProxy_$cfoldMap [InlPrag=INLINE (sat-args=2)]
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Proxy.Proxy a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6OZM eta_s6OZN ds_s6OZO]
        GHC.Base.mempty $dMonoid_s6OZM;

Data.Foldable.$fFoldableProxy_$cfold [InlPrag=INLINE (sat-args=1)]
  :: forall m. GHC.Base.Monoid m => Data.Proxy.Proxy m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6OZP ds_s6OZQ] GHC.Base.mempty $dMonoid_s6OZP;

Data.Foldable.$fFoldableDual1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6OZR eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6OZS eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual_$clength
  :: forall a. Data.Semigroup.Internal.Dual a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6OZT] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableDual_$cnull
  :: forall a. Data.Semigroup.Internal.Dual a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6OZU] GHC.Types.False [];

Data.Foldable.$fFoldableDual_$ctoList
  :: forall a. Data.Semigroup.Internal.Dual a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6OZV] : [ds_s6OZV GHC.Types.[]];

Data.Foldable.$fFoldableDual4
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6OZW eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual5
  :: forall b a. (b -> a -> b) -> b -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6OZX] v_s6OZX;

Data.Foldable.$fFoldableDual_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Dual a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6OZY z_s6OZZ ds_s6P00] f_s6OZY ds_s6P00 z_s6OZZ;

Data.Foldable.$fFoldableDual6
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> a -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P01 v_s6P02] v_s6P02;

Data.Foldable.$fFoldableSum1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6P03 eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6P04 eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum_$clength
  :: forall a. Data.Semigroup.Internal.Sum a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6P05] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableSum_$cnull
  :: forall a. Data.Semigroup.Internal.Sum a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P06] GHC.Types.False [];

Data.Foldable.$fFoldableSum_$ctoList
  :: forall a. Data.Semigroup.Internal.Sum a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6P07] : [ds_s6P07 GHC.Types.[]];

Data.Foldable.$fFoldableSum3
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P08 eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Sum a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6P09 z_s6P0a ds_s6P0b] f_s6P09 ds_s6P0b z_s6P0a;

Data.Foldable.$fFoldableProduct1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6P0c eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6P0d eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct_$clength
  :: forall a. Data.Semigroup.Internal.Product a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6P0e] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableProduct_$cnull
  :: forall a. Data.Semigroup.Internal.Product a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P0f] GHC.Types.False [];

Data.Foldable.$fFoldableProduct_$ctoList
  :: forall a. Data.Semigroup.Internal.Product a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6P0g] : [ds_s6P0g GHC.Types.[]];

Data.Foldable.$fFoldableProduct3
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P0h eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Product a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6P0i z_s6P0j ds_s6P0k] f_s6P0i ds_s6P0k z_s6P0j;

Data.Foldable.$fFoldableU1_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Generics.U1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P0l ds_s6P0m]
        GHC.Num.fromInteger $dNum_s6P0l Data.Foldable.$fFoldableProxy1;

Data.Foldable.$fFoldableU1_$csum
  :: forall a. GHC.Num.Num a => GHC.Generics.U1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P0n ds_s6P0o]
        GHC.Num.fromInteger $dNum_s6P0n Data.Foldable.$fFoldableProxy2;

Data.Foldable.$fFoldableU1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.U1 a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P0p ds_s6P0q ds1_s6P0r] GHC.Types.False [];

Data.Foldable.$fFoldableU1_$clength
  :: forall a. GHC.Generics.U1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6P0s] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableU1_$cnull
  :: forall a. GHC.Generics.U1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P0t] GHC.Types.True [];

Data.Foldable.$fFoldableU3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: U1"#;

Data.Foldable.$fFoldableU2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableU3;

Data.Foldable.$fFoldableU1_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6P0u ds1_s6P0v]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableU2;

Data.Foldable.$fFoldableU5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: U1"#;

Data.Foldable.$fFoldableU4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableU5;

Data.Foldable.$fFoldableU1_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6P0w ds1_s6P0x]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableU4;

Data.Foldable.$fFoldableU1_$cfoldl [InlPrag=INLINE (sat-args=3)]
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6P0y z_s6P0z ds1_s6P0A] z_s6P0z;

Data.Foldable.$fFoldableU1_$cfoldr [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6P0B z_s6P0C ds1_s6P0D] z_s6P0C;

Data.Foldable.$fFoldableU1_$cfoldMap [InlPrag=INLINE (sat-args=2)]
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.U1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P0E eta_s6P0F ds_s6P0G]
        GHC.Base.mempty $dMonoid_s6P0E;

Data.Foldable.$fFoldableU1_$cfold [InlPrag=INLINE (sat-args=1)]
  :: forall m. GHC.Base.Monoid m => GHC.Generics.U1 m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P0H ds_s6P0I] GHC.Base.mempty $dMonoid_s6P0H;

Data.Foldable.$fFoldableV1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.V1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P0J ds_s6P0K ds1_s6P0L]
        GHC.Base.mempty $dMonoid_s6P0J;

Data.Foldable.$fFoldablePar1_$cnull
  :: forall a. GHC.Generics.Par1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P0M] GHC.Types.False [];

Data.Foldable.$fFoldablePar1_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.Par1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6P0N z_s6P0O ds_s6P0P] f_s6P0N ds_s6P0P z_s6P0O;

Data.Foldable.$fFoldablePar1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.Par1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P0Q f_s6P0R ds_s6P0S] f_s6P0R ds_s6P0S;

Data.Foldable.$fFoldableK1_$cfoldMap
  :: forall i c m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.K1 i c a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P0T ds_s6P0U ds1_s6P0V]
        GHC.Base.mempty $dMonoid_s6P0T;

Data.Foldable.$fFoldable:+:_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P0W $dFoldable1_s6P0X ds_s6P0Y]
        case ds_s6P0Y of {
          GHC.Generics.L1 a1_s6P10 [Occ=Once] ->
              Data.Foldable.null $dFoldable_s6P0W a1_s6P10;
          GHC.Generics.R1 a1_s6P11 [Occ=Once] ->
              Data.Foldable.null $dFoldable1_s6P0X a1_s6P11;
        };

Data.Foldable.$fFoldable:+:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P12
           $dFoldable1_s6P13
           f1_s6P14
           z_s6P15
           ds_s6P16]
        case ds_s6P16 of {
          GHC.Generics.L1 a1_s6P18 [Occ=Once] ->
              Data.Foldable.foldr $dFoldable_s6P12 f1_s6P14 z_s6P15 a1_s6P18;
          GHC.Generics.R1 a1_s6P19 [Occ=Once] ->
              Data.Foldable.foldr $dFoldable1_s6P13 f1_s6P14 z_s6P15 a1_s6P19;
        };

Data.Foldable.$fFoldable:+:_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:+:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P1a
           $dFoldable1_s6P1b
           $dMonoid_s6P1c
           f1_s6P1d
           ds_s6P1e]
        case ds_s6P1e of {
          GHC.Generics.L1 a1_s6P1g [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_s6P1a $dMonoid_s6P1c f1_s6P1d a1_s6P1g;
          GHC.Generics.R1 a1_s6P1h [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_s6P1b $dMonoid_s6P1c f1_s6P1d a1_s6P1h;
        };

Data.Foldable.$fFoldable:*:_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(S)LLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P1i $dFoldable1_s6P1j ds_s6P1k]
        case ds_s6P1k of {
          GHC.Generics.:*: a1_s6P1m [Occ=Once] a2_s6P1n [Occ=Once] ->
              case Data.Foldable.null $dFoldable_s6P1i a1_s6P1m of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> Data.Foldable.null $dFoldable1_s6P1j a2_s6P1n;
              };
        };

Data.Foldable.$fFoldable:*:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P1p
           $dFoldable1_s6P1q
           f1_s6P1r
           z_s6P1s
           ds_s6P1t]
        case ds_s6P1t of {
          GHC.Generics.:*: a1_s6P1v [Occ=Once] a2_s6P1w [Occ=Once] ->
              let {
                sat_s6P1x [Occ=Once] :: b_a6L8t
                [LclId] =
                    [$dFoldable1_s6P1q f1_s6P1r z_s6P1s a2_s6P1w] \u []
                        Data.Foldable.foldr $dFoldable1_s6P1q f1_s6P1r z_s6P1s a2_s6P1w;
              } in 
                Data.Foldable.foldr $dFoldable_s6P1p f1_s6P1r sat_s6P1x a1_s6P1v;
        };

Data.Foldable.$w$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> f a -> g a -> m
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6P1y w1_s6P1z w2_s6P1A w3_s6P1B ww_s6P1C ww1_s6P1D]
        let {
          sat_s6P1F [Occ=Once] :: m_s6NSd
          [LclId] =
              [w1_s6P1z w2_s6P1A w3_s6P1B ww1_s6P1D] \u []
                  Data.Foldable.foldMap w1_s6P1z w2_s6P1A w3_s6P1B ww1_s6P1D; } in
        let {
          sat_s6P1E [Occ=Once] :: m_s6NSd
          [LclId] =
              [w_s6P1y w2_s6P1A w3_s6P1B ww_s6P1C] \u []
                  Data.Foldable.foldMap w_s6P1y w2_s6P1A w3_s6P1B ww_s6P1C;
        } in  GHC.Base.mappend w2_s6P1A sat_s6P1E sat_s6P1F;

Data.Foldable.$fFoldable:*:_$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:*:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6P1G w1_s6P1H w2_s6P1I w3_s6P1J w4_s6P1K]
        case w4_s6P1K of {
          GHC.Generics.:*: ww1_s6P1M [Occ=Once] ww2_s6P1N [Occ=Once] ->
              Data.Foldable.$w$cfoldMap
                  w_s6P1G w1_s6P1H w2_s6P1I w3_s6P1J ww1_s6P1M ww2_s6P1N;
        };

Data.Foldable.$fFoldable:.:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P1O
           $dFoldable1_s6P1P
           f1_s6P1Q
           z_s6P1R
           ds_s6P1S]
        let {
          sat_s6P1V [Occ=Once] :: g_a6L4V a_a6L5t -> b_a6L5u -> b_a6L5u
          [LclId] =
              [$dFoldable1_s6P1P f1_s6P1Q] \r [b1_s6P1T b2_s6P1U]
                  Data.Foldable.foldr $dFoldable1_s6P1P f1_s6P1Q b2_s6P1U b1_s6P1T;
        } in 
          Data.Foldable.foldr $dFoldable_s6P1O sat_s6P1V z_s6P1R ds_s6P1S;

Data.Foldable.$fFoldable:.:_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:.:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P1W
           $dFoldable1_s6P1X
           $dMonoid_s6P1Y
           f1_s6P1Z
           ds_s6P20]
        let {
          sat_s6P21 [Occ=Once] :: g_a6L4V a_a6L5c -> m_a6L5b
          [LclId] =
              [$dFoldable1_s6P1X $dMonoid_s6P1Y f1_s6P1Z] \u []
                  Data.Foldable.foldMap $dFoldable1_s6P1X $dMonoid_s6P1Y f1_s6P1Z;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6P1W $dMonoid_s6P1Y sat_s6P21 ds_s6P20;

Data.Foldable.$fFoldableURec4_$cnull
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P22]
        case ds_s6P22 of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec4_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P25 z_s6P26 ds_s6P27]
        case ds_s6P27 of { GHC.Generics.UAddr _ [Occ=Dead] -> z_s6P26; };

Data.Foldable.$fFoldableURec4_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P2a f_s6P2b ds_s6P2c]
        case ds_s6P2c of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P2a;
        };

Data.Foldable.$fFoldableURec3_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P2f]
        case ds_s6P2f of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec3_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Char a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P2i z_s6P2j ds_s6P2k]
        case ds_s6P2k of { GHC.Generics.UChar _ [Occ=Dead] -> z_s6P2j; };

Data.Foldable.$fFoldableURec3_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Char a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P2n f_s6P2o ds_s6P2p]
        case ds_s6P2p of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P2n;
        };

Data.Foldable.$fFoldableURec2_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P2s]
        case ds_s6P2s of {
          GHC.Generics.UDouble _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec2_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Double a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P2v z_s6P2w ds_s6P2x]
        case ds_s6P2x of { GHC.Generics.UDouble _ [Occ=Dead] -> z_s6P2w; };

Data.Foldable.$fFoldableURec2_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Double a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P2A f_s6P2B ds_s6P2C]
        case ds_s6P2C of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              GHC.Base.mempty $dMonoid_s6P2A;
        };

Data.Foldable.$fFoldableURec1_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P2F]
        case ds_s6P2F of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec1_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Float a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P2I z_s6P2J ds_s6P2K]
        case ds_s6P2K of { GHC.Generics.UFloat _ [Occ=Dead] -> z_s6P2J; };

Data.Foldable.$fFoldableURec1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Float a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P2N f_s6P2O ds_s6P2P]
        case ds_s6P2P of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P2N;
        };

Data.Foldable.$fFoldableURec0_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P2S]
        case ds_s6P2S of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec0_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Int a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P2V z_s6P2W ds_s6P2X]
        case ds_s6P2X of { GHC.Generics.UInt _ [Occ=Dead] -> z_s6P2W; };

Data.Foldable.$fFoldableURec0_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Int a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P30 f_s6P31 ds_s6P32]
        case ds_s6P32 of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P30;
        };

Data.Foldable.$fFoldableURec_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6P35]
        case ds_s6P35 of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Word a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P38 z_s6P39 ds_s6P3a]
        case ds_s6P3a of { GHC.Generics.UWord _ [Occ=Dead] -> z_s6P39; };

Data.Foldable.$fFoldableURec_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Word a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P3d f_s6P3e ds_s6P3f]
        case ds_s6P3f of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P3d;
        };

Data.Foldable.$fFoldable:*:1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6P3i] v_s6P3i;

$dmproduct1_r6OSR
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6P3j $dNum_s6P3k]
        let {
          sat_s6P3l [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6KPT)
          [LclId] =
              [$dNum_s6P3k] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6P3k;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6P3j sat_s6P3l Data.Foldable.$fFoldable:*:1;

Data.Foldable.$dmproduct
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] $dmproduct1_r6OSR eta_B2 eta_B1;

$dmsum1_r6OSS
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6P3m $dNum_s6P3n]
        let {
          sat_s6P3o [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6KPz)
          [LclId] =
              [$dNum_s6P3n] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6P3n;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6P3m sat_s6P3o Data.Foldable.$fFoldable:*:1;

Data.Foldable.$dmsum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] $dmsum1_r6OSS eta_B2 eta_B1;

Data.Foldable.$fFoldableK3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

poly_d_r6OST :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK3
        of
        sat_s6P3p
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6P3p;
        };

Data.Foldable.$dmminimum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3q $dOrd_s6P3r]
        let {
          g_s6P3s [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_X6Kii a_a6KOY -> Data.Functor.Utils.Min a_a6KOY
          [LclId] =
              [$dFoldable_s6P3q $dOrd_s6P3r] \u []
                  let {
                    sat_s6P3t [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6KOY)
                    [LclId] =
                        [$dOrd_s6P3r] \u [] Data.Functor.Utils.$fMonoidMin $dOrd_s6P3r;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6P3q sat_s6P3t GHC.Base.Just; } in
        let {
          sat_s6P3x [Occ=OnceT[0]] :: t_X6Kii a_a6KOY -> a_a6KOY
          [LclId] =
              [g_s6P3s] \r [x_s6P3u]
                  case g_s6P3s x_s6P3u of {
                    GHC.Base.Nothing -> poly_d_r6OST;
                    GHC.Base.Just v_s6P3w [Occ=Once] -> v_s6P3w;
                  };
        } in  sat_s6P3x;

Data.Foldable.$fFoldableK5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

poly_d1_r6OSU :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK5
        of
        sat_s6P3y
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6P3y;
        };

Data.Foldable.$dmmaximum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3z $dOrd_s6P3A]
        let {
          g_s6P3B [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_X6Kij a_a6KOn -> Data.Functor.Utils.Max a_a6KOn
          [LclId] =
              [$dFoldable_s6P3z $dOrd_s6P3A] \u []
                  let {
                    sat_s6P3C [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6KOn)
                    [LclId] =
                        [$dOrd_s6P3A] \u [] Data.Functor.Utils.$fMonoidMax $dOrd_s6P3A;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6P3z sat_s6P3C GHC.Base.Just; } in
        let {
          sat_s6P3G [Occ=OnceT[0]] :: t_X6Kij a_a6KOn -> a_a6KOn
          [LclId] =
              [g_s6P3B] \r [x_s6P3D]
                  case g_s6P3B x_s6P3D of {
                    GHC.Base.Nothing -> poly_d1_r6OSU;
                    GHC.Base.Just v_s6P3F [Occ=Once] -> v_s6P3F;
                  };
        } in  sat_s6P3G;

Data.Foldable.$fFoldable:*:5
  :: forall a. GHC.Types.Int -> a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,A>m,
 Unf=OtherCon []] =
    [] \r [c_s6P3H ds_s6P3I]
        case c_s6P3H of {
          GHC.Types.I# x_s6P3K [Occ=Once] ->
              case +# [x_s6P3K 1#] of sat_s6P3L {
                __DEFAULT -> GHC.Types.I# [sat_s6P3L];
              };
        };

Data.Foldable.$dmlength
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3M]
        Data.Foldable.foldl'
            $dFoldable_s6P3M
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4;

lvl_r6OSV :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s6P3N ds1_s6P3O] GHC.Types.False [];

Data.Foldable.$dmnull
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3P]
        Data.Foldable.foldr $dFoldable_s6P3P lvl_r6OSV GHC.Types.True;

Data.Foldable.$dmtoList [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3Q t1_s6P3R]
        Data.Foldable.foldr
            $dFoldable_s6P3Q GHC.Types.: GHC.Types.[] t1_s6P3R;

Data.Foldable.$fFoldableK7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Foldable.$fFoldable:*:6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK7
        of
        sat_s6P3S
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6P3S;
        };

Data.Foldable.$dmfoldl1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId,
 Arity=3,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P3T f_s6P3U xs_s6P3V]
        let {
          sat_s6P41 [Occ=Once]
            :: GHC.Base.Maybe a_a6KN3 -> a_a6KN3 -> GHC.Base.Maybe a_a6KN3
          [LclId] =
              [f_s6P3U] \r [m_s6P3W y_s6P3X]
                  let {
                    sat_s6P40 [Occ=Once] :: a_a6KN3
                    [LclId] =
                        [f_s6P3U m_s6P3W y_s6P3X] \u []
                            case m_s6P3W of {
                              GHC.Base.Nothing -> y_s6P3X;
                              GHC.Base.Just x_s6P3Z [Occ=Once] -> f_s6P3U x_s6P3Z y_s6P3X;
                            };
                  } in  GHC.Base.Just [sat_s6P40];
        } in 
          case
              Data.Foldable.foldl
                  $dFoldable_s6P3T sat_s6P41 GHC.Base.Nothing xs_s6P3V
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6P43 [Occ=Once] -> v_s6P43;
          };

Data.Foldable.$fFoldableK9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Foldable.$fFoldable:*:8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK9
        of
        sat_s6P44
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6P44;
        };

Data.Foldable.$dmfoldr1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P45 f_s6P46 xs_s6P47]
        let {
          sat_s6P4d [Occ=Once]
            :: a_a6KMx -> GHC.Base.Maybe a_a6KMx -> GHC.Base.Maybe a_a6KMx
          [LclId] =
              [f_s6P46] \r [x_s6P48 m_s6P49]
                  let {
                    sat_s6P4c [Occ=Once] :: a_a6KMx
                    [LclId] =
                        [f_s6P46 x_s6P48 m_s6P49] \u []
                            case m_s6P49 of {
                              GHC.Base.Nothing -> x_s6P48;
                              GHC.Base.Just y_s6P4b [Occ=Once] -> f_s6P46 x_s6P48 y_s6P4b;
                            };
                  } in  GHC.Base.Just [sat_s6P4c];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6P45 sat_s6P4d GHC.Base.Nothing xs_s6P47
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6P4f [Occ=Once] -> v_s6P4f;
          };

Data.Foldable.$dmfoldl'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P4g f_s6P4h z0_s6P4i xs_s6P4j]
        let {
          sat_s6P4o [Occ=Once]
            :: a_a6KM0 -> (b_a6KLZ -> b_a6KLZ) -> b_a6KLZ -> b_a6KLZ
          [LclId] =
              [f_s6P4h] \r [x_s6P4k k_s6P4l z_s6P4m]
                  case f_s6P4h z_s6P4m x_s6P4k of vx_s6P4n {
                    __DEFAULT -> k_s6P4l vx_s6P4n;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6P4g sat_s6P4o GHC.Base.id xs_s6P4j z0_s6P4i;

Data.Foldable.$fFoldable:*:7
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$dmfoldl
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P4p f_s6P4q z_s6P4r t1_s6P4s]
        let {
          sat_s6P4v [Occ=Once]
            :: a_a6KLz
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6KLy)
          [LclId] =
              [f_s6P4q] \r [x_s6P4t y_s6P4u] f_s6P4q y_s6P4u x_s6P4t;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6P4p
              Data.Foldable.$fFoldable:*:7
              sat_s6P4v
              t1_s6P4s
              z_s6P4r;

Data.Foldable.$dmfoldr'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P4w f_s6P4x z0_s6P4y xs_s6P4z]
        let {
          sat_s6P4E [Occ=Once]
            :: (b_a6KKX -> b_a6KKX) -> a_a6KKW -> b_a6KKX -> b_a6KKX
          [LclId] =
              [f_s6P4x] \r [k_s6P4A x_s6P4B z_s6P4C]
                  case f_s6P4x x_s6P4B z_s6P4C of vx_s6P4D {
                    __DEFAULT -> k_s6P4A vx_s6P4D;
                  };
        } in 
          Data.Foldable.foldl
              $dFoldable_s6P4w sat_s6P4E GHC.Base.id xs_s6P4z z0_s6P4y;

Data.Foldable.$fFoldableU1_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6P4F z0_s6P4G xs_s6P4H] z0_s6P4G;

Data.Foldable.$fFoldableK4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK5;

Data.Foldable.$fFoldableU1_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P4I eta_s6P4J]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableU1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6P4K z0_s6P4L xs_s6P4M] z0_s6P4L;

Data.Foldable.$fFoldableK2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK3;

Data.Foldable.$fFoldableU1_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P4N eta_s6P4O]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableU1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.U1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6P4P] [] [];

Data.Foldable.$fFoldableU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.U1
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableU1_$cfold
                                             Data.Foldable.$fFoldableU1_$cfoldMap
                                             Data.Foldable.$fFoldableU1_$cfoldr
                                             Data.Foldable.$fFoldableU1_$cfoldr'
                                             Data.Foldable.$fFoldableU1_$cfoldl
                                             Data.Foldable.$fFoldableU1_$cfoldl'
                                             Data.Foldable.$fFoldableU1_$cfoldr1
                                             Data.Foldable.$fFoldableU1_$cfoldl1
                                             Data.Foldable.$fFoldableU1_$ctoList
                                             Data.Foldable.$fFoldableU1_$cnull
                                             Data.Foldable.$fFoldableU1_$clength
                                             Data.Foldable.$fFoldableU1_$celem
                                             Data.Foldable.$fFoldableU1_$cmaximum
                                             Data.Foldable.$fFoldableU1_$cminimum
                                             Data.Foldable.$fFoldableU1_$csum
                                             Data.Foldable.$fFoldableU1_$cproduct];

Data.Foldable.$fFoldableProxy_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6P4Q z0_s6P4R xs_s6P4S] z0_s6P4R;

Data.Foldable.$fFoldableProxy_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P4T eta_s6P4U]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableProxy_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6P4V z0_s6P4W xs_s6P4X] z0_s6P4W;

Data.Foldable.$fFoldableProxy_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P4Y eta_s6P4Z]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableProxy_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Proxy.Proxy a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6P50] [] [];

Data.Foldable.$fFoldableProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Proxy.Proxy
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableProxy_$cfold
                                             Data.Foldable.$fFoldableProxy_$cfoldMap
                                             Data.Foldable.$fFoldableProxy_$cfoldr
                                             Data.Foldable.$fFoldableProxy_$cfoldr'
                                             Data.Foldable.$fFoldableProxy_$cfoldl
                                             Data.Foldable.$fFoldableProxy_$cfoldl'
                                             Data.Foldable.$fFoldableProxy_$cfoldr1
                                             Data.Foldable.$fFoldableProxy_$cfoldl1
                                             Data.Foldable.$fFoldableProxy_$ctoList
                                             Data.Foldable.$fFoldableProxy_$cnull
                                             Data.Foldable.$fFoldableProxy_$clength
                                             Data.Foldable.$fFoldableProxy_$celem
                                             Data.Foldable.$fFoldableProxy_$cmaximum
                                             Data.Foldable.$fFoldableProxy_$cminimum
                                             Data.Foldable.$fFoldableProxy_$csum
                                             Data.Foldable.$fFoldableProxy_$cproduct];

Data.Foldable.$dmfoldr
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P51 f_s6P52 z_s6P53 t1_s6P54]
        Data.Foldable.foldMap
            $dFoldable_s6P51
            Data.Semigroup.Internal.$fMonoidEndo
            f_s6P52
            t1_s6P54
            z_s6P53;

Data.Foldable.$dmfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*U,C(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P55 $dMonoid_s6P56 f_s6P57]
        let {
          sat_s6P5b [Occ=Once] :: m_a6KKk
          [LclId] =
              [$dMonoid_s6P56] \u [] GHC.Base.mempty $dMonoid_s6P56; } in
        let {
          sat_s6P5a [Occ=Once] :: a_a6KKl -> m_a6KKk -> m_a6KKk
          [LclId] =
              [$dMonoid_s6P56 f_s6P57] \r [x_s6P58]
                  let {
                    sat_s6P59 [Occ=Once] :: m_a6KKk
                    [LclId] =
                        [f_s6P57 x_s6P58] \u [] f_s6P57 x_s6P58;
                  } in  GHC.Base.mappend $dMonoid_s6P56 sat_s6P59;
        } in  Data.Foldable.foldr $dFoldable_s6P55 sat_s6P5a sat_s6P5b;

Data.Foldable.$dmfold
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m. GHC.Base.Monoid m => t m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P5c $dMonoid_s6P5d]
        Data.Foldable.foldMap $dFoldable_s6P5c $dMonoid_s6P5d GHC.Base.id;

Data.Foldable.$fFoldableDual7
  :: forall m. GHC.Base.Monoid m => m -> m
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dMonoid_s6P5e eta_B1] GHC.Base.id eta_B1;

Data.Foldable.$fFoldableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Product
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableProduct_$cfoldr
                                             Data.Foldable.$fFoldableProduct_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableProduct3
                                             Data.Foldable.$fFoldableProduct3
                                             Data.Foldable.$fFoldableProduct_$ctoList
                                             Data.Foldable.$fFoldableProduct_$cnull
                                             Data.Foldable.$fFoldableProduct_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableProduct2
                                             Data.Foldable.$fFoldableProduct2
                                             Data.Foldable.$fFoldableProduct1
                                             Data.Foldable.$fFoldableProduct1];

Data.Foldable.$fFoldableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Sum
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableSum_$cfoldr
                                             Data.Foldable.$fFoldableSum_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableSum3
                                             Data.Foldable.$fFoldableSum3
                                             Data.Foldable.$fFoldableSum_$ctoList
                                             Data.Foldable.$fFoldableSum_$cnull
                                             Data.Foldable.$fFoldableSum_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableSum2
                                             Data.Foldable.$fFoldableSum2
                                             Data.Foldable.$fFoldableSum1
                                             Data.Foldable.$fFoldableSum1];

Data.Foldable.$fFoldableDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Dual
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableDual_$cfoldr
                                             Data.Foldable.$fFoldableDual_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual4
                                             Data.Foldable.$fFoldableDual4
                                             Data.Foldable.$fFoldableDual_$ctoList
                                             Data.Foldable.$fFoldableDual_$cnull
                                             Data.Foldable.$fFoldableDual_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableDual2
                                             Data.Foldable.$fFoldableDual2
                                             Data.Foldable.$fFoldableDual1
                                             Data.Foldable.$fFoldableDual1];

Data.Foldable.$fFoldable[]_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6P5f z0_s6P5g xs_s6P5h]
        let-no-escape {
          go_s6P5i [Occ=LoopBreakerT[3]]
            :: [a_a6LRy] -> (b_a6LRz -> b_a6LRz) -> b_a6LRz -> b_a6LRz
          [LclId[JoinId(3)],
           Arity=3,
           Str=<S,1*U><C(S),1*C1(U)><L,U>,
           Unf=OtherCon []] =
              sat-only [f_s6P5f go_s6P5i] \r [ds_s6P5j eta_s6P5k eta1_s6P5l]
                  case ds_s6P5j of {
                    [] -> eta_s6P5k eta1_s6P5l;
                    : y_s6P5n [Occ=Once] ys_s6P5o [Occ=Once] ->
                        let {
                          sat_s6P5r [Occ=Once] :: b_a6LRz -> b_a6LRz
                          [LclId] =
                              [f_s6P5f eta_s6P5k y_s6P5n] \r [z_s6P5p]
                                  case f_s6P5f y_s6P5n z_s6P5p of vx_s6P5q {
                                    __DEFAULT -> eta_s6P5k vx_s6P5q;
                                  };
                        } in  go_s6P5i ys_s6P5o sat_s6P5r eta1_s6P5l;
                  };
        } in  go_s6P5i xs_s6P5h GHC.Base.id z0_s6P5g;

Data.Foldable.$fFoldable[]_$cfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> [a] -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P5s f_s6P5t eta_s6P5u]
        let {
          z_s6P5v [Occ=OnceL] :: m_a6LRe
          [LclId] =
              [$dMonoid_s6P5s] \u [] GHC.Base.mempty $dMonoid_s6P5s; } in
        let {
          go_s6P5w [Occ=LoopBreaker] :: [a_a6LRf] -> m_a6LRe
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_s6P5s f_s6P5t z_s6P5v go_s6P5w] \r [ds_s6P5x]
                  case ds_s6P5x of {
                    [] -> z_s6P5v;
                    : y_s6P5z [Occ=Once] ys_s6P5A [Occ=Once] ->
                        let {
                          sat_s6P5C [Occ=Once] :: m_a6LRe
                          [LclId] =
                              [go_s6P5w ys_s6P5A] \u [] go_s6P5w ys_s6P5A; } in
                        let {
                          sat_s6P5B [Occ=Once] :: m_a6LRe
                          [LclId] =
                              [f_s6P5t y_s6P5z] \u [] f_s6P5t y_s6P5z;
                        } in  GHC.Base.mappend $dMonoid_s6P5s sat_s6P5B sat_s6P5C;
                  };
        } in  go_s6P5w eta_s6P5u;

Data.Foldable.$fFoldableNonEmpty_$cfold1
  :: forall m. GHC.Base.Monoid m => [m] -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P5D eta_s6P5E]
        let {
          z_s6P5F [Occ=OnceL] :: m_a6LR4
          [LclId] =
              [$dMonoid_s6P5D] \u [] GHC.Base.mempty $dMonoid_s6P5D; } in
        let {
          go_s6P5G [Occ=LoopBreaker] :: [m_a6LR4] -> m_a6LR4
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_s6P5D z_s6P5F go_s6P5G] \r [ds_s6P5H]
                  case ds_s6P5H of {
                    [] -> z_s6P5F;
                    : y_s6P5J [Occ=Once] ys_s6P5K [Occ=Once] ->
                        let {
                          sat_s6P5L [Occ=Once] :: m_a6LR4
                          [LclId] =
                              [go_s6P5G ys_s6P5K] \u [] go_s6P5G ys_s6P5K;
                        } in  GHC.Base.mappend $dMonoid_s6P5D y_s6P5J sat_s6P5L;
                  };
        } in  go_s6P5G eta_s6P5E;

Data.Foldable.$fFoldable[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable []
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold1
                                             Data.Foldable.$fFoldable[]_$cfoldMap
                                             GHC.Base.foldr
                                             Data.Foldable.$fFoldable[]_$cfoldr'
                                             GHC.List.foldl
                                             GHC.List.foldl'
                                             GHC.List.foldr1
                                             GHC.List.foldl1
                                             GHC.Base.id
                                             GHC.List.null
                                             GHC.List.length
                                             GHC.List.elem
                                             GHC.List.maximum
                                             GHC.List.minimum
                                             GHC.List.sum
                                             GHC.List.product];

Data.Foldable.$fFoldableNonEmpty_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Base.NonEmpty m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),U(A,U,C(C1(U)),A)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P5M ds_s6P5N]
        let {
          sat_s6P5V [Occ=Once] :: m_a6LOt
          [LclId] =
              [$dMonoid_s6P5M ds_s6P5N] \u []
                  case ds_s6P5N of {
                    GHC.Base.:| _ [Occ=Dead] ms_s6P5U [Occ=Once] ->
                        Data.Foldable.$fFoldableNonEmpty_$cfold1 $dMonoid_s6P5M ms_s6P5U;
                  }; } in
        let {
          sat_s6P5R [Occ=Once] :: m_a6LOt
          [LclId] =
              [ds_s6P5N] \u []
                  case ds_s6P5N of {
                    GHC.Base.:| m1_s6P5P [Occ=Once] _ [Occ=Dead] -> m1_s6P5P;
                  };
        } in  GHC.Base.mappend $dMonoid_s6P5M sat_s6P5R sat_s6P5V;

Data.Foldable.$fFoldableNonEmpty_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Base.NonEmpty a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),U(A,1*U,C(C1(U)),A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P5W f_s6P5X ds_s6P5Y]
        let {
          sat_s6P6f [Occ=Once] :: m_a6LOG
          [LclId] =
              [$dMonoid_s6P5W f_s6P5X ds_s6P5Y] \u []
                  case ds_s6P5Y of {
                    GHC.Base.:| _ [Occ=Dead] as_s6P66 [Occ=Once] ->
                        let {
                          z_s6P67 [Occ=OnceL] :: m_a6LOG
                          [LclId] =
                              [$dMonoid_s6P5W] \u [] GHC.Base.mempty $dMonoid_s6P5W; } in
                        let {
                          go_s6P68 [Occ=LoopBreaker] :: [a_a6LOH] -> m_a6LOG
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dMonoid_s6P5W f_s6P5X z_s6P67 go_s6P68] \r [ds1_s6P69]
                                  case ds1_s6P69 of {
                                    [] -> z_s6P67;
                                    : y_s6P6b [Occ=Once] ys_s6P6c [Occ=Once] ->
                                        let {
                                          sat_s6P6e [Occ=Once] :: m_a6LOG
                                          [LclId] =
                                              [go_s6P68 ys_s6P6c] \u [] go_s6P68 ys_s6P6c; } in
                                        let {
                                          sat_s6P6d [Occ=Once] :: m_a6LOG
                                          [LclId] =
                                              [f_s6P5X y_s6P6b] \u [] f_s6P5X y_s6P6b;
                                        } in  GHC.Base.mappend $dMonoid_s6P5W sat_s6P6d sat_s6P6e;
                                  };
                        } in  go_s6P68 as_s6P66;
                  }; } in
        let {
          sat_s6P63 [Occ=Once] :: m_a6LOG
          [LclId] =
              [f_s6P5X ds_s6P5Y] \u []
                  let {
                    sat_s6P62 [Occ=Once] :: a_a6LOH
                    [LclId] =
                        [ds_s6P5Y] \u []
                            case ds_s6P5Y of {
                              GHC.Base.:| a1_s6P60 [Occ=Once] _ [Occ=Dead] -> a1_s6P60;
                            };
                  } in  f_s6P5X sat_s6P62;
        } in  GHC.Base.mappend $dMonoid_s6P5W sat_s6P63 sat_s6P6f;

Data.Foldable.foldrM
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (a -> b -> m b) -> b -> t a -> m b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6g $dMonad_s6P6h f_s6P6i z0_s6P6j xs_s6P6k]
        let {
          sat_s6P6q [Occ=Once] :: b_a6KJt -> m_a6KJr b_a6KJt
          [LclId] =
              [$dMonad_s6P6h] \u [] GHC.Base.return $dMonad_s6P6h; } in
        let {
          sat_s6P6p [Occ=Once]
            :: (b_a6KJt -> m_a6KJr b_a6KJt)
               -> a_a6KJs -> b_a6KJt -> m_a6KJr b_a6KJt
          [LclId] =
              [$dMonad_s6P6h f_s6P6i] \r [k_s6P6l x_s6P6m z_s6P6n]
                  let {
                    sat_s6P6o [Occ=Once] :: m_a6KJr b_a6KJt
                    [LclId] =
                        [f_s6P6i x_s6P6m z_s6P6n] \u [] f_s6P6i x_s6P6m z_s6P6n;
                  } in  GHC.Base.>>= $dMonad_s6P6h sat_s6P6o k_s6P6l;
        } in 
          Data.Foldable.foldl
              $dFoldable_s6P6g sat_s6P6p sat_s6P6q xs_s6P6k z0_s6P6j;

Data.Foldable.foldlM
  :: forall (t :: * -> *) (m :: * -> *) b a.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (b -> a -> m b) -> b -> t a -> m b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6r $dMonad_s6P6s f_s6P6t z0_s6P6u xs_s6P6v]
        let {
          sat_s6P6B [Occ=Once] :: b_a6KHt -> m_a6KHs b_a6KHt
          [LclId] =
              [$dMonad_s6P6s] \u [] GHC.Base.return $dMonad_s6P6s; } in
        let {
          sat_s6P6A [Occ=Once]
            :: a_a6KHu
               -> (b_a6KHt -> m_a6KHs b_a6KHt) -> b_a6KHt -> m_a6KHs b_a6KHt
          [LclId] =
              [$dMonad_s6P6s f_s6P6t] \r [x_s6P6w k_s6P6x z_s6P6y]
                  let {
                    sat_s6P6z [Occ=Once] :: m_a6KHs b_a6KHt
                    [LclId] =
                        [f_s6P6t x_s6P6w z_s6P6y] \u [] f_s6P6t z_s6P6y x_s6P6w;
                  } in  GHC.Base.>>= $dMonad_s6P6s sat_s6P6z k_s6P6x;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6P6r sat_s6P6A sat_s6P6B xs_s6P6v z0_s6P6u;

Data.Foldable.traverse_
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     (a -> f b) -> t a -> f ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6C $dApplicative_s6P6D f1_s6P6E]
        let {
          sat_s6P6I [Occ=Once] :: f_a6KGP ()
          [LclId] =
              [$dApplicative_s6P6D] \u []
                  GHC.Base.pure $dApplicative_s6P6D GHC.Tuple.(); } in
        let {
          sat_s6P6H [Occ=Once] :: a_a6KGQ -> f_a6KGP () -> f_a6KGP ()
          [LclId] =
              [$dApplicative_s6P6D f1_s6P6E] \r [x_s6P6F]
                  let {
                    sat_s6P6G [Occ=Once] :: f_a6KGP b_a6KGR
                    [LclId] =
                        [f1_s6P6E x_s6P6F] \u [] f1_s6P6E x_s6P6F;
                  } in  GHC.Base.*> $dApplicative_s6P6D sat_s6P6G;
        } in  Data.Foldable.foldr $dFoldable_s6P6C sat_s6P6H sat_s6P6I;

Data.Foldable.for_ [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     t a -> (a -> f b) -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6J $dApplicative_s6P6K x_s6P6L y_s6P6M]
        Data.Foldable.traverse_
            $dFoldable_s6P6J $dApplicative_s6P6K y_s6P6M x_s6P6L;

Data.Foldable.mapM_
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (a -> m b) -> t a -> m ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(U),1*C1(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6N $dMonad_s6P6O f_s6P6P]
        let {
          sat_s6P6T [Occ=Once] :: m_a6KG8 ()
          [LclId] =
              [$dMonad_s6P6O] \u []
                  GHC.Base.return $dMonad_s6P6O GHC.Tuple.(); } in
        let {
          sat_s6P6S [Occ=Once] :: a_a6KG9 -> m_a6KG8 () -> m_a6KG8 ()
          [LclId] =
              [$dMonad_s6P6O f_s6P6P] \r [x_s6P6Q]
                  let {
                    sat_s6P6R [Occ=Once] :: m_a6KG8 b_a6KGa
                    [LclId] =
                        [f_s6P6P x_s6P6Q] \u [] f_s6P6P x_s6P6Q;
                  } in  GHC.Base.>> $dMonad_s6P6O sat_s6P6R;
        } in  Data.Foldable.foldr $dFoldable_s6P6N sat_s6P6S sat_s6P6T;

Data.Foldable.forM_ [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     t a -> (a -> m b) -> m ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(U),C(U),A)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6U $dMonad_s6P6V x_s6P6W y_s6P6X]
        Data.Foldable.mapM_ $dFoldable_s6P6U $dMonad_s6P6V y_s6P6X x_s6P6W;

Data.Foldable.sequenceA_
  :: forall (t :: * -> *) (f :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     t (f a) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(U),A,A,1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P6Y $dApplicative_s6P6Z]
        let {
          sat_s6P71 [Occ=Once] :: f_a6KFQ ()
          [LclId] =
              [$dApplicative_s6P6Z] \u []
                  GHC.Base.pure $dApplicative_s6P6Z GHC.Tuple.(); } in
        let {
          sat_s6P70 [Occ=Once] :: f_a6KFQ a_a6KFR -> f_a6KFQ () -> f_a6KFQ ()
          [LclId] =
              [$dApplicative_s6P6Z] \u [] GHC.Base.*> $dApplicative_s6P6Z;
        } in  Data.Foldable.foldr $dFoldable_s6P6Y sat_s6P70 sat_s6P71;

Data.Foldable.sequence_
  :: forall (t :: * -> *) (m :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     t (m a) -> m ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,1*U,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P72 $dMonad_s6P73]
        let {
          sat_s6P75 [Occ=Once] :: m_a6KFy ()
          [LclId] =
              [$dMonad_s6P73] \u []
                  GHC.Base.return $dMonad_s6P73 GHC.Tuple.(); } in
        let {
          sat_s6P74 [Occ=Once] :: m_a6KFy a_a6KFz -> m_a6KFy () -> m_a6KFy ()
          [LclId] =
              [$dMonad_s6P73] \u [] GHC.Base.>> $dMonad_s6P73;
        } in  Data.Foldable.foldr $dFoldable_s6P72 sat_s6P74 sat_s6P75;

Data.Foldable.asum [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Alternative f) =>
     t (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P76 $dAlternative_s6P77]
        let {
          sat_s6P79 [Occ=Once] :: f_a6KF3 a_a6KF4
          [LclId] =
              [$dAlternative_s6P77] \u []
                  GHC.Base.empty $dAlternative_s6P77; } in
        let {
          sat_s6P78 [Occ=Once]
            :: f_a6KF3 a_a6KF4 -> f_a6KF3 a_a6KF4 -> f_a6KF3 a_a6KF4
          [LclId] =
              [$dAlternative_s6P77] \u [] GHC.Base.<|> $dAlternative_s6P77;
        } in  Data.Foldable.foldr $dFoldable_s6P76 sat_s6P78 sat_s6P79;

Data.Foldable.msum [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.MonadPlus m) =>
     t (m a) -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*U(A,1*U,1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7a $dMonadPlus_s6P7b]
        let {
          $dAlternative_s6P7c [Dmd=<L,U(A,1*U,1*U,A,A)>]
            :: GHC.Base.Alternative m_a6KFm
          [LclId] =
              [$dMonadPlus_s6P7b] \u []
                  GHC.Base.$p1MonadPlus $dMonadPlus_s6P7b; } in
        let {
          sat_s6P7e [Occ=Once] :: m_a6KFm a_a6KFn
          [LclId] =
              [$dAlternative_s6P7c] \u []
                  GHC.Base.empty $dAlternative_s6P7c; } in
        let {
          sat_s6P7d [Occ=Once]
            :: m_a6KFm a_a6KFn -> m_a6KFm a_a6KFn -> m_a6KFm a_a6KFn
          [LclId] =
              [$dAlternative_s6P7c] \u [] GHC.Base.<|> $dAlternative_s6P7c;
        } in  Data.Foldable.foldr $dFoldable_s6P7a sat_s6P7d sat_s6P7e;

Data.Foldable.concat [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *) a. Data.Foldable.Foldable t => t [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7f xs_s6P7g]
        Data.Foldable.foldr
            $dFoldable_s6P7f GHC.Base.++ GHC.Types.[] xs_s6P7g;

Data.Foldable.concatMap [InlPrag=INLINE (sat-args=2)]
  :: forall (t :: * -> *) a b.
     Data.Foldable.Foldable t =>
     (a -> [b]) -> t a -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7h f_s6P7i xs_s6P7j]
        let {
          sat_s6P7n [Occ=Once] :: a_a6KEs -> [b_a6KEt] -> [b_a6KEt]
          [LclId] =
              [f_s6P7i] \r [x_s6P7k b1_s6P7l]
                  case f_s6P7i x_s6P7k of sat_s6P7m {
                    __DEFAULT -> GHC.Base.++ sat_s6P7m b1_s6P7l;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6P7h sat_s6P7n GHC.Types.[] xs_s6P7j;

Data.Foldable.and2 :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6P7o] v_s6P7o;

Data.Foldable.and1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7p]
        Data.Foldable.foldMap
            $dFoldable_s6P7p
            Data.Semigroup.Internal.$fMonoidAll
            Data.Foldable.and2;

Data.Foldable.and
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Foldable.and1 eta_B1;

Data.Foldable.or1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7q]
        Data.Foldable.foldMap
            $dFoldable_s6P7q
            Data.Semigroup.Internal.$fMonoidAny
            Data.Foldable.and2;

Data.Foldable.or
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Foldable.or1 eta_B1;

Data.Foldable.any1
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6P7r p_s6P7s]
        Data.Foldable.foldMap
            $dFoldable_s6P7r Data.Semigroup.Internal.$fMonoidAny p_s6P7s;

Data.Foldable.any
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Foldable.any1 eta_B2 eta_B1;

$dmelem1_r6OSW
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a.
     GHC.Classes.Eq a =>
     a -> t a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6P7t $dEq_s6P7u eta_s6P7v]
        let {
          sat_s6P7w [Occ=Once] :: a_a6KO9 -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_s6P7u eta_s6P7v] \u [] GHC.Classes.== $dEq_s6P7u eta_s6P7v;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6P7t Data.Semigroup.Internal.$fMonoidAny sat_s6P7w;

Data.Foldable.$dmelem
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $dmelem1_r6OSW eta_B3 eta_B2 eta_B1;

Data.Foldable.$fFoldableURec11
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Word a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P7x eta_s6P7y eta1_s6P7z]
        case eta1_s6P7z of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec8
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Word a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P7C ds_s6P7D]
        case ds_s6P7D of {
          GHC.Generics.UWord _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6P7C;
        };

Data.Foldable.$fFoldable:*:2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableURec9
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P7G] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P7H eta_s6P7I]
        Data.Foldable.$fFoldableURec9 eta_s6P7I;

Data.Foldable.$fFoldable:*:3 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableURec10
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P7J] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P7K eta_s6P7L]
        Data.Foldable.$fFoldableURec10 eta_s6P7L;

Data.Foldable.$fFoldableURec_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P7M xs_s6P7N] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Word a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P7O z0_s6P7P xs_s6P7Q]
        case xs_s6P7Q of { GHC.Generics.UWord _ [Occ=Dead] -> z0_s6P7P; };

Data.Foldable.$fFoldableURec_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6P7T]
        case xs_s6P7T of {
          GHC.Generics.UWord _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P7W xs_s6P7X] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Word m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P7Y ds_s6P7Z]
        case ds_s6P7Z of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P7Y;
        };

Data.Foldable.$fFoldableURec7
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Word a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P82 ds_s6P83]
        case ds_s6P83 of {
          GHC.Generics.UWord _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6P82;
        };

Data.Foldable.$fFoldableURec_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6P86]
        case eta_s6P86 of { GHC.Generics.UWord _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Word)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec_$cfold
                                             Data.Foldable.$fFoldableURec_$cfoldMap
                                             Data.Foldable.$fFoldableURec_$cfoldr
                                             Data.Foldable.$fFoldableURec_$cfoldr
                                             Data.Foldable.$fFoldableURec_$cfoldl'
                                             Data.Foldable.$fFoldableURec_$cfoldl'
                                             Data.Foldable.$fFoldableURec_$cfoldr1
                                             Data.Foldable.$fFoldableURec_$cfoldl1
                                             Data.Foldable.$fFoldableURec_$ctoList
                                             Data.Foldable.$fFoldableURec_$cnull
                                             Data.Foldable.$fFoldableURec_$clength
                                             Data.Foldable.$fFoldableURec11
                                             Data.Foldable.$fFoldableURec_$cmaximum
                                             Data.Foldable.$fFoldableURec_$cminimum
                                             Data.Foldable.$fFoldableURec8
                                             Data.Foldable.$fFoldableURec7];

Data.Foldable.$fFoldableURec16
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Int a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P89 eta_s6P8a eta1_s6P8b]
        case eta1_s6P8b of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec13
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Int a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P8e ds_s6P8f]
        case ds_s6P8f of {
          GHC.Generics.UInt _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6P8e;
        };

Data.Foldable.$fFoldableURec14
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P8i] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec0_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P8j eta_s6P8k]
        Data.Foldable.$fFoldableURec14 eta_s6P8k;

Data.Foldable.$fFoldableURec15
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P8l] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec0_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P8m eta_s6P8n]
        Data.Foldable.$fFoldableURec15 eta_s6P8n;

Data.Foldable.$fFoldableURec0_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P8o xs_s6P8p] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec0_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Int a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P8q z0_s6P8r xs_s6P8s]
        case xs_s6P8s of { GHC.Generics.UInt _ [Occ=Dead] -> z0_s6P8r; };

Data.Foldable.$fFoldableURec0_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6P8v]
        case xs_s6P8v of {
          GHC.Generics.UInt _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec0_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P8y xs_s6P8z] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec0_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Int m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P8A ds_s6P8B]
        case ds_s6P8B of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P8A;
        };

Data.Foldable.$fFoldableURec12
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Int a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P8E ds_s6P8F]
        case ds_s6P8F of {
          GHC.Generics.UInt _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6P8E;
        };

Data.Foldable.$fFoldableURec0_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6P8I]
        case eta_s6P8I of { GHC.Generics.UInt _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec0 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Int)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec0_$cfold
                                             Data.Foldable.$fFoldableURec0_$cfoldMap
                                             Data.Foldable.$fFoldableURec0_$cfoldr
                                             Data.Foldable.$fFoldableURec0_$cfoldr
                                             Data.Foldable.$fFoldableURec0_$cfoldl'
                                             Data.Foldable.$fFoldableURec0_$cfoldl'
                                             Data.Foldable.$fFoldableURec0_$cfoldr1
                                             Data.Foldable.$fFoldableURec0_$cfoldl1
                                             Data.Foldable.$fFoldableURec0_$ctoList
                                             Data.Foldable.$fFoldableURec0_$cnull
                                             Data.Foldable.$fFoldableURec0_$clength
                                             Data.Foldable.$fFoldableURec16
                                             Data.Foldable.$fFoldableURec0_$cmaximum
                                             Data.Foldable.$fFoldableURec0_$cminimum
                                             Data.Foldable.$fFoldableURec13
                                             Data.Foldable.$fFoldableURec12];

Data.Foldable.$fFoldableURec21
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P8L eta_s6P8M eta1_s6P8N]
        case eta1_s6P8N of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec18
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P8Q ds_s6P8R]
        case ds_s6P8R of {
          GHC.Generics.UFloat _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6P8Q;
        };

Data.Foldable.$fFoldableURec19
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P8U] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec1_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P8V eta_s6P8W]
        Data.Foldable.$fFoldableURec19 eta_s6P8W;

Data.Foldable.$fFoldableURec20
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P8X] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec1_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P8Y eta_s6P8Z]
        Data.Foldable.$fFoldableURec20 eta_s6P8Z;

Data.Foldable.$fFoldableURec1_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P90 xs_s6P91] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec1_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Float a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P92 z0_s6P93 xs_s6P94]
        case xs_s6P94 of { GHC.Generics.UFloat _ [Occ=Dead] -> z0_s6P93; };

Data.Foldable.$fFoldableURec1_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6P97]
        case xs_s6P97 of {
          GHC.Generics.UFloat _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec1_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P9a xs_s6P9b] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec1_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Float m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P9c ds_s6P9d]
        case ds_s6P9d of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6P9c;
        };

Data.Foldable.$fFoldableURec17
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P9g ds_s6P9h]
        case ds_s6P9h of {
          GHC.Generics.UFloat _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6P9g;
        };

Data.Foldable.$fFoldableURec1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6P9k]
        case eta_s6P9k of { GHC.Generics.UFloat _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Float)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec1_$cfold
                                             Data.Foldable.$fFoldableURec1_$cfoldMap
                                             Data.Foldable.$fFoldableURec1_$cfoldr
                                             Data.Foldable.$fFoldableURec1_$cfoldr
                                             Data.Foldable.$fFoldableURec1_$cfoldl'
                                             Data.Foldable.$fFoldableURec1_$cfoldl'
                                             Data.Foldable.$fFoldableURec1_$cfoldr1
                                             Data.Foldable.$fFoldableURec1_$cfoldl1
                                             Data.Foldable.$fFoldableURec1_$ctoList
                                             Data.Foldable.$fFoldableURec1_$cnull
                                             Data.Foldable.$fFoldableURec1_$clength
                                             Data.Foldable.$fFoldableURec21
                                             Data.Foldable.$fFoldableURec1_$cmaximum
                                             Data.Foldable.$fFoldableURec1_$cminimum
                                             Data.Foldable.$fFoldableURec18
                                             Data.Foldable.$fFoldableURec17];

Data.Foldable.$fFoldableURec26
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P9n eta_s6P9o eta1_s6P9p]
        case eta1_s6P9p of {
          GHC.Generics.UDouble _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec23
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P9s ds_s6P9t]
        case ds_s6P9t of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6P9s;
        };

Data.Foldable.$fFoldableURec24
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P9w] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec2_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P9x eta_s6P9y]
        Data.Foldable.$fFoldableURec24 eta_s6P9y;

Data.Foldable.$fFoldableURec25
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6P9z] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec2_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6P9A eta_s6P9B]
        Data.Foldable.$fFoldableURec25 eta_s6P9B;

Data.Foldable.$fFoldableURec2_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P9C xs_s6P9D] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec2_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Double a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6P9E z0_s6P9F xs_s6P9G]
        case xs_s6P9G of {
          GHC.Generics.UDouble _ [Occ=Dead] -> z0_s6P9F;
        };

Data.Foldable.$fFoldableURec2_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6P9J]
        case xs_s6P9J of {
          GHC.Generics.UDouble _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec2_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6P9M xs_s6P9N] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec2_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Double m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6P9O ds_s6P9P]
        case ds_s6P9P of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              GHC.Base.mempty $dMonoid_s6P9O;
        };

Data.Foldable.$fFoldableURec22
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6P9S ds_s6P9T]
        case ds_s6P9T of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6P9S;
        };

Data.Foldable.$fFoldableURec2_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6P9W]
        case eta_s6P9W of { GHC.Generics.UDouble _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec2 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Double)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec2_$cfold
                                             Data.Foldable.$fFoldableURec2_$cfoldMap
                                             Data.Foldable.$fFoldableURec2_$cfoldr
                                             Data.Foldable.$fFoldableURec2_$cfoldr
                                             Data.Foldable.$fFoldableURec2_$cfoldl'
                                             Data.Foldable.$fFoldableURec2_$cfoldl'
                                             Data.Foldable.$fFoldableURec2_$cfoldr1
                                             Data.Foldable.$fFoldableURec2_$cfoldl1
                                             Data.Foldable.$fFoldableURec2_$ctoList
                                             Data.Foldable.$fFoldableURec2_$cnull
                                             Data.Foldable.$fFoldableURec2_$clength
                                             Data.Foldable.$fFoldableURec26
                                             Data.Foldable.$fFoldableURec2_$cmaximum
                                             Data.Foldable.$fFoldableURec2_$cminimum
                                             Data.Foldable.$fFoldableURec23
                                             Data.Foldable.$fFoldableURec22];

Data.Foldable.$fFoldableURec31
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Char a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6P9Z eta_s6Pa0 eta1_s6Pa1]
        case eta1_s6Pa1 of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec28
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Char a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pa4 ds_s6Pa5]
        case ds_s6Pa5 of {
          GHC.Generics.UChar _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Pa4;
        };

Data.Foldable.$fFoldableURec29
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Pa8] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec3_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Pa9 eta_s6Paa]
        Data.Foldable.$fFoldableURec29 eta_s6Paa;

Data.Foldable.$fFoldableURec30
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Pab] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec3_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Pac eta_s6Pad]
        Data.Foldable.$fFoldableURec30 eta_s6Pad;

Data.Foldable.$fFoldableURec3_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pae xs_s6Paf] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec3_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Char a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Pag z0_s6Pah xs_s6Pai]
        case xs_s6Pai of { GHC.Generics.UChar _ [Occ=Dead] -> z0_s6Pah; };

Data.Foldable.$fFoldableURec3_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6Pal]
        case xs_s6Pal of {
          GHC.Generics.UChar _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec3_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pao xs_s6Pap] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec3_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Char m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Paq ds_s6Par]
        case ds_s6Par of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Paq;
        };

Data.Foldable.$fFoldableURec27
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Char a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pau ds_s6Pav]
        case ds_s6Pav of {
          GHC.Generics.UChar _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Pau;
        };

Data.Foldable.$fFoldableURec3_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6Pay]
        case eta_s6Pay of { GHC.Generics.UChar _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec3 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Char)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec3_$cfold
                                             Data.Foldable.$fFoldableURec3_$cfoldMap
                                             Data.Foldable.$fFoldableURec3_$cfoldr
                                             Data.Foldable.$fFoldableURec3_$cfoldr
                                             Data.Foldable.$fFoldableURec3_$cfoldl'
                                             Data.Foldable.$fFoldableURec3_$cfoldl'
                                             Data.Foldable.$fFoldableURec3_$cfoldr1
                                             Data.Foldable.$fFoldableURec3_$cfoldl1
                                             Data.Foldable.$fFoldableURec3_$ctoList
                                             Data.Foldable.$fFoldableURec3_$cnull
                                             Data.Foldable.$fFoldableURec3_$clength
                                             Data.Foldable.$fFoldableURec31
                                             Data.Foldable.$fFoldableURec3_$cmaximum
                                             Data.Foldable.$fFoldableURec3_$cminimum
                                             Data.Foldable.$fFoldableURec28
                                             Data.Foldable.$fFoldableURec27];

Data.Foldable.$fFoldableURec36
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6PaB eta_s6PaC eta1_s6PaD]
        case eta1_s6PaD of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec33
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PaG ds_s6PaH]
        case ds_s6PaH of {
          GHC.Generics.UAddr _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6PaG;
        };

Data.Foldable.$fFoldableURec34
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6PaK] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec4_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6PaL eta_s6PaM]
        Data.Foldable.$fFoldableURec34 eta_s6PaM;

Data.Foldable.$fFoldableURec35
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6PaN] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec4_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6PaO eta_s6PaP]
        Data.Foldable.$fFoldableURec35 eta_s6PaP;

Data.Foldable.$fFoldableURec4_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6PaQ xs_s6PaR] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec4_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6PaS z0_s6PaT xs_s6PaU]
        case xs_s6PaU of { GHC.Generics.UAddr _ [Occ=Dead] -> z0_s6PaT; };

Data.Foldable.$fFoldableURec4_$clength
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6PaX]
        case xs_s6PaX of {
          GHC.Generics.UAddr _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec4_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pb0 xs_s6Pb1] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec4_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pb2 ds_s6Pb3]
        case ds_s6Pb3 of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Pb2;
        };

Data.Foldable.$fFoldableURec32
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pb6 ds_s6Pb7]
        case ds_s6Pb7 of {
          GHC.Generics.UAddr _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Pb6;
        };

Data.Foldable.$fFoldableURec4_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6Pba]
        case eta_s6Pba of { GHC.Generics.UAddr _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec4 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec (GHC.Ptr.Ptr ()))
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec4_$cfold
                                             Data.Foldable.$fFoldableURec4_$cfoldMap
                                             Data.Foldable.$fFoldableURec4_$cfoldr
                                             Data.Foldable.$fFoldableURec4_$cfoldr
                                             Data.Foldable.$fFoldableURec4_$cfoldl'
                                             Data.Foldable.$fFoldableURec4_$cfoldl'
                                             Data.Foldable.$fFoldableURec4_$cfoldr1
                                             Data.Foldable.$fFoldableURec4_$cfoldl1
                                             Data.Foldable.$fFoldableURec4_$ctoList
                                             Data.Foldable.$fFoldableURec4_$cnull
                                             Data.Foldable.$fFoldableURec4_$clength
                                             Data.Foldable.$fFoldableURec36
                                             Data.Foldable.$fFoldableURec4_$cmaximum
                                             Data.Foldable.$fFoldableURec4_$cminimum
                                             Data.Foldable.$fFoldableURec33
                                             Data.Foldable.$fFoldableURec32];

Data.Foldable.$fFoldable:*:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:*:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pbd $dFoldable1_s6Pbe $dEq_s6Pbf eta_s6Pbg]
        let {
          f1_s6Pbh :: a_a6Lad -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Pbf eta_s6Pbg] \u []
                  GHC.Classes.== $dEq_s6Pbf eta_s6Pbg; } in
        let {
          sat_s6Pbn [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lad
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6Pbd $dFoldable1_s6Pbe f1_s6Pbh] \r [ds_s6Pbi]
                  case ds_s6Pbi of {
                    GHC.Generics.:*: a1_s6Pbk [Occ=Once] a2_s6Pbl [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6Pbd
                                Data.Semigroup.Internal.$fMonoidAny
                                f1_s6Pbh
                                a1_s6Pbk
                        of
                        { GHC.Types.False ->
                              Data.Foldable.foldMap
                                  $dFoldable1_s6Pbe
                                  Data.Semigroup.Internal.$fMonoidAny
                                  f1_s6Pbh
                                  a2_s6Pbl;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_s6Pbn;

Data.Foldable.$fFoldable:*:_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pbo $dFoldable1_s6Pbp $dNum_s6Pbq]
        let {
          $dMonoid_s6Pbr
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LaH)
          [LclId] =
              [$dNum_s6Pbq] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6Pbq; } in
        let {
          sat_s6Pby [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6LaH
               -> Data.Semigroup.Internal.Sum a_a6LaH
          [LclId] =
              [$dFoldable_s6Pbo
               $dFoldable1_s6Pbp
               $dNum_s6Pbq
               $dMonoid_s6Pbr] \r [ds_s6Pbs]
                  case ds_s6Pbs of {
                    GHC.Generics.:*: a1_s6Pbu [Occ=Once] a2_s6Pbv [Occ=Once] ->
                        let {
                          sat_s6Pbx [Occ=Once] :: a_a6LaH
                          [LclId] =
                              [$dFoldable1_s6Pbp $dMonoid_s6Pbr a2_s6Pbv] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_s6Pbp
                                      $dMonoid_s6Pbr
                                      Data.Foldable.$fFoldable:*:1
                                      a2_s6Pbv; } in
                        let {
                          sat_s6Pbw [Occ=Once] :: a_a6LaH
                          [LclId] =
                              [$dFoldable_s6Pbo $dMonoid_s6Pbr a1_s6Pbu] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Pbo
                                      $dMonoid_s6Pbr
                                      Data.Foldable.$fFoldable:*:1
                                      a1_s6Pbu;
                        } in  GHC.Num.+ $dNum_s6Pbq sat_s6Pbw sat_s6Pbx;
                  };
        } in  sat_s6Pby;

Data.Foldable.$fFoldable:*:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pbz $dFoldable1_s6PbA $dOrd_s6PbB]
        let {
          $dMonoid_s6PbC :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6Lax)
          [LclId] =
              [$dOrd_s6PbB] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6PbB; } in
        let {
          sat_s6PbO [Occ=OnceT[0]]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lax -> a_a6Lax
          [LclId] =
              [$dFoldable_s6Pbz
               $dFoldable1_s6PbA
               $dOrd_s6PbB
               $dMonoid_s6PbC] \r [x_s6PbD]
                  case x_s6PbD of {
                    GHC.Generics.:*: a1_s6PbF [Occ=Once*] a2_s6PbG [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6PbA $dMonoid_s6PbC GHC.Base.Just a2_s6PbG
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Pbz $dMonoid_s6PbC GHC.Base.Just a1_s6PbF
                              of
                              { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                                GHC.Base.Just v_s6PbJ [Occ=Once] -> v_s6PbJ;
                              };
                          GHC.Base.Just ipv_s6PbK ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Pbz $dMonoid_s6PbC GHC.Base.Just a1_s6PbF
                              of
                              { GHC.Base.Nothing -> ipv_s6PbK;
                                GHC.Base.Just x1_s6PbM ->
                                    case GHC.Classes.<= $dOrd_s6PbB x1_s6PbM ipv_s6PbK of {
                                      GHC.Types.False -> ipv_s6PbK;
                                      GHC.Types.True -> x1_s6PbM;
                                    };
                              };
                        };
                  };
        } in  sat_s6PbO;

Data.Foldable.$fFoldable:*:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PbP $dFoldable1_s6PbQ $dOrd_s6PbR]
        let {
          $dMonoid_s6PbS :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lan)
          [LclId] =
              [$dOrd_s6PbR] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6PbR; } in
        let {
          sat_s6Pc4 [Occ=OnceT[0]]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lan -> a_a6Lan
          [LclId] =
              [$dFoldable_s6PbP
               $dFoldable1_s6PbQ
               $dOrd_s6PbR
               $dMonoid_s6PbS] \r [x_s6PbT]
                  case x_s6PbT of {
                    GHC.Generics.:*: a1_s6PbV [Occ=Once*] a2_s6PbW [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6PbQ $dMonoid_s6PbS GHC.Base.Just a2_s6PbW
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6PbP $dMonoid_s6PbS GHC.Base.Just a1_s6PbV
                              of
                              { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                                GHC.Base.Just v_s6PbZ [Occ=Once] -> v_s6PbZ;
                              };
                          GHC.Base.Just ipv_s6Pc0 ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6PbP $dMonoid_s6PbS GHC.Base.Just a1_s6PbV
                              of
                              { GHC.Base.Nothing -> ipv_s6Pc0;
                                GHC.Base.Just x1_s6Pc2 ->
                                    case GHC.Classes.>= $dOrd_s6PbR x1_s6Pc2 ipv_s6Pc0 of {
                                      GHC.Types.False -> ipv_s6Pc0;
                                      GHC.Types.True -> x1_s6Pc2;
                                    };
                              };
                        };
                  };
        } in  sat_s6Pc4;

Data.Foldable.$w$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pc5 w1_s6Pc6 w2_s6Pc7 ww_s6Pc8 ww1_s6Pc9]
        let {
          f1_s6Pca
            :: a_s6NTG -> GHC.Base.Maybe a_s6NTG -> GHC.Base.Maybe a_s6NTG
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_s6Pc7] \r [x_s6Pcb m_s6Pcc]
                  let {
                    sat_s6Pcf [Occ=Once] :: a_s6NTG
                    [LclId] =
                        [w2_s6Pc7 x_s6Pcb m_s6Pcc] \u []
                            case m_s6Pcc of {
                              GHC.Base.Nothing -> x_s6Pcb;
                              GHC.Base.Just y_s6Pce [Occ=Once] -> w2_s6Pc7 x_s6Pcb y_s6Pce;
                            };
                  } in  GHC.Base.Just [sat_s6Pcf]; } in
        let {
          sat_s6Pcg [Occ=Once] :: GHC.Base.Maybe a_s6NTG
          [LclId] =
              [w1_s6Pc6 ww1_s6Pc9 f1_s6Pca] \u []
                  Data.Foldable.foldr w1_s6Pc6 f1_s6Pca GHC.Base.Nothing ww1_s6Pc9;
        } in 
          case Data.Foldable.foldr w_s6Pc5 f1_s6Pca sat_s6Pcg ww_s6Pc8 of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6Pci [Occ=Once] -> v_s6Pci;
          };

Data.Foldable.$fFoldable:*:_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Pcj w1_s6Pck w2_s6Pcl w3_s6Pcm]
        case w3_s6Pcm of {
          GHC.Generics.:*: ww1_s6Pco [Occ=Once] ww2_s6Pcp [Occ=Once] ->
              Data.Foldable.$w$cfoldr1
                  w_s6Pcj w1_s6Pck w2_s6Pcl ww1_s6Pco ww2_s6Pcp;
        };

Data.Foldable.$w$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pcq w1_s6Pcr w2_s6Pcs w3_s6Pct ww_s6Pcu ww1_s6Pcv]
        let {
          f1_s6Pcw :: a_s6NTU -> (b_s6NTT -> b_s6NTT) -> b_s6NTT -> b_s6NTT
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_s6Pcs] \r [x_s6Pcx k_s6Pcy z_s6Pcz]
                  case w2_s6Pcs z_s6Pcz x_s6Pcx of vx_s6PcA {
                    __DEFAULT -> k_s6Pcy vx_s6PcA;
                  }; } in
        let {
          sat_s6PcB [Occ=Once] :: b_s6NTT -> b_s6NTT
          [LclId] =
              [w1_s6Pcr ww1_s6Pcv f1_s6Pcw] \u []
                  Data.Foldable.foldr w1_s6Pcr f1_s6Pcw GHC.Base.id ww1_s6Pcv;
        } in 
          Data.Foldable.foldr w_s6Pcq f1_s6Pcw sat_s6PcB ww_s6Pcu w3_s6Pct;

Data.Foldable.$fFoldable:*:_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PcC w1_s6PcD w2_s6PcE w3_s6PcF w4_s6PcG]
        case w4_s6PcG of {
          GHC.Generics.:*: ww1_s6PcI [Occ=Once] ww2_s6PcJ [Occ=Once] ->
              Data.Foldable.$w$cfoldl'
                  w_s6PcC w1_s6PcD w2_s6PcE w3_s6PcF ww1_s6PcI ww2_s6PcJ;
        };

Data.Foldable.$fFoldableM2
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s6PcK k_s6PcL z_s6PcM]
        case z_s6PcM of {
          GHC.Types.I# x1_s6PcO [Occ=Once] ->
              case +# [x1_s6PcO 1#] of sat_s6PcP {
                __DEFAULT ->
                    let {
                      sat_s6PcQ [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_s6PcP];
                    } in  k_s6PcL sat_s6PcQ;
              };
        };

Data.Foldable.$fFoldable:*:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PcR $dFoldable1_s6PcS eta_s6PcT]
        case eta_s6PcT of {
          GHC.Generics.:*: ww1_s6PcV [Occ=Once] ww2_s6PcW [Occ=Once] ->
              let {
                sat_s6PcX [Occ=Once] :: GHC.Types.Int -> GHC.Types.Int
                [LclId] =
                    [$dFoldable1_s6PcS ww2_s6PcW] \u []
                        Data.Foldable.foldr
                            $dFoldable1_s6PcS Data.Foldable.$fFoldableM2 GHC.Base.id ww2_s6PcW;
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6PcR
                    Data.Foldable.$fFoldableM2
                    sat_s6PcX
                    ww1_s6PcV
                    Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$w$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6PcY w1_s6PcZ w2_s6Pd0 w3_s6Pd1 ww_s6Pd2 ww1_s6Pd3]
        let {
          f1_s6Pd4 :: a_s6NU9 -> b_s6NU8 -> b_s6NU8
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w2_s6Pd0] \r [x_s6Pd5 y_s6Pd6] w2_s6Pd0 y_s6Pd6 x_s6Pd5; } in
        let {
          sat_s6Pd7 [Occ=Once] :: b_s6NU8
          [LclId] =
              [w_s6PcY w3_s6Pd1 ww_s6Pd2 f1_s6Pd4] \u []
                  Data.Foldable.foldMap
                      w_s6PcY Data.Foldable.$fFoldable:*:7 f1_s6Pd4 ww_s6Pd2 w3_s6Pd1;
        } in 
          Data.Foldable.foldMap
              w1_s6PcZ Data.Foldable.$fFoldable:*:7 f1_s6Pd4 ww1_s6Pd3 sat_s6Pd7;

Data.Foldable.$fFoldable:*:_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Pd8 w1_s6Pd9 w2_s6Pda w3_s6Pdb w4_s6Pdc]
        case w4_s6Pdc of {
          GHC.Generics.:*: ww1_s6Pde [Occ=Once] ww2_s6Pdf [Occ=Once] ->
              Data.Foldable.$w$cfoldl
                  w_s6Pd8 w1_s6Pd9 w2_s6Pda w3_s6Pdb ww1_s6Pde ww2_s6Pdf;
        };

Data.Foldable.$w$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pdg w1_s6Pdh w2_s6Pdi ww_s6Pdj ww1_s6Pdk]
        let {
          f1_s6Pdl
            :: a_s6NUn -> GHC.Base.Maybe a_s6NUn -> GHC.Base.Maybe a_s6NUn
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_s6Pdi] \r [x_s6Pdm y_s6Pdn]
                  let {
                    sat_s6Pdq [Occ=Once] :: a_s6NUn
                    [LclId] =
                        [w2_s6Pdi x_s6Pdm y_s6Pdn] \u []
                            case y_s6Pdn of {
                              GHC.Base.Nothing -> x_s6Pdm;
                              GHC.Base.Just x1_s6Pdp [Occ=Once] -> w2_s6Pdi x1_s6Pdp x_s6Pdm;
                            };
                  } in  GHC.Base.Just [sat_s6Pdq]; } in
        let {
          sat_s6Pdr [Occ=Once] :: GHC.Base.Maybe a_s6NUn
          [LclId] =
              [w_s6Pdg ww_s6Pdj f1_s6Pdl] \u []
                  Data.Foldable.foldMap
                      w_s6Pdg
                      Data.Foldable.$fFoldable:*:7
                      f1_s6Pdl
                      ww_s6Pdj
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w1_s6Pdh Data.Foldable.$fFoldable:*:7 f1_s6Pdl ww1_s6Pdk sat_s6Pdr
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6Pdt [Occ=Once] -> v_s6Pdt;
          };

Data.Foldable.$fFoldable:*:_$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Pdu w1_s6Pdv w2_s6Pdw w3_s6Pdx]
        case w3_s6Pdx of {
          GHC.Generics.:*: ww1_s6Pdz [Occ=Once] ww2_s6PdA [Occ=Once] ->
              Data.Foldable.$w$cfoldl1
                  w_s6Pdu w1_s6Pdv w2_s6Pdw ww1_s6Pdz ww2_s6PdA;
        };

Data.Foldable.$w$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6PdB w1_s6PdC w2_s6PdD w3_s6PdE ww_s6PdF ww1_s6PdG]
        let {
          f1_s6PdH :: a_s6NUA -> (b_s6NUB -> b_s6NUB) -> b_s6NUB -> b_s6NUB
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_s6PdD] \r [x_s6PdI y_s6PdJ z_s6PdK]
                  case w2_s6PdD x_s6PdI z_s6PdK of vx_s6PdL {
                    __DEFAULT -> y_s6PdJ vx_s6PdL;
                  }; } in
        let {
          sat_s6PdM [Occ=Once] :: b_s6NUB -> b_s6NUB
          [LclId] =
              [w_s6PdB ww_s6PdF f1_s6PdH] \u []
                  Data.Foldable.foldMap
                      w_s6PdB Data.Foldable.$fFoldable:*:7 f1_s6PdH ww_s6PdF GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w1_s6PdC
              Data.Foldable.$fFoldable:*:7
              f1_s6PdH
              ww1_s6PdG
              sat_s6PdM
              w3_s6PdE;

Data.Foldable.$fFoldable:*:_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PdN w1_s6PdO w2_s6PdP w3_s6PdQ w4_s6PdR]
        case w4_s6PdR of {
          GHC.Generics.:*: ww1_s6PdT [Occ=Once] ww2_s6PdU [Occ=Once] ->
              Data.Foldable.$w$cfoldr'
                  w_s6PdN w1_s6PdO w2_s6PdP w3_s6PdQ ww1_s6PdT ww2_s6PdU;
        };

Data.Foldable.$fFoldable:*:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:*:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PdV $dFoldable1_s6PdW $dMonoid_s6PdX w_s6PdY]
        case w_s6PdY of {
          GHC.Generics.:*: ww1_s6Pe0 [Occ=Once] ww2_s6Pe1 [Occ=Once] ->
              Data.Foldable.$w$cfoldMap
                  $dFoldable_s6PdV
                  $dFoldable1_s6PdW
                  $dMonoid_s6PdX
                  GHC.Base.id
                  ww1_s6Pe0
                  ww2_s6Pe1;
        };

Data.Foldable.$fFoldable:*:_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pe2 $dFoldable1_s6Pe3 $dNum_s6Pe4]
        let {
          $dMonoid_s6Pe5
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LaR)
          [LclId] =
              [$dNum_s6Pe4] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6Pe4; } in
        let {
          sat_s6Pec [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6LaR
               -> Data.Semigroup.Internal.Product a_a6LaR
          [LclId] =
              [$dFoldable_s6Pe2
               $dFoldable1_s6Pe3
               $dNum_s6Pe4
               $dMonoid_s6Pe5] \r [ds_s6Pe6]
                  case ds_s6Pe6 of {
                    GHC.Generics.:*: a1_s6Pe8 [Occ=Once] a2_s6Pe9 [Occ=Once] ->
                        let {
                          sat_s6Peb [Occ=Once] :: a_a6LaR
                          [LclId] =
                              [$dFoldable1_s6Pe3 $dMonoid_s6Pe5 a2_s6Pe9] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_s6Pe3
                                      $dMonoid_s6Pe5
                                      Data.Foldable.$fFoldable:*:1
                                      a2_s6Pe9; } in
                        let {
                          sat_s6Pea [Occ=Once] :: a_a6LaR
                          [LclId] =
                              [$dFoldable_s6Pe2 $dMonoid_s6Pe5 a1_s6Pe8] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Pe2
                                      $dMonoid_s6Pe5
                                      Data.Foldable.$fFoldable:*:1
                                      a1_s6Pe8;
                        } in  GHC.Num.* $dNum_s6Pe4 sat_s6Pea sat_s6Peb;
                  };
        } in  sat_s6Pec;

Data.Foldable.$fFoldable:*:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ped $dFoldable1_s6Pee eta_s6Pef]
        case eta_s6Pef of {
          GHC.Generics.:*: a1_s6Peh [Occ=Once] a2_s6Pei [Occ=Once] ->
              let {
                sat_s6Pej [Occ=Once] :: [a_a6L9L]
                [LclId] =
                    [$dFoldable1_s6Pee a2_s6Pei] \u []
                        Data.Foldable.foldr
                            $dFoldable1_s6Pee GHC.Types.: GHC.Types.[] a2_s6Pei;
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6Ped GHC.Types.: sat_s6Pej a1_s6Peh;
        };

Data.Foldable.$fFoldable:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6Pek $dFoldable1_s6Pel]
        let {
          sat_s6PeB [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cproduct
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6PeA [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$csum
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Pez [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cminimum
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Pey [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cmaximum
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Pex [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$celem
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B2 eta_B1; } in
        let {
          sat_s6Pew [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$clength
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Pev [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cnull
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Peu [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> [a]
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$ctoList
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B1; } in
        let {
          sat_s6Pet [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl1
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B2 eta_B1; } in
        let {
          sat_s6Pes [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr1
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B2 eta_B1; } in
        let {
          sat_s6Per [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl'
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Peq [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pep [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr'
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Peo [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pen [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> m
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldMap
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pem [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S m -> m
          [LclId] =
              [$dFoldable_s6Pek $dFoldable1_s6Pel] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfold
                      $dFoldable_s6Pek $dFoldable1_s6Pel eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6Pem
                                    sat_s6Pen
                                    sat_s6Peo
                                    sat_s6Pep
                                    sat_s6Peq
                                    sat_s6Per
                                    sat_s6Pes
                                    sat_s6Pet
                                    sat_s6Peu
                                    sat_s6Pev
                                    sat_s6Pew
                                    sat_s6Pex
                                    sat_s6Pey
                                    sat_s6Pez
                                    sat_s6PeA
                                    sat_s6PeB];

Data.Foldable.$fFoldable:+:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:+:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PeC $dFoldable1_s6PeD $dEq_s6PeE eta_s6PeF]
        let {
          f1_s6PeG [Occ=OnceL*] :: a_a6Ldk -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6PeE eta_s6PeF] \u []
                  GHC.Classes.== $dEq_s6PeE eta_s6PeF; } in
        let {
          sat_s6PeL [Occ=Once]
            :: (GHC.Generics.:+:) f_X6LpN g_X6LpP a_a6Ldk
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6PeC $dFoldable1_s6PeD f1_s6PeG] \r [ds_s6PeH]
                  case ds_s6PeH of {
                    GHC.Generics.L1 a1_s6PeJ [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6PeC
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_s6PeG
                            a1_s6PeJ;
                    GHC.Generics.R1 a1_s6PeK [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6PeD
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_s6PeG
                            a1_s6PeK;
                  };
        } in  sat_s6PeL;

Data.Foldable.$fFoldable:+:2
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     (GHC.Generics.:+:) f g a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PeM $dFoldable1_s6PeN $dNum_s6PeO]
        let {
          $dMonoid_s6PeP [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LdO)
          [LclId] =
              [$dNum_s6PeO] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6PeO; } in
        let {
          sat_s6PeU [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpF g_X6LpH a_a6LdO
               -> Data.Semigroup.Internal.Sum a_a6LdO
          [LclId] =
              [$dFoldable_s6PeM $dFoldable1_s6PeN $dMonoid_s6PeP] \r [ds_s6PeQ]
                  case ds_s6PeQ of {
                    GHC.Generics.L1 a1_s6PeS [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6PeM
                            $dMonoid_s6PeP
                            Data.Foldable.$fFoldable:*:1
                            a1_s6PeS;
                    GHC.Generics.R1 a1_s6PeT [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6PeN
                            $dMonoid_s6PeP
                            Data.Foldable.$fFoldable:*:1
                            a1_s6PeT;
                  };
        } in  sat_s6PeU;

Data.Foldable.$fFoldable:+:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PeV $dFoldable1_s6PeW $dOrd_s6PeX]
        let {
          g1_s6PeY [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6LdE)
          [LclId] =
              [$dOrd_s6PeX] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6PeX; } in
        let {
          sat_s6Pf7 [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpE g_X6LpG a_a6LdE -> a_a6LdE
          [LclId] =
              [$dFoldable_s6PeV $dFoldable1_s6PeW g1_s6PeY] \r [x_s6PeZ]
                  case x_s6PeZ of {
                    GHC.Generics.L1 a1_s6Pf1 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6PeV g1_s6PeY GHC.Base.Just a1_s6Pf1
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                          GHC.Base.Just v_s6Pf3 [Occ=Once] -> v_s6Pf3;
                        };
                    GHC.Generics.R1 a1_s6Pf4 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6PeW g1_s6PeY GHC.Base.Just a1_s6Pf4
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                          GHC.Base.Just v_s6Pf6 [Occ=Once] -> v_s6Pf6;
                        };
                  };
        } in  sat_s6Pf7;

Data.Foldable.$fFoldable:+:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pf8 $dFoldable1_s6Pf9 $dOrd_s6Pfa]
        let {
          g1_s6Pfb [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Ldu)
          [LclId] =
              [$dOrd_s6Pfa] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6Pfa; } in
        let {
          sat_s6Pfk [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpD g_X6LpF a_a6Ldu -> a_a6Ldu
          [LclId] =
              [$dFoldable_s6Pf8 $dFoldable1_s6Pf9 g1_s6Pfb] \r [x_s6Pfc]
                  case x_s6Pfc of {
                    GHC.Generics.L1 a1_s6Pfe [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6Pf8 g1_s6Pfb GHC.Base.Just a1_s6Pfe
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                          GHC.Base.Just v_s6Pfg [Occ=Once] -> v_s6Pfg;
                        };
                    GHC.Generics.R1 a1_s6Pfh [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6Pf9 g1_s6Pfb GHC.Base.Just a1_s6Pfh
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                          GHC.Base.Just v_s6Pfj [Occ=Once] -> v_s6Pfj;
                        };
                  };
        } in  sat_s6Pfk;

Data.Foldable.$fFoldable:+:_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pfl $dFoldable1_s6Pfm f1_s6Pfn xs_s6Pfo]
        case xs_s6Pfo of {
          GHC.Generics.L1 a1_s6Pfq [Occ=Once] ->
              let {
                sat_s6Pfw [Occ=Once]
                  :: a_a6LcC -> GHC.Base.Maybe a_a6LcC -> GHC.Base.Maybe a_a6LcC
                [LclId] =
                    [f1_s6Pfn] \r [x_s6Pfr m_s6Pfs]
                        let {
                          sat_s6Pfv [Occ=Once] :: a_a6LcC
                          [LclId] =
                              [f1_s6Pfn x_s6Pfr m_s6Pfs] \u []
                                  case m_s6Pfs of {
                                    GHC.Base.Nothing -> x_s6Pfr;
                                    GHC.Base.Just y_s6Pfu [Occ=Once] -> f1_s6Pfn x_s6Pfr y_s6Pfu;
                                  };
                        } in  GHC.Base.Just [sat_s6Pfv];
              } in 
                case
                    Data.Foldable.foldr
                        $dFoldable_s6Pfl sat_s6Pfw GHC.Base.Nothing a1_s6Pfq
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
                  GHC.Base.Just v_s6Pfy [Occ=Once] -> v_s6Pfy;
                };
          GHC.Generics.R1 a1_s6Pfz [Occ=Once] ->
              let {
                sat_s6PfF [Occ=Once]
                  :: a_a6LcC -> GHC.Base.Maybe a_a6LcC -> GHC.Base.Maybe a_a6LcC
                [LclId] =
                    [f1_s6Pfn] \r [x_s6PfA m_s6PfB]
                        let {
                          sat_s6PfE [Occ=Once] :: a_a6LcC
                          [LclId] =
                              [f1_s6Pfn x_s6PfA m_s6PfB] \u []
                                  case m_s6PfB of {
                                    GHC.Base.Nothing -> x_s6PfA;
                                    GHC.Base.Just y_s6PfD [Occ=Once] -> f1_s6Pfn x_s6PfA y_s6PfD;
                                  };
                        } in  GHC.Base.Just [sat_s6PfE];
              } in 
                case
                    Data.Foldable.foldr
                        $dFoldable1_s6Pfm sat_s6PfF GHC.Base.Nothing a1_s6Pfz
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
                  GHC.Base.Just v_s6PfH [Occ=Once] -> v_s6PfH;
                };
        };

Data.Foldable.$fFoldable:+:_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PfI
           $dFoldable1_s6PfJ
           f1_s6PfK
           z0_s6PfL
           xs_s6PfM]
        case xs_s6PfM of {
          GHC.Generics.L1 a1_s6PfO [Occ=Once] ->
              let {
                sat_s6PfT [Occ=Once]
                  :: a_a6Lct -> (b_a6Lcs -> b_a6Lcs) -> b_a6Lcs -> b_a6Lcs
                [LclId] =
                    [f1_s6PfK] \r [x_s6PfP k_s6PfQ z_s6PfR]
                        case f1_s6PfK z_s6PfR x_s6PfP of vx_s6PfS {
                          __DEFAULT -> k_s6PfQ vx_s6PfS;
                        };
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6PfI sat_s6PfT GHC.Base.id a1_s6PfO z0_s6PfL;
          GHC.Generics.R1 a1_s6PfU [Occ=Once] ->
              let {
                sat_s6PfZ [Occ=Once]
                  :: a_a6Lct -> (b_a6Lcs -> b_a6Lcs) -> b_a6Lcs -> b_a6Lcs
                [LclId] =
                    [f1_s6PfK] \r [x_s6PfV k_s6PfW z_s6PfX]
                        case f1_s6PfK z_s6PfX x_s6PfV of vx_s6PfY {
                          __DEFAULT -> k_s6PfW vx_s6PfY;
                        };
              } in 
                Data.Foldable.foldr
                    $dFoldable1_s6PfJ sat_s6PfZ GHC.Base.id a1_s6PfU z0_s6PfL;
        };

Data.Foldable.$fFoldable:+:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pg0 $dFoldable1_s6Pg1 eta_s6Pg2]
        Data.Foldable.$fFoldable:+:_$cfoldl'
            $dFoldable_s6Pg0
            $dFoldable1_s6Pg1
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4
            eta_s6Pg2;

Data.Foldable.$fFoldable:+:_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pg3 $dFoldable1_s6Pg4 f1_s6Pg5 z_s6Pg6 t_s6Pg7]
        let {
          f2_s6Pg8 [Occ=Once*] :: a_a6Lcj -> b_a6Lci -> b_a6Lci
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [f1_s6Pg5] \r [x_s6Pg9 y_s6Pga] f1_s6Pg5 y_s6Pga x_s6Pg9;
        } in 
          case t_s6Pg7 of {
            GHC.Generics.L1 a1_s6Pgc [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable_s6Pg3
                    Data.Foldable.$fFoldable:*:7
                    f2_s6Pg8
                    a1_s6Pgc
                    z_s6Pg6;
            GHC.Generics.R1 a1_s6Pgd [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable1_s6Pg4
                    Data.Foldable.$fFoldable:*:7
                    f2_s6Pg8
                    a1_s6Pgd
                    z_s6Pg6;
          };

Data.Foldable.$fFoldable:+:_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pge $dFoldable1_s6Pgf f1_s6Pgg xs_s6Pgh]
        case xs_s6Pgh of {
          GHC.Generics.L1 a1_s6Pgj [Occ=Once] ->
              let {
                sat_s6Pgp [Occ=Once]
                  :: a_a6LcK
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LcK))
                [LclId] =
                    [f1_s6Pgg] \r [x_s6Pgk y_s6Pgl]
                        let {
                          sat_s6Pgo [Occ=Once] :: a_a6LcK
                          [LclId] =
                              [f1_s6Pgg x_s6Pgk y_s6Pgl] \u []
                                  case y_s6Pgl of {
                                    GHC.Base.Nothing -> x_s6Pgk;
                                    GHC.Base.Just x1_s6Pgn [Occ=Once] -> f1_s6Pgg x1_s6Pgn x_s6Pgk;
                                  };
                        } in  GHC.Base.Just [sat_s6Pgo];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable_s6Pge
                        Data.Foldable.$fFoldable:*:7
                        sat_s6Pgp
                        a1_s6Pgj
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
                  GHC.Base.Just v_s6Pgr [Occ=Once] -> v_s6Pgr;
                };
          GHC.Generics.R1 a1_s6Pgs [Occ=Once] ->
              let {
                sat_s6Pgy [Occ=Once]
                  :: a_a6LcK
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LcK))
                [LclId] =
                    [f1_s6Pgg] \r [x_s6Pgt y_s6Pgu]
                        let {
                          sat_s6Pgx [Occ=Once] :: a_a6LcK
                          [LclId] =
                              [f1_s6Pgg x_s6Pgt y_s6Pgu] \u []
                                  case y_s6Pgu of {
                                    GHC.Base.Nothing -> x_s6Pgt;
                                    GHC.Base.Just x1_s6Pgw [Occ=Once] -> f1_s6Pgg x1_s6Pgw x_s6Pgt;
                                  };
                        } in  GHC.Base.Just [sat_s6Pgx];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable1_s6Pgf
                        Data.Foldable.$fFoldable:*:7
                        sat_s6Pgy
                        a1_s6Pgs
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
                  GHC.Base.Just v_s6PgA [Occ=Once] -> v_s6PgA;
                };
        };

Data.Foldable.$fFoldable:+:_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PgB
           $dFoldable1_s6PgC
           f1_s6PgD
           z0_s6PgE
           xs_s6PgF]
        case xs_s6PgF of {
          GHC.Generics.L1 a1_s6PgH [Occ=Once] ->
              let {
                sat_s6PgM [Occ=Once]
                  :: a_a6Lc8
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_a6Lc9 -> b_a6Lc9))
                [LclId] =
                    [f1_s6PgD] \r [x_s6PgI y_s6PgJ z_s6PgK]
                        case f1_s6PgD x_s6PgI z_s6PgK of vx_s6PgL {
                          __DEFAULT -> y_s6PgJ vx_s6PgL;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable_s6PgB
                    Data.Foldable.$fFoldable:*:7
                    sat_s6PgM
                    a1_s6PgH
                    GHC.Base.id
                    z0_s6PgE;
          GHC.Generics.R1 a1_s6PgN [Occ=Once] ->
              let {
                sat_s6PgS [Occ=Once]
                  :: a_a6Lc8
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_a6Lc9 -> b_a6Lc9))
                [LclId] =
                    [f1_s6PgD] \r [x_s6PgO y_s6PgP z_s6PgQ]
                        case f1_s6PgD x_s6PgO z_s6PgQ of vx_s6PgR {
                          __DEFAULT -> y_s6PgP vx_s6PgR;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable1_s6PgC
                    Data.Foldable.$fFoldable:*:7
                    sat_s6PgS
                    a1_s6PgN
                    GHC.Base.id
                    z0_s6PgE;
        };

Data.Foldable.$fFoldable:+:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:+:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PgT $dFoldable1_s6PgU $dMonoid_s6PgV ds_s6PgW]
        case ds_s6PgW of {
          GHC.Generics.L1 a1_s6PgY [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_s6PgT $dMonoid_s6PgV GHC.Base.id a1_s6PgY;
          GHC.Generics.R1 a1_s6PgZ [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_s6PgU $dMonoid_s6PgV GHC.Base.id a1_s6PgZ;
        };

Data.Foldable.$fFoldable:+:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     (GHC.Generics.:+:) f g a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ph0 $dFoldable1_s6Ph1 $dNum_s6Ph2]
        let {
          $dMonoid_s6Ph3 [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LdY)
          [LclId] =
              [$dNum_s6Ph2] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6Ph2; } in
        let {
          sat_s6Ph8 [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a_a6LdY
               -> Data.Semigroup.Internal.Product a_a6LdY
          [LclId] =
              [$dFoldable_s6Ph0 $dFoldable1_s6Ph1 $dMonoid_s6Ph3] \r [ds_s6Ph4]
                  case ds_s6Ph4 of {
                    GHC.Generics.L1 a1_s6Ph6 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6Ph0
                            $dMonoid_s6Ph3
                            Data.Foldable.$fFoldable:*:1
                            a1_s6Ph6;
                    GHC.Generics.R1 a1_s6Ph7 [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6Ph1
                            $dMonoid_s6Ph3
                            Data.Foldable.$fFoldable:*:1
                            a1_s6Ph7;
                  };
        } in  sat_s6Ph8;

Data.Foldable.$fFoldable:+:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ph9 $dFoldable1_s6Pha eta_s6Phb]
        case eta_s6Phb of {
          GHC.Generics.L1 a1_s6Phd [Occ=Once] ->
              Data.Foldable.foldr
                  $dFoldable_s6Ph9 GHC.Types.: GHC.Types.[] a1_s6Phd;
          GHC.Generics.R1 a1_s6Phe [Occ=Once] ->
              Data.Foldable.foldr
                  $dFoldable1_s6Pha GHC.Types.: GHC.Types.[] a1_s6Phe;
        };

Data.Foldable.$fFoldable:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6Phf $dFoldable1_s6Phg]
        let {
          sat_s6Phw [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:1
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Phv [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:2
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Phu [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cminimum
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Pht [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cmaximum
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Phs [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$celem
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B2 eta_B1; } in
        let {
          sat_s6Phr [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$clength
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Phq [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cnull
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Php [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> [a]
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$ctoList
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B1; } in
        let {
          sat_s6Pho [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl1
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B2 eta_B1; } in
        let {
          sat_s6Phn [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr1
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B2 eta_B1; } in
        let {
          sat_s6Phm [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl'
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Phl [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Phk [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr'
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Phj [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Phi [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> m
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldMap
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Phh [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 m -> m
          [LclId] =
              [$dFoldable_s6Phf $dFoldable1_s6Phg] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfold
                      $dFoldable_s6Phf $dFoldable1_s6Phg eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6Phh
                                    sat_s6Phi
                                    sat_s6Phj
                                    sat_s6Phk
                                    sat_s6Phl
                                    sat_s6Phm
                                    sat_s6Phn
                                    sat_s6Pho
                                    sat_s6Php
                                    sat_s6Phq
                                    sat_s6Phr
                                    sat_s6Phs
                                    sat_s6Pht
                                    sat_s6Phu
                                    sat_s6Phv
                                    sat_s6Phw];

Data.Foldable.$fFoldableM1_$celem
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.M1 i c f a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Phx $dEq_s6Phy eta_s6Phz]
        let {
          f1_s6PhA [Occ=OnceL] :: a_a6Lg5 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Phy eta_s6Phz] \u []
                  GHC.Classes.== $dEq_s6Phy eta_s6Phz; } in
        let {
          sat_s6PhC [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6Phx f1_s6PhA] \r [ds_s6PhB]
                  Data.Foldable.foldMap
                      $dFoldable_s6Phx
                      Data.Semigroup.Internal.$fMonoidAny
                      f1_s6PhA
                      ds_s6PhB;
        } in  sat_s6PhC;

Data.Foldable.$fFoldableM1_$csum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PhD $dNum_s6PhE]
        let {
          $dMonoid_s6PhF [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6Lgz)
          [LclId] =
              [$dNum_s6PhE] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6PhE; } in
        let {
          sat_s6PhH [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz
               -> Data.Semigroup.Internal.Sum a_a6Lgz
          [LclId] =
              [$dFoldable_s6PhD $dMonoid_s6PhF] \r [ds_s6PhG]
                  Data.Foldable.foldMap
                      $dFoldable_s6PhD
                      $dMonoid_s6PhF
                      Data.Foldable.$fFoldable:*:1
                      ds_s6PhG;
        } in  sat_s6PhH;

Data.Foldable.$fFoldableM1_$cminimum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PhI $dOrd_s6PhJ]
        let {
          $dMonoid_s6PhK [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6Lgp)
          [LclId] =
              [$dOrd_s6PhJ] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6PhJ; } in
        let {
          sat_s6PhO [Occ=OnceT[0]]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgp -> a_a6Lgp
          [LclId] =
              [$dFoldable_s6PhI $dMonoid_s6PhK] \r [x_s6PhL]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6PhI $dMonoid_s6PhK GHC.Base.Just x_s6PhL
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6PhN [Occ=Once] -> v_s6PhN;
                  };
        } in  sat_s6PhO;

Data.Foldable.$fFoldableM1_$cmaximum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PhP $dOrd_s6PhQ]
        let {
          $dMonoid_s6PhR [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lgf)
          [LclId] =
              [$dOrd_s6PhQ] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6PhQ; } in
        let {
          sat_s6PhV [Occ=OnceT[0]]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgf -> a_a6Lgf
          [LclId] =
              [$dFoldable_s6PhP $dMonoid_s6PhR] \r [x_s6PhS]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6PhP $dMonoid_s6PhR GHC.Base.Just x_s6PhS
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6PhU [Occ=Once] -> v_s6PhU;
                  };
        } in  sat_s6PhV;

Data.Foldable.$fFoldableM1_$cfoldr1
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PhW f1_s6PhX xs_s6PhY]
        let {
          sat_s6Pi4 [Occ=Once]
            :: a_a6Lfq -> GHC.Base.Maybe a_a6Lfq -> GHC.Base.Maybe a_a6Lfq
          [LclId] =
              [f1_s6PhX] \r [x_s6PhZ m_s6Pi0]
                  let {
                    sat_s6Pi3 [Occ=Once] :: a_a6Lfq
                    [LclId] =
                        [f1_s6PhX x_s6PhZ m_s6Pi0] \u []
                            case m_s6Pi0 of {
                              GHC.Base.Nothing -> x_s6PhZ;
                              GHC.Base.Just y_s6Pi2 [Occ=Once] -> f1_s6PhX x_s6PhZ y_s6Pi2;
                            };
                  } in  GHC.Base.Just [sat_s6Pi3];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6PhW sat_s6Pi4 GHC.Base.Nothing xs_s6PhY
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6Pi6 [Occ=Once] -> v_s6Pi6;
          };

Data.Foldable.$fFoldableM1_$cfoldl'
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pi7 f1_s6Pi8 z0_s6Pi9 xs_s6Pia]
        let {
          sat_s6Pif [Occ=Once]
            :: a_a6Lfh -> (b_a6Lfg -> b_a6Lfg) -> b_a6Lfg -> b_a6Lfg
          [LclId] =
              [f1_s6Pi8] \r [x_s6Pib k_s6Pic z_s6Pid]
                  case f1_s6Pi8 z_s6Pid x_s6Pib of vx_s6Pie {
                    __DEFAULT -> k_s6Pic vx_s6Pie;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6Pi7 sat_s6Pif GHC.Base.id xs_s6Pia z0_s6Pi9;

Data.Foldable.$fFoldableM1_$clength
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.M1 i c f a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pig eta_s6Pih]
        Data.Foldable.foldr
            $dFoldable_s6Pig
            Data.Foldable.$fFoldableM2
            GHC.Base.id
            eta_s6Pih
            Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableM1_$cfoldl
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pii f1_s6Pij z_s6Pik t_s6Pil]
        let {
          sat_s6Pio [Occ=Once]
            :: a_a6Lf7
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6Lf6)
          [LclId] =
              [f1_s6Pij] \r [x_s6Pim y_s6Pin] f1_s6Pij y_s6Pin x_s6Pim;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pii
              Data.Foldable.$fFoldable:*:7
              sat_s6Pio
              t_s6Pil
              z_s6Pik;

Data.Foldable.$fFoldableM3
  :: forall a.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual
          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a)))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$fFoldableM1_$cfoldl1
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pip f1_s6Piq xs_s6Pir]
        let {
          sat_s6Pix [Occ=Once]
            :: a_a6Lfy
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6Lfy))
          [LclId] =
              [f1_s6Piq] \r [x_s6Pis y_s6Pit]
                  let {
                    sat_s6Piw [Occ=Once] :: a_a6Lfy
                    [LclId] =
                        [f1_s6Piq x_s6Pis y_s6Pit] \u []
                            case y_s6Pit of {
                              GHC.Base.Nothing -> x_s6Pis;
                              GHC.Base.Just x1_s6Piv [Occ=Once] -> f1_s6Piq x1_s6Piv x_s6Pis;
                            };
                  } in  GHC.Base.Just [sat_s6Piw];
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6Pip
                  Data.Foldable.$fFoldableM3
                  sat_s6Pix
                  xs_s6Pir
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6Piz [Occ=Once] -> v_s6Piz;
          };

Data.Foldable.$fFoldableM4
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual
          (Data.Semigroup.Internal.Endo (b -> b)))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$fFoldableM1_$cfoldr'
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a b. (a -> b -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PiA f1_s6PiB z0_s6PiC xs_s6PiD]
        let {
          sat_s6PiI [Occ=Once]
            :: a_a6LeW
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6LeX -> b_a6LeX))
          [LclId] =
              [f1_s6PiB] \r [x_s6PiE y_s6PiF z_s6PiG]
                  case f1_s6PiB x_s6PiE z_s6PiG of vx_s6PiH {
                    __DEFAULT -> y_s6PiF vx_s6PiH;
                  };
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6PiA
              Data.Foldable.$fFoldableM4
              sat_s6PiI
              xs_s6PiD
              GHC.Base.id
              z0_s6PiC;

Data.Foldable.$fFoldableM1_$cfold
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall m. GHC.Base.Monoid m => GHC.Generics.M1 i c f m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PiJ $dMonoid_s6PiK ds_s6PiL]
        Data.Foldable.foldMap
            $dFoldable_s6PiJ $dMonoid_s6PiK GHC.Base.id ds_s6PiL;

Data.Foldable.$fFoldableM1_$cproduct
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PiM $dNum_s6PiN]
        let {
          $dMonoid_s6PiO [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LgJ)
          [LclId] =
              [$dNum_s6PiN] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6PiN; } in
        let {
          sat_s6PiQ [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ
               -> Data.Semigroup.Internal.Product a_a6LgJ
          [LclId] =
              [$dFoldable_s6PiM $dMonoid_s6PiO] \r [ds_s6PiP]
                  Data.Foldable.foldMap
                      $dFoldable_s6PiM
                      $dMonoid_s6PiO
                      Data.Foldable.$fFoldable:*:1
                      ds_s6PiP;
        } in  sat_s6PiQ;

Data.Foldable.$fFoldableM1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.M1 i c f a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PiR eta_s6PiS]
        Data.Foldable.foldr
            $dFoldable_s6PiR GHC.Types.: GHC.Types.[] eta_s6PiS;

Data.Foldable.$fFoldableM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     Data.Foldable.Foldable (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6PiT]
        let {
          sat_s6Pjg [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cproduct $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pjf [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$csum $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pje [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cminimum $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pjd [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cmaximum $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pjc [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$celem
                      $dFoldable_s6PiT eta_B2 eta_B1; } in
        let {
          sat_s6Pjb [Occ=Once]
            :: forall a.
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$clength $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pja [Occ=Once]
            :: forall a.
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6PiT] \r [ds_s6Pj9]
                  Data.Foldable.null $dFoldable_s6PiT ds_s6Pj9; } in
        let {
          sat_s6Pj8 [Occ=Once]
            :: forall a. GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> [a]
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$ctoList $dFoldable_s6PiT eta_B1; } in
        let {
          sat_s6Pj7 [Occ=Once]
            :: forall a.
               (a -> a -> a) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl1
                      $dFoldable_s6PiT eta_B2 eta_B1; } in
        let {
          sat_s6Pj6 [Occ=Once]
            :: forall a.
               (a -> a -> a) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldr1
                      $dFoldable_s6PiT eta_B2 eta_B1; } in
        let {
          sat_s6Pj5 [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl'
                      $dFoldable_s6PiT eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pj4 [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl
                      $dFoldable_s6PiT eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pj3 [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldr'
                      $dFoldable_s6PiT eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pj2 [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6PiT] \r [f1_s6PiZ z_s6Pj0 ds_s6Pj1]
                  Data.Foldable.foldr
                      $dFoldable_s6PiT f1_s6PiZ z_s6Pj0 ds_s6Pj1; } in
        let {
          sat_s6PiY [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> m
          [LclId] =
              [$dFoldable_s6PiT] \r [$dMonoid_s6PiV f1_s6PiW ds_s6PiX]
                  Data.Foldable.foldMap
                      $dFoldable_s6PiT $dMonoid_s6PiV f1_s6PiW ds_s6PiX; } in
        let {
          sat_s6PiU [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 m -> m
          [LclId] =
              [$dFoldable_s6PiT] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfold $dFoldable_s6PiT eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6PiU
                                    sat_s6PiY
                                    sat_s6Pj2
                                    sat_s6Pj3
                                    sat_s6Pj4
                                    sat_s6Pj5
                                    sat_s6Pj6
                                    sat_s6Pj7
                                    sat_s6Pj8
                                    sat_s6Pja
                                    sat_s6Pjb
                                    sat_s6Pjc
                                    sat_s6Pjd
                                    sat_s6Pje
                                    sat_s6Pjf
                                    sat_s6Pjg];

Data.Foldable.$fFoldableK1_$celem
  :: forall i c a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.K1 i c a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Pjh eta_s6Pji eta1_s6Pjj] GHC.Types.False [];

Data.Foldable.$fFoldableK1_$csum
  :: forall i c a. GHC.Num.Num a => GHC.Generics.K1 i c a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pjk ds_s6Pjl]
        Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Pjk;

Data.Foldable.$fFoldableK1_$cminimum
  :: forall i c a. GHC.Classes.Ord a => GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Pjm eta_s6Pjn]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableK1_$cmaximum
  :: forall i c a. GHC.Classes.Ord a => GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Pjo eta_s6Pjp]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableK1_$cfoldl
  :: forall i c b a. (b -> a -> b) -> b -> GHC.Generics.K1 i c a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6Pjq z_s6Pjr t_s6Pjs] z_s6Pjr;

Data.Foldable.$fFoldableK6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK7;

Data.Foldable.$fFoldableK1_$cfoldl1
  :: forall i c a. (a -> a -> a) -> GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pjt xs_s6Pju]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableK1_$cfoldr'
  :: forall i c a b. (a -> b -> b) -> b -> GHC.Generics.K1 i c a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6Pjv z0_s6Pjw xs_s6Pjx] z0_s6Pjw;

Data.Foldable.$fFoldableK1_$clength
  :: forall i c a. GHC.Generics.K1 i c a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6Pjy] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableK8 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK9;

Data.Foldable.$fFoldableK1_$cfoldr1
  :: forall i c a. (a -> a -> a) -> GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pjz xs_s6PjA]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableK1_$cnull
  :: forall i c a. GHC.Generics.K1 i c a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t_s6PjB] GHC.Types.True [];

Data.Foldable.$fFoldableK1_$cfold
  :: forall i c m. GHC.Base.Monoid m => GHC.Generics.K1 i c m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6PjC ds_s6PjD] GHC.Base.mempty $dMonoid_s6PjC;

Data.Foldable.$fFoldableK1_$cproduct
  :: forall i c a. GHC.Num.Num a => GHC.Generics.K1 i c a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PjE ds_s6PjF]
        Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6PjE;

Data.Foldable.$fFoldableK1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall i c a. GHC.Generics.K1 i c a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6PjG] [] [];

Data.Foldable.$fFoldableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Data.Foldable.Foldable (GHC.Generics.K1 i c)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableK1_$cfold
                                             Data.Foldable.$fFoldableK1_$cfoldMap
                                             Data.Foldable.$fFoldableK1_$cfoldr'
                                             Data.Foldable.$fFoldableK1_$cfoldr'
                                             Data.Foldable.$fFoldableK1_$cfoldl
                                             Data.Foldable.$fFoldableK1_$cfoldl
                                             Data.Foldable.$fFoldableK1_$cfoldr1
                                             Data.Foldable.$fFoldableK1_$cfoldl1
                                             Data.Foldable.$fFoldableK1_$ctoList
                                             Data.Foldable.$fFoldableK1_$cnull
                                             Data.Foldable.$fFoldableK1_$clength
                                             Data.Foldable.$fFoldableK1_$celem
                                             Data.Foldable.$fFoldableK1_$cmaximum
                                             Data.Foldable.$fFoldableK1_$cminimum
                                             Data.Foldable.$fFoldableK1_$csum
                                             Data.Foldable.$fFoldableK1_$cproduct];

Data.Foldable.$fFoldableRec1_$celem
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.Rec1 f a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PjH $dEq_s6PjI eta_s6PjJ]
        let {
          f1_s6PjK [Occ=OnceL] :: a_a6Lli -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6PjI eta_s6PjJ] \u []
                  GHC.Classes.== $dEq_s6PjI eta_s6PjJ; } in
        let {
          sat_s6PjM [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6Lli -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6PjH f1_s6PjK] \r [ds_s6PjL]
                  Data.Foldable.foldMap
                      $dFoldable_s6PjH
                      Data.Semigroup.Internal.$fMonoidAny
                      f1_s6PjK
                      ds_s6PjL;
        } in  sat_s6PjM;

Data.Foldable.$fFoldableRec1_$csum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PjN $dNum_s6PjO]
        let {
          $dMonoid_s6PjP [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LlM)
          [LclId] =
              [$dNum_s6PjO] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6PjO; } in
        let {
          sat_s6PjR [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlM
               -> Data.Semigroup.Internal.Sum a_a6LlM
          [LclId] =
              [$dFoldable_s6PjN $dMonoid_s6PjP] \r [ds_s6PjQ]
                  Data.Foldable.foldMap
                      $dFoldable_s6PjN
                      $dMonoid_s6PjP
                      Data.Foldable.$fFoldable:*:1
                      ds_s6PjQ;
        } in  sat_s6PjR;

Data.Foldable.$fFoldableRec1_$cminimum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PjS $dOrd_s6PjT]
        let {
          $dMonoid_s6PjU [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6LlC)
          [LclId] =
              [$dOrd_s6PjT] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6PjT; } in
        let {
          sat_s6PjY [Occ=OnceT[0]]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlC -> a_a6LlC
          [LclId] =
              [$dFoldable_s6PjS $dMonoid_s6PjU] \r [x_s6PjV]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6PjS $dMonoid_s6PjU GHC.Base.Just x_s6PjV
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6PjX [Occ=Once] -> v_s6PjX;
                  };
        } in  sat_s6PjY;

Data.Foldable.$fFoldableRec1_$cmaximum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PjZ $dOrd_s6Pk0]
        let {
          $dMonoid_s6Pk1 [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lls)
          [LclId] =
              [$dOrd_s6Pk0] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6Pk0; } in
        let {
          sat_s6Pk5 [Occ=OnceT[0]]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6Lls -> a_a6Lls
          [LclId] =
              [$dFoldable_s6PjZ $dMonoid_s6Pk1] \r [x_s6Pk2]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6PjZ $dMonoid_s6Pk1 GHC.Base.Just x_s6Pk2
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6Pk4 [Occ=Once] -> v_s6Pk4;
                  };
        } in  sat_s6Pk5;

Data.Foldable.$fFoldable:.:3 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableRec1_$cfoldr1
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pk6 f1_s6Pk7 xs_s6Pk8]
        let {
          sat_s6Pke [Occ=Once]
            :: a_a6LkD -> GHC.Base.Maybe a_a6LkD -> GHC.Base.Maybe a_a6LkD
          [LclId] =
              [f1_s6Pk7] \r [x_s6Pk9 m_s6Pka]
                  let {
                    sat_s6Pkd [Occ=Once] :: a_a6LkD
                    [LclId] =
                        [f1_s6Pk7 x_s6Pk9 m_s6Pka] \u []
                            case m_s6Pka of {
                              GHC.Base.Nothing -> x_s6Pk9;
                              GHC.Base.Just y_s6Pkc [Occ=Once] -> f1_s6Pk7 x_s6Pk9 y_s6Pkc;
                            };
                  } in  GHC.Base.Just [sat_s6Pkd];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6Pk6 sat_s6Pke GHC.Base.Nothing xs_s6Pk8
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
            GHC.Base.Just v_s6Pkg [Occ=Once] -> v_s6Pkg;
          };

Data.Foldable.$fFoldableRec1_$cfoldl'
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pkh f1_s6Pki z0_s6Pkj xs_s6Pkk]
        let {
          sat_s6Pkp [Occ=Once]
            :: a_a6Lku -> (b_a6Lkt -> b_a6Lkt) -> b_a6Lkt -> b_a6Lkt
          [LclId] =
              [f1_s6Pki] \r [x_s6Pkl k_s6Pkm z_s6Pkn]
                  case f1_s6Pki z_s6Pkn x_s6Pkl of vx_s6Pko {
                    __DEFAULT -> k_s6Pkm vx_s6Pko;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6Pkh sat_s6Pkp GHC.Base.id xs_s6Pkk z0_s6Pkj;

Data.Foldable.$fFoldableRec1_$clength
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.Rec1 f a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pkq eta_s6Pkr]
        Data.Foldable.foldr
            $dFoldable_s6Pkq
            Data.Foldable.$fFoldableM2
            GHC.Base.id
            eta_s6Pkr
            Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableRec1_$cfoldl
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pks f1_s6Pkt z_s6Pku t_s6Pkv]
        let {
          sat_s6Pky [Occ=Once]
            :: a_a6Lkk
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6Lkj)
          [LclId] =
              [f1_s6Pkt] \r [x_s6Pkw y_s6Pkx] f1_s6Pkt y_s6Pkx x_s6Pkw;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pks
              Data.Foldable.$fFoldable:*:7
              sat_s6Pky
              t_s6Pkv
              z_s6Pku;

Data.Foldable.$fFoldable:.:2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableRec1_$cfoldl1
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pkz f1_s6PkA xs_s6PkB]
        let {
          sat_s6PkH [Occ=Once]
            :: a_a6LkL
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LkL))
          [LclId] =
              [f1_s6PkA] \r [x_s6PkC y_s6PkD]
                  let {
                    sat_s6PkG [Occ=Once] :: a_a6LkL
                    [LclId] =
                        [f1_s6PkA x_s6PkC y_s6PkD] \u []
                            case y_s6PkD of {
                              GHC.Base.Nothing -> x_s6PkC;
                              GHC.Base.Just x1_s6PkF [Occ=Once] -> f1_s6PkA x1_s6PkF x_s6PkC;
                            };
                  } in  GHC.Base.Just [sat_s6PkG];
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6Pkz
                  Data.Foldable.$fFoldableM3
                  sat_s6PkH
                  xs_s6PkB
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
            GHC.Base.Just v_s6PkJ [Occ=Once] -> v_s6PkJ;
          };

Data.Foldable.$fFoldableRec1_$cfoldr'
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a b. (a -> b -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PkK f1_s6PkL z0_s6PkM xs_s6PkN]
        let {
          sat_s6PkS [Occ=Once]
            :: a_a6Lk9
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6Lka -> b_a6Lka))
          [LclId] =
              [f1_s6PkL] \r [x_s6PkO y_s6PkP z_s6PkQ]
                  case f1_s6PkL x_s6PkO z_s6PkQ of vx_s6PkR {
                    __DEFAULT -> y_s6PkP vx_s6PkR;
                  };
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6PkK
              Data.Foldable.$fFoldableM4
              sat_s6PkS
              xs_s6PkN
              GHC.Base.id
              z0_s6PkM;

Data.Foldable.$fFoldableRec1_$cfold
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall m. GHC.Base.Monoid m => GHC.Generics.Rec1 f m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PkT $dMonoid_s6PkU ds_s6PkV]
        Data.Foldable.foldMap
            $dFoldable_s6PkT $dMonoid_s6PkU GHC.Base.id ds_s6PkV;

Data.Foldable.$fFoldableRec1_$cproduct
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PkW $dNum_s6PkX]
        let {
          $dMonoid_s6PkY [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LlW)
          [LclId] =
              [$dNum_s6PkX] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6PkX; } in
        let {
          sat_s6Pl0 [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlW
               -> Data.Semigroup.Internal.Product a_a6LlW
          [LclId] =
              [$dFoldable_s6PkW $dMonoid_s6PkY] \r [ds_s6PkZ]
                  Data.Foldable.foldMap
                      $dFoldable_s6PkW
                      $dMonoid_s6PkY
                      Data.Foldable.$fFoldable:*:1
                      ds_s6PkZ;
        } in  sat_s6Pl0;

Data.Foldable.$fFoldableRec1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.Rec1 f a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pl1 eta_s6Pl2]
        Data.Foldable.foldr
            $dFoldable_s6Pl1 GHC.Types.: GHC.Types.[] eta_s6Pl2;

Data.Foldable.$fFoldableRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     Data.Foldable.Foldable (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6Pl3]
        let {
          sat_s6Plq [Occ=Once]
            :: forall a. GHC.Num.Num a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cproduct
                      $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Plp [Occ=Once]
            :: forall a. GHC.Num.Num a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$csum $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Plo [Occ=Once]
            :: forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cminimum
                      $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Pln [Occ=Once]
            :: forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cmaximum
                      $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Plm [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$celem
                      $dFoldable_s6Pl3 eta_B2 eta_B1; } in
        let {
          sat_s6Pll [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$clength $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Plk [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Pl3] \r [ds_s6Plj]
                  Data.Foldable.null $dFoldable_s6Pl3 ds_s6Plj; } in
        let {
          sat_s6Pli [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> [a]
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$ctoList $dFoldable_s6Pl3 eta_B1; } in
        let {
          sat_s6Plh [Occ=Once]
            :: forall a. (a -> a -> a) -> GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl1
                      $dFoldable_s6Pl3 eta_B2 eta_B1; } in
        let {
          sat_s6Plg [Occ=Once]
            :: forall a. (a -> a -> a) -> GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldr1
                      $dFoldable_s6Pl3 eta_B2 eta_B1; } in
        let {
          sat_s6Plf [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl'
                      $dFoldable_s6Pl3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Ple [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl
                      $dFoldable_s6Pl3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Pld [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldr'
                      $dFoldable_s6Pl3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Plc [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6Pl3] \r [f1_s6Pl9 z_s6Pla ds_s6Plb]
                  Data.Foldable.foldr
                      $dFoldable_s6Pl3 f1_s6Pl9 z_s6Pla ds_s6Plb; } in
        let {
          sat_s6Pl8 [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> GHC.Generics.Rec1 f_a6Ljm a -> m
          [LclId] =
              [$dFoldable_s6Pl3] \r [$dMonoid_s6Pl5 f1_s6Pl6 ds_s6Pl7]
                  Data.Foldable.foldMap
                      $dFoldable_s6Pl3 $dMonoid_s6Pl5 f1_s6Pl6 ds_s6Pl7; } in
        let {
          sat_s6Pl4 [Occ=Once]
            :: forall m. GHC.Base.Monoid m => GHC.Generics.Rec1 f_a6Ljm m -> m
          [LclId] =
              [$dFoldable_s6Pl3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfold $dFoldable_s6Pl3 eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6Pl4
                                    sat_s6Pl8
                                    sat_s6Plc
                                    sat_s6Pld
                                    sat_s6Ple
                                    sat_s6Plf
                                    sat_s6Plg
                                    sat_s6Plh
                                    sat_s6Pli
                                    sat_s6Plk
                                    sat_s6Pll
                                    sat_s6Plm
                                    sat_s6Pln
                                    sat_s6Plo
                                    sat_s6Plp
                                    sat_s6Plq];

Data.Foldable.$fFoldablePar1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.Par1 a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Plr eta_s6Pls]
        let {
          f_s6Plt [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LnB -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Plr eta_s6Pls] \u []
                  GHC.Classes.== $dEq_s6Plr eta_s6Pls; } in
        let {
          sat_s6Plv [Occ=OnceT[0]]
            :: GHC.Generics.Par1 a_a6LnB -> GHC.Types.Bool
          [LclId] =
              [f_s6Plt] \r [ds_s6Plu] f_s6Plt ds_s6Plu;
        } in  sat_s6Plv;

Data.Foldable.$fFoldablePar2
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Plw eta_s6Plx] eta_s6Plx;

Data.Foldable.$fFoldablePar3
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6Ply x_s6Plz] x_s6Plz;

Data.Foldable.$fFoldablePar4
  :: forall a.
     (a -> a -> a) -> GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6PlA xs_s6PlB] xs_s6PlB;

Data.Foldable.$fFoldablePar1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.Par1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6PlC z0_s6PlD xs_s6PlE] f_s6PlC z0_s6PlD xs_s6PlE;

Data.Foldable.$fFoldablePar1_$clength
  :: forall a. GHC.Generics.Par1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6PlF] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldablePar5
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.Par1 m -> GHC.Generics.Par1 m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6PlG ds_s6PlH] ds_s6PlH;

Data.Foldable.$fFoldablePar1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.Par1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_s6PlI] : [eta_s6PlI GHC.Types.[]];

Data.Foldable.$fFoldablePar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.Par1
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldablePar5
                                             Data.Foldable.$fFoldablePar1_$cfoldMap
                                             Data.Foldable.$fFoldablePar1_$cfoldr
                                             Data.Foldable.$fFoldablePar1_$cfoldr
                                             Data.Foldable.$fFoldablePar1_$cfoldl'
                                             Data.Foldable.$fFoldablePar1_$cfoldl'
                                             Data.Foldable.$fFoldablePar4
                                             Data.Foldable.$fFoldablePar4
                                             Data.Foldable.$fFoldablePar1_$ctoList
                                             Data.Foldable.$fFoldablePar1_$cnull
                                             Data.Foldable.$fFoldablePar1_$clength
                                             Data.Foldable.$fFoldablePar1_$celem
                                             Data.Foldable.$fFoldablePar3
                                             Data.Foldable.$fFoldablePar3
                                             Data.Foldable.$fFoldablePar2
                                             Data.Foldable.$fFoldablePar2];

Data.Foldable.$fFoldableV1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.V1 a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6PlJ eta_s6PlK eta1_s6PlL] GHC.Types.False [];

Data.Foldable.$fFoldableV1_$csum
  :: forall a. GHC.Num.Num a => GHC.Generics.V1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PlM ds_s6PlN]
        Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6PlM;

Data.Foldable.$fFoldableV1_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6PlO eta_s6PlP]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableV1_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6PlQ eta_s6PlR]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableV1_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.V1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6PlS z_s6PlT t_s6PlU] z_s6PlT;

Data.Foldable.$fFoldableV1_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6PlV xs_s6PlW]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableV1_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.V1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6PlX z0_s6PlY xs_s6PlZ] z0_s6PlY;

Data.Foldable.$fFoldableV1_$clength
  :: forall a. GHC.Generics.V1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6Pm0] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableV1_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Pm1 xs_s6Pm2]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableV1_$cnull
  :: forall a. GHC.Generics.V1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t_s6Pm3] GHC.Types.True [];

Data.Foldable.$fFoldableV1_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Generics.V1 m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pm4 ds_s6Pm5] GHC.Base.mempty $dMonoid_s6Pm4;

Data.Foldable.$fFoldableV1_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Generics.V1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pm6 ds_s6Pm7]
        Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Pm6;

Data.Foldable.$fFoldableV1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.V1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6Pm8] [] [];

Data.Foldable.$fFoldableV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.V1
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableV1_$cfold
                                             Data.Foldable.$fFoldableV1_$cfoldMap
                                             Data.Foldable.$fFoldableV1_$cfoldr'
                                             Data.Foldable.$fFoldableV1_$cfoldr'
                                             Data.Foldable.$fFoldableV1_$cfoldl
                                             Data.Foldable.$fFoldableV1_$cfoldl
                                             Data.Foldable.$fFoldableV1_$cfoldr1
                                             Data.Foldable.$fFoldableV1_$cfoldl1
                                             Data.Foldable.$fFoldableV1_$ctoList
                                             Data.Foldable.$fFoldableV1_$cnull
                                             Data.Foldable.$fFoldableV1_$clength
                                             Data.Foldable.$fFoldableV1_$celem
                                             Data.Foldable.$fFoldableV1_$cmaximum
                                             Data.Foldable.$fFoldableV1_$cminimum
                                             Data.Foldable.$fFoldableV1_$csum
                                             Data.Foldable.$fFoldableV1_$cproduct];

Data.Foldable.$fFoldableArray_$cfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall i m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Arr.Array i a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><L,C(U)><S(LLSL),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pm9 f_s6Pma eta_s6Pmb]
        case eta_s6Pmb of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6Pmf [Occ=OnceL]
                        ww4_s6Pmg [Occ=OnceL] ->
              let {
                w1_s6Pmh [Occ=OnceL] :: m_a6LGY
                [LclId] =
                    [$dMonoid_s6Pm9] \u [] GHC.Base.mempty $dMonoid_s6Pm9; } in
              let {
                $wgo_s6Pmi [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: GHC.Prim.Int# -> m_a6LGY
                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                    sat-only [$dMonoid_s6Pm9
                              f_s6Pma
                              ww3_s6Pmf
                              ww4_s6Pmg
                              w1_s6Pmh
                              $wgo_s6Pmi] \r [ww7_s6Pmj]
                        case ==# [ww7_s6Pmj ww3_s6Pmf] of {
                          __DEFAULT ->
                              let {
                                sat_s6Pmq [Occ=Once] :: m_a6LGY
                                [LclId] =
                                    [$wgo_s6Pmi ww7_s6Pmj] \u []
                                        case +# [ww7_s6Pmj 1#] of sat_s6Pmp {
                                          __DEFAULT -> $wgo_s6Pmi sat_s6Pmp;
                                        }; } in
                              let {
                                sat_s6Pmo [Occ=Once] :: m_a6LGY
                                [LclId] =
                                    [f_s6Pma ww4_s6Pmg ww7_s6Pmj] \u []
                                        let {
                                          sat_s6Pmn [Occ=Once] :: a_a6LGZ
                                          [LclId] =
                                              [ww4_s6Pmg ww7_s6Pmj] \u []
                                                  case indexArray# [ww4_s6Pmg ww7_s6Pmj] of {
                                                    Unit# ipv_s6Pmm [Occ=Once] -> ipv_s6Pmm;
                                                  };
                                        } in  f_s6Pma sat_s6Pmn;
                              } in  GHC.Base.mappend $dMonoid_s6Pm9 sat_s6Pmo sat_s6Pmq;
                          1# -> w1_s6Pmh;
                        };
              } in  $wgo_s6Pmi 0#;
        };

Data.Foldable.$fFoldableArray1
  :: forall i a.
     GHC.Num.Num a =>
     GHC.Arr.Array i a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pmr]
        let {
          w1_s6Pms [Occ=OnceL] :: a_a6LJu
          [LclId] =
              [$dNum_s6Pmr] \u []
                  GHC.Num.fromInteger
                      $dNum_s6Pmr Data.Semigroup.Internal.$fMonoidProduct1; } in
        let {
          sat_s6PmH [Occ=OnceT[0]]
            :: GHC.Arr.Array i_a6LGK a_a6LJu
               -> Data.Semigroup.Internal.Product a_a6LJu
          [LclId] =
              [$dNum_s6Pmr w1_s6Pms] \r [w2_s6Pmt]
                  case w2_s6Pmt of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6Pmx [Occ=OnceL]
                                  ww4_s6Pmy [Occ=OnceL] ->
                        let {
                          $wgo_s6Pmz [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Product a_a6LJu
                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6Pmr
                                        w1_s6Pms
                                        ww3_s6Pmx
                                        ww4_s6Pmy
                                        $wgo_s6Pmz] \r [ww7_s6PmA]
                                  case ==# [ww7_s6PmA ww3_s6Pmx] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6PmG [Occ=Once] :: a_a6LJu
                                          [LclId] =
                                              [$wgo_s6Pmz ww7_s6PmA] \u []
                                                  case +# [ww7_s6PmA 1#] of sat_s6PmF {
                                                    __DEFAULT -> $wgo_s6Pmz sat_s6PmF;
                                                  }; } in
                                        let {
                                          sat_s6PmE [Occ=Once] :: a_a6LJu
                                          [LclId] =
                                              [ww4_s6Pmy ww7_s6PmA] \u []
                                                  case indexArray# [ww4_s6Pmy ww7_s6PmA] of {
                                                    Unit# ipv_s6PmD [Occ=Once] -> ipv_s6PmD;
                                                  };
                                        } in  GHC.Num.* $dNum_s6Pmr sat_s6PmE sat_s6PmG;
                                    1# -> w1_s6Pms;
                                  };
                        } in  $wgo_s6Pmz 0#;
                  };
        } in  sat_s6PmH;

Data.Foldable.$w$cfold [InlPrag=NOUSERINLINE[0]]
  :: forall i m.
     GHC.Base.Monoid m =>
     GHC.Prim.Int# -> GHC.Prim.Array# m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6PmI ww_s6PmJ ww1_s6PmK]
        let {
          w1_s6PmL [Occ=OnceL] :: m_s6NXp
          [LclId] =
              [w_s6PmI] \u [] GHC.Base.mempty w_s6PmI; } in
        let {
          $wgo_s6PmM [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> m_s6NXp
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6PmI
                        ww_s6PmJ
                        ww1_s6PmK
                        w1_s6PmL
                        $wgo_s6PmM] \r [ww2_s6PmN]
                  case ==# [ww2_s6PmN ww_s6PmJ] of {
                    __DEFAULT ->
                        let {
                          sat_s6PmT [Occ=Once] :: m_s6NXp
                          [LclId] =
                              [$wgo_s6PmM ww2_s6PmN] \u []
                                  case +# [ww2_s6PmN 1#] of sat_s6PmS {
                                    __DEFAULT -> $wgo_s6PmM sat_s6PmS;
                                  }; } in
                        let {
                          sat_s6PmR [Occ=Once] :: m_s6NXp
                          [LclId] =
                              [ww1_s6PmK ww2_s6PmN] \u []
                                  case indexArray# [ww1_s6PmK ww2_s6PmN] of {
                                    Unit# ipv_s6PmQ [Occ=Once] -> ipv_s6PmQ;
                                  };
                        } in  GHC.Base.mappend w_s6PmI sat_s6PmR sat_s6PmT;
                    1# -> w1_s6PmL;
                  };
        } in  $wgo_s6PmM 0#;

Data.Foldable.$fFoldableArray_$cfold [InlPrag=NOUSERINLINE[0]]
  :: forall i m. GHC.Base.Monoid m => GHC.Arr.Array i m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,U,C(C1(U)),A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PmU w1_s6PmV]
        case w1_s6PmV of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6PmZ [Occ=Once]
                        ww4_s6Pn0 [Occ=Once] ->
              Data.Foldable.$w$cfold w_s6PmU ww3_s6PmZ ww4_s6Pn0;
        };

Data.Foldable.$w$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall i a.
     GHC.Classes.Ord a =>
     GHC.Prim.Int# -> GHC.Prim.Array# a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pn1 ww_s6Pn2 ww1_s6Pn3]
        let {
          $wgo_s6Pn4 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> Data.Functor.Utils.Max a_s6NXH
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6Pn1 ww_s6Pn2 ww1_s6Pn3 $wgo_s6Pn4] \r [ww2_s6Pn5]
                  case ==# [ww2_s6Pn5 ww_s6Pn2] of {
                    __DEFAULT ->
                        let {
                          x_s6Pn7 :: a_s6NXH
                          [LclId] =
                              [ww1_s6Pn3 ww2_s6Pn5] \u []
                                  case indexArray# [ww1_s6Pn3 ww2_s6Pn5] of {
                                    Unit# ipv_s6Pn9 [Occ=Once] -> ipv_s6Pn9;
                                  };
                        } in 
                          case +# [ww2_s6Pn5 1#] of sat_s6Pna {
                            __DEFAULT ->
                                case $wgo_s6Pn4 sat_s6Pna of wild_s6Pnb {
                                  GHC.Base.Nothing -> GHC.Base.Just [x_s6Pn7];
                                  GHC.Base.Just ipv_s6Pnc [Occ=Once] ->
                                      case GHC.Classes.>= w_s6Pn1 x_s6Pn7 ipv_s6Pnc of {
                                        GHC.Types.False -> wild_s6Pnb;
                                        GHC.Types.True -> GHC.Base.Just [x_s6Pn7];
                                      };
                                };
                          };
                    1# -> GHC.Base.Nothing [];
                  };
        } in 
          case $wgo_s6Pn4 0# of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
            GHC.Base.Just v_s6Pnf [Occ=Once] -> v_s6Pnf;
          };

Data.Foldable.$fFoldableArray_$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. GHC.Classes.Ord a => GHC.Arr.Array i a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Png w1_s6Pnh]
        case w1_s6Pnh of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6Pnl [Occ=Once]
                        ww4_s6Pnm [Occ=Once] ->
              Data.Foldable.$w$cmaximum w_s6Png ww3_s6Pnl ww4_s6Pnm;
        };

Data.Foldable.$w$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall i a.
     GHC.Classes.Ord a =>
     GHC.Prim.Int# -> GHC.Prim.Array# a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pnn ww_s6Pno ww1_s6Pnp]
        let {
          $wgo_s6Pnq [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> Data.Functor.Utils.Min a_s6NXZ
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6Pnn ww_s6Pno ww1_s6Pnp $wgo_s6Pnq] \r [ww2_s6Pnr]
                  case ==# [ww2_s6Pnr ww_s6Pno] of {
                    __DEFAULT ->
                        let {
                          x_s6Pnt :: a_s6NXZ
                          [LclId] =
                              [ww1_s6Pnp ww2_s6Pnr] \u []
                                  case indexArray# [ww1_s6Pnp ww2_s6Pnr] of {
                                    Unit# ipv_s6Pnv [Occ=Once] -> ipv_s6Pnv;
                                  };
                        } in 
                          case +# [ww2_s6Pnr 1#] of sat_s6Pnw {
                            __DEFAULT ->
                                case $wgo_s6Pnq sat_s6Pnw of wild_s6Pnx {
                                  GHC.Base.Nothing -> GHC.Base.Just [x_s6Pnt];
                                  GHC.Base.Just ipv_s6Pny [Occ=Once] ->
                                      case GHC.Classes.<= w_s6Pnn x_s6Pnt ipv_s6Pny of {
                                        GHC.Types.False -> wild_s6Pnx;
                                        GHC.Types.True -> GHC.Base.Just [x_s6Pnt];
                                      };
                                };
                          };
                    1# -> GHC.Base.Nothing [];
                  };
        } in 
          case $wgo_s6Pnq 0# of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
            GHC.Base.Just v_s6PnB [Occ=Once] -> v_s6PnB;
          };

Data.Foldable.$fFoldableArray_$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. GHC.Classes.Ord a => GHC.Arr.Array i a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PnC w1_s6PnD]
        case w1_s6PnD of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6PnH [Occ=Once]
                        ww4_s6PnI [Occ=Once] ->
              Data.Foldable.$w$cminimum w_s6PnC ww3_s6PnH ww4_s6PnI;
        };

Data.Foldable.$fFoldableArray2
  :: forall i a.
     GHC.Num.Num a =>
     GHC.Arr.Array i a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PnJ]
        let {
          w1_s6PnK [Occ=OnceL] :: a_a6LJk
          [LclId] =
              [$dNum_s6PnJ] \u []
                  GHC.Num.fromInteger
                      $dNum_s6PnJ Data.Semigroup.Internal.$fMonoidSum1; } in
        let {
          sat_s6PnZ [Occ=OnceT[0]]
            :: GHC.Arr.Array i_X6LX9 a_a6LJk
               -> Data.Semigroup.Internal.Sum a_a6LJk
          [LclId] =
              [$dNum_s6PnJ w1_s6PnK] \r [w2_s6PnL]
                  case w2_s6PnL of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6PnP [Occ=OnceL]
                                  ww4_s6PnQ [Occ=OnceL] ->
                        let {
                          $wgo_s6PnR [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Sum a_a6LJk
                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6PnJ
                                        w1_s6PnK
                                        ww3_s6PnP
                                        ww4_s6PnQ
                                        $wgo_s6PnR] \r [ww7_s6PnS]
                                  case ==# [ww7_s6PnS ww3_s6PnP] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6PnY [Occ=Once] :: a_a6LJk
                                          [LclId] =
                                              [$wgo_s6PnR ww7_s6PnS] \u []
                                                  case +# [ww7_s6PnS 1#] of sat_s6PnX {
                                                    __DEFAULT -> $wgo_s6PnR sat_s6PnX;
                                                  }; } in
                                        let {
                                          sat_s6PnW [Occ=Once] :: a_a6LJk
                                          [LclId] =
                                              [ww4_s6PnQ ww7_s6PnS] \u []
                                                  case indexArray# [ww4_s6PnQ ww7_s6PnS] of {
                                                    Unit# ipv_s6PnV [Occ=Once] -> ipv_s6PnV;
                                                  };
                                        } in  GHC.Num.+ $dNum_s6PnJ sat_s6PnW sat_s6PnY;
                                    1# -> w1_s6PnK;
                                  };
                        } in  $wgo_s6PnR 0#;
                  };
        } in  sat_s6PnZ;

Data.Foldable.$fFoldableArray_$celem
  :: forall i a.
     GHC.Classes.Eq a =>
     a -> GHC.Arr.Array i a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Po0 eta_s6Po1]
        let {
          f_s6Po2 [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LIQ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Po0 eta_s6Po1] \u []
                  GHC.Classes.== $dEq_s6Po0 eta_s6Po1; } in
        let {
          sat_s6Poh [Occ=Once]
            :: GHC.Arr.Array i_X6LXe a_a6LIQ -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6Po2] \r [w2_s6Po3]
                  case w2_s6Po3 of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6Po7 [Occ=OnceL]
                                  ww4_s6Po8 [Occ=OnceL] ->
                        let-no-escape {
                          $wgo_s6Po9 [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Any
                          [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [f_s6Po2 ww3_s6Po7 ww4_s6Po8 $wgo_s6Po9] \r [ww7_s6Poa]
                                  case ==# [ww7_s6Poa ww3_s6Po7] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6Poe [Occ=Once] :: a_a6LIQ
                                          [LclId] =
                                              [ww4_s6Po8 ww7_s6Poa] \u []
                                                  case indexArray# [ww4_s6Po8 ww7_s6Poa] of {
                                                    Unit# ipv_s6Pod [Occ=Once] -> ipv_s6Pod;
                                                  };
                                        } in 
                                          case f_s6Po2 sat_s6Poe of {
                                            GHC.Types.False ->
                                                case +# [ww7_s6Poa 1#] of sat_s6Pog {
                                                  __DEFAULT -> $wgo_s6Po9 sat_s6Pog;
                                                };
                                            GHC.Types.True -> GHC.Types.True [];
                                          };
                                    1# -> GHC.Types.False [];
                                  };
                        } in  $wgo_s6Po9 0#;
                  };
        } in  sat_s6Poh;

Data.Foldable.$fFoldableArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Foldable.Foldable (GHC.Arr.Array i)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableArray_$cfold
                                             Data.Foldable.$fFoldableArray_$cfoldMap
                                             GHC.Arr.foldrElems
                                             GHC.Arr.foldrElems'
                                             GHC.Arr.foldlElems
                                             GHC.Arr.foldlElems'
                                             GHC.Arr.foldr1Elems
                                             GHC.Arr.foldl1Elems
                                             GHC.Arr.elems
                                             Data.Foldable.$fFoldableArray_$cnull
                                             GHC.Arr.numElements
                                             Data.Foldable.$fFoldableArray_$celem
                                             Data.Foldable.$fFoldableArray_$cmaximum
                                             Data.Foldable.$fFoldableArray_$cminimum
                                             Data.Foldable.$fFoldableArray2
                                             Data.Foldable.$fFoldableArray1];

Data.Foldable.$fFoldable(,)_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> (a1, a2) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Poi eta_s6Poj]
        let {
          f_s6Pok [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_a6LLd -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Poi eta_s6Poj] \u []
                  GHC.Classes.== $dEq_s6Poi eta_s6Poj; } in
        let {
          sat_s6Pop [Occ=Once]
            :: (a_a6LJD, a1_a6LLd) -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6Pok] \r [ds_s6Pol]
                  case ds_s6Pol of {
                    (,) _ [Occ=Dead] y_s6Poo [Occ=Once] -> f_s6Pok y_s6Poo;
                  };
        } in  sat_s6Pop;

Data.Foldable.$fFoldable(,)2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     (a1, a2) -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Poq eta_s6Por]
        case eta_s6Por of {
          (,) _ [Occ=Dead] y_s6Pou [Occ=Once] -> y_s6Pou;
        };

Data.Foldable.$fFoldable(,)3 :: forall a1 a2. (a2, a1) -> a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [x_s6Pov]
        case x_s6Pov of {
          (,) _ [Occ=Dead] y_s6Poy [Occ=Once] -> y_s6Poy;
        };

Data.Foldable.$fFoldable(,)_$cminimum
  :: forall a1 a2. GHC.Classes.Ord a2 => (a1, a2) -> a2
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Poz eta_B1] Data.Foldable.$fFoldable(,)3 eta_B1;

Data.Foldable.$fFoldable(,)_$cnull
  :: forall a1 a2. (a1, a2) -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6PoA]
        case ds_s6PoA of {
          (,) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldable(,)_$cfoldr1
  :: forall a1 a2. (a2 -> a2 -> a2) -> (a1, a2) -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6PoE xs_s6PoF]
        case xs_s6PoF of {
          (,) _ [Occ=Dead] y_s6PoI [Occ=Once] -> y_s6PoI;
        };

Data.Foldable.$fFoldable(,)_$cfoldl'
  :: forall a1 b a2. (b -> a2 -> b) -> b -> (a1, a2) -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_s6PoJ z0_s6PoK xs_s6PoL]
        case xs_s6PoL of {
          (,) _ [Occ=Dead] y_s6PoO [Occ=Once] -> f_s6PoJ z0_s6PoK y_s6PoO;
        };

Data.Foldable.$fFoldable(,)_$clength
  :: forall a1 a2. (a1, a2) -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6PoP]
        case xs_s6PoP of {
          (,) _ [Occ=Dead] _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldable(,)_$cfold
  :: forall a m. GHC.Base.Monoid m => (a, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6PoT ds_s6PoU]
        case ds_s6PoU of {
          (,) _ [Occ=Dead] y_s6PoX [Occ=Once] -> y_s6PoX;
        };

Data.Foldable.$fFoldable(,)1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     (a1, a2) -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PoY eta_s6PoZ]
        case eta_s6PoZ of {
          (,) _ [Occ=Dead] y_s6Pp2 [Occ=Once] -> y_s6Pp2;
        };

Data.Foldable.$fFoldable(,)_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. (a1, a2) -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_s6Pp3]
        case eta_s6Pp3 of {
          (,) _ [Occ=Dead] y_s6Pp6 [Occ=Once] -> : [y_s6Pp6 GHC.Types.[]];
        };

Data.Foldable.$fFoldable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable ((,) a)
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldable(,)_$cfold
                                             Data.Foldable.$fFoldable(,)_$cfoldMap
                                             Data.Foldable.$fFoldable(,)_$cfoldr
                                             Data.Foldable.$fFoldable(,)_$cfoldr
                                             Data.Foldable.$fFoldable(,)_$cfoldl'
                                             Data.Foldable.$fFoldable(,)_$cfoldl'
                                             Data.Foldable.$fFoldable(,)_$cfoldr1
                                             Data.Foldable.$fFoldable(,)_$cfoldr1
                                             Data.Foldable.$fFoldable(,)_$ctoList
                                             Data.Foldable.$fFoldable(,)_$cnull
                                             Data.Foldable.$fFoldable(,)_$clength
                                             Data.Foldable.$fFoldable(,)_$celem
                                             Data.Foldable.$fFoldable(,)_$cminimum
                                             Data.Foldable.$fFoldable(,)_$cminimum
                                             Data.Foldable.$fFoldable(,)2
                                             Data.Foldable.$fFoldable(,)1];

Data.Foldable.$fFoldableEither_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> Data.Either.Either a1 a2 -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Pp7 eta_s6Pp8]
        let {
          ds_s6Pp9 [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_a6LND -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Pp7 eta_s6Pp8] \u []
                  GHC.Classes.== $dEq_s6Pp7 eta_s6Pp8; } in
        let {
          sat_s6Ppe [Occ=Once]
            :: Data.Either.Either a_a6LM0 a1_a6LND
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [ds_s6Pp9] \r [ds1_s6Ppa]
                  case ds1_s6Ppa of {
                    Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                    Data.Either.Right y_s6Ppd [Occ=Once] -> ds_s6Pp9 y_s6Ppd;
                  };
        } in  sat_s6Ppe;

Data.Foldable.$fFoldableEither2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Either.Either a1 a2 -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ppf ds_s6Ppg]
        case ds_s6Ppg of {
          Data.Either.Left _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Ppf;
          Data.Either.Right y_s6Ppj [Occ=Once] -> y_s6Ppj;
        };

Data.Foldable.$fFoldableEither3
  :: forall a1 a2. Data.Either.Either a2 a1 -> a1
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Ppk]
        case x_s6Ppk of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:2;
          Data.Either.Right y_s6Ppn [Occ=Once] -> y_s6Ppn;
        };

Data.Foldable.$fFoldableEither_$cminimum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ppo eta_B1] Data.Foldable.$fFoldableEither3 eta_B1;

Data.Foldable.$fFoldableEither4
  :: forall a1 a2. Data.Either.Either a2 a1 -> a1
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Ppp]
        case x_s6Ppp of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:3;
          Data.Either.Right y_s6Pps [Occ=Once] -> y_s6Pps;
        };

Data.Foldable.$fFoldableEither_$cmaximum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ppt eta_B1] Data.Foldable.$fFoldableEither4 eta_B1;

Data.Foldable.$fFoldableEither_$cfoldr1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6Ppu xs_s6Ppv]
        case xs_s6Ppv of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:.:3;
          Data.Either.Right y_s6Ppy [Occ=Once] -> y_s6Ppy;
        };

Data.Foldable.$fFoldableEither_$cfoldl'
  :: forall a1 b a2.
     (b -> a2 -> b) -> b -> Data.Either.Either a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6Ppz z0_s6PpA xs_s6PpB]
        case xs_s6PpB of {
          Data.Either.Left _ [Occ=Dead] -> z0_s6PpA;
          Data.Either.Right y_s6PpE [Occ=Once] -> f_s6Ppz z0_s6PpA y_s6PpE;
        };

Data.Foldable.$fFoldableEither_$cfoldl1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PpF xs_s6PpG]
        case xs_s6PpG of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:.:2;
          Data.Either.Right y_s6PpJ [Occ=Once] -> y_s6PpJ;
        };

Data.Foldable.$fFoldableEither_$cfold
  :: forall a m. GHC.Base.Monoid m => Data.Either.Either a m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6PpK ds_s6PpL]
        case ds_s6PpL of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6PpK;
          Data.Either.Right y_s6PpO [Occ=Once] -> y_s6PpO;
        };

Data.Foldable.$fFoldableEither1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Either.Either a1 a2 -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PpP ds_s6PpQ]
        case ds_s6PpQ of {
          Data.Either.Left _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6PpP;
          Data.Either.Right y_s6PpT [Occ=Once] -> y_s6PpT;
        };

Data.Foldable.$fFoldableEither_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. Data.Either.Either a1 a2 -> [a2]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6PpU]
        case eta_s6PpU of {
          Data.Either.Left _ [Occ=Dead] -> [] [];
          Data.Either.Right y_s6PpX [Occ=Once] -> : [y_s6PpX GHC.Types.[]];
        };

Data.Foldable.$fFoldableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable (Data.Either.Either a)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableEither_$cfold
                                             Data.Foldable.$fFoldableEither_$cfoldMap
                                             Data.Foldable.$fFoldableEither_$cfoldr
                                             Data.Foldable.$fFoldableEither_$cfoldr
                                             Data.Foldable.$fFoldableEither_$cfoldl'
                                             Data.Foldable.$fFoldableEither_$cfoldl'
                                             Data.Foldable.$fFoldableEither_$cfoldr1
                                             Data.Foldable.$fFoldableEither_$cfoldl1
                                             Data.Foldable.$fFoldableEither_$ctoList
                                             Data.Either.isLeft
                                             Data.Foldable.$fFoldableEither_$clength
                                             Data.Foldable.$fFoldableEither_$celem
                                             Data.Foldable.$fFoldableEither_$cmaximum
                                             Data.Foldable.$fFoldableEither_$cminimum
                                             Data.Foldable.$fFoldableEither2
                                             Data.Foldable.$fFoldableEither1];

Data.Foldable.$fFoldableNonEmpty_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6PpY eta_s6PpZ]
        let {
          f_s6Pq0 [Dmd=<L,C(U)>] :: a_a6LQe -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6PpY eta_s6PpZ] \u []
                  GHC.Classes.== $dEq_s6PpY eta_s6PpZ; } in
        let {
          sat_s6Pqg [Occ=OnceT[0]]
            :: GHC.Base.NonEmpty a_a6LQe -> GHC.Types.Bool
          [LclId] =
              [f_s6Pq0] \r [ds_s6Pq1]
                  let {
                    sat_s6Pq5 [Occ=Once] :: a_a6LQe
                    [LclId] =
                        [ds_s6Pq1] \u []
                            case ds_s6Pq1 of {
                              GHC.Base.:| a1_s6Pq3 [Occ=Once] _ [Occ=Dead] -> a1_s6Pq3;
                            };
                  } in 
                    case f_s6Pq0 sat_s6Pq5 of {
                      GHC.Types.False ->
                          case ds_s6Pq1 of {
                            GHC.Base.:| _ [Occ=Dead] as_s6Pq9 [Occ=Once] ->
                                let-no-escape {
                                  go_s6Pqa [Occ=LoopBreakerT[1]] :: [a_a6LQe] -> GHC.Types.Bool
                                  [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                      sat-only [f_s6Pq0 go_s6Pqa] \r [ds1_s6Pqb]
                                          case ds1_s6Pqb of {
                                            [] -> GHC.Types.False [];
                                            : y_s6Pqd [Occ=Once] ys_s6Pqe [Occ=Once] ->
                                                case f_s6Pq0 y_s6Pqd of {
                                                  GHC.Types.False -> go_s6Pqa ys_s6Pqe;
                                                  GHC.Types.True -> GHC.Types.True [];
                                                };
                                          };
                                } in  go_s6Pqa as_s6Pq9;
                          };
                      GHC.Types.True -> GHC.Types.True [];
                    };
        } in  sat_s6Pqg;

Data.Foldable.$fFoldableNonEmpty_$csum
  :: forall a. GHC.Num.Num a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Str=<S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,1*C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Pqh ds_s6Pqi]
        let {
          sat_s6Pqx [Occ=Once] :: a_a6LQI
          [LclId] =
              [$dNum_s6Pqh ds_s6Pqi] \u []
                  case ds_s6Pqi of {
                    GHC.Base.:| _ [Occ=Dead] as_s6Pqp [Occ=Once] ->
                        let {
                          z_s6Pqq [Occ=OnceL] :: a_a6LQI
                          [LclId] =
                              [$dNum_s6Pqh] \u []
                                  GHC.Num.fromInteger
                                      $dNum_s6Pqh Data.Semigroup.Internal.$fMonoidSum1; } in
                        let {
                          go_s6Pqr [Occ=LoopBreaker]
                            :: [a_a6LQI] -> Data.Semigroup.Internal.Sum a_a6LQI
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6Pqh z_s6Pqq go_s6Pqr] \r [ds1_s6Pqs]
                                  case ds1_s6Pqs of {
                                    [] -> z_s6Pqq;
                                    : y_s6Pqu [Occ=Once] ys_s6Pqv [Occ=Once] ->
                                        let {
                                          sat_s6Pqw [Occ=Once] :: a_a6LQI
                                          [LclId] =
                                              [go_s6Pqr ys_s6Pqv] \u [] go_s6Pqr ys_s6Pqv;
                                        } in  GHC.Num.+ $dNum_s6Pqh y_s6Pqu sat_s6Pqw;
                                  };
                        } in  go_s6Pqr as_s6Pqp;
                  }; } in
        let {
          sat_s6Pqm [Occ=Once] :: a_a6LQI
          [LclId] =
              [ds_s6Pqi] \u []
                  case ds_s6Pqi of {
                    GHC.Base.:| a1_s6Pqk [Occ=Once] _ [Occ=Dead] -> a1_s6Pqk;
                  };
        } in  GHC.Num.+ $dNum_s6Pqh sat_s6Pqm sat_s6Pqx;

Data.Foldable.$w$cminimum1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Pqy ww_s6Pqz ww1_s6PqA]
        let {
          go_s6PqB [Occ=LoopBreaker]
            :: [a_s6NYC] -> Data.Functor.Utils.Min a_s6NYC
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6Pqy go_s6PqB] \r [ds_s6PqC]
                  case ds_s6PqC of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6PqE ys_s6PqF [Occ=Once] ->
                        case go_s6PqB ys_s6PqF of wild1_s6PqG {
                          GHC.Base.Nothing -> GHC.Base.Just [y_s6PqE];
                          GHC.Base.Just ipv_s6PqH [Occ=Once] ->
                              case GHC.Classes.<= w_s6Pqy y_s6PqE ipv_s6PqH of {
                                GHC.Types.False -> wild1_s6PqG;
                                GHC.Types.True -> GHC.Base.Just [y_s6PqE];
                              };
                        };
                  };
        } in 
          case go_s6PqB ww1_s6PqA of {
            GHC.Base.Nothing -> ww_s6Pqz;
            GHC.Base.Just ipv_s6PqK ->
                case GHC.Classes.<= w_s6Pqy ww_s6Pqz ipv_s6PqK of {
                  GHC.Types.False -> ipv_s6PqK;
                  GHC.Types.True -> ww_s6Pqz;
                };
          };

Data.Foldable.$fFoldableNonEmpty_$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PqM w1_s6PqN]
        case w1_s6PqN of {
          GHC.Base.:| ww1_s6PqP [Occ=Once] ww2_s6PqQ [Occ=Once] ->
              Data.Foldable.$w$cminimum1 w_s6PqM ww1_s6PqP ww2_s6PqQ;
        };

Data.Foldable.$w$cmaximum1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6PqR ww_s6PqS ww1_s6PqT]
        let {
          go_s6PqU [Occ=LoopBreaker]
            :: [a_s6NYM] -> Data.Functor.Utils.Max a_s6NYM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6PqR go_s6PqU] \r [ds_s6PqV]
                  case ds_s6PqV of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6PqX ys_s6PqY [Occ=Once] ->
                        case go_s6PqU ys_s6PqY of wild1_s6PqZ {
                          GHC.Base.Nothing -> GHC.Base.Just [y_s6PqX];
                          GHC.Base.Just ipv_s6Pr0 [Occ=Once] ->
                              case GHC.Classes.>= w_s6PqR y_s6PqX ipv_s6Pr0 of {
                                GHC.Types.False -> wild1_s6PqZ;
                                GHC.Types.True -> GHC.Base.Just [y_s6PqX];
                              };
                        };
                  };
        } in 
          case go_s6PqU ww1_s6PqT of {
            GHC.Base.Nothing -> ww_s6PqS;
            GHC.Base.Just ipv_s6Pr3 ->
                case GHC.Classes.>= w_s6PqR ww_s6PqS ipv_s6Pr3 of {
                  GHC.Types.False -> ipv_s6Pr3;
                  GHC.Types.True -> ww_s6PqS;
                };
          };

Data.Foldable.$fFoldableNonEmpty_$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Pr5 w1_s6Pr6]
        case w1_s6Pr6 of {
          GHC.Base.:| ww1_s6Pr8 [Occ=Once] ww2_s6Pr9 [Occ=Once] ->
              Data.Foldable.$w$cmaximum1 w_s6Pr5 ww1_s6Pr8 ww2_s6Pr9;
        };

Data.Foldable.$fFoldableNonEmpty_$cnull
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Pra] GHC.Types.False [];

Data.Foldable.$w$cfoldr2 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> a -> a) -> a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Prb ww_s6Prc ww1_s6Prd]
        let {
          go_s6Pre [Occ=LoopBreaker] :: [a_s6NYW] -> GHC.Base.Maybe a_s6NYW
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6Prb go_s6Pre] \r [ds_s6Prf]
                  case ds_s6Prf of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6Prh [Occ=Once*] ys_s6Pri [Occ=Once] ->
                        let {
                          sat_s6Prl [Occ=Once] :: a_s6NYW
                          [LclId] =
                              [w_s6Prb go_s6Pre y_s6Prh ys_s6Pri] \u []
                                  case go_s6Pre ys_s6Pri of {
                                    GHC.Base.Nothing -> y_s6Prh;
                                    GHC.Base.Just y1_s6Prk [Occ=Once] -> w_s6Prb y_s6Prh y1_s6Prk;
                                  };
                        } in  GHC.Base.Just [sat_s6Prl];
                  };
        } in 
          case go_s6Pre ww1_s6Prd of {
            GHC.Base.Nothing -> ww_s6Prc;
            GHC.Base.Just y_s6Prn [Occ=Once] -> w_s6Prb ww_s6Prc y_s6Prn;
          };

Data.Foldable.$fFoldableNonEmpty_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> a -> a) -> GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Pro w1_s6Prp]
        case w1_s6Prp of {
          GHC.Base.:| ww1_s6Prr [Occ=Once] ww2_s6Prs [Occ=Once] ->
              Data.Foldable.$w$cfoldr2 w_s6Pro ww1_s6Prr ww2_s6Prs;
        };

Data.Foldable.$w$cfoldl'1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Prt w1_s6Pru ww_s6Prv ww1_s6Prw]
        case w_s6Prt w1_s6Pru ww_s6Prv of vx_s6Prx {
          __DEFAULT ->
              let-no-escape {
                go_s6Pry [Occ=LoopBreakerT[2]] :: [a_s6NZ8] -> b_s6NZ7 -> b_s6NZ7
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [w_s6Prt go_s6Pry] \r [ds_s6Prz eta_s6PrA]
                        case ds_s6Prz of {
                          [] -> eta_s6PrA;
                          : y_s6PrC [Occ=Once] ys_s6PrD [Occ=Once] ->
                              case w_s6Prt eta_s6PrA y_s6PrC of vx1_s6PrE {
                                __DEFAULT -> go_s6Pry ys_s6PrD vx1_s6PrE;
                              };
                        };
              } in  go_s6Pry ww1_s6Prw vx_s6Prx;
        };

Data.Foldable.$fFoldableNonEmpty_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6PrF w1_s6PrG w2_s6PrH]
        case w2_s6PrH of {
          GHC.Base.:| ww1_s6PrJ [Occ=Once] ww2_s6PrK [Occ=Once] ->
              Data.Foldable.$w$cfoldl'1 w_s6PrF w1_s6PrG ww1_s6PrJ ww2_s6PrK;
        };

Data.Foldable.$w$cfoldr'1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6PrL w1_s6PrM ww_s6PrN ww1_s6PrO]
        let {
          sat_s6Ps0 [Occ=Once] :: b_s6NZm -> b_s6NZm
          [LclId] =
              [w_s6PrL ww_s6PrN] \r [z_s6PrZ] w_s6PrL ww_s6PrN z_s6PrZ;
        } in 
          let-no-escape {
            go_s6PrP [Occ=LoopBreakerT[3]]
              :: [a_s6NZl] -> (b_s6NZm -> b_s6NZm) -> b_s6NZm -> b_s6NZm
            [LclId[JoinId(3)],
             Arity=3,
             Str=<S,1*U><C(S),1*C1(U)><L,U>,
             Unf=OtherCon []] =
                sat-only [w_s6PrL go_s6PrP] \r [ds_s6PrQ eta_s6PrR eta1_s6PrS]
                    case ds_s6PrQ of {
                      [] -> eta_s6PrR eta1_s6PrS;
                      : y_s6PrU [Occ=Once] ys_s6PrV [Occ=Once] ->
                          let {
                            sat_s6PrY [Occ=Once] :: b_s6NZm -> b_s6NZm
                            [LclId] =
                                [w_s6PrL eta_s6PrR y_s6PrU] \r [z_s6PrW]
                                    case w_s6PrL y_s6PrU z_s6PrW of vx_s6PrX {
                                      __DEFAULT -> eta_s6PrR vx_s6PrX;
                                    };
                          } in  go_s6PrP ys_s6PrV sat_s6PrY eta1_s6PrS;
                    };
          } in  go_s6PrP ww1_s6PrO sat_s6Ps0 w1_s6PrM;

Data.Foldable.$fFoldableNonEmpty_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Ps1 w1_s6Ps2 w2_s6Ps3]
        case w2_s6Ps3 of {
          GHC.Base.:| ww1_s6Ps5 [Occ=Once] ww2_s6Ps6 [Occ=Once] ->
              Data.Foldable.$w$cfoldr'1 w_s6Ps1 w1_s6Ps2 ww1_s6Ps5 ww2_s6Ps6;
        };

Data.Foldable.$fFoldableNonEmpty_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Str=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,1*C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ps7 ds_s6Ps8]
        let {
          sat_s6Psn [Occ=Once] :: a_a6LQS
          [LclId] =
              [$dNum_s6Ps7 ds_s6Ps8] \u []
                  case ds_s6Ps8 of {
                    GHC.Base.:| _ [Occ=Dead] as_s6Psf [Occ=Once] ->
                        let {
                          z_s6Psg [Occ=OnceL] :: a_a6LQS
                          [LclId] =
                              [$dNum_s6Ps7] \u []
                                  GHC.Num.fromInteger
                                      $dNum_s6Ps7 Data.Semigroup.Internal.$fMonoidProduct1; } in
                        let {
                          go_s6Psh [Occ=LoopBreaker]
                            :: [a_a6LQS] -> Data.Semigroup.Internal.Product a_a6LQS
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6Ps7 z_s6Psg go_s6Psh] \r [ds1_s6Psi]
                                  case ds1_s6Psi of {
                                    [] -> z_s6Psg;
                                    : y_s6Psk [Occ=Once] ys_s6Psl [Occ=Once] ->
                                        let {
                                          sat_s6Psm [Occ=Once] :: a_a6LQS
                                          [LclId] =
                                              [go_s6Psh ys_s6Psl] \u [] go_s6Psh ys_s6Psl;
                                        } in  GHC.Num.* $dNum_s6Ps7 y_s6Psk sat_s6Psm;
                                  };
                        } in  go_s6Psh as_s6Psf;
                  }; } in
        let {
          sat_s6Psc [Occ=Once] :: a_a6LQS
          [LclId] =
              [ds_s6Ps8] \u []
                  case ds_s6Ps8 of {
                    GHC.Base.:| a1_s6Psa [Occ=Once] _ [Occ=Dead] -> a1_s6Psa;
                  };
        } in  GHC.Num.* $dNum_s6Ps7 sat_s6Psc sat_s6Psn;

Data.Foldable.$fFoldableNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Base.NonEmpty
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldMap
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr'
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl'
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr1
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl1
                                             Data.Foldable.$fFoldableNonEmpty_$ctoList
                                             Data.Foldable.$fFoldableNonEmpty_$cnull
                                             Data.Foldable.$fFoldableNonEmpty_$clength
                                             Data.Foldable.$fFoldableNonEmpty_$celem
                                             Data.Foldable.$fFoldableNonEmpty_$cmaximum
                                             Data.Foldable.$fFoldableNonEmpty_$cminimum
                                             Data.Foldable.$fFoldableNonEmpty_$csum
                                             Data.Foldable.$fFoldableNonEmpty_$cproduct];

Data.Foldable.$fFoldableMaybe_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Pso eta_s6Psp]
        let {
          eta1_s6Psq [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LV4 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Pso eta_s6Psp] \u []
                  GHC.Classes.== $dEq_s6Pso eta_s6Psp; } in
        let {
          sat_s6Psu [Occ=Once]
            :: GHC.Base.Maybe a_a6LV4 -> Data.Semigroup.Internal.Any
          [LclId] =
              [eta1_s6Psq] \r [eta2_s6Psr]
                  case eta2_s6Psr of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x_s6Pst [Occ=Once] -> eta1_s6Psq x_s6Pst;
                  };
        } in  sat_s6Psu;

Data.Foldable.$fFoldableMaybe2
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Maybe a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Psv eta_s6Psw]
        case eta_s6Psw of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Psv;
          GHC.Base.Just x_s6Psy [Occ=Once] -> x_s6Psy;
        };

Data.Foldable.$fFoldableMaybe3 :: forall a. GHC.Base.Maybe a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Psz]
        case x_s6Psz of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6PsB [Occ=Once] -> v_s6PsB;
        };

Data.Foldable.$fFoldableMaybe_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6PsC eta_B1] Data.Foldable.$fFoldableMaybe3 eta_B1;

Data.Foldable.$fFoldableMaybe4 :: forall a. GHC.Base.Maybe a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6PsD]
        case x_s6PsD of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6PsF [Occ=Once] -> v_s6PsF;
        };

Data.Foldable.$fFoldableMaybe_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6PsG eta_B1] Data.Foldable.$fFoldableMaybe4 eta_B1;

Data.Foldable.$fFoldableMaybe_$cnull
  :: forall a. GHC.Base.Maybe a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6PsH]
        case ds_s6PsH of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableMaybe_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PsK xs_s6PsL]
        case xs_s6PsL of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just v_s6PsN [Occ=Once] -> v_s6PsN;
        };

Data.Foldable.$fFoldableMaybe_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PsO xs_s6PsP]
        case xs_s6PsP of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just v_s6PsR [Occ=Once] -> v_s6PsR;
        };

Data.Foldable.$fFoldableMaybe_$clength
  :: forall a. GHC.Base.Maybe a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6PsS]
        case xs_s6PsS of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableMaybe_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Base.Maybe m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6PsV eta_s6PsW]
        case eta_s6PsW of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6PsV;
          GHC.Base.Just x_s6PsY [Occ=Once] -> x_s6PsY;
        };

Data.Foldable.$fFoldableMaybe1
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Maybe a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PsZ eta_s6Pt0]
        case eta_s6Pt0 of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6PsZ;
          GHC.Base.Just x_s6Pt2 [Occ=Once] -> x_s6Pt2;
        };

Data.Foldable.$fFoldableMaybe_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Base.Maybe a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6Pt3]
        case eta_s6Pt3 of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6Pt5 [Occ=Once] -> : [x_s6Pt5 GHC.Types.[]];
        };

Data.Foldable.$fFoldableMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Base.Maybe
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableMaybe_$cfold
                                             Data.Foldable.$fFoldableMaybe_$cfoldMap
                                             Data.Foldable.$fFoldableMaybe_$cfoldr
                                             Data.Foldable.$fFoldableMaybe_$cfoldr
                                             Data.Foldable.$fFoldableMaybe_$cfoldl
                                             Data.Foldable.$fFoldableMaybe_$cfoldl
                                             Data.Foldable.$fFoldableMaybe_$cfoldr1
                                             Data.Foldable.$fFoldableMaybe_$cfoldl1
                                             Data.Foldable.$fFoldableMaybe_$ctoList
                                             Data.Foldable.$fFoldableMaybe_$cnull
                                             Data.Foldable.$fFoldableMaybe_$clength
                                             Data.Foldable.$fFoldableMaybe_$celem
                                             Data.Foldable.$fFoldableMaybe_$cmaximum
                                             Data.Foldable.$fFoldableMaybe_$cminimum
                                             Data.Foldable.$fFoldableMaybe2
                                             Data.Foldable.$fFoldableMaybe1];

Data.Foldable.$fFoldableLast_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Monoid.Last a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pt6 f_s6Pt7 x_s6Pt8]
        case x_s6Pt8 of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6Pt6;
          GHC.Base.Just x1_s6Pta [Occ=Once] -> f_s6Pt7 x1_s6Pta;
        };

Data.Foldable.$fFoldableLast_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Monoid.Last m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ptb x_s6Ptc]
        case x_s6Ptc of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6Ptb;
          GHC.Base.Just x1_s6Pte [Occ=Once] -> x1_s6Pte;
        };

Data.Foldable.$fFoldableLast2
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.Last a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ptf x_s6Ptg]
        case x_s6Ptg of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Ptf;
          GHC.Base.Just x1_s6Pti [Occ=Once] -> x1_s6Pti;
        };

Data.Foldable.$fFoldableLast3 :: forall a. Data.Monoid.Last a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Ptj]
        case x_s6Ptj of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6Ptl [Occ=Once] -> v_s6Ptl;
        };

Data.Foldable.$fFoldableLast_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ptm eta_B1] Data.Foldable.$fFoldableLast3 eta_B1;

Data.Foldable.$fFoldableLast4 :: forall a. Data.Monoid.Last a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Ptn]
        case x_s6Ptn of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6Ptp [Occ=Once] -> v_s6Ptp;
        };

Data.Foldable.$fFoldableLast_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ptq eta_B1] Data.Foldable.$fFoldableLast4 eta_B1;

Data.Foldable.$fFoldableLast_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Monoid.Last a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Ptr eta_s6Pts]
        let {
          f_s6Ptt [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LuI -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Ptr eta_s6Pts] \u []
                  GHC.Classes.== $dEq_s6Ptr eta_s6Pts; } in
        let {
          sat_s6Ptx [Occ=Once]
            :: Data.Monoid.Last a_a6LuI -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6Ptt] \r [x_s6Ptu]
                  case x_s6Ptu of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x1_s6Ptw [Occ=Once] -> f_s6Ptt x1_s6Ptw;
                  };
        } in  sat_s6Ptx;

Data.Foldable.$fFoldableLast_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Monoid.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6Pty z_s6Ptz t_s6PtA]
        case t_s6PtA of {
          GHC.Base.Nothing -> z_s6Ptz;
          GHC.Base.Just x_s6PtC [Occ=Once] -> f_s6Pty z_s6Ptz x_s6PtC;
        };

Data.Foldable.$fFoldableLast_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PtD xs_s6PtE]
        case xs_s6PtE of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just x_s6PtG [Occ=Once] -> x_s6PtG;
        };

Data.Foldable.$fFoldableLast_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Monoid.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6PtH z0_s6PtI xs_s6PtJ]
        case xs_s6PtJ of {
          GHC.Base.Nothing -> z0_s6PtI;
          GHC.Base.Just x_s6PtL [Occ=Once] -> f_s6PtH x_s6PtL z0_s6PtI;
        };

Data.Foldable.$fFoldableLast_$clength
  :: forall a. Data.Monoid.Last a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6PtM]
        case xs_s6PtM of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableLast_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PtP xs_s6PtQ]
        case xs_s6PtQ of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just x_s6PtS [Occ=Once] -> x_s6PtS;
        };

Data.Foldable.$fFoldableLast_$cnull
  :: forall a. Data.Monoid.Last a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t_s6PtT]
        case t_s6PtT of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableLast1
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.Last a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PtW x_s6PtX]
        case x_s6PtX of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6PtW;
          GHC.Base.Just x1_s6PtZ [Occ=Once] -> x1_s6PtZ;
        };

Data.Foldable.$fFoldableLast_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Monoid.Last a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6Pu0]
        case eta_s6Pu0 of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6Pu2 [Occ=Once] -> : [x_s6Pu2 GHC.Types.[]];
        };

Data.Foldable.$fFoldableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Monoid.Last
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableLast_$cfold
                                             Data.Foldable.$fFoldableLast_$cfoldMap
                                             Data.Foldable.$fFoldableLast_$cfoldr'
                                             Data.Foldable.$fFoldableLast_$cfoldr'
                                             Data.Foldable.$fFoldableLast_$cfoldl
                                             Data.Foldable.$fFoldableLast_$cfoldl
                                             Data.Foldable.$fFoldableLast_$cfoldr1
                                             Data.Foldable.$fFoldableLast_$cfoldl1
                                             Data.Foldable.$fFoldableLast_$ctoList
                                             Data.Foldable.$fFoldableLast_$cnull
                                             Data.Foldable.$fFoldableLast_$clength
                                             Data.Foldable.$fFoldableLast_$celem
                                             Data.Foldable.$fFoldableLast_$cmaximum
                                             Data.Foldable.$fFoldableLast_$cminimum
                                             Data.Foldable.$fFoldableLast2
                                             Data.Foldable.$fFoldableLast1];

Data.Foldable.$fFoldableFirst_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Monoid.First a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pu3 f_s6Pu4 x_s6Pu5]
        case x_s6Pu5 of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6Pu3;
          GHC.Base.Just x1_s6Pu7 [Occ=Once] -> f_s6Pu4 x1_s6Pu7;
        };

Data.Foldable.$fFoldableFirst_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Monoid.First m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Pu8 x_s6Pu9]
        case x_s6Pu9 of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6Pu8;
          GHC.Base.Just x1_s6Pub [Occ=Once] -> x1_s6Pub;
        };

Data.Foldable.$fFoldableFirst2
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.First a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Puc x_s6Pud]
        case x_s6Pud of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Puc;
          GHC.Base.Just x1_s6Puf [Occ=Once] -> x1_s6Puf;
        };

Data.Foldable.$fFoldableFirst3
  :: forall a. Data.Monoid.First a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Pug]
        case x_s6Pug of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6Pui [Occ=Once] -> v_s6Pui;
        };

Data.Foldable.$fFoldableFirst_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Puj eta_B1] Data.Foldable.$fFoldableFirst3 eta_B1;

Data.Foldable.$fFoldableFirst4
  :: forall a. Data.Monoid.First a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Puk]
        case x_s6Puk of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6Pum [Occ=Once] -> v_s6Pum;
        };

Data.Foldable.$fFoldableFirst_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Pun eta_B1] Data.Foldable.$fFoldableFirst4 eta_B1;

Data.Foldable.$fFoldableFirst_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Monoid.First a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Puo eta_s6Pup]
        let {
          f_s6Puq [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6Lxh -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Puo eta_s6Pup] \u []
                  GHC.Classes.== $dEq_s6Puo eta_s6Pup; } in
        let {
          sat_s6Puu [Occ=Once]
            :: Data.Monoid.First a_a6Lxh -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6Puq] \r [x_s6Pur]
                  case x_s6Pur of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x1_s6Put [Occ=Once] -> f_s6Puq x1_s6Put;
                  };
        } in  sat_s6Puu;

Data.Foldable.$fFoldableFirst_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Monoid.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6Puv z_s6Puw t_s6Pux]
        case t_s6Pux of {
          GHC.Base.Nothing -> z_s6Puw;
          GHC.Base.Just x_s6Puz [Occ=Once] -> f_s6Puv z_s6Puw x_s6Puz;
        };

Data.Foldable.$fFoldableFirst_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PuA xs_s6PuB]
        case xs_s6PuB of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just x_s6PuD [Occ=Once] -> x_s6PuD;
        };

Data.Foldable.$fFoldableFirst_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Monoid.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6PuE z0_s6PuF xs_s6PuG]
        case xs_s6PuG of {
          GHC.Base.Nothing -> z0_s6PuF;
          GHC.Base.Just x_s6PuI [Occ=Once] -> f_s6PuE x_s6PuI z0_s6PuF;
        };

Data.Foldable.$fFoldableFirst_$clength
  :: forall a. Data.Monoid.First a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6PuJ]
        case xs_s6PuJ of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableFirst_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6PuM xs_s6PuN]
        case xs_s6PuN of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just x_s6PuP [Occ=Once] -> x_s6PuP;
        };

Data.Foldable.$fFoldableFirst_$cnull
  :: forall a. Data.Monoid.First a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t_s6PuQ]
        case t_s6PuQ of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableFirst1
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.First a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6PuT x_s6PuU]
        case x_s6PuU of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6PuT;
          GHC.Base.Just x1_s6PuW [Occ=Once] -> x1_s6PuW;
        };

Data.Foldable.$fFoldableFirst_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Monoid.First a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6PuX]
        case eta_s6PuX of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6PuZ [Occ=Once] -> : [x_s6PuZ GHC.Types.[]];
        };

Data.Foldable.$fFoldableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Monoid.First
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableFirst_$cfold
                                             Data.Foldable.$fFoldableFirst_$cfoldMap
                                             Data.Foldable.$fFoldableFirst_$cfoldr'
                                             Data.Foldable.$fFoldableFirst_$cfoldr'
                                             Data.Foldable.$fFoldableFirst_$cfoldl
                                             Data.Foldable.$fFoldableFirst_$cfoldl
                                             Data.Foldable.$fFoldableFirst_$cfoldr1
                                             Data.Foldable.$fFoldableFirst_$cfoldl1
                                             Data.Foldable.$fFoldableFirst_$ctoList
                                             Data.Foldable.$fFoldableFirst_$cnull
                                             Data.Foldable.$fFoldableFirst_$clength
                                             Data.Foldable.$fFoldableFirst_$celem
                                             Data.Foldable.$fFoldableFirst_$cmaximum
                                             Data.Foldable.$fFoldableFirst_$cminimum
                                             Data.Foldable.$fFoldableFirst2
                                             Data.Foldable.$fFoldableFirst1];

Data.Foldable.all1
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> Data.Semigroup.Internal.All
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pv0 p_s6Pv1]
        Data.Foldable.foldMap
            $dFoldable_s6Pv0 Data.Semigroup.Internal.$fMonoidAll p_s6Pv1;

Data.Foldable.all
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Foldable.all1 eta_B2 eta_B1;

Data.Foldable.$fFoldable:.:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*U,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pv2 $dFoldable1_s6Pv3 ds_s6Pv4]
        let {
          sat_s6Pv5 [Occ=Once]
            :: g_a6L4V a_a6L6K -> Data.Semigroup.Internal.All
          [LclId] =
              [$dFoldable1_s6Pv3] \u [] Data.Foldable.null $dFoldable1_s6Pv3;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pv2
              Data.Semigroup.Internal.$fMonoidAll
              sat_s6Pv5
              ds_s6Pv4;

Data.Foldable.$fFoldable:.:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:.:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pv6 $dFoldable1_s6Pv7 $dMonoid_s6Pv8 ds_s6Pv9]
        let {
          sat_s6Pva [Occ=Once] :: g_X6Lnv m_a6L51 -> m_a6L51
          [LclId] =
              [$dFoldable1_s6Pv7 $dMonoid_s6Pv8] \u []
                  Data.Foldable.foldMap $dFoldable1_s6Pv7 $dMonoid_s6Pv8 GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pv6 $dMonoid_s6Pv8 sat_s6Pva ds_s6Pv9;

Data.Foldable.$fFoldable:.:_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pvb $dFoldable1_s6Pvc $dNum_s6Pvd]
        let {
          $dMonoid_s6Pve
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6L7y)
          [LclId] =
              [$dNum_s6Pvd] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6Pvd; } in
        let {
          lvl1_s6Pvf [Occ=OnceL]
            :: g_X6Lnu a_a6L7y -> Data.Semigroup.Internal.Sum a_a6L7y
          [LclId] =
              [$dFoldable1_s6Pvc $dMonoid_s6Pve] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6Pvc $dMonoid_s6Pve Data.Foldable.$fFoldable:*:1; } in
        let {
          sat_s6Pvh [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lns g_X6Lnu a_a6L7y
               -> Data.Semigroup.Internal.Sum a_a6L7y
          [LclId] =
              [$dFoldable_s6Pvb $dMonoid_s6Pve lvl1_s6Pvf] \r [ds_s6Pvg]
                  Data.Foldable.foldMap
                      $dFoldable_s6Pvb $dMonoid_s6Pve lvl1_s6Pvf ds_s6Pvg;
        } in  sat_s6Pvh;

Data.Foldable.$fFoldable:.:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pvi $dFoldable1_s6Pvj $dOrd_s6Pvk]
        let {
          $dMonoid_s6Pvl :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6L7o)
          [LclId] =
              [$dOrd_s6Pvk] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6Pvk; } in
        let {
          lvl1_s6Pvm [Occ=OnceL]
            :: g_X6Lnt a_a6L7o -> Data.Functor.Utils.Min a_a6L7o
          [LclId] =
              [$dFoldable1_s6Pvj $dMonoid_s6Pvl] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6Pvj $dMonoid_s6Pvl GHC.Base.Just; } in
        let {
          sat_s6Pvq [Occ=OnceT[0]]
            :: (GHC.Generics.:.:) f_X6Lnr g_X6Lnt a_a6L7o -> a_a6L7o
          [LclId] =
              [$dFoldable_s6Pvi $dMonoid_s6Pvl lvl1_s6Pvm] \r [x_s6Pvn]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6Pvi $dMonoid_s6Pvl lvl1_s6Pvm x_s6Pvn
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6Pvp [Occ=Once] -> v_s6Pvp;
                  };
        } in  sat_s6Pvq;

Data.Foldable.$fFoldable:.:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pvr $dFoldable1_s6Pvs $dOrd_s6Pvt]
        let {
          $dMonoid_s6Pvu :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6L7e)
          [LclId] =
              [$dOrd_s6Pvt] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6Pvt; } in
        let {
          lvl1_s6Pvv [Occ=OnceL]
            :: g_X6Lns a_a6L7e -> Data.Functor.Utils.Max a_a6L7e
          [LclId] =
              [$dFoldable1_s6Pvs $dMonoid_s6Pvu] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6Pvs $dMonoid_s6Pvu GHC.Base.Just; } in
        let {
          sat_s6Pvz [Occ=OnceT[0]]
            :: (GHC.Generics.:.:) f_X6Lnq g_X6Lns a_a6L7e -> a_a6L7e
          [LclId] =
              [$dFoldable_s6Pvr $dMonoid_s6Pvu lvl1_s6Pvv] \r [x_s6Pvw]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6Pvr $dMonoid_s6Pvu lvl1_s6Pvv x_s6Pvw
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6Pvy [Occ=Once] -> v_s6Pvy;
                  };
        } in  sat_s6Pvz;

Data.Foldable.$fFoldable:.:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:.:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PvA $dFoldable1_s6PvB $dEq_s6PvC eta_s6PvD]
        let {
          lvl1_s6PvE [Occ=OnceL]
            :: g_X6Lnr a_a6L74 -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable1_s6PvB $dEq_s6PvC eta_s6PvD] \u []
                  let {
                    sat_s6PvF [Occ=Once] :: a_a6L74 -> Data.Semigroup.Internal.Any
                    [LclId] =
                        [$dEq_s6PvC eta_s6PvD] \u [] GHC.Classes.== $dEq_s6PvC eta_s6PvD;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6PvB
                        Data.Semigroup.Internal.$fMonoidAny
                        sat_s6PvF; } in
        let {
          sat_s6PvH [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lnp g_X6Lnr a_a6L74
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6PvA lvl1_s6PvE] \r [ds_s6PvG]
                  Data.Foldable.foldMap
                      $dFoldable_s6PvA
                      Data.Semigroup.Internal.$fMonoidAny
                      lvl1_s6PvE
                      ds_s6PvG;
        } in  sat_s6PvH;

Data.Foldable.$fFoldable:.:_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PvI $dFoldable1_s6PvJ f1_s6PvK xs_s6PvL]
        let {
          f2_s6PvM [Occ=OnceL]
            :: a_a6L6m -> GHC.Base.Maybe a_a6L6m -> GHC.Base.Maybe a_a6L6m
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [f1_s6PvK] \r [x_s6PvN m_s6PvO]
                  let {
                    sat_s6PvR [Occ=Once] :: a_a6L6m
                    [LclId] =
                        [f1_s6PvK x_s6PvN m_s6PvO] \u []
                            case m_s6PvO of {
                              GHC.Base.Nothing -> x_s6PvN;
                              GHC.Base.Just y_s6PvQ [Occ=Once] -> f1_s6PvK x_s6PvN y_s6PvQ;
                            };
                  } in  GHC.Base.Just [sat_s6PvR]; } in
        let {
          sat_s6PvU [Occ=Once]
            :: g_X6Lno a_a6L6m
               -> GHC.Base.Maybe a_a6L6m -> GHC.Base.Maybe a_a6L6m
          [LclId] =
              [$dFoldable1_s6PvJ f2_s6PvM] \r [b1_s6PvS b2_s6PvT]
                  Data.Foldable.foldr $dFoldable1_s6PvJ f2_s6PvM b2_s6PvT b1_s6PvS;
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6PvI sat_s6PvU GHC.Base.Nothing xs_s6PvL
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
            GHC.Base.Just v_s6PvW [Occ=Once] -> v_s6PvW;
          };

Data.Foldable.$fFoldable:.:_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PvX
           $dFoldable1_s6PvY
           f1_s6PvZ
           z0_s6Pw0
           xs_s6Pw1]
        let {
          f2_s6Pw2 [Occ=OnceL]
            :: a_a6L6d -> (b_a6L6c -> b_a6L6c) -> b_a6L6c -> b_a6L6c
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [f1_s6PvZ] \r [x_s6Pw3 k_s6Pw4 z_s6Pw5]
                  case f1_s6PvZ z_s6Pw5 x_s6Pw3 of vx_s6Pw6 {
                    __DEFAULT -> k_s6Pw4 vx_s6Pw6;
                  }; } in
        let {
          sat_s6Pw9 [Occ=Once]
            :: g_X6Lnn a_a6L6d -> (b_a6L6c -> b_a6L6c) -> b_a6L6c -> b_a6L6c
          [LclId] =
              [$dFoldable1_s6PvY f2_s6Pw2] \r [b1_s6Pw7 b2_s6Pw8]
                  Data.Foldable.foldr $dFoldable1_s6PvY f2_s6Pw2 b2_s6Pw8 b1_s6Pw7;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6PvX sat_s6Pw9 GHC.Base.id xs_s6Pw1 z0_s6Pw0;

Data.Foldable.$fFoldable:.:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pwa $dFoldable1_s6Pwb eta_s6Pwc]
        Data.Foldable.$fFoldable:.:_$cfoldl'
            $dFoldable_s6Pwa
            $dFoldable1_s6Pwb
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4
            eta_s6Pwc;

Data.Foldable.$fFoldable:.:_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pwd $dFoldable1_s6Pwe f1_s6Pwf z_s6Pwg t_s6Pwh]
        let {
          sat_s6Pwl [Occ=Once]
            :: g_X6Lnm a_a6L63
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6L62)
          [LclId] =
              [$dFoldable1_s6Pwe f1_s6Pwf] \u []
                  let {
                    sat_s6Pwk [Occ=Once]
                      :: a_a6L63
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo b_a6L62)
                    [LclId] =
                        [f1_s6Pwf] \r [x_s6Pwi y_s6Pwj] f1_s6Pwf y_s6Pwj x_s6Pwi;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6Pwe Data.Foldable.$fFoldable:*:7 sat_s6Pwk;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pwd
              Data.Foldable.$fFoldable:*:7
              sat_s6Pwl
              t_s6Pwh
              z_s6Pwg;

Data.Foldable.$fFoldable:.:_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pwm $dFoldable1_s6Pwn f1_s6Pwo xs_s6Pwp]
        let {
          sat_s6Pww [Occ=Once]
            :: g_X6Lnp a_a6L6u
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6L6u))
          [LclId] =
              [$dFoldable1_s6Pwn f1_s6Pwo] \u []
                  let {
                    sat_s6Pwv [Occ=Once]
                      :: a_a6L6u
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6L6u))
                    [LclId] =
                        [f1_s6Pwo] \r [x_s6Pwq y_s6Pwr]
                            let {
                              sat_s6Pwu [Occ=Once] :: a_a6L6u
                              [LclId] =
                                  [f1_s6Pwo x_s6Pwq y_s6Pwr] \u []
                                      case y_s6Pwr of {
                                        GHC.Base.Nothing -> x_s6Pwq;
                                        GHC.Base.Just x1_s6Pwt [Occ=Once] ->
                                            f1_s6Pwo x1_s6Pwt x_s6Pwq;
                                      };
                            } in  GHC.Base.Just [sat_s6Pwu];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6Pwn Data.Foldable.$fFoldable:*:7 sat_s6Pwv;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6Pwm
                  Data.Foldable.$fFoldable:*:7
                  sat_s6Pww
                  xs_s6Pwp
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
            GHC.Base.Just v_s6Pwy [Occ=Once] -> v_s6Pwy;
          };

Data.Foldable.$fFoldable:.:_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pwz
           $dFoldable1_s6PwA
           f1_s6PwB
           z0_s6PwC
           xs_s6PwD]
        let {
          sat_s6PwJ [Occ=Once]
            :: g_X6Lnl a_a6L5S
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6L5T -> b_a6L5T))
          [LclId] =
              [$dFoldable1_s6PwA f1_s6PwB] \u []
                  let {
                    sat_s6PwI [Occ=Once]
                      :: a_a6L5S
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (b_a6L5T -> b_a6L5T))
                    [LclId] =
                        [f1_s6PwB] \r [x_s6PwE y_s6PwF z_s6PwG]
                            case f1_s6PwB x_s6PwE z_s6PwG of vx_s6PwH {
                              __DEFAULT -> y_s6PwF vx_s6PwH;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6PwA Data.Foldable.$fFoldable:*:7 sat_s6PwI;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Pwz
              Data.Foldable.$fFoldable:*:7
              sat_s6PwJ
              xs_s6PwD
              GHC.Base.id
              z0_s6PwC;

Data.Foldable.$fFoldable:.:_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PwK $dFoldable1_s6PwL $dNum_s6PwM]
        let {
          $dMonoid_s6PwN
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6L7I)
          [LclId] =
              [$dNum_s6PwM] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6PwM; } in
        let {
          lvl1_s6PwO [Occ=OnceL]
            :: g_X6Lnk a_a6L7I -> Data.Semigroup.Internal.Product a_a6L7I
          [LclId] =
              [$dFoldable1_s6PwL $dMonoid_s6PwN] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6PwL $dMonoid_s6PwN Data.Foldable.$fFoldable:*:1; } in
        let {
          sat_s6PwQ [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lni g_X6Lnk a_a6L7I
               -> Data.Semigroup.Internal.Product a_a6L7I
          [LclId] =
              [$dFoldable_s6PwK $dMonoid_s6PwN lvl1_s6PwO] \r [ds_s6PwP]
                  Data.Foldable.foldMap
                      $dFoldable_s6PwK $dMonoid_s6PwN lvl1_s6PwO ds_s6PwP;
        } in  sat_s6PwQ;

Data.Foldable.$fFoldable:.:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6PwR $dFoldable1_s6PwS eta_s6PwT]
        let {
          sat_s6PwW [Occ=Once] :: g_X6Lnj a_a6L6C -> [a_a6L6C] -> [a_a6L6C]
          [LclId] =
              [$dFoldable1_s6PwS] \r [b1_s6PwU b2_s6PwV]
                  Data.Foldable.foldr
                      $dFoldable1_s6PwS GHC.Types.: b2_s6PwV b1_s6PwU;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6PwR sat_s6PwW GHC.Types.[] eta_s6PwT;

Data.Foldable.$fFoldable:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6PwX $dFoldable1_s6PwY]
        let {
          sat_s6Pxe [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cproduct
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Pxd [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$csum
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Pxc [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cminimum
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Pxb [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cmaximum
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Pxa [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$celem
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B2 eta_B1; } in
        let {
          sat_s6Px9 [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$clength
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Px8 [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:1
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Px7 [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> [a]
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$ctoList
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B1; } in
        let {
          sat_s6Px6 [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl1
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B2 eta_B1; } in
        let {
          sat_s6Px5 [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr1
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B2 eta_B1; } in
        let {
          sat_s6Px4 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl'
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Px3 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Px2 [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr'
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Px1 [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Px0 [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> m
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldMap
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6PwZ [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni m -> m
          [LclId] =
              [$dFoldable_s6PwX $dFoldable1_s6PwY] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfold
                      $dFoldable_s6PwX $dFoldable1_s6PwY eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6PwZ
                                    sat_s6Px0
                                    sat_s6Px1
                                    sat_s6Px2
                                    sat_s6Px3
                                    sat_s6Px4
                                    sat_s6Px5
                                    sat_s6Px6
                                    sat_s6Px7
                                    sat_s6Px8
                                    sat_s6Px9
                                    sat_s6Pxa
                                    sat_s6Pxb
                                    sat_s6Pxc
                                    sat_s6Pxd
                                    sat_s6Pxe];

Data.Foldable.maximumBy
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pxf cmp_s6Pxg]
        let {
          sat_s6Pxk [Occ=Once] :: a_a6KCW -> a_a6KCW -> a_a6KCW
          [LclId] =
              [cmp_s6Pxg] \r [x_s6Pxh y_s6Pxi]
                  case cmp_s6Pxg x_s6Pxh y_s6Pxi of {
                    __DEFAULT -> y_s6Pxi;
                    GHC.Types.GT -> x_s6Pxh;
                  };
        } in  Data.Foldable.foldl1 $dFoldable_s6Pxf sat_s6Pxk;

Data.Foldable.minimumBy
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pxl cmp_s6Pxm]
        let {
          sat_s6Pxq [Occ=Once] :: a_a6KCy -> a_a6KCy -> a_a6KCy
          [LclId] =
              [cmp_s6Pxm] \r [x_s6Pxn y_s6Pxo]
                  case cmp_s6Pxm x_s6Pxn y_s6Pxo of {
                    __DEFAULT -> x_s6Pxn;
                    GHC.Types.GT -> y_s6Pxo;
                  };
        } in  Data.Foldable.foldl1 $dFoldable_s6Pxl sat_s6Pxq;

Data.Foldable.notElem
  :: forall (t :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Classes.Eq a) =>
     a -> t a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(C(U))),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pxr $dEq_s6Pxs x_s6Pxt]
        let {
          g_s6Pxu [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_a6KCk a_a6KCl -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Pxr $dEq_s6Pxs x_s6Pxt] \u []
                  Data.Foldable.elem $dFoldable_s6Pxr $dEq_s6Pxs x_s6Pxt; } in
        let {
          sat_s6Pxx [Occ=OnceT[0]] :: t_a6KCk a_a6KCl -> GHC.Types.Bool
          [LclId] =
              [g_s6Pxu] \r [x1_s6Pxv]
                  case g_s6Pxu x1_s6Pxv of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  sat_s6Pxx;

Data.Foldable.find
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Pxy p_s6Pxz]
        let {
          g_s6PxA [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_a6KC3 a_a6KC4 -> Data.Monoid.First a_a6KC4
          [LclId] =
              [$dFoldable_s6Pxy p_s6Pxz] \u []
                  let {
                    sat_s6PxD [Occ=Once] :: a_a6KC4 -> Data.Monoid.First a_a6KC4
                    [LclId] =
                        [p_s6Pxz] \r [x_s6PxB]
                            case p_s6Pxz x_s6PxB of {
                              GHC.Types.False -> GHC.Base.Nothing [];
                              GHC.Types.True -> GHC.Base.Just [x_s6PxB];
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6Pxy Data.Monoid.$fMonoidFirst sat_s6PxD; } in
        let {
          sat_s6PxF [Occ=Once]
            :: t_a6KC3 a_a6KC4 -> Data.Monoid.First a_a6KC4
          [LclId] =
              [g_s6PxA] \r [x_s6PxE] g_s6PxA x_s6PxE;
        } in  sat_s6PxF;

Data.Foldable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Foldable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$trModule4];

Data.Foldable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Foldable"#;

Data.Foldable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$trModule2];

Data.Foldable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Foldable.$trModule3
                                     Data.Foldable.$trModule1];

$krep_r6OSX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Foldable.$tcFoldable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_r6OSX];

Data.Foldable.$tcFoldable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foldable"#;

Data.Foldable.$tcFoldable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$tcFoldable3];

Data.Foldable.$tcFoldable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1610127274683713266##
                                    5928938033451775936##
                                    Data.Foldable.$trModule
                                    Data.Foldable.$tcFoldable2
                                    0#
                                    Data.Foldable.$tcFoldable1];

Data.Foldable.C:Foldable
  :: forall (t :: * -> *).
     (forall m. GHC.Base.Monoid m => t m -> m)
     -> (forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m)
     -> (forall a b. (a -> b -> b) -> b -> t a -> b)
     -> (forall a b. (a -> b -> b) -> b -> t a -> b)
     -> (forall b a. (b -> a -> b) -> b -> t a -> b)
     -> (forall b a. (b -> a -> b) -> b -> t a -> b)
     -> (forall a. (a -> a -> a) -> t a -> a)
     -> (forall a. (a -> a -> a) -> t a -> a)
     -> (forall a. t a -> [a])
     -> (forall a. t a -> GHC.Types.Bool)
     -> (forall a. t a -> GHC.Types.Int)
     -> (forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool)
     -> (forall a. GHC.Classes.Ord a => t a -> a)
     -> (forall a. GHC.Classes.Ord a => t a -> a)
     -> (forall a. GHC.Num.Num a => t a -> a)
     -> (forall a. GHC.Num.Num a => t a -> a)
     -> Data.Foldable.Foldable t
[GblId[DataCon],
 Arity=16,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_Bg
           eta_Bf
           eta_Be
           eta_Bd
           eta_Bc
           eta_Bb
           eta_Ba
           eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        Data.Foldable.C:Foldable [eta_Bg
                                  eta_Bf
                                  eta_Be
                                  eta_Bd
                                  eta_Bc
                                  eta_Bb
                                  eta_Ba
                                  eta_B9
                                  eta_B8
                                  eta_B7
                                  eta_B6
                                  eta_B5
                                  eta_B4
                                  eta_B3
                                  eta_B2
                                  eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:02:15.964133546 UTC

Data.Foldable.fold
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m. GHC.Base.Monoid m => t m -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6YdM]
        case v_s6YdM of {
          Data.Foldable.C:Foldable v_s6YdO [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YdO;
        };

Data.Foldable.foldMap
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6Ye4]
        case v_s6Ye4 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   v_s6Ye7 [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Ye7;
        };

Data.Foldable.foldr
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6Yem]
        case v_s6Yem of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yeq [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Yeq;
        };

Data.Foldable.foldr'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6YeE]
        case v_s6YeE of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6YeJ [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YeJ;
        };

Data.Foldable.foldl
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6YeW]
        case v_s6YeW of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yf2 [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Yf2;
        };

Data.Foldable.foldl'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6Yfe]
        case v_s6Yfe of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yfl [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Yfl;
        };

Data.Foldable.foldr1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6Yfw]
        case v_s6Yfw of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6YfE [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YfE;
        };

Data.Foldable.foldl1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6YfO]
        case v_s6YfO of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6YfX [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YfX;
        };

Data.Foldable.toList
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s6Yg6]
        case v_s6Yg6 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Ygg [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Ygg;
        };

Data.Foldable.null
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s6Ygo]
        case v_s6Ygo of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Ygz [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Ygz;
        };

Data.Foldable.length
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s6YgG]
        case v_s6YgG of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6YgS [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YgS;
        };

Data.Foldable.elem
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s6YgY]
        case v_s6YgY of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yhb [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Yhb;
        };

Data.Foldable.maximum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s6Yhg]
        case v_s6Yhg of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yhu [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Yhu;
        };

Data.Foldable.minimum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s6Yhy]
        case v_s6Yhy of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6YhN [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YhN;
        };

Data.Foldable.sum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s6YhQ]
        case v_s6YhQ of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yi6 [Occ=Once]
                                   _ [Occ=Dead] ->
              v_s6Yi6;
        };

Data.Foldable.product
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s6Yi8]
        case v_s6Yi8 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yip [Occ=Once] ->
              v_s6Yip;
        };

Data.Foldable.$fFoldableMaybe_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.Maybe a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6Yiq z_s6Yir ds1_s6Yis]
        case ds1_s6Yis of {
          GHC.Base.Nothing -> z_s6Yir;
          GHC.Base.Just x_s6Yiu [Occ=Once] -> ds_s6Yiq z_s6Yir x_s6Yiu;
        };

Data.Foldable.$fFoldableMaybe_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.Maybe a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6Yiv z_s6Yiw ds1_s6Yix]
        case ds1_s6Yix of {
          GHC.Base.Nothing -> z_s6Yiw;
          GHC.Base.Just x_s6Yiz [Occ=Once] -> ds_s6Yiv x_s6Yiz z_s6Yiw;
        };

Data.Foldable.$fFoldableMaybe_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Base.Maybe a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YiA eta_s6YiB eta1_s6YiC]
        case eta1_s6YiC of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YiA;
          GHC.Base.Just x_s6YiE [Occ=Once] -> eta_s6YiB x_s6YiE;
        };

Data.Foldable.$fFoldableNonEmpty_$clength
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s6YiF]
        case ds_s6YiF of {
          GHC.Base.:| _ [Occ=Dead] as_s6YiI [Occ=Once] ->
              case GHC.List.$wlenAcc as_s6YiI 0# of ww2_s6YiJ {
                __DEFAULT ->
                    case +# [1# ww2_s6YiJ] of sat_s6YiK {
                      __DEFAULT -> GHC.Types.I# [sat_s6YiK];
                    };
              };
        };

Data.Foldable.$fFoldableNonEmpty_$ctoList
  :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s6YiL]
        let {
          sat_s6YiT [Occ=Once] :: [a_a6LPN]
          [LclId] =
              [ds_s6YiL] \u []
                  case ds_s6YiL of {
                    GHC.Base.:| _ [Occ=Dead] as_s6YiS [Occ=Once] -> as_s6YiS;
                  }; } in
        let {
          sat_s6YiP [Occ=Once] :: a_a6LPN
          [LclId] =
              [ds_s6YiL] \u []
                  case ds_s6YiL of {
                    GHC.Base.:| a1_s6YiN [Occ=Once] _ [Occ=Dead] -> a1_s6YiN;
                  };
        } in  : [sat_s6YiP sat_s6YiT];

Data.Foldable.$fFoldableNonEmpty_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6YiU ds_s6YiV]
        case ds_s6YiV of {
          GHC.Base.:| a1_s6YiX [Occ=Once] as_s6YiY [Occ=Once] ->
              let-no-escape {
                go_s6YiZ [Occ=LoopBreakerT[2]] :: [a_a6LPG] -> a_a6LPG -> a_a6LPG
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [f_s6YiU go_s6YiZ] \r [ds1_s6Yj0 eta_s6Yj1]
                        case ds1_s6Yj0 of {
                          [] -> eta_s6Yj1;
                          : y_s6Yj3 [Occ=Once] ys_s6Yj4 [Occ=Once] ->
                              let {
                                sat_s6Yj5 [Occ=Once] :: a_a6LPG
                                [LclId] =
                                    [f_s6YiU eta_s6Yj1 y_s6Yj3] \u [] f_s6YiU eta_s6Yj1 y_s6Yj3;
                              } in  go_s6YiZ ys_s6Yj4 sat_s6Yj5;
                        };
              } in  go_s6YiZ as_s6YiY a1_s6YiX;
        };

Data.Foldable.$w$cfoldl2 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Yj6 w1_s6Yj7 ww_s6Yj8 ww1_s6Yj9]
        let {
          sat_s6Yjh [Occ=Once] :: b_s6NRS
          [LclId] =
              [w_s6Yj6 w1_s6Yj7 ww_s6Yj8] \u [] w_s6Yj6 w1_s6Yj7 ww_s6Yj8;
        } in 
          let-no-escape {
            go_s6Yja [Occ=LoopBreakerT[2]] :: [a_s6NRT] -> b_s6NRS -> b_s6NRS
            [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                sat-only [w_s6Yj6 go_s6Yja] \r [ds_s6Yjb eta_s6Yjc]
                    case ds_s6Yjb of {
                      [] -> eta_s6Yjc;
                      : y_s6Yje [Occ=Once] ys_s6Yjf [Occ=Once] ->
                          let {
                            sat_s6Yjg [Occ=Once] :: b_s6NRS
                            [LclId] =
                                [w_s6Yj6 eta_s6Yjc y_s6Yje] \u [] w_s6Yj6 eta_s6Yjc y_s6Yje;
                          } in  go_s6Yja ys_s6Yjf sat_s6Yjg;
                    };
          } in  go_s6Yja ww1_s6Yj9 sat_s6Yjh;

Data.Foldable.$fFoldableNonEmpty_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Yji w1_s6Yjj w2_s6Yjk]
        case w2_s6Yjk of {
          GHC.Base.:| ww1_s6Yjm [Occ=Once] ww2_s6Yjn [Occ=Once] ->
              Data.Foldable.$w$cfoldl2 w_s6Yji w1_s6Yjj ww1_s6Yjm ww2_s6Yjn;
        };

Data.Foldable.$fFoldableNonEmpty_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6Yjo z_s6Yjp ds_s6Yjq]
        let {
          sat_s6YjE [Occ=Once] :: b_a6LOW
          [LclId] =
              [f_s6Yjo z_s6Yjp ds_s6Yjq] \u []
                  case ds_s6Yjq of {
                    GHC.Base.:| _ [Occ=Dead] as_s6Yjx [Occ=Once] ->
                        let {
                          go_s6Yjy [Occ=LoopBreaker] :: [a_a6LOV] -> b_a6LOW
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [f_s6Yjo z_s6Yjp go_s6Yjy] \r [ds1_s6Yjz]
                                  case ds1_s6Yjz of {
                                    [] -> z_s6Yjp;
                                    : y_s6YjB [Occ=Once] ys_s6YjC [Occ=Once] ->
                                        let {
                                          sat_s6YjD [Occ=Once] :: b_a6LOW
                                          [LclId] =
                                              [go_s6Yjy ys_s6YjC] \u [] go_s6Yjy ys_s6YjC;
                                        } in  f_s6Yjo y_s6YjB sat_s6YjD;
                                  };
                        } in  go_s6Yjy as_s6Yjx;
                  }; } in
        let {
          sat_s6Yju [Occ=Once] :: a_a6LOV
          [LclId] =
              [ds_s6Yjq] \u []
                  case ds_s6Yjq of {
                    GHC.Base.:| a1_s6Yjs [Occ=Once] _ [Occ=Dead] -> a1_s6Yjs;
                  };
        } in  f_s6Yjo sat_s6Yju sat_s6YjE;

Data.Foldable.$fFoldable:*:4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Foldable.$fFoldableDual3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Foldable.$fFoldableEither_$clength
  :: forall a1 a2. Data.Either.Either a1 a2 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_s6YjF]
        case ds_s6YjF of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
          Data.Either.Right _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableEither_$cfoldr
  :: forall a1 a2 b.
     (a2 -> b -> b) -> b -> Data.Either.Either a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6YjJ z_s6YjK ds1_s6YjL]
        case ds1_s6YjL of {
          Data.Either.Left _ [Occ=Dead] -> z_s6YjK;
          Data.Either.Right y_s6YjO [Occ=Once] -> ds_s6YjJ y_s6YjO z_s6YjK;
        };

Data.Foldable.$fFoldableEither_$cfoldMap
  :: forall a1 m a2.
     GHC.Base.Monoid m =>
     (a2 -> m) -> Data.Either.Either a1 a2 -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YjP ds_s6YjQ ds1_s6YjR]
        case ds1_s6YjR of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YjP;
          Data.Either.Right y_s6YjU [Occ=Once] -> ds_s6YjQ y_s6YjU;
        };

Data.Foldable.$fFoldable(,)_$cfoldr
  :: forall a1 a2 b. (a2 -> b -> b) -> b -> (a1, a2) -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_s6YjV z_s6YjW ds_s6YjX]
        case ds_s6YjX of {
          (,) _ [Occ=Dead] y_s6Yk0 [Occ=Once] -> f_s6YjV y_s6Yk0 z_s6YjW;
        };

Data.Foldable.$fFoldable(,)_$cfoldMap
  :: forall a1 m a2. GHC.Base.Monoid m => (a2 -> m) -> (a1, a2) -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yk1 f_s6Yk2 ds_s6Yk3]
        case ds_s6Yk3 of {
          (,) _ [Occ=Dead] y_s6Yk6 [Occ=Once] -> f_s6Yk2 y_s6Yk6;
        };

Data.Foldable.$fFoldableArray_$cnull
  :: forall i a. GHC.Arr.Array i a -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),1*U(A,A,1*U,A)>,
 Unf=OtherCon []] =
    [] \r [a1_s6Yk7]
        case a1_s6Yk7 of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        dt_s6Ykb [Occ=Once!]
                        _ [Occ=Dead] ->
              case dt_s6Ykb of {
                __DEFAULT -> GHC.Types.False [];
                0# -> GHC.Types.True [];
              };
        };

sat_s6Yke :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s6Ykf :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6Yke GHC.Types.[]];

Data.Foldable.$fFoldableProxy1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6Ykf;

Data.Foldable.$fFoldableProxy_$cproduct
  :: forall a. GHC.Num.Num a => Data.Proxy.Proxy a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ykg ds_s6Ykh]
        GHC.Num.fromInteger $dNum_s6Ykg Data.Foldable.$fFoldableProxy1;

Data.Foldable.$fFoldableProxy2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Foldable.$fFoldableProxy_$csum
  :: forall a. GHC.Num.Num a => Data.Proxy.Proxy a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yki ds_s6Ykj]
        GHC.Num.fromInteger $dNum_s6Yki Data.Foldable.$fFoldableProxy2;

Data.Foldable.$fFoldableProxy_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Proxy.Proxy a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Ykk ds_s6Ykl ds1_s6Ykm] GHC.Types.False [];

Data.Foldable.$fFoldableProxy_$clength
  :: forall a. Data.Proxy.Proxy a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6Ykn] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableProxy_$cnull
  :: forall a. Data.Proxy.Proxy a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Yko] GHC.Types.True [];

Data.Foldable.$fFoldableProxy4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: Proxy"#;

Data.Foldable.$fFoldableProxy3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableProxy4;

Data.Foldable.$fFoldableProxy_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6Ykp ds1_s6Ykq]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableProxy3;

Data.Foldable.$fFoldableProxy6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: Proxy"#;

Data.Foldable.$fFoldableProxy5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableProxy6;

Data.Foldable.$fFoldableProxy_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6Ykr ds1_s6Yks]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableProxy5;

Data.Foldable.$fFoldableProxy_$cfoldl [InlPrag=INLINE (sat-args=3)]
  :: forall b a. (b -> a -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6Ykt z_s6Yku ds1_s6Ykv] z_s6Yku;

Data.Foldable.$fFoldableProxy_$cfoldr [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (a -> b -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6Ykw z_s6Ykx ds1_s6Yky] z_s6Ykx;

Data.Foldable.$fFoldableProxy_$cfoldMap [InlPrag=INLINE (sat-args=2)]
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Proxy.Proxy a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ykz eta_s6YkA ds_s6YkB]
        GHC.Base.mempty $dMonoid_s6Ykz;

Data.Foldable.$fFoldableProxy_$cfold [InlPrag=INLINE (sat-args=1)]
  :: forall m. GHC.Base.Monoid m => Data.Proxy.Proxy m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YkC ds_s6YkD] GHC.Base.mempty $dMonoid_s6YkC;

Data.Foldable.$fFoldableDual1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6YkE eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YkF eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual_$clength
  :: forall a. Data.Semigroup.Internal.Dual a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6YkG] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableDual_$cnull
  :: forall a. Data.Semigroup.Internal.Dual a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YkH] GHC.Types.False [];

Data.Foldable.$fFoldableDual_$ctoList
  :: forall a. Data.Semigroup.Internal.Dual a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6YkI] : [ds_s6YkI GHC.Types.[]];

Data.Foldable.$fFoldableDual4
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YkJ eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual5
  :: forall b a. (b -> a -> b) -> b -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6YkK] v_s6YkK;

Data.Foldable.$fFoldableDual_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Dual a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6YkL z_s6YkM ds_s6YkN] f_s6YkL ds_s6YkN z_s6YkM;

Data.Foldable.$fFoldableDual6
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> a -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YkO v_s6YkP] v_s6YkP;

Data.Foldable.$fFoldableSum1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6YkQ eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YkR eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum_$clength
  :: forall a. Data.Semigroup.Internal.Sum a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6YkS] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableSum_$cnull
  :: forall a. Data.Semigroup.Internal.Sum a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YkT] GHC.Types.False [];

Data.Foldable.$fFoldableSum_$ctoList
  :: forall a. Data.Semigroup.Internal.Sum a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6YkU] : [ds_s6YkU GHC.Types.[]];

Data.Foldable.$fFoldableSum3
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YkV eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Sum a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6YkW z_s6YkX ds_s6YkY] f_s6YkW ds_s6YkY z_s6YkX;

Data.Foldable.$fFoldableProduct1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6YkZ eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yl0 eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct_$clength
  :: forall a. Data.Semigroup.Internal.Product a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6Yl1] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableProduct_$cnull
  :: forall a. Data.Semigroup.Internal.Product a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Yl2] GHC.Types.False [];

Data.Foldable.$fFoldableProduct_$ctoList
  :: forall a. Data.Semigroup.Internal.Product a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6Yl3] : [ds_s6Yl3 GHC.Types.[]];

Data.Foldable.$fFoldableProduct3
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Yl4 eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Product a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6Yl5 z_s6Yl6 ds_s6Yl7] f_s6Yl5 ds_s6Yl7 z_s6Yl6;

Data.Foldable.$fFoldableU1_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Generics.U1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yl8 ds_s6Yl9]
        GHC.Num.fromInteger $dNum_s6Yl8 Data.Foldable.$fFoldableProxy1;

Data.Foldable.$fFoldableU1_$csum
  :: forall a. GHC.Num.Num a => GHC.Generics.U1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yla ds_s6Ylb]
        GHC.Num.fromInteger $dNum_s6Yla Data.Foldable.$fFoldableProxy2;

Data.Foldable.$fFoldableU1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.U1 a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Ylc ds_s6Yld ds1_s6Yle] GHC.Types.False [];

Data.Foldable.$fFoldableU1_$clength
  :: forall a. GHC.Generics.U1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6Ylf] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableU1_$cnull
  :: forall a. GHC.Generics.U1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Ylg] GHC.Types.True [];

Data.Foldable.$fFoldableU3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: U1"#;

Data.Foldable.$fFoldableU2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableU3;

Data.Foldable.$fFoldableU1_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6Ylh ds1_s6Yli]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableU2;

Data.Foldable.$fFoldableU5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: U1"#;

Data.Foldable.$fFoldableU4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableU5;

Data.Foldable.$fFoldableU1_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6Ylj ds1_s6Ylk]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableU4;

Data.Foldable.$fFoldableU1_$cfoldl [InlPrag=INLINE (sat-args=3)]
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6Yll z_s6Ylm ds1_s6Yln] z_s6Ylm;

Data.Foldable.$fFoldableU1_$cfoldr [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6Ylo z_s6Ylp ds1_s6Ylq] z_s6Ylp;

Data.Foldable.$fFoldableU1_$cfoldMap [InlPrag=INLINE (sat-args=2)]
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.U1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ylr eta_s6Yls ds_s6Ylt]
        GHC.Base.mempty $dMonoid_s6Ylr;

Data.Foldable.$fFoldableU1_$cfold [InlPrag=INLINE (sat-args=1)]
  :: forall m. GHC.Base.Monoid m => GHC.Generics.U1 m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ylu ds_s6Ylv] GHC.Base.mempty $dMonoid_s6Ylu;

Data.Foldable.$fFoldableV1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.V1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ylw ds_s6Ylx ds1_s6Yly]
        GHC.Base.mempty $dMonoid_s6Ylw;

Data.Foldable.$fFoldablePar1_$cnull
  :: forall a. GHC.Generics.Par1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Ylz] GHC.Types.False [];

Data.Foldable.$fFoldablePar1_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.Par1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6YlA z_s6YlB ds_s6YlC] f_s6YlA ds_s6YlC z_s6YlB;

Data.Foldable.$fFoldablePar1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.Par1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YlD f_s6YlE ds_s6YlF] f_s6YlE ds_s6YlF;

Data.Foldable.$fFoldableK1_$cfoldMap
  :: forall i c m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.K1 i c a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YlG ds_s6YlH ds1_s6YlI]
        GHC.Base.mempty $dMonoid_s6YlG;

Data.Foldable.$fFoldable:+:_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YlJ $dFoldable1_s6YlK ds_s6YlL]
        case ds_s6YlL of {
          GHC.Generics.L1 a1_s6YlN [Occ=Once] ->
              Data.Foldable.null $dFoldable_s6YlJ a1_s6YlN;
          GHC.Generics.R1 a1_s6YlO [Occ=Once] ->
              Data.Foldable.null $dFoldable1_s6YlK a1_s6YlO;
        };

Data.Foldable.$fFoldable:+:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YlP
           $dFoldable1_s6YlQ
           f1_s6YlR
           z_s6YlS
           ds_s6YlT]
        case ds_s6YlT of {
          GHC.Generics.L1 a1_s6YlV [Occ=Once] ->
              Data.Foldable.foldr $dFoldable_s6YlP f1_s6YlR z_s6YlS a1_s6YlV;
          GHC.Generics.R1 a1_s6YlW [Occ=Once] ->
              Data.Foldable.foldr $dFoldable1_s6YlQ f1_s6YlR z_s6YlS a1_s6YlW;
        };

Data.Foldable.$fFoldable:+:_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:+:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YlX
           $dFoldable1_s6YlY
           $dMonoid_s6YlZ
           f1_s6Ym0
           ds_s6Ym1]
        case ds_s6Ym1 of {
          GHC.Generics.L1 a1_s6Ym3 [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_s6YlX $dMonoid_s6YlZ f1_s6Ym0 a1_s6Ym3;
          GHC.Generics.R1 a1_s6Ym4 [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_s6YlY $dMonoid_s6YlZ f1_s6Ym0 a1_s6Ym4;
        };

Data.Foldable.$fFoldable:*:_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(S)LLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ym5 $dFoldable1_s6Ym6 ds_s6Ym7]
        case ds_s6Ym7 of {
          GHC.Generics.:*: a1_s6Ym9 [Occ=Once] a2_s6Yma [Occ=Once] ->
              case Data.Foldable.null $dFoldable_s6Ym5 a1_s6Ym9 of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> Data.Foldable.null $dFoldable1_s6Ym6 a2_s6Yma;
              };
        };

Data.Foldable.$fFoldable:*:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ymc
           $dFoldable1_s6Ymd
           f1_s6Yme
           z_s6Ymf
           ds_s6Ymg]
        case ds_s6Ymg of {
          GHC.Generics.:*: a1_s6Ymi [Occ=Once] a2_s6Ymj [Occ=Once] ->
              let {
                sat_s6Ymk [Occ=Once] :: b_a6L8t
                [LclId] =
                    [$dFoldable1_s6Ymd f1_s6Yme z_s6Ymf a2_s6Ymj] \u []
                        Data.Foldable.foldr $dFoldable1_s6Ymd f1_s6Yme z_s6Ymf a2_s6Ymj;
              } in 
                Data.Foldable.foldr $dFoldable_s6Ymc f1_s6Yme sat_s6Ymk a1_s6Ymi;
        };

Data.Foldable.$w$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> f a -> g a -> m
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Yml w1_s6Ymm w2_s6Ymn w3_s6Ymo ww_s6Ymp ww1_s6Ymq]
        let {
          sat_s6Yms [Occ=Once] :: m_s6NSd
          [LclId] =
              [w1_s6Ymm w2_s6Ymn w3_s6Ymo ww1_s6Ymq] \u []
                  Data.Foldable.foldMap w1_s6Ymm w2_s6Ymn w3_s6Ymo ww1_s6Ymq; } in
        let {
          sat_s6Ymr [Occ=Once] :: m_s6NSd
          [LclId] =
              [w_s6Yml w2_s6Ymn w3_s6Ymo ww_s6Ymp] \u []
                  Data.Foldable.foldMap w_s6Yml w2_s6Ymn w3_s6Ymo ww_s6Ymp;
        } in  GHC.Base.mappend w2_s6Ymn sat_s6Ymr sat_s6Yms;

Data.Foldable.$fFoldable:*:_$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:*:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Ymt w1_s6Ymu w2_s6Ymv w3_s6Ymw w4_s6Ymx]
        case w4_s6Ymx of {
          GHC.Generics.:*: ww1_s6Ymz [Occ=Once] ww2_s6YmA [Occ=Once] ->
              Data.Foldable.$w$cfoldMap
                  w_s6Ymt w1_s6Ymu w2_s6Ymv w3_s6Ymw ww1_s6Ymz ww2_s6YmA;
        };

Data.Foldable.$fFoldable:.:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YmB
           $dFoldable1_s6YmC
           f1_s6YmD
           z_s6YmE
           ds_s6YmF]
        let {
          sat_s6YmI [Occ=Once] :: g_a6L4V a_a6L5t -> b_a6L5u -> b_a6L5u
          [LclId] =
              [$dFoldable1_s6YmC f1_s6YmD] \r [b1_s6YmG b2_s6YmH]
                  Data.Foldable.foldr $dFoldable1_s6YmC f1_s6YmD b2_s6YmH b1_s6YmG;
        } in 
          Data.Foldable.foldr $dFoldable_s6YmB sat_s6YmI z_s6YmE ds_s6YmF;

Data.Foldable.$fFoldable:.:_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:.:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YmJ
           $dFoldable1_s6YmK
           $dMonoid_s6YmL
           f1_s6YmM
           ds_s6YmN]
        let {
          sat_s6YmO [Occ=Once] :: g_a6L4V a_a6L5c -> m_a6L5b
          [LclId] =
              [$dFoldable1_s6YmK $dMonoid_s6YmL f1_s6YmM] \u []
                  Data.Foldable.foldMap $dFoldable1_s6YmK $dMonoid_s6YmL f1_s6YmM;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YmJ $dMonoid_s6YmL sat_s6YmO ds_s6YmN;

Data.Foldable.$fFoldableURec4_$cnull
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6YmP]
        case ds_s6YmP of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec4_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YmS z_s6YmT ds_s6YmU]
        case ds_s6YmU of { GHC.Generics.UAddr _ [Occ=Dead] -> z_s6YmT; };

Data.Foldable.$fFoldableURec4_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YmX f_s6YmY ds_s6YmZ]
        case ds_s6YmZ of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YmX;
        };

Data.Foldable.$fFoldableURec3_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6Yn2]
        case ds_s6Yn2 of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec3_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Char a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Yn5 z_s6Yn6 ds_s6Yn7]
        case ds_s6Yn7 of { GHC.Generics.UChar _ [Occ=Dead] -> z_s6Yn6; };

Data.Foldable.$fFoldableURec3_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Char a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yna f_s6Ynb ds_s6Ync]
        case ds_s6Ync of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Yna;
        };

Data.Foldable.$fFoldableURec2_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6Ynf]
        case ds_s6Ynf of {
          GHC.Generics.UDouble _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec2_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Double a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Yni z_s6Ynj ds_s6Ynk]
        case ds_s6Ynk of { GHC.Generics.UDouble _ [Occ=Dead] -> z_s6Ynj; };

Data.Foldable.$fFoldableURec2_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Double a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ynn f_s6Yno ds_s6Ynp]
        case ds_s6Ynp of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              GHC.Base.mempty $dMonoid_s6Ynn;
        };

Data.Foldable.$fFoldableURec1_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6Yns]
        case ds_s6Yns of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec1_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Float a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Ynv z_s6Ynw ds_s6Ynx]
        case ds_s6Ynx of { GHC.Generics.UFloat _ [Occ=Dead] -> z_s6Ynw; };

Data.Foldable.$fFoldableURec1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Float a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YnA f_s6YnB ds_s6YnC]
        case ds_s6YnC of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YnA;
        };

Data.Foldable.$fFoldableURec0_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6YnF]
        case ds_s6YnF of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec0_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Int a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YnI z_s6YnJ ds_s6YnK]
        case ds_s6YnK of { GHC.Generics.UInt _ [Occ=Dead] -> z_s6YnJ; };

Data.Foldable.$fFoldableURec0_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Int a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YnN f_s6YnO ds_s6YnP]
        case ds_s6YnP of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YnN;
        };

Data.Foldable.$fFoldableURec_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6YnS]
        case ds_s6YnS of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Word a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YnV z_s6YnW ds_s6YnX]
        case ds_s6YnX of { GHC.Generics.UWord _ [Occ=Dead] -> z_s6YnW; };

Data.Foldable.$fFoldableURec_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Word a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yo0 f_s6Yo1 ds_s6Yo2]
        case ds_s6Yo2 of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Yo0;
        };

Data.Foldable.$fFoldable:*:1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6Yo5] v_s6Yo5;

$dmproduct1_r6OSR
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6Yo6 $dNum_s6Yo7]
        let {
          sat_s6Yo8 [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6KPT)
          [LclId] =
              [$dNum_s6Yo7] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6Yo7;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Yo6 sat_s6Yo8 Data.Foldable.$fFoldable:*:1;

Data.Foldable.$dmproduct
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] $dmproduct1_r6OSR eta_B2 eta_B1;

$dmsum1_r6OSS
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6Yo9 $dNum_s6Yoa]
        let {
          sat_s6Yob [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6KPz)
          [LclId] =
              [$dNum_s6Yoa] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6Yoa;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Yo9 sat_s6Yob Data.Foldable.$fFoldable:*:1;

Data.Foldable.$dmsum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] $dmsum1_r6OSS eta_B2 eta_B1;

Data.Foldable.$fFoldableK3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

poly_d_r6OST :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK3
        of
        sat_s6Yoc
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6Yoc;
        };

Data.Foldable.$dmminimum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yod $dOrd_s6Yoe]
        let {
          g_s6Yof [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_X6Kii a_a6KOY -> Data.Functor.Utils.Min a_a6KOY
          [LclId] =
              [$dFoldable_s6Yod $dOrd_s6Yoe] \u []
                  let {
                    sat_s6Yog [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6KOY)
                    [LclId] =
                        [$dOrd_s6Yoe] \u [] Data.Functor.Utils.$fMonoidMin $dOrd_s6Yoe;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6Yod sat_s6Yog GHC.Base.Just; } in
        let {
          sat_s6Yok [Occ=OnceT[0]] :: t_X6Kii a_a6KOY -> a_a6KOY
          [LclId] =
              [g_s6Yof] \r [x_s6Yoh]
                  case g_s6Yof x_s6Yoh of {
                    GHC.Base.Nothing -> poly_d_r6OST;
                    GHC.Base.Just v_s6Yoj [Occ=Once] -> v_s6Yoj;
                  };
        } in  sat_s6Yok;

Data.Foldable.$fFoldableK5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

poly_d1_r6OSU :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK5
        of
        sat_s6Yol
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6Yol;
        };

Data.Foldable.$dmmaximum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yom $dOrd_s6Yon]
        let {
          g_s6Yoo [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_X6Kij a_a6KOn -> Data.Functor.Utils.Max a_a6KOn
          [LclId] =
              [$dFoldable_s6Yom $dOrd_s6Yon] \u []
                  let {
                    sat_s6Yop [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6KOn)
                    [LclId] =
                        [$dOrd_s6Yon] \u [] Data.Functor.Utils.$fMonoidMax $dOrd_s6Yon;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6Yom sat_s6Yop GHC.Base.Just; } in
        let {
          sat_s6Yot [Occ=OnceT[0]] :: t_X6Kij a_a6KOn -> a_a6KOn
          [LclId] =
              [g_s6Yoo] \r [x_s6Yoq]
                  case g_s6Yoo x_s6Yoq of {
                    GHC.Base.Nothing -> poly_d1_r6OSU;
                    GHC.Base.Just v_s6Yos [Occ=Once] -> v_s6Yos;
                  };
        } in  sat_s6Yot;

Data.Foldable.$fFoldable:*:5
  :: forall a. GHC.Types.Int -> a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,A>m,
 Unf=OtherCon []] =
    [] \r [c_s6You ds_s6Yov]
        case c_s6You of {
          GHC.Types.I# x_s6Yox [Occ=Once] ->
              case +# [x_s6Yox 1#] of sat_s6Yoy {
                __DEFAULT -> GHC.Types.I# [sat_s6Yoy];
              };
        };

Data.Foldable.$dmlength
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yoz]
        Data.Foldable.foldl'
            $dFoldable_s6Yoz
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4;

lvl_r6OSV :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YoA ds1_s6YoB] GHC.Types.False [];

Data.Foldable.$dmnull
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YoC]
        Data.Foldable.foldr $dFoldable_s6YoC lvl_r6OSV GHC.Types.True;

Data.Foldable.$dmtoList [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YoD t1_s6YoE]
        Data.Foldable.foldr
            $dFoldable_s6YoD GHC.Types.: GHC.Types.[] t1_s6YoE;

Data.Foldable.$fFoldableK7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Foldable.$fFoldable:*:6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK7
        of
        sat_s6YoF
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6YoF;
        };

Data.Foldable.$dmfoldl1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId,
 Arity=3,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YoG f_s6YoH xs_s6YoI]
        let {
          sat_s6YoO [Occ=Once]
            :: GHC.Base.Maybe a_a6KN3 -> a_a6KN3 -> GHC.Base.Maybe a_a6KN3
          [LclId] =
              [f_s6YoH] \r [m_s6YoJ y_s6YoK]
                  let {
                    sat_s6YoN [Occ=Once] :: a_a6KN3
                    [LclId] =
                        [f_s6YoH m_s6YoJ y_s6YoK] \u []
                            case m_s6YoJ of {
                              GHC.Base.Nothing -> y_s6YoK;
                              GHC.Base.Just x_s6YoM [Occ=Once] -> f_s6YoH x_s6YoM y_s6YoK;
                            };
                  } in  GHC.Base.Just [sat_s6YoN];
        } in 
          case
              Data.Foldable.foldl
                  $dFoldable_s6YoG sat_s6YoO GHC.Base.Nothing xs_s6YoI
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6YoQ [Occ=Once] -> v_s6YoQ;
          };

Data.Foldable.$fFoldableK9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Foldable.$fFoldable:*:8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK9
        of
        sat_s6YoR
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6YoR;
        };

Data.Foldable.$dmfoldr1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YoS f_s6YoT xs_s6YoU]
        let {
          sat_s6Yp0 [Occ=Once]
            :: a_a6KMx -> GHC.Base.Maybe a_a6KMx -> GHC.Base.Maybe a_a6KMx
          [LclId] =
              [f_s6YoT] \r [x_s6YoV m_s6YoW]
                  let {
                    sat_s6YoZ [Occ=Once] :: a_a6KMx
                    [LclId] =
                        [f_s6YoT x_s6YoV m_s6YoW] \u []
                            case m_s6YoW of {
                              GHC.Base.Nothing -> x_s6YoV;
                              GHC.Base.Just y_s6YoY [Occ=Once] -> f_s6YoT x_s6YoV y_s6YoY;
                            };
                  } in  GHC.Base.Just [sat_s6YoZ];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6YoS sat_s6Yp0 GHC.Base.Nothing xs_s6YoU
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6Yp2 [Occ=Once] -> v_s6Yp2;
          };

Data.Foldable.$dmfoldl'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yp3 f_s6Yp4 z0_s6Yp5 xs_s6Yp6]
        let {
          sat_s6Ypb [Occ=Once]
            :: a_a6KM0 -> (b_a6KLZ -> b_a6KLZ) -> b_a6KLZ -> b_a6KLZ
          [LclId] =
              [f_s6Yp4] \r [x_s6Yp7 k_s6Yp8 z_s6Yp9]
                  case f_s6Yp4 z_s6Yp9 x_s6Yp7 of vx_s6Ypa {
                    __DEFAULT -> k_s6Yp8 vx_s6Ypa;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6Yp3 sat_s6Ypb GHC.Base.id xs_s6Yp6 z0_s6Yp5;

Data.Foldable.$fFoldable:*:7
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$dmfoldl
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ypc f_s6Ypd z_s6Ype t1_s6Ypf]
        let {
          sat_s6Ypi [Occ=Once]
            :: a_a6KLz
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6KLy)
          [LclId] =
              [f_s6Ypd] \r [x_s6Ypg y_s6Yph] f_s6Ypd y_s6Yph x_s6Ypg;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Ypc
              Data.Foldable.$fFoldable:*:7
              sat_s6Ypi
              t1_s6Ypf
              z_s6Ype;

Data.Foldable.$dmfoldr'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ypj f_s6Ypk z0_s6Ypl xs_s6Ypm]
        let {
          sat_s6Ypr [Occ=Once]
            :: (b_a6KKX -> b_a6KKX) -> a_a6KKW -> b_a6KKX -> b_a6KKX
          [LclId] =
              [f_s6Ypk] \r [k_s6Ypn x_s6Ypo z_s6Ypp]
                  case f_s6Ypk x_s6Ypo z_s6Ypp of vx_s6Ypq {
                    __DEFAULT -> k_s6Ypn vx_s6Ypq;
                  };
        } in 
          Data.Foldable.foldl
              $dFoldable_s6Ypj sat_s6Ypr GHC.Base.id xs_s6Ypm z0_s6Ypl;

Data.Foldable.$fFoldableU1_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6Yps z0_s6Ypt xs_s6Ypu] z0_s6Ypt;

Data.Foldable.$fFoldableK4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK5;

Data.Foldable.$fFoldableU1_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ypv eta_s6Ypw]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableU1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6Ypx z0_s6Ypy xs_s6Ypz] z0_s6Ypy;

Data.Foldable.$fFoldableK2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK3;

Data.Foldable.$fFoldableU1_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YpA eta_s6YpB]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableU1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.U1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6YpC] [] [];

Data.Foldable.$fFoldableU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.U1
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableU1_$cfold
                                             Data.Foldable.$fFoldableU1_$cfoldMap
                                             Data.Foldable.$fFoldableU1_$cfoldr
                                             Data.Foldable.$fFoldableU1_$cfoldr'
                                             Data.Foldable.$fFoldableU1_$cfoldl
                                             Data.Foldable.$fFoldableU1_$cfoldl'
                                             Data.Foldable.$fFoldableU1_$cfoldr1
                                             Data.Foldable.$fFoldableU1_$cfoldl1
                                             Data.Foldable.$fFoldableU1_$ctoList
                                             Data.Foldable.$fFoldableU1_$cnull
                                             Data.Foldable.$fFoldableU1_$clength
                                             Data.Foldable.$fFoldableU1_$celem
                                             Data.Foldable.$fFoldableU1_$cmaximum
                                             Data.Foldable.$fFoldableU1_$cminimum
                                             Data.Foldable.$fFoldableU1_$csum
                                             Data.Foldable.$fFoldableU1_$cproduct];

Data.Foldable.$fFoldableProxy_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YpD z0_s6YpE xs_s6YpF] z0_s6YpE;

Data.Foldable.$fFoldableProxy_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YpG eta_s6YpH]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableProxy_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YpI z0_s6YpJ xs_s6YpK] z0_s6YpJ;

Data.Foldable.$fFoldableProxy_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YpL eta_s6YpM]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableProxy_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Proxy.Proxy a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6YpN] [] [];

Data.Foldable.$fFoldableProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Proxy.Proxy
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableProxy_$cfold
                                             Data.Foldable.$fFoldableProxy_$cfoldMap
                                             Data.Foldable.$fFoldableProxy_$cfoldr
                                             Data.Foldable.$fFoldableProxy_$cfoldr'
                                             Data.Foldable.$fFoldableProxy_$cfoldl
                                             Data.Foldable.$fFoldableProxy_$cfoldl'
                                             Data.Foldable.$fFoldableProxy_$cfoldr1
                                             Data.Foldable.$fFoldableProxy_$cfoldl1
                                             Data.Foldable.$fFoldableProxy_$ctoList
                                             Data.Foldable.$fFoldableProxy_$cnull
                                             Data.Foldable.$fFoldableProxy_$clength
                                             Data.Foldable.$fFoldableProxy_$celem
                                             Data.Foldable.$fFoldableProxy_$cmaximum
                                             Data.Foldable.$fFoldableProxy_$cminimum
                                             Data.Foldable.$fFoldableProxy_$csum
                                             Data.Foldable.$fFoldableProxy_$cproduct];

Data.Foldable.$dmfoldr
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YpO f_s6YpP z_s6YpQ t1_s6YpR]
        Data.Foldable.foldMap
            $dFoldable_s6YpO
            Data.Semigroup.Internal.$fMonoidEndo
            f_s6YpP
            t1_s6YpR
            z_s6YpQ;

Data.Foldable.$dmfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*U,C(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YpS $dMonoid_s6YpT f_s6YpU]
        let {
          sat_s6YpY [Occ=Once] :: m_a6KKk
          [LclId] =
              [$dMonoid_s6YpT] \u [] GHC.Base.mempty $dMonoid_s6YpT; } in
        let {
          sat_s6YpX [Occ=Once] :: a_a6KKl -> m_a6KKk -> m_a6KKk
          [LclId] =
              [$dMonoid_s6YpT f_s6YpU] \r [x_s6YpV]
                  let {
                    sat_s6YpW [Occ=Once] :: m_a6KKk
                    [LclId] =
                        [f_s6YpU x_s6YpV] \u [] f_s6YpU x_s6YpV;
                  } in  GHC.Base.mappend $dMonoid_s6YpT sat_s6YpW;
        } in  Data.Foldable.foldr $dFoldable_s6YpS sat_s6YpX sat_s6YpY;

Data.Foldable.$dmfold
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m. GHC.Base.Monoid m => t m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YpZ $dMonoid_s6Yq0]
        Data.Foldable.foldMap $dFoldable_s6YpZ $dMonoid_s6Yq0 GHC.Base.id;

Data.Foldable.$fFoldableDual7
  :: forall m. GHC.Base.Monoid m => m -> m
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yq1 eta_B1] GHC.Base.id eta_B1;

Data.Foldable.$fFoldableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Product
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableProduct_$cfoldr
                                             Data.Foldable.$fFoldableProduct_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableProduct3
                                             Data.Foldable.$fFoldableProduct3
                                             Data.Foldable.$fFoldableProduct_$ctoList
                                             Data.Foldable.$fFoldableProduct_$cnull
                                             Data.Foldable.$fFoldableProduct_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableProduct2
                                             Data.Foldable.$fFoldableProduct2
                                             Data.Foldable.$fFoldableProduct1
                                             Data.Foldable.$fFoldableProduct1];

Data.Foldable.$fFoldableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Sum
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableSum_$cfoldr
                                             Data.Foldable.$fFoldableSum_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableSum3
                                             Data.Foldable.$fFoldableSum3
                                             Data.Foldable.$fFoldableSum_$ctoList
                                             Data.Foldable.$fFoldableSum_$cnull
                                             Data.Foldable.$fFoldableSum_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableSum2
                                             Data.Foldable.$fFoldableSum2
                                             Data.Foldable.$fFoldableSum1
                                             Data.Foldable.$fFoldableSum1];

Data.Foldable.$fFoldableDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Dual
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableDual_$cfoldr
                                             Data.Foldable.$fFoldableDual_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual4
                                             Data.Foldable.$fFoldableDual4
                                             Data.Foldable.$fFoldableDual_$ctoList
                                             Data.Foldable.$fFoldableDual_$cnull
                                             Data.Foldable.$fFoldableDual_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableDual2
                                             Data.Foldable.$fFoldableDual2
                                             Data.Foldable.$fFoldableDual1
                                             Data.Foldable.$fFoldableDual1];

Data.Foldable.$fFoldable[]_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6Yq2 z0_s6Yq3 xs_s6Yq4]
        let-no-escape {
          go_s6Yq5 [Occ=LoopBreakerT[3]]
            :: [a_a6LRy] -> (b_a6LRz -> b_a6LRz) -> b_a6LRz -> b_a6LRz
          [LclId[JoinId(3)],
           Arity=3,
           Str=<S,1*U><C(S),1*C1(U)><L,U>,
           Unf=OtherCon []] =
              sat-only [f_s6Yq2 go_s6Yq5] \r [ds_s6Yq6 eta_s6Yq7 eta1_s6Yq8]
                  case ds_s6Yq6 of {
                    [] -> eta_s6Yq7 eta1_s6Yq8;
                    : y_s6Yqa [Occ=Once] ys_s6Yqb [Occ=Once] ->
                        let {
                          sat_s6Yqe [Occ=Once] :: b_a6LRz -> b_a6LRz
                          [LclId] =
                              [f_s6Yq2 eta_s6Yq7 y_s6Yqa] \r [z_s6Yqc]
                                  case f_s6Yq2 y_s6Yqa z_s6Yqc of vx_s6Yqd {
                                    __DEFAULT -> eta_s6Yq7 vx_s6Yqd;
                                  };
                        } in  go_s6Yq5 ys_s6Yqb sat_s6Yqe eta1_s6Yq8;
                  };
        } in  go_s6Yq5 xs_s6Yq4 GHC.Base.id z0_s6Yq3;

Data.Foldable.$fFoldable[]_$cfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> [a] -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yqf f_s6Yqg eta_s6Yqh]
        let {
          z_s6Yqi [Occ=OnceL] :: m_a6LRe
          [LclId] =
              [$dMonoid_s6Yqf] \u [] GHC.Base.mempty $dMonoid_s6Yqf; } in
        let {
          go_s6Yqj [Occ=LoopBreaker] :: [a_a6LRf] -> m_a6LRe
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_s6Yqf f_s6Yqg z_s6Yqi go_s6Yqj] \r [ds_s6Yqk]
                  case ds_s6Yqk of {
                    [] -> z_s6Yqi;
                    : y_s6Yqm [Occ=Once] ys_s6Yqn [Occ=Once] ->
                        let {
                          sat_s6Yqp [Occ=Once] :: m_a6LRe
                          [LclId] =
                              [go_s6Yqj ys_s6Yqn] \u [] go_s6Yqj ys_s6Yqn; } in
                        let {
                          sat_s6Yqo [Occ=Once] :: m_a6LRe
                          [LclId] =
                              [f_s6Yqg y_s6Yqm] \u [] f_s6Yqg y_s6Yqm;
                        } in  GHC.Base.mappend $dMonoid_s6Yqf sat_s6Yqo sat_s6Yqp;
                  };
        } in  go_s6Yqj eta_s6Yqh;

Data.Foldable.$fFoldableNonEmpty_$cfold1
  :: forall m. GHC.Base.Monoid m => [m] -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yqq eta_s6Yqr]
        let {
          z_s6Yqs [Occ=OnceL] :: m_a6LR4
          [LclId] =
              [$dMonoid_s6Yqq] \u [] GHC.Base.mempty $dMonoid_s6Yqq; } in
        let {
          go_s6Yqt [Occ=LoopBreaker] :: [m_a6LR4] -> m_a6LR4
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_s6Yqq z_s6Yqs go_s6Yqt] \r [ds_s6Yqu]
                  case ds_s6Yqu of {
                    [] -> z_s6Yqs;
                    : y_s6Yqw [Occ=Once] ys_s6Yqx [Occ=Once] ->
                        let {
                          sat_s6Yqy [Occ=Once] :: m_a6LR4
                          [LclId] =
                              [go_s6Yqt ys_s6Yqx] \u [] go_s6Yqt ys_s6Yqx;
                        } in  GHC.Base.mappend $dMonoid_s6Yqq y_s6Yqw sat_s6Yqy;
                  };
        } in  go_s6Yqt eta_s6Yqr;

Data.Foldable.$fFoldable[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable []
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold1
                                             Data.Foldable.$fFoldable[]_$cfoldMap
                                             GHC.Base.foldr
                                             Data.Foldable.$fFoldable[]_$cfoldr'
                                             GHC.List.foldl
                                             GHC.List.foldl'
                                             GHC.List.foldr1
                                             GHC.List.foldl1
                                             GHC.Base.id
                                             GHC.List.null
                                             GHC.List.length
                                             GHC.List.elem
                                             GHC.List.maximum
                                             GHC.List.minimum
                                             GHC.List.sum
                                             GHC.List.product];

Data.Foldable.$fFoldableNonEmpty_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Base.NonEmpty m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),U(A,U,C(C1(U)),A)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yqz ds_s6YqA]
        let {
          sat_s6YqI [Occ=Once] :: m_a6LOt
          [LclId] =
              [$dMonoid_s6Yqz ds_s6YqA] \u []
                  case ds_s6YqA of {
                    GHC.Base.:| _ [Occ=Dead] ms_s6YqH [Occ=Once] ->
                        Data.Foldable.$fFoldableNonEmpty_$cfold1 $dMonoid_s6Yqz ms_s6YqH;
                  }; } in
        let {
          sat_s6YqE [Occ=Once] :: m_a6LOt
          [LclId] =
              [ds_s6YqA] \u []
                  case ds_s6YqA of {
                    GHC.Base.:| m1_s6YqC [Occ=Once] _ [Occ=Dead] -> m1_s6YqC;
                  };
        } in  GHC.Base.mappend $dMonoid_s6Yqz sat_s6YqE sat_s6YqI;

Data.Foldable.$fFoldableNonEmpty_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Base.NonEmpty a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),U(A,1*U,C(C1(U)),A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YqJ f_s6YqK ds_s6YqL]
        let {
          sat_s6Yr2 [Occ=Once] :: m_a6LOG
          [LclId] =
              [$dMonoid_s6YqJ f_s6YqK ds_s6YqL] \u []
                  case ds_s6YqL of {
                    GHC.Base.:| _ [Occ=Dead] as_s6YqT [Occ=Once] ->
                        let {
                          z_s6YqU [Occ=OnceL] :: m_a6LOG
                          [LclId] =
                              [$dMonoid_s6YqJ] \u [] GHC.Base.mempty $dMonoid_s6YqJ; } in
                        let {
                          go_s6YqV [Occ=LoopBreaker] :: [a_a6LOH] -> m_a6LOG
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dMonoid_s6YqJ f_s6YqK z_s6YqU go_s6YqV] \r [ds1_s6YqW]
                                  case ds1_s6YqW of {
                                    [] -> z_s6YqU;
                                    : y_s6YqY [Occ=Once] ys_s6YqZ [Occ=Once] ->
                                        let {
                                          sat_s6Yr1 [Occ=Once] :: m_a6LOG
                                          [LclId] =
                                              [go_s6YqV ys_s6YqZ] \u [] go_s6YqV ys_s6YqZ; } in
                                        let {
                                          sat_s6Yr0 [Occ=Once] :: m_a6LOG
                                          [LclId] =
                                              [f_s6YqK y_s6YqY] \u [] f_s6YqK y_s6YqY;
                                        } in  GHC.Base.mappend $dMonoid_s6YqJ sat_s6Yr0 sat_s6Yr1;
                                  };
                        } in  go_s6YqV as_s6YqT;
                  }; } in
        let {
          sat_s6YqQ [Occ=Once] :: m_a6LOG
          [LclId] =
              [f_s6YqK ds_s6YqL] \u []
                  let {
                    sat_s6YqP [Occ=Once] :: a_a6LOH
                    [LclId] =
                        [ds_s6YqL] \u []
                            case ds_s6YqL of {
                              GHC.Base.:| a1_s6YqN [Occ=Once] _ [Occ=Dead] -> a1_s6YqN;
                            };
                  } in  f_s6YqK sat_s6YqP;
        } in  GHC.Base.mappend $dMonoid_s6YqJ sat_s6YqQ sat_s6Yr2;

Data.Foldable.foldrM
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (a -> b -> m b) -> b -> t a -> m b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yr3 $dMonad_s6Yr4 f_s6Yr5 z0_s6Yr6 xs_s6Yr7]
        let {
          sat_s6Yrd [Occ=Once] :: b_a6KJt -> m_a6KJr b_a6KJt
          [LclId] =
              [$dMonad_s6Yr4] \u [] GHC.Base.return $dMonad_s6Yr4; } in
        let {
          sat_s6Yrc [Occ=Once]
            :: (b_a6KJt -> m_a6KJr b_a6KJt)
               -> a_a6KJs -> b_a6KJt -> m_a6KJr b_a6KJt
          [LclId] =
              [$dMonad_s6Yr4 f_s6Yr5] \r [k_s6Yr8 x_s6Yr9 z_s6Yra]
                  let {
                    sat_s6Yrb [Occ=Once] :: m_a6KJr b_a6KJt
                    [LclId] =
                        [f_s6Yr5 x_s6Yr9 z_s6Yra] \u [] f_s6Yr5 x_s6Yr9 z_s6Yra;
                  } in  GHC.Base.>>= $dMonad_s6Yr4 sat_s6Yrb k_s6Yr8;
        } in 
          Data.Foldable.foldl
              $dFoldable_s6Yr3 sat_s6Yrc sat_s6Yrd xs_s6Yr7 z0_s6Yr6;

Data.Foldable.foldlM
  :: forall (t :: * -> *) (m :: * -> *) b a.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (b -> a -> m b) -> b -> t a -> m b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yre $dMonad_s6Yrf f_s6Yrg z0_s6Yrh xs_s6Yri]
        let {
          sat_s6Yro [Occ=Once] :: b_a6KHt -> m_a6KHs b_a6KHt
          [LclId] =
              [$dMonad_s6Yrf] \u [] GHC.Base.return $dMonad_s6Yrf; } in
        let {
          sat_s6Yrn [Occ=Once]
            :: a_a6KHu
               -> (b_a6KHt -> m_a6KHs b_a6KHt) -> b_a6KHt -> m_a6KHs b_a6KHt
          [LclId] =
              [$dMonad_s6Yrf f_s6Yrg] \r [x_s6Yrj k_s6Yrk z_s6Yrl]
                  let {
                    sat_s6Yrm [Occ=Once] :: m_a6KHs b_a6KHt
                    [LclId] =
                        [f_s6Yrg x_s6Yrj z_s6Yrl] \u [] f_s6Yrg z_s6Yrl x_s6Yrj;
                  } in  GHC.Base.>>= $dMonad_s6Yrf sat_s6Yrm k_s6Yrk;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6Yre sat_s6Yrn sat_s6Yro xs_s6Yri z0_s6Yrh;

Data.Foldable.traverse_
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     (a -> f b) -> t a -> f ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yrp $dApplicative_s6Yrq f1_s6Yrr]
        let {
          sat_s6Yrv [Occ=Once] :: f_a6KGP ()
          [LclId] =
              [$dApplicative_s6Yrq] \u []
                  GHC.Base.pure $dApplicative_s6Yrq GHC.Tuple.(); } in
        let {
          sat_s6Yru [Occ=Once] :: a_a6KGQ -> f_a6KGP () -> f_a6KGP ()
          [LclId] =
              [$dApplicative_s6Yrq f1_s6Yrr] \r [x_s6Yrs]
                  let {
                    sat_s6Yrt [Occ=Once] :: f_a6KGP b_a6KGR
                    [LclId] =
                        [f1_s6Yrr x_s6Yrs] \u [] f1_s6Yrr x_s6Yrs;
                  } in  GHC.Base.*> $dApplicative_s6Yrq sat_s6Yrt;
        } in  Data.Foldable.foldr $dFoldable_s6Yrp sat_s6Yru sat_s6Yrv;

Data.Foldable.for_ [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     t a -> (a -> f b) -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yrw $dApplicative_s6Yrx x_s6Yry y_s6Yrz]
        Data.Foldable.traverse_
            $dFoldable_s6Yrw $dApplicative_s6Yrx y_s6Yrz x_s6Yry;

Data.Foldable.mapM_
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (a -> m b) -> t a -> m ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(U),1*C1(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrA $dMonad_s6YrB f_s6YrC]
        let {
          sat_s6YrG [Occ=Once] :: m_a6KG8 ()
          [LclId] =
              [$dMonad_s6YrB] \u []
                  GHC.Base.return $dMonad_s6YrB GHC.Tuple.(); } in
        let {
          sat_s6YrF [Occ=Once] :: a_a6KG9 -> m_a6KG8 () -> m_a6KG8 ()
          [LclId] =
              [$dMonad_s6YrB f_s6YrC] \r [x_s6YrD]
                  let {
                    sat_s6YrE [Occ=Once] :: m_a6KG8 b_a6KGa
                    [LclId] =
                        [f_s6YrC x_s6YrD] \u [] f_s6YrC x_s6YrD;
                  } in  GHC.Base.>> $dMonad_s6YrB sat_s6YrE;
        } in  Data.Foldable.foldr $dFoldable_s6YrA sat_s6YrF sat_s6YrG;

Data.Foldable.forM_ [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     t a -> (a -> m b) -> m ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(U),C(U),A)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrH $dMonad_s6YrI x_s6YrJ y_s6YrK]
        Data.Foldable.mapM_ $dFoldable_s6YrH $dMonad_s6YrI y_s6YrK x_s6YrJ;

Data.Foldable.sequenceA_
  :: forall (t :: * -> *) (f :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     t (f a) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(U),A,A,1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrL $dApplicative_s6YrM]
        let {
          sat_s6YrO [Occ=Once] :: f_a6KFQ ()
          [LclId] =
              [$dApplicative_s6YrM] \u []
                  GHC.Base.pure $dApplicative_s6YrM GHC.Tuple.(); } in
        let {
          sat_s6YrN [Occ=Once] :: f_a6KFQ a_a6KFR -> f_a6KFQ () -> f_a6KFQ ()
          [LclId] =
              [$dApplicative_s6YrM] \u [] GHC.Base.*> $dApplicative_s6YrM;
        } in  Data.Foldable.foldr $dFoldable_s6YrL sat_s6YrN sat_s6YrO;

Data.Foldable.sequence_
  :: forall (t :: * -> *) (m :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     t (m a) -> m ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,1*U,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrP $dMonad_s6YrQ]
        let {
          sat_s6YrS [Occ=Once] :: m_a6KFy ()
          [LclId] =
              [$dMonad_s6YrQ] \u []
                  GHC.Base.return $dMonad_s6YrQ GHC.Tuple.(); } in
        let {
          sat_s6YrR [Occ=Once] :: m_a6KFy a_a6KFz -> m_a6KFy () -> m_a6KFy ()
          [LclId] =
              [$dMonad_s6YrQ] \u [] GHC.Base.>> $dMonad_s6YrQ;
        } in  Data.Foldable.foldr $dFoldable_s6YrP sat_s6YrR sat_s6YrS;

Data.Foldable.asum [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Alternative f) =>
     t (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrT $dAlternative_s6YrU]
        let {
          sat_s6YrW [Occ=Once] :: f_a6KF3 a_a6KF4
          [LclId] =
              [$dAlternative_s6YrU] \u []
                  GHC.Base.empty $dAlternative_s6YrU; } in
        let {
          sat_s6YrV [Occ=Once]
            :: f_a6KF3 a_a6KF4 -> f_a6KF3 a_a6KF4 -> f_a6KF3 a_a6KF4
          [LclId] =
              [$dAlternative_s6YrU] \u [] GHC.Base.<|> $dAlternative_s6YrU;
        } in  Data.Foldable.foldr $dFoldable_s6YrT sat_s6YrV sat_s6YrW;

Data.Foldable.msum [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.MonadPlus m) =>
     t (m a) -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*U(A,1*U,1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrX $dMonadPlus_s6YrY]
        let {
          $dAlternative_s6YrZ [Dmd=<L,U(A,1*U,1*U,A,A)>]
            :: GHC.Base.Alternative m_a6KFm
          [LclId] =
              [$dMonadPlus_s6YrY] \u []
                  GHC.Base.$p1MonadPlus $dMonadPlus_s6YrY; } in
        let {
          sat_s6Ys1 [Occ=Once] :: m_a6KFm a_a6KFn
          [LclId] =
              [$dAlternative_s6YrZ] \u []
                  GHC.Base.empty $dAlternative_s6YrZ; } in
        let {
          sat_s6Ys0 [Occ=Once]
            :: m_a6KFm a_a6KFn -> m_a6KFm a_a6KFn -> m_a6KFm a_a6KFn
          [LclId] =
              [$dAlternative_s6YrZ] \u [] GHC.Base.<|> $dAlternative_s6YrZ;
        } in  Data.Foldable.foldr $dFoldable_s6YrX sat_s6Ys0 sat_s6Ys1;

Data.Foldable.concat [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *) a. Data.Foldable.Foldable t => t [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ys2 xs_s6Ys3]
        Data.Foldable.foldr
            $dFoldable_s6Ys2 GHC.Base.++ GHC.Types.[] xs_s6Ys3;

Data.Foldable.concatMap [InlPrag=INLINE (sat-args=2)]
  :: forall (t :: * -> *) a b.
     Data.Foldable.Foldable t =>
     (a -> [b]) -> t a -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ys4 f_s6Ys5 xs_s6Ys6]
        let {
          sat_s6Ysa [Occ=Once] :: a_a6KEs -> [b_a6KEt] -> [b_a6KEt]
          [LclId] =
              [f_s6Ys5] \r [x_s6Ys7 b1_s6Ys8]
                  case f_s6Ys5 x_s6Ys7 of sat_s6Ys9 {
                    __DEFAULT -> GHC.Base.++ sat_s6Ys9 b1_s6Ys8;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6Ys4 sat_s6Ysa GHC.Types.[] xs_s6Ys6;

Data.Foldable.and2 :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6Ysb] v_s6Ysb;

Data.Foldable.and1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ysc]
        Data.Foldable.foldMap
            $dFoldable_s6Ysc
            Data.Semigroup.Internal.$fMonoidAll
            Data.Foldable.and2;

Data.Foldable.and
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Foldable.and1 eta_B1;

Data.Foldable.or1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ysd]
        Data.Foldable.foldMap
            $dFoldable_s6Ysd
            Data.Semigroup.Internal.$fMonoidAny
            Data.Foldable.and2;

Data.Foldable.or
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Foldable.or1 eta_B1;

Data.Foldable.any1
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yse p_s6Ysf]
        Data.Foldable.foldMap
            $dFoldable_s6Yse Data.Semigroup.Internal.$fMonoidAny p_s6Ysf;

Data.Foldable.any
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Foldable.any1 eta_B2 eta_B1;

$dmelem1_r6OSW
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a.
     GHC.Classes.Eq a =>
     a -> t a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6Ysg $dEq_s6Ysh eta_s6Ysi]
        let {
          sat_s6Ysj [Occ=Once] :: a_a6KO9 -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_s6Ysh eta_s6Ysi] \u [] GHC.Classes.== $dEq_s6Ysh eta_s6Ysi;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Ysg Data.Semigroup.Internal.$fMonoidAny sat_s6Ysj;

Data.Foldable.$dmelem
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $dmelem1_r6OSW eta_B3 eta_B2 eta_B1;

Data.Foldable.$fFoldableURec11
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Word a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Ysk eta_s6Ysl eta1_s6Ysm]
        case eta1_s6Ysm of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec8
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Word a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ysp ds_s6Ysq]
        case ds_s6Ysq of {
          GHC.Generics.UWord _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Ysp;
        };

Data.Foldable.$fFoldable:*:2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableURec9
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yst] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ysu eta_s6Ysv]
        Data.Foldable.$fFoldableURec9 eta_s6Ysv;

Data.Foldable.$fFoldable:*:3 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableURec10
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Ysw] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ysx eta_s6Ysy]
        Data.Foldable.$fFoldableURec10 eta_s6Ysy;

Data.Foldable.$fFoldableURec_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Ysz xs_s6YsA] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Word a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YsB z0_s6YsC xs_s6YsD]
        case xs_s6YsD of { GHC.Generics.UWord _ [Occ=Dead] -> z0_s6YsC; };

Data.Foldable.$fFoldableURec_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6YsG]
        case xs_s6YsG of {
          GHC.Generics.UWord _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YsJ xs_s6YsK] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Word m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YsL ds_s6YsM]
        case ds_s6YsM of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YsL;
        };

Data.Foldable.$fFoldableURec7
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Word a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YsP ds_s6YsQ]
        case ds_s6YsQ of {
          GHC.Generics.UWord _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YsP;
        };

Data.Foldable.$fFoldableURec_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6YsT]
        case eta_s6YsT of { GHC.Generics.UWord _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Word)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec_$cfold
                                             Data.Foldable.$fFoldableURec_$cfoldMap
                                             Data.Foldable.$fFoldableURec_$cfoldr
                                             Data.Foldable.$fFoldableURec_$cfoldr
                                             Data.Foldable.$fFoldableURec_$cfoldl'
                                             Data.Foldable.$fFoldableURec_$cfoldl'
                                             Data.Foldable.$fFoldableURec_$cfoldr1
                                             Data.Foldable.$fFoldableURec_$cfoldl1
                                             Data.Foldable.$fFoldableURec_$ctoList
                                             Data.Foldable.$fFoldableURec_$cnull
                                             Data.Foldable.$fFoldableURec_$clength
                                             Data.Foldable.$fFoldableURec11
                                             Data.Foldable.$fFoldableURec_$cmaximum
                                             Data.Foldable.$fFoldableURec_$cminimum
                                             Data.Foldable.$fFoldableURec8
                                             Data.Foldable.$fFoldableURec7];

Data.Foldable.$fFoldableURec16
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Int a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YsW eta_s6YsX eta1_s6YsY]
        case eta1_s6YsY of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec13
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Int a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yt1 ds_s6Yt2]
        case ds_s6Yt2 of {
          GHC.Generics.UInt _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Yt1;
        };

Data.Foldable.$fFoldableURec14
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yt5] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec0_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yt6 eta_s6Yt7]
        Data.Foldable.$fFoldableURec14 eta_s6Yt7;

Data.Foldable.$fFoldableURec15
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yt8] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec0_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yt9 eta_s6Yta]
        Data.Foldable.$fFoldableURec15 eta_s6Yta;

Data.Foldable.$fFoldableURec0_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Ytb xs_s6Ytc] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec0_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Int a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Ytd z0_s6Yte xs_s6Ytf]
        case xs_s6Ytf of { GHC.Generics.UInt _ [Occ=Dead] -> z0_s6Yte; };

Data.Foldable.$fFoldableURec0_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6Yti]
        case xs_s6Yti of {
          GHC.Generics.UInt _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec0_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Ytl xs_s6Ytm] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec0_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Int m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ytn ds_s6Yto]
        case ds_s6Yto of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Ytn;
        };

Data.Foldable.$fFoldableURec12
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Int a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ytr ds_s6Yts]
        case ds_s6Yts of {
          GHC.Generics.UInt _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Ytr;
        };

Data.Foldable.$fFoldableURec0_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6Ytv]
        case eta_s6Ytv of { GHC.Generics.UInt _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec0 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Int)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec0_$cfold
                                             Data.Foldable.$fFoldableURec0_$cfoldMap
                                             Data.Foldable.$fFoldableURec0_$cfoldr
                                             Data.Foldable.$fFoldableURec0_$cfoldr
                                             Data.Foldable.$fFoldableURec0_$cfoldl'
                                             Data.Foldable.$fFoldableURec0_$cfoldl'
                                             Data.Foldable.$fFoldableURec0_$cfoldr1
                                             Data.Foldable.$fFoldableURec0_$cfoldl1
                                             Data.Foldable.$fFoldableURec0_$ctoList
                                             Data.Foldable.$fFoldableURec0_$cnull
                                             Data.Foldable.$fFoldableURec0_$clength
                                             Data.Foldable.$fFoldableURec16
                                             Data.Foldable.$fFoldableURec0_$cmaximum
                                             Data.Foldable.$fFoldableURec0_$cminimum
                                             Data.Foldable.$fFoldableURec13
                                             Data.Foldable.$fFoldableURec12];

Data.Foldable.$fFoldableURec21
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Yty eta_s6Ytz eta1_s6YtA]
        case eta1_s6YtA of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec18
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YtD ds_s6YtE]
        case ds_s6YtE of {
          GHC.Generics.UFloat _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YtD;
        };

Data.Foldable.$fFoldableURec19
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6YtH] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec1_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YtI eta_s6YtJ]
        Data.Foldable.$fFoldableURec19 eta_s6YtJ;

Data.Foldable.$fFoldableURec20
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6YtK] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec1_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YtL eta_s6YtM]
        Data.Foldable.$fFoldableURec20 eta_s6YtM;

Data.Foldable.$fFoldableURec1_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YtN xs_s6YtO] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec1_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Float a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YtP z0_s6YtQ xs_s6YtR]
        case xs_s6YtR of { GHC.Generics.UFloat _ [Occ=Dead] -> z0_s6YtQ; };

Data.Foldable.$fFoldableURec1_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6YtU]
        case xs_s6YtU of {
          GHC.Generics.UFloat _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec1_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YtX xs_s6YtY] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec1_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Float m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YtZ ds_s6Yu0]
        case ds_s6Yu0 of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YtZ;
        };

Data.Foldable.$fFoldableURec17
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yu3 ds_s6Yu4]
        case ds_s6Yu4 of {
          GHC.Generics.UFloat _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Yu3;
        };

Data.Foldable.$fFoldableURec1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6Yu7]
        case eta_s6Yu7 of { GHC.Generics.UFloat _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Float)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec1_$cfold
                                             Data.Foldable.$fFoldableURec1_$cfoldMap
                                             Data.Foldable.$fFoldableURec1_$cfoldr
                                             Data.Foldable.$fFoldableURec1_$cfoldr
                                             Data.Foldable.$fFoldableURec1_$cfoldl'
                                             Data.Foldable.$fFoldableURec1_$cfoldl'
                                             Data.Foldable.$fFoldableURec1_$cfoldr1
                                             Data.Foldable.$fFoldableURec1_$cfoldl1
                                             Data.Foldable.$fFoldableURec1_$ctoList
                                             Data.Foldable.$fFoldableURec1_$cnull
                                             Data.Foldable.$fFoldableURec1_$clength
                                             Data.Foldable.$fFoldableURec21
                                             Data.Foldable.$fFoldableURec1_$cmaximum
                                             Data.Foldable.$fFoldableURec1_$cminimum
                                             Data.Foldable.$fFoldableURec18
                                             Data.Foldable.$fFoldableURec17];

Data.Foldable.$fFoldableURec26
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Yua eta_s6Yub eta1_s6Yuc]
        case eta1_s6Yuc of {
          GHC.Generics.UDouble _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec23
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yuf ds_s6Yug]
        case ds_s6Yug of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Yuf;
        };

Data.Foldable.$fFoldableURec24
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yuj] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec2_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yuk eta_s6Yul]
        Data.Foldable.$fFoldableURec24 eta_s6Yul;

Data.Foldable.$fFoldableURec25
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yum] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec2_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yun eta_s6Yuo]
        Data.Foldable.$fFoldableURec25 eta_s6Yuo;

Data.Foldable.$fFoldableURec2_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Yup xs_s6Yuq] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec2_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Double a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Yur z0_s6Yus xs_s6Yut]
        case xs_s6Yut of {
          GHC.Generics.UDouble _ [Occ=Dead] -> z0_s6Yus;
        };

Data.Foldable.$fFoldableURec2_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6Yuw]
        case xs_s6Yuw of {
          GHC.Generics.UDouble _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec2_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Yuz xs_s6YuA] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec2_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Double m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YuB ds_s6YuC]
        case ds_s6YuC of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              GHC.Base.mempty $dMonoid_s6YuB;
        };

Data.Foldable.$fFoldableURec22
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YuF ds_s6YuG]
        case ds_s6YuG of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YuF;
        };

Data.Foldable.$fFoldableURec2_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6YuJ]
        case eta_s6YuJ of { GHC.Generics.UDouble _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec2 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Double)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec2_$cfold
                                             Data.Foldable.$fFoldableURec2_$cfoldMap
                                             Data.Foldable.$fFoldableURec2_$cfoldr
                                             Data.Foldable.$fFoldableURec2_$cfoldr
                                             Data.Foldable.$fFoldableURec2_$cfoldl'
                                             Data.Foldable.$fFoldableURec2_$cfoldl'
                                             Data.Foldable.$fFoldableURec2_$cfoldr1
                                             Data.Foldable.$fFoldableURec2_$cfoldl1
                                             Data.Foldable.$fFoldableURec2_$ctoList
                                             Data.Foldable.$fFoldableURec2_$cnull
                                             Data.Foldable.$fFoldableURec2_$clength
                                             Data.Foldable.$fFoldableURec26
                                             Data.Foldable.$fFoldableURec2_$cmaximum
                                             Data.Foldable.$fFoldableURec2_$cminimum
                                             Data.Foldable.$fFoldableURec23
                                             Data.Foldable.$fFoldableURec22];

Data.Foldable.$fFoldableURec31
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Char a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YuM eta_s6YuN eta1_s6YuO]
        case eta1_s6YuO of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec28
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Char a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YuR ds_s6YuS]
        case ds_s6YuS of {
          GHC.Generics.UChar _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YuR;
        };

Data.Foldable.$fFoldableURec29
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6YuV] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec3_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YuW eta_s6YuX]
        Data.Foldable.$fFoldableURec29 eta_s6YuX;

Data.Foldable.$fFoldableURec30
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6YuY] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec3_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YuZ eta_s6Yv0]
        Data.Foldable.$fFoldableURec30 eta_s6Yv0;

Data.Foldable.$fFoldableURec3_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Yv1 xs_s6Yv2] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec3_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Char a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Yv3 z0_s6Yv4 xs_s6Yv5]
        case xs_s6Yv5 of { GHC.Generics.UChar _ [Occ=Dead] -> z0_s6Yv4; };

Data.Foldable.$fFoldableURec3_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6Yv8]
        case xs_s6Yv8 of {
          GHC.Generics.UChar _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec3_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Yvb xs_s6Yvc] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec3_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Char m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yvd ds_s6Yve]
        case ds_s6Yve of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Yvd;
        };

Data.Foldable.$fFoldableURec27
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Char a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yvh ds_s6Yvi]
        case ds_s6Yvi of {
          GHC.Generics.UChar _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Yvh;
        };

Data.Foldable.$fFoldableURec3_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6Yvl]
        case eta_s6Yvl of { GHC.Generics.UChar _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec3 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Char)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec3_$cfold
                                             Data.Foldable.$fFoldableURec3_$cfoldMap
                                             Data.Foldable.$fFoldableURec3_$cfoldr
                                             Data.Foldable.$fFoldableURec3_$cfoldr
                                             Data.Foldable.$fFoldableURec3_$cfoldl'
                                             Data.Foldable.$fFoldableURec3_$cfoldl'
                                             Data.Foldable.$fFoldableURec3_$cfoldr1
                                             Data.Foldable.$fFoldableURec3_$cfoldl1
                                             Data.Foldable.$fFoldableURec3_$ctoList
                                             Data.Foldable.$fFoldableURec3_$cnull
                                             Data.Foldable.$fFoldableURec3_$clength
                                             Data.Foldable.$fFoldableURec31
                                             Data.Foldable.$fFoldableURec3_$cmaximum
                                             Data.Foldable.$fFoldableURec3_$cminimum
                                             Data.Foldable.$fFoldableURec28
                                             Data.Foldable.$fFoldableURec27];

Data.Foldable.$fFoldableURec36
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Yvo eta_s6Yvp eta1_s6Yvq]
        case eta1_s6Yvq of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec33
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yvt ds_s6Yvu]
        case ds_s6Yvu of {
          GHC.Generics.UAddr _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Yvt;
        };

Data.Foldable.$fFoldableURec34
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yvx] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec4_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yvy eta_s6Yvz]
        Data.Foldable.$fFoldableURec34 eta_s6Yvz;

Data.Foldable.$fFoldableURec35
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6YvA] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec4_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YvB eta_s6YvC]
        Data.Foldable.$fFoldableURec35 eta_s6YvC;

Data.Foldable.$fFoldableURec4_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YvD xs_s6YvE] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec4_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YvF z0_s6YvG xs_s6YvH]
        case xs_s6YvH of { GHC.Generics.UAddr _ [Occ=Dead] -> z0_s6YvG; };

Data.Foldable.$fFoldableURec4_$clength
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6YvK]
        case xs_s6YvK of {
          GHC.Generics.UAddr _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec4_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YvN xs_s6YvO] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec4_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YvP ds_s6YvQ]
        case ds_s6YvQ of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YvP;
        };

Data.Foldable.$fFoldableURec32
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YvT ds_s6YvU]
        case ds_s6YvU of {
          GHC.Generics.UAddr _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YvT;
        };

Data.Foldable.$fFoldableURec4_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6YvX]
        case eta_s6YvX of { GHC.Generics.UAddr _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec4 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec (GHC.Ptr.Ptr ()))
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec4_$cfold
                                             Data.Foldable.$fFoldableURec4_$cfoldMap
                                             Data.Foldable.$fFoldableURec4_$cfoldr
                                             Data.Foldable.$fFoldableURec4_$cfoldr
                                             Data.Foldable.$fFoldableURec4_$cfoldl'
                                             Data.Foldable.$fFoldableURec4_$cfoldl'
                                             Data.Foldable.$fFoldableURec4_$cfoldr1
                                             Data.Foldable.$fFoldableURec4_$cfoldl1
                                             Data.Foldable.$fFoldableURec4_$ctoList
                                             Data.Foldable.$fFoldableURec4_$cnull
                                             Data.Foldable.$fFoldableURec4_$clength
                                             Data.Foldable.$fFoldableURec36
                                             Data.Foldable.$fFoldableURec4_$cmaximum
                                             Data.Foldable.$fFoldableURec4_$cminimum
                                             Data.Foldable.$fFoldableURec33
                                             Data.Foldable.$fFoldableURec32];

Data.Foldable.$fFoldable:*:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:*:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yw0 $dFoldable1_s6Yw1 $dEq_s6Yw2 eta_s6Yw3]
        let {
          f1_s6Yw4 :: a_a6Lad -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Yw2 eta_s6Yw3] \u []
                  GHC.Classes.== $dEq_s6Yw2 eta_s6Yw3; } in
        let {
          sat_s6Ywa [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lad
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6Yw0 $dFoldable1_s6Yw1 f1_s6Yw4] \r [ds_s6Yw5]
                  case ds_s6Yw5 of {
                    GHC.Generics.:*: a1_s6Yw7 [Occ=Once] a2_s6Yw8 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6Yw0
                                Data.Semigroup.Internal.$fMonoidAny
                                f1_s6Yw4
                                a1_s6Yw7
                        of
                        { GHC.Types.False ->
                              Data.Foldable.foldMap
                                  $dFoldable1_s6Yw1
                                  Data.Semigroup.Internal.$fMonoidAny
                                  f1_s6Yw4
                                  a2_s6Yw8;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_s6Ywa;

Data.Foldable.$fFoldable:*:_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ywb $dFoldable1_s6Ywc $dNum_s6Ywd]
        let {
          $dMonoid_s6Ywe
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LaH)
          [LclId] =
              [$dNum_s6Ywd] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6Ywd; } in
        let {
          sat_s6Ywl [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6LaH
               -> Data.Semigroup.Internal.Sum a_a6LaH
          [LclId] =
              [$dFoldable_s6Ywb
               $dFoldable1_s6Ywc
               $dNum_s6Ywd
               $dMonoid_s6Ywe] \r [ds_s6Ywf]
                  case ds_s6Ywf of {
                    GHC.Generics.:*: a1_s6Ywh [Occ=Once] a2_s6Ywi [Occ=Once] ->
                        let {
                          sat_s6Ywk [Occ=Once] :: a_a6LaH
                          [LclId] =
                              [$dFoldable1_s6Ywc $dMonoid_s6Ywe a2_s6Ywi] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_s6Ywc
                                      $dMonoid_s6Ywe
                                      Data.Foldable.$fFoldable:*:1
                                      a2_s6Ywi; } in
                        let {
                          sat_s6Ywj [Occ=Once] :: a_a6LaH
                          [LclId] =
                              [$dFoldable_s6Ywb $dMonoid_s6Ywe a1_s6Ywh] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Ywb
                                      $dMonoid_s6Ywe
                                      Data.Foldable.$fFoldable:*:1
                                      a1_s6Ywh;
                        } in  GHC.Num.+ $dNum_s6Ywd sat_s6Ywj sat_s6Ywk;
                  };
        } in  sat_s6Ywl;

Data.Foldable.$fFoldable:*:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ywm $dFoldable1_s6Ywn $dOrd_s6Ywo]
        let {
          $dMonoid_s6Ywp :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6Lax)
          [LclId] =
              [$dOrd_s6Ywo] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6Ywo; } in
        let {
          sat_s6YwB [Occ=OnceT[0]]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lax -> a_a6Lax
          [LclId] =
              [$dFoldable_s6Ywm
               $dFoldable1_s6Ywn
               $dOrd_s6Ywo
               $dMonoid_s6Ywp] \r [x_s6Ywq]
                  case x_s6Ywq of {
                    GHC.Generics.:*: a1_s6Yws [Occ=Once*] a2_s6Ywt [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6Ywn $dMonoid_s6Ywp GHC.Base.Just a2_s6Ywt
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Ywm $dMonoid_s6Ywp GHC.Base.Just a1_s6Yws
                              of
                              { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                                GHC.Base.Just v_s6Yww [Occ=Once] -> v_s6Yww;
                              };
                          GHC.Base.Just ipv_s6Ywx ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Ywm $dMonoid_s6Ywp GHC.Base.Just a1_s6Yws
                              of
                              { GHC.Base.Nothing -> ipv_s6Ywx;
                                GHC.Base.Just x1_s6Ywz ->
                                    case GHC.Classes.<= $dOrd_s6Ywo x1_s6Ywz ipv_s6Ywx of {
                                      GHC.Types.False -> ipv_s6Ywx;
                                      GHC.Types.True -> x1_s6Ywz;
                                    };
                              };
                        };
                  };
        } in  sat_s6YwB;

Data.Foldable.$fFoldable:*:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YwC $dFoldable1_s6YwD $dOrd_s6YwE]
        let {
          $dMonoid_s6YwF :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lan)
          [LclId] =
              [$dOrd_s6YwE] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6YwE; } in
        let {
          sat_s6YwR [Occ=OnceT[0]]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lan -> a_a6Lan
          [LclId] =
              [$dFoldable_s6YwC
               $dFoldable1_s6YwD
               $dOrd_s6YwE
               $dMonoid_s6YwF] \r [x_s6YwG]
                  case x_s6YwG of {
                    GHC.Generics.:*: a1_s6YwI [Occ=Once*] a2_s6YwJ [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6YwD $dMonoid_s6YwF GHC.Base.Just a2_s6YwJ
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6YwC $dMonoid_s6YwF GHC.Base.Just a1_s6YwI
                              of
                              { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                                GHC.Base.Just v_s6YwM [Occ=Once] -> v_s6YwM;
                              };
                          GHC.Base.Just ipv_s6YwN ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6YwC $dMonoid_s6YwF GHC.Base.Just a1_s6YwI
                              of
                              { GHC.Base.Nothing -> ipv_s6YwN;
                                GHC.Base.Just x1_s6YwP ->
                                    case GHC.Classes.>= $dOrd_s6YwE x1_s6YwP ipv_s6YwN of {
                                      GHC.Types.False -> ipv_s6YwN;
                                      GHC.Types.True -> x1_s6YwP;
                                    };
                              };
                        };
                  };
        } in  sat_s6YwR;

Data.Foldable.$w$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6YwS w1_s6YwT w2_s6YwU ww_s6YwV ww1_s6YwW]
        let {
          f1_s6YwX
            :: a_s6NTG -> GHC.Base.Maybe a_s6NTG -> GHC.Base.Maybe a_s6NTG
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_s6YwU] \r [x_s6YwY m_s6YwZ]
                  let {
                    sat_s6Yx2 [Occ=Once] :: a_s6NTG
                    [LclId] =
                        [w2_s6YwU x_s6YwY m_s6YwZ] \u []
                            case m_s6YwZ of {
                              GHC.Base.Nothing -> x_s6YwY;
                              GHC.Base.Just y_s6Yx1 [Occ=Once] -> w2_s6YwU x_s6YwY y_s6Yx1;
                            };
                  } in  GHC.Base.Just [sat_s6Yx2]; } in
        let {
          sat_s6Yx3 [Occ=Once] :: GHC.Base.Maybe a_s6NTG
          [LclId] =
              [w1_s6YwT ww1_s6YwW f1_s6YwX] \u []
                  Data.Foldable.foldr w1_s6YwT f1_s6YwX GHC.Base.Nothing ww1_s6YwW;
        } in 
          case Data.Foldable.foldr w_s6YwS f1_s6YwX sat_s6Yx3 ww_s6YwV of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6Yx5 [Occ=Once] -> v_s6Yx5;
          };

Data.Foldable.$fFoldable:*:_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Yx6 w1_s6Yx7 w2_s6Yx8 w3_s6Yx9]
        case w3_s6Yx9 of {
          GHC.Generics.:*: ww1_s6Yxb [Occ=Once] ww2_s6Yxc [Occ=Once] ->
              Data.Foldable.$w$cfoldr1
                  w_s6Yx6 w1_s6Yx7 w2_s6Yx8 ww1_s6Yxb ww2_s6Yxc;
        };

Data.Foldable.$w$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Yxd w1_s6Yxe w2_s6Yxf w3_s6Yxg ww_s6Yxh ww1_s6Yxi]
        let {
          f1_s6Yxj :: a_s6NTU -> (b_s6NTT -> b_s6NTT) -> b_s6NTT -> b_s6NTT
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_s6Yxf] \r [x_s6Yxk k_s6Yxl z_s6Yxm]
                  case w2_s6Yxf z_s6Yxm x_s6Yxk of vx_s6Yxn {
                    __DEFAULT -> k_s6Yxl vx_s6Yxn;
                  }; } in
        let {
          sat_s6Yxo [Occ=Once] :: b_s6NTT -> b_s6NTT
          [LclId] =
              [w1_s6Yxe ww1_s6Yxi f1_s6Yxj] \u []
                  Data.Foldable.foldr w1_s6Yxe f1_s6Yxj GHC.Base.id ww1_s6Yxi;
        } in 
          Data.Foldable.foldr w_s6Yxd f1_s6Yxj sat_s6Yxo ww_s6Yxh w3_s6Yxg;

Data.Foldable.$fFoldable:*:_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Yxp w1_s6Yxq w2_s6Yxr w3_s6Yxs w4_s6Yxt]
        case w4_s6Yxt of {
          GHC.Generics.:*: ww1_s6Yxv [Occ=Once] ww2_s6Yxw [Occ=Once] ->
              Data.Foldable.$w$cfoldl'
                  w_s6Yxp w1_s6Yxq w2_s6Yxr w3_s6Yxs ww1_s6Yxv ww2_s6Yxw;
        };

Data.Foldable.$fFoldableM2
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s6Yxx k_s6Yxy z_s6Yxz]
        case z_s6Yxz of {
          GHC.Types.I# x1_s6YxB [Occ=Once] ->
              case +# [x1_s6YxB 1#] of sat_s6YxC {
                __DEFAULT ->
                    let {
                      sat_s6YxD [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_s6YxC];
                    } in  k_s6Yxy sat_s6YxD;
              };
        };

Data.Foldable.$fFoldable:*:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YxE $dFoldable1_s6YxF eta_s6YxG]
        case eta_s6YxG of {
          GHC.Generics.:*: ww1_s6YxI [Occ=Once] ww2_s6YxJ [Occ=Once] ->
              let {
                sat_s6YxK [Occ=Once] :: GHC.Types.Int -> GHC.Types.Int
                [LclId] =
                    [$dFoldable1_s6YxF ww2_s6YxJ] \u []
                        Data.Foldable.foldr
                            $dFoldable1_s6YxF Data.Foldable.$fFoldableM2 GHC.Base.id ww2_s6YxJ;
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6YxE
                    Data.Foldable.$fFoldableM2
                    sat_s6YxK
                    ww1_s6YxI
                    Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$w$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6YxL w1_s6YxM w2_s6YxN w3_s6YxO ww_s6YxP ww1_s6YxQ]
        let {
          f1_s6YxR :: a_s6NU9 -> b_s6NU8 -> b_s6NU8
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w2_s6YxN] \r [x_s6YxS y_s6YxT] w2_s6YxN y_s6YxT x_s6YxS; } in
        let {
          sat_s6YxU [Occ=Once] :: b_s6NU8
          [LclId] =
              [w_s6YxL w3_s6YxO ww_s6YxP f1_s6YxR] \u []
                  Data.Foldable.foldMap
                      w_s6YxL Data.Foldable.$fFoldable:*:7 f1_s6YxR ww_s6YxP w3_s6YxO;
        } in 
          Data.Foldable.foldMap
              w1_s6YxM Data.Foldable.$fFoldable:*:7 f1_s6YxR ww1_s6YxQ sat_s6YxU;

Data.Foldable.$fFoldable:*:_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YxV w1_s6YxW w2_s6YxX w3_s6YxY w4_s6YxZ]
        case w4_s6YxZ of {
          GHC.Generics.:*: ww1_s6Yy1 [Occ=Once] ww2_s6Yy2 [Occ=Once] ->
              Data.Foldable.$w$cfoldl
                  w_s6YxV w1_s6YxW w2_s6YxX w3_s6YxY ww1_s6Yy1 ww2_s6Yy2;
        };

Data.Foldable.$w$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Yy3 w1_s6Yy4 w2_s6Yy5 ww_s6Yy6 ww1_s6Yy7]
        let {
          f1_s6Yy8
            :: a_s6NUn -> GHC.Base.Maybe a_s6NUn -> GHC.Base.Maybe a_s6NUn
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_s6Yy5] \r [x_s6Yy9 y_s6Yya]
                  let {
                    sat_s6Yyd [Occ=Once] :: a_s6NUn
                    [LclId] =
                        [w2_s6Yy5 x_s6Yy9 y_s6Yya] \u []
                            case y_s6Yya of {
                              GHC.Base.Nothing -> x_s6Yy9;
                              GHC.Base.Just x1_s6Yyc [Occ=Once] -> w2_s6Yy5 x1_s6Yyc x_s6Yy9;
                            };
                  } in  GHC.Base.Just [sat_s6Yyd]; } in
        let {
          sat_s6Yye [Occ=Once] :: GHC.Base.Maybe a_s6NUn
          [LclId] =
              [w_s6Yy3 ww_s6Yy6 f1_s6Yy8] \u []
                  Data.Foldable.foldMap
                      w_s6Yy3
                      Data.Foldable.$fFoldable:*:7
                      f1_s6Yy8
                      ww_s6Yy6
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w1_s6Yy4 Data.Foldable.$fFoldable:*:7 f1_s6Yy8 ww1_s6Yy7 sat_s6Yye
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6Yyg [Occ=Once] -> v_s6Yyg;
          };

Data.Foldable.$fFoldable:*:_$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Yyh w1_s6Yyi w2_s6Yyj w3_s6Yyk]
        case w3_s6Yyk of {
          GHC.Generics.:*: ww1_s6Yym [Occ=Once] ww2_s6Yyn [Occ=Once] ->
              Data.Foldable.$w$cfoldl1
                  w_s6Yyh w1_s6Yyi w2_s6Yyj ww1_s6Yym ww2_s6Yyn;
        };

Data.Foldable.$w$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Yyo w1_s6Yyp w2_s6Yyq w3_s6Yyr ww_s6Yys ww1_s6Yyt]
        let {
          f1_s6Yyu :: a_s6NUA -> (b_s6NUB -> b_s6NUB) -> b_s6NUB -> b_s6NUB
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_s6Yyq] \r [x_s6Yyv y_s6Yyw z_s6Yyx]
                  case w2_s6Yyq x_s6Yyv z_s6Yyx of vx_s6Yyy {
                    __DEFAULT -> y_s6Yyw vx_s6Yyy;
                  }; } in
        let {
          sat_s6Yyz [Occ=Once] :: b_s6NUB -> b_s6NUB
          [LclId] =
              [w_s6Yyo ww_s6Yys f1_s6Yyu] \u []
                  Data.Foldable.foldMap
                      w_s6Yyo Data.Foldable.$fFoldable:*:7 f1_s6Yyu ww_s6Yys GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w1_s6Yyp
              Data.Foldable.$fFoldable:*:7
              f1_s6Yyu
              ww1_s6Yyt
              sat_s6Yyz
              w3_s6Yyr;

Data.Foldable.$fFoldable:*:_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YyA w1_s6YyB w2_s6YyC w3_s6YyD w4_s6YyE]
        case w4_s6YyE of {
          GHC.Generics.:*: ww1_s6YyG [Occ=Once] ww2_s6YyH [Occ=Once] ->
              Data.Foldable.$w$cfoldr'
                  w_s6YyA w1_s6YyB w2_s6YyC w3_s6YyD ww1_s6YyG ww2_s6YyH;
        };

Data.Foldable.$fFoldable:*:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:*:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YyI $dFoldable1_s6YyJ $dMonoid_s6YyK w_s6YyL]
        case w_s6YyL of {
          GHC.Generics.:*: ww1_s6YyN [Occ=Once] ww2_s6YyO [Occ=Once] ->
              Data.Foldable.$w$cfoldMap
                  $dFoldable_s6YyI
                  $dFoldable1_s6YyJ
                  $dMonoid_s6YyK
                  GHC.Base.id
                  ww1_s6YyN
                  ww2_s6YyO;
        };

Data.Foldable.$fFoldable:*:_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YyP $dFoldable1_s6YyQ $dNum_s6YyR]
        let {
          $dMonoid_s6YyS
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LaR)
          [LclId] =
              [$dNum_s6YyR] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6YyR; } in
        let {
          sat_s6YyZ [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6LaR
               -> Data.Semigroup.Internal.Product a_a6LaR
          [LclId] =
              [$dFoldable_s6YyP
               $dFoldable1_s6YyQ
               $dNum_s6YyR
               $dMonoid_s6YyS] \r [ds_s6YyT]
                  case ds_s6YyT of {
                    GHC.Generics.:*: a1_s6YyV [Occ=Once] a2_s6YyW [Occ=Once] ->
                        let {
                          sat_s6YyY [Occ=Once] :: a_a6LaR
                          [LclId] =
                              [$dFoldable1_s6YyQ $dMonoid_s6YyS a2_s6YyW] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_s6YyQ
                                      $dMonoid_s6YyS
                                      Data.Foldable.$fFoldable:*:1
                                      a2_s6YyW; } in
                        let {
                          sat_s6YyX [Occ=Once] :: a_a6LaR
                          [LclId] =
                              [$dFoldable_s6YyP $dMonoid_s6YyS a1_s6YyV] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_s6YyP
                                      $dMonoid_s6YyS
                                      Data.Foldable.$fFoldable:*:1
                                      a1_s6YyV;
                        } in  GHC.Num.* $dNum_s6YyR sat_s6YyX sat_s6YyY;
                  };
        } in  sat_s6YyZ;

Data.Foldable.$fFoldable:*:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yz0 $dFoldable1_s6Yz1 eta_s6Yz2]
        case eta_s6Yz2 of {
          GHC.Generics.:*: a1_s6Yz4 [Occ=Once] a2_s6Yz5 [Occ=Once] ->
              let {
                sat_s6Yz6 [Occ=Once] :: [a_a6L9L]
                [LclId] =
                    [$dFoldable1_s6Yz1 a2_s6Yz5] \u []
                        Data.Foldable.foldr
                            $dFoldable1_s6Yz1 GHC.Types.: GHC.Types.[] a2_s6Yz5;
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6Yz0 GHC.Types.: sat_s6Yz6 a1_s6Yz4;
        };

Data.Foldable.$fFoldable:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6Yz7 $dFoldable1_s6Yz8]
        let {
          sat_s6Yzo [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cproduct
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzn [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$csum
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzm [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cminimum
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzl [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cmaximum
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzk [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$celem
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B2 eta_B1; } in
        let {
          sat_s6Yzj [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$clength
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzi [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cnull
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzh [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> [a]
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$ctoList
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzg [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl1
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B2 eta_B1; } in
        let {
          sat_s6Yzf [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr1
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B2 eta_B1; } in
        let {
          sat_s6Yze [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl'
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Yzd [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Yzc [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr'
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Yzb [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Yza [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> m
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldMap
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Yz9 [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S m -> m
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfold
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6Yz9
                                    sat_s6Yza
                                    sat_s6Yzb
                                    sat_s6Yzc
                                    sat_s6Yzd
                                    sat_s6Yze
                                    sat_s6Yzf
                                    sat_s6Yzg
                                    sat_s6Yzh
                                    sat_s6Yzi
                                    sat_s6Yzj
                                    sat_s6Yzk
                                    sat_s6Yzl
                                    sat_s6Yzm
                                    sat_s6Yzn
                                    sat_s6Yzo];

Data.Foldable.$fFoldable:+:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:+:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yzp $dFoldable1_s6Yzq $dEq_s6Yzr eta_s6Yzs]
        let {
          f1_s6Yzt [Occ=OnceL*] :: a_a6Ldk -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Yzr eta_s6Yzs] \u []
                  GHC.Classes.== $dEq_s6Yzr eta_s6Yzs; } in
        let {
          sat_s6Yzy [Occ=Once]
            :: (GHC.Generics.:+:) f_X6LpN g_X6LpP a_a6Ldk
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6Yzp $dFoldable1_s6Yzq f1_s6Yzt] \r [ds_s6Yzu]
                  case ds_s6Yzu of {
                    GHC.Generics.L1 a1_s6Yzw [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6Yzp
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_s6Yzt
                            a1_s6Yzw;
                    GHC.Generics.R1 a1_s6Yzx [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6Yzq
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_s6Yzt
                            a1_s6Yzx;
                  };
        } in  sat_s6Yzy;

Data.Foldable.$fFoldable:+:2
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     (GHC.Generics.:+:) f g a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yzz $dFoldable1_s6YzA $dNum_s6YzB]
        let {
          $dMonoid_s6YzC [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LdO)
          [LclId] =
              [$dNum_s6YzB] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6YzB; } in
        let {
          sat_s6YzH [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpF g_X6LpH a_a6LdO
               -> Data.Semigroup.Internal.Sum a_a6LdO
          [LclId] =
              [$dFoldable_s6Yzz $dFoldable1_s6YzA $dMonoid_s6YzC] \r [ds_s6YzD]
                  case ds_s6YzD of {
                    GHC.Generics.L1 a1_s6YzF [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6Yzz
                            $dMonoid_s6YzC
                            Data.Foldable.$fFoldable:*:1
                            a1_s6YzF;
                    GHC.Generics.R1 a1_s6YzG [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6YzA
                            $dMonoid_s6YzC
                            Data.Foldable.$fFoldable:*:1
                            a1_s6YzG;
                  };
        } in  sat_s6YzH;

Data.Foldable.$fFoldable:+:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YzI $dFoldable1_s6YzJ $dOrd_s6YzK]
        let {
          g1_s6YzL [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6LdE)
          [LclId] =
              [$dOrd_s6YzK] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6YzK; } in
        let {
          sat_s6YzU [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpE g_X6LpG a_a6LdE -> a_a6LdE
          [LclId] =
              [$dFoldable_s6YzI $dFoldable1_s6YzJ g1_s6YzL] \r [x_s6YzM]
                  case x_s6YzM of {
                    GHC.Generics.L1 a1_s6YzO [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6YzI g1_s6YzL GHC.Base.Just a1_s6YzO
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                          GHC.Base.Just v_s6YzQ [Occ=Once] -> v_s6YzQ;
                        };
                    GHC.Generics.R1 a1_s6YzR [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6YzJ g1_s6YzL GHC.Base.Just a1_s6YzR
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                          GHC.Base.Just v_s6YzT [Occ=Once] -> v_s6YzT;
                        };
                  };
        } in  sat_s6YzU;

Data.Foldable.$fFoldable:+:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YzV $dFoldable1_s6YzW $dOrd_s6YzX]
        let {
          g1_s6YzY [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Ldu)
          [LclId] =
              [$dOrd_s6YzX] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6YzX; } in
        let {
          sat_s6YA7 [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpD g_X6LpF a_a6Ldu -> a_a6Ldu
          [LclId] =
              [$dFoldable_s6YzV $dFoldable1_s6YzW g1_s6YzY] \r [x_s6YzZ]
                  case x_s6YzZ of {
                    GHC.Generics.L1 a1_s6YA1 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6YzV g1_s6YzY GHC.Base.Just a1_s6YA1
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                          GHC.Base.Just v_s6YA3 [Occ=Once] -> v_s6YA3;
                        };
                    GHC.Generics.R1 a1_s6YA4 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6YzW g1_s6YzY GHC.Base.Just a1_s6YA4
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                          GHC.Base.Just v_s6YA6 [Occ=Once] -> v_s6YA6;
                        };
                  };
        } in  sat_s6YA7;

Data.Foldable.$fFoldable:+:_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YA8 $dFoldable1_s6YA9 f1_s6YAa xs_s6YAb]
        case xs_s6YAb of {
          GHC.Generics.L1 a1_s6YAd [Occ=Once] ->
              let {
                sat_s6YAj [Occ=Once]
                  :: a_a6LcC -> GHC.Base.Maybe a_a6LcC -> GHC.Base.Maybe a_a6LcC
                [LclId] =
                    [f1_s6YAa] \r [x_s6YAe m_s6YAf]
                        let {
                          sat_s6YAi [Occ=Once] :: a_a6LcC
                          [LclId] =
                              [f1_s6YAa x_s6YAe m_s6YAf] \u []
                                  case m_s6YAf of {
                                    GHC.Base.Nothing -> x_s6YAe;
                                    GHC.Base.Just y_s6YAh [Occ=Once] -> f1_s6YAa x_s6YAe y_s6YAh;
                                  };
                        } in  GHC.Base.Just [sat_s6YAi];
              } in 
                case
                    Data.Foldable.foldr
                        $dFoldable_s6YA8 sat_s6YAj GHC.Base.Nothing a1_s6YAd
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
                  GHC.Base.Just v_s6YAl [Occ=Once] -> v_s6YAl;
                };
          GHC.Generics.R1 a1_s6YAm [Occ=Once] ->
              let {
                sat_s6YAs [Occ=Once]
                  :: a_a6LcC -> GHC.Base.Maybe a_a6LcC -> GHC.Base.Maybe a_a6LcC
                [LclId] =
                    [f1_s6YAa] \r [x_s6YAn m_s6YAo]
                        let {
                          sat_s6YAr [Occ=Once] :: a_a6LcC
                          [LclId] =
                              [f1_s6YAa x_s6YAn m_s6YAo] \u []
                                  case m_s6YAo of {
                                    GHC.Base.Nothing -> x_s6YAn;
                                    GHC.Base.Just y_s6YAq [Occ=Once] -> f1_s6YAa x_s6YAn y_s6YAq;
                                  };
                        } in  GHC.Base.Just [sat_s6YAr];
              } in 
                case
                    Data.Foldable.foldr
                        $dFoldable1_s6YA9 sat_s6YAs GHC.Base.Nothing a1_s6YAm
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
                  GHC.Base.Just v_s6YAu [Occ=Once] -> v_s6YAu;
                };
        };

Data.Foldable.$fFoldable:+:_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YAv
           $dFoldable1_s6YAw
           f1_s6YAx
           z0_s6YAy
           xs_s6YAz]
        case xs_s6YAz of {
          GHC.Generics.L1 a1_s6YAB [Occ=Once] ->
              let {
                sat_s6YAG [Occ=Once]
                  :: a_a6Lct -> (b_a6Lcs -> b_a6Lcs) -> b_a6Lcs -> b_a6Lcs
                [LclId] =
                    [f1_s6YAx] \r [x_s6YAC k_s6YAD z_s6YAE]
                        case f1_s6YAx z_s6YAE x_s6YAC of vx_s6YAF {
                          __DEFAULT -> k_s6YAD vx_s6YAF;
                        };
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6YAv sat_s6YAG GHC.Base.id a1_s6YAB z0_s6YAy;
          GHC.Generics.R1 a1_s6YAH [Occ=Once] ->
              let {
                sat_s6YAM [Occ=Once]
                  :: a_a6Lct -> (b_a6Lcs -> b_a6Lcs) -> b_a6Lcs -> b_a6Lcs
                [LclId] =
                    [f1_s6YAx] \r [x_s6YAI k_s6YAJ z_s6YAK]
                        case f1_s6YAx z_s6YAK x_s6YAI of vx_s6YAL {
                          __DEFAULT -> k_s6YAJ vx_s6YAL;
                        };
              } in 
                Data.Foldable.foldr
                    $dFoldable1_s6YAw sat_s6YAM GHC.Base.id a1_s6YAH z0_s6YAy;
        };

Data.Foldable.$fFoldable:+:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YAN $dFoldable1_s6YAO eta_s6YAP]
        Data.Foldable.$fFoldable:+:_$cfoldl'
            $dFoldable_s6YAN
            $dFoldable1_s6YAO
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4
            eta_s6YAP;

Data.Foldable.$fFoldable:+:_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YAQ $dFoldable1_s6YAR f1_s6YAS z_s6YAT t_s6YAU]
        let {
          f2_s6YAV [Occ=Once*] :: a_a6Lcj -> b_a6Lci -> b_a6Lci
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [f1_s6YAS] \r [x_s6YAW y_s6YAX] f1_s6YAS y_s6YAX x_s6YAW;
        } in 
          case t_s6YAU of {
            GHC.Generics.L1 a1_s6YAZ [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable_s6YAQ
                    Data.Foldable.$fFoldable:*:7
                    f2_s6YAV
                    a1_s6YAZ
                    z_s6YAT;
            GHC.Generics.R1 a1_s6YB0 [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable1_s6YAR
                    Data.Foldable.$fFoldable:*:7
                    f2_s6YAV
                    a1_s6YB0
                    z_s6YAT;
          };

Data.Foldable.$fFoldable:+:_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YB1 $dFoldable1_s6YB2 f1_s6YB3 xs_s6YB4]
        case xs_s6YB4 of {
          GHC.Generics.L1 a1_s6YB6 [Occ=Once] ->
              let {
                sat_s6YBc [Occ=Once]
                  :: a_a6LcK
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LcK))
                [LclId] =
                    [f1_s6YB3] \r [x_s6YB7 y_s6YB8]
                        let {
                          sat_s6YBb [Occ=Once] :: a_a6LcK
                          [LclId] =
                              [f1_s6YB3 x_s6YB7 y_s6YB8] \u []
                                  case y_s6YB8 of {
                                    GHC.Base.Nothing -> x_s6YB7;
                                    GHC.Base.Just x1_s6YBa [Occ=Once] -> f1_s6YB3 x1_s6YBa x_s6YB7;
                                  };
                        } in  GHC.Base.Just [sat_s6YBb];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable_s6YB1
                        Data.Foldable.$fFoldable:*:7
                        sat_s6YBc
                        a1_s6YB6
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
                  GHC.Base.Just v_s6YBe [Occ=Once] -> v_s6YBe;
                };
          GHC.Generics.R1 a1_s6YBf [Occ=Once] ->
              let {
                sat_s6YBl [Occ=Once]
                  :: a_a6LcK
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LcK))
                [LclId] =
                    [f1_s6YB3] \r [x_s6YBg y_s6YBh]
                        let {
                          sat_s6YBk [Occ=Once] :: a_a6LcK
                          [LclId] =
                              [f1_s6YB3 x_s6YBg y_s6YBh] \u []
                                  case y_s6YBh of {
                                    GHC.Base.Nothing -> x_s6YBg;
                                    GHC.Base.Just x1_s6YBj [Occ=Once] -> f1_s6YB3 x1_s6YBj x_s6YBg;
                                  };
                        } in  GHC.Base.Just [sat_s6YBk];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable1_s6YB2
                        Data.Foldable.$fFoldable:*:7
                        sat_s6YBl
                        a1_s6YBf
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
                  GHC.Base.Just v_s6YBn [Occ=Once] -> v_s6YBn;
                };
        };

Data.Foldable.$fFoldable:+:_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YBo
           $dFoldable1_s6YBp
           f1_s6YBq
           z0_s6YBr
           xs_s6YBs]
        case xs_s6YBs of {
          GHC.Generics.L1 a1_s6YBu [Occ=Once] ->
              let {
                sat_s6YBz [Occ=Once]
                  :: a_a6Lc8
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_a6Lc9 -> b_a6Lc9))
                [LclId] =
                    [f1_s6YBq] \r [x_s6YBv y_s6YBw z_s6YBx]
                        case f1_s6YBq x_s6YBv z_s6YBx of vx_s6YBy {
                          __DEFAULT -> y_s6YBw vx_s6YBy;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable_s6YBo
                    Data.Foldable.$fFoldable:*:7
                    sat_s6YBz
                    a1_s6YBu
                    GHC.Base.id
                    z0_s6YBr;
          GHC.Generics.R1 a1_s6YBA [Occ=Once] ->
              let {
                sat_s6YBF [Occ=Once]
                  :: a_a6Lc8
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_a6Lc9 -> b_a6Lc9))
                [LclId] =
                    [f1_s6YBq] \r [x_s6YBB y_s6YBC z_s6YBD]
                        case f1_s6YBq x_s6YBB z_s6YBD of vx_s6YBE {
                          __DEFAULT -> y_s6YBC vx_s6YBE;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable1_s6YBp
                    Data.Foldable.$fFoldable:*:7
                    sat_s6YBF
                    a1_s6YBA
                    GHC.Base.id
                    z0_s6YBr;
        };

Data.Foldable.$fFoldable:+:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:+:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YBG $dFoldable1_s6YBH $dMonoid_s6YBI ds_s6YBJ]
        case ds_s6YBJ of {
          GHC.Generics.L1 a1_s6YBL [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_s6YBG $dMonoid_s6YBI GHC.Base.id a1_s6YBL;
          GHC.Generics.R1 a1_s6YBM [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_s6YBH $dMonoid_s6YBI GHC.Base.id a1_s6YBM;
        };

Data.Foldable.$fFoldable:+:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     (GHC.Generics.:+:) f g a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YBN $dFoldable1_s6YBO $dNum_s6YBP]
        let {
          $dMonoid_s6YBQ [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LdY)
          [LclId] =
              [$dNum_s6YBP] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6YBP; } in
        let {
          sat_s6YBV [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a_a6LdY
               -> Data.Semigroup.Internal.Product a_a6LdY
          [LclId] =
              [$dFoldable_s6YBN $dFoldable1_s6YBO $dMonoid_s6YBQ] \r [ds_s6YBR]
                  case ds_s6YBR of {
                    GHC.Generics.L1 a1_s6YBT [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6YBN
                            $dMonoid_s6YBQ
                            Data.Foldable.$fFoldable:*:1
                            a1_s6YBT;
                    GHC.Generics.R1 a1_s6YBU [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6YBO
                            $dMonoid_s6YBQ
                            Data.Foldable.$fFoldable:*:1
                            a1_s6YBU;
                  };
        } in  sat_s6YBV;

Data.Foldable.$fFoldable:+:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YBW $dFoldable1_s6YBX eta_s6YBY]
        case eta_s6YBY of {
          GHC.Generics.L1 a1_s6YC0 [Occ=Once] ->
              Data.Foldable.foldr
                  $dFoldable_s6YBW GHC.Types.: GHC.Types.[] a1_s6YC0;
          GHC.Generics.R1 a1_s6YC1 [Occ=Once] ->
              Data.Foldable.foldr
                  $dFoldable1_s6YBX GHC.Types.: GHC.Types.[] a1_s6YC1;
        };

Data.Foldable.$fFoldable:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6YC2 $dFoldable1_s6YC3]
        let {
          sat_s6YCj [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:1
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCi [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:2
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCh [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cminimum
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCg [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cmaximum
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCf [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$celem
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B2 eta_B1; } in
        let {
          sat_s6YCe [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$clength
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCd [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cnull
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCc [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> [a]
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$ctoList
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCb [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl1
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B2 eta_B1; } in
        let {
          sat_s6YCa [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr1
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B2 eta_B1; } in
        let {
          sat_s6YC9 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl'
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YC8 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YC7 [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr'
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YC6 [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YC5 [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> m
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldMap
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YC4 [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 m -> m
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfold
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6YC4
                                    sat_s6YC5
                                    sat_s6YC6
                                    sat_s6YC7
                                    sat_s6YC8
                                    sat_s6YC9
                                    sat_s6YCa
                                    sat_s6YCb
                                    sat_s6YCc
                                    sat_s6YCd
                                    sat_s6YCe
                                    sat_s6YCf
                                    sat_s6YCg
                                    sat_s6YCh
                                    sat_s6YCi
                                    sat_s6YCj];

Data.Foldable.$fFoldableM1_$celem
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.M1 i c f a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCk $dEq_s6YCl eta_s6YCm]
        let {
          f1_s6YCn [Occ=OnceL] :: a_a6Lg5 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YCl eta_s6YCm] \u []
                  GHC.Classes.== $dEq_s6YCl eta_s6YCm; } in
        let {
          sat_s6YCp [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6YCk f1_s6YCn] \r [ds_s6YCo]
                  Data.Foldable.foldMap
                      $dFoldable_s6YCk
                      Data.Semigroup.Internal.$fMonoidAny
                      f1_s6YCn
                      ds_s6YCo;
        } in  sat_s6YCp;

Data.Foldable.$fFoldableM1_$csum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCq $dNum_s6YCr]
        let {
          $dMonoid_s6YCs [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6Lgz)
          [LclId] =
              [$dNum_s6YCr] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6YCr; } in
        let {
          sat_s6YCu [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz
               -> Data.Semigroup.Internal.Sum a_a6Lgz
          [LclId] =
              [$dFoldable_s6YCq $dMonoid_s6YCs] \r [ds_s6YCt]
                  Data.Foldable.foldMap
                      $dFoldable_s6YCq
                      $dMonoid_s6YCs
                      Data.Foldable.$fFoldable:*:1
                      ds_s6YCt;
        } in  sat_s6YCu;

Data.Foldable.$fFoldableM1_$cminimum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCv $dOrd_s6YCw]
        let {
          $dMonoid_s6YCx [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6Lgp)
          [LclId] =
              [$dOrd_s6YCw] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6YCw; } in
        let {
          sat_s6YCB [Occ=OnceT[0]]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgp -> a_a6Lgp
          [LclId] =
              [$dFoldable_s6YCv $dMonoid_s6YCx] \r [x_s6YCy]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YCv $dMonoid_s6YCx GHC.Base.Just x_s6YCy
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6YCA [Occ=Once] -> v_s6YCA;
                  };
        } in  sat_s6YCB;

Data.Foldable.$fFoldableM1_$cmaximum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCC $dOrd_s6YCD]
        let {
          $dMonoid_s6YCE [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lgf)
          [LclId] =
              [$dOrd_s6YCD] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6YCD; } in
        let {
          sat_s6YCI [Occ=OnceT[0]]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgf -> a_a6Lgf
          [LclId] =
              [$dFoldable_s6YCC $dMonoid_s6YCE] \r [x_s6YCF]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YCC $dMonoid_s6YCE GHC.Base.Just x_s6YCF
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6YCH [Occ=Once] -> v_s6YCH;
                  };
        } in  sat_s6YCI;

Data.Foldable.$fFoldableM1_$cfoldr1
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCJ f1_s6YCK xs_s6YCL]
        let {
          sat_s6YCR [Occ=Once]
            :: a_a6Lfq -> GHC.Base.Maybe a_a6Lfq -> GHC.Base.Maybe a_a6Lfq
          [LclId] =
              [f1_s6YCK] \r [x_s6YCM m_s6YCN]
                  let {
                    sat_s6YCQ [Occ=Once] :: a_a6Lfq
                    [LclId] =
                        [f1_s6YCK x_s6YCM m_s6YCN] \u []
                            case m_s6YCN of {
                              GHC.Base.Nothing -> x_s6YCM;
                              GHC.Base.Just y_s6YCP [Occ=Once] -> f1_s6YCK x_s6YCM y_s6YCP;
                            };
                  } in  GHC.Base.Just [sat_s6YCQ];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6YCJ sat_s6YCR GHC.Base.Nothing xs_s6YCL
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6YCT [Occ=Once] -> v_s6YCT;
          };

Data.Foldable.$fFoldableM1_$cfoldl'
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCU f1_s6YCV z0_s6YCW xs_s6YCX]
        let {
          sat_s6YD2 [Occ=Once]
            :: a_a6Lfh -> (b_a6Lfg -> b_a6Lfg) -> b_a6Lfg -> b_a6Lfg
          [LclId] =
              [f1_s6YCV] \r [x_s6YCY k_s6YCZ z_s6YD0]
                  case f1_s6YCV z_s6YD0 x_s6YCY of vx_s6YD1 {
                    __DEFAULT -> k_s6YCZ vx_s6YD1;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6YCU sat_s6YD2 GHC.Base.id xs_s6YCX z0_s6YCW;

Data.Foldable.$fFoldableM1_$clength
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.M1 i c f a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YD3 eta_s6YD4]
        Data.Foldable.foldr
            $dFoldable_s6YD3
            Data.Foldable.$fFoldableM2
            GHC.Base.id
            eta_s6YD4
            Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableM1_$cfoldl
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YD5 f1_s6YD6 z_s6YD7 t_s6YD8]
        let {
          sat_s6YDb [Occ=Once]
            :: a_a6Lf7
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6Lf6)
          [LclId] =
              [f1_s6YD6] \r [x_s6YD9 y_s6YDa] f1_s6YD6 y_s6YDa x_s6YD9;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YD5
              Data.Foldable.$fFoldable:*:7
              sat_s6YDb
              t_s6YD8
              z_s6YD7;

Data.Foldable.$fFoldableM3
  :: forall a.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual
          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a)))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$fFoldableM1_$cfoldl1
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YDc f1_s6YDd xs_s6YDe]
        let {
          sat_s6YDk [Occ=Once]
            :: a_a6Lfy
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6Lfy))
          [LclId] =
              [f1_s6YDd] \r [x_s6YDf y_s6YDg]
                  let {
                    sat_s6YDj [Occ=Once] :: a_a6Lfy
                    [LclId] =
                        [f1_s6YDd x_s6YDf y_s6YDg] \u []
                            case y_s6YDg of {
                              GHC.Base.Nothing -> x_s6YDf;
                              GHC.Base.Just x1_s6YDi [Occ=Once] -> f1_s6YDd x1_s6YDi x_s6YDf;
                            };
                  } in  GHC.Base.Just [sat_s6YDj];
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6YDc
                  Data.Foldable.$fFoldableM3
                  sat_s6YDk
                  xs_s6YDe
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6YDm [Occ=Once] -> v_s6YDm;
          };

Data.Foldable.$fFoldableM4
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual
          (Data.Semigroup.Internal.Endo (b -> b)))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$fFoldableM1_$cfoldr'
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a b. (a -> b -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YDn f1_s6YDo z0_s6YDp xs_s6YDq]
        let {
          sat_s6YDv [Occ=Once]
            :: a_a6LeW
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6LeX -> b_a6LeX))
          [LclId] =
              [f1_s6YDo] \r [x_s6YDr y_s6YDs z_s6YDt]
                  case f1_s6YDo x_s6YDr z_s6YDt of vx_s6YDu {
                    __DEFAULT -> y_s6YDs vx_s6YDu;
                  };
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YDn
              Data.Foldable.$fFoldableM4
              sat_s6YDv
              xs_s6YDq
              GHC.Base.id
              z0_s6YDp;

Data.Foldable.$fFoldableM1_$cfold
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall m. GHC.Base.Monoid m => GHC.Generics.M1 i c f m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YDw $dMonoid_s6YDx ds_s6YDy]
        Data.Foldable.foldMap
            $dFoldable_s6YDw $dMonoid_s6YDx GHC.Base.id ds_s6YDy;

Data.Foldable.$fFoldableM1_$cproduct
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YDz $dNum_s6YDA]
        let {
          $dMonoid_s6YDB [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LgJ)
          [LclId] =
              [$dNum_s6YDA] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6YDA; } in
        let {
          sat_s6YDD [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ
               -> Data.Semigroup.Internal.Product a_a6LgJ
          [LclId] =
              [$dFoldable_s6YDz $dMonoid_s6YDB] \r [ds_s6YDC]
                  Data.Foldable.foldMap
                      $dFoldable_s6YDz
                      $dMonoid_s6YDB
                      Data.Foldable.$fFoldable:*:1
                      ds_s6YDC;
        } in  sat_s6YDD;

Data.Foldable.$fFoldableM1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.M1 i c f a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YDE eta_s6YDF]
        Data.Foldable.foldr
            $dFoldable_s6YDE GHC.Types.: GHC.Types.[] eta_s6YDF;

Data.Foldable.$fFoldableM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     Data.Foldable.Foldable (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6YDG]
        let {
          sat_s6YE3 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cproduct $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YE2 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$csum $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YE1 [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cminimum $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YE0 [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cmaximum $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YDZ [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$celem
                      $dFoldable_s6YDG eta_B2 eta_B1; } in
        let {
          sat_s6YDY [Occ=Once]
            :: forall a.
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$clength $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YDX [Occ=Once]
            :: forall a.
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YDG] \r [ds_s6YDW]
                  Data.Foldable.null $dFoldable_s6YDG ds_s6YDW; } in
        let {
          sat_s6YDV [Occ=Once]
            :: forall a. GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> [a]
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$ctoList $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YDU [Occ=Once]
            :: forall a.
               (a -> a -> a) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl1
                      $dFoldable_s6YDG eta_B2 eta_B1; } in
        let {
          sat_s6YDT [Occ=Once]
            :: forall a.
               (a -> a -> a) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldr1
                      $dFoldable_s6YDG eta_B2 eta_B1; } in
        let {
          sat_s6YDS [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl'
                      $dFoldable_s6YDG eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YDR [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl
                      $dFoldable_s6YDG eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YDQ [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldr'
                      $dFoldable_s6YDG eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YDP [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6YDG] \r [f1_s6YDM z_s6YDN ds_s6YDO]
                  Data.Foldable.foldr
                      $dFoldable_s6YDG f1_s6YDM z_s6YDN ds_s6YDO; } in
        let {
          sat_s6YDL [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> m
          [LclId] =
              [$dFoldable_s6YDG] \r [$dMonoid_s6YDI f1_s6YDJ ds_s6YDK]
                  Data.Foldable.foldMap
                      $dFoldable_s6YDG $dMonoid_s6YDI f1_s6YDJ ds_s6YDK; } in
        let {
          sat_s6YDH [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 m -> m
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfold $dFoldable_s6YDG eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6YDH
                                    sat_s6YDL
                                    sat_s6YDP
                                    sat_s6YDQ
                                    sat_s6YDR
                                    sat_s6YDS
                                    sat_s6YDT
                                    sat_s6YDU
                                    sat_s6YDV
                                    sat_s6YDX
                                    sat_s6YDY
                                    sat_s6YDZ
                                    sat_s6YE0
                                    sat_s6YE1
                                    sat_s6YE2
                                    sat_s6YE3];

Data.Foldable.$fFoldableK1_$celem
  :: forall i c a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.K1 i c a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YE4 eta_s6YE5 eta1_s6YE6] GHC.Types.False [];

Data.Foldable.$fFoldableK1_$csum
  :: forall i c a. GHC.Num.Num a => GHC.Generics.K1 i c a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YE7 ds_s6YE8]
        Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YE7;

Data.Foldable.$fFoldableK1_$cminimum
  :: forall i c a. GHC.Classes.Ord a => GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YE9 eta_s6YEa]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableK1_$cmaximum
  :: forall i c a. GHC.Classes.Ord a => GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YEb eta_s6YEc]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableK1_$cfoldl
  :: forall i c b a. (b -> a -> b) -> b -> GHC.Generics.K1 i c a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YEd z_s6YEe t_s6YEf] z_s6YEe;

Data.Foldable.$fFoldableK6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK7;

Data.Foldable.$fFoldableK1_$cfoldl1
  :: forall i c a. (a -> a -> a) -> GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YEg xs_s6YEh]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableK1_$cfoldr'
  :: forall i c a b. (a -> b -> b) -> b -> GHC.Generics.K1 i c a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YEi z0_s6YEj xs_s6YEk] z0_s6YEj;

Data.Foldable.$fFoldableK1_$clength
  :: forall i c a. GHC.Generics.K1 i c a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6YEl] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableK8 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK9;

Data.Foldable.$fFoldableK1_$cfoldr1
  :: forall i c a. (a -> a -> a) -> GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YEm xs_s6YEn]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableK1_$cnull
  :: forall i c a. GHC.Generics.K1 i c a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t_s6YEo] GHC.Types.True [];

Data.Foldable.$fFoldableK1_$cfold
  :: forall i c m. GHC.Base.Monoid m => GHC.Generics.K1 i c m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YEp ds_s6YEq] GHC.Base.mempty $dMonoid_s6YEp;

Data.Foldable.$fFoldableK1_$cproduct
  :: forall i c a. GHC.Num.Num a => GHC.Generics.K1 i c a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YEr ds_s6YEs]
        Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YEr;

Data.Foldable.$fFoldableK1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall i c a. GHC.Generics.K1 i c a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6YEt] [] [];

Data.Foldable.$fFoldableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Data.Foldable.Foldable (GHC.Generics.K1 i c)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableK1_$cfold
                                             Data.Foldable.$fFoldableK1_$cfoldMap
                                             Data.Foldable.$fFoldableK1_$cfoldr'
                                             Data.Foldable.$fFoldableK1_$cfoldr'
                                             Data.Foldable.$fFoldableK1_$cfoldl
                                             Data.Foldable.$fFoldableK1_$cfoldl
                                             Data.Foldable.$fFoldableK1_$cfoldr1
                                             Data.Foldable.$fFoldableK1_$cfoldl1
                                             Data.Foldable.$fFoldableK1_$ctoList
                                             Data.Foldable.$fFoldableK1_$cnull
                                             Data.Foldable.$fFoldableK1_$clength
                                             Data.Foldable.$fFoldableK1_$celem
                                             Data.Foldable.$fFoldableK1_$cmaximum
                                             Data.Foldable.$fFoldableK1_$cminimum
                                             Data.Foldable.$fFoldableK1_$csum
                                             Data.Foldable.$fFoldableK1_$cproduct];

Data.Foldable.$fFoldableRec1_$celem
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.Rec1 f a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YEu $dEq_s6YEv eta_s6YEw]
        let {
          f1_s6YEx [Occ=OnceL] :: a_a6Lli -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YEv eta_s6YEw] \u []
                  GHC.Classes.== $dEq_s6YEv eta_s6YEw; } in
        let {
          sat_s6YEz [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6Lli -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6YEu f1_s6YEx] \r [ds_s6YEy]
                  Data.Foldable.foldMap
                      $dFoldable_s6YEu
                      Data.Semigroup.Internal.$fMonoidAny
                      f1_s6YEx
                      ds_s6YEy;
        } in  sat_s6YEz;

Data.Foldable.$fFoldableRec1_$csum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YEA $dNum_s6YEB]
        let {
          $dMonoid_s6YEC [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LlM)
          [LclId] =
              [$dNum_s6YEB] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6YEB; } in
        let {
          sat_s6YEE [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlM
               -> Data.Semigroup.Internal.Sum a_a6LlM
          [LclId] =
              [$dFoldable_s6YEA $dMonoid_s6YEC] \r [ds_s6YED]
                  Data.Foldable.foldMap
                      $dFoldable_s6YEA
                      $dMonoid_s6YEC
                      Data.Foldable.$fFoldable:*:1
                      ds_s6YED;
        } in  sat_s6YEE;

Data.Foldable.$fFoldableRec1_$cminimum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YEF $dOrd_s6YEG]
        let {
          $dMonoid_s6YEH [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6LlC)
          [LclId] =
              [$dOrd_s6YEG] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6YEG; } in
        let {
          sat_s6YEL [Occ=OnceT[0]]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlC -> a_a6LlC
          [LclId] =
              [$dFoldable_s6YEF $dMonoid_s6YEH] \r [x_s6YEI]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YEF $dMonoid_s6YEH GHC.Base.Just x_s6YEI
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6YEK [Occ=Once] -> v_s6YEK;
                  };
        } in  sat_s6YEL;

Data.Foldable.$fFoldableRec1_$cmaximum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YEM $dOrd_s6YEN]
        let {
          $dMonoid_s6YEO [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lls)
          [LclId] =
              [$dOrd_s6YEN] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6YEN; } in
        let {
          sat_s6YES [Occ=OnceT[0]]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6Lls -> a_a6Lls
          [LclId] =
              [$dFoldable_s6YEM $dMonoid_s6YEO] \r [x_s6YEP]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YEM $dMonoid_s6YEO GHC.Base.Just x_s6YEP
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6YER [Occ=Once] -> v_s6YER;
                  };
        } in  sat_s6YES;

Data.Foldable.$fFoldable:.:3 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableRec1_$cfoldr1
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YET f1_s6YEU xs_s6YEV]
        let {
          sat_s6YF1 [Occ=Once]
            :: a_a6LkD -> GHC.Base.Maybe a_a6LkD -> GHC.Base.Maybe a_a6LkD
          [LclId] =
              [f1_s6YEU] \r [x_s6YEW m_s6YEX]
                  let {
                    sat_s6YF0 [Occ=Once] :: a_a6LkD
                    [LclId] =
                        [f1_s6YEU x_s6YEW m_s6YEX] \u []
                            case m_s6YEX of {
                              GHC.Base.Nothing -> x_s6YEW;
                              GHC.Base.Just y_s6YEZ [Occ=Once] -> f1_s6YEU x_s6YEW y_s6YEZ;
                            };
                  } in  GHC.Base.Just [sat_s6YF0];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6YET sat_s6YF1 GHC.Base.Nothing xs_s6YEV
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
            GHC.Base.Just v_s6YF3 [Occ=Once] -> v_s6YF3;
          };

Data.Foldable.$fFoldableRec1_$cfoldl'
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YF4 f1_s6YF5 z0_s6YF6 xs_s6YF7]
        let {
          sat_s6YFc [Occ=Once]
            :: a_a6Lku -> (b_a6Lkt -> b_a6Lkt) -> b_a6Lkt -> b_a6Lkt
          [LclId] =
              [f1_s6YF5] \r [x_s6YF8 k_s6YF9 z_s6YFa]
                  case f1_s6YF5 z_s6YFa x_s6YF8 of vx_s6YFb {
                    __DEFAULT -> k_s6YF9 vx_s6YFb;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6YF4 sat_s6YFc GHC.Base.id xs_s6YF7 z0_s6YF6;

Data.Foldable.$fFoldableRec1_$clength
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.Rec1 f a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFd eta_s6YFe]
        Data.Foldable.foldr
            $dFoldable_s6YFd
            Data.Foldable.$fFoldableM2
            GHC.Base.id
            eta_s6YFe
            Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableRec1_$cfoldl
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFf f1_s6YFg z_s6YFh t_s6YFi]
        let {
          sat_s6YFl [Occ=Once]
            :: a_a6Lkk
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6Lkj)
          [LclId] =
              [f1_s6YFg] \r [x_s6YFj y_s6YFk] f1_s6YFg y_s6YFk x_s6YFj;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YFf
              Data.Foldable.$fFoldable:*:7
              sat_s6YFl
              t_s6YFi
              z_s6YFh;

Data.Foldable.$fFoldable:.:2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableRec1_$cfoldl1
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFm f1_s6YFn xs_s6YFo]
        let {
          sat_s6YFu [Occ=Once]
            :: a_a6LkL
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LkL))
          [LclId] =
              [f1_s6YFn] \r [x_s6YFp y_s6YFq]
                  let {
                    sat_s6YFt [Occ=Once] :: a_a6LkL
                    [LclId] =
                        [f1_s6YFn x_s6YFp y_s6YFq] \u []
                            case y_s6YFq of {
                              GHC.Base.Nothing -> x_s6YFp;
                              GHC.Base.Just x1_s6YFs [Occ=Once] -> f1_s6YFn x1_s6YFs x_s6YFp;
                            };
                  } in  GHC.Base.Just [sat_s6YFt];
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6YFm
                  Data.Foldable.$fFoldableM3
                  sat_s6YFu
                  xs_s6YFo
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
            GHC.Base.Just v_s6YFw [Occ=Once] -> v_s6YFw;
          };

Data.Foldable.$fFoldableRec1_$cfoldr'
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a b. (a -> b -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFx f1_s6YFy z0_s6YFz xs_s6YFA]
        let {
          sat_s6YFF [Occ=Once]
            :: a_a6Lk9
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6Lka -> b_a6Lka))
          [LclId] =
              [f1_s6YFy] \r [x_s6YFB y_s6YFC z_s6YFD]
                  case f1_s6YFy x_s6YFB z_s6YFD of vx_s6YFE {
                    __DEFAULT -> y_s6YFC vx_s6YFE;
                  };
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YFx
              Data.Foldable.$fFoldableM4
              sat_s6YFF
              xs_s6YFA
              GHC.Base.id
              z0_s6YFz;

Data.Foldable.$fFoldableRec1_$cfold
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall m. GHC.Base.Monoid m => GHC.Generics.Rec1 f m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFG $dMonoid_s6YFH ds_s6YFI]
        Data.Foldable.foldMap
            $dFoldable_s6YFG $dMonoid_s6YFH GHC.Base.id ds_s6YFI;

Data.Foldable.$fFoldableRec1_$cproduct
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFJ $dNum_s6YFK]
        let {
          $dMonoid_s6YFL [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LlW)
          [LclId] =
              [$dNum_s6YFK] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6YFK; } in
        let {
          sat_s6YFN [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlW
               -> Data.Semigroup.Internal.Product a_a6LlW
          [LclId] =
              [$dFoldable_s6YFJ $dMonoid_s6YFL] \r [ds_s6YFM]
                  Data.Foldable.foldMap
                      $dFoldable_s6YFJ
                      $dMonoid_s6YFL
                      Data.Foldable.$fFoldable:*:1
                      ds_s6YFM;
        } in  sat_s6YFN;

Data.Foldable.$fFoldableRec1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.Rec1 f a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFO eta_s6YFP]
        Data.Foldable.foldr
            $dFoldable_s6YFO GHC.Types.: GHC.Types.[] eta_s6YFP;

Data.Foldable.$fFoldableRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     Data.Foldable.Foldable (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6YFQ]
        let {
          sat_s6YGd [Occ=Once]
            :: forall a. GHC.Num.Num a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cproduct
                      $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YGc [Occ=Once]
            :: forall a. GHC.Num.Num a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$csum $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YGb [Occ=Once]
            :: forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cminimum
                      $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YGa [Occ=Once]
            :: forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cmaximum
                      $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YG9 [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$celem
                      $dFoldable_s6YFQ eta_B2 eta_B1; } in
        let {
          sat_s6YG8 [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$clength $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YG7 [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YFQ] \r [ds_s6YG6]
                  Data.Foldable.null $dFoldable_s6YFQ ds_s6YG6; } in
        let {
          sat_s6YG5 [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> [a]
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$ctoList $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YG4 [Occ=Once]
            :: forall a. (a -> a -> a) -> GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl1
                      $dFoldable_s6YFQ eta_B2 eta_B1; } in
        let {
          sat_s6YG3 [Occ=Once]
            :: forall a. (a -> a -> a) -> GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldr1
                      $dFoldable_s6YFQ eta_B2 eta_B1; } in
        let {
          sat_s6YG2 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl'
                      $dFoldable_s6YFQ eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YG1 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl
                      $dFoldable_s6YFQ eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YG0 [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldr'
                      $dFoldable_s6YFQ eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YFZ [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6YFQ] \r [f1_s6YFW z_s6YFX ds_s6YFY]
                  Data.Foldable.foldr
                      $dFoldable_s6YFQ f1_s6YFW z_s6YFX ds_s6YFY; } in
        let {
          sat_s6YFV [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> GHC.Generics.Rec1 f_a6Ljm a -> m
          [LclId] =
              [$dFoldable_s6YFQ] \r [$dMonoid_s6YFS f1_s6YFT ds_s6YFU]
                  Data.Foldable.foldMap
                      $dFoldable_s6YFQ $dMonoid_s6YFS f1_s6YFT ds_s6YFU; } in
        let {
          sat_s6YFR [Occ=Once]
            :: forall m. GHC.Base.Monoid m => GHC.Generics.Rec1 f_a6Ljm m -> m
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfold $dFoldable_s6YFQ eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6YFR
                                    sat_s6YFV
                                    sat_s6YFZ
                                    sat_s6YG0
                                    sat_s6YG1
                                    sat_s6YG2
                                    sat_s6YG3
                                    sat_s6YG4
                                    sat_s6YG5
                                    sat_s6YG7
                                    sat_s6YG8
                                    sat_s6YG9
                                    sat_s6YGa
                                    sat_s6YGb
                                    sat_s6YGc
                                    sat_s6YGd];

Data.Foldable.$fFoldablePar1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.Par1 a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YGe eta_s6YGf]
        let {
          f_s6YGg [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LnB -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YGe eta_s6YGf] \u []
                  GHC.Classes.== $dEq_s6YGe eta_s6YGf; } in
        let {
          sat_s6YGi [Occ=OnceT[0]]
            :: GHC.Generics.Par1 a_a6LnB -> GHC.Types.Bool
          [LclId] =
              [f_s6YGg] \r [ds_s6YGh] f_s6YGg ds_s6YGh;
        } in  sat_s6YGi;

Data.Foldable.$fFoldablePar2
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YGj eta_s6YGk] eta_s6YGk;

Data.Foldable.$fFoldablePar3
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6YGl x_s6YGm] x_s6YGm;

Data.Foldable.$fFoldablePar4
  :: forall a.
     (a -> a -> a) -> GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YGn xs_s6YGo] xs_s6YGo;

Data.Foldable.$fFoldablePar1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.Par1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6YGp z0_s6YGq xs_s6YGr] f_s6YGp z0_s6YGq xs_s6YGr;

Data.Foldable.$fFoldablePar1_$clength
  :: forall a. GHC.Generics.Par1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6YGs] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldablePar5
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.Par1 m -> GHC.Generics.Par1 m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YGt ds_s6YGu] ds_s6YGu;

Data.Foldable.$fFoldablePar1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.Par1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_s6YGv] : [eta_s6YGv GHC.Types.[]];

Data.Foldable.$fFoldablePar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.Par1
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldablePar5
                                             Data.Foldable.$fFoldablePar1_$cfoldMap
                                             Data.Foldable.$fFoldablePar1_$cfoldr
                                             Data.Foldable.$fFoldablePar1_$cfoldr
                                             Data.Foldable.$fFoldablePar1_$cfoldl'
                                             Data.Foldable.$fFoldablePar1_$cfoldl'
                                             Data.Foldable.$fFoldablePar4
                                             Data.Foldable.$fFoldablePar4
                                             Data.Foldable.$fFoldablePar1_$ctoList
                                             Data.Foldable.$fFoldablePar1_$cnull
                                             Data.Foldable.$fFoldablePar1_$clength
                                             Data.Foldable.$fFoldablePar1_$celem
                                             Data.Foldable.$fFoldablePar3
                                             Data.Foldable.$fFoldablePar3
                                             Data.Foldable.$fFoldablePar2
                                             Data.Foldable.$fFoldablePar2];

Data.Foldable.$fFoldableV1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.V1 a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YGw eta_s6YGx eta1_s6YGy] GHC.Types.False [];

Data.Foldable.$fFoldableV1_$csum
  :: forall a. GHC.Num.Num a => GHC.Generics.V1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YGz ds_s6YGA]
        Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YGz;

Data.Foldable.$fFoldableV1_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YGB eta_s6YGC]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableV1_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YGD eta_s6YGE]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableV1_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.V1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YGF z_s6YGG t_s6YGH] z_s6YGG;

Data.Foldable.$fFoldableV1_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YGI xs_s6YGJ]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableV1_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.V1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YGK z0_s6YGL xs_s6YGM] z0_s6YGL;

Data.Foldable.$fFoldableV1_$clength
  :: forall a. GHC.Generics.V1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6YGN] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableV1_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YGO xs_s6YGP]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableV1_$cnull
  :: forall a. GHC.Generics.V1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t_s6YGQ] GHC.Types.True [];

Data.Foldable.$fFoldableV1_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Generics.V1 m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YGR ds_s6YGS] GHC.Base.mempty $dMonoid_s6YGR;

Data.Foldable.$fFoldableV1_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Generics.V1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YGT ds_s6YGU]
        Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YGT;

Data.Foldable.$fFoldableV1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.V1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6YGV] [] [];

Data.Foldable.$fFoldableV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.V1
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableV1_$cfold
                                             Data.Foldable.$fFoldableV1_$cfoldMap
                                             Data.Foldable.$fFoldableV1_$cfoldr'
                                             Data.Foldable.$fFoldableV1_$cfoldr'
                                             Data.Foldable.$fFoldableV1_$cfoldl
                                             Data.Foldable.$fFoldableV1_$cfoldl
                                             Data.Foldable.$fFoldableV1_$cfoldr1
                                             Data.Foldable.$fFoldableV1_$cfoldl1
                                             Data.Foldable.$fFoldableV1_$ctoList
                                             Data.Foldable.$fFoldableV1_$cnull
                                             Data.Foldable.$fFoldableV1_$clength
                                             Data.Foldable.$fFoldableV1_$celem
                                             Data.Foldable.$fFoldableV1_$cmaximum
                                             Data.Foldable.$fFoldableV1_$cminimum
                                             Data.Foldable.$fFoldableV1_$csum
                                             Data.Foldable.$fFoldableV1_$cproduct];

Data.Foldable.$fFoldableArray_$cfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall i m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Arr.Array i a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><L,C(U)><S(LLSL),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YGW f_s6YGX eta_s6YGY]
        case eta_s6YGY of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6YH2 [Occ=OnceL]
                        ww4_s6YH3 [Occ=OnceL] ->
              let {
                w1_s6YH4 [Occ=OnceL] :: m_a6LGY
                [LclId] =
                    [$dMonoid_s6YGW] \u [] GHC.Base.mempty $dMonoid_s6YGW; } in
              let {
                $wgo_s6YH5 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: GHC.Prim.Int# -> m_a6LGY
                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                    sat-only [$dMonoid_s6YGW
                              f_s6YGX
                              ww3_s6YH2
                              ww4_s6YH3
                              w1_s6YH4
                              $wgo_s6YH5] \r [ww7_s6YH6]
                        case ==# [ww7_s6YH6 ww3_s6YH2] of {
                          __DEFAULT ->
                              let {
                                sat_s6YHd [Occ=Once] :: m_a6LGY
                                [LclId] =
                                    [$wgo_s6YH5 ww7_s6YH6] \u []
                                        case +# [ww7_s6YH6 1#] of sat_s6YHc {
                                          __DEFAULT -> $wgo_s6YH5 sat_s6YHc;
                                        }; } in
                              let {
                                sat_s6YHb [Occ=Once] :: m_a6LGY
                                [LclId] =
                                    [f_s6YGX ww4_s6YH3 ww7_s6YH6] \u []
                                        let {
                                          sat_s6YHa [Occ=Once] :: a_a6LGZ
                                          [LclId] =
                                              [ww4_s6YH3 ww7_s6YH6] \u []
                                                  case indexArray# [ww4_s6YH3 ww7_s6YH6] of {
                                                    Unit# ipv_s6YH9 [Occ=Once] -> ipv_s6YH9;
                                                  };
                                        } in  f_s6YGX sat_s6YHa;
                              } in  GHC.Base.mappend $dMonoid_s6YGW sat_s6YHb sat_s6YHd;
                          1# -> w1_s6YH4;
                        };
              } in  $wgo_s6YH5 0#;
        };

Data.Foldable.$fFoldableArray1
  :: forall i a.
     GHC.Num.Num a =>
     GHC.Arr.Array i a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YHe]
        let {
          w1_s6YHf [Occ=OnceL] :: a_a6LJu
          [LclId] =
              [$dNum_s6YHe] \u []
                  GHC.Num.fromInteger
                      $dNum_s6YHe Data.Semigroup.Internal.$fMonoidProduct1; } in
        let {
          sat_s6YHu [Occ=OnceT[0]]
            :: GHC.Arr.Array i_a6LGK a_a6LJu
               -> Data.Semigroup.Internal.Product a_a6LJu
          [LclId] =
              [$dNum_s6YHe w1_s6YHf] \r [w2_s6YHg]
                  case w2_s6YHg of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6YHk [Occ=OnceL]
                                  ww4_s6YHl [Occ=OnceL] ->
                        let {
                          $wgo_s6YHm [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Product a_a6LJu
                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6YHe
                                        w1_s6YHf
                                        ww3_s6YHk
                                        ww4_s6YHl
                                        $wgo_s6YHm] \r [ww7_s6YHn]
                                  case ==# [ww7_s6YHn ww3_s6YHk] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6YHt [Occ=Once] :: a_a6LJu
                                          [LclId] =
                                              [$wgo_s6YHm ww7_s6YHn] \u []
                                                  case +# [ww7_s6YHn 1#] of sat_s6YHs {
                                                    __DEFAULT -> $wgo_s6YHm sat_s6YHs;
                                                  }; } in
                                        let {
                                          sat_s6YHr [Occ=Once] :: a_a6LJu
                                          [LclId] =
                                              [ww4_s6YHl ww7_s6YHn] \u []
                                                  case indexArray# [ww4_s6YHl ww7_s6YHn] of {
                                                    Unit# ipv_s6YHq [Occ=Once] -> ipv_s6YHq;
                                                  };
                                        } in  GHC.Num.* $dNum_s6YHe sat_s6YHr sat_s6YHt;
                                    1# -> w1_s6YHf;
                                  };
                        } in  $wgo_s6YHm 0#;
                  };
        } in  sat_s6YHu;

Data.Foldable.$w$cfold [InlPrag=NOUSERINLINE[0]]
  :: forall i m.
     GHC.Base.Monoid m =>
     GHC.Prim.Int# -> GHC.Prim.Array# m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6YHv ww_s6YHw ww1_s6YHx]
        let {
          w1_s6YHy [Occ=OnceL] :: m_s6NXp
          [LclId] =
              [w_s6YHv] \u [] GHC.Base.mempty w_s6YHv; } in
        let {
          $wgo_s6YHz [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> m_s6NXp
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6YHv
                        ww_s6YHw
                        ww1_s6YHx
                        w1_s6YHy
                        $wgo_s6YHz] \r [ww2_s6YHA]
                  case ==# [ww2_s6YHA ww_s6YHw] of {
                    __DEFAULT ->
                        let {
                          sat_s6YHG [Occ=Once] :: m_s6NXp
                          [LclId] =
                              [$wgo_s6YHz ww2_s6YHA] \u []
                                  case +# [ww2_s6YHA 1#] of sat_s6YHF {
                                    __DEFAULT -> $wgo_s6YHz sat_s6YHF;
                                  }; } in
                        let {
                          sat_s6YHE [Occ=Once] :: m_s6NXp
                          [LclId] =
                              [ww1_s6YHx ww2_s6YHA] \u []
                                  case indexArray# [ww1_s6YHx ww2_s6YHA] of {
                                    Unit# ipv_s6YHD [Occ=Once] -> ipv_s6YHD;
                                  };
                        } in  GHC.Base.mappend w_s6YHv sat_s6YHE sat_s6YHG;
                    1# -> w1_s6YHy;
                  };
        } in  $wgo_s6YHz 0#;

Data.Foldable.$fFoldableArray_$cfold [InlPrag=NOUSERINLINE[0]]
  :: forall i m. GHC.Base.Monoid m => GHC.Arr.Array i m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,U,C(C1(U)),A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YHH w1_s6YHI]
        case w1_s6YHI of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6YHM [Occ=Once]
                        ww4_s6YHN [Occ=Once] ->
              Data.Foldable.$w$cfold w_s6YHH ww3_s6YHM ww4_s6YHN;
        };

Data.Foldable.$w$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall i a.
     GHC.Classes.Ord a =>
     GHC.Prim.Int# -> GHC.Prim.Array# a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6YHO ww_s6YHP ww1_s6YHQ]
        let {
          $wgo_s6YHR [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> Data.Functor.Utils.Max a_s6NXH
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6YHO ww_s6YHP ww1_s6YHQ $wgo_s6YHR] \r [ww2_s6YHS]
                  case ==# [ww2_s6YHS ww_s6YHP] of {
                    __DEFAULT ->
                        let {
                          x_s6YHU :: a_s6NXH
                          [LclId] =
                              [ww1_s6YHQ ww2_s6YHS] \u []
                                  case indexArray# [ww1_s6YHQ ww2_s6YHS] of {
                                    Unit# ipv_s6YHW [Occ=Once] -> ipv_s6YHW;
                                  };
                        } in 
                          case +# [ww2_s6YHS 1#] of sat_s6YHX {
                            __DEFAULT ->
                                case $wgo_s6YHR sat_s6YHX of wild_s6YHY {
                                  GHC.Base.Nothing -> GHC.Base.Just [x_s6YHU];
                                  GHC.Base.Just ipv_s6YHZ [Occ=Once] ->
                                      case GHC.Classes.>= w_s6YHO x_s6YHU ipv_s6YHZ of {
                                        GHC.Types.False -> wild_s6YHY;
                                        GHC.Types.True -> GHC.Base.Just [x_s6YHU];
                                      };
                                };
                          };
                    1# -> GHC.Base.Nothing [];
                  };
        } in 
          case $wgo_s6YHR 0# of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
            GHC.Base.Just v_s6YI2 [Occ=Once] -> v_s6YI2;
          };

Data.Foldable.$fFoldableArray_$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. GHC.Classes.Ord a => GHC.Arr.Array i a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YI3 w1_s6YI4]
        case w1_s6YI4 of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6YI8 [Occ=Once]
                        ww4_s6YI9 [Occ=Once] ->
              Data.Foldable.$w$cmaximum w_s6YI3 ww3_s6YI8 ww4_s6YI9;
        };

Data.Foldable.$w$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall i a.
     GHC.Classes.Ord a =>
     GHC.Prim.Int# -> GHC.Prim.Array# a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6YIa ww_s6YIb ww1_s6YIc]
        let {
          $wgo_s6YId [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> Data.Functor.Utils.Min a_s6NXZ
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6YIa ww_s6YIb ww1_s6YIc $wgo_s6YId] \r [ww2_s6YIe]
                  case ==# [ww2_s6YIe ww_s6YIb] of {
                    __DEFAULT ->
                        let {
                          x_s6YIg :: a_s6NXZ
                          [LclId] =
                              [ww1_s6YIc ww2_s6YIe] \u []
                                  case indexArray# [ww1_s6YIc ww2_s6YIe] of {
                                    Unit# ipv_s6YIi [Occ=Once] -> ipv_s6YIi;
                                  };
                        } in 
                          case +# [ww2_s6YIe 1#] of sat_s6YIj {
                            __DEFAULT ->
                                case $wgo_s6YId sat_s6YIj of wild_s6YIk {
                                  GHC.Base.Nothing -> GHC.Base.Just [x_s6YIg];
                                  GHC.Base.Just ipv_s6YIl [Occ=Once] ->
                                      case GHC.Classes.<= w_s6YIa x_s6YIg ipv_s6YIl of {
                                        GHC.Types.False -> wild_s6YIk;
                                        GHC.Types.True -> GHC.Base.Just [x_s6YIg];
                                      };
                                };
                          };
                    1# -> GHC.Base.Nothing [];
                  };
        } in 
          case $wgo_s6YId 0# of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
            GHC.Base.Just v_s6YIo [Occ=Once] -> v_s6YIo;
          };

Data.Foldable.$fFoldableArray_$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. GHC.Classes.Ord a => GHC.Arr.Array i a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YIp w1_s6YIq]
        case w1_s6YIq of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6YIu [Occ=Once]
                        ww4_s6YIv [Occ=Once] ->
              Data.Foldable.$w$cminimum w_s6YIp ww3_s6YIu ww4_s6YIv;
        };

Data.Foldable.$fFoldableArray2
  :: forall i a.
     GHC.Num.Num a =>
     GHC.Arr.Array i a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YIw]
        let {
          w1_s6YIx [Occ=OnceL] :: a_a6LJk
          [LclId] =
              [$dNum_s6YIw] \u []
                  GHC.Num.fromInteger
                      $dNum_s6YIw Data.Semigroup.Internal.$fMonoidSum1; } in
        let {
          sat_s6YIM [Occ=OnceT[0]]
            :: GHC.Arr.Array i_X6LX9 a_a6LJk
               -> Data.Semigroup.Internal.Sum a_a6LJk
          [LclId] =
              [$dNum_s6YIw w1_s6YIx] \r [w2_s6YIy]
                  case w2_s6YIy of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6YIC [Occ=OnceL]
                                  ww4_s6YID [Occ=OnceL] ->
                        let {
                          $wgo_s6YIE [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Sum a_a6LJk
                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6YIw
                                        w1_s6YIx
                                        ww3_s6YIC
                                        ww4_s6YID
                                        $wgo_s6YIE] \r [ww7_s6YIF]
                                  case ==# [ww7_s6YIF ww3_s6YIC] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6YIL [Occ=Once] :: a_a6LJk
                                          [LclId] =
                                              [$wgo_s6YIE ww7_s6YIF] \u []
                                                  case +# [ww7_s6YIF 1#] of sat_s6YIK {
                                                    __DEFAULT -> $wgo_s6YIE sat_s6YIK;
                                                  }; } in
                                        let {
                                          sat_s6YIJ [Occ=Once] :: a_a6LJk
                                          [LclId] =
                                              [ww4_s6YID ww7_s6YIF] \u []
                                                  case indexArray# [ww4_s6YID ww7_s6YIF] of {
                                                    Unit# ipv_s6YII [Occ=Once] -> ipv_s6YII;
                                                  };
                                        } in  GHC.Num.+ $dNum_s6YIw sat_s6YIJ sat_s6YIL;
                                    1# -> w1_s6YIx;
                                  };
                        } in  $wgo_s6YIE 0#;
                  };
        } in  sat_s6YIM;

Data.Foldable.$fFoldableArray_$celem
  :: forall i a.
     GHC.Classes.Eq a =>
     a -> GHC.Arr.Array i a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YIN eta_s6YIO]
        let {
          f_s6YIP [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LIQ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YIN eta_s6YIO] \u []
                  GHC.Classes.== $dEq_s6YIN eta_s6YIO; } in
        let {
          sat_s6YJ4 [Occ=Once]
            :: GHC.Arr.Array i_X6LXe a_a6LIQ -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6YIP] \r [w2_s6YIQ]
                  case w2_s6YIQ of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6YIU [Occ=OnceL]
                                  ww4_s6YIV [Occ=OnceL] ->
                        let-no-escape {
                          $wgo_s6YIW [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Any
                          [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [f_s6YIP ww3_s6YIU ww4_s6YIV $wgo_s6YIW] \r [ww7_s6YIX]
                                  case ==# [ww7_s6YIX ww3_s6YIU] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6YJ1 [Occ=Once] :: a_a6LIQ
                                          [LclId] =
                                              [ww4_s6YIV ww7_s6YIX] \u []
                                                  case indexArray# [ww4_s6YIV ww7_s6YIX] of {
                                                    Unit# ipv_s6YJ0 [Occ=Once] -> ipv_s6YJ0;
                                                  };
                                        } in 
                                          case f_s6YIP sat_s6YJ1 of {
                                            GHC.Types.False ->
                                                case +# [ww7_s6YIX 1#] of sat_s6YJ3 {
                                                  __DEFAULT -> $wgo_s6YIW sat_s6YJ3;
                                                };
                                            GHC.Types.True -> GHC.Types.True [];
                                          };
                                    1# -> GHC.Types.False [];
                                  };
                        } in  $wgo_s6YIW 0#;
                  };
        } in  sat_s6YJ4;

Data.Foldable.$fFoldableArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Foldable.Foldable (GHC.Arr.Array i)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableArray_$cfold
                                             Data.Foldable.$fFoldableArray_$cfoldMap
                                             GHC.Arr.foldrElems
                                             GHC.Arr.foldrElems'
                                             GHC.Arr.foldlElems
                                             GHC.Arr.foldlElems'
                                             GHC.Arr.foldr1Elems
                                             GHC.Arr.foldl1Elems
                                             GHC.Arr.elems
                                             Data.Foldable.$fFoldableArray_$cnull
                                             GHC.Arr.numElements
                                             Data.Foldable.$fFoldableArray_$celem
                                             Data.Foldable.$fFoldableArray_$cmaximum
                                             Data.Foldable.$fFoldableArray_$cminimum
                                             Data.Foldable.$fFoldableArray2
                                             Data.Foldable.$fFoldableArray1];

Data.Foldable.$fFoldable(,)_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> (a1, a2) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YJ5 eta_s6YJ6]
        let {
          f_s6YJ7 [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_a6LLd -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YJ5 eta_s6YJ6] \u []
                  GHC.Classes.== $dEq_s6YJ5 eta_s6YJ6; } in
        let {
          sat_s6YJc [Occ=Once]
            :: (a_a6LJD, a1_a6LLd) -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6YJ7] \r [ds_s6YJ8]
                  case ds_s6YJ8 of {
                    (,) _ [Occ=Dead] y_s6YJb [Occ=Once] -> f_s6YJ7 y_s6YJb;
                  };
        } in  sat_s6YJc;

Data.Foldable.$fFoldable(,)2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     (a1, a2) -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YJd eta_s6YJe]
        case eta_s6YJe of {
          (,) _ [Occ=Dead] y_s6YJh [Occ=Once] -> y_s6YJh;
        };

Data.Foldable.$fFoldable(,)3 :: forall a1 a2. (a2, a1) -> a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [x_s6YJi]
        case x_s6YJi of {
          (,) _ [Occ=Dead] y_s6YJl [Occ=Once] -> y_s6YJl;
        };

Data.Foldable.$fFoldable(,)_$cminimum
  :: forall a1 a2. GHC.Classes.Ord a2 => (a1, a2) -> a2
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YJm eta_B1] Data.Foldable.$fFoldable(,)3 eta_B1;

Data.Foldable.$fFoldable(,)_$cnull
  :: forall a1 a2. (a1, a2) -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6YJn]
        case ds_s6YJn of {
          (,) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldable(,)_$cfoldr1
  :: forall a1 a2. (a2 -> a2 -> a2) -> (a1, a2) -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6YJr xs_s6YJs]
        case xs_s6YJs of {
          (,) _ [Occ=Dead] y_s6YJv [Occ=Once] -> y_s6YJv;
        };

Data.Foldable.$fFoldable(,)_$cfoldl'
  :: forall a1 b a2. (b -> a2 -> b) -> b -> (a1, a2) -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_s6YJw z0_s6YJx xs_s6YJy]
        case xs_s6YJy of {
          (,) _ [Occ=Dead] y_s6YJB [Occ=Once] -> f_s6YJw z0_s6YJx y_s6YJB;
        };

Data.Foldable.$fFoldable(,)_$clength
  :: forall a1 a2. (a1, a2) -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6YJC]
        case xs_s6YJC of {
          (,) _ [Occ=Dead] _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldable(,)_$cfold
  :: forall a m. GHC.Base.Monoid m => (a, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YJG ds_s6YJH]
        case ds_s6YJH of {
          (,) _ [Occ=Dead] y_s6YJK [Occ=Once] -> y_s6YJK;
        };

Data.Foldable.$fFoldable(,)1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     (a1, a2) -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YJL eta_s6YJM]
        case eta_s6YJM of {
          (,) _ [Occ=Dead] y_s6YJP [Occ=Once] -> y_s6YJP;
        };

Data.Foldable.$fFoldable(,)_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. (a1, a2) -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_s6YJQ]
        case eta_s6YJQ of {
          (,) _ [Occ=Dead] y_s6YJT [Occ=Once] -> : [y_s6YJT GHC.Types.[]];
        };

Data.Foldable.$fFoldable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable ((,) a)
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldable(,)_$cfold
                                             Data.Foldable.$fFoldable(,)_$cfoldMap
                                             Data.Foldable.$fFoldable(,)_$cfoldr
                                             Data.Foldable.$fFoldable(,)_$cfoldr
                                             Data.Foldable.$fFoldable(,)_$cfoldl'
                                             Data.Foldable.$fFoldable(,)_$cfoldl'
                                             Data.Foldable.$fFoldable(,)_$cfoldr1
                                             Data.Foldable.$fFoldable(,)_$cfoldr1
                                             Data.Foldable.$fFoldable(,)_$ctoList
                                             Data.Foldable.$fFoldable(,)_$cnull
                                             Data.Foldable.$fFoldable(,)_$clength
                                             Data.Foldable.$fFoldable(,)_$celem
                                             Data.Foldable.$fFoldable(,)_$cminimum
                                             Data.Foldable.$fFoldable(,)_$cminimum
                                             Data.Foldable.$fFoldable(,)2
                                             Data.Foldable.$fFoldable(,)1];

Data.Foldable.$fFoldableEither_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> Data.Either.Either a1 a2 -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YJU eta_s6YJV]
        let {
          ds_s6YJW [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_a6LND -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YJU eta_s6YJV] \u []
                  GHC.Classes.== $dEq_s6YJU eta_s6YJV; } in
        let {
          sat_s6YK1 [Occ=Once]
            :: Data.Either.Either a_a6LM0 a1_a6LND
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [ds_s6YJW] \r [ds1_s6YJX]
                  case ds1_s6YJX of {
                    Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                    Data.Either.Right y_s6YK0 [Occ=Once] -> ds_s6YJW y_s6YK0;
                  };
        } in  sat_s6YK1;

Data.Foldable.$fFoldableEither2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Either.Either a1 a2 -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YK2 ds_s6YK3]
        case ds_s6YK3 of {
          Data.Either.Left _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YK2;
          Data.Either.Right y_s6YK6 [Occ=Once] -> y_s6YK6;
        };

Data.Foldable.$fFoldableEither3
  :: forall a1 a2. Data.Either.Either a2 a1 -> a1
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YK7]
        case x_s6YK7 of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:2;
          Data.Either.Right y_s6YKa [Occ=Once] -> y_s6YKa;
        };

Data.Foldable.$fFoldableEither_$cminimum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YKb eta_B1] Data.Foldable.$fFoldableEither3 eta_B1;

Data.Foldable.$fFoldableEither4
  :: forall a1 a2. Data.Either.Either a2 a1 -> a1
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YKc]
        case x_s6YKc of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:3;
          Data.Either.Right y_s6YKf [Occ=Once] -> y_s6YKf;
        };

Data.Foldable.$fFoldableEither_$cmaximum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YKg eta_B1] Data.Foldable.$fFoldableEither4 eta_B1;

Data.Foldable.$fFoldableEither_$cfoldr1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YKh xs_s6YKi]
        case xs_s6YKi of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:.:3;
          Data.Either.Right y_s6YKl [Occ=Once] -> y_s6YKl;
        };

Data.Foldable.$fFoldableEither_$cfoldl'
  :: forall a1 b a2.
     (b -> a2 -> b) -> b -> Data.Either.Either a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YKm z0_s6YKn xs_s6YKo]
        case xs_s6YKo of {
          Data.Either.Left _ [Occ=Dead] -> z0_s6YKn;
          Data.Either.Right y_s6YKr [Occ=Once] -> f_s6YKm z0_s6YKn y_s6YKr;
        };

Data.Foldable.$fFoldableEither_$cfoldl1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YKs xs_s6YKt]
        case xs_s6YKt of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:.:2;
          Data.Either.Right y_s6YKw [Occ=Once] -> y_s6YKw;
        };

Data.Foldable.$fFoldableEither_$cfold
  :: forall a m. GHC.Base.Monoid m => Data.Either.Either a m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YKx ds_s6YKy]
        case ds_s6YKy of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YKx;
          Data.Either.Right y_s6YKB [Occ=Once] -> y_s6YKB;
        };

Data.Foldable.$fFoldableEither1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Either.Either a1 a2 -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YKC ds_s6YKD]
        case ds_s6YKD of {
          Data.Either.Left _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YKC;
          Data.Either.Right y_s6YKG [Occ=Once] -> y_s6YKG;
        };

Data.Foldable.$fFoldableEither_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. Data.Either.Either a1 a2 -> [a2]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6YKH]
        case eta_s6YKH of {
          Data.Either.Left _ [Occ=Dead] -> [] [];
          Data.Either.Right y_s6YKK [Occ=Once] -> : [y_s6YKK GHC.Types.[]];
        };

Data.Foldable.$fFoldableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable (Data.Either.Either a)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableEither_$cfold
                                             Data.Foldable.$fFoldableEither_$cfoldMap
                                             Data.Foldable.$fFoldableEither_$cfoldr
                                             Data.Foldable.$fFoldableEither_$cfoldr
                                             Data.Foldable.$fFoldableEither_$cfoldl'
                                             Data.Foldable.$fFoldableEither_$cfoldl'
                                             Data.Foldable.$fFoldableEither_$cfoldr1
                                             Data.Foldable.$fFoldableEither_$cfoldl1
                                             Data.Foldable.$fFoldableEither_$ctoList
                                             Data.Either.isLeft
                                             Data.Foldable.$fFoldableEither_$clength
                                             Data.Foldable.$fFoldableEither_$celem
                                             Data.Foldable.$fFoldableEither_$cmaximum
                                             Data.Foldable.$fFoldableEither_$cminimum
                                             Data.Foldable.$fFoldableEither2
                                             Data.Foldable.$fFoldableEither1];

Data.Foldable.$fFoldableNonEmpty_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YKL eta_s6YKM]
        let {
          f_s6YKN [Dmd=<L,C(U)>] :: a_a6LQe -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YKL eta_s6YKM] \u []
                  GHC.Classes.== $dEq_s6YKL eta_s6YKM; } in
        let {
          sat_s6YL3 [Occ=OnceT[0]]
            :: GHC.Base.NonEmpty a_a6LQe -> GHC.Types.Bool
          [LclId] =
              [f_s6YKN] \r [ds_s6YKO]
                  let {
                    sat_s6YKS [Occ=Once] :: a_a6LQe
                    [LclId] =
                        [ds_s6YKO] \u []
                            case ds_s6YKO of {
                              GHC.Base.:| a1_s6YKQ [Occ=Once] _ [Occ=Dead] -> a1_s6YKQ;
                            };
                  } in 
                    case f_s6YKN sat_s6YKS of {
                      GHC.Types.False ->
                          case ds_s6YKO of {
                            GHC.Base.:| _ [Occ=Dead] as_s6YKW [Occ=Once] ->
                                let-no-escape {
                                  go_s6YKX [Occ=LoopBreakerT[1]] :: [a_a6LQe] -> GHC.Types.Bool
                                  [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                      sat-only [f_s6YKN go_s6YKX] \r [ds1_s6YKY]
                                          case ds1_s6YKY of {
                                            [] -> GHC.Types.False [];
                                            : y_s6YL0 [Occ=Once] ys_s6YL1 [Occ=Once] ->
                                                case f_s6YKN y_s6YL0 of {
                                                  GHC.Types.False -> go_s6YKX ys_s6YL1;
                                                  GHC.Types.True -> GHC.Types.True [];
                                                };
                                          };
                                } in  go_s6YKX as_s6YKW;
                          };
                      GHC.Types.True -> GHC.Types.True [];
                    };
        } in  sat_s6YL3;

Data.Foldable.$fFoldableNonEmpty_$csum
  :: forall a. GHC.Num.Num a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Str=<S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,1*C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YL4 ds_s6YL5]
        let {
          sat_s6YLk [Occ=Once] :: a_a6LQI
          [LclId] =
              [$dNum_s6YL4 ds_s6YL5] \u []
                  case ds_s6YL5 of {
                    GHC.Base.:| _ [Occ=Dead] as_s6YLc [Occ=Once] ->
                        let {
                          z_s6YLd [Occ=OnceL] :: a_a6LQI
                          [LclId] =
                              [$dNum_s6YL4] \u []
                                  GHC.Num.fromInteger
                                      $dNum_s6YL4 Data.Semigroup.Internal.$fMonoidSum1; } in
                        let {
                          go_s6YLe [Occ=LoopBreaker]
                            :: [a_a6LQI] -> Data.Semigroup.Internal.Sum a_a6LQI
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6YL4 z_s6YLd go_s6YLe] \r [ds1_s6YLf]
                                  case ds1_s6YLf of {
                                    [] -> z_s6YLd;
                                    : y_s6YLh [Occ=Once] ys_s6YLi [Occ=Once] ->
                                        let {
                                          sat_s6YLj [Occ=Once] :: a_a6LQI
                                          [LclId] =
                                              [go_s6YLe ys_s6YLi] \u [] go_s6YLe ys_s6YLi;
                                        } in  GHC.Num.+ $dNum_s6YL4 y_s6YLh sat_s6YLj;
                                  };
                        } in  go_s6YLe as_s6YLc;
                  }; } in
        let {
          sat_s6YL9 [Occ=Once] :: a_a6LQI
          [LclId] =
              [ds_s6YL5] \u []
                  case ds_s6YL5 of {
                    GHC.Base.:| a1_s6YL7 [Occ=Once] _ [Occ=Dead] -> a1_s6YL7;
                  };
        } in  GHC.Num.+ $dNum_s6YL4 sat_s6YL9 sat_s6YLk;

Data.Foldable.$w$cminimum1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6YLl ww_s6YLm ww1_s6YLn]
        let {
          go_s6YLo [Occ=LoopBreaker]
            :: [a_s6NYC] -> Data.Functor.Utils.Min a_s6NYC
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6YLl go_s6YLo] \r [ds_s6YLp]
                  case ds_s6YLp of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6YLr ys_s6YLs [Occ=Once] ->
                        case go_s6YLo ys_s6YLs of wild1_s6YLt {
                          GHC.Base.Nothing -> GHC.Base.Just [y_s6YLr];
                          GHC.Base.Just ipv_s6YLu [Occ=Once] ->
                              case GHC.Classes.<= w_s6YLl y_s6YLr ipv_s6YLu of {
                                GHC.Types.False -> wild1_s6YLt;
                                GHC.Types.True -> GHC.Base.Just [y_s6YLr];
                              };
                        };
                  };
        } in 
          case go_s6YLo ww1_s6YLn of {
            GHC.Base.Nothing -> ww_s6YLm;
            GHC.Base.Just ipv_s6YLx ->
                case GHC.Classes.<= w_s6YLl ww_s6YLm ipv_s6YLx of {
                  GHC.Types.False -> ipv_s6YLx;
                  GHC.Types.True -> ww_s6YLm;
                };
          };

Data.Foldable.$fFoldableNonEmpty_$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YLz w1_s6YLA]
        case w1_s6YLA of {
          GHC.Base.:| ww1_s6YLC [Occ=Once] ww2_s6YLD [Occ=Once] ->
              Data.Foldable.$w$cminimum1 w_s6YLz ww1_s6YLC ww2_s6YLD;
        };

Data.Foldable.$w$cmaximum1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6YLE ww_s6YLF ww1_s6YLG]
        let {
          go_s6YLH [Occ=LoopBreaker]
            :: [a_s6NYM] -> Data.Functor.Utils.Max a_s6NYM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6YLE go_s6YLH] \r [ds_s6YLI]
                  case ds_s6YLI of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6YLK ys_s6YLL [Occ=Once] ->
                        case go_s6YLH ys_s6YLL of wild1_s6YLM {
                          GHC.Base.Nothing -> GHC.Base.Just [y_s6YLK];
                          GHC.Base.Just ipv_s6YLN [Occ=Once] ->
                              case GHC.Classes.>= w_s6YLE y_s6YLK ipv_s6YLN of {
                                GHC.Types.False -> wild1_s6YLM;
                                GHC.Types.True -> GHC.Base.Just [y_s6YLK];
                              };
                        };
                  };
        } in 
          case go_s6YLH ww1_s6YLG of {
            GHC.Base.Nothing -> ww_s6YLF;
            GHC.Base.Just ipv_s6YLQ ->
                case GHC.Classes.>= w_s6YLE ww_s6YLF ipv_s6YLQ of {
                  GHC.Types.False -> ipv_s6YLQ;
                  GHC.Types.True -> ww_s6YLF;
                };
          };

Data.Foldable.$fFoldableNonEmpty_$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YLS w1_s6YLT]
        case w1_s6YLT of {
          GHC.Base.:| ww1_s6YLV [Occ=Once] ww2_s6YLW [Occ=Once] ->
              Data.Foldable.$w$cmaximum1 w_s6YLS ww1_s6YLV ww2_s6YLW;
        };

Data.Foldable.$fFoldableNonEmpty_$cnull
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YLX] GHC.Types.False [];

Data.Foldable.$w$cfoldr2 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> a -> a) -> a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6YLY ww_s6YLZ ww1_s6YM0]
        let {
          go_s6YM1 [Occ=LoopBreaker] :: [a_s6NYW] -> GHC.Base.Maybe a_s6NYW
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6YLY go_s6YM1] \r [ds_s6YM2]
                  case ds_s6YM2 of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6YM4 [Occ=Once*] ys_s6YM5 [Occ=Once] ->
                        let {
                          sat_s6YM8 [Occ=Once] :: a_s6NYW
                          [LclId] =
                              [w_s6YLY go_s6YM1 y_s6YM4 ys_s6YM5] \u []
                                  case go_s6YM1 ys_s6YM5 of {
                                    GHC.Base.Nothing -> y_s6YM4;
                                    GHC.Base.Just y1_s6YM7 [Occ=Once] -> w_s6YLY y_s6YM4 y1_s6YM7;
                                  };
                        } in  GHC.Base.Just [sat_s6YM8];
                  };
        } in 
          case go_s6YM1 ww1_s6YM0 of {
            GHC.Base.Nothing -> ww_s6YLZ;
            GHC.Base.Just y_s6YMa [Occ=Once] -> w_s6YLY ww_s6YLZ y_s6YMa;
          };

Data.Foldable.$fFoldableNonEmpty_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> a -> a) -> GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YMb w1_s6YMc]
        case w1_s6YMc of {
          GHC.Base.:| ww1_s6YMe [Occ=Once] ww2_s6YMf [Occ=Once] ->
              Data.Foldable.$w$cfoldr2 w_s6YMb ww1_s6YMe ww2_s6YMf;
        };

Data.Foldable.$w$cfoldl'1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6YMg w1_s6YMh ww_s6YMi ww1_s6YMj]
        case w_s6YMg w1_s6YMh ww_s6YMi of vx_s6YMk {
          __DEFAULT ->
              let-no-escape {
                go_s6YMl [Occ=LoopBreakerT[2]] :: [a_s6NZ8] -> b_s6NZ7 -> b_s6NZ7
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [w_s6YMg go_s6YMl] \r [ds_s6YMm eta_s6YMn]
                        case ds_s6YMm of {
                          [] -> eta_s6YMn;
                          : y_s6YMp [Occ=Once] ys_s6YMq [Occ=Once] ->
                              case w_s6YMg eta_s6YMn y_s6YMp of vx1_s6YMr {
                                __DEFAULT -> go_s6YMl ys_s6YMq vx1_s6YMr;
                              };
                        };
              } in  go_s6YMl ww1_s6YMj vx_s6YMk;
        };

Data.Foldable.$fFoldableNonEmpty_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YMs w1_s6YMt w2_s6YMu]
        case w2_s6YMu of {
          GHC.Base.:| ww1_s6YMw [Occ=Once] ww2_s6YMx [Occ=Once] ->
              Data.Foldable.$w$cfoldl'1 w_s6YMs w1_s6YMt ww1_s6YMw ww2_s6YMx;
        };

Data.Foldable.$w$cfoldr'1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6YMy w1_s6YMz ww_s6YMA ww1_s6YMB]
        let {
          sat_s6YMN [Occ=Once] :: b_s6NZm -> b_s6NZm
          [LclId] =
              [w_s6YMy ww_s6YMA] \r [z_s6YMM] w_s6YMy ww_s6YMA z_s6YMM;
        } in 
          let-no-escape {
            go_s6YMC [Occ=LoopBreakerT[3]]
              :: [a_s6NZl] -> (b_s6NZm -> b_s6NZm) -> b_s6NZm -> b_s6NZm
            [LclId[JoinId(3)],
             Arity=3,
             Str=<S,1*U><C(S),1*C1(U)><L,U>,
             Unf=OtherCon []] =
                sat-only [w_s6YMy go_s6YMC] \r [ds_s6YMD eta_s6YME eta1_s6YMF]
                    case ds_s6YMD of {
                      [] -> eta_s6YME eta1_s6YMF;
                      : y_s6YMH [Occ=Once] ys_s6YMI [Occ=Once] ->
                          let {
                            sat_s6YML [Occ=Once] :: b_s6NZm -> b_s6NZm
                            [LclId] =
                                [w_s6YMy eta_s6YME y_s6YMH] \r [z_s6YMJ]
                                    case w_s6YMy y_s6YMH z_s6YMJ of vx_s6YMK {
                                      __DEFAULT -> eta_s6YME vx_s6YMK;
                                    };
                          } in  go_s6YMC ys_s6YMI sat_s6YML eta1_s6YMF;
                    };
          } in  go_s6YMC ww1_s6YMB sat_s6YMN w1_s6YMz;

Data.Foldable.$fFoldableNonEmpty_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YMO w1_s6YMP w2_s6YMQ]
        case w2_s6YMQ of {
          GHC.Base.:| ww1_s6YMS [Occ=Once] ww2_s6YMT [Occ=Once] ->
              Data.Foldable.$w$cfoldr'1 w_s6YMO w1_s6YMP ww1_s6YMS ww2_s6YMT;
        };

Data.Foldable.$fFoldableNonEmpty_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Str=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,1*C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YMU ds_s6YMV]
        let {
          sat_s6YNa [Occ=Once] :: a_a6LQS
          [LclId] =
              [$dNum_s6YMU ds_s6YMV] \u []
                  case ds_s6YMV of {
                    GHC.Base.:| _ [Occ=Dead] as_s6YN2 [Occ=Once] ->
                        let {
                          z_s6YN3 [Occ=OnceL] :: a_a6LQS
                          [LclId] =
                              [$dNum_s6YMU] \u []
                                  GHC.Num.fromInteger
                                      $dNum_s6YMU Data.Semigroup.Internal.$fMonoidProduct1; } in
                        let {
                          go_s6YN4 [Occ=LoopBreaker]
                            :: [a_a6LQS] -> Data.Semigroup.Internal.Product a_a6LQS
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6YMU z_s6YN3 go_s6YN4] \r [ds1_s6YN5]
                                  case ds1_s6YN5 of {
                                    [] -> z_s6YN3;
                                    : y_s6YN7 [Occ=Once] ys_s6YN8 [Occ=Once] ->
                                        let {
                                          sat_s6YN9 [Occ=Once] :: a_a6LQS
                                          [LclId] =
                                              [go_s6YN4 ys_s6YN8] \u [] go_s6YN4 ys_s6YN8;
                                        } in  GHC.Num.* $dNum_s6YMU y_s6YN7 sat_s6YN9;
                                  };
                        } in  go_s6YN4 as_s6YN2;
                  }; } in
        let {
          sat_s6YMZ [Occ=Once] :: a_a6LQS
          [LclId] =
              [ds_s6YMV] \u []
                  case ds_s6YMV of {
                    GHC.Base.:| a1_s6YMX [Occ=Once] _ [Occ=Dead] -> a1_s6YMX;
                  };
        } in  GHC.Num.* $dNum_s6YMU sat_s6YMZ sat_s6YNa;

Data.Foldable.$fFoldableNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Base.NonEmpty
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldMap
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr'
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl'
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr1
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl1
                                             Data.Foldable.$fFoldableNonEmpty_$ctoList
                                             Data.Foldable.$fFoldableNonEmpty_$cnull
                                             Data.Foldable.$fFoldableNonEmpty_$clength
                                             Data.Foldable.$fFoldableNonEmpty_$celem
                                             Data.Foldable.$fFoldableNonEmpty_$cmaximum
                                             Data.Foldable.$fFoldableNonEmpty_$cminimum
                                             Data.Foldable.$fFoldableNonEmpty_$csum
                                             Data.Foldable.$fFoldableNonEmpty_$cproduct];

Data.Foldable.$fFoldableMaybe_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YNb eta_s6YNc]
        let {
          eta1_s6YNd [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LV4 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YNb eta_s6YNc] \u []
                  GHC.Classes.== $dEq_s6YNb eta_s6YNc; } in
        let {
          sat_s6YNh [Occ=Once]
            :: GHC.Base.Maybe a_a6LV4 -> Data.Semigroup.Internal.Any
          [LclId] =
              [eta1_s6YNd] \r [eta2_s6YNe]
                  case eta2_s6YNe of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x_s6YNg [Occ=Once] -> eta1_s6YNd x_s6YNg;
                  };
        } in  sat_s6YNh;

Data.Foldable.$fFoldableMaybe2
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Maybe a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YNi eta_s6YNj]
        case eta_s6YNj of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YNi;
          GHC.Base.Just x_s6YNl [Occ=Once] -> x_s6YNl;
        };

Data.Foldable.$fFoldableMaybe3 :: forall a. GHC.Base.Maybe a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YNm]
        case x_s6YNm of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6YNo [Occ=Once] -> v_s6YNo;
        };

Data.Foldable.$fFoldableMaybe_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YNp eta_B1] Data.Foldable.$fFoldableMaybe3 eta_B1;

Data.Foldable.$fFoldableMaybe4 :: forall a. GHC.Base.Maybe a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YNq]
        case x_s6YNq of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6YNs [Occ=Once] -> v_s6YNs;
        };

Data.Foldable.$fFoldableMaybe_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YNt eta_B1] Data.Foldable.$fFoldableMaybe4 eta_B1;

Data.Foldable.$fFoldableMaybe_$cnull
  :: forall a. GHC.Base.Maybe a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6YNu]
        case ds_s6YNu of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableMaybe_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YNx xs_s6YNy]
        case xs_s6YNy of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just v_s6YNA [Occ=Once] -> v_s6YNA;
        };

Data.Foldable.$fFoldableMaybe_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YNB xs_s6YNC]
        case xs_s6YNC of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just v_s6YNE [Occ=Once] -> v_s6YNE;
        };

Data.Foldable.$fFoldableMaybe_$clength
  :: forall a. GHC.Base.Maybe a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6YNF]
        case xs_s6YNF of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableMaybe_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Base.Maybe m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YNI eta_s6YNJ]
        case eta_s6YNJ of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YNI;
          GHC.Base.Just x_s6YNL [Occ=Once] -> x_s6YNL;
        };

Data.Foldable.$fFoldableMaybe1
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Maybe a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YNM eta_s6YNN]
        case eta_s6YNN of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YNM;
          GHC.Base.Just x_s6YNP [Occ=Once] -> x_s6YNP;
        };

Data.Foldable.$fFoldableMaybe_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Base.Maybe a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6YNQ]
        case eta_s6YNQ of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6YNS [Occ=Once] -> : [x_s6YNS GHC.Types.[]];
        };

Data.Foldable.$fFoldableMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Base.Maybe
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableMaybe_$cfold
                                             Data.Foldable.$fFoldableMaybe_$cfoldMap
                                             Data.Foldable.$fFoldableMaybe_$cfoldr
                                             Data.Foldable.$fFoldableMaybe_$cfoldr
                                             Data.Foldable.$fFoldableMaybe_$cfoldl
                                             Data.Foldable.$fFoldableMaybe_$cfoldl
                                             Data.Foldable.$fFoldableMaybe_$cfoldr1
                                             Data.Foldable.$fFoldableMaybe_$cfoldl1
                                             Data.Foldable.$fFoldableMaybe_$ctoList
                                             Data.Foldable.$fFoldableMaybe_$cnull
                                             Data.Foldable.$fFoldableMaybe_$clength
                                             Data.Foldable.$fFoldableMaybe_$celem
                                             Data.Foldable.$fFoldableMaybe_$cmaximum
                                             Data.Foldable.$fFoldableMaybe_$cminimum
                                             Data.Foldable.$fFoldableMaybe2
                                             Data.Foldable.$fFoldableMaybe1];

Data.Foldable.$fFoldableLast_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Monoid.Last a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YNT f_s6YNU x_s6YNV]
        case x_s6YNV of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YNT;
          GHC.Base.Just x1_s6YNX [Occ=Once] -> f_s6YNU x1_s6YNX;
        };

Data.Foldable.$fFoldableLast_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Monoid.Last m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YNY x_s6YNZ]
        case x_s6YNZ of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YNY;
          GHC.Base.Just x1_s6YO1 [Occ=Once] -> x1_s6YO1;
        };

Data.Foldable.$fFoldableLast2
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.Last a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YO2 x_s6YO3]
        case x_s6YO3 of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YO2;
          GHC.Base.Just x1_s6YO5 [Occ=Once] -> x1_s6YO5;
        };

Data.Foldable.$fFoldableLast3 :: forall a. Data.Monoid.Last a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YO6]
        case x_s6YO6 of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6YO8 [Occ=Once] -> v_s6YO8;
        };

Data.Foldable.$fFoldableLast_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YO9 eta_B1] Data.Foldable.$fFoldableLast3 eta_B1;

Data.Foldable.$fFoldableLast4 :: forall a. Data.Monoid.Last a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YOa]
        case x_s6YOa of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6YOc [Occ=Once] -> v_s6YOc;
        };

Data.Foldable.$fFoldableLast_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YOd eta_B1] Data.Foldable.$fFoldableLast4 eta_B1;

Data.Foldable.$fFoldableLast_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Monoid.Last a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YOe eta_s6YOf]
        let {
          f_s6YOg [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LuI -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YOe eta_s6YOf] \u []
                  GHC.Classes.== $dEq_s6YOe eta_s6YOf; } in
        let {
          sat_s6YOk [Occ=Once]
            :: Data.Monoid.Last a_a6LuI -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6YOg] \r [x_s6YOh]
                  case x_s6YOh of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x1_s6YOj [Occ=Once] -> f_s6YOg x1_s6YOj;
                  };
        } in  sat_s6YOk;

Data.Foldable.$fFoldableLast_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Monoid.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YOl z_s6YOm t_s6YOn]
        case t_s6YOn of {
          GHC.Base.Nothing -> z_s6YOm;
          GHC.Base.Just x_s6YOp [Occ=Once] -> f_s6YOl z_s6YOm x_s6YOp;
        };

Data.Foldable.$fFoldableLast_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YOq xs_s6YOr]
        case xs_s6YOr of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just x_s6YOt [Occ=Once] -> x_s6YOt;
        };

Data.Foldable.$fFoldableLast_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Monoid.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YOu z0_s6YOv xs_s6YOw]
        case xs_s6YOw of {
          GHC.Base.Nothing -> z0_s6YOv;
          GHC.Base.Just x_s6YOy [Occ=Once] -> f_s6YOu x_s6YOy z0_s6YOv;
        };

Data.Foldable.$fFoldableLast_$clength
  :: forall a. Data.Monoid.Last a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6YOz]
        case xs_s6YOz of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableLast_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YOC xs_s6YOD]
        case xs_s6YOD of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just x_s6YOF [Occ=Once] -> x_s6YOF;
        };

Data.Foldable.$fFoldableLast_$cnull
  :: forall a. Data.Monoid.Last a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t_s6YOG]
        case t_s6YOG of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableLast1
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.Last a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YOJ x_s6YOK]
        case x_s6YOK of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YOJ;
          GHC.Base.Just x1_s6YOM [Occ=Once] -> x1_s6YOM;
        };

Data.Foldable.$fFoldableLast_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Monoid.Last a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6YON]
        case eta_s6YON of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6YOP [Occ=Once] -> : [x_s6YOP GHC.Types.[]];
        };

Data.Foldable.$fFoldableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Monoid.Last
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableLast_$cfold
                                             Data.Foldable.$fFoldableLast_$cfoldMap
                                             Data.Foldable.$fFoldableLast_$cfoldr'
                                             Data.Foldable.$fFoldableLast_$cfoldr'
                                             Data.Foldable.$fFoldableLast_$cfoldl
                                             Data.Foldable.$fFoldableLast_$cfoldl
                                             Data.Foldable.$fFoldableLast_$cfoldr1
                                             Data.Foldable.$fFoldableLast_$cfoldl1
                                             Data.Foldable.$fFoldableLast_$ctoList
                                             Data.Foldable.$fFoldableLast_$cnull
                                             Data.Foldable.$fFoldableLast_$clength
                                             Data.Foldable.$fFoldableLast_$celem
                                             Data.Foldable.$fFoldableLast_$cmaximum
                                             Data.Foldable.$fFoldableLast_$cminimum
                                             Data.Foldable.$fFoldableLast2
                                             Data.Foldable.$fFoldableLast1];

Data.Foldable.$fFoldableFirst_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Monoid.First a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YOQ f_s6YOR x_s6YOS]
        case x_s6YOS of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YOQ;
          GHC.Base.Just x1_s6YOU [Occ=Once] -> f_s6YOR x1_s6YOU;
        };

Data.Foldable.$fFoldableFirst_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Monoid.First m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YOV x_s6YOW]
        case x_s6YOW of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YOV;
          GHC.Base.Just x1_s6YOY [Occ=Once] -> x1_s6YOY;
        };

Data.Foldable.$fFoldableFirst2
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.First a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YOZ x_s6YP0]
        case x_s6YP0 of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YOZ;
          GHC.Base.Just x1_s6YP2 [Occ=Once] -> x1_s6YP2;
        };

Data.Foldable.$fFoldableFirst3
  :: forall a. Data.Monoid.First a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YP3]
        case x_s6YP3 of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6YP5 [Occ=Once] -> v_s6YP5;
        };

Data.Foldable.$fFoldableFirst_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YP6 eta_B1] Data.Foldable.$fFoldableFirst3 eta_B1;

Data.Foldable.$fFoldableFirst4
  :: forall a. Data.Monoid.First a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YP7]
        case x_s6YP7 of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6YP9 [Occ=Once] -> v_s6YP9;
        };

Data.Foldable.$fFoldableFirst_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YPa eta_B1] Data.Foldable.$fFoldableFirst4 eta_B1;

Data.Foldable.$fFoldableFirst_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Monoid.First a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YPb eta_s6YPc]
        let {
          f_s6YPd [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6Lxh -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YPb eta_s6YPc] \u []
                  GHC.Classes.== $dEq_s6YPb eta_s6YPc; } in
        let {
          sat_s6YPh [Occ=Once]
            :: Data.Monoid.First a_a6Lxh -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6YPd] \r [x_s6YPe]
                  case x_s6YPe of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x1_s6YPg [Occ=Once] -> f_s6YPd x1_s6YPg;
                  };
        } in  sat_s6YPh;

Data.Foldable.$fFoldableFirst_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Monoid.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YPi z_s6YPj t_s6YPk]
        case t_s6YPk of {
          GHC.Base.Nothing -> z_s6YPj;
          GHC.Base.Just x_s6YPm [Occ=Once] -> f_s6YPi z_s6YPj x_s6YPm;
        };

Data.Foldable.$fFoldableFirst_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YPn xs_s6YPo]
        case xs_s6YPo of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just x_s6YPq [Occ=Once] -> x_s6YPq;
        };

Data.Foldable.$fFoldableFirst_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Monoid.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YPr z0_s6YPs xs_s6YPt]
        case xs_s6YPt of {
          GHC.Base.Nothing -> z0_s6YPs;
          GHC.Base.Just x_s6YPv [Occ=Once] -> f_s6YPr x_s6YPv z0_s6YPs;
        };

Data.Foldable.$fFoldableFirst_$clength
  :: forall a. Data.Monoid.First a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6YPw]
        case xs_s6YPw of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableFirst_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YPz xs_s6YPA]
        case xs_s6YPA of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just x_s6YPC [Occ=Once] -> x_s6YPC;
        };

Data.Foldable.$fFoldableFirst_$cnull
  :: forall a. Data.Monoid.First a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t_s6YPD]
        case t_s6YPD of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableFirst1
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.First a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YPG x_s6YPH]
        case x_s6YPH of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YPG;
          GHC.Base.Just x1_s6YPJ [Occ=Once] -> x1_s6YPJ;
        };

Data.Foldable.$fFoldableFirst_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Monoid.First a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6YPK]
        case eta_s6YPK of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6YPM [Occ=Once] -> : [x_s6YPM GHC.Types.[]];
        };

Data.Foldable.$fFoldableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Monoid.First
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableFirst_$cfold
                                             Data.Foldable.$fFoldableFirst_$cfoldMap
                                             Data.Foldable.$fFoldableFirst_$cfoldr'
                                             Data.Foldable.$fFoldableFirst_$cfoldr'
                                             Data.Foldable.$fFoldableFirst_$cfoldl
                                             Data.Foldable.$fFoldableFirst_$cfoldl
                                             Data.Foldable.$fFoldableFirst_$cfoldr1
                                             Data.Foldable.$fFoldableFirst_$cfoldl1
                                             Data.Foldable.$fFoldableFirst_$ctoList
                                             Data.Foldable.$fFoldableFirst_$cnull
                                             Data.Foldable.$fFoldableFirst_$clength
                                             Data.Foldable.$fFoldableFirst_$celem
                                             Data.Foldable.$fFoldableFirst_$cmaximum
                                             Data.Foldable.$fFoldableFirst_$cminimum
                                             Data.Foldable.$fFoldableFirst2
                                             Data.Foldable.$fFoldableFirst1];

Data.Foldable.all1
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> Data.Semigroup.Internal.All
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YPN p_s6YPO]
        Data.Foldable.foldMap
            $dFoldable_s6YPN Data.Semigroup.Internal.$fMonoidAll p_s6YPO;

Data.Foldable.all
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Foldable.all1 eta_B2 eta_B1;

Data.Foldable.$fFoldable:.:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*U,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YPP $dFoldable1_s6YPQ ds_s6YPR]
        let {
          sat_s6YPS [Occ=Once]
            :: g_a6L4V a_a6L6K -> Data.Semigroup.Internal.All
          [LclId] =
              [$dFoldable1_s6YPQ] \u [] Data.Foldable.null $dFoldable1_s6YPQ;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YPP
              Data.Semigroup.Internal.$fMonoidAll
              sat_s6YPS
              ds_s6YPR;

Data.Foldable.$fFoldable:.:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:.:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YPT $dFoldable1_s6YPU $dMonoid_s6YPV ds_s6YPW]
        let {
          sat_s6YPX [Occ=Once] :: g_X6Lnv m_a6L51 -> m_a6L51
          [LclId] =
              [$dFoldable1_s6YPU $dMonoid_s6YPV] \u []
                  Data.Foldable.foldMap $dFoldable1_s6YPU $dMonoid_s6YPV GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YPT $dMonoid_s6YPV sat_s6YPX ds_s6YPW;

Data.Foldable.$fFoldable:.:_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YPY $dFoldable1_s6YPZ $dNum_s6YQ0]
        let {
          $dMonoid_s6YQ1
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6L7y)
          [LclId] =
              [$dNum_s6YQ0] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6YQ0; } in
        let {
          lvl1_s6YQ2 [Occ=OnceL]
            :: g_X6Lnu a_a6L7y -> Data.Semigroup.Internal.Sum a_a6L7y
          [LclId] =
              [$dFoldable1_s6YPZ $dMonoid_s6YQ1] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6YPZ $dMonoid_s6YQ1 Data.Foldable.$fFoldable:*:1; } in
        let {
          sat_s6YQ4 [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lns g_X6Lnu a_a6L7y
               -> Data.Semigroup.Internal.Sum a_a6L7y
          [LclId] =
              [$dFoldable_s6YPY $dMonoid_s6YQ1 lvl1_s6YQ2] \r [ds_s6YQ3]
                  Data.Foldable.foldMap
                      $dFoldable_s6YPY $dMonoid_s6YQ1 lvl1_s6YQ2 ds_s6YQ3;
        } in  sat_s6YQ4;

Data.Foldable.$fFoldable:.:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQ5 $dFoldable1_s6YQ6 $dOrd_s6YQ7]
        let {
          $dMonoid_s6YQ8 :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6L7o)
          [LclId] =
              [$dOrd_s6YQ7] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6YQ7; } in
        let {
          lvl1_s6YQ9 [Occ=OnceL]
            :: g_X6Lnt a_a6L7o -> Data.Functor.Utils.Min a_a6L7o
          [LclId] =
              [$dFoldable1_s6YQ6 $dMonoid_s6YQ8] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6YQ6 $dMonoid_s6YQ8 GHC.Base.Just; } in
        let {
          sat_s6YQd [Occ=OnceT[0]]
            :: (GHC.Generics.:.:) f_X6Lnr g_X6Lnt a_a6L7o -> a_a6L7o
          [LclId] =
              [$dFoldable_s6YQ5 $dMonoid_s6YQ8 lvl1_s6YQ9] \r [x_s6YQa]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YQ5 $dMonoid_s6YQ8 lvl1_s6YQ9 x_s6YQa
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6YQc [Occ=Once] -> v_s6YQc;
                  };
        } in  sat_s6YQd;

Data.Foldable.$fFoldable:.:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQe $dFoldable1_s6YQf $dOrd_s6YQg]
        let {
          $dMonoid_s6YQh :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6L7e)
          [LclId] =
              [$dOrd_s6YQg] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6YQg; } in
        let {
          lvl1_s6YQi [Occ=OnceL]
            :: g_X6Lns a_a6L7e -> Data.Functor.Utils.Max a_a6L7e
          [LclId] =
              [$dFoldable1_s6YQf $dMonoid_s6YQh] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6YQf $dMonoid_s6YQh GHC.Base.Just; } in
        let {
          sat_s6YQm [Occ=OnceT[0]]
            :: (GHC.Generics.:.:) f_X6Lnq g_X6Lns a_a6L7e -> a_a6L7e
          [LclId] =
              [$dFoldable_s6YQe $dMonoid_s6YQh lvl1_s6YQi] \r [x_s6YQj]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YQe $dMonoid_s6YQh lvl1_s6YQi x_s6YQj
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6YQl [Occ=Once] -> v_s6YQl;
                  };
        } in  sat_s6YQm;

Data.Foldable.$fFoldable:.:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:.:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQn $dFoldable1_s6YQo $dEq_s6YQp eta_s6YQq]
        let {
          lvl1_s6YQr [Occ=OnceL]
            :: g_X6Lnr a_a6L74 -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable1_s6YQo $dEq_s6YQp eta_s6YQq] \u []
                  let {
                    sat_s6YQs [Occ=Once] :: a_a6L74 -> Data.Semigroup.Internal.Any
                    [LclId] =
                        [$dEq_s6YQp eta_s6YQq] \u [] GHC.Classes.== $dEq_s6YQp eta_s6YQq;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6YQo
                        Data.Semigroup.Internal.$fMonoidAny
                        sat_s6YQs; } in
        let {
          sat_s6YQu [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lnp g_X6Lnr a_a6L74
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6YQn lvl1_s6YQr] \r [ds_s6YQt]
                  Data.Foldable.foldMap
                      $dFoldable_s6YQn
                      Data.Semigroup.Internal.$fMonoidAny
                      lvl1_s6YQr
                      ds_s6YQt;
        } in  sat_s6YQu;

Data.Foldable.$fFoldable:.:_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQv $dFoldable1_s6YQw f1_s6YQx xs_s6YQy]
        let {
          f2_s6YQz [Occ=OnceL]
            :: a_a6L6m -> GHC.Base.Maybe a_a6L6m -> GHC.Base.Maybe a_a6L6m
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [f1_s6YQx] \r [x_s6YQA m_s6YQB]
                  let {
                    sat_s6YQE [Occ=Once] :: a_a6L6m
                    [LclId] =
                        [f1_s6YQx x_s6YQA m_s6YQB] \u []
                            case m_s6YQB of {
                              GHC.Base.Nothing -> x_s6YQA;
                              GHC.Base.Just y_s6YQD [Occ=Once] -> f1_s6YQx x_s6YQA y_s6YQD;
                            };
                  } in  GHC.Base.Just [sat_s6YQE]; } in
        let {
          sat_s6YQH [Occ=Once]
            :: g_X6Lno a_a6L6m
               -> GHC.Base.Maybe a_a6L6m -> GHC.Base.Maybe a_a6L6m
          [LclId] =
              [$dFoldable1_s6YQw f2_s6YQz] \r [b1_s6YQF b2_s6YQG]
                  Data.Foldable.foldr $dFoldable1_s6YQw f2_s6YQz b2_s6YQG b1_s6YQF;
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6YQv sat_s6YQH GHC.Base.Nothing xs_s6YQy
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
            GHC.Base.Just v_s6YQJ [Occ=Once] -> v_s6YQJ;
          };

Data.Foldable.$fFoldable:.:_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQK
           $dFoldable1_s6YQL
           f1_s6YQM
           z0_s6YQN
           xs_s6YQO]
        let {
          f2_s6YQP [Occ=OnceL]
            :: a_a6L6d -> (b_a6L6c -> b_a6L6c) -> b_a6L6c -> b_a6L6c
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [f1_s6YQM] \r [x_s6YQQ k_s6YQR z_s6YQS]
                  case f1_s6YQM z_s6YQS x_s6YQQ of vx_s6YQT {
                    __DEFAULT -> k_s6YQR vx_s6YQT;
                  }; } in
        let {
          sat_s6YQW [Occ=Once]
            :: g_X6Lnn a_a6L6d -> (b_a6L6c -> b_a6L6c) -> b_a6L6c -> b_a6L6c
          [LclId] =
              [$dFoldable1_s6YQL f2_s6YQP] \r [b1_s6YQU b2_s6YQV]
                  Data.Foldable.foldr $dFoldable1_s6YQL f2_s6YQP b2_s6YQV b1_s6YQU;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6YQK sat_s6YQW GHC.Base.id xs_s6YQO z0_s6YQN;

Data.Foldable.$fFoldable:.:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQX $dFoldable1_s6YQY eta_s6YQZ]
        Data.Foldable.$fFoldable:.:_$cfoldl'
            $dFoldable_s6YQX
            $dFoldable1_s6YQY
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4
            eta_s6YQZ;

Data.Foldable.$fFoldable:.:_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YR0 $dFoldable1_s6YR1 f1_s6YR2 z_s6YR3 t_s6YR4]
        let {
          sat_s6YR8 [Occ=Once]
            :: g_X6Lnm a_a6L63
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6L62)
          [LclId] =
              [$dFoldable1_s6YR1 f1_s6YR2] \u []
                  let {
                    sat_s6YR7 [Occ=Once]
                      :: a_a6L63
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo b_a6L62)
                    [LclId] =
                        [f1_s6YR2] \r [x_s6YR5 y_s6YR6] f1_s6YR2 y_s6YR6 x_s6YR5;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6YR1 Data.Foldable.$fFoldable:*:7 sat_s6YR7;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YR0
              Data.Foldable.$fFoldable:*:7
              sat_s6YR8
              t_s6YR4
              z_s6YR3;

Data.Foldable.$fFoldable:.:_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YR9 $dFoldable1_s6YRa f1_s6YRb xs_s6YRc]
        let {
          sat_s6YRj [Occ=Once]
            :: g_X6Lnp a_a6L6u
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6L6u))
          [LclId] =
              [$dFoldable1_s6YRa f1_s6YRb] \u []
                  let {
                    sat_s6YRi [Occ=Once]
                      :: a_a6L6u
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6L6u))
                    [LclId] =
                        [f1_s6YRb] \r [x_s6YRd y_s6YRe]
                            let {
                              sat_s6YRh [Occ=Once] :: a_a6L6u
                              [LclId] =
                                  [f1_s6YRb x_s6YRd y_s6YRe] \u []
                                      case y_s6YRe of {
                                        GHC.Base.Nothing -> x_s6YRd;
                                        GHC.Base.Just x1_s6YRg [Occ=Once] ->
                                            f1_s6YRb x1_s6YRg x_s6YRd;
                                      };
                            } in  GHC.Base.Just [sat_s6YRh];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6YRa Data.Foldable.$fFoldable:*:7 sat_s6YRi;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6YR9
                  Data.Foldable.$fFoldable:*:7
                  sat_s6YRj
                  xs_s6YRc
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
            GHC.Base.Just v_s6YRl [Occ=Once] -> v_s6YRl;
          };

Data.Foldable.$fFoldable:.:_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YRm
           $dFoldable1_s6YRn
           f1_s6YRo
           z0_s6YRp
           xs_s6YRq]
        let {
          sat_s6YRw [Occ=Once]
            :: g_X6Lnl a_a6L5S
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6L5T -> b_a6L5T))
          [LclId] =
              [$dFoldable1_s6YRn f1_s6YRo] \u []
                  let {
                    sat_s6YRv [Occ=Once]
                      :: a_a6L5S
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (b_a6L5T -> b_a6L5T))
                    [LclId] =
                        [f1_s6YRo] \r [x_s6YRr y_s6YRs z_s6YRt]
                            case f1_s6YRo x_s6YRr z_s6YRt of vx_s6YRu {
                              __DEFAULT -> y_s6YRs vx_s6YRu;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6YRn Data.Foldable.$fFoldable:*:7 sat_s6YRv;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YRm
              Data.Foldable.$fFoldable:*:7
              sat_s6YRw
              xs_s6YRq
              GHC.Base.id
              z0_s6YRp;

Data.Foldable.$fFoldable:.:_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YRx $dFoldable1_s6YRy $dNum_s6YRz]
        let {
          $dMonoid_s6YRA
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6L7I)
          [LclId] =
              [$dNum_s6YRz] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6YRz; } in
        let {
          lvl1_s6YRB [Occ=OnceL]
            :: g_X6Lnk a_a6L7I -> Data.Semigroup.Internal.Product a_a6L7I
          [LclId] =
              [$dFoldable1_s6YRy $dMonoid_s6YRA] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6YRy $dMonoid_s6YRA Data.Foldable.$fFoldable:*:1; } in
        let {
          sat_s6YRD [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lni g_X6Lnk a_a6L7I
               -> Data.Semigroup.Internal.Product a_a6L7I
          [LclId] =
              [$dFoldable_s6YRx $dMonoid_s6YRA lvl1_s6YRB] \r [ds_s6YRC]
                  Data.Foldable.foldMap
                      $dFoldable_s6YRx $dMonoid_s6YRA lvl1_s6YRB ds_s6YRC;
        } in  sat_s6YRD;

Data.Foldable.$fFoldable:.:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YRE $dFoldable1_s6YRF eta_s6YRG]
        let {
          sat_s6YRJ [Occ=Once] :: g_X6Lnj a_a6L6C -> [a_a6L6C] -> [a_a6L6C]
          [LclId] =
              [$dFoldable1_s6YRF] \r [b1_s6YRH b2_s6YRI]
                  Data.Foldable.foldr
                      $dFoldable1_s6YRF GHC.Types.: b2_s6YRI b1_s6YRH;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6YRE sat_s6YRJ GHC.Types.[] eta_s6YRG;

Data.Foldable.$fFoldable:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6YRK $dFoldable1_s6YRL]
        let {
          sat_s6YS1 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cproduct
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YS0 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$csum
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRZ [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cminimum
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRY [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cmaximum
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRX [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$celem
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B2 eta_B1; } in
        let {
          sat_s6YRW [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$clength
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRV [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:1
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRU [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> [a]
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$ctoList
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRT [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl1
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B2 eta_B1; } in
        let {
          sat_s6YRS [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr1
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B2 eta_B1; } in
        let {
          sat_s6YRR [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl'
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YRQ [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YRP [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr'
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YRO [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YRN [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> m
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldMap
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YRM [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni m -> m
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfold
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6YRM
                                    sat_s6YRN
                                    sat_s6YRO
                                    sat_s6YRP
                                    sat_s6YRQ
                                    sat_s6YRR
                                    sat_s6YRS
                                    sat_s6YRT
                                    sat_s6YRU
                                    sat_s6YRV
                                    sat_s6YRW
                                    sat_s6YRX
                                    sat_s6YRY
                                    sat_s6YRZ
                                    sat_s6YS0
                                    sat_s6YS1];

Data.Foldable.maximumBy
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YS2 cmp_s6YS3]
        let {
          sat_s6YS7 [Occ=Once] :: a_a6KCW -> a_a6KCW -> a_a6KCW
          [LclId] =
              [cmp_s6YS3] \r [x_s6YS4 y_s6YS5]
                  case cmp_s6YS3 x_s6YS4 y_s6YS5 of {
                    __DEFAULT -> y_s6YS5;
                    GHC.Types.GT -> x_s6YS4;
                  };
        } in  Data.Foldable.foldl1 $dFoldable_s6YS2 sat_s6YS7;

Data.Foldable.minimumBy
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YS8 cmp_s6YS9]
        let {
          sat_s6YSd [Occ=Once] :: a_a6KCy -> a_a6KCy -> a_a6KCy
          [LclId] =
              [cmp_s6YS9] \r [x_s6YSa y_s6YSb]
                  case cmp_s6YS9 x_s6YSa y_s6YSb of {
                    __DEFAULT -> x_s6YSa;
                    GHC.Types.GT -> y_s6YSb;
                  };
        } in  Data.Foldable.foldl1 $dFoldable_s6YS8 sat_s6YSd;

Data.Foldable.notElem
  :: forall (t :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Classes.Eq a) =>
     a -> t a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(C(U))),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YSe $dEq_s6YSf x_s6YSg]
        let {
          g_s6YSh [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_a6KCk a_a6KCl -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YSe $dEq_s6YSf x_s6YSg] \u []
                  Data.Foldable.elem $dFoldable_s6YSe $dEq_s6YSf x_s6YSg; } in
        let {
          sat_s6YSk [Occ=OnceT[0]] :: t_a6KCk a_a6KCl -> GHC.Types.Bool
          [LclId] =
              [g_s6YSh] \r [x1_s6YSi]
                  case g_s6YSh x1_s6YSi of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  sat_s6YSk;

Data.Foldable.find
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YSl p_s6YSm]
        let {
          g_s6YSn [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_a6KC3 a_a6KC4 -> Data.Monoid.First a_a6KC4
          [LclId] =
              [$dFoldable_s6YSl p_s6YSm] \u []
                  let {
                    sat_s6YSq [Occ=Once] :: a_a6KC4 -> Data.Monoid.First a_a6KC4
                    [LclId] =
                        [p_s6YSm] \r [x_s6YSo]
                            case p_s6YSm x_s6YSo of {
                              GHC.Types.False -> GHC.Base.Nothing [];
                              GHC.Types.True -> GHC.Base.Just [x_s6YSo];
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6YSl Data.Monoid.$fMonoidFirst sat_s6YSq; } in
        let {
          sat_s6YSs [Occ=Once]
            :: t_a6KC3 a_a6KC4 -> Data.Monoid.First a_a6KC4
          [LclId] =
              [g_s6YSn] \r [x_s6YSr] g_s6YSn x_s6YSr;
        } in  sat_s6YSs;

Data.Foldable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Foldable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$trModule4];

Data.Foldable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Foldable"#;

Data.Foldable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$trModule2];

Data.Foldable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Foldable.$trModule3
                                     Data.Foldable.$trModule1];

$krep_r6OSX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Foldable.$tcFoldable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_r6OSX];

Data.Foldable.$tcFoldable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foldable"#;

Data.Foldable.$tcFoldable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$tcFoldable3];

Data.Foldable.$tcFoldable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1610127274683713266##
                                    5928938033451775936##
                                    Data.Foldable.$trModule
                                    Data.Foldable.$tcFoldable2
                                    0#
                                    Data.Foldable.$tcFoldable1];

Data.Foldable.C:Foldable
  :: forall (t :: * -> *).
     (forall m. GHC.Base.Monoid m => t m -> m)
     -> (forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m)
     -> (forall a b. (a -> b -> b) -> b -> t a -> b)
     -> (forall a b. (a -> b -> b) -> b -> t a -> b)
     -> (forall b a. (b -> a -> b) -> b -> t a -> b)
     -> (forall b a. (b -> a -> b) -> b -> t a -> b)
     -> (forall a. (a -> a -> a) -> t a -> a)
     -> (forall a. (a -> a -> a) -> t a -> a)
     -> (forall a. t a -> [a])
     -> (forall a. t a -> GHC.Types.Bool)
     -> (forall a. t a -> GHC.Types.Int)
     -> (forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool)
     -> (forall a. GHC.Classes.Ord a => t a -> a)
     -> (forall a. GHC.Classes.Ord a => t a -> a)
     -> (forall a. GHC.Num.Num a => t a -> a)
     -> (forall a. GHC.Num.Num a => t a -> a)
     -> Data.Foldable.Foldable t
[GblId[DataCon],
 Arity=16,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_Bg
           eta_Bf
           eta_Be
           eta_Bd
           eta_Bc
           eta_Bb
           eta_Ba
           eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        Data.Foldable.C:Foldable [eta_Bg
                                  eta_Bf
                                  eta_Be
                                  eta_Bd
                                  eta_Bc
                                  eta_Bb
                                  eta_Ba
                                  eta_B9
                                  eta_B8
                                  eta_B7
                                  eta_B6
                                  eta_B5
                                  eta_B4
                                  eta_B3
                                  eta_B2
                                  eta_B1];


==================== STG syntax: ====================
2018-03-16 16:02:16.135427327 UTC

Data.Foldable.fold
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m. GHC.Base.Monoid m => t m -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6YdM]
        case v_s6YdM of {
          Data.Foldable.C:Foldable v_s6YdO [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YdO;
        };

Data.Foldable.foldMap
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6Ye4]
        case v_s6Ye4 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   v_s6Ye7 [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Ye7;
        };

Data.Foldable.foldr
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6Yem]
        case v_s6Yem of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yeq [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Yeq;
        };

Data.Foldable.foldr'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6YeE]
        case v_s6YeE of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6YeJ [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YeJ;
        };

Data.Foldable.foldl
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6YeW]
        case v_s6YeW of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yf2 [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Yf2;
        };

Data.Foldable.foldl'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6Yfe]
        case v_s6Yfe of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yfl [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Yfl;
        };

Data.Foldable.foldr1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6Yfw]
        case v_s6Yfw of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6YfE [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YfE;
        };

Data.Foldable.foldl1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s6YfO]
        case v_s6YfO of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6YfX [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YfX;
        };

Data.Foldable.toList
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s6Yg6]
        case v_s6Yg6 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Ygg [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Ygg;
        };

Data.Foldable.null
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s6Ygo]
        case v_s6Ygo of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Ygz [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Ygz;
        };

Data.Foldable.length
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s6YgG]
        case v_s6YgG of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6YgS [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YgS;
        };

Data.Foldable.elem
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s6YgY]
        case v_s6YgY of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yhb [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Yhb;
        };

Data.Foldable.maximum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s6Yhg]
        case v_s6Yhg of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yhu [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6Yhu;
        };

Data.Foldable.minimum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s6Yhy]
        case v_s6Yhy of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6YhN [Occ=Once]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead] ->
              v_s6YhN;
        };

Data.Foldable.sum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s6YhQ]
        case v_s6YhQ of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yi6 [Occ=Once]
                                   _ [Occ=Dead] ->
              v_s6Yi6;
        };

Data.Foldable.product
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s6Yi8]
        case v_s6Yi8 of {
          Data.Foldable.C:Foldable _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   _ [Occ=Dead]
                                   v_s6Yip [Occ=Once] ->
              v_s6Yip;
        };

Data.Foldable.$fFoldableMaybe_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.Maybe a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6Yiq z_s6Yir ds1_s6Yis]
        case ds1_s6Yis of {
          GHC.Base.Nothing -> z_s6Yir;
          GHC.Base.Just x_s6Yiu [Occ=Once] -> ds_s6Yiq z_s6Yir x_s6Yiu;
        };

Data.Foldable.$fFoldableMaybe_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.Maybe a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6Yiv z_s6Yiw ds1_s6Yix]
        case ds1_s6Yix of {
          GHC.Base.Nothing -> z_s6Yiw;
          GHC.Base.Just x_s6Yiz [Occ=Once] -> ds_s6Yiv x_s6Yiz z_s6Yiw;
        };

Data.Foldable.$fFoldableMaybe_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Base.Maybe a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YiA eta_s6YiB eta1_s6YiC]
        case eta1_s6YiC of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YiA;
          GHC.Base.Just x_s6YiE [Occ=Once] -> eta_s6YiB x_s6YiE;
        };

Data.Foldable.$fFoldableNonEmpty_$clength
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s6YiF]
        case ds_s6YiF of {
          GHC.Base.:| _ [Occ=Dead] as_s6YiI [Occ=Once] ->
              case GHC.List.$wlenAcc as_s6YiI 0# of ww2_s6YiJ {
                __DEFAULT ->
                    case +# [1# ww2_s6YiJ] of sat_s6YiK {
                      __DEFAULT -> GHC.Types.I# [sat_s6YiK];
                    };
              };
        };

Data.Foldable.$fFoldableNonEmpty_$ctoList
  :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s6YiL]
        let {
          sat_s6YiT [Occ=Once] :: [a_a6LPN]
          [LclId] =
              [ds_s6YiL] \u []
                  case ds_s6YiL of {
                    GHC.Base.:| _ [Occ=Dead] as_s6YiS [Occ=Once] -> as_s6YiS;
                  }; } in
        let {
          sat_s6YiP [Occ=Once] :: a_a6LPN
          [LclId] =
              [ds_s6YiL] \u []
                  case ds_s6YiL of {
                    GHC.Base.:| a1_s6YiN [Occ=Once] _ [Occ=Dead] -> a1_s6YiN;
                  };
        } in  : [sat_s6YiP sat_s6YiT];

Data.Foldable.$fFoldableNonEmpty_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6YiU ds_s6YiV]
        case ds_s6YiV of {
          GHC.Base.:| a1_s6YiX [Occ=Once] as_s6YiY [Occ=Once] ->
              let-no-escape {
                go_s6YiZ [Occ=LoopBreakerT[2]] :: [a_a6LPG] -> a_a6LPG -> a_a6LPG
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [f_s6YiU go_s6YiZ] \r [ds1_s6Yj0 eta_s6Yj1]
                        case ds1_s6Yj0 of {
                          [] -> eta_s6Yj1;
                          : y_s6Yj3 [Occ=Once] ys_s6Yj4 [Occ=Once] ->
                              let {
                                sat_s6Yj5 [Occ=Once] :: a_a6LPG
                                [LclId] =
                                    [f_s6YiU eta_s6Yj1 y_s6Yj3] \u [] f_s6YiU eta_s6Yj1 y_s6Yj3;
                              } in  go_s6YiZ ys_s6Yj4 sat_s6Yj5;
                        };
              } in  go_s6YiZ as_s6YiY a1_s6YiX;
        };

Data.Foldable.$w$cfoldl2 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Yj6 w1_s6Yj7 ww_s6Yj8 ww1_s6Yj9]
        let {
          sat_s6Yjh [Occ=Once] :: b_s6NRS
          [LclId] =
              [w_s6Yj6 w1_s6Yj7 ww_s6Yj8] \u [] w_s6Yj6 w1_s6Yj7 ww_s6Yj8;
        } in 
          let-no-escape {
            go_s6Yja [Occ=LoopBreakerT[2]] :: [a_s6NRT] -> b_s6NRS -> b_s6NRS
            [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                sat-only [w_s6Yj6 go_s6Yja] \r [ds_s6Yjb eta_s6Yjc]
                    case ds_s6Yjb of {
                      [] -> eta_s6Yjc;
                      : y_s6Yje [Occ=Once] ys_s6Yjf [Occ=Once] ->
                          let {
                            sat_s6Yjg [Occ=Once] :: b_s6NRS
                            [LclId] =
                                [w_s6Yj6 eta_s6Yjc y_s6Yje] \u [] w_s6Yj6 eta_s6Yjc y_s6Yje;
                          } in  go_s6Yja ys_s6Yjf sat_s6Yjg;
                    };
          } in  go_s6Yja ww1_s6Yj9 sat_s6Yjh;

Data.Foldable.$fFoldableNonEmpty_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Yji w1_s6Yjj w2_s6Yjk]
        case w2_s6Yjk of {
          GHC.Base.:| ww1_s6Yjm [Occ=Once] ww2_s6Yjn [Occ=Once] ->
              Data.Foldable.$w$cfoldl2 w_s6Yji w1_s6Yjj ww1_s6Yjm ww2_s6Yjn;
        };

Data.Foldable.$fFoldableNonEmpty_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6Yjo z_s6Yjp ds_s6Yjq]
        let {
          sat_s6YjE [Occ=Once] :: b_a6LOW
          [LclId] =
              [f_s6Yjo z_s6Yjp ds_s6Yjq] \u []
                  case ds_s6Yjq of {
                    GHC.Base.:| _ [Occ=Dead] as_s6Yjx [Occ=Once] ->
                        let {
                          go_s6Yjy [Occ=LoopBreaker] :: [a_a6LOV] -> b_a6LOW
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [f_s6Yjo z_s6Yjp go_s6Yjy] \r [ds1_s6Yjz]
                                  case ds1_s6Yjz of {
                                    [] -> z_s6Yjp;
                                    : y_s6YjB [Occ=Once] ys_s6YjC [Occ=Once] ->
                                        let {
                                          sat_s6YjD [Occ=Once] :: b_a6LOW
                                          [LclId] =
                                              [go_s6Yjy ys_s6YjC] \u [] go_s6Yjy ys_s6YjC;
                                        } in  f_s6Yjo y_s6YjB sat_s6YjD;
                                  };
                        } in  go_s6Yjy as_s6Yjx;
                  }; } in
        let {
          sat_s6Yju [Occ=Once] :: a_a6LOV
          [LclId] =
              [ds_s6Yjq] \u []
                  case ds_s6Yjq of {
                    GHC.Base.:| a1_s6Yjs [Occ=Once] _ [Occ=Dead] -> a1_s6Yjs;
                  };
        } in  f_s6Yjo sat_s6Yju sat_s6YjE;

Data.Foldable.$fFoldable:*:4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Foldable.$fFoldableDual3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Foldable.$fFoldableEither_$clength
  :: forall a1 a2. Data.Either.Either a1 a2 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_s6YjF]
        case ds_s6YjF of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
          Data.Either.Right _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableEither_$cfoldr
  :: forall a1 a2 b.
     (a2 -> b -> b) -> b -> Data.Either.Either a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6YjJ z_s6YjK ds1_s6YjL]
        case ds1_s6YjL of {
          Data.Either.Left _ [Occ=Dead] -> z_s6YjK;
          Data.Either.Right y_s6YjO [Occ=Once] -> ds_s6YjJ y_s6YjO z_s6YjK;
        };

Data.Foldable.$fFoldableEither_$cfoldMap
  :: forall a1 m a2.
     GHC.Base.Monoid m =>
     (a2 -> m) -> Data.Either.Either a1 a2 -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YjP ds_s6YjQ ds1_s6YjR]
        case ds1_s6YjR of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YjP;
          Data.Either.Right y_s6YjU [Occ=Once] -> ds_s6YjQ y_s6YjU;
        };

Data.Foldable.$fFoldable(,)_$cfoldr
  :: forall a1 a2 b. (a2 -> b -> b) -> b -> (a1, a2) -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_s6YjV z_s6YjW ds_s6YjX]
        case ds_s6YjX of {
          (,) _ [Occ=Dead] y_s6Yk0 [Occ=Once] -> f_s6YjV y_s6Yk0 z_s6YjW;
        };

Data.Foldable.$fFoldable(,)_$cfoldMap
  :: forall a1 m a2. GHC.Base.Monoid m => (a2 -> m) -> (a1, a2) -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yk1 f_s6Yk2 ds_s6Yk3]
        case ds_s6Yk3 of {
          (,) _ [Occ=Dead] y_s6Yk6 [Occ=Once] -> f_s6Yk2 y_s6Yk6;
        };

Data.Foldable.$fFoldableArray_$cnull
  :: forall i a. GHC.Arr.Array i a -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),1*U(A,A,1*U,A)>,
 Unf=OtherCon []] =
    [] \r [a1_s6Yk7]
        case a1_s6Yk7 of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        dt_s6Ykb [Occ=Once!]
                        _ [Occ=Dead] ->
              case dt_s6Ykb of {
                __DEFAULT -> GHC.Types.False [];
                0# -> GHC.Types.True [];
              };
        };

sat_s6Yke :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s6Ykf :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6Yke GHC.Types.[]];

Data.Foldable.$fFoldableProxy1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6Ykf;

Data.Foldable.$fFoldableProxy_$cproduct
  :: forall a. GHC.Num.Num a => Data.Proxy.Proxy a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ykg ds_s6Ykh]
        GHC.Num.fromInteger $dNum_s6Ykg Data.Foldable.$fFoldableProxy1;

Data.Foldable.$fFoldableProxy2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Foldable.$fFoldableProxy_$csum
  :: forall a. GHC.Num.Num a => Data.Proxy.Proxy a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yki ds_s6Ykj]
        GHC.Num.fromInteger $dNum_s6Yki Data.Foldable.$fFoldableProxy2;

Data.Foldable.$fFoldableProxy_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Proxy.Proxy a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Ykk ds_s6Ykl ds1_s6Ykm] GHC.Types.False [];

Data.Foldable.$fFoldableProxy_$clength
  :: forall a. Data.Proxy.Proxy a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6Ykn] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableProxy_$cnull
  :: forall a. Data.Proxy.Proxy a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Yko] GHC.Types.True [];

Data.Foldable.$fFoldableProxy4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: Proxy"#;

Data.Foldable.$fFoldableProxy3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableProxy4;

Data.Foldable.$fFoldableProxy_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6Ykp ds1_s6Ykq]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableProxy3;

Data.Foldable.$fFoldableProxy6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: Proxy"#;

Data.Foldable.$fFoldableProxy5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableProxy6;

Data.Foldable.$fFoldableProxy_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6Ykr ds1_s6Yks]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableProxy5;

Data.Foldable.$fFoldableProxy_$cfoldl [InlPrag=INLINE (sat-args=3)]
  :: forall b a. (b -> a -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6Ykt z_s6Yku ds1_s6Ykv] z_s6Yku;

Data.Foldable.$fFoldableProxy_$cfoldr [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (a -> b -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6Ykw z_s6Ykx ds1_s6Yky] z_s6Ykx;

Data.Foldable.$fFoldableProxy_$cfoldMap [InlPrag=INLINE (sat-args=2)]
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Proxy.Proxy a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ykz eta_s6YkA ds_s6YkB]
        GHC.Base.mempty $dMonoid_s6Ykz;

Data.Foldable.$fFoldableProxy_$cfold [InlPrag=INLINE (sat-args=1)]
  :: forall m. GHC.Base.Monoid m => Data.Proxy.Proxy m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YkC ds_s6YkD] GHC.Base.mempty $dMonoid_s6YkC;

Data.Foldable.$fFoldableDual1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6YkE eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YkF eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual_$clength
  :: forall a. Data.Semigroup.Internal.Dual a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6YkG] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableDual_$cnull
  :: forall a. Data.Semigroup.Internal.Dual a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YkH] GHC.Types.False [];

Data.Foldable.$fFoldableDual_$ctoList
  :: forall a. Data.Semigroup.Internal.Dual a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6YkI] : [ds_s6YkI GHC.Types.[]];

Data.Foldable.$fFoldableDual4
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YkJ eta_B1]
        Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Foldable.$fFoldableDual5
  :: forall b a. (b -> a -> b) -> b -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6YkK] v_s6YkK;

Data.Foldable.$fFoldableDual_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Dual a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6YkL z_s6YkM ds_s6YkN] f_s6YkL ds_s6YkN z_s6YkM;

Data.Foldable.$fFoldableDual6
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> a -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YkO v_s6YkP] v_s6YkP;

Data.Foldable.$fFoldableSum1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6YkQ eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YkR eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum_$clength
  :: forall a. Data.Semigroup.Internal.Sum a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6YkS] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableSum_$cnull
  :: forall a. Data.Semigroup.Internal.Sum a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YkT] GHC.Types.False [];

Data.Foldable.$fFoldableSum_$ctoList
  :: forall a. Data.Semigroup.Internal.Sum a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6YkU] : [ds_s6YkU GHC.Types.[]];

Data.Foldable.$fFoldableSum3
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YkV eta_B1]
        Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Foldable.$fFoldableSum_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Sum a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6YkW z_s6YkX ds_s6YkY] f_s6YkW ds_s6YkY z_s6YkX;

Data.Foldable.$fFoldableProduct1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_s6YkZ eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yl0 eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct_$clength
  :: forall a. Data.Semigroup.Internal.Product a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6Yl1] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldableProduct_$cnull
  :: forall a. Data.Semigroup.Internal.Product a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Yl2] GHC.Types.False [];

Data.Foldable.$fFoldableProduct_$ctoList
  :: forall a. Data.Semigroup.Internal.Product a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_s6Yl3] : [ds_s6Yl3 GHC.Types.[]];

Data.Foldable.$fFoldableProduct3
  :: forall a.
     (a -> a -> a)
     -> Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Yl4 eta_B1]
        Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Foldable.$fFoldableProduct_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Semigroup.Internal.Product a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6Yl5 z_s6Yl6 ds_s6Yl7] f_s6Yl5 ds_s6Yl7 z_s6Yl6;

Data.Foldable.$fFoldableU1_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Generics.U1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yl8 ds_s6Yl9]
        GHC.Num.fromInteger $dNum_s6Yl8 Data.Foldable.$fFoldableProxy1;

Data.Foldable.$fFoldableU1_$csum
  :: forall a. GHC.Num.Num a => GHC.Generics.U1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yla ds_s6Ylb]
        GHC.Num.fromInteger $dNum_s6Yla Data.Foldable.$fFoldableProxy2;

Data.Foldable.$fFoldableU1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.U1 a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Ylc ds_s6Yld ds1_s6Yle] GHC.Types.False [];

Data.Foldable.$fFoldableU1_$clength
  :: forall a. GHC.Generics.U1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s6Ylf] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableU1_$cnull
  :: forall a. GHC.Generics.U1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Ylg] GHC.Types.True [];

Data.Foldable.$fFoldableU3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: U1"#;

Data.Foldable.$fFoldableU2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableU3;

Data.Foldable.$fFoldableU1_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6Ylh ds1_s6Yli]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableU2;

Data.Foldable.$fFoldableU5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: U1"#;

Data.Foldable.$fFoldableU4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableU5;

Data.Foldable.$fFoldableU1_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [ds_s6Ylj ds1_s6Ylk]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableU4;

Data.Foldable.$fFoldableU1_$cfoldl [InlPrag=INLINE (sat-args=3)]
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6Yll z_s6Ylm ds1_s6Yln] z_s6Ylm;

Data.Foldable.$fFoldableU1_$cfoldr [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_s6Ylo z_s6Ylp ds1_s6Ylq] z_s6Ylp;

Data.Foldable.$fFoldableU1_$cfoldMap [InlPrag=INLINE (sat-args=2)]
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.U1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ylr eta_s6Yls ds_s6Ylt]
        GHC.Base.mempty $dMonoid_s6Ylr;

Data.Foldable.$fFoldableU1_$cfold [InlPrag=INLINE (sat-args=1)]
  :: forall m. GHC.Base.Monoid m => GHC.Generics.U1 m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ylu ds_s6Ylv] GHC.Base.mempty $dMonoid_s6Ylu;

Data.Foldable.$fFoldableV1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.V1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ylw ds_s6Ylx ds1_s6Yly]
        GHC.Base.mempty $dMonoid_s6Ylw;

Data.Foldable.$fFoldablePar1_$cnull
  :: forall a. GHC.Generics.Par1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6Ylz] GHC.Types.False [];

Data.Foldable.$fFoldablePar1_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.Par1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6YlA z_s6YlB ds_s6YlC] f_s6YlA ds_s6YlC z_s6YlB;

Data.Foldable.$fFoldablePar1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.Par1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YlD f_s6YlE ds_s6YlF] f_s6YlE ds_s6YlF;

Data.Foldable.$fFoldableK1_$cfoldMap
  :: forall i c m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.K1 i c a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YlG ds_s6YlH ds1_s6YlI]
        GHC.Base.mempty $dMonoid_s6YlG;

Data.Foldable.$fFoldable:+:_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YlJ $dFoldable1_s6YlK ds_s6YlL]
        case ds_s6YlL of {
          GHC.Generics.L1 a1_s6YlN [Occ=Once] ->
              Data.Foldable.null $dFoldable_s6YlJ a1_s6YlN;
          GHC.Generics.R1 a1_s6YlO [Occ=Once] ->
              Data.Foldable.null $dFoldable1_s6YlK a1_s6YlO;
        };

Data.Foldable.$fFoldable:+:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YlP
           $dFoldable1_s6YlQ
           f1_s6YlR
           z_s6YlS
           ds_s6YlT]
        case ds_s6YlT of {
          GHC.Generics.L1 a1_s6YlV [Occ=Once] ->
              Data.Foldable.foldr $dFoldable_s6YlP f1_s6YlR z_s6YlS a1_s6YlV;
          GHC.Generics.R1 a1_s6YlW [Occ=Once] ->
              Data.Foldable.foldr $dFoldable1_s6YlQ f1_s6YlR z_s6YlS a1_s6YlW;
        };

Data.Foldable.$fFoldable:+:_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:+:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YlX
           $dFoldable1_s6YlY
           $dMonoid_s6YlZ
           f1_s6Ym0
           ds_s6Ym1]
        case ds_s6Ym1 of {
          GHC.Generics.L1 a1_s6Ym3 [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_s6YlX $dMonoid_s6YlZ f1_s6Ym0 a1_s6Ym3;
          GHC.Generics.R1 a1_s6Ym4 [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_s6YlY $dMonoid_s6YlZ f1_s6Ym0 a1_s6Ym4;
        };

Data.Foldable.$fFoldable:*:_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(S)LLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ym5 $dFoldable1_s6Ym6 ds_s6Ym7]
        case ds_s6Ym7 of {
          GHC.Generics.:*: a1_s6Ym9 [Occ=Once] a2_s6Yma [Occ=Once] ->
              case Data.Foldable.null $dFoldable_s6Ym5 a1_s6Ym9 of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> Data.Foldable.null $dFoldable1_s6Ym6 a2_s6Yma;
              };
        };

Data.Foldable.$fFoldable:*:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ymc
           $dFoldable1_s6Ymd
           f1_s6Yme
           z_s6Ymf
           ds_s6Ymg]
        case ds_s6Ymg of {
          GHC.Generics.:*: a1_s6Ymi [Occ=Once] a2_s6Ymj [Occ=Once] ->
              let {
                sat_s6Ymk [Occ=Once] :: b_a6L8t
                [LclId] =
                    [$dFoldable1_s6Ymd f1_s6Yme z_s6Ymf a2_s6Ymj] \u []
                        Data.Foldable.foldr $dFoldable1_s6Ymd f1_s6Yme z_s6Ymf a2_s6Ymj;
              } in 
                Data.Foldable.foldr $dFoldable_s6Ymc f1_s6Yme sat_s6Ymk a1_s6Ymi;
        };

Data.Foldable.$w$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> f a -> g a -> m
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Yml w1_s6Ymm w2_s6Ymn w3_s6Ymo ww_s6Ymp ww1_s6Ymq]
        let {
          sat_s6Yms [Occ=Once] :: m_s6NSd
          [LclId] =
              [w1_s6Ymm w2_s6Ymn w3_s6Ymo ww1_s6Ymq] \u []
                  Data.Foldable.foldMap w1_s6Ymm w2_s6Ymn w3_s6Ymo ww1_s6Ymq; } in
        let {
          sat_s6Ymr [Occ=Once] :: m_s6NSd
          [LclId] =
              [w_s6Yml w2_s6Ymn w3_s6Ymo ww_s6Ymp] \u []
                  Data.Foldable.foldMap w_s6Yml w2_s6Ymn w3_s6Ymo ww_s6Ymp;
        } in  GHC.Base.mappend w2_s6Ymn sat_s6Ymr sat_s6Yms;

Data.Foldable.$fFoldable:*:_$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:*:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Ymt w1_s6Ymu w2_s6Ymv w3_s6Ymw w4_s6Ymx]
        case w4_s6Ymx of {
          GHC.Generics.:*: ww1_s6Ymz [Occ=Once] ww2_s6YmA [Occ=Once] ->
              Data.Foldable.$w$cfoldMap
                  w_s6Ymt w1_s6Ymu w2_s6Ymv w3_s6Ymw ww1_s6Ymz ww2_s6YmA;
        };

Data.Foldable.$fFoldable:.:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YmB
           $dFoldable1_s6YmC
           f1_s6YmD
           z_s6YmE
           ds_s6YmF]
        let {
          sat_s6YmI [Occ=Once] :: g_a6L4V a_a6L5t -> b_a6L5u -> b_a6L5u
          [LclId] =
              [$dFoldable1_s6YmC f1_s6YmD] \r [b1_s6YmG b2_s6YmH]
                  Data.Foldable.foldr $dFoldable1_s6YmC f1_s6YmD b2_s6YmH b1_s6YmG;
        } in 
          Data.Foldable.foldr $dFoldable_s6YmB sat_s6YmI z_s6YmE ds_s6YmF;

Data.Foldable.$fFoldable:.:_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> (GHC.Generics.:.:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YmJ
           $dFoldable1_s6YmK
           $dMonoid_s6YmL
           f1_s6YmM
           ds_s6YmN]
        let {
          sat_s6YmO [Occ=Once] :: g_a6L4V a_a6L5c -> m_a6L5b
          [LclId] =
              [$dFoldable1_s6YmK $dMonoid_s6YmL f1_s6YmM] \u []
                  Data.Foldable.foldMap $dFoldable1_s6YmK $dMonoid_s6YmL f1_s6YmM;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YmJ $dMonoid_s6YmL sat_s6YmO ds_s6YmN;

Data.Foldable.$fFoldableURec4_$cnull
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6YmP]
        case ds_s6YmP of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec4_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YmS z_s6YmT ds_s6YmU]
        case ds_s6YmU of { GHC.Generics.UAddr _ [Occ=Dead] -> z_s6YmT; };

Data.Foldable.$fFoldableURec4_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YmX f_s6YmY ds_s6YmZ]
        case ds_s6YmZ of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YmX;
        };

Data.Foldable.$fFoldableURec3_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6Yn2]
        case ds_s6Yn2 of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec3_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Char a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Yn5 z_s6Yn6 ds_s6Yn7]
        case ds_s6Yn7 of { GHC.Generics.UChar _ [Occ=Dead] -> z_s6Yn6; };

Data.Foldable.$fFoldableURec3_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Char a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yna f_s6Ynb ds_s6Ync]
        case ds_s6Ync of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Yna;
        };

Data.Foldable.$fFoldableURec2_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6Ynf]
        case ds_s6Ynf of {
          GHC.Generics.UDouble _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec2_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Double a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Yni z_s6Ynj ds_s6Ynk]
        case ds_s6Ynk of { GHC.Generics.UDouble _ [Occ=Dead] -> z_s6Ynj; };

Data.Foldable.$fFoldableURec2_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Double a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ynn f_s6Yno ds_s6Ynp]
        case ds_s6Ynp of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              GHC.Base.mempty $dMonoid_s6Ynn;
        };

Data.Foldable.$fFoldableURec1_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6Yns]
        case ds_s6Yns of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec1_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Float a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Ynv z_s6Ynw ds_s6Ynx]
        case ds_s6Ynx of { GHC.Generics.UFloat _ [Occ=Dead] -> z_s6Ynw; };

Data.Foldable.$fFoldableURec1_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Float a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YnA f_s6YnB ds_s6YnC]
        case ds_s6YnC of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YnA;
        };

Data.Foldable.$fFoldableURec0_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6YnF]
        case ds_s6YnF of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec0_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Int a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YnI z_s6YnJ ds_s6YnK]
        case ds_s6YnK of { GHC.Generics.UInt _ [Occ=Dead] -> z_s6YnJ; };

Data.Foldable.$fFoldableURec0_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Int a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YnN f_s6YnO ds_s6YnP]
        case ds_s6YnP of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YnN;
        };

Data.Foldable.$fFoldableURec_$cnull
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6YnS]
        case ds_s6YnS of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Foldable.$fFoldableURec_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> GHC.Generics.URec GHC.Types.Word a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YnV z_s6YnW ds_s6YnX]
        case ds_s6YnX of { GHC.Generics.UWord _ [Occ=Dead] -> z_s6YnW; };

Data.Foldable.$fFoldableURec_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Generics.URec GHC.Types.Word a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yo0 f_s6Yo1 ds_s6Yo2]
        case ds_s6Yo2 of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Yo0;
        };

Data.Foldable.$fFoldable:*:1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6Yo5] v_s6Yo5;

$dmproduct1_r6OSR
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6Yo6 $dNum_s6Yo7]
        let {
          sat_s6Yo8 [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6KPT)
          [LclId] =
              [$dNum_s6Yo7] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6Yo7;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Yo6 sat_s6Yo8 Data.Foldable.$fFoldable:*:1;

Data.Foldable.$dmproduct
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] $dmproduct1_r6OSR eta_B2 eta_B1;

$dmsum1_r6OSS
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6Yo9 $dNum_s6Yoa]
        let {
          sat_s6Yob [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6KPz)
          [LclId] =
              [$dNum_s6Yoa] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6Yoa;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Yo9 sat_s6Yob Data.Foldable.$fFoldable:*:1;

Data.Foldable.$dmsum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Num.Num a => t a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] $dmsum1_r6OSS eta_B2 eta_B1;

Data.Foldable.$fFoldableK3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

poly_d_r6OST :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK3
        of
        sat_s6Yoc
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6Yoc;
        };

Data.Foldable.$dmminimum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yod $dOrd_s6Yoe]
        let {
          g_s6Yof [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_X6Kii a_a6KOY -> Data.Functor.Utils.Min a_a6KOY
          [LclId] =
              [$dFoldable_s6Yod $dOrd_s6Yoe] \u []
                  let {
                    sat_s6Yog [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6KOY)
                    [LclId] =
                        [$dOrd_s6Yoe] \u [] Data.Functor.Utils.$fMonoidMin $dOrd_s6Yoe;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6Yod sat_s6Yog GHC.Base.Just; } in
        let {
          sat_s6Yok [Occ=OnceT[0]] :: t_X6Kii a_a6KOY -> a_a6KOY
          [LclId] =
              [g_s6Yof] \r [x_s6Yoh]
                  case g_s6Yof x_s6Yoh of {
                    GHC.Base.Nothing -> poly_d_r6OST;
                    GHC.Base.Just v_s6Yoj [Occ=Once] -> v_s6Yoj;
                  };
        } in  sat_s6Yok;

Data.Foldable.$fFoldableK5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

poly_d1_r6OSU :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK5
        of
        sat_s6Yol
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6Yol;
        };

Data.Foldable.$dmmaximum
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Ord a => t a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yom $dOrd_s6Yon]
        let {
          g_s6Yoo [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_X6Kij a_a6KOn -> Data.Functor.Utils.Max a_a6KOn
          [LclId] =
              [$dFoldable_s6Yom $dOrd_s6Yon] \u []
                  let {
                    sat_s6Yop [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6KOn)
                    [LclId] =
                        [$dOrd_s6Yon] \u [] Data.Functor.Utils.$fMonoidMax $dOrd_s6Yon;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6Yom sat_s6Yop GHC.Base.Just; } in
        let {
          sat_s6Yot [Occ=OnceT[0]] :: t_X6Kij a_a6KOn -> a_a6KOn
          [LclId] =
              [g_s6Yoo] \r [x_s6Yoq]
                  case g_s6Yoo x_s6Yoq of {
                    GHC.Base.Nothing -> poly_d1_r6OSU;
                    GHC.Base.Just v_s6Yos [Occ=Once] -> v_s6Yos;
                  };
        } in  sat_s6Yot;

Data.Foldable.$fFoldable:*:5
  :: forall a. GHC.Types.Int -> a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,A>m,
 Unf=OtherCon []] =
    [] \r [c_s6You ds_s6Yov]
        case c_s6You of {
          GHC.Types.I# x_s6Yox [Occ=Once] ->
              case +# [x_s6Yox 1#] of sat_s6Yoy {
                __DEFAULT -> GHC.Types.I# [sat_s6Yoy];
              };
        };

Data.Foldable.$dmlength
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yoz]
        Data.Foldable.foldl'
            $dFoldable_s6Yoz
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4;

lvl_r6OSV :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YoA ds1_s6YoB] GHC.Types.False [];

Data.Foldable.$dmnull
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YoC]
        Data.Foldable.foldr $dFoldable_s6YoC lvl_r6OSV GHC.Types.True;

Data.Foldable.$dmtoList [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. t a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YoD t1_s6YoE]
        Data.Foldable.foldr
            $dFoldable_s6YoD GHC.Types.: GHC.Types.[] t1_s6YoE;

Data.Foldable.$fFoldableK7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Foldable.$fFoldable:*:6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK7
        of
        sat_s6YoF
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6YoF;
        };

Data.Foldable.$dmfoldl1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId,
 Arity=3,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YoG f_s6YoH xs_s6YoI]
        let {
          sat_s6YoO [Occ=Once]
            :: GHC.Base.Maybe a_a6KN3 -> a_a6KN3 -> GHC.Base.Maybe a_a6KN3
          [LclId] =
              [f_s6YoH] \r [m_s6YoJ y_s6YoK]
                  let {
                    sat_s6YoN [Occ=Once] :: a_a6KN3
                    [LclId] =
                        [f_s6YoH m_s6YoJ y_s6YoK] \u []
                            case m_s6YoJ of {
                              GHC.Base.Nothing -> y_s6YoK;
                              GHC.Base.Just x_s6YoM [Occ=Once] -> f_s6YoH x_s6YoM y_s6YoK;
                            };
                  } in  GHC.Base.Just [sat_s6YoN];
        } in 
          case
              Data.Foldable.foldl
                  $dFoldable_s6YoG sat_s6YoO GHC.Base.Nothing xs_s6YoI
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6YoQ [Occ=Once] -> v_s6YoQ;
          };

Data.Foldable.$fFoldableK9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Foldable.$fFoldable:*:8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case
            GHC.CString.unpackCString# Data.Foldable.$fFoldableK9
        of
        sat_s6YoR
        { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6YoR;
        };

Data.Foldable.$dmfoldr1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YoS f_s6YoT xs_s6YoU]
        let {
          sat_s6Yp0 [Occ=Once]
            :: a_a6KMx -> GHC.Base.Maybe a_a6KMx -> GHC.Base.Maybe a_a6KMx
          [LclId] =
              [f_s6YoT] \r [x_s6YoV m_s6YoW]
                  let {
                    sat_s6YoZ [Occ=Once] :: a_a6KMx
                    [LclId] =
                        [f_s6YoT x_s6YoV m_s6YoW] \u []
                            case m_s6YoW of {
                              GHC.Base.Nothing -> x_s6YoV;
                              GHC.Base.Just y_s6YoY [Occ=Once] -> f_s6YoT x_s6YoV y_s6YoY;
                            };
                  } in  GHC.Base.Just [sat_s6YoZ];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6YoS sat_s6Yp0 GHC.Base.Nothing xs_s6YoU
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6Yp2 [Occ=Once] -> v_s6Yp2;
          };

Data.Foldable.$dmfoldl'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yp3 f_s6Yp4 z0_s6Yp5 xs_s6Yp6]
        let {
          sat_s6Ypb [Occ=Once]
            :: a_a6KM0 -> (b_a6KLZ -> b_a6KLZ) -> b_a6KLZ -> b_a6KLZ
          [LclId] =
              [f_s6Yp4] \r [x_s6Yp7 k_s6Yp8 z_s6Yp9]
                  case f_s6Yp4 z_s6Yp9 x_s6Yp7 of vx_s6Ypa {
                    __DEFAULT -> k_s6Yp8 vx_s6Ypa;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6Yp3 sat_s6Ypb GHC.Base.id xs_s6Yp6 z0_s6Yp5;

Data.Foldable.$fFoldable:*:7
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$dmfoldl
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ypc f_s6Ypd z_s6Ype t1_s6Ypf]
        let {
          sat_s6Ypi [Occ=Once]
            :: a_a6KLz
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6KLy)
          [LclId] =
              [f_s6Ypd] \r [x_s6Ypg y_s6Yph] f_s6Ypd y_s6Yph x_s6Ypg;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Ypc
              Data.Foldable.$fFoldable:*:7
              sat_s6Ypi
              t1_s6Ypf
              z_s6Ype;

Data.Foldable.$dmfoldr'
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ypj f_s6Ypk z0_s6Ypl xs_s6Ypm]
        let {
          sat_s6Ypr [Occ=Once]
            :: (b_a6KKX -> b_a6KKX) -> a_a6KKW -> b_a6KKX -> b_a6KKX
          [LclId] =
              [f_s6Ypk] \r [k_s6Ypn x_s6Ypo z_s6Ypp]
                  case f_s6Ypk x_s6Ypo z_s6Ypp of vx_s6Ypq {
                    __DEFAULT -> k_s6Ypn vx_s6Ypq;
                  };
        } in 
          Data.Foldable.foldl
              $dFoldable_s6Ypj sat_s6Ypr GHC.Base.id xs_s6Ypm z0_s6Ypl;

Data.Foldable.$fFoldableU1_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6Yps z0_s6Ypt xs_s6Ypu] z0_s6Ypt;

Data.Foldable.$fFoldableK4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK5;

Data.Foldable.$fFoldableU1_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ypv eta_s6Ypw]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableU1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6Ypx z0_s6Ypy xs_s6Ypz] z0_s6Ypy;

Data.Foldable.$fFoldableK2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK3;

Data.Foldable.$fFoldableU1_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.U1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YpA eta_s6YpB]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableU1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.U1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6YpC] [] [];

Data.Foldable.$fFoldableU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.U1
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableU1_$cfold
                                             Data.Foldable.$fFoldableU1_$cfoldMap
                                             Data.Foldable.$fFoldableU1_$cfoldr
                                             Data.Foldable.$fFoldableU1_$cfoldr'
                                             Data.Foldable.$fFoldableU1_$cfoldl
                                             Data.Foldable.$fFoldableU1_$cfoldl'
                                             Data.Foldable.$fFoldableU1_$cfoldr1
                                             Data.Foldable.$fFoldableU1_$cfoldl1
                                             Data.Foldable.$fFoldableU1_$ctoList
                                             Data.Foldable.$fFoldableU1_$cnull
                                             Data.Foldable.$fFoldableU1_$clength
                                             Data.Foldable.$fFoldableU1_$celem
                                             Data.Foldable.$fFoldableU1_$cmaximum
                                             Data.Foldable.$fFoldableU1_$cminimum
                                             Data.Foldable.$fFoldableU1_$csum
                                             Data.Foldable.$fFoldableU1_$cproduct];

Data.Foldable.$fFoldableProxy_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YpD z0_s6YpE xs_s6YpF] z0_s6YpE;

Data.Foldable.$fFoldableProxy_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YpG eta_s6YpH]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableProxy_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Data.Proxy.Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YpI z0_s6YpJ xs_s6YpK] z0_s6YpJ;

Data.Foldable.$fFoldableProxy_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Proxy.Proxy a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YpL eta_s6YpM]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableProxy_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Proxy.Proxy a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6YpN] [] [];

Data.Foldable.$fFoldableProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Proxy.Proxy
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableProxy_$cfold
                                             Data.Foldable.$fFoldableProxy_$cfoldMap
                                             Data.Foldable.$fFoldableProxy_$cfoldr
                                             Data.Foldable.$fFoldableProxy_$cfoldr'
                                             Data.Foldable.$fFoldableProxy_$cfoldl
                                             Data.Foldable.$fFoldableProxy_$cfoldl'
                                             Data.Foldable.$fFoldableProxy_$cfoldr1
                                             Data.Foldable.$fFoldableProxy_$cfoldl1
                                             Data.Foldable.$fFoldableProxy_$ctoList
                                             Data.Foldable.$fFoldableProxy_$cnull
                                             Data.Foldable.$fFoldableProxy_$clength
                                             Data.Foldable.$fFoldableProxy_$celem
                                             Data.Foldable.$fFoldableProxy_$cmaximum
                                             Data.Foldable.$fFoldableProxy_$cminimum
                                             Data.Foldable.$fFoldableProxy_$csum
                                             Data.Foldable.$fFoldableProxy_$cproduct];

Data.Foldable.$dmfoldr
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YpO f_s6YpP z_s6YpQ t1_s6YpR]
        Data.Foldable.foldMap
            $dFoldable_s6YpO
            Data.Semigroup.Internal.$fMonoidEndo
            f_s6YpP
            t1_s6YpR
            z_s6YpQ;

Data.Foldable.$dmfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*U,C(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YpS $dMonoid_s6YpT f_s6YpU]
        let {
          sat_s6YpY [Occ=Once] :: m_a6KKk
          [LclId] =
              [$dMonoid_s6YpT] \u [] GHC.Base.mempty $dMonoid_s6YpT; } in
        let {
          sat_s6YpX [Occ=Once] :: a_a6KKl -> m_a6KKk -> m_a6KKk
          [LclId] =
              [$dMonoid_s6YpT f_s6YpU] \r [x_s6YpV]
                  let {
                    sat_s6YpW [Occ=Once] :: m_a6KKk
                    [LclId] =
                        [f_s6YpU x_s6YpV] \u [] f_s6YpU x_s6YpV;
                  } in  GHC.Base.mappend $dMonoid_s6YpT sat_s6YpW;
        } in  Data.Foldable.foldr $dFoldable_s6YpS sat_s6YpX sat_s6YpY;

Data.Foldable.$dmfold
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall m. GHC.Base.Monoid m => t m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YpZ $dMonoid_s6Yq0]
        Data.Foldable.foldMap $dFoldable_s6YpZ $dMonoid_s6Yq0 GHC.Base.id;

Data.Foldable.$fFoldableDual7
  :: forall m. GHC.Base.Monoid m => m -> m
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yq1 eta_B1] GHC.Base.id eta_B1;

Data.Foldable.$fFoldableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Product
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableProduct_$cfoldr
                                             Data.Foldable.$fFoldableProduct_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableProduct3
                                             Data.Foldable.$fFoldableProduct3
                                             Data.Foldable.$fFoldableProduct_$ctoList
                                             Data.Foldable.$fFoldableProduct_$cnull
                                             Data.Foldable.$fFoldableProduct_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableProduct2
                                             Data.Foldable.$fFoldableProduct2
                                             Data.Foldable.$fFoldableProduct1
                                             Data.Foldable.$fFoldableProduct1];

Data.Foldable.$fFoldableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Sum
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableSum_$cfoldr
                                             Data.Foldable.$fFoldableSum_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableSum3
                                             Data.Foldable.$fFoldableSum3
                                             Data.Foldable.$fFoldableSum_$ctoList
                                             Data.Foldable.$fFoldableSum_$cnull
                                             Data.Foldable.$fFoldableSum_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableSum2
                                             Data.Foldable.$fFoldableSum2
                                             Data.Foldable.$fFoldableSum1
                                             Data.Foldable.$fFoldableSum1];

Data.Foldable.$fFoldableDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Internal.Dual
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableDual7
                                             Data.Foldable.$fFoldableDual6
                                             Data.Foldable.$fFoldableDual_$cfoldr
                                             Data.Foldable.$fFoldableDual_$cfoldr
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual5
                                             Data.Foldable.$fFoldableDual4
                                             Data.Foldable.$fFoldableDual4
                                             Data.Foldable.$fFoldableDual_$ctoList
                                             Data.Foldable.$fFoldableDual_$cnull
                                             Data.Foldable.$fFoldableDual_$clength
                                             GHC.Classes.==
                                             Data.Foldable.$fFoldableDual2
                                             Data.Foldable.$fFoldableDual2
                                             Data.Foldable.$fFoldableDual1
                                             Data.Foldable.$fFoldableDual1];

Data.Foldable.$fFoldable[]_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6Yq2 z0_s6Yq3 xs_s6Yq4]
        let-no-escape {
          go_s6Yq5 [Occ=LoopBreakerT[3]]
            :: [a_a6LRy] -> (b_a6LRz -> b_a6LRz) -> b_a6LRz -> b_a6LRz
          [LclId[JoinId(3)],
           Arity=3,
           Str=<S,1*U><C(S),1*C1(U)><L,U>,
           Unf=OtherCon []] =
              sat-only [f_s6Yq2 go_s6Yq5] \r [ds_s6Yq6 eta_s6Yq7 eta1_s6Yq8]
                  case ds_s6Yq6 of {
                    [] -> eta_s6Yq7 eta1_s6Yq8;
                    : y_s6Yqa [Occ=Once] ys_s6Yqb [Occ=Once] ->
                        let {
                          sat_s6Yqe [Occ=Once] :: b_a6LRz -> b_a6LRz
                          [LclId] =
                              [f_s6Yq2 eta_s6Yq7 y_s6Yqa] \r [z_s6Yqc]
                                  case f_s6Yq2 y_s6Yqa z_s6Yqc of vx_s6Yqd {
                                    __DEFAULT -> eta_s6Yq7 vx_s6Yqd;
                                  };
                        } in  go_s6Yq5 ys_s6Yqb sat_s6Yqe eta1_s6Yq8;
                  };
        } in  go_s6Yq5 xs_s6Yq4 GHC.Base.id z0_s6Yq3;

Data.Foldable.$fFoldable[]_$cfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> [a] -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yqf f_s6Yqg eta_s6Yqh]
        let {
          z_s6Yqi [Occ=OnceL] :: m_a6LRe
          [LclId] =
              [$dMonoid_s6Yqf] \u [] GHC.Base.mempty $dMonoid_s6Yqf; } in
        let {
          go_s6Yqj [Occ=LoopBreaker] :: [a_a6LRf] -> m_a6LRe
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_s6Yqf f_s6Yqg z_s6Yqi go_s6Yqj] \r [ds_s6Yqk]
                  case ds_s6Yqk of {
                    [] -> z_s6Yqi;
                    : y_s6Yqm [Occ=Once] ys_s6Yqn [Occ=Once] ->
                        let {
                          sat_s6Yqp [Occ=Once] :: m_a6LRe
                          [LclId] =
                              [go_s6Yqj ys_s6Yqn] \u [] go_s6Yqj ys_s6Yqn; } in
                        let {
                          sat_s6Yqo [Occ=Once] :: m_a6LRe
                          [LclId] =
                              [f_s6Yqg y_s6Yqm] \u [] f_s6Yqg y_s6Yqm;
                        } in  GHC.Base.mappend $dMonoid_s6Yqf sat_s6Yqo sat_s6Yqp;
                  };
        } in  go_s6Yqj eta_s6Yqh;

Data.Foldable.$fFoldableNonEmpty_$cfold1
  :: forall m. GHC.Base.Monoid m => [m] -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yqq eta_s6Yqr]
        let {
          z_s6Yqs [Occ=OnceL] :: m_a6LR4
          [LclId] =
              [$dMonoid_s6Yqq] \u [] GHC.Base.mempty $dMonoid_s6Yqq; } in
        let {
          go_s6Yqt [Occ=LoopBreaker] :: [m_a6LR4] -> m_a6LR4
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_s6Yqq z_s6Yqs go_s6Yqt] \r [ds_s6Yqu]
                  case ds_s6Yqu of {
                    [] -> z_s6Yqs;
                    : y_s6Yqw [Occ=Once] ys_s6Yqx [Occ=Once] ->
                        let {
                          sat_s6Yqy [Occ=Once] :: m_a6LR4
                          [LclId] =
                              [go_s6Yqt ys_s6Yqx] \u [] go_s6Yqt ys_s6Yqx;
                        } in  GHC.Base.mappend $dMonoid_s6Yqq y_s6Yqw sat_s6Yqy;
                  };
        } in  go_s6Yqt eta_s6Yqr;

Data.Foldable.$fFoldable[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable []
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold1
                                             Data.Foldable.$fFoldable[]_$cfoldMap
                                             GHC.Base.foldr
                                             Data.Foldable.$fFoldable[]_$cfoldr'
                                             GHC.List.foldl
                                             GHC.List.foldl'
                                             GHC.List.foldr1
                                             GHC.List.foldl1
                                             GHC.Base.id
                                             GHC.List.null
                                             GHC.List.length
                                             GHC.List.elem
                                             GHC.List.maximum
                                             GHC.List.minimum
                                             GHC.List.sum
                                             GHC.List.product];

Data.Foldable.$fFoldableNonEmpty_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Base.NonEmpty m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),U(A,U,C(C1(U)),A)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yqz ds_s6YqA]
        let {
          sat_s6YqI [Occ=Once] :: m_a6LOt
          [LclId] =
              [$dMonoid_s6Yqz ds_s6YqA] \u []
                  case ds_s6YqA of {
                    GHC.Base.:| _ [Occ=Dead] ms_s6YqH [Occ=Once] ->
                        Data.Foldable.$fFoldableNonEmpty_$cfold1 $dMonoid_s6Yqz ms_s6YqH;
                  }; } in
        let {
          sat_s6YqE [Occ=Once] :: m_a6LOt
          [LclId] =
              [ds_s6YqA] \u []
                  case ds_s6YqA of {
                    GHC.Base.:| m1_s6YqC [Occ=Once] _ [Occ=Dead] -> m1_s6YqC;
                  };
        } in  GHC.Base.mappend $dMonoid_s6Yqz sat_s6YqE sat_s6YqI;

Data.Foldable.$fFoldableNonEmpty_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Base.NonEmpty a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),U(A,1*U,C(C1(U)),A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YqJ f_s6YqK ds_s6YqL]
        let {
          sat_s6Yr2 [Occ=Once] :: m_a6LOG
          [LclId] =
              [$dMonoid_s6YqJ f_s6YqK ds_s6YqL] \u []
                  case ds_s6YqL of {
                    GHC.Base.:| _ [Occ=Dead] as_s6YqT [Occ=Once] ->
                        let {
                          z_s6YqU [Occ=OnceL] :: m_a6LOG
                          [LclId] =
                              [$dMonoid_s6YqJ] \u [] GHC.Base.mempty $dMonoid_s6YqJ; } in
                        let {
                          go_s6YqV [Occ=LoopBreaker] :: [a_a6LOH] -> m_a6LOG
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dMonoid_s6YqJ f_s6YqK z_s6YqU go_s6YqV] \r [ds1_s6YqW]
                                  case ds1_s6YqW of {
                                    [] -> z_s6YqU;
                                    : y_s6YqY [Occ=Once] ys_s6YqZ [Occ=Once] ->
                                        let {
                                          sat_s6Yr1 [Occ=Once] :: m_a6LOG
                                          [LclId] =
                                              [go_s6YqV ys_s6YqZ] \u [] go_s6YqV ys_s6YqZ; } in
                                        let {
                                          sat_s6Yr0 [Occ=Once] :: m_a6LOG
                                          [LclId] =
                                              [f_s6YqK y_s6YqY] \u [] f_s6YqK y_s6YqY;
                                        } in  GHC.Base.mappend $dMonoid_s6YqJ sat_s6Yr0 sat_s6Yr1;
                                  };
                        } in  go_s6YqV as_s6YqT;
                  }; } in
        let {
          sat_s6YqQ [Occ=Once] :: m_a6LOG
          [LclId] =
              [f_s6YqK ds_s6YqL] \u []
                  let {
                    sat_s6YqP [Occ=Once] :: a_a6LOH
                    [LclId] =
                        [ds_s6YqL] \u []
                            case ds_s6YqL of {
                              GHC.Base.:| a1_s6YqN [Occ=Once] _ [Occ=Dead] -> a1_s6YqN;
                            };
                  } in  f_s6YqK sat_s6YqP;
        } in  GHC.Base.mappend $dMonoid_s6YqJ sat_s6YqQ sat_s6Yr2;

Data.Foldable.foldrM
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (a -> b -> m b) -> b -> t a -> m b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yr3 $dMonad_s6Yr4 f_s6Yr5 z0_s6Yr6 xs_s6Yr7]
        let {
          sat_s6Yrd [Occ=Once] :: b_a6KJt -> m_a6KJr b_a6KJt
          [LclId] =
              [$dMonad_s6Yr4] \u [] GHC.Base.return $dMonad_s6Yr4; } in
        let {
          sat_s6Yrc [Occ=Once]
            :: (b_a6KJt -> m_a6KJr b_a6KJt)
               -> a_a6KJs -> b_a6KJt -> m_a6KJr b_a6KJt
          [LclId] =
              [$dMonad_s6Yr4 f_s6Yr5] \r [k_s6Yr8 x_s6Yr9 z_s6Yra]
                  let {
                    sat_s6Yrb [Occ=Once] :: m_a6KJr b_a6KJt
                    [LclId] =
                        [f_s6Yr5 x_s6Yr9 z_s6Yra] \u [] f_s6Yr5 x_s6Yr9 z_s6Yra;
                  } in  GHC.Base.>>= $dMonad_s6Yr4 sat_s6Yrb k_s6Yr8;
        } in 
          Data.Foldable.foldl
              $dFoldable_s6Yr3 sat_s6Yrc sat_s6Yrd xs_s6Yr7 z0_s6Yr6;

Data.Foldable.foldlM
  :: forall (t :: * -> *) (m :: * -> *) b a.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (b -> a -> m b) -> b -> t a -> m b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yre $dMonad_s6Yrf f_s6Yrg z0_s6Yrh xs_s6Yri]
        let {
          sat_s6Yro [Occ=Once] :: b_a6KHt -> m_a6KHs b_a6KHt
          [LclId] =
              [$dMonad_s6Yrf] \u [] GHC.Base.return $dMonad_s6Yrf; } in
        let {
          sat_s6Yrn [Occ=Once]
            :: a_a6KHu
               -> (b_a6KHt -> m_a6KHs b_a6KHt) -> b_a6KHt -> m_a6KHs b_a6KHt
          [LclId] =
              [$dMonad_s6Yrf f_s6Yrg] \r [x_s6Yrj k_s6Yrk z_s6Yrl]
                  let {
                    sat_s6Yrm [Occ=Once] :: m_a6KHs b_a6KHt
                    [LclId] =
                        [f_s6Yrg x_s6Yrj z_s6Yrl] \u [] f_s6Yrg z_s6Yrl x_s6Yrj;
                  } in  GHC.Base.>>= $dMonad_s6Yrf sat_s6Yrm k_s6Yrk;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6Yre sat_s6Yrn sat_s6Yro xs_s6Yri z0_s6Yrh;

Data.Foldable.traverse_
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     (a -> f b) -> t a -> f ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yrp $dApplicative_s6Yrq f1_s6Yrr]
        let {
          sat_s6Yrv [Occ=Once] :: f_a6KGP ()
          [LclId] =
              [$dApplicative_s6Yrq] \u []
                  GHC.Base.pure $dApplicative_s6Yrq GHC.Tuple.(); } in
        let {
          sat_s6Yru [Occ=Once] :: a_a6KGQ -> f_a6KGP () -> f_a6KGP ()
          [LclId] =
              [$dApplicative_s6Yrq f1_s6Yrr] \r [x_s6Yrs]
                  let {
                    sat_s6Yrt [Occ=Once] :: f_a6KGP b_a6KGR
                    [LclId] =
                        [f1_s6Yrr x_s6Yrs] \u [] f1_s6Yrr x_s6Yrs;
                  } in  GHC.Base.*> $dApplicative_s6Yrq sat_s6Yrt;
        } in  Data.Foldable.foldr $dFoldable_s6Yrp sat_s6Yru sat_s6Yrv;

Data.Foldable.for_ [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     t a -> (a -> f b) -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yrw $dApplicative_s6Yrx x_s6Yry y_s6Yrz]
        Data.Foldable.traverse_
            $dFoldable_s6Yrw $dApplicative_s6Yrx y_s6Yrz x_s6Yry;

Data.Foldable.mapM_
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     (a -> m b) -> t a -> m ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(U),1*C1(U),A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrA $dMonad_s6YrB f_s6YrC]
        let {
          sat_s6YrG [Occ=Once] :: m_a6KG8 ()
          [LclId] =
              [$dMonad_s6YrB] \u []
                  GHC.Base.return $dMonad_s6YrB GHC.Tuple.(); } in
        let {
          sat_s6YrF [Occ=Once] :: a_a6KG9 -> m_a6KG8 () -> m_a6KG8 ()
          [LclId] =
              [$dMonad_s6YrB f_s6YrC] \r [x_s6YrD]
                  let {
                    sat_s6YrE [Occ=Once] :: m_a6KG8 b_a6KGa
                    [LclId] =
                        [f_s6YrC x_s6YrD] \u [] f_s6YrC x_s6YrD;
                  } in  GHC.Base.>> $dMonad_s6YrB sat_s6YrE;
        } in  Data.Foldable.foldr $dFoldable_s6YrA sat_s6YrF sat_s6YrG;

Data.Foldable.forM_ [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     t a -> (a -> m b) -> m ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(U),C(U),A)><L,U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrH $dMonad_s6YrI x_s6YrJ y_s6YrK]
        Data.Foldable.mapM_ $dFoldable_s6YrH $dMonad_s6YrI y_s6YrK x_s6YrJ;

Data.Foldable.sequenceA_
  :: forall (t :: * -> *) (f :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Applicative f) =>
     t (f a) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(U),A,A,1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrL $dApplicative_s6YrM]
        let {
          sat_s6YrO [Occ=Once] :: f_a6KFQ ()
          [LclId] =
              [$dApplicative_s6YrM] \u []
                  GHC.Base.pure $dApplicative_s6YrM GHC.Tuple.(); } in
        let {
          sat_s6YrN [Occ=Once] :: f_a6KFQ a_a6KFR -> f_a6KFQ () -> f_a6KFQ ()
          [LclId] =
              [$dApplicative_s6YrM] \u [] GHC.Base.*> $dApplicative_s6YrM;
        } in  Data.Foldable.foldr $dFoldable_s6YrL sat_s6YrN sat_s6YrO;

Data.Foldable.sequence_
  :: forall (t :: * -> *) (m :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Monad m) =>
     t (m a) -> m ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,1*U,1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrP $dMonad_s6YrQ]
        let {
          sat_s6YrS [Occ=Once] :: m_a6KFy ()
          [LclId] =
              [$dMonad_s6YrQ] \u []
                  GHC.Base.return $dMonad_s6YrQ GHC.Tuple.(); } in
        let {
          sat_s6YrR [Occ=Once] :: m_a6KFy a_a6KFz -> m_a6KFy () -> m_a6KFy ()
          [LclId] =
              [$dMonad_s6YrQ] \u [] GHC.Base.>> $dMonad_s6YrQ;
        } in  Data.Foldable.foldr $dFoldable_s6YrP sat_s6YrR sat_s6YrS;

Data.Foldable.asum [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.Alternative f) =>
     t (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrT $dAlternative_s6YrU]
        let {
          sat_s6YrW [Occ=Once] :: f_a6KF3 a_a6KF4
          [LclId] =
              [$dAlternative_s6YrU] \u []
                  GHC.Base.empty $dAlternative_s6YrU; } in
        let {
          sat_s6YrV [Occ=Once]
            :: f_a6KF3 a_a6KF4 -> f_a6KF3 a_a6KF4 -> f_a6KF3 a_a6KF4
          [LclId] =
              [$dAlternative_s6YrU] \u [] GHC.Base.<|> $dAlternative_s6YrU;
        } in  Data.Foldable.foldr $dFoldable_s6YrT sat_s6YrV sat_s6YrW;

Data.Foldable.msum [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Base.MonadPlus m) =>
     t (m a) -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*U(A,1*U,1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YrX $dMonadPlus_s6YrY]
        let {
          $dAlternative_s6YrZ [Dmd=<L,U(A,1*U,1*U,A,A)>]
            :: GHC.Base.Alternative m_a6KFm
          [LclId] =
              [$dMonadPlus_s6YrY] \u []
                  GHC.Base.$p1MonadPlus $dMonadPlus_s6YrY; } in
        let {
          sat_s6Ys1 [Occ=Once] :: m_a6KFm a_a6KFn
          [LclId] =
              [$dAlternative_s6YrZ] \u []
                  GHC.Base.empty $dAlternative_s6YrZ; } in
        let {
          sat_s6Ys0 [Occ=Once]
            :: m_a6KFm a_a6KFn -> m_a6KFm a_a6KFn -> m_a6KFm a_a6KFn
          [LclId] =
              [$dAlternative_s6YrZ] \u [] GHC.Base.<|> $dAlternative_s6YrZ;
        } in  Data.Foldable.foldr $dFoldable_s6YrX sat_s6Ys0 sat_s6Ys1;

Data.Foldable.concat [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *) a. Data.Foldable.Foldable t => t [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ys2 xs_s6Ys3]
        Data.Foldable.foldr
            $dFoldable_s6Ys2 GHC.Base.++ GHC.Types.[] xs_s6Ys3;

Data.Foldable.concatMap [InlPrag=INLINE (sat-args=2)]
  :: forall (t :: * -> *) a b.
     Data.Foldable.Foldable t =>
     (a -> [b]) -> t a -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ys4 f_s6Ys5 xs_s6Ys6]
        let {
          sat_s6Ysa [Occ=Once] :: a_a6KEs -> [b_a6KEt] -> [b_a6KEt]
          [LclId] =
              [f_s6Ys5] \r [x_s6Ys7 b1_s6Ys8]
                  case f_s6Ys5 x_s6Ys7 of sat_s6Ys9 {
                    __DEFAULT -> GHC.Base.++ sat_s6Ys9 b1_s6Ys8;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6Ys4 sat_s6Ysa GHC.Types.[] xs_s6Ys6;

Data.Foldable.and2 :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6Ysb] v_s6Ysb;

Data.Foldable.and1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ysc]
        Data.Foldable.foldMap
            $dFoldable_s6Ysc
            Data.Semigroup.Internal.$fMonoidAll
            Data.Foldable.and2;

Data.Foldable.and
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Foldable.and1 eta_B1;

Data.Foldable.or1
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ysd]
        Data.Foldable.foldMap
            $dFoldable_s6Ysd
            Data.Semigroup.Internal.$fMonoidAny
            Data.Foldable.and2;

Data.Foldable.or
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     t GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Foldable.or1 eta_B1;

Data.Foldable.any1
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yse p_s6Ysf]
        Data.Foldable.foldMap
            $dFoldable_s6Yse Data.Semigroup.Internal.$fMonoidAny p_s6Ysf;

Data.Foldable.any
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Foldable.any1 eta_B2 eta_B1;

$dmelem1_r6OSW
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a.
     GHC.Classes.Eq a =>
     a -> t a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dFoldable_s6Ysg $dEq_s6Ysh eta_s6Ysi]
        let {
          sat_s6Ysj [Occ=Once] :: a_a6KO9 -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_s6Ysh eta_s6Ysi] \u [] GHC.Classes.== $dEq_s6Ysh eta_s6Ysi;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6Ysg Data.Semigroup.Internal.$fMonoidAny sat_s6Ysj;

Data.Foldable.$dmelem
  :: forall (t :: * -> *).
     Data.Foldable.Foldable t =>
     forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $dmelem1_r6OSW eta_B3 eta_B2 eta_B1;

Data.Foldable.$fFoldableURec11
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Word a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Ysk eta_s6Ysl eta1_s6Ysm]
        case eta1_s6Ysm of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec8
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Word a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ysp ds_s6Ysq]
        case ds_s6Ysq of {
          GHC.Generics.UWord _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Ysp;
        };

Data.Foldable.$fFoldable:*:2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableURec9
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yst] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ysu eta_s6Ysv]
        Data.Foldable.$fFoldableURec9 eta_s6Ysv;

Data.Foldable.$fFoldable:*:3 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableURec10
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Ysw] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Ysx eta_s6Ysy]
        Data.Foldable.$fFoldableURec10 eta_s6Ysy;

Data.Foldable.$fFoldableURec_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Ysz xs_s6YsA] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Word a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YsB z0_s6YsC xs_s6YsD]
        case xs_s6YsD of { GHC.Generics.UWord _ [Occ=Dead] -> z0_s6YsC; };

Data.Foldable.$fFoldableURec_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6YsG]
        case xs_s6YsG of {
          GHC.Generics.UWord _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Word a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YsJ xs_s6YsK] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Word m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YsL ds_s6YsM]
        case ds_s6YsM of {
          GHC.Generics.UWord _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YsL;
        };

Data.Foldable.$fFoldableURec7
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Word a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YsP ds_s6YsQ]
        case ds_s6YsQ of {
          GHC.Generics.UWord _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YsP;
        };

Data.Foldable.$fFoldableURec_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Word a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6YsT]
        case eta_s6YsT of { GHC.Generics.UWord _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Word)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec_$cfold
                                             Data.Foldable.$fFoldableURec_$cfoldMap
                                             Data.Foldable.$fFoldableURec_$cfoldr
                                             Data.Foldable.$fFoldableURec_$cfoldr
                                             Data.Foldable.$fFoldableURec_$cfoldl'
                                             Data.Foldable.$fFoldableURec_$cfoldl'
                                             Data.Foldable.$fFoldableURec_$cfoldr1
                                             Data.Foldable.$fFoldableURec_$cfoldl1
                                             Data.Foldable.$fFoldableURec_$ctoList
                                             Data.Foldable.$fFoldableURec_$cnull
                                             Data.Foldable.$fFoldableURec_$clength
                                             Data.Foldable.$fFoldableURec11
                                             Data.Foldable.$fFoldableURec_$cmaximum
                                             Data.Foldable.$fFoldableURec_$cminimum
                                             Data.Foldable.$fFoldableURec8
                                             Data.Foldable.$fFoldableURec7];

Data.Foldable.$fFoldableURec16
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Int a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YsW eta_s6YsX eta1_s6YsY]
        case eta1_s6YsY of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec13
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Int a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yt1 ds_s6Yt2]
        case ds_s6Yt2 of {
          GHC.Generics.UInt _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Yt1;
        };

Data.Foldable.$fFoldableURec14
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yt5] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec0_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yt6 eta_s6Yt7]
        Data.Foldable.$fFoldableURec14 eta_s6Yt7;

Data.Foldable.$fFoldableURec15
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yt8] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec0_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yt9 eta_s6Yta]
        Data.Foldable.$fFoldableURec15 eta_s6Yta;

Data.Foldable.$fFoldableURec0_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Ytb xs_s6Ytc] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec0_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Int a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Ytd z0_s6Yte xs_s6Ytf]
        case xs_s6Ytf of { GHC.Generics.UInt _ [Occ=Dead] -> z0_s6Yte; };

Data.Foldable.$fFoldableURec0_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6Yti]
        case xs_s6Yti of {
          GHC.Generics.UInt _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec0_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Int a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Ytl xs_s6Ytm] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec0_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Int m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Ytn ds_s6Yto]
        case ds_s6Yto of {
          GHC.Generics.UInt _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Ytn;
        };

Data.Foldable.$fFoldableURec12
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Int a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Ytr ds_s6Yts]
        case ds_s6Yts of {
          GHC.Generics.UInt _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Ytr;
        };

Data.Foldable.$fFoldableURec0_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Int a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6Ytv]
        case eta_s6Ytv of { GHC.Generics.UInt _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec0 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Int)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec0_$cfold
                                             Data.Foldable.$fFoldableURec0_$cfoldMap
                                             Data.Foldable.$fFoldableURec0_$cfoldr
                                             Data.Foldable.$fFoldableURec0_$cfoldr
                                             Data.Foldable.$fFoldableURec0_$cfoldl'
                                             Data.Foldable.$fFoldableURec0_$cfoldl'
                                             Data.Foldable.$fFoldableURec0_$cfoldr1
                                             Data.Foldable.$fFoldableURec0_$cfoldl1
                                             Data.Foldable.$fFoldableURec0_$ctoList
                                             Data.Foldable.$fFoldableURec0_$cnull
                                             Data.Foldable.$fFoldableURec0_$clength
                                             Data.Foldable.$fFoldableURec16
                                             Data.Foldable.$fFoldableURec0_$cmaximum
                                             Data.Foldable.$fFoldableURec0_$cminimum
                                             Data.Foldable.$fFoldableURec13
                                             Data.Foldable.$fFoldableURec12];

Data.Foldable.$fFoldableURec21
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Yty eta_s6Ytz eta1_s6YtA]
        case eta1_s6YtA of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec18
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YtD ds_s6YtE]
        case ds_s6YtE of {
          GHC.Generics.UFloat _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YtD;
        };

Data.Foldable.$fFoldableURec19
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6YtH] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec1_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YtI eta_s6YtJ]
        Data.Foldable.$fFoldableURec19 eta_s6YtJ;

Data.Foldable.$fFoldableURec20
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6YtK] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec1_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YtL eta_s6YtM]
        Data.Foldable.$fFoldableURec20 eta_s6YtM;

Data.Foldable.$fFoldableURec1_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YtN xs_s6YtO] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec1_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Float a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YtP z0_s6YtQ xs_s6YtR]
        case xs_s6YtR of { GHC.Generics.UFloat _ [Occ=Dead] -> z0_s6YtQ; };

Data.Foldable.$fFoldableURec1_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6YtU]
        case xs_s6YtU of {
          GHC.Generics.UFloat _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec1_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Float a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YtX xs_s6YtY] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec1_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Float m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YtZ ds_s6Yu0]
        case ds_s6Yu0 of {
          GHC.Generics.UFloat _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YtZ;
        };

Data.Foldable.$fFoldableURec17
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Float a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yu3 ds_s6Yu4]
        case ds_s6Yu4 of {
          GHC.Generics.UFloat _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Yu3;
        };

Data.Foldable.$fFoldableURec1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Float a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6Yu7]
        case eta_s6Yu7 of { GHC.Generics.UFloat _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Float)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec1_$cfold
                                             Data.Foldable.$fFoldableURec1_$cfoldMap
                                             Data.Foldable.$fFoldableURec1_$cfoldr
                                             Data.Foldable.$fFoldableURec1_$cfoldr
                                             Data.Foldable.$fFoldableURec1_$cfoldl'
                                             Data.Foldable.$fFoldableURec1_$cfoldl'
                                             Data.Foldable.$fFoldableURec1_$cfoldr1
                                             Data.Foldable.$fFoldableURec1_$cfoldl1
                                             Data.Foldable.$fFoldableURec1_$ctoList
                                             Data.Foldable.$fFoldableURec1_$cnull
                                             Data.Foldable.$fFoldableURec1_$clength
                                             Data.Foldable.$fFoldableURec21
                                             Data.Foldable.$fFoldableURec1_$cmaximum
                                             Data.Foldable.$fFoldableURec1_$cminimum
                                             Data.Foldable.$fFoldableURec18
                                             Data.Foldable.$fFoldableURec17];

Data.Foldable.$fFoldableURec26
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Yua eta_s6Yub eta1_s6Yuc]
        case eta1_s6Yuc of {
          GHC.Generics.UDouble _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec23
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yuf ds_s6Yug]
        case ds_s6Yug of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Yuf;
        };

Data.Foldable.$fFoldableURec24
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yuj] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec2_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yuk eta_s6Yul]
        Data.Foldable.$fFoldableURec24 eta_s6Yul;

Data.Foldable.$fFoldableURec25
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yum] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec2_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yun eta_s6Yuo]
        Data.Foldable.$fFoldableURec25 eta_s6Yuo;

Data.Foldable.$fFoldableURec2_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Yup xs_s6Yuq] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec2_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Double a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Yur z0_s6Yus xs_s6Yut]
        case xs_s6Yut of {
          GHC.Generics.UDouble _ [Occ=Dead] -> z0_s6Yus;
        };

Data.Foldable.$fFoldableURec2_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6Yuw]
        case xs_s6Yuw of {
          GHC.Generics.UDouble _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec2_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Double a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Yuz xs_s6YuA] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec2_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Double m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YuB ds_s6YuC]
        case ds_s6YuC of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              GHC.Base.mempty $dMonoid_s6YuB;
        };

Data.Foldable.$fFoldableURec22
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Double a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YuF ds_s6YuG]
        case ds_s6YuG of {
          GHC.Generics.UDouble _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YuF;
        };

Data.Foldable.$fFoldableURec2_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Double a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6YuJ]
        case eta_s6YuJ of { GHC.Generics.UDouble _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec2 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Double)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec2_$cfold
                                             Data.Foldable.$fFoldableURec2_$cfoldMap
                                             Data.Foldable.$fFoldableURec2_$cfoldr
                                             Data.Foldable.$fFoldableURec2_$cfoldr
                                             Data.Foldable.$fFoldableURec2_$cfoldl'
                                             Data.Foldable.$fFoldableURec2_$cfoldl'
                                             Data.Foldable.$fFoldableURec2_$cfoldr1
                                             Data.Foldable.$fFoldableURec2_$cfoldl1
                                             Data.Foldable.$fFoldableURec2_$ctoList
                                             Data.Foldable.$fFoldableURec2_$cnull
                                             Data.Foldable.$fFoldableURec2_$clength
                                             Data.Foldable.$fFoldableURec26
                                             Data.Foldable.$fFoldableURec2_$cmaximum
                                             Data.Foldable.$fFoldableURec2_$cminimum
                                             Data.Foldable.$fFoldableURec23
                                             Data.Foldable.$fFoldableURec22];

Data.Foldable.$fFoldableURec31
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec GHC.Types.Char a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YuM eta_s6YuN eta1_s6YuO]
        case eta1_s6YuO of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec28
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Char a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YuR ds_s6YuS]
        case ds_s6YuS of {
          GHC.Generics.UChar _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YuR;
        };

Data.Foldable.$fFoldableURec29
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6YuV] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec3_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YuW eta_s6YuX]
        Data.Foldable.$fFoldableURec29 eta_s6YuX;

Data.Foldable.$fFoldableURec30
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6YuY] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec3_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YuZ eta_s6Yv0]
        Data.Foldable.$fFoldableURec30 eta_s6Yv0;

Data.Foldable.$fFoldableURec3_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Yv1 xs_s6Yv2] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec3_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec GHC.Types.Char a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6Yv3 z0_s6Yv4 xs_s6Yv5]
        case xs_s6Yv5 of { GHC.Generics.UChar _ [Occ=Dead] -> z0_s6Yv4; };

Data.Foldable.$fFoldableURec3_$clength
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6Yv8]
        case xs_s6Yv8 of {
          GHC.Generics.UChar _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec3_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec GHC.Types.Char a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6Yvb xs_s6Yvc] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec3_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec GHC.Types.Char m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6Yvd ds_s6Yve]
        case ds_s6Yve of {
          GHC.Generics.UChar _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6Yvd;
        };

Data.Foldable.$fFoldableURec27
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec GHC.Types.Char a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yvh ds_s6Yvi]
        case ds_s6Yvi of {
          GHC.Generics.UChar _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6Yvh;
        };

Data.Foldable.$fFoldableURec3_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec GHC.Types.Char a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6Yvl]
        case eta_s6Yvl of { GHC.Generics.UChar _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec3 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Char)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec3_$cfold
                                             Data.Foldable.$fFoldableURec3_$cfoldMap
                                             Data.Foldable.$fFoldableURec3_$cfoldr
                                             Data.Foldable.$fFoldableURec3_$cfoldr
                                             Data.Foldable.$fFoldableURec3_$cfoldl'
                                             Data.Foldable.$fFoldableURec3_$cfoldl'
                                             Data.Foldable.$fFoldableURec3_$cfoldr1
                                             Data.Foldable.$fFoldableURec3_$cfoldl1
                                             Data.Foldable.$fFoldableURec3_$ctoList
                                             Data.Foldable.$fFoldableURec3_$cnull
                                             Data.Foldable.$fFoldableURec3_$clength
                                             Data.Foldable.$fFoldableURec31
                                             Data.Foldable.$fFoldableURec3_$cmaximum
                                             Data.Foldable.$fFoldableURec3_$cminimum
                                             Data.Foldable.$fFoldableURec28
                                             Data.Foldable.$fFoldableURec27];

Data.Foldable.$fFoldableURec36
  :: forall a.
     GHC.Classes.Eq a =>
     a
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6Yvo eta_s6Yvp eta1_s6Yvq]
        case eta1_s6Yvq of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableURec33
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6Yvt ds_s6Yvu]
        case ds_s6Yvu of {
          GHC.Generics.UAddr _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6Yvt;
        };

Data.Foldable.$fFoldableURec34
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6Yvx] Data.Foldable.$fFoldable:*:2;

Data.Foldable.$fFoldableURec4_$cminimum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6Yvy eta_s6Yvz]
        Data.Foldable.$fFoldableURec34 eta_s6Yvz;

Data.Foldable.$fFoldableURec35
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [x_s6YvA] Data.Foldable.$fFoldable:*:3;

Data.Foldable.$fFoldableURec4_$cmaximum
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YvB eta_s6YvC]
        Data.Foldable.$fFoldableURec35 eta_s6YvC;

Data.Foldable.$fFoldableURec4_$cfoldr1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YvD xs_s6YvE] Data.Foldable.$fFoldable:*:8;

Data.Foldable.$fFoldableURec4_$cfoldl'
  :: forall b a.
     (b -> a -> b) -> b -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [f_s6YvF z0_s6YvG xs_s6YvH]
        case xs_s6YvH of { GHC.Generics.UAddr _ [Occ=Dead] -> z0_s6YvG; };

Data.Foldable.$fFoldableURec4_$clength
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6YvK]
        case xs_s6YvK of {
          GHC.Generics.UAddr _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$fFoldableURec4_$cfoldl1
  :: forall a.
     (a -> a -> a) -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YvN xs_s6YvO] Data.Foldable.$fFoldable:*:6;

Data.Foldable.$fFoldableURec4_$cfold
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YvP ds_s6YvQ]
        case ds_s6YvQ of {
          GHC.Generics.UAddr _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YvP;
        };

Data.Foldable.$fFoldableURec32
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YvT ds_s6YvU]
        case ds_s6YvU of {
          GHC.Generics.UAddr _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YvT;
        };

Data.Foldable.$fFoldableURec4_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.URec (GHC.Ptr.Ptr ()) a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [eta_s6YvX]
        case eta_s6YvX of { GHC.Generics.UAddr _ [Occ=Dead] -> [] []; };

Data.Foldable.$fFoldableURec4 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable (GHC.Generics.URec (GHC.Ptr.Ptr ()))
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableURec4_$cfold
                                             Data.Foldable.$fFoldableURec4_$cfoldMap
                                             Data.Foldable.$fFoldableURec4_$cfoldr
                                             Data.Foldable.$fFoldableURec4_$cfoldr
                                             Data.Foldable.$fFoldableURec4_$cfoldl'
                                             Data.Foldable.$fFoldableURec4_$cfoldl'
                                             Data.Foldable.$fFoldableURec4_$cfoldr1
                                             Data.Foldable.$fFoldableURec4_$cfoldl1
                                             Data.Foldable.$fFoldableURec4_$ctoList
                                             Data.Foldable.$fFoldableURec4_$cnull
                                             Data.Foldable.$fFoldableURec4_$clength
                                             Data.Foldable.$fFoldableURec36
                                             Data.Foldable.$fFoldableURec4_$cmaximum
                                             Data.Foldable.$fFoldableURec4_$cminimum
                                             Data.Foldable.$fFoldableURec33
                                             Data.Foldable.$fFoldableURec32];

Data.Foldable.$fFoldable:*:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:*:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yw0 $dFoldable1_s6Yw1 $dEq_s6Yw2 eta_s6Yw3]
        let {
          f1_s6Yw4 :: a_a6Lad -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Yw2 eta_s6Yw3] \u []
                  GHC.Classes.== $dEq_s6Yw2 eta_s6Yw3; } in
        let {
          sat_s6Ywa [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lad
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6Yw0 $dFoldable1_s6Yw1 f1_s6Yw4] \r [ds_s6Yw5]
                  case ds_s6Yw5 of {
                    GHC.Generics.:*: a1_s6Yw7 [Occ=Once] a2_s6Yw8 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6Yw0
                                Data.Semigroup.Internal.$fMonoidAny
                                f1_s6Yw4
                                a1_s6Yw7
                        of
                        { GHC.Types.False ->
                              Data.Foldable.foldMap
                                  $dFoldable1_s6Yw1
                                  Data.Semigroup.Internal.$fMonoidAny
                                  f1_s6Yw4
                                  a2_s6Yw8;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_s6Ywa;

Data.Foldable.$fFoldable:*:_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ywb $dFoldable1_s6Ywc $dNum_s6Ywd]
        let {
          $dMonoid_s6Ywe
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LaH)
          [LclId] =
              [$dNum_s6Ywd] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6Ywd; } in
        let {
          sat_s6Ywl [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6LaH
               -> Data.Semigroup.Internal.Sum a_a6LaH
          [LclId] =
              [$dFoldable_s6Ywb
               $dFoldable1_s6Ywc
               $dNum_s6Ywd
               $dMonoid_s6Ywe] \r [ds_s6Ywf]
                  case ds_s6Ywf of {
                    GHC.Generics.:*: a1_s6Ywh [Occ=Once] a2_s6Ywi [Occ=Once] ->
                        let {
                          sat_s6Ywk [Occ=Once] :: a_a6LaH
                          [LclId] =
                              [$dFoldable1_s6Ywc $dMonoid_s6Ywe a2_s6Ywi] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_s6Ywc
                                      $dMonoid_s6Ywe
                                      Data.Foldable.$fFoldable:*:1
                                      a2_s6Ywi; } in
                        let {
                          sat_s6Ywj [Occ=Once] :: a_a6LaH
                          [LclId] =
                              [$dFoldable_s6Ywb $dMonoid_s6Ywe a1_s6Ywh] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Ywb
                                      $dMonoid_s6Ywe
                                      Data.Foldable.$fFoldable:*:1
                                      a1_s6Ywh;
                        } in  GHC.Num.+ $dNum_s6Ywd sat_s6Ywj sat_s6Ywk;
                  };
        } in  sat_s6Ywl;

Data.Foldable.$fFoldable:*:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Ywm $dFoldable1_s6Ywn $dOrd_s6Ywo]
        let {
          $dMonoid_s6Ywp :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6Lax)
          [LclId] =
              [$dOrd_s6Ywo] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6Ywo; } in
        let {
          sat_s6YwB [Occ=OnceT[0]]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lax -> a_a6Lax
          [LclId] =
              [$dFoldable_s6Ywm
               $dFoldable1_s6Ywn
               $dOrd_s6Ywo
               $dMonoid_s6Ywp] \r [x_s6Ywq]
                  case x_s6Ywq of {
                    GHC.Generics.:*: a1_s6Yws [Occ=Once*] a2_s6Ywt [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6Ywn $dMonoid_s6Ywp GHC.Base.Just a2_s6Ywt
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Ywm $dMonoid_s6Ywp GHC.Base.Just a1_s6Yws
                              of
                              { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                                GHC.Base.Just v_s6Yww [Occ=Once] -> v_s6Yww;
                              };
                          GHC.Base.Just ipv_s6Ywx ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6Ywm $dMonoid_s6Ywp GHC.Base.Just a1_s6Yws
                              of
                              { GHC.Base.Nothing -> ipv_s6Ywx;
                                GHC.Base.Just x1_s6Ywz ->
                                    case GHC.Classes.<= $dOrd_s6Ywo x1_s6Ywz ipv_s6Ywx of {
                                      GHC.Types.False -> ipv_s6Ywx;
                                      GHC.Types.True -> x1_s6Ywz;
                                    };
                              };
                        };
                  };
        } in  sat_s6YwB;

Data.Foldable.$fFoldable:*:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YwC $dFoldable1_s6YwD $dOrd_s6YwE]
        let {
          $dMonoid_s6YwF :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lan)
          [LclId] =
              [$dOrd_s6YwE] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6YwE; } in
        let {
          sat_s6YwR [Occ=OnceT[0]]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6Lan -> a_a6Lan
          [LclId] =
              [$dFoldable_s6YwC
               $dFoldable1_s6YwD
               $dOrd_s6YwE
               $dMonoid_s6YwF] \r [x_s6YwG]
                  case x_s6YwG of {
                    GHC.Generics.:*: a1_s6YwI [Occ=Once*] a2_s6YwJ [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6YwD $dMonoid_s6YwF GHC.Base.Just a2_s6YwJ
                        of
                        { GHC.Base.Nothing ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6YwC $dMonoid_s6YwF GHC.Base.Just a1_s6YwI
                              of
                              { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                                GHC.Base.Just v_s6YwM [Occ=Once] -> v_s6YwM;
                              };
                          GHC.Base.Just ipv_s6YwN ->
                              case
                                  Data.Foldable.foldMap
                                      $dFoldable_s6YwC $dMonoid_s6YwF GHC.Base.Just a1_s6YwI
                              of
                              { GHC.Base.Nothing -> ipv_s6YwN;
                                GHC.Base.Just x1_s6YwP ->
                                    case GHC.Classes.>= $dOrd_s6YwE x1_s6YwP ipv_s6YwN of {
                                      GHC.Types.False -> ipv_s6YwN;
                                      GHC.Types.True -> x1_s6YwP;
                                    };
                              };
                        };
                  };
        } in  sat_s6YwR;

Data.Foldable.$w$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6YwS w1_s6YwT w2_s6YwU ww_s6YwV ww1_s6YwW]
        let {
          f1_s6YwX
            :: a_s6NTG -> GHC.Base.Maybe a_s6NTG -> GHC.Base.Maybe a_s6NTG
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_s6YwU] \r [x_s6YwY m_s6YwZ]
                  let {
                    sat_s6Yx2 [Occ=Once] :: a_s6NTG
                    [LclId] =
                        [w2_s6YwU x_s6YwY m_s6YwZ] \u []
                            case m_s6YwZ of {
                              GHC.Base.Nothing -> x_s6YwY;
                              GHC.Base.Just y_s6Yx1 [Occ=Once] -> w2_s6YwU x_s6YwY y_s6Yx1;
                            };
                  } in  GHC.Base.Just [sat_s6Yx2]; } in
        let {
          sat_s6Yx3 [Occ=Once] :: GHC.Base.Maybe a_s6NTG
          [LclId] =
              [w1_s6YwT ww1_s6YwW f1_s6YwX] \u []
                  Data.Foldable.foldr w1_s6YwT f1_s6YwX GHC.Base.Nothing ww1_s6YwW;
        } in 
          case Data.Foldable.foldr w_s6YwS f1_s6YwX sat_s6Yx3 ww_s6YwV of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6Yx5 [Occ=Once] -> v_s6Yx5;
          };

Data.Foldable.$fFoldable:*:_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Yx6 w1_s6Yx7 w2_s6Yx8 w3_s6Yx9]
        case w3_s6Yx9 of {
          GHC.Generics.:*: ww1_s6Yxb [Occ=Once] ww2_s6Yxc [Occ=Once] ->
              Data.Foldable.$w$cfoldr1
                  w_s6Yx6 w1_s6Yx7 w2_s6Yx8 ww1_s6Yxb ww2_s6Yxc;
        };

Data.Foldable.$w$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Yxd w1_s6Yxe w2_s6Yxf w3_s6Yxg ww_s6Yxh ww1_s6Yxi]
        let {
          f1_s6Yxj :: a_s6NTU -> (b_s6NTT -> b_s6NTT) -> b_s6NTT -> b_s6NTT
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_s6Yxf] \r [x_s6Yxk k_s6Yxl z_s6Yxm]
                  case w2_s6Yxf z_s6Yxm x_s6Yxk of vx_s6Yxn {
                    __DEFAULT -> k_s6Yxl vx_s6Yxn;
                  }; } in
        let {
          sat_s6Yxo [Occ=Once] :: b_s6NTT -> b_s6NTT
          [LclId] =
              [w1_s6Yxe ww1_s6Yxi f1_s6Yxj] \u []
                  Data.Foldable.foldr w1_s6Yxe f1_s6Yxj GHC.Base.id ww1_s6Yxi;
        } in 
          Data.Foldable.foldr w_s6Yxd f1_s6Yxj sat_s6Yxo ww_s6Yxh w3_s6Yxg;

Data.Foldable.$fFoldable:*:_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Yxp w1_s6Yxq w2_s6Yxr w3_s6Yxs w4_s6Yxt]
        case w4_s6Yxt of {
          GHC.Generics.:*: ww1_s6Yxv [Occ=Once] ww2_s6Yxw [Occ=Once] ->
              Data.Foldable.$w$cfoldl'
                  w_s6Yxp w1_s6Yxq w2_s6Yxr w3_s6Yxs ww1_s6Yxv ww2_s6Yxw;
        };

Data.Foldable.$fFoldableM2
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s6Yxx k_s6Yxy z_s6Yxz]
        case z_s6Yxz of {
          GHC.Types.I# x1_s6YxB [Occ=Once] ->
              case +# [x1_s6YxB 1#] of sat_s6YxC {
                __DEFAULT ->
                    let {
                      sat_s6YxD [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_s6YxC];
                    } in  k_s6Yxy sat_s6YxD;
              };
        };

Data.Foldable.$fFoldable:*:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YxE $dFoldable1_s6YxF eta_s6YxG]
        case eta_s6YxG of {
          GHC.Generics.:*: ww1_s6YxI [Occ=Once] ww2_s6YxJ [Occ=Once] ->
              let {
                sat_s6YxK [Occ=Once] :: GHC.Types.Int -> GHC.Types.Int
                [LclId] =
                    [$dFoldable1_s6YxF ww2_s6YxJ] \u []
                        Data.Foldable.foldr
                            $dFoldable1_s6YxF Data.Foldable.$fFoldableM2 GHC.Base.id ww2_s6YxJ;
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6YxE
                    Data.Foldable.$fFoldableM2
                    sat_s6YxK
                    ww1_s6YxI
                    Data.Foldable.$fFoldable:*:4;
        };

Data.Foldable.$w$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6YxL w1_s6YxM w2_s6YxN w3_s6YxO ww_s6YxP ww1_s6YxQ]
        let {
          f1_s6YxR :: a_s6NU9 -> b_s6NU8 -> b_s6NU8
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w2_s6YxN] \r [x_s6YxS y_s6YxT] w2_s6YxN y_s6YxT x_s6YxS; } in
        let {
          sat_s6YxU [Occ=Once] :: b_s6NU8
          [LclId] =
              [w_s6YxL w3_s6YxO ww_s6YxP f1_s6YxR] \u []
                  Data.Foldable.foldMap
                      w_s6YxL Data.Foldable.$fFoldable:*:7 f1_s6YxR ww_s6YxP w3_s6YxO;
        } in 
          Data.Foldable.foldMap
              w1_s6YxM Data.Foldable.$fFoldable:*:7 f1_s6YxR ww1_s6YxQ sat_s6YxU;

Data.Foldable.$fFoldable:*:_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YxV w1_s6YxW w2_s6YxX w3_s6YxY w4_s6YxZ]
        case w4_s6YxZ of {
          GHC.Generics.:*: ww1_s6Yy1 [Occ=Once] ww2_s6Yy2 [Occ=Once] ->
              Data.Foldable.$w$cfoldl
                  w_s6YxV w1_s6YxW w2_s6YxX w3_s6YxY ww1_s6Yy1 ww2_s6Yy2;
        };

Data.Foldable.$w$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Yy3 w1_s6Yy4 w2_s6Yy5 ww_s6Yy6 ww1_s6Yy7]
        let {
          f1_s6Yy8
            :: a_s6NUn -> GHC.Base.Maybe a_s6NUn -> GHC.Base.Maybe a_s6NUn
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [w2_s6Yy5] \r [x_s6Yy9 y_s6Yya]
                  let {
                    sat_s6Yyd [Occ=Once] :: a_s6NUn
                    [LclId] =
                        [w2_s6Yy5 x_s6Yy9 y_s6Yya] \u []
                            case y_s6Yya of {
                              GHC.Base.Nothing -> x_s6Yy9;
                              GHC.Base.Just x1_s6Yyc [Occ=Once] -> w2_s6Yy5 x1_s6Yyc x_s6Yy9;
                            };
                  } in  GHC.Base.Just [sat_s6Yyd]; } in
        let {
          sat_s6Yye [Occ=Once] :: GHC.Base.Maybe a_s6NUn
          [LclId] =
              [w_s6Yy3 ww_s6Yy6 f1_s6Yy8] \u []
                  Data.Foldable.foldMap
                      w_s6Yy3
                      Data.Foldable.$fFoldable:*:7
                      f1_s6Yy8
                      ww_s6Yy6
                      GHC.Base.Nothing;
        } in 
          case
              Data.Foldable.foldMap
                  w1_s6Yy4 Data.Foldable.$fFoldable:*:7 f1_s6Yy8 ww1_s6Yy7 sat_s6Yye
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6Yyg [Occ=Once] -> v_s6Yyg;
          };

Data.Foldable.$fFoldable:*:_$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6Yyh w1_s6Yyi w2_s6Yyj w3_s6Yyk]
        case w3_s6Yyk of {
          GHC.Generics.:*: ww1_s6Yym [Occ=Once] ww2_s6Yyn [Occ=Once] ->
              Data.Foldable.$w$cfoldl1
                  w_s6Yyh w1_s6Yyi w2_s6Yyj ww1_s6Yym ww2_s6Yyn;
        };

Data.Foldable.$w$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6Yyo w1_s6Yyp w2_s6Yyq w3_s6Yyr ww_s6Yys ww1_s6Yyt]
        let {
          f1_s6Yyu :: a_s6NUA -> (b_s6NUB -> b_s6NUB) -> b_s6NUB -> b_s6NUB
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [w2_s6Yyq] \r [x_s6Yyv y_s6Yyw z_s6Yyx]
                  case w2_s6Yyq x_s6Yyv z_s6Yyx of vx_s6Yyy {
                    __DEFAULT -> y_s6Yyw vx_s6Yyy;
                  }; } in
        let {
          sat_s6Yyz [Occ=Once] :: b_s6NUB -> b_s6NUB
          [LclId] =
              [w_s6Yyo ww_s6Yys f1_s6Yyu] \u []
                  Data.Foldable.foldMap
                      w_s6Yyo Data.Foldable.$fFoldable:*:7 f1_s6Yyu ww_s6Yys GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              w1_s6Yyp
              Data.Foldable.$fFoldable:*:7
              f1_s6Yyu
              ww1_s6Yyt
              sat_s6Yyz
              w3_s6Yyr;

Data.Foldable.$fFoldable:*:_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:*:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YyA w1_s6YyB w2_s6YyC w3_s6YyD w4_s6YyE]
        case w4_s6YyE of {
          GHC.Generics.:*: ww1_s6YyG [Occ=Once] ww2_s6YyH [Occ=Once] ->
              Data.Foldable.$w$cfoldr'
                  w_s6YyA w1_s6YyB w2_s6YyC w3_s6YyD ww1_s6YyG ww2_s6YyH;
        };

Data.Foldable.$fFoldable:*:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:*:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YyI $dFoldable1_s6YyJ $dMonoid_s6YyK w_s6YyL]
        case w_s6YyL of {
          GHC.Generics.:*: ww1_s6YyN [Occ=Once] ww2_s6YyO [Occ=Once] ->
              Data.Foldable.$w$cfoldMap
                  $dFoldable_s6YyI
                  $dFoldable1_s6YyJ
                  $dMonoid_s6YyK
                  GHC.Base.id
                  ww1_s6YyN
                  ww2_s6YyO;
        };

Data.Foldable.$fFoldable:*:_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YyP $dFoldable1_s6YyQ $dNum_s6YyR]
        let {
          $dMonoid_s6YyS
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LaR)
          [LclId] =
              [$dNum_s6YyR] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6YyR; } in
        let {
          sat_s6YyZ [Occ=Once]
            :: (GHC.Generics.:*:) f_a6L7R g_a6L7S a_a6LaR
               -> Data.Semigroup.Internal.Product a_a6LaR
          [LclId] =
              [$dFoldable_s6YyP
               $dFoldable1_s6YyQ
               $dNum_s6YyR
               $dMonoid_s6YyS] \r [ds_s6YyT]
                  case ds_s6YyT of {
                    GHC.Generics.:*: a1_s6YyV [Occ=Once] a2_s6YyW [Occ=Once] ->
                        let {
                          sat_s6YyY [Occ=Once] :: a_a6LaR
                          [LclId] =
                              [$dFoldable1_s6YyQ $dMonoid_s6YyS a2_s6YyW] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable1_s6YyQ
                                      $dMonoid_s6YyS
                                      Data.Foldable.$fFoldable:*:1
                                      a2_s6YyW; } in
                        let {
                          sat_s6YyX [Occ=Once] :: a_a6LaR
                          [LclId] =
                              [$dFoldable_s6YyP $dMonoid_s6YyS a1_s6YyV] \u []
                                  Data.Foldable.foldMap
                                      $dFoldable_s6YyP
                                      $dMonoid_s6YyS
                                      Data.Foldable.$fFoldable:*:1
                                      a1_s6YyV;
                        } in  GHC.Num.* $dNum_s6YyR sat_s6YyX sat_s6YyY;
                  };
        } in  sat_s6YyZ;

Data.Foldable.$fFoldable:*:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:*:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yz0 $dFoldable1_s6Yz1 eta_s6Yz2]
        case eta_s6Yz2 of {
          GHC.Generics.:*: a1_s6Yz4 [Occ=Once] a2_s6Yz5 [Occ=Once] ->
              let {
                sat_s6Yz6 [Occ=Once] :: [a_a6L9L]
                [LclId] =
                    [$dFoldable1_s6Yz1 a2_s6Yz5] \u []
                        Data.Foldable.foldr
                            $dFoldable1_s6Yz1 GHC.Types.: GHC.Types.[] a2_s6Yz5;
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6Yz0 GHC.Types.: sat_s6Yz6 a1_s6Yz4;
        };

Data.Foldable.$fFoldable:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6Yz7 $dFoldable1_s6Yz8]
        let {
          sat_s6Yzo [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cproduct
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzn [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$csum
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzm [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cminimum
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzl [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cmaximum
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzk [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$celem
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B2 eta_B1; } in
        let {
          sat_s6Yzj [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$clength
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzi [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$cnull
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzh [Occ=Once]
            :: forall a. (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> [a]
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B1]
                  Data.Foldable.$fFoldable:*:_$ctoList
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B1; } in
        let {
          sat_s6Yzg [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl1
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B2 eta_B1; } in
        let {
          sat_s6Yzf [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> a
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr1
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B2 eta_B1; } in
        let {
          sat_s6Yze [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl'
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Yzd [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldl
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Yzc [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr'
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Yzb [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> b
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldr
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Yza [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:*:) f_a6L7R g_a6L7S a -> m
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfoldMap
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6Yz9 [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:*:) f_a6L7R g_a6L7S m -> m
          [LclId] =
              [$dFoldable_s6Yz7 $dFoldable1_s6Yz8] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:*:_$cfold
                      $dFoldable_s6Yz7 $dFoldable1_s6Yz8 eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6Yz9
                                    sat_s6Yza
                                    sat_s6Yzb
                                    sat_s6Yzc
                                    sat_s6Yzd
                                    sat_s6Yze
                                    sat_s6Yzf
                                    sat_s6Yzg
                                    sat_s6Yzh
                                    sat_s6Yzi
                                    sat_s6Yzj
                                    sat_s6Yzk
                                    sat_s6Yzl
                                    sat_s6Yzm
                                    sat_s6Yzn
                                    sat_s6Yzo];

Data.Foldable.$fFoldable:+:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:+:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yzp $dFoldable1_s6Yzq $dEq_s6Yzr eta_s6Yzs]
        let {
          f1_s6Yzt [Occ=OnceL*] :: a_a6Ldk -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Yzr eta_s6Yzs] \u []
                  GHC.Classes.== $dEq_s6Yzr eta_s6Yzs; } in
        let {
          sat_s6Yzy [Occ=Once]
            :: (GHC.Generics.:+:) f_X6LpN g_X6LpP a_a6Ldk
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6Yzp $dFoldable1_s6Yzq f1_s6Yzt] \r [ds_s6Yzu]
                  case ds_s6Yzu of {
                    GHC.Generics.L1 a1_s6Yzw [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6Yzp
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_s6Yzt
                            a1_s6Yzw;
                    GHC.Generics.R1 a1_s6Yzx [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6Yzq
                            Data.Semigroup.Internal.$fMonoidAny
                            f1_s6Yzt
                            a1_s6Yzx;
                  };
        } in  sat_s6Yzy;

Data.Foldable.$fFoldable:+:2
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     (GHC.Generics.:+:) f g a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6Yzz $dFoldable1_s6YzA $dNum_s6YzB]
        let {
          $dMonoid_s6YzC [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LdO)
          [LclId] =
              [$dNum_s6YzB] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6YzB; } in
        let {
          sat_s6YzH [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpF g_X6LpH a_a6LdO
               -> Data.Semigroup.Internal.Sum a_a6LdO
          [LclId] =
              [$dFoldable_s6Yzz $dFoldable1_s6YzA $dMonoid_s6YzC] \r [ds_s6YzD]
                  case ds_s6YzD of {
                    GHC.Generics.L1 a1_s6YzF [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6Yzz
                            $dMonoid_s6YzC
                            Data.Foldable.$fFoldable:*:1
                            a1_s6YzF;
                    GHC.Generics.R1 a1_s6YzG [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6YzA
                            $dMonoid_s6YzC
                            Data.Foldable.$fFoldable:*:1
                            a1_s6YzG;
                  };
        } in  sat_s6YzH;

Data.Foldable.$fFoldable:+:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YzI $dFoldable1_s6YzJ $dOrd_s6YzK]
        let {
          g1_s6YzL [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6LdE)
          [LclId] =
              [$dOrd_s6YzK] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6YzK; } in
        let {
          sat_s6YzU [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpE g_X6LpG a_a6LdE -> a_a6LdE
          [LclId] =
              [$dFoldable_s6YzI $dFoldable1_s6YzJ g1_s6YzL] \r [x_s6YzM]
                  case x_s6YzM of {
                    GHC.Generics.L1 a1_s6YzO [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6YzI g1_s6YzL GHC.Base.Just a1_s6YzO
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                          GHC.Base.Just v_s6YzQ [Occ=Once] -> v_s6YzQ;
                        };
                    GHC.Generics.R1 a1_s6YzR [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6YzJ g1_s6YzL GHC.Base.Just a1_s6YzR
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                          GHC.Base.Just v_s6YzT [Occ=Once] -> v_s6YzT;
                        };
                  };
        } in  sat_s6YzU;

Data.Foldable.$fFoldable:+:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YzV $dFoldable1_s6YzW $dOrd_s6YzX]
        let {
          g1_s6YzY [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Ldu)
          [LclId] =
              [$dOrd_s6YzX] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6YzX; } in
        let {
          sat_s6YA7 [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_X6LpD g_X6LpF a_a6Ldu -> a_a6Ldu
          [LclId] =
              [$dFoldable_s6YzV $dFoldable1_s6YzW g1_s6YzY] \r [x_s6YzZ]
                  case x_s6YzZ of {
                    GHC.Generics.L1 a1_s6YA1 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable_s6YzV g1_s6YzY GHC.Base.Just a1_s6YA1
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                          GHC.Base.Just v_s6YA3 [Occ=Once] -> v_s6YA3;
                        };
                    GHC.Generics.R1 a1_s6YA4 [Occ=Once] ->
                        case
                            Data.Foldable.foldMap
                                $dFoldable1_s6YzW g1_s6YzY GHC.Base.Just a1_s6YA4
                        of
                        { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                          GHC.Base.Just v_s6YA6 [Occ=Once] -> v_s6YA6;
                        };
                  };
        } in  sat_s6YA7;

Data.Foldable.$fFoldable:+:_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YA8 $dFoldable1_s6YA9 f1_s6YAa xs_s6YAb]
        case xs_s6YAb of {
          GHC.Generics.L1 a1_s6YAd [Occ=Once] ->
              let {
                sat_s6YAj [Occ=Once]
                  :: a_a6LcC -> GHC.Base.Maybe a_a6LcC -> GHC.Base.Maybe a_a6LcC
                [LclId] =
                    [f1_s6YAa] \r [x_s6YAe m_s6YAf]
                        let {
                          sat_s6YAi [Occ=Once] :: a_a6LcC
                          [LclId] =
                              [f1_s6YAa x_s6YAe m_s6YAf] \u []
                                  case m_s6YAf of {
                                    GHC.Base.Nothing -> x_s6YAe;
                                    GHC.Base.Just y_s6YAh [Occ=Once] -> f1_s6YAa x_s6YAe y_s6YAh;
                                  };
                        } in  GHC.Base.Just [sat_s6YAi];
              } in 
                case
                    Data.Foldable.foldr
                        $dFoldable_s6YA8 sat_s6YAj GHC.Base.Nothing a1_s6YAd
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
                  GHC.Base.Just v_s6YAl [Occ=Once] -> v_s6YAl;
                };
          GHC.Generics.R1 a1_s6YAm [Occ=Once] ->
              let {
                sat_s6YAs [Occ=Once]
                  :: a_a6LcC -> GHC.Base.Maybe a_a6LcC -> GHC.Base.Maybe a_a6LcC
                [LclId] =
                    [f1_s6YAa] \r [x_s6YAn m_s6YAo]
                        let {
                          sat_s6YAr [Occ=Once] :: a_a6LcC
                          [LclId] =
                              [f1_s6YAa x_s6YAn m_s6YAo] \u []
                                  case m_s6YAo of {
                                    GHC.Base.Nothing -> x_s6YAn;
                                    GHC.Base.Just y_s6YAq [Occ=Once] -> f1_s6YAa x_s6YAn y_s6YAq;
                                  };
                        } in  GHC.Base.Just [sat_s6YAr];
              } in 
                case
                    Data.Foldable.foldr
                        $dFoldable1_s6YA9 sat_s6YAs GHC.Base.Nothing a1_s6YAm
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
                  GHC.Base.Just v_s6YAu [Occ=Once] -> v_s6YAu;
                };
        };

Data.Foldable.$fFoldable:+:_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YAv
           $dFoldable1_s6YAw
           f1_s6YAx
           z0_s6YAy
           xs_s6YAz]
        case xs_s6YAz of {
          GHC.Generics.L1 a1_s6YAB [Occ=Once] ->
              let {
                sat_s6YAG [Occ=Once]
                  :: a_a6Lct -> (b_a6Lcs -> b_a6Lcs) -> b_a6Lcs -> b_a6Lcs
                [LclId] =
                    [f1_s6YAx] \r [x_s6YAC k_s6YAD z_s6YAE]
                        case f1_s6YAx z_s6YAE x_s6YAC of vx_s6YAF {
                          __DEFAULT -> k_s6YAD vx_s6YAF;
                        };
              } in 
                Data.Foldable.foldr
                    $dFoldable_s6YAv sat_s6YAG GHC.Base.id a1_s6YAB z0_s6YAy;
          GHC.Generics.R1 a1_s6YAH [Occ=Once] ->
              let {
                sat_s6YAM [Occ=Once]
                  :: a_a6Lct -> (b_a6Lcs -> b_a6Lcs) -> b_a6Lcs -> b_a6Lcs
                [LclId] =
                    [f1_s6YAx] \r [x_s6YAI k_s6YAJ z_s6YAK]
                        case f1_s6YAx z_s6YAK x_s6YAI of vx_s6YAL {
                          __DEFAULT -> k_s6YAJ vx_s6YAL;
                        };
              } in 
                Data.Foldable.foldr
                    $dFoldable1_s6YAw sat_s6YAM GHC.Base.id a1_s6YAH z0_s6YAy;
        };

Data.Foldable.$fFoldable:+:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YAN $dFoldable1_s6YAO eta_s6YAP]
        Data.Foldable.$fFoldable:+:_$cfoldl'
            $dFoldable_s6YAN
            $dFoldable1_s6YAO
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4
            eta_s6YAP;

Data.Foldable.$fFoldable:+:_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YAQ $dFoldable1_s6YAR f1_s6YAS z_s6YAT t_s6YAU]
        let {
          f2_s6YAV [Occ=Once*] :: a_a6Lcj -> b_a6Lci -> b_a6Lci
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [f1_s6YAS] \r [x_s6YAW y_s6YAX] f1_s6YAS y_s6YAX x_s6YAW;
        } in 
          case t_s6YAU of {
            GHC.Generics.L1 a1_s6YAZ [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable_s6YAQ
                    Data.Foldable.$fFoldable:*:7
                    f2_s6YAV
                    a1_s6YAZ
                    z_s6YAT;
            GHC.Generics.R1 a1_s6YB0 [Occ=Once] ->
                Data.Foldable.foldMap
                    $dFoldable1_s6YAR
                    Data.Foldable.$fFoldable:*:7
                    f2_s6YAV
                    a1_s6YB0
                    z_s6YAT;
          };

Data.Foldable.$fFoldable:+:_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:+:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YB1 $dFoldable1_s6YB2 f1_s6YB3 xs_s6YB4]
        case xs_s6YB4 of {
          GHC.Generics.L1 a1_s6YB6 [Occ=Once] ->
              let {
                sat_s6YBc [Occ=Once]
                  :: a_a6LcK
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LcK))
                [LclId] =
                    [f1_s6YB3] \r [x_s6YB7 y_s6YB8]
                        let {
                          sat_s6YBb [Occ=Once] :: a_a6LcK
                          [LclId] =
                              [f1_s6YB3 x_s6YB7 y_s6YB8] \u []
                                  case y_s6YB8 of {
                                    GHC.Base.Nothing -> x_s6YB7;
                                    GHC.Base.Just x1_s6YBa [Occ=Once] -> f1_s6YB3 x1_s6YBa x_s6YB7;
                                  };
                        } in  GHC.Base.Just [sat_s6YBb];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable_s6YB1
                        Data.Foldable.$fFoldable:*:7
                        sat_s6YBc
                        a1_s6YB6
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
                  GHC.Base.Just v_s6YBe [Occ=Once] -> v_s6YBe;
                };
          GHC.Generics.R1 a1_s6YBf [Occ=Once] ->
              let {
                sat_s6YBl [Occ=Once]
                  :: a_a6LcK
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LcK))
                [LclId] =
                    [f1_s6YB3] \r [x_s6YBg y_s6YBh]
                        let {
                          sat_s6YBk [Occ=Once] :: a_a6LcK
                          [LclId] =
                              [f1_s6YB3 x_s6YBg y_s6YBh] \u []
                                  case y_s6YBh of {
                                    GHC.Base.Nothing -> x_s6YBg;
                                    GHC.Base.Just x1_s6YBj [Occ=Once] -> f1_s6YB3 x1_s6YBj x_s6YBg;
                                  };
                        } in  GHC.Base.Just [sat_s6YBk];
              } in 
                case
                    Data.Foldable.foldMap
                        $dFoldable1_s6YB2
                        Data.Foldable.$fFoldable:*:7
                        sat_s6YBl
                        a1_s6YBf
                        GHC.Base.Nothing
                of
                { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
                  GHC.Base.Just v_s6YBn [Occ=Once] -> v_s6YBn;
                };
        };

Data.Foldable.$fFoldable:+:_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:+:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YBo
           $dFoldable1_s6YBp
           f1_s6YBq
           z0_s6YBr
           xs_s6YBs]
        case xs_s6YBs of {
          GHC.Generics.L1 a1_s6YBu [Occ=Once] ->
              let {
                sat_s6YBz [Occ=Once]
                  :: a_a6Lc8
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_a6Lc9 -> b_a6Lc9))
                [LclId] =
                    [f1_s6YBq] \r [x_s6YBv y_s6YBw z_s6YBx]
                        case f1_s6YBq x_s6YBv z_s6YBx of vx_s6YBy {
                          __DEFAULT -> y_s6YBw vx_s6YBy;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable_s6YBo
                    Data.Foldable.$fFoldable:*:7
                    sat_s6YBz
                    a1_s6YBu
                    GHC.Base.id
                    z0_s6YBr;
          GHC.Generics.R1 a1_s6YBA [Occ=Once] ->
              let {
                sat_s6YBF [Occ=Once]
                  :: a_a6Lc8
                     -> Data.Semigroup.Internal.Dual
                          (Data.Semigroup.Internal.Endo (b_a6Lc9 -> b_a6Lc9))
                [LclId] =
                    [f1_s6YBq] \r [x_s6YBB y_s6YBC z_s6YBD]
                        case f1_s6YBq x_s6YBB z_s6YBD of vx_s6YBE {
                          __DEFAULT -> y_s6YBC vx_s6YBE;
                        };
              } in 
                Data.Foldable.foldMap
                    $dFoldable1_s6YBp
                    Data.Foldable.$fFoldable:*:7
                    sat_s6YBF
                    a1_s6YBA
                    GHC.Base.id
                    z0_s6YBr;
        };

Data.Foldable.$fFoldable:+:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:+:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YBG $dFoldable1_s6YBH $dMonoid_s6YBI ds_s6YBJ]
        case ds_s6YBJ of {
          GHC.Generics.L1 a1_s6YBL [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable_s6YBG $dMonoid_s6YBI GHC.Base.id a1_s6YBL;
          GHC.Generics.R1 a1_s6YBM [Occ=Once] ->
              Data.Foldable.foldMap
                  $dFoldable1_s6YBH $dMonoid_s6YBI GHC.Base.id a1_s6YBM;
        };

Data.Foldable.$fFoldable:+:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Num.Num a =>
     (GHC.Generics.:+:) f g a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YBN $dFoldable1_s6YBO $dNum_s6YBP]
        let {
          $dMonoid_s6YBQ [Occ=OnceL*]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LdY)
          [LclId] =
              [$dNum_s6YBP] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6YBP; } in
        let {
          sat_s6YBV [Occ=OnceT[0]]
            :: (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a_a6LdY
               -> Data.Semigroup.Internal.Product a_a6LdY
          [LclId] =
              [$dFoldable_s6YBN $dFoldable1_s6YBO $dMonoid_s6YBQ] \r [ds_s6YBR]
                  case ds_s6YBR of {
                    GHC.Generics.L1 a1_s6YBT [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable_s6YBN
                            $dMonoid_s6YBQ
                            Data.Foldable.$fFoldable:*:1
                            a1_s6YBT;
                    GHC.Generics.R1 a1_s6YBU [Occ=Once] ->
                        Data.Foldable.foldMap
                            $dFoldable1_s6YBO
                            $dMonoid_s6YBQ
                            Data.Foldable.$fFoldable:*:1
                            a1_s6YBU;
                  };
        } in  sat_s6YBV;

Data.Foldable.$fFoldable:+:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:+:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YBW $dFoldable1_s6YBX eta_s6YBY]
        case eta_s6YBY of {
          GHC.Generics.L1 a1_s6YC0 [Occ=Once] ->
              Data.Foldable.foldr
                  $dFoldable_s6YBW GHC.Types.: GHC.Types.[] a1_s6YC0;
          GHC.Generics.R1 a1_s6YC1 [Occ=Once] ->
              Data.Foldable.foldr
                  $dFoldable1_s6YBX GHC.Types.: GHC.Types.[] a1_s6YC1;
        };

Data.Foldable.$fFoldable:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6YC2 $dFoldable1_s6YC3]
        let {
          sat_s6YCj [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:1
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCi [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:2
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCh [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cminimum
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCg [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cmaximum
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCf [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$celem
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B2 eta_B1; } in
        let {
          sat_s6YCe [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$clength
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCd [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$cnull
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCc [Occ=Once]
            :: forall a. (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> [a]
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B1]
                  Data.Foldable.$fFoldable:+:_$ctoList
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B1; } in
        let {
          sat_s6YCb [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl1
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B2 eta_B1; } in
        let {
          sat_s6YCa [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> a
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr1
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B2 eta_B1; } in
        let {
          sat_s6YC9 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl'
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YC8 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldl
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YC7 [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr'
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YC6 [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> b
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldr
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YC5 [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 a -> m
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfoldMap
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YC4 [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:+:) f_a6Lb0 g_a6Lb1 m -> m
          [LclId] =
              [$dFoldable_s6YC2 $dFoldable1_s6YC3] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:+:_$cfold
                      $dFoldable_s6YC2 $dFoldable1_s6YC3 eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6YC4
                                    sat_s6YC5
                                    sat_s6YC6
                                    sat_s6YC7
                                    sat_s6YC8
                                    sat_s6YC9
                                    sat_s6YCa
                                    sat_s6YCb
                                    sat_s6YCc
                                    sat_s6YCd
                                    sat_s6YCe
                                    sat_s6YCf
                                    sat_s6YCg
                                    sat_s6YCh
                                    sat_s6YCi
                                    sat_s6YCj];

Data.Foldable.$fFoldableM1_$celem
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.M1 i c f a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCk $dEq_s6YCl eta_s6YCm]
        let {
          f1_s6YCn [Occ=OnceL] :: a_a6Lg5 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YCl eta_s6YCm] \u []
                  GHC.Classes.== $dEq_s6YCl eta_s6YCm; } in
        let {
          sat_s6YCp [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6YCk f1_s6YCn] \r [ds_s6YCo]
                  Data.Foldable.foldMap
                      $dFoldable_s6YCk
                      Data.Semigroup.Internal.$fMonoidAny
                      f1_s6YCn
                      ds_s6YCo;
        } in  sat_s6YCp;

Data.Foldable.$fFoldableM1_$csum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCq $dNum_s6YCr]
        let {
          $dMonoid_s6YCs [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6Lgz)
          [LclId] =
              [$dNum_s6YCr] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6YCr; } in
        let {
          sat_s6YCu [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz
               -> Data.Semigroup.Internal.Sum a_a6Lgz
          [LclId] =
              [$dFoldable_s6YCq $dMonoid_s6YCs] \r [ds_s6YCt]
                  Data.Foldable.foldMap
                      $dFoldable_s6YCq
                      $dMonoid_s6YCs
                      Data.Foldable.$fFoldable:*:1
                      ds_s6YCt;
        } in  sat_s6YCu;

Data.Foldable.$fFoldableM1_$cminimum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCv $dOrd_s6YCw]
        let {
          $dMonoid_s6YCx [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6Lgp)
          [LclId] =
              [$dOrd_s6YCw] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6YCw; } in
        let {
          sat_s6YCB [Occ=OnceT[0]]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgp -> a_a6Lgp
          [LclId] =
              [$dFoldable_s6YCv $dMonoid_s6YCx] \r [x_s6YCy]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YCv $dMonoid_s6YCx GHC.Base.Just x_s6YCy
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6YCA [Occ=Once] -> v_s6YCA;
                  };
        } in  sat_s6YCB;

Data.Foldable.$fFoldableM1_$cmaximum
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCC $dOrd_s6YCD]
        let {
          $dMonoid_s6YCE [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lgf)
          [LclId] =
              [$dOrd_s6YCD] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6YCD; } in
        let {
          sat_s6YCI [Occ=OnceT[0]]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgf -> a_a6Lgf
          [LclId] =
              [$dFoldable_s6YCC $dMonoid_s6YCE] \r [x_s6YCF]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YCC $dMonoid_s6YCE GHC.Base.Just x_s6YCF
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6YCH [Occ=Once] -> v_s6YCH;
                  };
        } in  sat_s6YCI;

Data.Foldable.$fFoldableM1_$cfoldr1
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCJ f1_s6YCK xs_s6YCL]
        let {
          sat_s6YCR [Occ=Once]
            :: a_a6Lfq -> GHC.Base.Maybe a_a6Lfq -> GHC.Base.Maybe a_a6Lfq
          [LclId] =
              [f1_s6YCK] \r [x_s6YCM m_s6YCN]
                  let {
                    sat_s6YCQ [Occ=Once] :: a_a6Lfq
                    [LclId] =
                        [f1_s6YCK x_s6YCM m_s6YCN] \u []
                            case m_s6YCN of {
                              GHC.Base.Nothing -> x_s6YCM;
                              GHC.Base.Just y_s6YCP [Occ=Once] -> f1_s6YCK x_s6YCM y_s6YCP;
                            };
                  } in  GHC.Base.Just [sat_s6YCQ];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6YCJ sat_s6YCR GHC.Base.Nothing xs_s6YCL
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:8;
            GHC.Base.Just v_s6YCT [Occ=Once] -> v_s6YCT;
          };

Data.Foldable.$fFoldableM1_$cfoldl'
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YCU f1_s6YCV z0_s6YCW xs_s6YCX]
        let {
          sat_s6YD2 [Occ=Once]
            :: a_a6Lfh -> (b_a6Lfg -> b_a6Lfg) -> b_a6Lfg -> b_a6Lfg
          [LclId] =
              [f1_s6YCV] \r [x_s6YCY k_s6YCZ z_s6YD0]
                  case f1_s6YCV z_s6YD0 x_s6YCY of vx_s6YD1 {
                    __DEFAULT -> k_s6YCZ vx_s6YD1;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6YCU sat_s6YD2 GHC.Base.id xs_s6YCX z0_s6YCW;

Data.Foldable.$fFoldableM1_$clength
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.M1 i c f a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YD3 eta_s6YD4]
        Data.Foldable.foldr
            $dFoldable_s6YD3
            Data.Foldable.$fFoldableM2
            GHC.Base.id
            eta_s6YD4
            Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableM1_$cfoldl
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YD5 f1_s6YD6 z_s6YD7 t_s6YD8]
        let {
          sat_s6YDb [Occ=Once]
            :: a_a6Lf7
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6Lf6)
          [LclId] =
              [f1_s6YD6] \r [x_s6YD9 y_s6YDa] f1_s6YD6 y_s6YDa x_s6YD9;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YD5
              Data.Foldable.$fFoldable:*:7
              sat_s6YDb
              t_s6YD8
              z_s6YD7;

Data.Foldable.$fFoldableM3
  :: forall a.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual
          (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a)))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$fFoldableM1_$cfoldl1
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YDc f1_s6YDd xs_s6YDe]
        let {
          sat_s6YDk [Occ=Once]
            :: a_a6Lfy
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6Lfy))
          [LclId] =
              [f1_s6YDd] \r [x_s6YDf y_s6YDg]
                  let {
                    sat_s6YDj [Occ=Once] :: a_a6Lfy
                    [LclId] =
                        [f1_s6YDd x_s6YDf y_s6YDg] \u []
                            case y_s6YDg of {
                              GHC.Base.Nothing -> x_s6YDf;
                              GHC.Base.Just x1_s6YDi [Occ=Once] -> f1_s6YDd x1_s6YDi x_s6YDf;
                            };
                  } in  GHC.Base.Just [sat_s6YDj];
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6YDc
                  Data.Foldable.$fFoldableM3
                  sat_s6YDk
                  xs_s6YDe
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:6;
            GHC.Base.Just v_s6YDm [Occ=Once] -> v_s6YDm;
          };

Data.Foldable.$fFoldableM4
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual
          (Data.Semigroup.Internal.Endo (b -> b)))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Foldable.$fFoldableM1_$cfoldr'
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a b. (a -> b -> b) -> b -> GHC.Generics.M1 i c f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YDn f1_s6YDo z0_s6YDp xs_s6YDq]
        let {
          sat_s6YDv [Occ=Once]
            :: a_a6LeW
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6LeX -> b_a6LeX))
          [LclId] =
              [f1_s6YDo] \r [x_s6YDr y_s6YDs z_s6YDt]
                  case f1_s6YDo x_s6YDr z_s6YDt of vx_s6YDu {
                    __DEFAULT -> y_s6YDs vx_s6YDu;
                  };
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YDn
              Data.Foldable.$fFoldableM4
              sat_s6YDv
              xs_s6YDq
              GHC.Base.id
              z0_s6YDp;

Data.Foldable.$fFoldableM1_$cfold
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall m. GHC.Base.Monoid m => GHC.Generics.M1 i c f m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YDw $dMonoid_s6YDx ds_s6YDy]
        Data.Foldable.foldMap
            $dFoldable_s6YDw $dMonoid_s6YDx GHC.Base.id ds_s6YDy;

Data.Foldable.$fFoldableM1_$cproduct
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YDz $dNum_s6YDA]
        let {
          $dMonoid_s6YDB [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LgJ)
          [LclId] =
              [$dNum_s6YDA] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6YDA; } in
        let {
          sat_s6YDD [Occ=Once]
            :: GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ
               -> Data.Semigroup.Internal.Product a_a6LgJ
          [LclId] =
              [$dFoldable_s6YDz $dMonoid_s6YDB] \r [ds_s6YDC]
                  Data.Foldable.foldMap
                      $dFoldable_s6YDz
                      $dMonoid_s6YDB
                      Data.Foldable.$fFoldable:*:1
                      ds_s6YDC;
        } in  sat_s6YDD;

Data.Foldable.$fFoldableM1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.M1 i c f a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YDE eta_s6YDF]
        Data.Foldable.foldr
            $dFoldable_s6YDE GHC.Types.: GHC.Types.[] eta_s6YDF;

Data.Foldable.$fFoldableM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Foldable.Foldable f =>
     Data.Foldable.Foldable (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6YDG]
        let {
          sat_s6YE3 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cproduct $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YE2 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$csum $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YE1 [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cminimum $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YE0 [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$cmaximum $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YDZ [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$celem
                      $dFoldable_s6YDG eta_B2 eta_B1; } in
        let {
          sat_s6YDY [Occ=Once]
            :: forall a.
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$clength $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YDX [Occ=Once]
            :: forall a.
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YDG] \r [ds_s6YDW]
                  Data.Foldable.null $dFoldable_s6YDG ds_s6YDW; } in
        let {
          sat_s6YDV [Occ=Once]
            :: forall a. GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> [a]
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B1]
                  Data.Foldable.$fFoldableM1_$ctoList $dFoldable_s6YDG eta_B1; } in
        let {
          sat_s6YDU [Occ=Once]
            :: forall a.
               (a -> a -> a) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl1
                      $dFoldable_s6YDG eta_B2 eta_B1; } in
        let {
          sat_s6YDT [Occ=Once]
            :: forall a.
               (a -> a -> a) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> a
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldr1
                      $dFoldable_s6YDG eta_B2 eta_B1; } in
        let {
          sat_s6YDS [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl'
                      $dFoldable_s6YDG eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YDR [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldl
                      $dFoldable_s6YDG eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YDQ [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfoldr'
                      $dFoldable_s6YDG eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YDP [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> b
          [LclId] =
              [$dFoldable_s6YDG] \r [f1_s6YDM z_s6YDN ds_s6YDO]
                  Data.Foldable.foldr
                      $dFoldable_s6YDG f1_s6YDM z_s6YDN ds_s6YDO; } in
        let {
          sat_s6YDL [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 a -> m
          [LclId] =
              [$dFoldable_s6YDG] \r [$dMonoid_s6YDI f1_s6YDJ ds_s6YDK]
                  Data.Foldable.foldMap
                      $dFoldable_s6YDG $dMonoid_s6YDI f1_s6YDJ ds_s6YDK; } in
        let {
          sat_s6YDH [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               GHC.Generics.M1 i_a6Le8 c_a6Le9 f_a6Le7 m -> m
          [LclId] =
              [$dFoldable_s6YDG] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableM1_$cfold $dFoldable_s6YDG eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6YDH
                                    sat_s6YDL
                                    sat_s6YDP
                                    sat_s6YDQ
                                    sat_s6YDR
                                    sat_s6YDS
                                    sat_s6YDT
                                    sat_s6YDU
                                    sat_s6YDV
                                    sat_s6YDX
                                    sat_s6YDY
                                    sat_s6YDZ
                                    sat_s6YE0
                                    sat_s6YE1
                                    sat_s6YE2
                                    sat_s6YE3];

Data.Foldable.$fFoldableK1_$celem
  :: forall i c a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.K1 i c a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YE4 eta_s6YE5 eta1_s6YE6] GHC.Types.False [];

Data.Foldable.$fFoldableK1_$csum
  :: forall i c a. GHC.Num.Num a => GHC.Generics.K1 i c a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YE7 ds_s6YE8]
        Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YE7;

Data.Foldable.$fFoldableK1_$cminimum
  :: forall i c a. GHC.Classes.Ord a => GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YE9 eta_s6YEa]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableK1_$cmaximum
  :: forall i c a. GHC.Classes.Ord a => GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YEb eta_s6YEc]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableK1_$cfoldl
  :: forall i c b a. (b -> a -> b) -> b -> GHC.Generics.K1 i c a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YEd z_s6YEe t_s6YEf] z_s6YEe;

Data.Foldable.$fFoldableK6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK7;

Data.Foldable.$fFoldableK1_$cfoldl1
  :: forall i c a. (a -> a -> a) -> GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YEg xs_s6YEh]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableK1_$cfoldr'
  :: forall i c a b. (a -> b -> b) -> b -> GHC.Generics.K1 i c a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YEi z0_s6YEj xs_s6YEk] z0_s6YEj;

Data.Foldable.$fFoldableK1_$clength
  :: forall i c a. GHC.Generics.K1 i c a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6YEl] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableK8 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Foldable.$fFoldableK9;

Data.Foldable.$fFoldableK1_$cfoldr1
  :: forall i c a. (a -> a -> a) -> GHC.Generics.K1 i c a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YEm xs_s6YEn]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableK1_$cnull
  :: forall i c a. GHC.Generics.K1 i c a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t_s6YEo] GHC.Types.True [];

Data.Foldable.$fFoldableK1_$cfold
  :: forall i c m. GHC.Base.Monoid m => GHC.Generics.K1 i c m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YEp ds_s6YEq] GHC.Base.mempty $dMonoid_s6YEp;

Data.Foldable.$fFoldableK1_$cproduct
  :: forall i c a. GHC.Num.Num a => GHC.Generics.K1 i c a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YEr ds_s6YEs]
        Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YEr;

Data.Foldable.$fFoldableK1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall i c a. GHC.Generics.K1 i c a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6YEt] [] [];

Data.Foldable.$fFoldableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Data.Foldable.Foldable (GHC.Generics.K1 i c)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableK1_$cfold
                                             Data.Foldable.$fFoldableK1_$cfoldMap
                                             Data.Foldable.$fFoldableK1_$cfoldr'
                                             Data.Foldable.$fFoldableK1_$cfoldr'
                                             Data.Foldable.$fFoldableK1_$cfoldl
                                             Data.Foldable.$fFoldableK1_$cfoldl
                                             Data.Foldable.$fFoldableK1_$cfoldr1
                                             Data.Foldable.$fFoldableK1_$cfoldl1
                                             Data.Foldable.$fFoldableK1_$ctoList
                                             Data.Foldable.$fFoldableK1_$cnull
                                             Data.Foldable.$fFoldableK1_$clength
                                             Data.Foldable.$fFoldableK1_$celem
                                             Data.Foldable.$fFoldableK1_$cmaximum
                                             Data.Foldable.$fFoldableK1_$cminimum
                                             Data.Foldable.$fFoldableK1_$csum
                                             Data.Foldable.$fFoldableK1_$cproduct];

Data.Foldable.$fFoldableRec1_$celem
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.Rec1 f a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YEu $dEq_s6YEv eta_s6YEw]
        let {
          f1_s6YEx [Occ=OnceL] :: a_a6Lli -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YEv eta_s6YEw] \u []
                  GHC.Classes.== $dEq_s6YEv eta_s6YEw; } in
        let {
          sat_s6YEz [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6Lli -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6YEu f1_s6YEx] \r [ds_s6YEy]
                  Data.Foldable.foldMap
                      $dFoldable_s6YEu
                      Data.Semigroup.Internal.$fMonoidAny
                      f1_s6YEx
                      ds_s6YEy;
        } in  sat_s6YEz;

Data.Foldable.$fFoldableRec1_$csum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YEA $dNum_s6YEB]
        let {
          $dMonoid_s6YEC [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6LlM)
          [LclId] =
              [$dNum_s6YEB] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6YEB; } in
        let {
          sat_s6YEE [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlM
               -> Data.Semigroup.Internal.Sum a_a6LlM
          [LclId] =
              [$dFoldable_s6YEA $dMonoid_s6YEC] \r [ds_s6YED]
                  Data.Foldable.foldMap
                      $dFoldable_s6YEA
                      $dMonoid_s6YEC
                      Data.Foldable.$fFoldable:*:1
                      ds_s6YED;
        } in  sat_s6YEE;

Data.Foldable.$fFoldableRec1_$cminimum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YEF $dOrd_s6YEG]
        let {
          $dMonoid_s6YEH [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6LlC)
          [LclId] =
              [$dOrd_s6YEG] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6YEG; } in
        let {
          sat_s6YEL [Occ=OnceT[0]]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlC -> a_a6LlC
          [LclId] =
              [$dFoldable_s6YEF $dMonoid_s6YEH] \r [x_s6YEI]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YEF $dMonoid_s6YEH GHC.Base.Just x_s6YEI
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6YEK [Occ=Once] -> v_s6YEK;
                  };
        } in  sat_s6YEL;

Data.Foldable.$fFoldableRec1_$cmaximum
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YEM $dOrd_s6YEN]
        let {
          $dMonoid_s6YEO [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6Lls)
          [LclId] =
              [$dOrd_s6YEN] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6YEN; } in
        let {
          sat_s6YES [Occ=OnceT[0]]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6Lls -> a_a6Lls
          [LclId] =
              [$dFoldable_s6YEM $dMonoid_s6YEO] \r [x_s6YEP]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YEM $dMonoid_s6YEO GHC.Base.Just x_s6YEP
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6YER [Occ=Once] -> v_s6YER;
                  };
        } in  sat_s6YES;

Data.Foldable.$fFoldable:.:3 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableRec1_$cfoldr1
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YET f1_s6YEU xs_s6YEV]
        let {
          sat_s6YF1 [Occ=Once]
            :: a_a6LkD -> GHC.Base.Maybe a_a6LkD -> GHC.Base.Maybe a_a6LkD
          [LclId] =
              [f1_s6YEU] \r [x_s6YEW m_s6YEX]
                  let {
                    sat_s6YF0 [Occ=Once] :: a_a6LkD
                    [LclId] =
                        [f1_s6YEU x_s6YEW m_s6YEX] \u []
                            case m_s6YEX of {
                              GHC.Base.Nothing -> x_s6YEW;
                              GHC.Base.Just y_s6YEZ [Occ=Once] -> f1_s6YEU x_s6YEW y_s6YEZ;
                            };
                  } in  GHC.Base.Just [sat_s6YF0];
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6YET sat_s6YF1 GHC.Base.Nothing xs_s6YEV
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
            GHC.Base.Just v_s6YF3 [Occ=Once] -> v_s6YF3;
          };

Data.Foldable.$fFoldableRec1_$cfoldl'
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YF4 f1_s6YF5 z0_s6YF6 xs_s6YF7]
        let {
          sat_s6YFc [Occ=Once]
            :: a_a6Lku -> (b_a6Lkt -> b_a6Lkt) -> b_a6Lkt -> b_a6Lkt
          [LclId] =
              [f1_s6YF5] \r [x_s6YF8 k_s6YF9 z_s6YFa]
                  case f1_s6YF5 z_s6YFa x_s6YF8 of vx_s6YFb {
                    __DEFAULT -> k_s6YF9 vx_s6YFb;
                  };
        } in 
          Data.Foldable.foldr
              $dFoldable_s6YF4 sat_s6YFc GHC.Base.id xs_s6YF7 z0_s6YF6;

Data.Foldable.$fFoldableRec1_$clength
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.Rec1 f a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFd eta_s6YFe]
        Data.Foldable.foldr
            $dFoldable_s6YFd
            Data.Foldable.$fFoldableM2
            GHC.Base.id
            eta_s6YFe
            Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableRec1_$cfoldl
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall b a. (b -> a -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFf f1_s6YFg z_s6YFh t_s6YFi]
        let {
          sat_s6YFl [Occ=Once]
            :: a_a6Lkk
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6Lkj)
          [LclId] =
              [f1_s6YFg] \r [x_s6YFj y_s6YFk] f1_s6YFg y_s6YFk x_s6YFj;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YFf
              Data.Foldable.$fFoldable:*:7
              sat_s6YFl
              t_s6YFi
              z_s6YFh;

Data.Foldable.$fFoldable:.:2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableRec1_$cfoldl1
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. (a -> a -> a) -> GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFm f1_s6YFn xs_s6YFo]
        let {
          sat_s6YFu [Occ=Once]
            :: a_a6LkL
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6LkL))
          [LclId] =
              [f1_s6YFn] \r [x_s6YFp y_s6YFq]
                  let {
                    sat_s6YFt [Occ=Once] :: a_a6LkL
                    [LclId] =
                        [f1_s6YFn x_s6YFp y_s6YFq] \u []
                            case y_s6YFq of {
                              GHC.Base.Nothing -> x_s6YFp;
                              GHC.Base.Just x1_s6YFs [Occ=Once] -> f1_s6YFn x1_s6YFs x_s6YFp;
                            };
                  } in  GHC.Base.Just [sat_s6YFt];
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6YFm
                  Data.Foldable.$fFoldableM3
                  sat_s6YFu
                  xs_s6YFo
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
            GHC.Base.Just v_s6YFw [Occ=Once] -> v_s6YFw;
          };

Data.Foldable.$fFoldableRec1_$cfoldr'
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a b. (a -> b -> b) -> b -> GHC.Generics.Rec1 f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFx f1_s6YFy z0_s6YFz xs_s6YFA]
        let {
          sat_s6YFF [Occ=Once]
            :: a_a6Lk9
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6Lka -> b_a6Lka))
          [LclId] =
              [f1_s6YFy] \r [x_s6YFB y_s6YFC z_s6YFD]
                  case f1_s6YFy x_s6YFB z_s6YFD of vx_s6YFE {
                    __DEFAULT -> y_s6YFC vx_s6YFE;
                  };
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YFx
              Data.Foldable.$fFoldableM4
              sat_s6YFF
              xs_s6YFA
              GHC.Base.id
              z0_s6YFz;

Data.Foldable.$fFoldableRec1_$cfold
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall m. GHC.Base.Monoid m => GHC.Generics.Rec1 f m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFG $dMonoid_s6YFH ds_s6YFI]
        Data.Foldable.foldMap
            $dFoldable_s6YFG $dMonoid_s6YFH GHC.Base.id ds_s6YFI;

Data.Foldable.$fFoldableRec1_$cproduct
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Num.Num a => GHC.Generics.Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFJ $dNum_s6YFK]
        let {
          $dMonoid_s6YFL [Occ=OnceL]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6LlW)
          [LclId] =
              [$dNum_s6YFK] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6YFK; } in
        let {
          sat_s6YFN [Occ=Once]
            :: GHC.Generics.Rec1 f_a6Ljm a_a6LlW
               -> Data.Semigroup.Internal.Product a_a6LlW
          [LclId] =
              [$dFoldable_s6YFJ $dMonoid_s6YFL] \r [ds_s6YFM]
                  Data.Foldable.foldMap
                      $dFoldable_s6YFJ
                      $dMonoid_s6YFL
                      Data.Foldable.$fFoldable:*:1
                      ds_s6YFM;
        } in  sat_s6YFN;

Data.Foldable.$fFoldableRec1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     forall a. GHC.Generics.Rec1 f a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YFO eta_s6YFP]
        Data.Foldable.foldr
            $dFoldable_s6YFO GHC.Types.: GHC.Types.[] eta_s6YFP;

Data.Foldable.$fFoldableRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Foldable.Foldable f =>
     Data.Foldable.Foldable (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6YFQ]
        let {
          sat_s6YGd [Occ=Once]
            :: forall a. GHC.Num.Num a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cproduct
                      $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YGc [Occ=Once]
            :: forall a. GHC.Num.Num a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$csum $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YGb [Occ=Once]
            :: forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cminimum
                      $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YGa [Occ=Once]
            :: forall a. GHC.Classes.Ord a => GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$cmaximum
                      $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YG9 [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$celem
                      $dFoldable_s6YFQ eta_B2 eta_B1; } in
        let {
          sat_s6YG8 [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$clength $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YG7 [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YFQ] \r [ds_s6YG6]
                  Data.Foldable.null $dFoldable_s6YFQ ds_s6YG6; } in
        let {
          sat_s6YG5 [Occ=Once]
            :: forall a. GHC.Generics.Rec1 f_a6Ljm a -> [a]
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B1]
                  Data.Foldable.$fFoldableRec1_$ctoList $dFoldable_s6YFQ eta_B1; } in
        let {
          sat_s6YG4 [Occ=Once]
            :: forall a. (a -> a -> a) -> GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl1
                      $dFoldable_s6YFQ eta_B2 eta_B1; } in
        let {
          sat_s6YG3 [Occ=Once]
            :: forall a. (a -> a -> a) -> GHC.Generics.Rec1 f_a6Ljm a -> a
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldr1
                      $dFoldable_s6YFQ eta_B2 eta_B1; } in
        let {
          sat_s6YG2 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl'
                      $dFoldable_s6YFQ eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YG1 [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldl
                      $dFoldable_s6YFQ eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YG0 [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfoldr'
                      $dFoldable_s6YFQ eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YFZ [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> GHC.Generics.Rec1 f_a6Ljm a -> b
          [LclId] =
              [$dFoldable_s6YFQ] \r [f1_s6YFW z_s6YFX ds_s6YFY]
                  Data.Foldable.foldr
                      $dFoldable_s6YFQ f1_s6YFW z_s6YFX ds_s6YFY; } in
        let {
          sat_s6YFV [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> GHC.Generics.Rec1 f_a6Ljm a -> m
          [LclId] =
              [$dFoldable_s6YFQ] \r [$dMonoid_s6YFS f1_s6YFT ds_s6YFU]
                  Data.Foldable.foldMap
                      $dFoldable_s6YFQ $dMonoid_s6YFS f1_s6YFT ds_s6YFU; } in
        let {
          sat_s6YFR [Occ=Once]
            :: forall m. GHC.Base.Monoid m => GHC.Generics.Rec1 f_a6Ljm m -> m
          [LclId] =
              [$dFoldable_s6YFQ] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldableRec1_$cfold $dFoldable_s6YFQ eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6YFR
                                    sat_s6YFV
                                    sat_s6YFZ
                                    sat_s6YG0
                                    sat_s6YG1
                                    sat_s6YG2
                                    sat_s6YG3
                                    sat_s6YG4
                                    sat_s6YG5
                                    sat_s6YG7
                                    sat_s6YG8
                                    sat_s6YG9
                                    sat_s6YGa
                                    sat_s6YGb
                                    sat_s6YGc
                                    sat_s6YGd];

Data.Foldable.$fFoldablePar1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.Par1 a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YGe eta_s6YGf]
        let {
          f_s6YGg [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LnB -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YGe eta_s6YGf] \u []
                  GHC.Classes.== $dEq_s6YGe eta_s6YGf; } in
        let {
          sat_s6YGi [Occ=OnceT[0]]
            :: GHC.Generics.Par1 a_a6LnB -> GHC.Types.Bool
          [LclId] =
              [f_s6YGg] \r [ds_s6YGh] f_s6YGg ds_s6YGh;
        } in  sat_s6YGi;

Data.Foldable.$fFoldablePar2
  :: forall a.
     GHC.Num.Num a =>
     GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YGj eta_s6YGk] eta_s6YGk;

Data.Foldable.$fFoldablePar3
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6YGl x_s6YGm] x_s6YGm;

Data.Foldable.$fFoldablePar4
  :: forall a.
     (a -> a -> a) -> GHC.Generics.Par1 a -> GHC.Generics.Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YGn xs_s6YGo] xs_s6YGo;

Data.Foldable.$fFoldablePar1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.Par1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s6YGp z0_s6YGq xs_s6YGr] f_s6YGp z0_s6YGq xs_s6YGr;

Data.Foldable.$fFoldablePar1_$clength
  :: forall a. GHC.Generics.Par1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6YGs] Data.Foldable.$fFoldableDual3;

Data.Foldable.$fFoldablePar5
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Generics.Par1 m -> GHC.Generics.Par1 m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YGt ds_s6YGu] ds_s6YGu;

Data.Foldable.$fFoldablePar1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.Par1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_s6YGv] : [eta_s6YGv GHC.Types.[]];

Data.Foldable.$fFoldablePar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.Par1
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldablePar5
                                             Data.Foldable.$fFoldablePar1_$cfoldMap
                                             Data.Foldable.$fFoldablePar1_$cfoldr
                                             Data.Foldable.$fFoldablePar1_$cfoldr
                                             Data.Foldable.$fFoldablePar1_$cfoldl'
                                             Data.Foldable.$fFoldablePar1_$cfoldl'
                                             Data.Foldable.$fFoldablePar4
                                             Data.Foldable.$fFoldablePar4
                                             Data.Foldable.$fFoldablePar1_$ctoList
                                             Data.Foldable.$fFoldablePar1_$cnull
                                             Data.Foldable.$fFoldablePar1_$clength
                                             Data.Foldable.$fFoldablePar1_$celem
                                             Data.Foldable.$fFoldablePar3
                                             Data.Foldable.$fFoldablePar3
                                             Data.Foldable.$fFoldablePar2
                                             Data.Foldable.$fFoldablePar2];

Data.Foldable.$fFoldableV1_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Generics.V1 a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YGw eta_s6YGx eta1_s6YGy] GHC.Types.False [];

Data.Foldable.$fFoldableV1_$csum
  :: forall a. GHC.Num.Num a => GHC.Generics.V1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YGz ds_s6YGA]
        Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YGz;

Data.Foldable.$fFoldableV1_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YGB eta_s6YGC]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK2;

Data.Foldable.$fFoldableV1_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [$dOrd_s6YGD eta_s6YGE]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK4;

Data.Foldable.$fFoldableV1_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> GHC.Generics.V1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YGF z_s6YGG t_s6YGH] z_s6YGG;

Data.Foldable.$fFoldableV1_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YGI xs_s6YGJ]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK6;

Data.Foldable.$fFoldableV1_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> GHC.Generics.V1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [f_s6YGK z0_s6YGL xs_s6YGM] z0_s6YGL;

Data.Foldable.$fFoldableV1_$clength
  :: forall a. GHC.Generics.V1 a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_s6YGN] Data.Foldable.$fFoldable:*:4;

Data.Foldable.$fFoldableV1_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Generics.V1 a -> a
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []] =
    [] \r [f_s6YGO xs_s6YGP]
        GHC.Err.errorWithoutStackTrace Data.Foldable.$fFoldableK8;

Data.Foldable.$fFoldableV1_$cnull
  :: forall a. GHC.Generics.V1 a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t_s6YGQ] GHC.Types.True [];

Data.Foldable.$fFoldableV1_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Generics.V1 m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YGR ds_s6YGS] GHC.Base.mempty $dMonoid_s6YGR;

Data.Foldable.$fFoldableV1_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Generics.V1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YGT ds_s6YGU]
        Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YGT;

Data.Foldable.$fFoldableV1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Generics.V1 a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_s6YGV] [] [];

Data.Foldable.$fFoldableV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Generics.V1
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableV1_$cfold
                                             Data.Foldable.$fFoldableV1_$cfoldMap
                                             Data.Foldable.$fFoldableV1_$cfoldr'
                                             Data.Foldable.$fFoldableV1_$cfoldr'
                                             Data.Foldable.$fFoldableV1_$cfoldl
                                             Data.Foldable.$fFoldableV1_$cfoldl
                                             Data.Foldable.$fFoldableV1_$cfoldr1
                                             Data.Foldable.$fFoldableV1_$cfoldl1
                                             Data.Foldable.$fFoldableV1_$ctoList
                                             Data.Foldable.$fFoldableV1_$cnull
                                             Data.Foldable.$fFoldableV1_$clength
                                             Data.Foldable.$fFoldableV1_$celem
                                             Data.Foldable.$fFoldableV1_$cmaximum
                                             Data.Foldable.$fFoldableV1_$cminimum
                                             Data.Foldable.$fFoldableV1_$csum
                                             Data.Foldable.$fFoldableV1_$cproduct];

Data.Foldable.$fFoldableArray_$cfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall i m a.
     GHC.Base.Monoid m =>
     (a -> m) -> GHC.Arr.Array i a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><L,C(U)><S(LLSL),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YGW f_s6YGX eta_s6YGY]
        case eta_s6YGY of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6YH2 [Occ=OnceL]
                        ww4_s6YH3 [Occ=OnceL] ->
              let {
                w1_s6YH4 [Occ=OnceL] :: m_a6LGY
                [LclId] =
                    [$dMonoid_s6YGW] \u [] GHC.Base.mempty $dMonoid_s6YGW; } in
              let {
                $wgo_s6YH5 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                  :: GHC.Prim.Int# -> m_a6LGY
                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                    sat-only [$dMonoid_s6YGW
                              f_s6YGX
                              ww3_s6YH2
                              ww4_s6YH3
                              w1_s6YH4
                              $wgo_s6YH5] \r [ww7_s6YH6]
                        case ==# [ww7_s6YH6 ww3_s6YH2] of {
                          __DEFAULT ->
                              let {
                                sat_s6YHd [Occ=Once] :: m_a6LGY
                                [LclId] =
                                    [$wgo_s6YH5 ww7_s6YH6] \u []
                                        case +# [ww7_s6YH6 1#] of sat_s6YHc {
                                          __DEFAULT -> $wgo_s6YH5 sat_s6YHc;
                                        }; } in
                              let {
                                sat_s6YHb [Occ=Once] :: m_a6LGY
                                [LclId] =
                                    [f_s6YGX ww4_s6YH3 ww7_s6YH6] \u []
                                        let {
                                          sat_s6YHa [Occ=Once] :: a_a6LGZ
                                          [LclId] =
                                              [ww4_s6YH3 ww7_s6YH6] \u []
                                                  case indexArray# [ww4_s6YH3 ww7_s6YH6] of {
                                                    Unit# ipv_s6YH9 [Occ=Once] -> ipv_s6YH9;
                                                  };
                                        } in  f_s6YGX sat_s6YHa;
                              } in  GHC.Base.mappend $dMonoid_s6YGW sat_s6YHb sat_s6YHd;
                          1# -> w1_s6YH4;
                        };
              } in  $wgo_s6YH5 0#;
        };

Data.Foldable.$fFoldableArray1
  :: forall i a.
     GHC.Num.Num a =>
     GHC.Arr.Array i a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YHe]
        let {
          w1_s6YHf [Occ=OnceL] :: a_a6LJu
          [LclId] =
              [$dNum_s6YHe] \u []
                  GHC.Num.fromInteger
                      $dNum_s6YHe Data.Semigroup.Internal.$fMonoidProduct1; } in
        let {
          sat_s6YHu [Occ=OnceT[0]]
            :: GHC.Arr.Array i_a6LGK a_a6LJu
               -> Data.Semigroup.Internal.Product a_a6LJu
          [LclId] =
              [$dNum_s6YHe w1_s6YHf] \r [w2_s6YHg]
                  case w2_s6YHg of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6YHk [Occ=OnceL]
                                  ww4_s6YHl [Occ=OnceL] ->
                        let {
                          $wgo_s6YHm [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Product a_a6LJu
                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6YHe
                                        w1_s6YHf
                                        ww3_s6YHk
                                        ww4_s6YHl
                                        $wgo_s6YHm] \r [ww7_s6YHn]
                                  case ==# [ww7_s6YHn ww3_s6YHk] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6YHt [Occ=Once] :: a_a6LJu
                                          [LclId] =
                                              [$wgo_s6YHm ww7_s6YHn] \u []
                                                  case +# [ww7_s6YHn 1#] of sat_s6YHs {
                                                    __DEFAULT -> $wgo_s6YHm sat_s6YHs;
                                                  }; } in
                                        let {
                                          sat_s6YHr [Occ=Once] :: a_a6LJu
                                          [LclId] =
                                              [ww4_s6YHl ww7_s6YHn] \u []
                                                  case indexArray# [ww4_s6YHl ww7_s6YHn] of {
                                                    Unit# ipv_s6YHq [Occ=Once] -> ipv_s6YHq;
                                                  };
                                        } in  GHC.Num.* $dNum_s6YHe sat_s6YHr sat_s6YHt;
                                    1# -> w1_s6YHf;
                                  };
                        } in  $wgo_s6YHm 0#;
                  };
        } in  sat_s6YHu;

Data.Foldable.$w$cfold [InlPrag=NOUSERINLINE[0]]
  :: forall i m.
     GHC.Base.Monoid m =>
     GHC.Prim.Int# -> GHC.Prim.Array# m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6YHv ww_s6YHw ww1_s6YHx]
        let {
          w1_s6YHy [Occ=OnceL] :: m_s6NXp
          [LclId] =
              [w_s6YHv] \u [] GHC.Base.mempty w_s6YHv; } in
        let {
          $wgo_s6YHz [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> m_s6NXp
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6YHv
                        ww_s6YHw
                        ww1_s6YHx
                        w1_s6YHy
                        $wgo_s6YHz] \r [ww2_s6YHA]
                  case ==# [ww2_s6YHA ww_s6YHw] of {
                    __DEFAULT ->
                        let {
                          sat_s6YHG [Occ=Once] :: m_s6NXp
                          [LclId] =
                              [$wgo_s6YHz ww2_s6YHA] \u []
                                  case +# [ww2_s6YHA 1#] of sat_s6YHF {
                                    __DEFAULT -> $wgo_s6YHz sat_s6YHF;
                                  }; } in
                        let {
                          sat_s6YHE [Occ=Once] :: m_s6NXp
                          [LclId] =
                              [ww1_s6YHx ww2_s6YHA] \u []
                                  case indexArray# [ww1_s6YHx ww2_s6YHA] of {
                                    Unit# ipv_s6YHD [Occ=Once] -> ipv_s6YHD;
                                  };
                        } in  GHC.Base.mappend w_s6YHv sat_s6YHE sat_s6YHG;
                    1# -> w1_s6YHy;
                  };
        } in  $wgo_s6YHz 0#;

Data.Foldable.$fFoldableArray_$cfold [InlPrag=NOUSERINLINE[0]]
  :: forall i m. GHC.Base.Monoid m => GHC.Arr.Array i m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,U,C(C1(U)),A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YHH w1_s6YHI]
        case w1_s6YHI of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6YHM [Occ=Once]
                        ww4_s6YHN [Occ=Once] ->
              Data.Foldable.$w$cfold w_s6YHH ww3_s6YHM ww4_s6YHN;
        };

Data.Foldable.$w$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall i a.
     GHC.Classes.Ord a =>
     GHC.Prim.Int# -> GHC.Prim.Array# a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6YHO ww_s6YHP ww1_s6YHQ]
        let {
          $wgo_s6YHR [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> Data.Functor.Utils.Max a_s6NXH
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6YHO ww_s6YHP ww1_s6YHQ $wgo_s6YHR] \r [ww2_s6YHS]
                  case ==# [ww2_s6YHS ww_s6YHP] of {
                    __DEFAULT ->
                        let {
                          x_s6YHU :: a_s6NXH
                          [LclId] =
                              [ww1_s6YHQ ww2_s6YHS] \u []
                                  case indexArray# [ww1_s6YHQ ww2_s6YHS] of {
                                    Unit# ipv_s6YHW [Occ=Once] -> ipv_s6YHW;
                                  };
                        } in 
                          case +# [ww2_s6YHS 1#] of sat_s6YHX {
                            __DEFAULT ->
                                case $wgo_s6YHR sat_s6YHX of wild_s6YHY {
                                  GHC.Base.Nothing -> GHC.Base.Just [x_s6YHU];
                                  GHC.Base.Just ipv_s6YHZ [Occ=Once] ->
                                      case GHC.Classes.>= w_s6YHO x_s6YHU ipv_s6YHZ of {
                                        GHC.Types.False -> wild_s6YHY;
                                        GHC.Types.True -> GHC.Base.Just [x_s6YHU];
                                      };
                                };
                          };
                    1# -> GHC.Base.Nothing [];
                  };
        } in 
          case $wgo_s6YHR 0# of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
            GHC.Base.Just v_s6YI2 [Occ=Once] -> v_s6YI2;
          };

Data.Foldable.$fFoldableArray_$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. GHC.Classes.Ord a => GHC.Arr.Array i a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YI3 w1_s6YI4]
        case w1_s6YI4 of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6YI8 [Occ=Once]
                        ww4_s6YI9 [Occ=Once] ->
              Data.Foldable.$w$cmaximum w_s6YI3 ww3_s6YI8 ww4_s6YI9;
        };

Data.Foldable.$w$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall i a.
     GHC.Classes.Ord a =>
     GHC.Prim.Int# -> GHC.Prim.Array# a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6YIa ww_s6YIb ww1_s6YIc]
        let {
          $wgo_s6YId [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: GHC.Prim.Int# -> Data.Functor.Utils.Min a_s6NXZ
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [w_s6YIa ww_s6YIb ww1_s6YIc $wgo_s6YId] \r [ww2_s6YIe]
                  case ==# [ww2_s6YIe ww_s6YIb] of {
                    __DEFAULT ->
                        let {
                          x_s6YIg :: a_s6NXZ
                          [LclId] =
                              [ww1_s6YIc ww2_s6YIe] \u []
                                  case indexArray# [ww1_s6YIc ww2_s6YIe] of {
                                    Unit# ipv_s6YIi [Occ=Once] -> ipv_s6YIi;
                                  };
                        } in 
                          case +# [ww2_s6YIe 1#] of sat_s6YIj {
                            __DEFAULT ->
                                case $wgo_s6YId sat_s6YIj of wild_s6YIk {
                                  GHC.Base.Nothing -> GHC.Base.Just [x_s6YIg];
                                  GHC.Base.Just ipv_s6YIl [Occ=Once] ->
                                      case GHC.Classes.<= w_s6YIa x_s6YIg ipv_s6YIl of {
                                        GHC.Types.False -> wild_s6YIk;
                                        GHC.Types.True -> GHC.Base.Just [x_s6YIg];
                                      };
                                };
                          };
                    1# -> GHC.Base.Nothing [];
                  };
        } in 
          case $wgo_s6YId 0# of {
            GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
            GHC.Base.Just v_s6YIo [Occ=Once] -> v_s6YIo;
          };

Data.Foldable.$fFoldableArray_$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. GHC.Classes.Ord a => GHC.Arr.Array i a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YIp w1_s6YIq]
        case w1_s6YIq of {
          GHC.Arr.Array _ [Occ=Dead]
                        _ [Occ=Dead]
                        ww3_s6YIu [Occ=Once]
                        ww4_s6YIv [Occ=Once] ->
              Data.Foldable.$w$cminimum w_s6YIp ww3_s6YIu ww4_s6YIv;
        };

Data.Foldable.$fFoldableArray2
  :: forall i a.
     GHC.Num.Num a =>
     GHC.Arr.Array i a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YIw]
        let {
          w1_s6YIx [Occ=OnceL] :: a_a6LJk
          [LclId] =
              [$dNum_s6YIw] \u []
                  GHC.Num.fromInteger
                      $dNum_s6YIw Data.Semigroup.Internal.$fMonoidSum1; } in
        let {
          sat_s6YIM [Occ=OnceT[0]]
            :: GHC.Arr.Array i_X6LX9 a_a6LJk
               -> Data.Semigroup.Internal.Sum a_a6LJk
          [LclId] =
              [$dNum_s6YIw w1_s6YIx] \r [w2_s6YIy]
                  case w2_s6YIy of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6YIC [Occ=OnceL]
                                  ww4_s6YID [Occ=OnceL] ->
                        let {
                          $wgo_s6YIE [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Sum a_a6LJk
                          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6YIw
                                        w1_s6YIx
                                        ww3_s6YIC
                                        ww4_s6YID
                                        $wgo_s6YIE] \r [ww7_s6YIF]
                                  case ==# [ww7_s6YIF ww3_s6YIC] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6YIL [Occ=Once] :: a_a6LJk
                                          [LclId] =
                                              [$wgo_s6YIE ww7_s6YIF] \u []
                                                  case +# [ww7_s6YIF 1#] of sat_s6YIK {
                                                    __DEFAULT -> $wgo_s6YIE sat_s6YIK;
                                                  }; } in
                                        let {
                                          sat_s6YIJ [Occ=Once] :: a_a6LJk
                                          [LclId] =
                                              [ww4_s6YID ww7_s6YIF] \u []
                                                  case indexArray# [ww4_s6YID ww7_s6YIF] of {
                                                    Unit# ipv_s6YII [Occ=Once] -> ipv_s6YII;
                                                  };
                                        } in  GHC.Num.+ $dNum_s6YIw sat_s6YIJ sat_s6YIL;
                                    1# -> w1_s6YIx;
                                  };
                        } in  $wgo_s6YIE 0#;
                  };
        } in  sat_s6YIM;

Data.Foldable.$fFoldableArray_$celem
  :: forall i a.
     GHC.Classes.Eq a =>
     a -> GHC.Arr.Array i a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YIN eta_s6YIO]
        let {
          f_s6YIP [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LIQ -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YIN eta_s6YIO] \u []
                  GHC.Classes.== $dEq_s6YIN eta_s6YIO; } in
        let {
          sat_s6YJ4 [Occ=Once]
            :: GHC.Arr.Array i_X6LXe a_a6LIQ -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6YIP] \r [w2_s6YIQ]
                  case w2_s6YIQ of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  ww3_s6YIU [Occ=OnceL]
                                  ww4_s6YIV [Occ=OnceL] ->
                        let-no-escape {
                          $wgo_s6YIW [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                            :: GHC.Prim.Int# -> Data.Semigroup.Internal.Any
                          [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                              sat-only [f_s6YIP ww3_s6YIU ww4_s6YIV $wgo_s6YIW] \r [ww7_s6YIX]
                                  case ==# [ww7_s6YIX ww3_s6YIU] of {
                                    __DEFAULT ->
                                        let {
                                          sat_s6YJ1 [Occ=Once] :: a_a6LIQ
                                          [LclId] =
                                              [ww4_s6YIV ww7_s6YIX] \u []
                                                  case indexArray# [ww4_s6YIV ww7_s6YIX] of {
                                                    Unit# ipv_s6YJ0 [Occ=Once] -> ipv_s6YJ0;
                                                  };
                                        } in 
                                          case f_s6YIP sat_s6YJ1 of {
                                            GHC.Types.False ->
                                                case +# [ww7_s6YIX 1#] of sat_s6YJ3 {
                                                  __DEFAULT -> $wgo_s6YIW sat_s6YJ3;
                                                };
                                            GHC.Types.True -> GHC.Types.True [];
                                          };
                                    1# -> GHC.Types.False [];
                                  };
                        } in  $wgo_s6YIW 0#;
                  };
        } in  sat_s6YJ4;

Data.Foldable.$fFoldableArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Foldable.Foldable (GHC.Arr.Array i)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableArray_$cfold
                                             Data.Foldable.$fFoldableArray_$cfoldMap
                                             GHC.Arr.foldrElems
                                             GHC.Arr.foldrElems'
                                             GHC.Arr.foldlElems
                                             GHC.Arr.foldlElems'
                                             GHC.Arr.foldr1Elems
                                             GHC.Arr.foldl1Elems
                                             GHC.Arr.elems
                                             Data.Foldable.$fFoldableArray_$cnull
                                             GHC.Arr.numElements
                                             Data.Foldable.$fFoldableArray_$celem
                                             Data.Foldable.$fFoldableArray_$cmaximum
                                             Data.Foldable.$fFoldableArray_$cminimum
                                             Data.Foldable.$fFoldableArray2
                                             Data.Foldable.$fFoldableArray1];

Data.Foldable.$fFoldable(,)_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> (a1, a2) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YJ5 eta_s6YJ6]
        let {
          f_s6YJ7 [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_a6LLd -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YJ5 eta_s6YJ6] \u []
                  GHC.Classes.== $dEq_s6YJ5 eta_s6YJ6; } in
        let {
          sat_s6YJc [Occ=Once]
            :: (a_a6LJD, a1_a6LLd) -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6YJ7] \r [ds_s6YJ8]
                  case ds_s6YJ8 of {
                    (,) _ [Occ=Dead] y_s6YJb [Occ=Once] -> f_s6YJ7 y_s6YJb;
                  };
        } in  sat_s6YJc;

Data.Foldable.$fFoldable(,)2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     (a1, a2) -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YJd eta_s6YJe]
        case eta_s6YJe of {
          (,) _ [Occ=Dead] y_s6YJh [Occ=Once] -> y_s6YJh;
        };

Data.Foldable.$fFoldable(,)3 :: forall a1 a2. (a2, a1) -> a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [x_s6YJi]
        case x_s6YJi of {
          (,) _ [Occ=Dead] y_s6YJl [Occ=Once] -> y_s6YJl;
        };

Data.Foldable.$fFoldable(,)_$cminimum
  :: forall a1 a2. GHC.Classes.Ord a2 => (a1, a2) -> a2
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YJm eta_B1] Data.Foldable.$fFoldable(,)3 eta_B1;

Data.Foldable.$fFoldable(,)_$cnull
  :: forall a1 a2. (a1, a2) -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_s6YJn]
        case ds_s6YJn of {
          (,) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldable(,)_$cfoldr1
  :: forall a1 a2. (a2 -> a2 -> a2) -> (a1, a2) -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_s6YJr xs_s6YJs]
        case xs_s6YJs of {
          (,) _ [Occ=Dead] y_s6YJv [Occ=Once] -> y_s6YJv;
        };

Data.Foldable.$fFoldable(,)_$cfoldl'
  :: forall a1 b a2. (b -> a2 -> b) -> b -> (a1, a2) -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_s6YJw z0_s6YJx xs_s6YJy]
        case xs_s6YJy of {
          (,) _ [Occ=Dead] y_s6YJB [Occ=Once] -> f_s6YJw z0_s6YJx y_s6YJB;
        };

Data.Foldable.$fFoldable(,)_$clength
  :: forall a1 a2. (a1, a2) -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_s6YJC]
        case xs_s6YJC of {
          (,) _ [Occ=Dead] _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldable(,)_$cfold
  :: forall a m. GHC.Base.Monoid m => (a, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YJG ds_s6YJH]
        case ds_s6YJH of {
          (,) _ [Occ=Dead] y_s6YJK [Occ=Once] -> y_s6YJK;
        };

Data.Foldable.$fFoldable(,)1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     (a1, a2) -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YJL eta_s6YJM]
        case eta_s6YJM of {
          (,) _ [Occ=Dead] y_s6YJP [Occ=Once] -> y_s6YJP;
        };

Data.Foldable.$fFoldable(,)_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. (a1, a2) -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_s6YJQ]
        case eta_s6YJQ of {
          (,) _ [Occ=Dead] y_s6YJT [Occ=Once] -> : [y_s6YJT GHC.Types.[]];
        };

Data.Foldable.$fFoldable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable ((,) a)
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldable(,)_$cfold
                                             Data.Foldable.$fFoldable(,)_$cfoldMap
                                             Data.Foldable.$fFoldable(,)_$cfoldr
                                             Data.Foldable.$fFoldable(,)_$cfoldr
                                             Data.Foldable.$fFoldable(,)_$cfoldl'
                                             Data.Foldable.$fFoldable(,)_$cfoldl'
                                             Data.Foldable.$fFoldable(,)_$cfoldr1
                                             Data.Foldable.$fFoldable(,)_$cfoldr1
                                             Data.Foldable.$fFoldable(,)_$ctoList
                                             Data.Foldable.$fFoldable(,)_$cnull
                                             Data.Foldable.$fFoldable(,)_$clength
                                             Data.Foldable.$fFoldable(,)_$celem
                                             Data.Foldable.$fFoldable(,)_$cminimum
                                             Data.Foldable.$fFoldable(,)_$cminimum
                                             Data.Foldable.$fFoldable(,)2
                                             Data.Foldable.$fFoldable(,)1];

Data.Foldable.$fFoldableEither_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> Data.Either.Either a1 a2 -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YJU eta_s6YJV]
        let {
          ds_s6YJW [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_a6LND -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YJU eta_s6YJV] \u []
                  GHC.Classes.== $dEq_s6YJU eta_s6YJV; } in
        let {
          sat_s6YK1 [Occ=Once]
            :: Data.Either.Either a_a6LM0 a1_a6LND
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [ds_s6YJW] \r [ds1_s6YJX]
                  case ds1_s6YJX of {
                    Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                    Data.Either.Right y_s6YK0 [Occ=Once] -> ds_s6YJW y_s6YK0;
                  };
        } in  sat_s6YK1;

Data.Foldable.$fFoldableEither2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Either.Either a1 a2 -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YK2 ds_s6YK3]
        case ds_s6YK3 of {
          Data.Either.Left _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YK2;
          Data.Either.Right y_s6YK6 [Occ=Once] -> y_s6YK6;
        };

Data.Foldable.$fFoldableEither3
  :: forall a1 a2. Data.Either.Either a2 a1 -> a1
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YK7]
        case x_s6YK7 of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:2;
          Data.Either.Right y_s6YKa [Occ=Once] -> y_s6YKa;
        };

Data.Foldable.$fFoldableEither_$cminimum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YKb eta_B1] Data.Foldable.$fFoldableEither3 eta_B1;

Data.Foldable.$fFoldableEither4
  :: forall a1 a2. Data.Either.Either a2 a1 -> a1
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YKc]
        case x_s6YKc of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:3;
          Data.Either.Right y_s6YKf [Occ=Once] -> y_s6YKf;
        };

Data.Foldable.$fFoldableEither_$cmaximum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YKg eta_B1] Data.Foldable.$fFoldableEither4 eta_B1;

Data.Foldable.$fFoldableEither_$cfoldr1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YKh xs_s6YKi]
        case xs_s6YKi of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:.:3;
          Data.Either.Right y_s6YKl [Occ=Once] -> y_s6YKl;
        };

Data.Foldable.$fFoldableEither_$cfoldl'
  :: forall a1 b a2.
     (b -> a2 -> b) -> b -> Data.Either.Either a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YKm z0_s6YKn xs_s6YKo]
        case xs_s6YKo of {
          Data.Either.Left _ [Occ=Dead] -> z0_s6YKn;
          Data.Either.Right y_s6YKr [Occ=Once] -> f_s6YKm z0_s6YKn y_s6YKr;
        };

Data.Foldable.$fFoldableEither_$cfoldl1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Either.Either a1 a2 -> a2
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YKs xs_s6YKt]
        case xs_s6YKt of {
          Data.Either.Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:.:2;
          Data.Either.Right y_s6YKw [Occ=Once] -> y_s6YKw;
        };

Data.Foldable.$fFoldableEither_$cfold
  :: forall a m. GHC.Base.Monoid m => Data.Either.Either a m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YKx ds_s6YKy]
        case ds_s6YKy of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Base.mempty $dMonoid_s6YKx;
          Data.Either.Right y_s6YKB [Occ=Once] -> y_s6YKB;
        };

Data.Foldable.$fFoldableEither1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Either.Either a1 a2 -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YKC ds_s6YKD]
        case ds_s6YKD of {
          Data.Either.Left _ [Occ=Dead] ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YKC;
          Data.Either.Right y_s6YKG [Occ=Once] -> y_s6YKG;
        };

Data.Foldable.$fFoldableEither_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. Data.Either.Either a1 a2 -> [a2]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6YKH]
        case eta_s6YKH of {
          Data.Either.Left _ [Occ=Dead] -> [] [];
          Data.Either.Right y_s6YKK [Occ=Once] -> : [y_s6YKK GHC.Types.[]];
        };

Data.Foldable.$fFoldableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable (Data.Either.Either a)
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableEither_$cfold
                                             Data.Foldable.$fFoldableEither_$cfoldMap
                                             Data.Foldable.$fFoldableEither_$cfoldr
                                             Data.Foldable.$fFoldableEither_$cfoldr
                                             Data.Foldable.$fFoldableEither_$cfoldl'
                                             Data.Foldable.$fFoldableEither_$cfoldl'
                                             Data.Foldable.$fFoldableEither_$cfoldr1
                                             Data.Foldable.$fFoldableEither_$cfoldl1
                                             Data.Foldable.$fFoldableEither_$ctoList
                                             Data.Either.isLeft
                                             Data.Foldable.$fFoldableEither_$clength
                                             Data.Foldable.$fFoldableEither_$celem
                                             Data.Foldable.$fFoldableEither_$cmaximum
                                             Data.Foldable.$fFoldableEither_$cminimum
                                             Data.Foldable.$fFoldableEither2
                                             Data.Foldable.$fFoldableEither1];

Data.Foldable.$fFoldableNonEmpty_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YKL eta_s6YKM]
        let {
          f_s6YKN [Dmd=<L,C(U)>] :: a_a6LQe -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YKL eta_s6YKM] \u []
                  GHC.Classes.== $dEq_s6YKL eta_s6YKM; } in
        let {
          sat_s6YL3 [Occ=OnceT[0]]
            :: GHC.Base.NonEmpty a_a6LQe -> GHC.Types.Bool
          [LclId] =
              [f_s6YKN] \r [ds_s6YKO]
                  let {
                    sat_s6YKS [Occ=Once] :: a_a6LQe
                    [LclId] =
                        [ds_s6YKO] \u []
                            case ds_s6YKO of {
                              GHC.Base.:| a1_s6YKQ [Occ=Once] _ [Occ=Dead] -> a1_s6YKQ;
                            };
                  } in 
                    case f_s6YKN sat_s6YKS of {
                      GHC.Types.False ->
                          case ds_s6YKO of {
                            GHC.Base.:| _ [Occ=Dead] as_s6YKW [Occ=Once] ->
                                let-no-escape {
                                  go_s6YKX [Occ=LoopBreakerT[1]] :: [a_a6LQe] -> GHC.Types.Bool
                                  [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                      sat-only [f_s6YKN go_s6YKX] \r [ds1_s6YKY]
                                          case ds1_s6YKY of {
                                            [] -> GHC.Types.False [];
                                            : y_s6YL0 [Occ=Once] ys_s6YL1 [Occ=Once] ->
                                                case f_s6YKN y_s6YL0 of {
                                                  GHC.Types.False -> go_s6YKX ys_s6YL1;
                                                  GHC.Types.True -> GHC.Types.True [];
                                                };
                                          };
                                } in  go_s6YKX as_s6YKW;
                          };
                      GHC.Types.True -> GHC.Types.True [];
                    };
        } in  sat_s6YL3;

Data.Foldable.$fFoldableNonEmpty_$csum
  :: forall a. GHC.Num.Num a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Str=<S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,1*C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YL4 ds_s6YL5]
        let {
          sat_s6YLk [Occ=Once] :: a_a6LQI
          [LclId] =
              [$dNum_s6YL4 ds_s6YL5] \u []
                  case ds_s6YL5 of {
                    GHC.Base.:| _ [Occ=Dead] as_s6YLc [Occ=Once] ->
                        let {
                          z_s6YLd [Occ=OnceL] :: a_a6LQI
                          [LclId] =
                              [$dNum_s6YL4] \u []
                                  GHC.Num.fromInteger
                                      $dNum_s6YL4 Data.Semigroup.Internal.$fMonoidSum1; } in
                        let {
                          go_s6YLe [Occ=LoopBreaker]
                            :: [a_a6LQI] -> Data.Semigroup.Internal.Sum a_a6LQI
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6YL4 z_s6YLd go_s6YLe] \r [ds1_s6YLf]
                                  case ds1_s6YLf of {
                                    [] -> z_s6YLd;
                                    : y_s6YLh [Occ=Once] ys_s6YLi [Occ=Once] ->
                                        let {
                                          sat_s6YLj [Occ=Once] :: a_a6LQI
                                          [LclId] =
                                              [go_s6YLe ys_s6YLi] \u [] go_s6YLe ys_s6YLi;
                                        } in  GHC.Num.+ $dNum_s6YL4 y_s6YLh sat_s6YLj;
                                  };
                        } in  go_s6YLe as_s6YLc;
                  }; } in
        let {
          sat_s6YL9 [Occ=Once] :: a_a6LQI
          [LclId] =
              [ds_s6YL5] \u []
                  case ds_s6YL5 of {
                    GHC.Base.:| a1_s6YL7 [Occ=Once] _ [Occ=Dead] -> a1_s6YL7;
                  };
        } in  GHC.Num.+ $dNum_s6YL4 sat_s6YL9 sat_s6YLk;

Data.Foldable.$w$cminimum1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6YLl ww_s6YLm ww1_s6YLn]
        let {
          go_s6YLo [Occ=LoopBreaker]
            :: [a_s6NYC] -> Data.Functor.Utils.Min a_s6NYC
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6YLl go_s6YLo] \r [ds_s6YLp]
                  case ds_s6YLp of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6YLr ys_s6YLs [Occ=Once] ->
                        case go_s6YLo ys_s6YLs of wild1_s6YLt {
                          GHC.Base.Nothing -> GHC.Base.Just [y_s6YLr];
                          GHC.Base.Just ipv_s6YLu [Occ=Once] ->
                              case GHC.Classes.<= w_s6YLl y_s6YLr ipv_s6YLu of {
                                GHC.Types.False -> wild1_s6YLt;
                                GHC.Types.True -> GHC.Base.Just [y_s6YLr];
                              };
                        };
                  };
        } in 
          case go_s6YLo ww1_s6YLn of {
            GHC.Base.Nothing -> ww_s6YLm;
            GHC.Base.Just ipv_s6YLx ->
                case GHC.Classes.<= w_s6YLl ww_s6YLm ipv_s6YLx of {
                  GHC.Types.False -> ipv_s6YLx;
                  GHC.Types.True -> ww_s6YLm;
                };
          };

Data.Foldable.$fFoldableNonEmpty_$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YLz w1_s6YLA]
        case w1_s6YLA of {
          GHC.Base.:| ww1_s6YLC [Occ=Once] ww2_s6YLD [Occ=Once] ->
              Data.Foldable.$w$cminimum1 w_s6YLz ww1_s6YLC ww2_s6YLD;
        };

Data.Foldable.$w$cmaximum1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6YLE ww_s6YLF ww1_s6YLG]
        let {
          go_s6YLH [Occ=LoopBreaker]
            :: [a_s6NYM] -> Data.Functor.Utils.Max a_s6NYM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6YLE go_s6YLH] \r [ds_s6YLI]
                  case ds_s6YLI of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6YLK ys_s6YLL [Occ=Once] ->
                        case go_s6YLH ys_s6YLL of wild1_s6YLM {
                          GHC.Base.Nothing -> GHC.Base.Just [y_s6YLK];
                          GHC.Base.Just ipv_s6YLN [Occ=Once] ->
                              case GHC.Classes.>= w_s6YLE y_s6YLK ipv_s6YLN of {
                                GHC.Types.False -> wild1_s6YLM;
                                GHC.Types.True -> GHC.Base.Just [y_s6YLK];
                              };
                        };
                  };
        } in 
          case go_s6YLH ww1_s6YLG of {
            GHC.Base.Nothing -> ww_s6YLF;
            GHC.Base.Just ipv_s6YLQ ->
                case GHC.Classes.>= w_s6YLE ww_s6YLF ipv_s6YLQ of {
                  GHC.Types.False -> ipv_s6YLQ;
                  GHC.Types.True -> ww_s6YLF;
                };
          };

Data.Foldable.$fFoldableNonEmpty_$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Classes.Ord a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YLS w1_s6YLT]
        case w1_s6YLT of {
          GHC.Base.:| ww1_s6YLV [Occ=Once] ww2_s6YLW [Occ=Once] ->
              Data.Foldable.$w$cmaximum1 w_s6YLS ww1_s6YLV ww2_s6YLW;
        };

Data.Foldable.$fFoldableNonEmpty_$cnull
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s6YLX] GHC.Types.False [];

Data.Foldable.$w$cfoldr2 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> a -> a) -> a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6YLY ww_s6YLZ ww1_s6YM0]
        let {
          go_s6YM1 [Occ=LoopBreaker] :: [a_s6NYW] -> GHC.Base.Maybe a_s6NYW
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6YLY go_s6YM1] \r [ds_s6YM2]
                  case ds_s6YM2 of {
                    [] -> GHC.Base.Nothing [];
                    : y_s6YM4 [Occ=Once*] ys_s6YM5 [Occ=Once] ->
                        let {
                          sat_s6YM8 [Occ=Once] :: a_s6NYW
                          [LclId] =
                              [w_s6YLY go_s6YM1 y_s6YM4 ys_s6YM5] \u []
                                  case go_s6YM1 ys_s6YM5 of {
                                    GHC.Base.Nothing -> y_s6YM4;
                                    GHC.Base.Just y1_s6YM7 [Occ=Once] -> w_s6YLY y_s6YM4 y1_s6YM7;
                                  };
                        } in  GHC.Base.Just [sat_s6YM8];
                  };
        } in 
          case go_s6YM1 ww1_s6YM0 of {
            GHC.Base.Nothing -> ww_s6YLZ;
            GHC.Base.Just y_s6YMa [Occ=Once] -> w_s6YLY ww_s6YLZ y_s6YMa;
          };

Data.Foldable.$fFoldableNonEmpty_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> a -> a) -> GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YMb w1_s6YMc]
        case w1_s6YMc of {
          GHC.Base.:| ww1_s6YMe [Occ=Once] ww2_s6YMf [Occ=Once] ->
              Data.Foldable.$w$cfoldr2 w_s6YMb ww1_s6YMe ww2_s6YMf;
        };

Data.Foldable.$w$cfoldl'1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6YMg w1_s6YMh ww_s6YMi ww1_s6YMj]
        case w_s6YMg w1_s6YMh ww_s6YMi of vx_s6YMk {
          __DEFAULT ->
              let-no-escape {
                go_s6YMl [Occ=LoopBreakerT[2]] :: [a_s6NZ8] -> b_s6NZ7 -> b_s6NZ7
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [w_s6YMg go_s6YMl] \r [ds_s6YMm eta_s6YMn]
                        case ds_s6YMm of {
                          [] -> eta_s6YMn;
                          : y_s6YMp [Occ=Once] ys_s6YMq [Occ=Once] ->
                              case w_s6YMg eta_s6YMn y_s6YMp of vx1_s6YMr {
                                __DEFAULT -> go_s6YMl ys_s6YMq vx1_s6YMr;
                              };
                        };
              } in  go_s6YMl ww1_s6YMj vx_s6YMk;
        };

Data.Foldable.$fFoldableNonEmpty_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YMs w1_s6YMt w2_s6YMu]
        case w2_s6YMu of {
          GHC.Base.:| ww1_s6YMw [Occ=Once] ww2_s6YMx [Occ=Once] ->
              Data.Foldable.$w$cfoldl'1 w_s6YMs w1_s6YMt ww1_s6YMw ww2_s6YMx;
        };

Data.Foldable.$w$cfoldr'1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6YMy w1_s6YMz ww_s6YMA ww1_s6YMB]
        let {
          sat_s6YMN [Occ=Once] :: b_s6NZm -> b_s6NZm
          [LclId] =
              [w_s6YMy ww_s6YMA] \r [z_s6YMM] w_s6YMy ww_s6YMA z_s6YMM;
        } in 
          let-no-escape {
            go_s6YMC [Occ=LoopBreakerT[3]]
              :: [a_s6NZl] -> (b_s6NZm -> b_s6NZm) -> b_s6NZm -> b_s6NZm
            [LclId[JoinId(3)],
             Arity=3,
             Str=<S,1*U><C(S),1*C1(U)><L,U>,
             Unf=OtherCon []] =
                sat-only [w_s6YMy go_s6YMC] \r [ds_s6YMD eta_s6YME eta1_s6YMF]
                    case ds_s6YMD of {
                      [] -> eta_s6YME eta1_s6YMF;
                      : y_s6YMH [Occ=Once] ys_s6YMI [Occ=Once] ->
                          let {
                            sat_s6YML [Occ=Once] :: b_s6NZm -> b_s6NZm
                            [LclId] =
                                [w_s6YMy eta_s6YME y_s6YMH] \r [z_s6YMJ]
                                    case w_s6YMy y_s6YMH z_s6YMJ of vx_s6YMK {
                                      __DEFAULT -> eta_s6YME vx_s6YMK;
                                    };
                          } in  go_s6YMC ys_s6YMI sat_s6YML eta1_s6YMF;
                    };
          } in  go_s6YMC ww1_s6YMB sat_s6YMN w1_s6YMz;

Data.Foldable.$fFoldableNonEmpty_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> b) -> b -> GHC.Base.NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6YMO w1_s6YMP w2_s6YMQ]
        case w2_s6YMQ of {
          GHC.Base.:| ww1_s6YMS [Occ=Once] ww2_s6YMT [Occ=Once] ->
              Data.Foldable.$w$cfoldr'1 w_s6YMO w1_s6YMP ww1_s6YMS ww2_s6YMT;
        };

Data.Foldable.$fFoldableNonEmpty_$cproduct
  :: forall a. GHC.Num.Num a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Str=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,1*C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YMU ds_s6YMV]
        let {
          sat_s6YNa [Occ=Once] :: a_a6LQS
          [LclId] =
              [$dNum_s6YMU ds_s6YMV] \u []
                  case ds_s6YMV of {
                    GHC.Base.:| _ [Occ=Dead] as_s6YN2 [Occ=Once] ->
                        let {
                          z_s6YN3 [Occ=OnceL] :: a_a6LQS
                          [LclId] =
                              [$dNum_s6YMU] \u []
                                  GHC.Num.fromInteger
                                      $dNum_s6YMU Data.Semigroup.Internal.$fMonoidProduct1; } in
                        let {
                          go_s6YN4 [Occ=LoopBreaker]
                            :: [a_a6LQS] -> Data.Semigroup.Internal.Product a_a6LQS
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dNum_s6YMU z_s6YN3 go_s6YN4] \r [ds1_s6YN5]
                                  case ds1_s6YN5 of {
                                    [] -> z_s6YN3;
                                    : y_s6YN7 [Occ=Once] ys_s6YN8 [Occ=Once] ->
                                        let {
                                          sat_s6YN9 [Occ=Once] :: a_a6LQS
                                          [LclId] =
                                              [go_s6YN4 ys_s6YN8] \u [] go_s6YN4 ys_s6YN8;
                                        } in  GHC.Num.* $dNum_s6YMU y_s6YN7 sat_s6YN9;
                                  };
                        } in  go_s6YN4 as_s6YN2;
                  }; } in
        let {
          sat_s6YMZ [Occ=Once] :: a_a6LQS
          [LclId] =
              [ds_s6YMV] \u []
                  case ds_s6YMV of {
                    GHC.Base.:| a1_s6YMX [Occ=Once] _ [Occ=Dead] -> a1_s6YMX;
                  };
        } in  GHC.Num.* $dNum_s6YMU sat_s6YMZ sat_s6YNa;

Data.Foldable.$fFoldableNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Base.NonEmpty
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableNonEmpty_$cfold
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldMap
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr'
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl'
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldr1
                                             Data.Foldable.$fFoldableNonEmpty_$cfoldl1
                                             Data.Foldable.$fFoldableNonEmpty_$ctoList
                                             Data.Foldable.$fFoldableNonEmpty_$cnull
                                             Data.Foldable.$fFoldableNonEmpty_$clength
                                             Data.Foldable.$fFoldableNonEmpty_$celem
                                             Data.Foldable.$fFoldableNonEmpty_$cmaximum
                                             Data.Foldable.$fFoldableNonEmpty_$cminimum
                                             Data.Foldable.$fFoldableNonEmpty_$csum
                                             Data.Foldable.$fFoldableNonEmpty_$cproduct];

Data.Foldable.$fFoldableMaybe_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YNb eta_s6YNc]
        let {
          eta1_s6YNd [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LV4 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YNb eta_s6YNc] \u []
                  GHC.Classes.== $dEq_s6YNb eta_s6YNc; } in
        let {
          sat_s6YNh [Occ=Once]
            :: GHC.Base.Maybe a_a6LV4 -> Data.Semigroup.Internal.Any
          [LclId] =
              [eta1_s6YNd] \r [eta2_s6YNe]
                  case eta2_s6YNe of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x_s6YNg [Occ=Once] -> eta1_s6YNd x_s6YNg;
                  };
        } in  sat_s6YNh;

Data.Foldable.$fFoldableMaybe2
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Maybe a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YNi eta_s6YNj]
        case eta_s6YNj of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YNi;
          GHC.Base.Just x_s6YNl [Occ=Once] -> x_s6YNl;
        };

Data.Foldable.$fFoldableMaybe3 :: forall a. GHC.Base.Maybe a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YNm]
        case x_s6YNm of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6YNo [Occ=Once] -> v_s6YNo;
        };

Data.Foldable.$fFoldableMaybe_$cminimum
  :: forall a. GHC.Classes.Ord a => GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YNp eta_B1] Data.Foldable.$fFoldableMaybe3 eta_B1;

Data.Foldable.$fFoldableMaybe4 :: forall a. GHC.Base.Maybe a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YNq]
        case x_s6YNq of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6YNs [Occ=Once] -> v_s6YNs;
        };

Data.Foldable.$fFoldableMaybe_$cmaximum
  :: forall a. GHC.Classes.Ord a => GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YNt eta_B1] Data.Foldable.$fFoldableMaybe4 eta_B1;

Data.Foldable.$fFoldableMaybe_$cnull
  :: forall a. GHC.Base.Maybe a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6YNu]
        case ds_s6YNu of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableMaybe_$cfoldl1
  :: forall a. (a -> a -> a) -> GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YNx xs_s6YNy]
        case xs_s6YNy of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just v_s6YNA [Occ=Once] -> v_s6YNA;
        };

Data.Foldable.$fFoldableMaybe_$cfoldr1
  :: forall a. (a -> a -> a) -> GHC.Base.Maybe a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YNB xs_s6YNC]
        case xs_s6YNC of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just v_s6YNE [Occ=Once] -> v_s6YNE;
        };

Data.Foldable.$fFoldableMaybe_$clength
  :: forall a. GHC.Base.Maybe a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6YNF]
        case xs_s6YNF of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableMaybe_$cfold
  :: forall m. GHC.Base.Monoid m => GHC.Base.Maybe m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YNI eta_s6YNJ]
        case eta_s6YNJ of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YNI;
          GHC.Base.Just x_s6YNL [Occ=Once] -> x_s6YNL;
        };

Data.Foldable.$fFoldableMaybe1
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Maybe a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YNM eta_s6YNN]
        case eta_s6YNN of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YNM;
          GHC.Base.Just x_s6YNP [Occ=Once] -> x_s6YNP;
        };

Data.Foldable.$fFoldableMaybe_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Base.Maybe a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6YNQ]
        case eta_s6YNQ of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6YNS [Occ=Once] -> : [x_s6YNS GHC.Types.[]];
        };

Data.Foldable.$fFoldableMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable GHC.Base.Maybe
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableMaybe_$cfold
                                             Data.Foldable.$fFoldableMaybe_$cfoldMap
                                             Data.Foldable.$fFoldableMaybe_$cfoldr
                                             Data.Foldable.$fFoldableMaybe_$cfoldr
                                             Data.Foldable.$fFoldableMaybe_$cfoldl
                                             Data.Foldable.$fFoldableMaybe_$cfoldl
                                             Data.Foldable.$fFoldableMaybe_$cfoldr1
                                             Data.Foldable.$fFoldableMaybe_$cfoldl1
                                             Data.Foldable.$fFoldableMaybe_$ctoList
                                             Data.Foldable.$fFoldableMaybe_$cnull
                                             Data.Foldable.$fFoldableMaybe_$clength
                                             Data.Foldable.$fFoldableMaybe_$celem
                                             Data.Foldable.$fFoldableMaybe_$cmaximum
                                             Data.Foldable.$fFoldableMaybe_$cminimum
                                             Data.Foldable.$fFoldableMaybe2
                                             Data.Foldable.$fFoldableMaybe1];

Data.Foldable.$fFoldableLast_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Monoid.Last a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YNT f_s6YNU x_s6YNV]
        case x_s6YNV of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YNT;
          GHC.Base.Just x1_s6YNX [Occ=Once] -> f_s6YNU x1_s6YNX;
        };

Data.Foldable.$fFoldableLast_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Monoid.Last m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YNY x_s6YNZ]
        case x_s6YNZ of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YNY;
          GHC.Base.Just x1_s6YO1 [Occ=Once] -> x1_s6YO1;
        };

Data.Foldable.$fFoldableLast2
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.Last a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YO2 x_s6YO3]
        case x_s6YO3 of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YO2;
          GHC.Base.Just x1_s6YO5 [Occ=Once] -> x1_s6YO5;
        };

Data.Foldable.$fFoldableLast3 :: forall a. Data.Monoid.Last a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YO6]
        case x_s6YO6 of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6YO8 [Occ=Once] -> v_s6YO8;
        };

Data.Foldable.$fFoldableLast_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YO9 eta_B1] Data.Foldable.$fFoldableLast3 eta_B1;

Data.Foldable.$fFoldableLast4 :: forall a. Data.Monoid.Last a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YOa]
        case x_s6YOa of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6YOc [Occ=Once] -> v_s6YOc;
        };

Data.Foldable.$fFoldableLast_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YOd eta_B1] Data.Foldable.$fFoldableLast4 eta_B1;

Data.Foldable.$fFoldableLast_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Monoid.Last a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YOe eta_s6YOf]
        let {
          f_s6YOg [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6LuI -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YOe eta_s6YOf] \u []
                  GHC.Classes.== $dEq_s6YOe eta_s6YOf; } in
        let {
          sat_s6YOk [Occ=Once]
            :: Data.Monoid.Last a_a6LuI -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6YOg] \r [x_s6YOh]
                  case x_s6YOh of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x1_s6YOj [Occ=Once] -> f_s6YOg x1_s6YOj;
                  };
        } in  sat_s6YOk;

Data.Foldable.$fFoldableLast_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Monoid.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YOl z_s6YOm t_s6YOn]
        case t_s6YOn of {
          GHC.Base.Nothing -> z_s6YOm;
          GHC.Base.Just x_s6YOp [Occ=Once] -> f_s6YOl z_s6YOm x_s6YOp;
        };

Data.Foldable.$fFoldableLast_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YOq xs_s6YOr]
        case xs_s6YOr of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just x_s6YOt [Occ=Once] -> x_s6YOt;
        };

Data.Foldable.$fFoldableLast_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Monoid.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YOu z0_s6YOv xs_s6YOw]
        case xs_s6YOw of {
          GHC.Base.Nothing -> z0_s6YOv;
          GHC.Base.Just x_s6YOy [Occ=Once] -> f_s6YOu x_s6YOy z0_s6YOv;
        };

Data.Foldable.$fFoldableLast_$clength
  :: forall a. Data.Monoid.Last a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6YOz]
        case xs_s6YOz of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableLast_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Monoid.Last a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YOC xs_s6YOD]
        case xs_s6YOD of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just x_s6YOF [Occ=Once] -> x_s6YOF;
        };

Data.Foldable.$fFoldableLast_$cnull
  :: forall a. Data.Monoid.Last a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t_s6YOG]
        case t_s6YOG of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableLast1
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.Last a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YOJ x_s6YOK]
        case x_s6YOK of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YOJ;
          GHC.Base.Just x1_s6YOM [Occ=Once] -> x1_s6YOM;
        };

Data.Foldable.$fFoldableLast_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Monoid.Last a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6YON]
        case eta_s6YON of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6YOP [Occ=Once] -> : [x_s6YOP GHC.Types.[]];
        };

Data.Foldable.$fFoldableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Monoid.Last
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableLast_$cfold
                                             Data.Foldable.$fFoldableLast_$cfoldMap
                                             Data.Foldable.$fFoldableLast_$cfoldr'
                                             Data.Foldable.$fFoldableLast_$cfoldr'
                                             Data.Foldable.$fFoldableLast_$cfoldl
                                             Data.Foldable.$fFoldableLast_$cfoldl
                                             Data.Foldable.$fFoldableLast_$cfoldr1
                                             Data.Foldable.$fFoldableLast_$cfoldl1
                                             Data.Foldable.$fFoldableLast_$ctoList
                                             Data.Foldable.$fFoldableLast_$cnull
                                             Data.Foldable.$fFoldableLast_$clength
                                             Data.Foldable.$fFoldableLast_$celem
                                             Data.Foldable.$fFoldableLast_$cmaximum
                                             Data.Foldable.$fFoldableLast_$cminimum
                                             Data.Foldable.$fFoldableLast2
                                             Data.Foldable.$fFoldableLast1];

Data.Foldable.$fFoldableFirst_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Monoid.First a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YOQ f_s6YOR x_s6YOS]
        case x_s6YOS of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YOQ;
          GHC.Base.Just x1_s6YOU [Occ=Once] -> f_s6YOR x1_s6YOU;
        };

Data.Foldable.$fFoldableFirst_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Monoid.First m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6YOV x_s6YOW]
        case x_s6YOW of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_s6YOV;
          GHC.Base.Just x1_s6YOY [Occ=Once] -> x1_s6YOY;
        };

Data.Foldable.$fFoldableFirst2
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.First a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YOZ x_s6YP0]
        case x_s6YP0 of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6YOZ;
          GHC.Base.Just x1_s6YP2 [Occ=Once] -> x1_s6YP2;
        };

Data.Foldable.$fFoldableFirst3
  :: forall a. Data.Monoid.First a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YP3]
        case x_s6YP3 of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
          GHC.Base.Just v_s6YP5 [Occ=Once] -> v_s6YP5;
        };

Data.Foldable.$fFoldableFirst_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YP6 eta_B1] Data.Foldable.$fFoldableFirst3 eta_B1;

Data.Foldable.$fFoldableFirst4
  :: forall a. Data.Monoid.First a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6YP7]
        case x_s6YP7 of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
          GHC.Base.Just v_s6YP9 [Occ=Once] -> v_s6YP9;
        };

Data.Foldable.$fFoldableFirst_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_s6YPa eta_B1] Data.Foldable.$fFoldableFirst4 eta_B1;

Data.Foldable.$fFoldableFirst_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Monoid.First a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s6YPb eta_s6YPc]
        let {
          f_s6YPd [Occ=OnceL!, Dmd=<L,C(U)>] :: a_a6Lxh -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6YPb eta_s6YPc] \u []
                  GHC.Classes.== $dEq_s6YPb eta_s6YPc; } in
        let {
          sat_s6YPh [Occ=Once]
            :: Data.Monoid.First a_a6Lxh -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_s6YPd] \r [x_s6YPe]
                  case x_s6YPe of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just x1_s6YPg [Occ=Once] -> f_s6YPd x1_s6YPg;
                  };
        } in  sat_s6YPh;

Data.Foldable.$fFoldableFirst_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Monoid.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YPi z_s6YPj t_s6YPk]
        case t_s6YPk of {
          GHC.Base.Nothing -> z_s6YPj;
          GHC.Base.Just x_s6YPm [Occ=Once] -> f_s6YPi z_s6YPj x_s6YPm;
        };

Data.Foldable.$fFoldableFirst_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YPn xs_s6YPo]
        case xs_s6YPo of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
          GHC.Base.Just x_s6YPq [Occ=Once] -> x_s6YPq;
        };

Data.Foldable.$fFoldableFirst_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Monoid.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s6YPr z0_s6YPs xs_s6YPt]
        case xs_s6YPt of {
          GHC.Base.Nothing -> z0_s6YPs;
          GHC.Base.Just x_s6YPv [Occ=Once] -> f_s6YPr x_s6YPv z0_s6YPs;
        };

Data.Foldable.$fFoldableFirst_$clength
  :: forall a. Data.Monoid.First a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_s6YPw]
        case xs_s6YPw of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:4;
          GHC.Base.Just _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3;
        };

Data.Foldable.$fFoldableFirst_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Monoid.First a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_s6YPz xs_s6YPA]
        case xs_s6YPA of {
          GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
          GHC.Base.Just x_s6YPC [Occ=Once] -> x_s6YPC;
        };

Data.Foldable.$fFoldableFirst_$cnull
  :: forall a. Data.Monoid.First a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t_s6YPD]
        case t_s6YPD of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Foldable.$fFoldableFirst1
  :: forall a.
     GHC.Num.Num a =>
     Data.Monoid.First a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6YPG x_s6YPH]
        case x_s6YPH of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6YPG;
          GHC.Base.Just x1_s6YPJ [Occ=Once] -> x1_s6YPJ;
        };

Data.Foldable.$fFoldableFirst_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Monoid.First a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_s6YPK]
        case eta_s6YPK of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just x_s6YPM [Occ=Once] -> : [x_s6YPM GHC.Types.[]];
        };

Data.Foldable.$fFoldableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Monoid.First
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Foldable.$fFoldableFirst_$cfold
                                             Data.Foldable.$fFoldableFirst_$cfoldMap
                                             Data.Foldable.$fFoldableFirst_$cfoldr'
                                             Data.Foldable.$fFoldableFirst_$cfoldr'
                                             Data.Foldable.$fFoldableFirst_$cfoldl
                                             Data.Foldable.$fFoldableFirst_$cfoldl
                                             Data.Foldable.$fFoldableFirst_$cfoldr1
                                             Data.Foldable.$fFoldableFirst_$cfoldl1
                                             Data.Foldable.$fFoldableFirst_$ctoList
                                             Data.Foldable.$fFoldableFirst_$cnull
                                             Data.Foldable.$fFoldableFirst_$clength
                                             Data.Foldable.$fFoldableFirst_$celem
                                             Data.Foldable.$fFoldableFirst_$cmaximum
                                             Data.Foldable.$fFoldableFirst_$cminimum
                                             Data.Foldable.$fFoldableFirst2
                                             Data.Foldable.$fFoldableFirst1];

Data.Foldable.all1
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> Data.Semigroup.Internal.All
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YPN p_s6YPO]
        Data.Foldable.foldMap
            $dFoldable_s6YPN Data.Semigroup.Internal.$fMonoidAll p_s6YPO;

Data.Foldable.all
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Foldable.all1 eta_B2 eta_B1;

Data.Foldable.$fFoldable:.:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*U,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YPP $dFoldable1_s6YPQ ds_s6YPR]
        let {
          sat_s6YPS [Occ=Once]
            :: g_a6L4V a_a6L6K -> Data.Semigroup.Internal.All
          [LclId] =
              [$dFoldable1_s6YPQ] \u [] Data.Foldable.null $dFoldable1_s6YPQ;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YPP
              Data.Semigroup.Internal.$fMonoidAll
              sat_s6YPS
              ds_s6YPR;

Data.Foldable.$fFoldable:.:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m. GHC.Base.Monoid m => (GHC.Generics.:.:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YPT $dFoldable1_s6YPU $dMonoid_s6YPV ds_s6YPW]
        let {
          sat_s6YPX [Occ=Once] :: g_X6Lnv m_a6L51 -> m_a6L51
          [LclId] =
              [$dFoldable1_s6YPU $dMonoid_s6YPV] \u []
                  Data.Foldable.foldMap $dFoldable1_s6YPU $dMonoid_s6YPV GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YPT $dMonoid_s6YPV sat_s6YPX ds_s6YPW;

Data.Foldable.$fFoldable:.:_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YPY $dFoldable1_s6YPZ $dNum_s6YQ0]
        let {
          $dMonoid_s6YQ1
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_a6L7y)
          [LclId] =
              [$dNum_s6YQ0] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_s6YQ0; } in
        let {
          lvl1_s6YQ2 [Occ=OnceL]
            :: g_X6Lnu a_a6L7y -> Data.Semigroup.Internal.Sum a_a6L7y
          [LclId] =
              [$dFoldable1_s6YPZ $dMonoid_s6YQ1] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6YPZ $dMonoid_s6YQ1 Data.Foldable.$fFoldable:*:1; } in
        let {
          sat_s6YQ4 [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lns g_X6Lnu a_a6L7y
               -> Data.Semigroup.Internal.Sum a_a6L7y
          [LclId] =
              [$dFoldable_s6YPY $dMonoid_s6YQ1 lvl1_s6YQ2] \r [ds_s6YQ3]
                  Data.Foldable.foldMap
                      $dFoldable_s6YPY $dMonoid_s6YQ1 lvl1_s6YQ2 ds_s6YQ3;
        } in  sat_s6YQ4;

Data.Foldable.$fFoldable:.:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQ5 $dFoldable1_s6YQ6 $dOrd_s6YQ7]
        let {
          $dMonoid_s6YQ8 :: GHC.Base.Monoid (Data.Functor.Utils.Min a_a6L7o)
          [LclId] =
              [$dOrd_s6YQ7] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_s6YQ7; } in
        let {
          lvl1_s6YQ9 [Occ=OnceL]
            :: g_X6Lnt a_a6L7o -> Data.Functor.Utils.Min a_a6L7o
          [LclId] =
              [$dFoldable1_s6YQ6 $dMonoid_s6YQ8] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6YQ6 $dMonoid_s6YQ8 GHC.Base.Just; } in
        let {
          sat_s6YQd [Occ=OnceT[0]]
            :: (GHC.Generics.:.:) f_X6Lnr g_X6Lnt a_a6L7o -> a_a6L7o
          [LclId] =
              [$dFoldable_s6YQ5 $dMonoid_s6YQ8 lvl1_s6YQ9] \r [x_s6YQa]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YQ5 $dMonoid_s6YQ8 lvl1_s6YQ9 x_s6YQa
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:2;
                    GHC.Base.Just v_s6YQc [Occ=Once] -> v_s6YQc;
                  };
        } in  sat_s6YQd;

Data.Foldable.$fFoldable:.:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Classes.Ord a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQe $dFoldable1_s6YQf $dOrd_s6YQg]
        let {
          $dMonoid_s6YQh :: GHC.Base.Monoid (Data.Functor.Utils.Max a_a6L7e)
          [LclId] =
              [$dOrd_s6YQg] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_s6YQg; } in
        let {
          lvl1_s6YQi [Occ=OnceL]
            :: g_X6Lns a_a6L7e -> Data.Functor.Utils.Max a_a6L7e
          [LclId] =
              [$dFoldable1_s6YQf $dMonoid_s6YQh] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6YQf $dMonoid_s6YQh GHC.Base.Just; } in
        let {
          sat_s6YQm [Occ=OnceT[0]]
            :: (GHC.Generics.:.:) f_X6Lnq g_X6Lns a_a6L7e -> a_a6L7e
          [LclId] =
              [$dFoldable_s6YQe $dMonoid_s6YQh lvl1_s6YQi] \r [x_s6YQj]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_s6YQe $dMonoid_s6YQh lvl1_s6YQi x_s6YQj
                  of
                  { GHC.Base.Nothing -> Data.Foldable.$fFoldable:*:3;
                    GHC.Base.Just v_s6YQl [Occ=Once] -> v_s6YQl;
                  };
        } in  sat_s6YQm;

Data.Foldable.$fFoldable:.:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> (GHC.Generics.:.:) f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQn $dFoldable1_s6YQo $dEq_s6YQp eta_s6YQq]
        let {
          lvl1_s6YQr [Occ=OnceL]
            :: g_X6Lnr a_a6L74 -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable1_s6YQo $dEq_s6YQp eta_s6YQq] \u []
                  let {
                    sat_s6YQs [Occ=Once] :: a_a6L74 -> Data.Semigroup.Internal.Any
                    [LclId] =
                        [$dEq_s6YQp eta_s6YQq] \u [] GHC.Classes.== $dEq_s6YQp eta_s6YQq;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6YQo
                        Data.Semigroup.Internal.$fMonoidAny
                        sat_s6YQs; } in
        let {
          sat_s6YQu [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lnp g_X6Lnr a_a6L74
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_s6YQn lvl1_s6YQr] \r [ds_s6YQt]
                  Data.Foldable.foldMap
                      $dFoldable_s6YQn
                      Data.Semigroup.Internal.$fMonoidAny
                      lvl1_s6YQr
                      ds_s6YQt;
        } in  sat_s6YQu;

Data.Foldable.$fFoldable:.:_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQv $dFoldable1_s6YQw f1_s6YQx xs_s6YQy]
        let {
          f2_s6YQz [Occ=OnceL]
            :: a_a6L6m -> GHC.Base.Maybe a_a6L6m -> GHC.Base.Maybe a_a6L6m
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [f1_s6YQx] \r [x_s6YQA m_s6YQB]
                  let {
                    sat_s6YQE [Occ=Once] :: a_a6L6m
                    [LclId] =
                        [f1_s6YQx x_s6YQA m_s6YQB] \u []
                            case m_s6YQB of {
                              GHC.Base.Nothing -> x_s6YQA;
                              GHC.Base.Just y_s6YQD [Occ=Once] -> f1_s6YQx x_s6YQA y_s6YQD;
                            };
                  } in  GHC.Base.Just [sat_s6YQE]; } in
        let {
          sat_s6YQH [Occ=Once]
            :: g_X6Lno a_a6L6m
               -> GHC.Base.Maybe a_a6L6m -> GHC.Base.Maybe a_a6L6m
          [LclId] =
              [$dFoldable1_s6YQw f2_s6YQz] \r [b1_s6YQF b2_s6YQG]
                  Data.Foldable.foldr $dFoldable1_s6YQw f2_s6YQz b2_s6YQG b1_s6YQF;
        } in 
          case
              Data.Foldable.foldr
                  $dFoldable_s6YQv sat_s6YQH GHC.Base.Nothing xs_s6YQy
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:3;
            GHC.Base.Just v_s6YQJ [Occ=Once] -> v_s6YQJ;
          };

Data.Foldable.$fFoldable:.:_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQK
           $dFoldable1_s6YQL
           f1_s6YQM
           z0_s6YQN
           xs_s6YQO]
        let {
          f2_s6YQP [Occ=OnceL]
            :: a_a6L6d -> (b_a6L6c -> b_a6L6c) -> b_a6L6c -> b_a6L6c
          [LclId, Arity=3, Str=<L,U><C(S),1*C1(U)><L,U>, Unf=OtherCon []] =
              [f1_s6YQM] \r [x_s6YQQ k_s6YQR z_s6YQS]
                  case f1_s6YQM z_s6YQS x_s6YQQ of vx_s6YQT {
                    __DEFAULT -> k_s6YQR vx_s6YQT;
                  }; } in
        let {
          sat_s6YQW [Occ=Once]
            :: g_X6Lnn a_a6L6d -> (b_a6L6c -> b_a6L6c) -> b_a6L6c -> b_a6L6c
          [LclId] =
              [$dFoldable1_s6YQL f2_s6YQP] \r [b1_s6YQU b2_s6YQV]
                  Data.Foldable.foldr $dFoldable1_s6YQL f2_s6YQP b2_s6YQV b1_s6YQU;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6YQK sat_s6YQW GHC.Base.id xs_s6YQO z0_s6YQN;

Data.Foldable.$fFoldable:.:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YQX $dFoldable1_s6YQY eta_s6YQZ]
        Data.Foldable.$fFoldable:.:_$cfoldl'
            $dFoldable_s6YQX
            $dFoldable1_s6YQY
            Data.Foldable.$fFoldable:*:5
            Data.Foldable.$fFoldable:*:4
            eta_s6YQZ;

Data.Foldable.$fFoldable:.:_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YR0 $dFoldable1_s6YR1 f1_s6YR2 z_s6YR3 t_s6YR4]
        let {
          sat_s6YR8 [Occ=Once]
            :: g_X6Lnm a_a6L63
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_a6L62)
          [LclId] =
              [$dFoldable1_s6YR1 f1_s6YR2] \u []
                  let {
                    sat_s6YR7 [Occ=Once]
                      :: a_a6L63
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo b_a6L62)
                    [LclId] =
                        [f1_s6YR2] \r [x_s6YR5 y_s6YR6] f1_s6YR2 y_s6YR6 x_s6YR5;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6YR1 Data.Foldable.$fFoldable:*:7 sat_s6YR7;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YR0
              Data.Foldable.$fFoldable:*:7
              sat_s6YR8
              t_s6YR4
              z_s6YR3;

Data.Foldable.$fFoldable:.:_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YR9 $dFoldable1_s6YRa f1_s6YRb xs_s6YRc]
        let {
          sat_s6YRj [Occ=Once]
            :: g_X6Lnp a_a6L6u
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6L6u))
          [LclId] =
              [$dFoldable1_s6YRa f1_s6YRb] \u []
                  let {
                    sat_s6YRi [Occ=Once]
                      :: a_a6L6u
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_a6L6u))
                    [LclId] =
                        [f1_s6YRb] \r [x_s6YRd y_s6YRe]
                            let {
                              sat_s6YRh [Occ=Once] :: a_a6L6u
                              [LclId] =
                                  [f1_s6YRb x_s6YRd y_s6YRe] \u []
                                      case y_s6YRe of {
                                        GHC.Base.Nothing -> x_s6YRd;
                                        GHC.Base.Just x1_s6YRg [Occ=Once] ->
                                            f1_s6YRb x1_s6YRg x_s6YRd;
                                      };
                            } in  GHC.Base.Just [sat_s6YRh];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6YRa Data.Foldable.$fFoldable:*:7 sat_s6YRi;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_s6YR9
                  Data.Foldable.$fFoldable:*:7
                  sat_s6YRj
                  xs_s6YRc
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Foldable.$fFoldable:.:2;
            GHC.Base.Just v_s6YRl [Occ=Once] -> v_s6YRl;
          };

Data.Foldable.$fFoldable:.:_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (GHC.Generics.:.:) f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YRm
           $dFoldable1_s6YRn
           f1_s6YRo
           z0_s6YRp
           xs_s6YRq]
        let {
          sat_s6YRw [Occ=Once]
            :: g_X6Lnl a_a6L5S
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_a6L5T -> b_a6L5T))
          [LclId] =
              [$dFoldable1_s6YRn f1_s6YRo] \u []
                  let {
                    sat_s6YRv [Occ=Once]
                      :: a_a6L5S
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (b_a6L5T -> b_a6L5T))
                    [LclId] =
                        [f1_s6YRo] \r [x_s6YRr y_s6YRs z_s6YRt]
                            case f1_s6YRo x_s6YRr z_s6YRt of vx_s6YRu {
                              __DEFAULT -> y_s6YRs vx_s6YRu;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_s6YRn Data.Foldable.$fFoldable:*:7 sat_s6YRv;
        } in 
          Data.Foldable.foldMap
              $dFoldable_s6YRm
              Data.Foldable.$fFoldable:*:7
              sat_s6YRw
              xs_s6YRq
              GHC.Base.id
              z0_s6YRp;

Data.Foldable.$fFoldable:.:_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => (GHC.Generics.:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YRx $dFoldable1_s6YRy $dNum_s6YRz]
        let {
          $dMonoid_s6YRA
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_a6L7I)
          [LclId] =
              [$dNum_s6YRz] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_s6YRz; } in
        let {
          lvl1_s6YRB [Occ=OnceL]
            :: g_X6Lnk a_a6L7I -> Data.Semigroup.Internal.Product a_a6L7I
          [LclId] =
              [$dFoldable1_s6YRy $dMonoid_s6YRA] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_s6YRy $dMonoid_s6YRA Data.Foldable.$fFoldable:*:1; } in
        let {
          sat_s6YRD [Occ=Once]
            :: (GHC.Generics.:.:) f_X6Lni g_X6Lnk a_a6L7I
               -> Data.Semigroup.Internal.Product a_a6L7I
          [LclId] =
              [$dFoldable_s6YRx $dMonoid_s6YRA lvl1_s6YRB] \r [ds_s6YRC]
                  Data.Foldable.foldMap
                      $dFoldable_s6YRx $dMonoid_s6YRA lvl1_s6YRB ds_s6YRC;
        } in  sat_s6YRD;

Data.Foldable.$fFoldable:.:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (GHC.Generics.:.:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YRE $dFoldable1_s6YRF eta_s6YRG]
        let {
          sat_s6YRJ [Occ=Once] :: g_X6Lnj a_a6L6C -> [a_a6L6C] -> [a_a6L6C]
          [LclId] =
              [$dFoldable1_s6YRF] \r [b1_s6YRH b2_s6YRI]
                  Data.Foldable.foldr
                      $dFoldable1_s6YRF GHC.Types.: b2_s6YRI b1_s6YRH;
        } in 
          Data.Foldable.foldr
              $dFoldable_s6YRE sat_s6YRJ GHC.Types.[] eta_s6YRG;

Data.Foldable.$fFoldable:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_s6YRK $dFoldable1_s6YRL]
        let {
          sat_s6YS1 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cproduct
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YS0 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$csum
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRZ [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cminimum
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRY [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$cmaximum
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRX [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$celem
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B2 eta_B1; } in
        let {
          sat_s6YRW [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$clength
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRV [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:1
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRU [Occ=Once]
            :: forall a. (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> [a]
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B1]
                  Data.Foldable.$fFoldable:.:_$ctoList
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B1; } in
        let {
          sat_s6YRT [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl1
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B2 eta_B1; } in
        let {
          sat_s6YRS [Occ=Once]
            :: forall a.
               (a -> a -> a) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> a
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr1
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B2 eta_B1; } in
        let {
          sat_s6YRR [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl'
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YRQ [Occ=Once]
            :: forall b a.
               (b -> a -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldl
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YRP [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr'
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YRO [Occ=Once]
            :: forall a b.
               (a -> b -> b) -> b -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> b
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldr
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YRN [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> (GHC.Generics.:.:) f_X6Lng g_X6Lni a -> m
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B3 eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfoldMap
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6YRM [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               (GHC.Generics.:.:) f_X6Lng g_X6Lni m -> m
          [LclId] =
              [$dFoldable_s6YRK $dFoldable1_s6YRL] \r [eta_B2 eta_B1]
                  Data.Foldable.$fFoldable:.:_$cfold
                      $dFoldable_s6YRK $dFoldable1_s6YRL eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_s6YRM
                                    sat_s6YRN
                                    sat_s6YRO
                                    sat_s6YRP
                                    sat_s6YRQ
                                    sat_s6YRR
                                    sat_s6YRS
                                    sat_s6YRT
                                    sat_s6YRU
                                    sat_s6YRV
                                    sat_s6YRW
                                    sat_s6YRX
                                    sat_s6YRY
                                    sat_s6YRZ
                                    sat_s6YS0
                                    sat_s6YS1];

Data.Foldable.maximumBy
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YS2 cmp_s6YS3]
        let {
          sat_s6YS7 [Occ=Once] :: a_a6KCW -> a_a6KCW -> a_a6KCW
          [LclId] =
              [cmp_s6YS3] \r [x_s6YS4 y_s6YS5]
                  case cmp_s6YS3 x_s6YS4 y_s6YS5 of {
                    __DEFAULT -> y_s6YS5;
                    GHC.Types.GT -> x_s6YS4;
                  };
        } in  Data.Foldable.foldl1 $dFoldable_s6YS2 sat_s6YS7;

Data.Foldable.minimumBy
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YS8 cmp_s6YS9]
        let {
          sat_s6YSd [Occ=Once] :: a_a6KCy -> a_a6KCy -> a_a6KCy
          [LclId] =
              [cmp_s6YS9] \r [x_s6YSa y_s6YSb]
                  case cmp_s6YS9 x_s6YSa y_s6YSb of {
                    __DEFAULT -> x_s6YSa;
                    GHC.Types.GT -> y_s6YSb;
                  };
        } in  Data.Foldable.foldl1 $dFoldable_s6YS8 sat_s6YSd;

Data.Foldable.notElem
  :: forall (t :: * -> *) a.
     (Data.Foldable.Foldable t, GHC.Classes.Eq a) =>
     a -> t a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(C(U))),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YSe $dEq_s6YSf x_s6YSg]
        let {
          g_s6YSh [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_a6KCk a_a6KCl -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_s6YSe $dEq_s6YSf x_s6YSg] \u []
                  Data.Foldable.elem $dFoldable_s6YSe $dEq_s6YSf x_s6YSg; } in
        let {
          sat_s6YSk [Occ=OnceT[0]] :: t_a6KCk a_a6KCl -> GHC.Types.Bool
          [LclId] =
              [g_s6YSh] \r [x1_s6YSi]
                  case g_s6YSh x1_s6YSi of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  sat_s6YSk;

Data.Foldable.find
  :: forall (t :: * -> *) a.
     Data.Foldable.Foldable t =>
     (a -> GHC.Types.Bool) -> t a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_s6YSl p_s6YSm]
        let {
          g_s6YSn [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_a6KC3 a_a6KC4 -> Data.Monoid.First a_a6KC4
          [LclId] =
              [$dFoldable_s6YSl p_s6YSm] \u []
                  let {
                    sat_s6YSq [Occ=Once] :: a_a6KC4 -> Data.Monoid.First a_a6KC4
                    [LclId] =
                        [p_s6YSm] \r [x_s6YSo]
                            case p_s6YSm x_s6YSo of {
                              GHC.Types.False -> GHC.Base.Nothing [];
                              GHC.Types.True -> GHC.Base.Just [x_s6YSo];
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable_s6YSl Data.Monoid.$fMonoidFirst sat_s6YSq; } in
        let {
          sat_s6YSs [Occ=Once]
            :: t_a6KC3 a_a6KC4 -> Data.Monoid.First a_a6KC4
          [LclId] =
              [g_s6YSn] \r [x_s6YSr] g_s6YSn x_s6YSr;
        } in  sat_s6YSs;

Data.Foldable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Foldable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$trModule4];

Data.Foldable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Foldable"#;

Data.Foldable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$trModule2];

Data.Foldable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Foldable.$trModule3
                                     Data.Foldable.$trModule1];

$krep_r6OSX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Foldable.$tcFoldable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_r6OSX];

Data.Foldable.$tcFoldable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foldable"#;

Data.Foldable.$tcFoldable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Foldable.$tcFoldable3];

Data.Foldable.$tcFoldable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1610127274683713266##
                                    5928938033451775936##
                                    Data.Foldable.$trModule
                                    Data.Foldable.$tcFoldable2
                                    0#
                                    Data.Foldable.$tcFoldable1];

Data.Foldable.C:Foldable
  :: forall (t :: * -> *).
     (forall m. GHC.Base.Monoid m => t m -> m)
     -> (forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m)
     -> (forall a b. (a -> b -> b) -> b -> t a -> b)
     -> (forall a b. (a -> b -> b) -> b -> t a -> b)
     -> (forall b a. (b -> a -> b) -> b -> t a -> b)
     -> (forall b a. (b -> a -> b) -> b -> t a -> b)
     -> (forall a. (a -> a -> a) -> t a -> a)
     -> (forall a. (a -> a -> a) -> t a -> a)
     -> (forall a. t a -> [a])
     -> (forall a. t a -> GHC.Types.Bool)
     -> (forall a. t a -> GHC.Types.Int)
     -> (forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool)
     -> (forall a. GHC.Classes.Ord a => t a -> a)
     -> (forall a. GHC.Classes.Ord a => t a -> a)
     -> (forall a. GHC.Num.Num a => t a -> a)
     -> (forall a. GHC.Num.Num a => t a -> a)
     -> Data.Foldable.Foldable t
[GblId[DataCon],
 Arity=16,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_Bg
           eta_Bf
           eta_Be
           eta_Bd
           eta_Bc
           eta_Bb
           eta_Ba
           eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        Data.Foldable.C:Foldable [eta_Bg
                                  eta_Bf
                                  eta_Be
                                  eta_Bd
                                  eta_Bc
                                  eta_Bb
                                  eta_Ba
                                  eta_B9
                                  eta_B8
                                  eta_B7
                                  eta_B6
                                  eta_B5
                                  eta_B4
                                  eta_B3
                                  eta_B2
                                  eta_B1];

