
==================== Tidy Core ====================
2018-03-16 15:56:22.844982076 UTC

Result size of Tidy Core
  = {terms: 2,516, types: 3,016, coercions: 0, joins: 22/42}

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
Data.Bits.$p1FiniteBits :: forall b. FiniteBits b => Bits b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>,
 RULES: Built in rule for Data.Bits.$p1FiniteBits: "Class op $p1FiniteBits"]
Data.Bits.$p1FiniteBits
  = \ (@ b_a1A4A) (v_B1 :: FiniteBits b_a1A4A) ->
      case v_B1 of v_B1 { Data.Bits.C:FiniteBits v_B2 v_B3 v_B4 v_B5 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
finiteBitSize :: forall b. FiniteBits b => b -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>,
 RULES: Built in rule for finiteBitSize: "Class op finiteBitSize"]
finiteBitSize
  = \ (@ b_a1A4A) (v_B1 :: FiniteBits b_a1A4A) ->
      case v_B1 of v_B1 { Data.Bits.C:FiniteBits v_B2 v_B3 v_B4 v_B5 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
countLeadingZeros :: forall b. FiniteBits b => b -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>,
 RULES: Built in rule for countLeadingZeros: "Class op countLeadingZeros"]
countLeadingZeros
  = \ (@ b_a1A4A) (v_B1 :: FiniteBits b_a1A4A) ->
      case v_B1 of v_B1 { Data.Bits.C:FiniteBits v_B2 v_B3 v_B4 v_B5 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
countTrailingZeros :: forall b. FiniteBits b => b -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>,
 RULES: Built in rule for countTrailingZeros: "Class op countTrailingZeros"]
countTrailingZeros
  = \ (@ b_a1A4A) (v_B1 :: FiniteBits b_a1A4A) ->
      case v_B1 of v_B1 { Data.Bits.C:FiniteBits v_B2 v_B3 v_B4 v_B5 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
Data.Bits.$p1Bits :: forall a. Bits a => Eq a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for Data.Bits.$p1Bits: "Class op $p1Bits"]
Data.Bits.$p1Bits
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_B2
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
.&. :: forall a. Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for .&.: "Class op .&."]
.&.
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_B3
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
.|. :: forall a. Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for .|.: "Class op .|."]
.|.
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_B4
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
xor :: forall a. Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for xor: "Class op xor"]
xor
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_B5
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
complement :: forall a. Bits a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for complement: "Class op complement"]
complement
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_B6
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
shift :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for shift: "Class op shift"]
shift
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_B7
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
rotate :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for rotate: "Class op rotate"]
rotate
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_B8
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
zeroBits :: forall a. Bits a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for zeroBits: "Class op zeroBits"]
zeroBits
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_B9
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
bit :: forall a. Bits a => Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for bit: "Class op bit"]
bit
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Ba
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
setBit :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for setBit: "Class op setBit"]
setBit
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bb
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
clearBit :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for clearBit: "Class op clearBit"]
clearBit
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bc
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
complementBit :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for complementBit: "Class op complementBit"]
complementBit
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bd
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
testBit :: forall a. Bits a => a -> Int -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for testBit: "Class op testBit"]
testBit
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Be
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
bitSizeMaybe :: forall a. Bits a => a -> Maybe Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for bitSizeMaybe: "Class op bitSizeMaybe"]
bitSizeMaybe
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bf
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
bitSize :: forall a. Bits a => a -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for bitSize: "Class op bitSize"]
bitSize
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bg
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
isSigned :: forall a. Bits a => a -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>,
 RULES: Built in rule for isSigned: "Class op isSigned"]
isSigned
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bh
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
shiftL :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>,
 RULES: Built in rule for shiftL: "Class op shiftL"]
shiftL
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bi
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
unsafeShiftL :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>,
 RULES: Built in rule for unsafeShiftL: "Class op unsafeShiftL"]
unsafeShiftL
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bj
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
shiftR :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>,
 RULES: Built in rule for shiftR: "Class op shiftR"]
shiftR
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bk
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
unsafeShiftR :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>,
 RULES: Built in rule for unsafeShiftR: "Class op unsafeShiftR"]
unsafeShiftR
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bl
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
rotateL :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>,
 RULES: Built in rule for rotateL: "Class op rotateL"]
rotateL
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bm
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
rotateR :: forall a. Bits a => a -> Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>,
 RULES: Built in rule for rotateR: "Class op rotateR"]
rotateR
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bn
      }

-- RHS size: {terms: 6, types: 67, coercions: 0, joins: 0/0}
popCount :: forall a. Bits a => a -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>,
 RULES: Built in rule for popCount: "Class op popCount"]
popCount
  = \ (@ a_a1A4J) (v_B1 :: Bits a_a1A4J) ->
      case v_B1 of v_B1
      { Data.Bits.C:Bits v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh v_Bi v_Bj v_Bk v_Bl v_Bm v_Bn
                         v_Bo ->
      v_Bo
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$fBitsBool2 = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$fBitsBool1 = GHC.Types.I# 1#

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$cpopCount :: Bool -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AKa [Occ=Once!] :: Bool) ->
                 case ds_d1AKa of {
                   False -> Data.Bits.$fBitsBool2;
                   True -> Data.Bits.$fBitsBool1
                 }}]
Data.Bits.$fBitsBool_$cpopCount
  = \ (ds_d1AKa :: Bool) ->
      case ds_d1AKa of {
        False -> Data.Bits.$fBitsBool2;
        True -> Data.Bits.$fBitsBool1
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$cisSigned :: Bool -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.False}]
Data.Bits.$fBitsBool_$cisSigned = \ _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$cbitSize :: Bool -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Bits.$fBitsBool1}]
Data.Bits.$fBitsBool_$cbitSize
  = \ _ [Occ=Dead] -> Data.Bits.$fBitsBool1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool3 :: Maybe Int
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$fBitsBool3 = GHC.Base.Just @ Int Data.Bits.$fBitsBool1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$cbitSizeMaybe :: Bool -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Bits.$fBitsBool3}]
Data.Bits.$fBitsBool_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> Data.Bits.$fBitsBool3

-- RHS size: {terms: 11, types: 5, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$ctestBit :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1A68 [Occ=Once] :: Bool)
                 (ds_d1AJU [Occ=Once!] :: Int) ->
                 case ds_d1AJU of { I# ds1_d1AJY [Occ=Once!] ->
                 case ds1_d1AJY of {
                   __DEFAULT -> GHC.Types.False;
                   0# -> x_a1A68
                 }
                 }}]
Data.Bits.$fBitsBool_$ctestBit
  = \ (x_a1A68 :: Bool) (ds_d1AJU :: Int) ->
      case ds_d1AJU of { I# ds1_d1AJY ->
      case ds1_d1AJY of {
        __DEFAULT -> GHC.Types.False;
        0# -> x_a1A68
      }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$cbit :: Int -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AJO [Occ=Once!] :: Int) ->
                 case ds_d1AJO of { I# ds1_d1AJR [Occ=Once!] ->
                 case ds1_d1AJR of {
                   __DEFAULT -> GHC.Types.False;
                   0# -> GHC.Types.True
                 }
                 }}]
Data.Bits.$fBitsBool_$cbit
  = \ (ds_d1AJO :: Int) ->
      case ds_d1AJO of { I# ds1_d1AJR ->
      case ds1_d1AJR of {
        __DEFAULT -> GHC.Types.False;
        0# -> GHC.Types.True
      }
      }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$crotate :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_a1A67 [Occ=Once] :: Bool) _ [Occ=Dead] -> x_a1A67}]
Data.Bits.$fBitsBool_$crotate
  = \ (x_a1A67 :: Bool) _ [Occ=Dead] -> x_a1A67

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$cisSigned :: Integer -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.True}]
Data.Bits.$fBitsInteger_$cisSigned
  = \ _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
Data.Bits.$fBitsInteger2 = "Data.Bits.bitSize(Integer)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Bits.$fBitsInteger1 = unpackCString# Data.Bits.$fBitsInteger2

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$cbitSize :: Integer -> Int
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ Int Data.Bits.$fBitsInteger1}]
Data.Bits.$fBitsInteger_$cbitSize
  = \ _ [Occ=Dead] ->
      errorWithoutStackTrace @ 'LiftedRep @ Int Data.Bits.$fBitsInteger1

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$cbitSizeMaybe :: Integer -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Base.Nothing @ Int}]
Data.Bits.$fBitsInteger_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> GHC.Base.Nothing @ Int

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$ctestBit :: Integer -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1A59 [Occ=Once] :: Integer)
                 (ds_d1AJf [Occ=Once!] :: Int) ->
                 case ds_d1AJf of { I# i_a1A5a [Occ=Once] ->
                 testBitInteger x_a1A59 i_a1A5a
                 }}]
Data.Bits.$fBitsInteger_$ctestBit
  = \ (x_a1A59 :: Integer) (ds_d1AJf :: Int) ->
      case ds_d1AJf of { I# i_a1A5a -> testBitInteger x_a1A59 i_a1A5a }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$czeroBits :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Bits.$fBitsInteger_$czeroBits = 0

-- RHS size: {terms: 15, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$w$cshift [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Int# -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 82 0}]
Data.Bits.$w$cshift
  = \ (w_s1C1f :: Integer) (ww_s1C1j :: Int#) ->
      case >=# ww_s1C1j 0# of {
        __DEFAULT -> shiftRInteger w_s1C1f (negateInt# ww_s1C1j);
        1# -> shiftLInteger w_s1C1f ww_s1C1j
      }

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$cshift [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1C1f [Occ=Once] :: Integer)
                 (w1_s1C1g [Occ=Once!] :: Int) ->
                 case w1_s1C1g of { I# ww1_s1C1j [Occ=Once] ->
                 Data.Bits.$w$cshift w_s1C1f ww1_s1C1j
                 }}]
Data.Bits.$fBitsInteger_$cshift
  = \ (w_s1C1f :: Integer) (w1_s1C1g :: Int) ->
      case w1_s1C1g of { I# ww1_s1C1j ->
      Data.Bits.$w$cshift w_s1C1f ww1_s1C1j
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger3 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Bits.$fBitsInteger3 = 1

-- RHS size: {terms: 17, types: 4, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$cbit :: Int -> Integer
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once] :: Int) ->
                 Data.Bits.$fBitsInteger_$cshift Data.Bits.$fBitsInteger3 i_a1A6g}]
Data.Bits.$fBitsInteger_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# ww1_s1C1j ->
      case >=# ww1_s1C1j 0# of {
        __DEFAULT ->
          shiftRInteger Data.Bits.$fBitsInteger3 (negateInt# ww1_s1C1j);
        1# -> shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1C1j
      }
      }

-- RHS size: {terms: 24, types: 5, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once] :: Integer)
                 (i_a1A4R [Occ=Once] :: Int) ->
                 andInteger
                   x_a1A4Q
                   (complementInteger
                      (Data.Bits.$fBitsInteger_$cshift
                         Data.Bits.$fBitsInteger3 i_a1A4R))}]
Data.Bits.$fBitsInteger_$cclearBit
  = \ (eta_B2 :: Integer) (eta1_B1 :: Int) ->
      case eta1_B1 of { I# ww1_s1C1j ->
      case >=# ww1_s1C1j 0# of {
        __DEFAULT ->
          andInteger
            eta_B2
            (complementInteger
               (shiftRInteger Data.Bits.$fBitsInteger3 (negateInt# ww1_s1C1j)));
        1# ->
          andInteger
            eta_B2
            (complementInteger
               (shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1C1j))
      }
      }

-- RHS size: {terms: 22, types: 5, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once] :: Integer)
                 (i_a1A4T [Occ=Once] :: Int) ->
                 xorInteger
                   x_a1A4S
                   (Data.Bits.$fBitsInteger_$cshift
                      Data.Bits.$fBitsInteger3 i_a1A4T)}]
Data.Bits.$fBitsInteger_$ccomplementBit
  = \ (eta_B2 :: Integer) (eta1_B1 :: Int) ->
      case eta1_B1 of { I# ww1_s1C1j ->
      case >=# ww1_s1C1j 0# of {
        __DEFAULT ->
          xorInteger
            eta_B2
            (shiftRInteger Data.Bits.$fBitsInteger3 (negateInt# ww1_s1C1j));
        1# ->
          xorInteger
            eta_B2 (shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1C1j)
      }
      }

-- RHS size: {terms: 22, types: 5, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once] :: Integer)
                 (i_a1A4P [Occ=Once] :: Int) ->
                 orInteger
                   x_a1A4O
                   (Data.Bits.$fBitsInteger_$cshift
                      Data.Bits.$fBitsInteger3 i_a1A4P)}]
Data.Bits.$fBitsInteger_$csetBit
  = \ (eta_B2 :: Integer) (eta1_B1 :: Int) ->
      case eta1_B1 of { I# ww1_s1C1j ->
      case >=# ww1_s1C1j 0# of {
        __DEFAULT ->
          orInteger
            eta_B2
            (shiftRInteger Data.Bits.$fBitsInteger3 (negateInt# ww1_s1C1j));
        1# ->
          orInteger eta_B2 (shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1C1j)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshift}]
Data.Bits.$fBitsInteger_$cunsafeShiftL
  = Data.Bits.$fBitsInteger_$cshift

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$cshiftL [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshift}]
Data.Bits.$fBitsInteger_$cshiftL = Data.Bits.$fBitsInteger_$cshift

-- RHS size: {terms: 21, types: 6, coercions: 0, joins: 0/1}
Data.Bits.$fBitsInteger_$cshiftR [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Y [Occ=Once*] :: Integer)
                 (i_a1A4Z [Occ=Once!] :: Int) ->
                 case i_a1A4Z of { I# x1_i1AMT [Occ=Once] ->
                 let {
                   i#_a1A58 :: Int#
                   [LclId]
                   i#_a1A58 = negateInt# x1_i1AMT } in
                 case >=# i#_a1A58 0# of {
                   __DEFAULT -> shiftRInteger x_a1A4Y (negateInt# i#_a1A58);
                   1# -> shiftLInteger x_a1A4Y i#_a1A58
                 }
                 }}]
Data.Bits.$fBitsInteger_$cshiftR
  = \ (eta_B2 :: Integer) (eta1_B1 :: Int) ->
      case eta1_B1 of { I# x_i1AMT ->
      let {
        i#_a1A58 [Dmd=<S,U>] :: Int#
        [LclId]
        i#_a1A58 = negateInt# x_i1AMT } in
      case >=# i#_a1A58 0# of {
        __DEFAULT -> shiftRInteger eta_B2 (negateInt# i#_a1A58);
        1# -> shiftLInteger eta_B2 i#_a1A58
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshiftR}]
Data.Bits.$fBitsInteger_$cunsafeShiftR
  = Data.Bits.$fBitsInteger_$cshiftR

-- RHS size: {terms: 21, types: 6, coercions: 0, joins: 0/1}
Data.Bits.$fBitsInteger_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once*] :: Integer)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 let {
                   i#_a1A58 :: Int#
                   [LclId]
                   i#_a1A58 = negateInt# x1_i1AMT } in
                 case >=# i#_a1A58 0# of {
                   __DEFAULT -> shiftRInteger x_a1A54 (negateInt# i#_a1A58);
                   1# -> shiftLInteger x_a1A54 i#_a1A58
                 }
                 }}]
Data.Bits.$fBitsInteger_$crotateR
  = \ (eta_B2 :: Integer) (eta1_B1 :: Int) ->
      case eta1_B1 of { I# x_i1AMT ->
      let {
        i#_a1A58 [Dmd=<S,U>] :: Int#
        [LclId]
        i#_a1A58 = negateInt# x_i1AMT } in
      case >=# i#_a1A58 0# of {
        __DEFAULT -> shiftRInteger eta_B2 (negateInt# i#_a1A58);
        1# -> shiftLInteger eta_B2 i#_a1A58
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInteger_$cshift}]
Data.Bits.$fBitsInteger_$crotateL = Data.Bits.$fBitsInteger_$cshift

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros :: Bool -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1A64 [Occ=Once!] :: Bool) ->
                 case x_a1A64 of {
                   False -> Data.Bits.$fBitsBool1;
                   True -> Data.Bits.$fBitsBool2
                 }}]
Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
  = \ (x_a1A64 :: Bool) ->
      case x_a1A64 of {
        False -> Data.Bits.$fBitsBool1;
        True -> Data.Bits.$fBitsBool2
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cpopCount :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AIT [Occ=Once!] :: Int) ->
                 case ds_d1AIT of { I# x#_a1A63 [Occ=Once] ->
                 GHC.Types.I# (word2Int# (popCnt# (int2Word# x#_a1A63)))
                 }}]
Data.Bits.$fBitsInt_$cpopCount
  = \ (ds_d1AIT :: Int) ->
      case ds_d1AIT of { I# x#_a1A63 ->
      GHC.Types.I# (word2Int# (popCnt# (int2Word# x#_a1A63)))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cunsafeShiftR :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AIM [Occ=Once!] :: Int)
                 (ds1_d1AIN [Occ=Once!] :: Int) ->
                 case ds_d1AIM of { I# x#_a1A5V [Occ=Once] ->
                 case ds1_d1AIN of { I# i#_a1A5W [Occ=Once] ->
                 GHC.Types.I# (uncheckedIShiftRA# x#_a1A5V i#_a1A5W)
                 }
                 }}]
Data.Bits.$fBitsInt_$cunsafeShiftR
  = \ (ds_d1AIM :: Int) (ds1_d1AIN :: Int) ->
      case ds_d1AIM of { I# x#_a1A5V ->
      case ds1_d1AIN of { I# i#_a1A5W ->
      GHC.Types.I# (uncheckedIShiftRA# x#_a1A5V i#_a1A5W)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_r1CDD :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl_r1CDD = GHC.Types.I# -1#

-- RHS size: {terms: 26, types: 8, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cshiftR [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1C1m [Occ=Once!] :: Int)
                 (w1_s1C1n [Occ=Once!] :: Int) ->
                 case w_s1C1m of { I# ww1_s1C1q [Occ=Once*] ->
                 case w1_s1C1n of { I# ww3_s1C1u ->
                 case >=# ww3_s1C1u 64# of {
                   __DEFAULT -> GHC.Types.I# (uncheckedIShiftRA# ww1_s1C1q ww3_s1C1u);
                   1# ->
                     case <# ww1_s1C1q 0# of {
                       __DEFAULT -> GHC.Types.I# 0#;
                       1# -> GHC.Types.I# -1#
                     }
                 }
                 }
                 }}]
Data.Bits.$fBitsInt_$cshiftR
  = \ (w_s1C1m :: Int) (w1_s1C1n :: Int) ->
      case w_s1C1m of { I# ww1_s1C1q ->
      case w1_s1C1n of { I# ww3_s1C1u ->
      case >=# ww3_s1C1u 64# of {
        __DEFAULT -> GHC.Types.I# (uncheckedIShiftRA# ww1_s1C1q ww3_s1C1u);
        1# ->
          case <# ww1_s1C1q 0# of {
            __DEFAULT -> Data.Bits.$fBitsBool2;
            1# -> lvl_r1CDD
          }
      }
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cunsafeShiftL :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AIy [Occ=Once!] :: Int)
                 (ds1_d1AIz [Occ=Once!] :: Int) ->
                 case ds_d1AIy of { I# x#_a1A5R [Occ=Once] ->
                 case ds1_d1AIz of { I# i#_a1A5S [Occ=Once] ->
                 GHC.Types.I# (uncheckedIShiftL# x#_a1A5R i#_a1A5S)
                 }
                 }}]
Data.Bits.$fBitsInt_$cunsafeShiftL
  = \ (ds_d1AIy :: Int) (ds1_d1AIz :: Int) ->
      case ds_d1AIy of { I# x#_a1A5R ->
      case ds1_d1AIz of { I# i#_a1A5S ->
      GHC.Types.I# (uncheckedIShiftL# x#_a1A5R i#_a1A5S)
      }
      }

-- RHS size: {terms: 19, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cshiftL :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AIr [Occ=Once!] :: Int)
                 (ds1_d1AIs [Occ=Once!] :: Int) ->
                 case ds_d1AIr of { I# x#_a1A5P [Occ=Once] ->
                 case ds1_d1AIs of { I# i#_a1A5Q ->
                 case >=# i#_a1A5Q 64# of {
                   __DEFAULT -> GHC.Types.I# (uncheckedIShiftL# x#_a1A5P i#_a1A5Q);
                   1# -> GHC.Types.I# 0#
                 }
                 }
                 }}]
Data.Bits.$fBitsInt_$cshiftL
  = \ (ds_d1AIr :: Int) (ds1_d1AIs :: Int) ->
      case ds_d1AIr of { I# x#_a1A5P ->
      case ds1_d1AIs of { I# i#_a1A5Q ->
      case >=# i#_a1A5Q 64# of {
        __DEFAULT -> GHC.Types.I# (uncheckedIShiftL# x#_a1A5P i#_a1A5Q);
        1# -> Data.Bits.$fBitsBool2
      }
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cisSigned :: Int -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.True}]
Data.Bits.$fBitsInt_$cisSigned = \ _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 22, types: 7, coercions: 0, joins: 0/1}
Data.Bits.$fBitsInt_$crotate [InlPrag=INLINE (sat-args=2)]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d1AIa [Occ=Once!] :: Int)
                 (ds1_d1AIb [Occ=Once!] :: Int) ->
                 case ds_d1AIa of { I# x#_a1A5X ->
                 case ds1_d1AIb of { I# i#_a1A5Y [Occ=Once] ->
                 let {
                   i'#_a1A5Z :: Int#
                   [LclId]
                   i'#_a1A5Z = andI# i#_a1A5Y 63# } in
                 GHC.Types.I#
                   (orI#
                      (uncheckedIShiftL# x#_a1A5X i'#_a1A5Z)
                      (uncheckedIShiftRL# x#_a1A5X (-# 64# i'#_a1A5Z)))
                 }
                 }}]
Data.Bits.$fBitsInt_$crotate
  = \ (ds_d1AIa :: Int) (ds1_d1AIb :: Int) ->
      case ds_d1AIa of { I# x#_a1A5X ->
      case ds1_d1AIb of { I# i#_a1A5Y ->
      let {
        i'#_s1B3r [Dmd=<S,U>] :: Int#
        [LclId]
        i'#_s1B3r = andI# i#_a1A5Y 63# } in
      GHC.Types.I#
        (orI#
           (uncheckedIShiftL# x#_a1A5X i'#_s1B3r)
           (uncheckedIShiftRL# x#_a1A5X (-# 64# i'#_s1B3r)))
      }
      }

-- RHS size: {terms: 46, types: 11, coercions: 0, joins: 0/1}
Data.Bits.$fBitsInt_$cshift [InlPrag=INLINE (sat-args=2)]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d1AHU [Occ=Once!] :: Int)
                 (ds1_d1AHV [Occ=Once!] :: Int) ->
                 case ds_d1AHU of { I# x#_a1A5N [Occ=Once*] ->
                 case ds1_d1AHV of { I# i#_a1A5O ->
                 case >=# i#_a1A5O 0# of {
                   __DEFAULT ->
                     let {
                       b_i1AI0 :: Int#
                       [LclId]
                       b_i1AI0 = negateInt# i#_a1A5O } in
                     case >=# b_i1AI0 64# of {
                       __DEFAULT -> GHC.Types.I# (uncheckedIShiftRA# x#_a1A5N b_i1AI0);
                       1# ->
                         case <# x#_a1A5N 0# of {
                           __DEFAULT -> GHC.Types.I# 0#;
                           1# -> GHC.Types.I# -1#
                         }
                     };
                   1# ->
                     case >=# i#_a1A5O 64# of {
                       __DEFAULT -> GHC.Types.I# (uncheckedIShiftL# x#_a1A5N i#_a1A5O);
                       1# -> GHC.Types.I# 0#
                     }
                 }
                 }
                 }}]
Data.Bits.$fBitsInt_$cshift
  = \ (ds_d1AHU :: Int) (ds1_d1AHV :: Int) ->
      case ds_d1AHU of { I# x#_a1A5N ->
      case ds1_d1AHV of { I# i#_a1A5O ->
      case >=# i#_a1A5O 0# of {
        __DEFAULT ->
          let {
            b_s1B3p [Dmd=<S,U>] :: Int#
            [LclId]
            b_s1B3p = negateInt# i#_a1A5O } in
          case >=# b_s1B3p 64# of {
            __DEFAULT -> GHC.Types.I# (uncheckedIShiftRA# x#_a1A5N b_s1B3p);
            1# ->
              case <# x#_a1A5N 0# of {
                __DEFAULT -> Data.Bits.$fBitsBool2;
                1# -> lvl_r1CDD
              }
          };
        1# ->
          case >=# i#_a1A5O 64# of {
            __DEFAULT -> GHC.Types.I# (uncheckedIShiftL# x#_a1A5N i#_a1A5O);
            1# -> Data.Bits.$fBitsBool2
          }
      }
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$ccomplement :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AHQ [Occ=Once!] :: Int) ->
                 case ds_d1AHQ of { I# x#_a1A5M [Occ=Once] ->
                 GHC.Types.I# (notI# x#_a1A5M)
                 }}]
Data.Bits.$fBitsInt_$ccomplement
  = \ (ds_d1AHQ :: Int) ->
      case ds_d1AHQ of { I# x#_a1A5M -> GHC.Types.I# (notI# x#_a1A5M) }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cxor :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AHJ [Occ=Once!] :: Int)
                 (ds1_d1AHK [Occ=Once!] :: Int) ->
                 case ds_d1AHJ of { I# x#_a1A5K [Occ=Once] ->
                 case ds1_d1AHK of { I# y#_a1A5L [Occ=Once] ->
                 GHC.Types.I# (xorI# x#_a1A5K y#_a1A5L)
                 }
                 }}]
Data.Bits.$fBitsInt_$cxor
  = \ (ds_d1AHJ :: Int) (ds1_d1AHK :: Int) ->
      case ds_d1AHJ of { I# x#_a1A5K ->
      case ds1_d1AHK of { I# y#_a1A5L ->
      GHC.Types.I# (xorI# x#_a1A5K y#_a1A5L)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$c.|. :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AHC [Occ=Once!] :: Int)
                 (ds1_d1AHD [Occ=Once!] :: Int) ->
                 case ds_d1AHC of { I# x#_a1A5I [Occ=Once] ->
                 case ds1_d1AHD of { I# y#_a1A5J [Occ=Once] ->
                 GHC.Types.I# (orI# x#_a1A5I y#_a1A5J)
                 }
                 }}]
Data.Bits.$fBitsInt_$c.|.
  = \ (ds_d1AHC :: Int) (ds1_d1AHD :: Int) ->
      case ds_d1AHC of { I# x#_a1A5I ->
      case ds1_d1AHD of { I# y#_a1A5J ->
      GHC.Types.I# (orI# x#_a1A5I y#_a1A5J)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$c.&. :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AHv [Occ=Once!] :: Int)
                 (ds1_d1AHw [Occ=Once!] :: Int) ->
                 case ds_d1AHv of { I# x#_a1A5G [Occ=Once] ->
                 case ds1_d1AHw of { I# y#_a1A5H [Occ=Once] ->
                 GHC.Types.I# (andI# x#_a1A5G y#_a1A5H)
                 }
                 }}]
Data.Bits.$fBitsInt_$c.&.
  = \ (ds_d1AHv :: Int) (ds1_d1AHw :: Int) ->
      case ds_d1AHv of { I# x#_a1A5G ->
      case ds1_d1AHw of { I# y#_a1A5H ->
      GHC.Types.I# (andI# x#_a1A5G y#_a1A5H)
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AHr [Occ=Once!] :: Int) ->
                 case ds_d1AHr of { I# x#_a1A5F [Occ=Once] ->
                 GHC.Types.I# (word2Int# (ctz# (int2Word# x#_a1A5F)))
                 }}]
Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros
  = \ (ds_d1AHr :: Int) ->
      case ds_d1AHr of { I# x#_a1A5F ->
      GHC.Types.I# (word2Int# (ctz# (int2Word# x#_a1A5F)))
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AHn [Occ=Once!] :: Int) ->
                 case ds_d1AHn of { I# x#_a1A5E [Occ=Once] ->
                 GHC.Types.I# (word2Int# (clz# (int2Word# x#_a1A5E)))
                 }}]
Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
  = \ (ds_d1AHn :: Int) ->
      case ds_d1AHn of { I# x#_a1A5E ->
      GHC.Types.I# (word2Int# (clz# (int2Word# x#_a1A5E)))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$fBitsInt1 = GHC.Types.I# 64#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cfiniteBitSize :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Bits.$fBitsInt1}]
Data.Bits.$fBitsInt_$cfiniteBitSize
  = \ _ [Occ=Dead] -> Data.Bits.$fBitsInt1

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cpopCount :: Word -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AHg [Occ=Once!] :: Word) ->
                 case ds_d1AHg of { W# x#_a1A5D [Occ=Once] ->
                 GHC.Types.I# (word2Int# (popCnt# x#_a1A5D))
                 }}]
Data.Bits.$fBitsWord_$cpopCount
  = \ (ds_d1AHg :: Word) ->
      case ds_d1AHg of { W# x#_a1A5D ->
      GHC.Types.I# (word2Int# (popCnt# x#_a1A5D))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cunsafeShiftR :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AH9 [Occ=Once!] :: Word)
                 (ds1_d1AHa [Occ=Once!] :: Int) ->
                 case ds_d1AH9 of { W# x#_a1A5v [Occ=Once] ->
                 case ds1_d1AHa of { I# i#_a1A5w [Occ=Once] ->
                 GHC.Types.W# (uncheckedShiftRL# x#_a1A5v i#_a1A5w)
                 }
                 }}]
Data.Bits.$fBitsWord_$cunsafeShiftR
  = \ (ds_d1AH9 :: Word) (ds1_d1AHa :: Int) ->
      case ds_d1AH9 of { W# x#_a1A5v ->
      case ds1_d1AHa of { I# i#_a1A5w ->
      GHC.Types.W# (uncheckedShiftRL# x#_a1A5v i#_a1A5w)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord1 :: Word
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$fBitsWord1 = GHC.Types.W# 0##

-- RHS size: {terms: 19, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cshiftR :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AH2 [Occ=Once!] :: Word)
                 (ds1_d1AH3 [Occ=Once!] :: Int) ->
                 case ds_d1AH2 of { W# x#_a1A5t [Occ=Once] ->
                 case ds1_d1AH3 of { I# i#_a1A5u ->
                 case >=# i#_a1A5u 64# of {
                   __DEFAULT -> GHC.Types.W# (uncheckedShiftRL# x#_a1A5t i#_a1A5u);
                   1# -> GHC.Types.W# 0##
                 }
                 }
                 }}]
Data.Bits.$fBitsWord_$cshiftR
  = \ (ds_d1AH2 :: Word) (ds1_d1AH3 :: Int) ->
      case ds_d1AH2 of { W# x#_a1A5t ->
      case ds1_d1AH3 of { I# i#_a1A5u ->
      case >=# i#_a1A5u 64# of {
        __DEFAULT -> GHC.Types.W# (uncheckedShiftRL# x#_a1A5t i#_a1A5u);
        1# -> Data.Bits.$fBitsWord1
      }
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cunsafeShiftL :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AGV [Occ=Once!] :: Word)
                 (ds1_d1AGW [Occ=Once!] :: Int) ->
                 case ds_d1AGV of { W# x#_a1A5r [Occ=Once] ->
                 case ds1_d1AGW of { I# i#_a1A5s [Occ=Once] ->
                 GHC.Types.W# (uncheckedShiftL# x#_a1A5r i#_a1A5s)
                 }
                 }}]
Data.Bits.$fBitsWord_$cunsafeShiftL
  = \ (ds_d1AGV :: Word) (ds1_d1AGW :: Int) ->
      case ds_d1AGV of { W# x#_a1A5r ->
      case ds1_d1AGW of { I# i#_a1A5s ->
      GHC.Types.W# (uncheckedShiftL# x#_a1A5r i#_a1A5s)
      }
      }

-- RHS size: {terms: 19, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cshiftL :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AGO [Occ=Once!] :: Word)
                 (ds1_d1AGP [Occ=Once!] :: Int) ->
                 case ds_d1AGO of { W# x#_a1A5p [Occ=Once] ->
                 case ds1_d1AGP of { I# i#_a1A5q ->
                 case >=# i#_a1A5q 64# of {
                   __DEFAULT -> GHC.Types.W# (uncheckedShiftL# x#_a1A5p i#_a1A5q);
                   1# -> GHC.Types.W# 0##
                 }
                 }
                 }}]
Data.Bits.$fBitsWord_$cshiftL
  = \ (ds_d1AGO :: Word) (ds1_d1AGP :: Int) ->
      case ds_d1AGO of { W# x#_a1A5p ->
      case ds1_d1AGP of { I# i#_a1A5q ->
      case >=# i#_a1A5q 64# of {
        __DEFAULT -> GHC.Types.W# (uncheckedShiftL# x#_a1A5p i#_a1A5q);
        1# -> Data.Bits.$fBitsWord1
      }
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cisSigned :: Word -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.False}]
Data.Bits.$fBitsWord_$cisSigned = \ _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 25, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$crotate :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AGw [Occ=Once!] :: Word)
                 (ds1_d1AGx [Occ=Once!] :: Int) ->
                 case ds_d1AGw of { W# x#_a1A5x ->
                 case ds1_d1AGx of { I# i#_a1A5y [Occ=Once] ->
                 case andI# i#_a1A5y 63# of wild2_X3A {
                   __DEFAULT ->
                     GHC.Types.W#
                       (or#
                          (uncheckedShiftL# x#_a1A5x wild2_X3A)
                          (uncheckedShiftRL# x#_a1A5x (-# 64# wild2_X3A)));
                   0# -> GHC.Types.W# x#_a1A5x
                 }
                 }
                 }}]
Data.Bits.$fBitsWord_$crotate
  = \ (ds_d1AGw :: Word) (ds1_d1AGx :: Int) ->
      case ds_d1AGw of wild_X3o { W# x#_a1A5x ->
      case ds1_d1AGx of { I# i#_a1A5y ->
      case andI# i#_a1A5y 63# of wild2_X3A {
        __DEFAULT ->
          GHC.Types.W#
            (or#
               (uncheckedShiftL# x#_a1A5x wild2_X3A)
               (uncheckedShiftRL# x#_a1A5x (-# 64# wild2_X3A)));
        0# -> wild_X3o
      }
      }
      }

-- RHS size: {terms: 39, types: 10, coercions: 0, joins: 0/1}
Data.Bits.$fBitsWord_$cshift [InlPrag=INLINE (sat-args=2)]
  :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d1AGh [Occ=Once!] :: Word)
                 (ds1_d1AGi [Occ=Once!] :: Int) ->
                 case ds_d1AGh of { W# x#_a1A5n [Occ=Once*] ->
                 case ds1_d1AGi of { I# i#_a1A5o ->
                 case >=# i#_a1A5o 0# of {
                   __DEFAULT ->
                     let {
                       b_i1AGn :: Int#
                       [LclId]
                       b_i1AGn = negateInt# i#_a1A5o } in
                     case >=# b_i1AGn 64# of {
                       __DEFAULT -> GHC.Types.W# (uncheckedShiftRL# x#_a1A5n b_i1AGn);
                       1# -> GHC.Types.W# 0##
                     };
                   1# ->
                     case >=# i#_a1A5o 64# of {
                       __DEFAULT -> GHC.Types.W# (uncheckedShiftL# x#_a1A5n i#_a1A5o);
                       1# -> GHC.Types.W# 0##
                     }
                 }
                 }
                 }}]
Data.Bits.$fBitsWord_$cshift
  = \ (ds_d1AGh :: Word) (ds1_d1AGi :: Int) ->
      case ds_d1AGh of { W# x#_a1A5n ->
      case ds1_d1AGi of { I# i#_a1A5o ->
      case >=# i#_a1A5o 0# of {
        __DEFAULT ->
          let {
            b_s1B3l [Dmd=<S,U>] :: Int#
            [LclId]
            b_s1B3l = negateInt# i#_a1A5o } in
          case >=# b_s1B3l 64# of {
            __DEFAULT -> GHC.Types.W# (uncheckedShiftRL# x#_a1A5n b_s1B3l);
            1# -> Data.Bits.$fBitsWord1
          };
        1# ->
          case >=# i#_a1A5o 64# of {
            __DEFAULT -> GHC.Types.W# (uncheckedShiftL# x#_a1A5n i#_a1A5o);
            1# -> Data.Bits.$fBitsWord1
          }
      }
      }
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$ccomplement :: Word -> Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AGb [Occ=Once!] :: Word) ->
                 case ds_d1AGb of { W# x#_a1A5l [Occ=Once] ->
                 GHC.Types.W# (xor# x#_a1A5l 18446744073709551615##)
                 }}]
Data.Bits.$fBitsWord_$ccomplement
  = \ (ds_d1AGb :: Word) ->
      case ds_d1AGb of { W# x#_a1A5l ->
      GHC.Types.W# (xor# x#_a1A5l 18446744073709551615##)
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cxor :: Word -> Word -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AG4 [Occ=Once!] :: Word)
                 (ds1_d1AG5 [Occ=Once!] :: Word) ->
                 case ds_d1AG4 of { W# x#_a1A5j [Occ=Once] ->
                 case ds1_d1AG5 of { W# y#_a1A5k [Occ=Once] ->
                 GHC.Types.W# (xor# x#_a1A5j y#_a1A5k)
                 }
                 }}]
Data.Bits.$fBitsWord_$cxor
  = \ (ds_d1AG4 :: Word) (ds1_d1AG5 :: Word) ->
      case ds_d1AG4 of { W# x#_a1A5j ->
      case ds1_d1AG5 of { W# y#_a1A5k ->
      GHC.Types.W# (xor# x#_a1A5j y#_a1A5k)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$c.|. :: Word -> Word -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AFX [Occ=Once!] :: Word)
                 (ds1_d1AFY [Occ=Once!] :: Word) ->
                 case ds_d1AFX of { W# x#_a1A5h [Occ=Once] ->
                 case ds1_d1AFY of { W# y#_a1A5i [Occ=Once] ->
                 GHC.Types.W# (or# x#_a1A5h y#_a1A5i)
                 }
                 }}]
Data.Bits.$fBitsWord_$c.|.
  = \ (ds_d1AFX :: Word) (ds1_d1AFY :: Word) ->
      case ds_d1AFX of { W# x#_a1A5h ->
      case ds1_d1AFY of { W# y#_a1A5i ->
      GHC.Types.W# (or# x#_a1A5h y#_a1A5i)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$c.&. :: Word -> Word -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AFQ [Occ=Once!] :: Word)
                 (ds1_d1AFR [Occ=Once!] :: Word) ->
                 case ds_d1AFQ of { W# x#_a1A5f [Occ=Once] ->
                 case ds1_d1AFR of { W# y#_a1A5g [Occ=Once] ->
                 GHC.Types.W# (and# x#_a1A5f y#_a1A5g)
                 }
                 }}]
Data.Bits.$fBitsWord_$c.&.
  = \ (ds_d1AFQ :: Word) (ds1_d1AFR :: Word) ->
      case ds_d1AFQ of { W# x#_a1A5f ->
      case ds1_d1AFR of { W# y#_a1A5g ->
      GHC.Types.W# (and# x#_a1A5f y#_a1A5g)
      }
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros :: Word -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AFM [Occ=Once!] :: Word) ->
                 case ds_d1AFM of { W# x#_a1A5e [Occ=Once] ->
                 GHC.Types.I# (word2Int# (ctz# x#_a1A5e))
                 }}]
Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros
  = \ (ds_d1AFM :: Word) ->
      case ds_d1AFM of { W# x#_a1A5e ->
      GHC.Types.I# (word2Int# (ctz# x#_a1A5e))
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros :: Word -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1AFI [Occ=Once!] :: Word) ->
                 case ds_d1AFI of { W# x#_a1A5d [Occ=Once] ->
                 GHC.Types.I# (word2Int# (clz# x#_a1A5d))
                 }}]
Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
  = \ (ds_d1AFI :: Word) ->
      case ds_d1AFI of { W# x#_a1A5d ->
      GHC.Types.I# (word2Int# (clz# x#_a1A5d))
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cfiniteBitSize :: Word -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Bits.$fBitsInt1}]
Data.Bits.$fBitsWord_$cfiniteBitSize
  = \ _ [Occ=Dead] -> Data.Bits.$fBitsInt1

-- RHS size: {terms: 37, types: 18, coercions: 0, joins: 1/3}
Data.Bits.$dmcountTrailingZeros
  :: forall b. FiniteBits b => b -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S(S))LL),U(1*U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A),1*C1(U(U)),A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a1A4A) ($dFiniteBits_a1AnH :: FiniteBits b_a1A4A) ->
                 let {
                   $dBits_a1AyI [Occ=OnceL] :: Bits b_a1A4A
                   [LclId]
                   $dBits_a1AyI
                     = Data.Bits.$p1FiniteBits @ b_a1A4A $dFiniteBits_a1AnH } in
                 \ (x_a1A4F :: b_a1A4A) ->
                   let {
                     w_a1A4H [Occ=OnceL] :: Int
                     [LclId]
                     w_a1A4H = finiteBitSize @ b_a1A4A $dFiniteBits_a1AnH x_a1A4F } in
                   joinrec {
                     go_a1AoJ [Occ=LoopBreakerT[1]] :: Int -> Int
                     [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                     go_a1AoJ (i_a1A4I :: Int)
                       = case geInt i_a1A4I w_a1A4H of {
                           False ->
                             case testBit @ b_a1A4A $dBits_a1AyI x_a1A4F i_a1A4I of {
                               False ->
                                 jump go_a1AoJ
                                   (case i_a1A4I of { I# x1_i1AMi [Occ=Once] ->
                                    GHC.Types.I# (+# x1_i1AMi 1#)
                                    });
                               True -> i_a1A4I
                             };
                           True -> i_a1A4I
                         }; } in
                   jump go_a1AoJ (GHC.Types.I# 0#)}]
Data.Bits.$dmcountTrailingZeros
  = \ (@ b_a1A4A)
      ($dFiniteBits_a1AnH :: FiniteBits b_a1A4A)
      (eta_B1 :: b_a1A4A) ->
      case finiteBitSize @ b_a1A4A $dFiniteBits_a1AnH eta_B1 of
      { I# ww1_s1C1C ->
      let {
        $dBits_s1B3j [Dmd=<L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A)>]
          :: Bits b_a1A4A
        [LclId]
        $dBits_s1B3j
          = Data.Bits.$p1FiniteBits @ b_a1A4A $dFiniteBits_a1AnH } in
      joinrec {
        $wgo_s1C1J [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: Int# -> Int
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $wgo_s1C1J (ww2_s1C1H :: Int#)
          = let {
              wild_alMW [Dmd=<L,U(U)>] :: Int
              [LclId, Unf=OtherCon []]
              wild_alMW = GHC.Types.I# ww2_s1C1H } in
            case >=# ww2_s1C1H ww1_s1C1C of {
              __DEFAULT ->
                case testBit @ b_a1A4A $dBits_s1B3j eta_B1 wild_alMW of {
                  False -> jump $wgo_s1C1J (+# ww2_s1C1H 1#);
                  True -> wild_alMW
                };
              1# -> wild_alMW
            }; } in
      jump $wgo_s1C1J 0#
      }

-- RHS size: {terms: 55, types: 23, coercions: 0, joins: 3/4}
Data.Bits.$dmcountLeadingZeros
  :: forall b. FiniteBits b => b -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S(S))LL),U(1*U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A),1*C1(U(U)),A,A)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a1A4A) ($dFiniteBits_a1AnH :: FiniteBits b_a1A4A) ->
                 let {
                   $dBits_a1AyG [Occ=OnceL] :: Bits b_a1A4A
                   [LclId]
                   $dBits_a1AyG
                     = Data.Bits.$p1FiniteBits @ b_a1A4A $dFiniteBits_a1AnH } in
                 \ (x_a1A4B :: b_a1A4A) ->
                   case finiteBitSize @ b_a1A4A $dFiniteBits_a1AnH x_a1A4B of
                   { I# x1_i1AMw ->
                   letrec {
                     go_a1AnW [Occ=LoopBreaker] :: Int -> Int
                     [LclId, Arity=1, Unf=OtherCon []]
                     go_a1AnW
                       = \ (i_a1A4E :: Int) ->
                           case ltInt i_a1A4E (GHC.Types.I# 0#) of {
                             False ->
                               case testBit @ b_a1A4A $dBits_a1AyG x_a1A4B i_a1A4E of {
                                 False ->
                                   go_a1AnW
                                     (case i_a1A4E of { I# x2_X1AQn [Occ=Once] ->
                                      GHC.Types.I# (-# x2_X1AQn 1#)
                                      });
                                 True -> i_a1A4E
                               };
                             True -> i_a1A4E
                           }; } in
                   case go_a1AnW (GHC.Types.I# (-# x1_i1AMw 1#)) of
                   { I# y_i1AMA [Occ=Once] ->
                   GHC.Types.I# (-# (-# x1_i1AMw 1#) y_i1AMA)
                   }
                   }}]
Data.Bits.$dmcountLeadingZeros
  = \ (@ b_a1A4A)
      ($dFiniteBits_a1AnH :: FiniteBits b_a1A4A)
      (eta_B1 :: b_a1A4A) ->
      case finiteBitSize @ b_a1A4A $dFiniteBits_a1AnH eta_B1 of
      { I# x_i1AMw ->
      let {
        $dBits_s1B3d [Dmd=<L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A)>]
          :: Bits b_a1A4A
        [LclId]
        $dBits_s1B3d
          = Data.Bits.$p1FiniteBits @ b_a1A4A $dFiniteBits_a1AnH } in
      join {
        exit_X3A [Dmd=<L,C(U(U))>] :: Int# -> Int
        [LclId[JoinId(1)], Arity=1, Str=<S,U>m]
        exit_X3A (ww_s1C1N [OS=OneShot] :: Int#)
          = GHC.Types.I# (-# (-# x_i1AMw 1#) ww_s1C1N) } in
      join {
        exit1_X7a [Dmd=<L,C(U(U))>] :: Int# -> Int
        [LclId[JoinId(1)], Arity=1, Str=<S,U>m]
        exit1_X7a (ww_s1C1N [OS=OneShot] :: Int#)
          = GHC.Types.I# (-# (-# x_i1AMw 1#) ww_s1C1N) } in
      joinrec {
        $wgo_s1C1P [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: Int# -> Int
        [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []]
        $wgo_s1C1P (ww_s1C1N :: Int#)
          = case <# ww_s1C1N 0# of {
              __DEFAULT ->
                case testBit @ b_a1A4A $dBits_s1B3d eta_B1 (GHC.Types.I# ww_s1C1N)
                of {
                  False -> jump $wgo_s1C1P (-# ww_s1C1N 1#);
                  True -> jump exit_X3A ww_s1C1N
                };
              1# -> jump exit1_X7a ww_s1C1N
            }; } in
      jump $wgo_s1C1P (-# x_i1AMw 1#)
      }

-- RHS size: {terms: 13, types: 9, coercions: 0, joins: 0/0}
Data.Bits.$dmrotateR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 [Occ=Once] :: Bits a_a1A4J)
                 (x_a1A54 [Occ=Once] :: a_a1A4J)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 rotate
                   @ a_a1A4J
                   $dBits_a1Am6
                   x_a1A54
                   (case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                    GHC.Types.I# (negateInt# x1_i1AMT)
                    })}]
Data.Bits.$dmrotateR
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A54 :: a_a1A4J)
      (i_a1A55 :: Int) ->
      rotate
        @ a_a1A4J
        $dBits_a1Am6
        x_a1A54
        (case i_a1A55 of { I# x1_i1AMT ->
         GHC.Types.I# (negateInt# x1_i1AMT)
         })

-- RHS size: {terms: 8, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$dmrotateL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 [Occ=Once] :: Bits a_a1A4J)
                 (x_a1A52 [Occ=Once] :: a_a1A4J)
                 (i_a1A53 [Occ=Once] :: Int) ->
                 rotate @ a_a1A4J $dBits_a1Am6 x_a1A52 i_a1A53}]
Data.Bits.$dmrotateL
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A52 :: a_a1A4J)
      (i_a1A53 :: Int) ->
      rotate @ a_a1A4J $dBits_a1Am6 x_a1A52 i_a1A53

-- RHS size: {terms: 8, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$dmunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLC(C(S))LLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 [Occ=Once] :: Bits a_a1A4J)
                 (x_a1A50 [Occ=Once] :: a_a1A4J)
                 (i_a1A51 [Occ=Once] :: Int) ->
                 shiftR @ a_a1A4J $dBits_a1Am6 x_a1A50 i_a1A51}]
Data.Bits.$dmunsafeShiftR
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A50 :: a_a1A4J)
      (i_a1A51 :: Int) ->
      shiftR @ a_a1A4J $dBits_a1Am6 x_a1A50 i_a1A51

-- RHS size: {terms: 13, types: 9, coercions: 0, joins: 0/0}
Data.Bits.$dmshiftR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 [Occ=Once] :: Bits a_a1A4J)
                 (x_a1A4Y [Occ=Once] :: a_a1A4J)
                 (i_a1A4Z [Occ=Once!] :: Int) ->
                 shift
                   @ a_a1A4J
                   $dBits_a1Am6
                   x_a1A4Y
                   (case i_a1A4Z of { I# x1_i1AMT [Occ=Once] ->
                    GHC.Types.I# (negateInt# x1_i1AMT)
                    })}]
Data.Bits.$dmshiftR
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A4Y :: a_a1A4J)
      (i_a1A4Z :: Int) ->
      shift
        @ a_a1A4J
        $dBits_a1Am6
        x_a1A4Y
        (case i_a1A4Z of { I# x1_i1AMT ->
         GHC.Types.I# (negateInt# x1_i1AMT)
         })

-- RHS size: {terms: 8, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$dmunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLC(C(S))LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 [Occ=Once] :: Bits a_a1A4J)
                 (x_a1A4W [Occ=Once] :: a_a1A4J)
                 (i_a1A4X [Occ=Once] :: Int) ->
                 shiftL @ a_a1A4J $dBits_a1Am6 x_a1A4W i_a1A4X}]
Data.Bits.$dmunsafeShiftL
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A4W :: a_a1A4J)
      (i_a1A4X :: Int) ->
      shiftL @ a_a1A4J $dBits_a1Am6 x_a1A4W i_a1A4X

-- RHS size: {terms: 8, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$dmshiftL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 [Occ=Once] :: Bits a_a1A4J)
                 (x_a1A4U [Occ=Once] :: a_a1A4J)
                 (i_a1A4V [Occ=Once] :: Int) ->
                 shift @ a_a1A4J $dBits_a1Am6 x_a1A4U i_a1A4V}]
Data.Bits.$dmshiftL
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A4U :: a_a1A4J)
      (i_a1A4V :: Int) ->
      shift @ a_a1A4J $dBits_a1Am6 x_a1A4U i_a1A4V

-- RHS size: {terms: 10, types: 8, coercions: 0, joins: 0/0}
Data.Bits.$dmcomplementBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLLLLLLLLLLLLLLLLL),U(A,A,A,1*C1(C1(U)),A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 :: Bits a_a1A4J)
                 (x_a1A4S [Occ=Once] :: a_a1A4J)
                 (i_a1A4T [Occ=Once] :: Int) ->
                 xor
                   @ a_a1A4J
                   $dBits_a1Am6
                   x_a1A4S
                   (bit @ a_a1A4J $dBits_a1Am6 i_a1A4T)}]
Data.Bits.$dmcomplementBit
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A4S :: a_a1A4J)
      (i_a1A4T :: Int) ->
      xor
        @ a_a1A4J $dBits_a1Am6 x_a1A4S (bit @ a_a1A4J $dBits_a1Am6 i_a1A4T)

-- RHS size: {terms: 12, types: 9, coercions: 0, joins: 0/0}
Data.Bits.$dmclearBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLLLLLLLLLL),U(A,1*C1(C1(U)),A,A,1*C1(U),A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 :: Bits a_a1A4J)
                 (x_a1A4Q [Occ=Once] :: a_a1A4J)
                 (i_a1A4R [Occ=Once] :: Int) ->
                 .&.
                   @ a_a1A4J
                   $dBits_a1Am6
                   x_a1A4Q
                   (complement
                      @ a_a1A4J $dBits_a1Am6 (bit @ a_a1A4J $dBits_a1Am6 i_a1A4R))}]
Data.Bits.$dmclearBit
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A4Q :: a_a1A4J)
      (i_a1A4R :: Int) ->
      .&.
        @ a_a1A4J
        $dBits_a1Am6
        x_a1A4Q
        (complement
           @ a_a1A4J $dBits_a1Am6 (bit @ a_a1A4J $dBits_a1Am6 i_a1A4R))

-- RHS size: {terms: 10, types: 8, coercions: 0, joins: 0/0}
Data.Bits.$dmsetBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLLLLLLLLL),U(A,A,1*C1(C1(U)),A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 :: Bits a_a1A4J)
                 (x_a1A4O [Occ=Once] :: a_a1A4J)
                 (i_a1A4P [Occ=Once] :: Int) ->
                 .|.
                   @ a_a1A4J
                   $dBits_a1Am6
                   x_a1A4O
                   (bit @ a_a1A4J $dBits_a1Am6 i_a1A4P)}]
Data.Bits.$dmsetBit
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A4O :: a_a1A4J)
      (i_a1A4P :: Int) ->
      .|.
        @ a_a1A4J $dBits_a1Am6 x_a1A4O (bit @ a_a1A4J $dBits_a1Am6 i_a1A4P)

-- RHS size: {terms: 8, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$dmzeroBits :: forall a. Bits a => a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLC(C(S))LLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,1*C1(U),A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1A4J) ($dBits_a1Am6 :: Bits a_a1A4J) ->
                 clearBit
                   @ a_a1A4J
                   $dBits_a1Am6
                   (bit @ a_a1A4J $dBits_a1Am6 (GHC.Types.I# 0#))
                   (GHC.Types.I# 0#)}]
Data.Bits.$dmzeroBits
  = \ (@ a_a1A4J) ($dBits_a1Am6 :: Bits a_a1A4J) ->
      clearBit
        @ a_a1A4J
        $dBits_a1Am6
        (bit @ a_a1A4J $dBits_a1Am6 Data.Bits.$fBitsBool2)
        Data.Bits.$fBitsBool2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (x_a1A52 [Occ=Once] :: Bool) _ [Occ=Dead] -> x_a1A52}]
Data.Bits.$fBitsBool_$crotateL = Data.Bits.$fBitsBool_$crotate

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$cshiftR [InlPrag=INLINE (sat-args=2)]
  :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Y [Occ=Once] :: Bool)
                 (i_a1A4Z [Occ=Once!] :: Int) ->
                 case i_a1A4Z of { I# x1_i1AMT [Occ=Once!] ->
                 case x1_i1AMT of {
                   __DEFAULT -> GHC.Types.False;
                   0# -> x_a1A4Y
                 }
                 }}]
Data.Bits.$fBitsBool_$cshiftR = Data.Bits.$fBitsBool_$ctestBit

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsBool_$cshiftR}]
Data.Bits.$fBitsBool_$cunsafeShiftR = Data.Bits.$fBitsBool_$cshiftR

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$cshiftL [InlPrag=INLINE (sat-args=2)]
  :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4U [Occ=Once] :: Bool)
                 (i_a1A4V [Occ=Once!] :: Int) ->
                 case i_a1A4V of { I# ds_d1AJI [Occ=Once!] ->
                 case ds_d1AJI of {
                   __DEFAULT -> GHC.Types.False;
                   0# -> x_a1A4U
                 }
                 }}]
Data.Bits.$fBitsBool_$cshiftL = Data.Bits.$fBitsBool_$ctestBit

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsBool_$cshiftL}]
Data.Bits.$fBitsBool_$cunsafeShiftL = Data.Bits.$fBitsBool_$cshiftL

-- RHS size: {terms: 24, types: 9, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Bool)
                 (i_a1A4T [Occ=Once*!] :: Int) ->
                 case x_a1A4S of {
                   False ->
                     case i_a1A4T of { I# ds_d1AJR [Occ=Once!] ->
                     case ds_d1AJR of {
                       __DEFAULT -> GHC.Types.False;
                       0# -> GHC.Types.True
                     }
                     };
                   True ->
                     case i_a1A4T of { I# ds_d1AJR [Occ=Once!] ->
                     case ds_d1AJR of {
                       __DEFAULT -> GHC.Types.True;
                       0# -> GHC.Types.False
                     }
                     }
                 }}]
Data.Bits.$fBitsBool_$ccomplementBit
  = \ (eta_B2 :: Bool) (eta1_B1 :: Int) ->
      case eta_B2 of {
        False ->
          case eta1_B1 of { I# ds_d1AJR ->
          case ds_d1AJR of {
            __DEFAULT -> GHC.Types.False;
            0# -> GHC.Types.True
          }
          };
        True ->
          case eta1_B1 of { I# ds_d1AJR ->
          case ds_d1AJR of {
            __DEFAULT -> GHC.Types.True;
            0# -> GHC.Types.False
          }
          }
      }

-- RHS size: {terms: 16, types: 6, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Bool)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of {
                   False -> GHC.Types.False;
                   True ->
                     case i_a1A4R of { I# ds_d1AJR [Occ=Once!] ->
                     case ds_d1AJR of {
                       __DEFAULT -> GHC.Types.True;
                       0# -> GHC.Types.False
                     }
                     }
                 }}]
Data.Bits.$fBitsBool_$cclearBit
  = \ (eta_B2 :: Bool) (eta1_B1 :: Int) ->
      case eta_B2 of {
        False -> GHC.Types.False;
        True ->
          case eta1_B1 of { I# ds_d1AJR ->
          case ds_d1AJR of {
            __DEFAULT -> GHC.Types.True;
            0# -> GHC.Types.False
          }
          }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Bool)
                 (i_a1A4P [Occ=Once] :: Int) ->
                 case x_a1A4O of {
                   False -> Data.Bits.$fBitsBool_$cbit i_a1A4P;
                   True -> GHC.Types.True
                 }}]
Data.Bits.$fBitsBool_$csetBit
  = \ (eta_B2 :: Bool) (eta1_B1 :: Int) ->
      case eta_B2 of {
        False -> Data.Bits.$fBitsBool_$cbit eta1_B1;
        True -> GHC.Types.True
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Bool -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (x_a1A54 [Occ=Once] :: Bool) _ [Occ=Dead] -> x_a1A54}]
Data.Bits.$fBitsBool_$crotateR = Data.Bits.$fBitsBool_$crotate

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsBool [InlPrag=NOUSERINLINE CONLIKE] :: Bits Bool
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Bool
                        GHC.Classes.$fEqBool
                        &&
                        ||
                        GHC.Classes.$fEqBool_$c/=
                        not
                        Data.Bits.$fBitsBool_$ctestBit
                        Data.Bits.$fBitsBool_$crotate
                        GHC.Types.False
                        Data.Bits.$fBitsBool_$cbit
                        Data.Bits.$fBitsBool_$csetBit
                        Data.Bits.$fBitsBool_$cclearBit
                        Data.Bits.$fBitsBool_$ccomplementBit
                        Data.Bits.$fBitsBool_$ctestBit
                        Data.Bits.$fBitsBool_$cbitSizeMaybe
                        Data.Bits.$fBitsBool_$cbitSize
                        Data.Bits.$fBitsBool_$cisSigned
                        Data.Bits.$fBitsBool_$cshiftL
                        Data.Bits.$fBitsBool_$cunsafeShiftL
                        Data.Bits.$fBitsBool_$cshiftR
                        Data.Bits.$fBitsBool_$cunsafeShiftR
                        Data.Bits.$fBitsBool_$crotateL
                        Data.Bits.$fBitsBool_$crotateR
                        Data.Bits.$fBitsBool_$cpopCount]
Data.Bits.$fBitsBool
  = Data.Bits.C:Bits
      @ Bool
      GHC.Classes.$fEqBool
      &&
      ||
      GHC.Classes.$fEqBool_$c/=
      not
      Data.Bits.$fBitsBool_$ctestBit
      Data.Bits.$fBitsBool_$crotate
      GHC.Types.False
      Data.Bits.$fBitsBool_$cbit
      Data.Bits.$fBitsBool_$csetBit
      Data.Bits.$fBitsBool_$cclearBit
      Data.Bits.$fBitsBool_$ccomplementBit
      Data.Bits.$fBitsBool_$ctestBit
      Data.Bits.$fBitsBool_$cbitSizeMaybe
      Data.Bits.$fBitsBool_$cbitSize
      Data.Bits.$fBitsBool_$cisSigned
      Data.Bits.$fBitsBool_$cshiftL
      Data.Bits.$fBitsBool_$cunsafeShiftL
      Data.Bits.$fBitsBool_$cshiftR
      Data.Bits.$fBitsBool_$cunsafeShiftR
      Data.Bits.$fBitsBool_$crotateL
      Data.Bits.$fBitsBool_$crotateR
      Data.Bits.$fBitsBool_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fFiniteBitsBool [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Bool
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Bool
                              Data.Bits.$fBitsBool
                              Data.Bits.$fBitsBool_$cbitSize
                              Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
                              Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros]
Data.Bits.$fFiniteBitsBool
  = Data.Bits.C:FiniteBits
      @ Bool
      Data.Bits.$fBitsBool
      Data.Bits.$fBitsBool_$cbitSize
      Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
      Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros

-- RHS size: {terms: 30, types: 12, coercions: 0, joins: 0/0}
Data.Bits.$dmrotate :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),1*C1(C1(U)),A)><L,U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 [Occ=Once*] :: Bits a_a1A4J)
                 (x_a1A4M [Occ=Once*] :: a_a1A4J)
                 (i_a1A4N :: Int) ->
                 case ltInt i_a1A4N (GHC.Types.I# 0#) of {
                   False ->
                     case gtInt i_a1A4N (GHC.Types.I# 0#) of {
                       False -> x_a1A4M;
                       True -> rotateL @ a_a1A4J $dBits_a1Am6 x_a1A4M i_a1A4N
                     };
                   True ->
                     rotateR
                       @ a_a1A4J
                       $dBits_a1Am6
                       x_a1A4M
                       (case i_a1A4N of { I# x1_i1AMT [Occ=Once] ->
                        GHC.Types.I# (negateInt# x1_i1AMT)
                        })
                 }}]
Data.Bits.$dmrotate
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A4M :: a_a1A4J)
      (i_a1A4N :: Int) ->
      case i_a1A4N of wild_alN7 { I# x1_alN9 ->
      case <# x1_alN9 0# of {
        __DEFAULT ->
          case ># x1_alN9 0# of {
            __DEFAULT -> x_a1A4M;
            1# -> rotateL @ a_a1A4J $dBits_a1Am6 x_a1A4M wild_alN7
          };
        1# ->
          rotateR
            @ a_a1A4J $dBits_a1Am6 x_a1A4M (GHC.Types.I# (negateInt# x1_alN9))
      }
      }

-- RHS size: {terms: 30, types: 12, coercions: 0, joins: 0/0}
Data.Bits.$dmshift :: forall a. Bits a => a -> Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,1*C1(C1(U)),A,A,A,A)><L,U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1A4J)
                 ($dBits_a1Am6 [Occ=Once*] :: Bits a_a1A4J)
                 (x_a1A4K [Occ=Once*] :: a_a1A4J)
                 (i_a1A4L :: Int) ->
                 case ltInt i_a1A4L (GHC.Types.I# 0#) of {
                   False ->
                     case gtInt i_a1A4L (GHC.Types.I# 0#) of {
                       False -> x_a1A4K;
                       True -> shiftL @ a_a1A4J $dBits_a1Am6 x_a1A4K i_a1A4L
                     };
                   True ->
                     shiftR
                       @ a_a1A4J
                       $dBits_a1Am6
                       x_a1A4K
                       (case i_a1A4L of { I# x1_i1AMT [Occ=Once] ->
                        GHC.Types.I# (negateInt# x1_i1AMT)
                        })
                 }}]
Data.Bits.$dmshift
  = \ (@ a_a1A4J)
      ($dBits_a1Am6 :: Bits a_a1A4J)
      (x_a1A4K :: a_a1A4J)
      (i_a1A4L :: Int) ->
      case i_a1A4L of wild_alN7 { I# x1_alN9 ->
      case <# x1_alN9 0# of {
        __DEFAULT ->
          case ># x1_alN9 0# of {
            __DEFAULT -> x_a1A4K;
            1# -> shiftL @ a_a1A4J $dBits_a1Am6 x_a1A4K wild_alN7
          };
        1# ->
          shiftR
            @ a_a1A4J $dBits_a1Am6 x_a1A4K (GHC.Types.I# (negateInt# x1_alN9))
      }
      }

-- RHS size: {terms: 10, types: 9, coercions: 0, joins: 0/0}
bitDefault [InlPrag=INLINE (sat-args=0)]
  :: forall a. (Bits a, Num a) => Int -> a
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLLLLLLLLLC(C(S))LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a1AlX)
                 ($dBits_a1AlZ [Occ=Once] :: Bits a_a1AlX)
                 ($dNum_a1Am0 [Occ=Once] :: Num a_a1AlX)
                 (i_a1A6g [Occ=Once] :: Int) ->
                 shiftL
                   @ a_a1AlX
                   $dBits_a1AlZ
                   (fromInteger @ a_a1AlX $dNum_a1Am0 1)
                   i_a1A6g}]
bitDefault
  = \ (@ a_a1AlX)
      ($dBits_a1AlZ :: Bits a_a1AlX)
      ($dNum_a1Am0 :: Num a_a1AlX)
      (i_a1A6g :: Int) ->
      shiftL
        @ a_a1AlX
        $dBits_a1AlZ
        (fromInteger @ a_a1AlX $dNum_a1Am0 Data.Bits.$fBitsInteger3)
        i_a1A6g

-- RHS size: {terms: 17, types: 13, coercions: 0, joins: 0/0}
testBitDefault [InlPrag=INLINE (sat-args=0)]
  :: forall a. (Bits a, Num a) => a -> Int -> Bool
[GblId,
 Arity=4,
 Str=<S(S(LC(C(S)))LLLLLLLLLLLLLLLLLLLLLL),U(1*U(A,1*C1(C1(U))),1*C1(C1(U)),A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a1AlK)
                 ($dBits_a1AlM :: Bits a_a1AlK)
                 ($dNum_a1AlN [Occ=OnceL] :: Num a_a1AlK) ->
                 let {
                   $dEq_a1AlP [Occ=OnceL] :: Eq a_a1AlK
                   [LclId]
                   $dEq_a1AlP = Data.Bits.$p1Bits @ a_a1AlK $dBits_a1AlM } in
                 \ (x_a1A6h [Occ=Once] :: a_a1AlK) (i_a1A6i [Occ=Once] :: Int) ->
                   /=
                     @ a_a1AlK
                     $dEq_a1AlP
                     (.&.
                        @ a_a1AlK
                        $dBits_a1AlM
                        x_a1A6h
                        (bit @ a_a1AlK $dBits_a1AlM i_a1A6i))
                     (fromInteger @ a_a1AlK $dNum_a1AlN 0)}]
testBitDefault
  = \ (@ a_a1AlK)
      ($dBits_a1AlM :: Bits a_a1AlK)
      ($dNum_a1AlN :: Num a_a1AlK)
      (eta_B2 :: a_a1AlK)
      (eta1_B1 :: Int) ->
      /=
        @ a_a1AlK
        (Data.Bits.$p1Bits @ a_a1AlK $dBits_a1AlM)
        (.&.
           @ a_a1AlK $dBits_a1AlM eta_B2 (bit @ a_a1AlK $dBits_a1AlM eta1_B1))
        (fromInteger
           @ a_a1AlK $dNum_a1AlN Data.Bits.$fBitsInteger_$czeroBits)

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt2 :: Maybe Int
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$fBitsInt2 = GHC.Base.Just @ Int Data.Bits.$fBitsInt1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cbitSizeMaybe :: Word -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Bits.$fBitsInt2}]
Data.Bits.$fBitsWord_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> Data.Bits.$fBitsInt2

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cbit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once!] :: Int) ->
                 case i_a1A6g of { I# i#_a1A5q ->
                 case >=# i#_a1A5q 64# of {
                   __DEFAULT -> GHC.Types.W# (uncheckedShiftL# 1## i#_a1A5q);
                   1# -> GHC.Types.W# 0##
                 }
                 }}]
Data.Bits.$fBitsWord_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# i#_a1A5q ->
      case >=# i#_a1A5q 64# of {
        __DEFAULT -> GHC.Types.W# (uncheckedShiftL# 1## i#_a1A5q);
        1# -> Data.Bits.$fBitsWord1
      }
      }

-- RHS size: {terms: 25, types: 8, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: Word -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A6h [Occ=Once!] :: Word)
                 (i_a1A6i [Occ=Once!] :: Int) ->
                 case x_a1A6h of { W# x#_a1A5f [Occ=Once] ->
                 case i_a1A6i of { I# i#_a1A5q ->
                 case >=# i#_a1A5q 64# of {
                   __DEFAULT ->
                     neWord
                       (GHC.Types.W# (and# x#_a1A5f (uncheckedShiftL# 1## i#_a1A5q)))
                       (GHC.Types.W# 0##);
                   1# -> neWord (GHC.Types.W# 0##) (GHC.Types.W# 0##)
                 }
                 }
                 }}]
Data.Bits.$fBitsWord_$ctestBit
  = \ (x_a1A6h :: Word) (i_a1A6i :: Int) ->
      case x_a1A6h of { W# x#_a1A5f ->
      case i_a1A6i of { I# i#_a1A5q ->
      case >=# i#_a1A5q 64# of {
        __DEFAULT ->
          case and# x#_a1A5f (uncheckedShiftL# 1## i#_a1A5q) of {
            __DEFAULT -> GHC.Types.True;
            0## -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 26, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once!] :: Word)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case x_a1A54 of { W# x#_a1A5x ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 case andI# (negateInt# x1_i1AMT) 63# of wild2_X3A {
                   __DEFAULT ->
                     GHC.Types.W#
                       (or#
                          (uncheckedShiftL# x#_a1A5x wild2_X3A)
                          (uncheckedShiftRL# x#_a1A5x (-# 64# wild2_X3A)));
                   0# -> GHC.Types.W# x#_a1A5x
                 }
                 }
                 }}]
Data.Bits.$fBitsWord_$crotateR
  = \ (eta_B2 :: Word) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X3o { W# x#_a1A5x ->
      case eta1_B1 of { I# x_i1AMT ->
      case andI# (negateInt# x_i1AMT) 63# of wild2_X3A {
        __DEFAULT ->
          GHC.Types.W#
            (or#
               (uncheckedShiftL# x#_a1A5x wild2_X3A)
               (uncheckedShiftRL# x#_a1A5x (-# 64# wild2_X3A)));
        0# -> wild_X3o
      }
      }
      }

-- RHS size: {terms: 21, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Word)
                 (i_a1A4T [Occ=Once!] :: Int) ->
                 case x_a1A4S of { W# x#_a1A5j [Occ=Once*] ->
                 case i_a1A4T of { I# i#_a1A5q ->
                 case >=# i#_a1A5q 64# of {
                   __DEFAULT ->
                     GHC.Types.W# (xor# x#_a1A5j (uncheckedShiftL# 1## i#_a1A5q));
                   1# -> GHC.Types.W# x#_a1A5j
                 }
                 }
                 }}]
Data.Bits.$fBitsWord_$ccomplementBit
  = \ (eta_B2 :: Word) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X3r { W# x#_a1A5j ->
      case eta1_B1 of { I# i#_a1A5q ->
      case >=# i#_a1A5q 64# of {
        __DEFAULT ->
          GHC.Types.W# (xor# x#_a1A5j (uncheckedShiftL# 1## i#_a1A5q));
        1# -> wild_X3r
      }
      }
      }

-- RHS size: {terms: 26, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Word)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of { W# x#_a1A5f [Occ=Once*] ->
                 case i_a1A4R of { I# i#_a1A5q ->
                 case >=# i#_a1A5q 64# of {
                   __DEFAULT ->
                     GHC.Types.W#
                       (and#
                          x#_a1A5f
                          (xor# (uncheckedShiftL# 1## i#_a1A5q) 18446744073709551615##));
                   1# -> GHC.Types.W# (and# x#_a1A5f 18446744073709551615##)
                 }
                 }
                 }}]
Data.Bits.$fBitsWord_$cclearBit
  = \ (eta_B2 :: Word) (eta1_B1 :: Int) ->
      case eta_B2 of { W# x#_a1A5f ->
      case eta1_B1 of { I# i#_a1A5q ->
      case >=# i#_a1A5q 64# of {
        __DEFAULT ->
          GHC.Types.W#
            (and#
               x#_a1A5f
               (xor# (uncheckedShiftL# 1## i#_a1A5q) 18446744073709551615##));
        1# -> GHC.Types.W# (and# x#_a1A5f 18446744073709551615##)
      }
      }
      }

-- RHS size: {terms: 21, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Word)
                 (i_a1A4P [Occ=Once!] :: Int) ->
                 case x_a1A4O of { W# x#_a1A5h [Occ=Once*] ->
                 case i_a1A4P of { I# i#_a1A5q ->
                 case >=# i#_a1A5q 64# of {
                   __DEFAULT ->
                     GHC.Types.W# (or# x#_a1A5h (uncheckedShiftL# 1## i#_a1A5q));
                   1# -> GHC.Types.W# x#_a1A5h
                 }
                 }
                 }}]
Data.Bits.$fBitsWord_$csetBit
  = \ (eta_B2 :: Word) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X3s { W# x#_a1A5h ->
      case eta1_B1 of { I# i#_a1A5q ->
      case >=# i#_a1A5q 64# of {
        __DEFAULT ->
          GHC.Types.W# (or# x#_a1A5h (uncheckedShiftL# 1## i#_a1A5q));
        1# -> wild_X3s
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Word -> Int -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsWord_$crotate}]
Data.Bits.$fBitsWord_$crotateL = Data.Bits.$fBitsWord_$crotate

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsWord [InlPrag=NOUSERINLINE CONLIKE] :: Bits Word
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Word
                        GHC.Classes.$fEqWord
                        Data.Bits.$fBitsWord_$c.&.
                        Data.Bits.$fBitsWord_$c.|.
                        Data.Bits.$fBitsWord_$cxor
                        Data.Bits.$fBitsWord_$ccomplement
                        Data.Bits.$fBitsWord_$cshift
                        Data.Bits.$fBitsWord_$crotate
                        Data.Bits.$fBitsWord1
                        Data.Bits.$fBitsWord_$cbit
                        Data.Bits.$fBitsWord_$csetBit
                        Data.Bits.$fBitsWord_$cclearBit
                        Data.Bits.$fBitsWord_$ccomplementBit
                        Data.Bits.$fBitsWord_$ctestBit
                        Data.Bits.$fBitsWord_$cbitSizeMaybe
                        Data.Bits.$fBitsWord_$cfiniteBitSize
                        Data.Bits.$fBitsWord_$cisSigned
                        Data.Bits.$fBitsWord_$cshiftL
                        Data.Bits.$fBitsWord_$cunsafeShiftL
                        Data.Bits.$fBitsWord_$cshiftR
                        Data.Bits.$fBitsWord_$cunsafeShiftR
                        Data.Bits.$fBitsWord_$crotateL
                        Data.Bits.$fBitsWord_$crotateR
                        Data.Bits.$fBitsWord_$cpopCount]
Data.Bits.$fBitsWord
  = Data.Bits.C:Bits
      @ Word
      GHC.Classes.$fEqWord
      Data.Bits.$fBitsWord_$c.&.
      Data.Bits.$fBitsWord_$c.|.
      Data.Bits.$fBitsWord_$cxor
      Data.Bits.$fBitsWord_$ccomplement
      Data.Bits.$fBitsWord_$cshift
      Data.Bits.$fBitsWord_$crotate
      Data.Bits.$fBitsWord1
      Data.Bits.$fBitsWord_$cbit
      Data.Bits.$fBitsWord_$csetBit
      Data.Bits.$fBitsWord_$cclearBit
      Data.Bits.$fBitsWord_$ccomplementBit
      Data.Bits.$fBitsWord_$ctestBit
      Data.Bits.$fBitsWord_$cbitSizeMaybe
      Data.Bits.$fBitsWord_$cfiniteBitSize
      Data.Bits.$fBitsWord_$cisSigned
      Data.Bits.$fBitsWord_$cshiftL
      Data.Bits.$fBitsWord_$cunsafeShiftL
      Data.Bits.$fBitsWord_$cshiftR
      Data.Bits.$fBitsWord_$cunsafeShiftR
      Data.Bits.$fBitsWord_$crotateL
      Data.Bits.$fBitsWord_$crotateR
      Data.Bits.$fBitsWord_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fFiniteBitsWord [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Word
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Word
                              Data.Bits.$fBitsWord
                              Data.Bits.$fBitsWord_$cfiniteBitSize
                              Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
                              Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros]
Data.Bits.$fFiniteBitsWord
  = Data.Bits.C:FiniteBits
      @ Word
      Data.Bits.$fBitsWord
      Data.Bits.$fBitsWord_$cfiniteBitSize
      Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
      Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cbitSizeMaybe :: Int -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Bits.$fBitsInt2}]
Data.Bits.$fBitsInt_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> Data.Bits.$fBitsInt2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Bits.$fBitsInt_$crotate}]
Data.Bits.$fBitsInt_$crotateL = Data.Bits.$fBitsInt_$crotate

-- RHS size: {terms: 23, types: 7, coercions: 0, joins: 0/1}
Data.Bits.$fBitsInt_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once!] :: Int)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case x_a1A54 of { I# x#_a1A5X ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 let {
                   i'#_a1A5Z :: Int#
                   [LclId]
                   i'#_a1A5Z = andI# (negateInt# x1_i1AMT) 63# } in
                 GHC.Types.I#
                   (orI#
                      (uncheckedIShiftL# x#_a1A5X i'#_a1A5Z)
                      (uncheckedIShiftRL# x#_a1A5X (-# 64# i'#_a1A5Z)))
                 }
                 }}]
Data.Bits.$fBitsInt_$crotateR
  = \ (eta_B2 :: Int) (eta1_B1 :: Int) ->
      case eta_B2 of { I# x#_a1A5X ->
      case eta1_B1 of { I# x_i1AMT ->
      let {
        i'#_s1B35 [Dmd=<S,U>] :: Int#
        [LclId]
        i'#_s1B35 = andI# (negateInt# x_i1AMT) 63# } in
      GHC.Types.I#
        (orI#
           (uncheckedIShiftL# x#_a1A5X i'#_s1B35)
           (uncheckedIShiftRL# x#_a1A5X (-# 64# i'#_s1B35)))
      }
      }

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cbit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once!] :: Int) ->
                 case i_a1A6g of { I# i#_a1A5Q ->
                 case >=# i#_a1A5Q 64# of {
                   __DEFAULT -> GHC.Types.I# (uncheckedIShiftL# 1# i#_a1A5Q);
                   1# -> GHC.Types.I# 0#
                 }
                 }}]
Data.Bits.$fBitsInt_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# i#_a1A5Q ->
      case >=# i#_a1A5Q 64# of {
        __DEFAULT -> GHC.Types.I# (uncheckedIShiftL# 1# i#_a1A5Q);
        1# -> Data.Bits.$fBitsBool2
      }
      }

-- RHS size: {terms: 25, types: 8, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A6h [Occ=Once!] :: Int)
                 (i_a1A6i [Occ=Once!] :: Int) ->
                 case x_a1A6h of { I# x#_a1A5G [Occ=Once] ->
                 case i_a1A6i of { I# i#_a1A5Q ->
                 case >=# i#_a1A5Q 64# of {
                   __DEFAULT ->
                     neInt
                       (GHC.Types.I# (andI# x#_a1A5G (uncheckedIShiftL# 1# i#_a1A5Q)))
                       (GHC.Types.I# 0#);
                   1# -> neInt (GHC.Types.I# 0#) (GHC.Types.I# 0#)
                 }
                 }
                 }}]
Data.Bits.$fBitsInt_$ctestBit
  = \ (x_a1A6h :: Int) (i_a1A6i :: Int) ->
      case x_a1A6h of { I# x#_a1A5G ->
      case i_a1A6i of { I# i#_a1A5Q ->
      case >=# i#_a1A5Q 64# of {
        __DEFAULT ->
          case andI# x#_a1A5G (uncheckedIShiftL# 1# i#_a1A5Q) of {
            __DEFAULT -> GHC.Types.True;
            0# -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 21, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Int)
                 (i_a1A4P [Occ=Once!] :: Int) ->
                 case x_a1A4O of { I# x#_a1A5I [Occ=Once*] ->
                 case i_a1A4P of { I# i#_a1A5Q ->
                 case >=# i#_a1A5Q 64# of {
                   __DEFAULT ->
                     GHC.Types.I# (orI# x#_a1A5I (uncheckedIShiftL# 1# i#_a1A5Q));
                   1# -> GHC.Types.I# x#_a1A5I
                 }
                 }
                 }}]
Data.Bits.$fBitsInt_$csetBit
  = \ (eta_B2 :: Int) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X3d { I# x#_a1A5I ->
      case eta1_B1 of { I# i#_a1A5Q ->
      case >=# i#_a1A5Q 64# of {
        __DEFAULT ->
          GHC.Types.I# (orI# x#_a1A5I (uncheckedIShiftL# 1# i#_a1A5Q));
        1# -> wild_X3d
      }
      }
      }

-- RHS size: {terms: 25, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Int)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of { I# x#_a1A5G [Occ=Once*] ->
                 case i_a1A4R of { I# i#_a1A5Q ->
                 case >=# i#_a1A5Q 64# of {
                   __DEFAULT ->
                     GHC.Types.I#
                       (andI# x#_a1A5G (notI# (uncheckedIShiftL# 1# i#_a1A5Q)));
                   1# -> GHC.Types.I# (andI# x#_a1A5G -1#)
                 }
                 }
                 }}]
Data.Bits.$fBitsInt_$cclearBit
  = \ (eta_B2 :: Int) (eta1_B1 :: Int) ->
      case eta_B2 of { I# x#_a1A5G ->
      case eta1_B1 of { I# i#_a1A5Q ->
      case >=# i#_a1A5Q 64# of {
        __DEFAULT ->
          GHC.Types.I#
            (andI# x#_a1A5G (notI# (uncheckedIShiftL# 1# i#_a1A5Q)));
        1# -> GHC.Types.I# (andI# x#_a1A5G -1#)
      }
      }
      }

-- RHS size: {terms: 21, types: 7, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Int)
                 (i_a1A4T [Occ=Once!] :: Int) ->
                 case x_a1A4S of { I# x#_a1A5K [Occ=Once*] ->
                 case i_a1A4T of { I# i#_a1A5Q ->
                 case >=# i#_a1A5Q 64# of {
                   __DEFAULT ->
                     GHC.Types.I# (xorI# x#_a1A5K (uncheckedIShiftL# 1# i#_a1A5Q));
                   1# -> GHC.Types.I# x#_a1A5K
                 }
                 }
                 }}]
Data.Bits.$fBitsInt_$ccomplementBit
  = \ (eta_B2 :: Int) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X3c { I# x#_a1A5K ->
      case eta1_B1 of { I# i#_a1A5Q ->
      case >=# i#_a1A5Q 64# of {
        __DEFAULT ->
          GHC.Types.I# (xorI# x#_a1A5K (uncheckedIShiftL# 1# i#_a1A5Q));
        1# -> wild_X3c
      }
      }
      }

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInt [InlPrag=NOUSERINLINE CONLIKE] :: Bits Int
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Int
                        GHC.Classes.$fEqInt
                        Data.Bits.$fBitsInt_$c.&.
                        Data.Bits.$fBitsInt_$c.|.
                        Data.Bits.$fBitsInt_$cxor
                        Data.Bits.$fBitsInt_$ccomplement
                        Data.Bits.$fBitsInt_$cshift
                        Data.Bits.$fBitsInt_$crotate
                        Data.Bits.$fBitsBool2
                        Data.Bits.$fBitsInt_$cbit
                        Data.Bits.$fBitsInt_$csetBit
                        Data.Bits.$fBitsInt_$cclearBit
                        Data.Bits.$fBitsInt_$ccomplementBit
                        Data.Bits.$fBitsInt_$ctestBit
                        Data.Bits.$fBitsInt_$cbitSizeMaybe
                        Data.Bits.$fBitsInt_$cfiniteBitSize
                        Data.Bits.$fBitsInt_$cisSigned
                        Data.Bits.$fBitsInt_$cshiftL
                        Data.Bits.$fBitsInt_$cunsafeShiftL
                        Data.Bits.$fBitsInt_$cshiftR
                        Data.Bits.$fBitsInt_$cunsafeShiftR
                        Data.Bits.$fBitsInt_$crotateL
                        Data.Bits.$fBitsInt_$crotateR
                        Data.Bits.$fBitsInt_$cpopCount]
Data.Bits.$fBitsInt
  = Data.Bits.C:Bits
      @ Int
      GHC.Classes.$fEqInt
      Data.Bits.$fBitsInt_$c.&.
      Data.Bits.$fBitsInt_$c.|.
      Data.Bits.$fBitsInt_$cxor
      Data.Bits.$fBitsInt_$ccomplement
      Data.Bits.$fBitsInt_$cshift
      Data.Bits.$fBitsInt_$crotate
      Data.Bits.$fBitsBool2
      Data.Bits.$fBitsInt_$cbit
      Data.Bits.$fBitsInt_$csetBit
      Data.Bits.$fBitsInt_$cclearBit
      Data.Bits.$fBitsInt_$ccomplementBit
      Data.Bits.$fBitsInt_$ctestBit
      Data.Bits.$fBitsInt_$cbitSizeMaybe
      Data.Bits.$fBitsInt_$cfiniteBitSize
      Data.Bits.$fBitsInt_$cisSigned
      Data.Bits.$fBitsInt_$cshiftL
      Data.Bits.$fBitsInt_$cunsafeShiftL
      Data.Bits.$fBitsInt_$cshiftR
      Data.Bits.$fBitsInt_$cunsafeShiftR
      Data.Bits.$fBitsInt_$crotateL
      Data.Bits.$fBitsInt_$crotateR
      Data.Bits.$fBitsInt_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fFiniteBitsInt [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Int
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Int
                              Data.Bits.$fBitsInt
                              Data.Bits.$fBitsInt_$cfiniteBitSize
                              Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
                              Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros]
Data.Bits.$fFiniteBitsInt
  = Data.Bits.C:FiniteBits
      @ Int
      Data.Bits.$fBitsInt
      Data.Bits.$fBitsInt_$cfiniteBitSize
      Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
      Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros

-- RHS size: {terms: 40, types: 23, coercions: 0, joins: 1/4}
Data.Bits.$wpopCountDefault [InlPrag=INLINABLE[0]]
  :: forall a. (Bits a, Num a) => a -> Int#
[GblId,
 Arity=3,
 Str=<S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 90 0] 561 0
         Tmpl= \ (@ a_s1C1X)
                 (w_s1C1Y :: Bits a_s1C1X)
                 (w1_s1C1Z :: Num a_s1C1X)
                 (w2_s1C20 [Occ=Once] :: a_s1C1X) ->
                 let {
                   $dEq_a1AkY [Occ=OnceL] :: Eq a_s1C1X
                   [LclId]
                   $dEq_a1AkY = Data.Bits.$p1Bits @ a_s1C1X w_s1C1Y } in
                 letrec {
                   go_a1AkN [Occ=LoopBreaker] :: Int -> a_s1C1X -> Int
                   [LclId, Arity=2, Unf=OtherCon []]
                   go_a1AkN
                     = \ (c_a1A6k [Occ=Once!] :: Int) (ds_d1AEv :: a_s1C1X) ->
                         case c_a1A6k of c1_X1A6s { I# ipv_s1AOY [Occ=Once] ->
                         case ==
                                @ a_s1C1X $dEq_a1AkY ds_d1AEv (fromInteger @ a_s1C1X w1_s1C1Z 0)
                         of {
                           False ->
                             go_a1AkN
                               (GHC.Types.I# (+# ipv_s1AOY 1#))
                               (.&.
                                  @ a_s1C1X
                                  w_s1C1Y
                                  ds_d1AEv
                                  (- @ a_s1C1X
                                     w1_s1C1Z
                                     ds_d1AEv
                                     (fromInteger @ a_s1C1X w1_s1C1Z 1)));
                           True -> c1_X1A6s
                         }
                         }; } in
                 case go_a1AkN (GHC.Types.I# 0#) w2_s1C20 of
                 { I# ww1_s1C23 [Occ=Once] ->
                 ww1_s1C23
                 }}]
Data.Bits.$wpopCountDefault
  = \ (@ a_s1C1X)
      (w_s1C1Y :: Bits a_s1C1X)
      (w1_s1C1Z :: Num a_s1C1X)
      (w2_s1C20 :: a_s1C1X) ->
      let {
        lvl1_s1B45 :: a_s1C1X
        [LclId]
        lvl1_s1B45
          = fromInteger @ a_s1C1X w1_s1C1Z Data.Bits.$fBitsInteger3 } in
      let {
        lvl2_s1B43 :: a_s1C1X
        [LclId]
        lvl2_s1B43
          = fromInteger
              @ a_s1C1X w1_s1C1Z Data.Bits.$fBitsInteger_$czeroBits } in
      let {
        $dEq_s1B33 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_s1C1X
        [LclId]
        $dEq_s1B33 = Data.Bits.$p1Bits @ a_s1C1X w_s1C1Y } in
      joinrec {
        $wgo_s1C1W [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: Int# -> a_s1C1X -> Int#
        [LclId[JoinId(2)], Arity=2, Str=<S,U><L,U>, Unf=OtherCon []]
        $wgo_s1C1W (ww_s1C1U :: Int#) (w3_s1C1R :: a_s1C1X)
          = case == @ a_s1C1X $dEq_s1B33 w3_s1C1R lvl2_s1B43 of {
              False ->
                jump $wgo_s1C1W
                  (+# ww_s1C1U 1#)
                  (.&.
                     @ a_s1C1X
                     w_s1C1Y
                     w3_s1C1R
                     (- @ a_s1C1X w1_s1C1Z w3_s1C1R lvl1_s1B45));
              True -> ww_s1C1U
            }; } in
      jump $wgo_s1C1W 0# w2_s1C20

-- RHS size: {terms: 12, types: 9, coercions: 0, joins: 0/0}
popCountDefault [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Bits a, Num a) => a -> Int
[GblId,
 Arity=3,
 Str=<S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1C1X)
                 (w_s1C1Y [Occ=Once] :: Bits a_s1C1X)
                 (w1_s1C1Z [Occ=Once] :: Num a_s1C1X)
                 (w2_s1C20 [Occ=Once] :: a_s1C1X) ->
                 case Data.Bits.$wpopCountDefault
                        @ a_s1C1X w_s1C1Y w1_s1C1Z w2_s1C20
                 of ww_s1C23
                 { __DEFAULT ->
                 GHC.Types.I# ww_s1C23
                 }}]
popCountDefault
  = \ (@ a_s1C1X)
      (w_s1C1Y :: Bits a_s1C1X)
      (w1_s1C1Z :: Num a_s1C1X)
      (w2_s1C20 :: a_s1C1X) ->
      case Data.Bits.$wpopCountDefault
             @ a_s1C1X w_s1C1Y w1_s1C1Z w2_s1C20
      of ww_s1C23
      { __DEFAULT ->
      GHC.Types.I# ww_s1C23
      }

Rec {
-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits Integer
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Integer
                        integer-simple-0.1.1.1:GHC.Integer.Type.$fEqInteger
                        andInteger
                        orInteger
                        xorInteger
                        complementInteger
                        Data.Bits.$fBitsInteger_$cshift
                        Data.Bits.$fBitsInteger_$cshift
                        Data.Bits.$fBitsInteger_$czeroBits
                        Data.Bits.$fBitsInteger_$cbit
                        Data.Bits.$fBitsInteger_$csetBit
                        Data.Bits.$fBitsInteger_$cclearBit
                        Data.Bits.$fBitsInteger_$ccomplementBit
                        Data.Bits.$fBitsInteger_$ctestBit
                        Data.Bits.$fBitsInteger_$cbitSizeMaybe
                        Data.Bits.$fBitsInteger_$cbitSize
                        Data.Bits.$fBitsInteger_$cisSigned
                        Data.Bits.$fBitsInteger_$cshiftL
                        Data.Bits.$fBitsInteger_$cunsafeShiftL
                        Data.Bits.$fBitsInteger_$cshiftR
                        Data.Bits.$fBitsInteger_$cunsafeShiftR
                        Data.Bits.$fBitsInteger_$crotateL
                        Data.Bits.$fBitsInteger_$crotateR
                        Data.Bits.$fBitsInteger_$cpopCount]
Data.Bits.$fBitsInteger
  = Data.Bits.C:Bits
      @ Integer
      integer-simple-0.1.1.1:GHC.Integer.Type.$fEqInteger
      andInteger
      orInteger
      xorInteger
      complementInteger
      Data.Bits.$fBitsInteger_$cshift
      Data.Bits.$fBitsInteger_$cshift
      Data.Bits.$fBitsInteger_$czeroBits
      Data.Bits.$fBitsInteger_$cbit
      Data.Bits.$fBitsInteger_$csetBit
      Data.Bits.$fBitsInteger_$cclearBit
      Data.Bits.$fBitsInteger_$ccomplementBit
      Data.Bits.$fBitsInteger_$ctestBit
      Data.Bits.$fBitsInteger_$cbitSizeMaybe
      Data.Bits.$fBitsInteger_$cbitSize
      Data.Bits.$fBitsInteger_$cisSigned
      Data.Bits.$fBitsInteger_$cshiftL
      Data.Bits.$fBitsInteger_$cunsafeShiftL
      Data.Bits.$fBitsInteger_$cshiftR
      Data.Bits.$fBitsInteger_$cunsafeShiftR
      Data.Bits.$fBitsInteger_$crotateL
      Data.Bits.$fBitsInteger_$crotateR
      Data.Bits.$fBitsInteger_$cpopCount

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
Data.Bits.$fBitsInteger_$cpopCount [Occ=LoopBreaker]
  :: Integer -> Int
[GblId, Arity=1, Str=<L,U>m, Unf=OtherCon []]
Data.Bits.$fBitsInteger_$cpopCount
  = \ (w_s1C20 :: Integer) ->
      case Data.Bits.$wpopCountDefault
             @ Integer Data.Bits.$fBitsInteger GHC.Num.$fNumInteger w_s1C20
      of ww_s1C23
      { __DEFAULT ->
      GHC.Types.I# ww_s1C23
      }
end Rec }

-- RHS size: {terms: 542, types: 256, coercions: 0, joins: 17/25}
toIntegralSized [InlPrag=INLINABLE]
  :: forall a b.
     (Integral a, Integral b, Bits a, Bits b) =>
     a -> Maybe b
[GblId,
 Arity=5,
 Str=<L,U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U)),1*U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,1*C1(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(LLLLLLLLLLLLLC(S)LLLLLLLLL),U(A,A,A,A,A,A,A,A,C(U),A,A,A,A,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A)><S(LLLLLLLLLLLLLC(S)LC(S)LLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER
         Tmpl= \ (@ a_a1AhX)
                 (@ b_a1AhY)
                 ($dIntegral_a1Ai0 :: Integral a_a1AhX)
                 ($dIntegral1_a1Ai1 [Occ=OnceL] :: Integral b_a1AhY)
                 ($dBits_a1Ai2 :: Bits a_a1AhX)
                 ($dBits1_a1Ai3 :: Bits b_a1AhY) ->
                 let {
                   $dReal_a1Ayj [Occ=OnceL] :: Real b_a1AhY
                   [LclId]
                   $dReal_a1Ayj
                     = GHC.Real.$p1Integral @ b_a1AhY $dIntegral1_a1Ai1 } in
                 let {
                   $dNum_a1Ayl [Occ=OnceL] :: Num b_a1AhY
                   [LclId]
                   $dNum_a1Ayl = GHC.Real.$p1Real @ b_a1AhY $dReal_a1Ayj } in
                 let {
                   $dReal1_a1Aye :: Real a_a1AhX
                   [LclId]
                   $dReal1_a1Aye
                     = GHC.Real.$p1Integral @ a_a1AhX $dIntegral_a1Ai0 } in
                 let {
                   $dNum1_a1Ayg :: Num a_a1AhX
                   [LclId]
                   $dNum1_a1Ayg = GHC.Real.$p1Real @ a_a1AhX $dReal1_a1Aye } in
                 let {
                   $dOrd_a1Ayh :: Ord a_a1AhX
                   [LclId]
                   $dOrd_a1Ayh = GHC.Real.$p2Real @ a_a1AhX $dReal1_a1Aye } in
                 \ (x_a1A6n :: a_a1AhX) ->
                   let {
                     y_a1A6o :: b_a1AhY
                     [LclId]
                     y_a1A6o
                       = fromIntegral
                           @ a_a1AhX @ b_a1AhY $dIntegral_a1Ai0 $dNum_a1Ayl x_a1A6n } in
                   let {
                     yWidth_a1A6q :: Maybe Int
                     [LclId]
                     yWidth_a1A6q = bitSizeMaybe @ b_a1AhY $dBits1_a1Ai3 y_a1A6o } in
                   let {
                     ySigned_a1A6C :: Bool
                     [LclId]
                     ySigned_a1A6C = isSigned @ b_a1AhY $dBits1_a1Ai3 y_a1A6o } in
                   let {
                     yWidth1_a1A6B :: Maybe Int
                     [LclId]
                     yWidth1_a1A6B = bitSizeMaybe @ b_a1AhY $dBits1_a1Ai3 y_a1A6o } in
                   let {
                     xSigned_a1A6A :: Bool
                     [LclId]
                     xSigned_a1A6A = isSigned @ a_a1AhX $dBits_a1Ai2 x_a1A6n } in
                   let {
                     xWidth_a1A6z :: Maybe Int
                     [LclId]
                     xWidth_a1A6z = bitSizeMaybe @ a_a1AhX $dBits_a1Ai2 x_a1A6n } in
                   join {
                     $j_s1Bak :: Maybe b_a1AhY
                     [LclId[JoinId(0)]]
                     $j_s1Bak
                       = let {
                           ySigned1_X1Adg :: Bool
                           [LclId]
                           ySigned1_X1Adg = isSigned @ b_a1AhY $dBits1_a1Ai3 y_a1A6o } in
                         let {
                           yWidth2_X1Adh :: Maybe Int
                           [LclId]
                           yWidth2_X1Adh = bitSizeMaybe @ b_a1AhY $dBits1_a1Ai3 y_a1A6o } in
                         let {
                           xSigned1_X1Adi :: Bool
                           [LclId]
                           xSigned1_X1Adi = isSigned @ a_a1AhX $dBits_a1Ai2 x_a1A6n } in
                         let {
                           xWidth1_X1Adj :: Maybe Int
                           [LclId]
                           xWidth1_X1Adj = bitSizeMaybe @ a_a1AhX $dBits_a1Ai2 x_a1A6n } in
                         join {
                           $j1_s1B9W :: Maybe b_a1AhY
                           [LclId[JoinId(0)]]
                           $j1_s1B9W
                             = join {
                                 fail_d1AD4 [Occ=Once*!T[1]] :: Void# -> Maybe b_a1AhY
                                 [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                                 fail_d1AD4 _ [Occ=Dead, OS=OneShot]
                                   = case yWidth_a1A6q of {
                                       Nothing -> GHC.Base.Just @ b_a1AhY y_a1A6o;
                                       Just yW_a1A6w [Occ=Once*] ->
                                         case isSigned @ b_a1AhY $dBits1_a1Ai3 y_a1A6o of {
                                           False ->
                                             case <=
                                                    @ a_a1AhX
                                                    $dOrd_a1Ayh
                                                    x_a1A6n
                                                    (- @ a_a1AhX
                                                       $dNum1_a1Ayg
                                                       (bit @ a_a1AhX $dBits_a1Ai2 yW_a1A6w)
                                                       (fromInteger @ a_a1AhX $dNum1_a1Ayg 1))
                                             of {
                                               False -> GHC.Base.Nothing @ b_a1AhY;
                                               True -> GHC.Base.Just @ b_a1AhY y_a1A6o
                                             };
                                           True ->
                                             case <=
                                                    @ a_a1AhX
                                                    $dOrd_a1Ayh
                                                    x_a1A6n
                                                    (- @ a_a1AhX
                                                       $dNum1_a1Ayg
                                                       (bit
                                                          @ a_a1AhX
                                                          $dBits_a1Ai2
                                                          (case yW_a1A6w of
                                                           { I# x1_i1AMw [Occ=Once] ->
                                                           GHC.Types.I# (-# x1_i1AMw 1#)
                                                           }))
                                                       (fromInteger @ a_a1AhX $dNum1_a1Ayg 1))
                                             of {
                                               False -> GHC.Base.Nothing @ b_a1AhY;
                                               True -> GHC.Base.Just @ b_a1AhY y_a1A6o
                                             }
                                         }
                                     } } in
                               case isSigned @ a_a1AhX $dBits_a1Ai2 x_a1A6n of {
                                 False -> jump fail_d1AD4 void#;
                                 True ->
                                   case isSigned @ b_a1AhY $dBits1_a1Ai3 y_a1A6o of {
                                     False ->
                                       case bitSizeMaybe @ a_a1AhX $dBits_a1Ai2 x_a1A6n of {
                                         Nothing -> jump fail_d1AD4 void#;
                                         Just xW_a1A6u [Occ=Once] ->
                                           case yWidth_a1A6q of {
                                             Nothing -> jump fail_d1AD4 void#;
                                             Just yW_a1A6v [Occ=Once!] ->
                                               case yW_a1A6v of { I# x1_i1AMi [Occ=Once] ->
                                               case leInt xW_a1A6u (GHC.Types.I# (+# x1_i1AMi 1#))
                                               of {
                                                 False -> jump fail_d1AD4 void#;
                                                 True -> GHC.Base.Just @ b_a1AhY y_a1A6o
                                               }
                                               }
                                           }
                                       };
                                     True -> jump fail_d1AD4 void#
                                   }
                               } } in
                         join {
                           fail_d1AB3 :: Void# -> Maybe b_a1AhY
                           [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                           fail_d1AB3 _ [Occ=Dead, OS=OneShot]
                             = join {
                                 fail1_d1AB1 [Occ=Once*!T[1]] :: Void# -> Maybe b_a1AhY
                                 [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                                 fail1_d1AB1 _ [Occ=Dead, OS=OneShot]
                                   = join {
                                       fail2_d1AAZ [Occ=Once*!T[1]] :: Void# -> Maybe b_a1AhY
                                       [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                                       fail2_d1AAZ _ [Occ=Dead, OS=OneShot]
                                         = join {
                                             fail3_d1AAX :: Void# -> Maybe b_a1AhY
                                             [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                                             fail3_d1AAX _ [Occ=Dead, OS=OneShot]
                                               = case xSigned1_X1Adi of {
                                                   False ->
                                                     case ySigned1_X1Adg of {
                                                       False -> jump $j1_s1B9W;
                                                       True ->
                                                         case xWidth1_X1Adj of {
                                                           Nothing -> jump $j1_s1B9W;
                                                           Just xW_a1A6F [Occ=Once] ->
                                                             case yWidth2_X1Adh of {
                                                               Nothing -> jump $j1_s1B9W;
                                                               Just yW_a1A6G [Occ=Once] ->
                                                                 case ltInt xW_a1A6F yW_a1A6G of {
                                                                   False -> jump $j1_s1B9W;
                                                                   True ->
                                                                     GHC.Base.Just @ b_a1AhY y_a1A6o
                                                                 }
                                                             }
                                                         }
                                                     };
                                                   True -> jump $j1_s1B9W
                                                 } } in
                                           join {
                                             $j2_s1B8j [Occ=Once*T[0]] :: Maybe b_a1AhY
                                             [LclId[JoinId(0)]]
                                             $j2_s1B8j
                                               = case xWidth1_X1Adj of {
                                                   Nothing -> jump fail3_d1AAX void#;
                                                   Just xW_a1A6D [Occ=Once] ->
                                                     case yWidth2_X1Adh of {
                                                       Nothing -> jump fail3_d1AAX void#;
                                                       Just yW_a1A6E [Occ=Once] ->
                                                         case leInt xW_a1A6D yW_a1A6E of {
                                                           False -> jump $j1_s1B9W;
                                                           True -> GHC.Base.Just @ b_a1AhY y_a1A6o
                                                         }
                                                     }
                                                 } } in
                                           case xSigned1_X1Adi of {
                                             False ->
                                               case ySigned1_X1Adg of {
                                                 False -> jump $j2_s1B8j;
                                                 True -> jump fail3_d1AAX void#
                                               };
                                             True ->
                                               case ySigned1_X1Adg of {
                                                 False -> jump fail3_d1AAX void#;
                                                 True -> jump $j2_s1B8j
                                               }
                                           } } in
                                     case xSigned1_X1Adi of {
                                       False ->
                                         case ySigned1_X1Adg of {
                                           False ->
                                             case yWidth2_X1Adh of {
                                               Nothing -> GHC.Base.Just @ b_a1AhY y_a1A6o;
                                               Just _ [Occ=Dead] -> jump fail2_d1AAZ void#
                                             };
                                           True -> jump fail2_d1AAZ void#
                                         };
                                       True -> jump fail2_d1AAZ void#
                                     } } in
                               case ySigned1_X1Adg of {
                                 False -> jump fail1_d1AB1 void#;
                                 True ->
                                   case yWidth2_X1Adh of {
                                     Nothing -> GHC.Base.Just @ b_a1AhY y_a1A6o;
                                     Just _ [Occ=Dead] -> jump fail1_d1AB1 void#
                                   }
                               } } in
                         join {
                           $j2_s1B8x [Occ=Once*T[0]] :: Maybe b_a1AhY
                           [LclId[JoinId(0)]]
                           $j2_s1B8x
                             = case xSigned1_X1Adi of {
                                 False ->
                                   case ySigned1_X1Adg of {
                                     False -> GHC.Base.Just @ b_a1AhY y_a1A6o;
                                     True -> jump fail_d1AB3 void#
                                   };
                                 True ->
                                   case ySigned1_X1Adg of {
                                     False -> jump fail_d1AB3 void#;
                                     True -> GHC.Base.Just @ b_a1AhY y_a1A6o
                                   }
                               } } in
                         case xWidth1_X1Adj of {
                           Nothing ->
                             case yWidth2_X1Adh of {
                               Nothing -> jump $j2_s1B8x;
                               Just _ [Occ=Dead] -> jump fail_d1AB3 void#
                             };
                           Just a1_i1APF [Occ=Once] ->
                             case yWidth2_X1Adh of {
                               Nothing -> jump fail_d1AB3 void#;
                               Just b1_i1APK [Occ=Once] ->
                                 case eqInt a1_i1APF b1_i1APK of {
                                   False -> jump fail_d1AB3 void#;
                                   True -> jump $j2_s1B8x
                                 }
                             }
                         } } in
                   join {
                     $j1_s1Bau :: Maybe b_a1AhY
                     [LclId[JoinId(0)]]
                     $j1_s1Bau
                       = join {
                           fail_d1ADH [Occ=Once*!T[1]] :: Void# -> Maybe b_a1AhY
                           [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                           fail_d1ADH _ [Occ=Dead, OS=OneShot]
                             = case isSigned @ a_a1AhX $dBits_a1Ai2 x_a1A6n of {
                                 False -> jump $j_s1Bak;
                                 True ->
                                   case isSigned @ b_a1AhY $dBits1_a1Ai3 y_a1A6o of {
                                     False -> jump $j_s1Bak;
                                     True ->
                                       case yWidth_a1A6q of {
                                         Nothing -> jump $j_s1Bak;
                                         Just yW_a1A6t [Occ=Once!] ->
                                           case <=
                                                  @ a_a1AhX
                                                  $dOrd_a1Ayh
                                                  (negate
                                                     @ a_a1AhX
                                                     $dNum1_a1Ayg
                                                     (bit
                                                        @ a_a1AhX
                                                        $dBits_a1Ai2
                                                        (case yW_a1A6t of
                                                         { I# x1_i1AMw [Occ=Once] ->
                                                         GHC.Types.I# (-# x1_i1AMw 1#)
                                                         })))
                                                  x_a1A6n
                                           of {
                                             False -> GHC.Base.Nothing @ b_a1AhY;
                                             True -> jump $j_s1Bak
                                           }
                                       }
                                   }
                               } } in
                         case isSigned @ a_a1AhX $dBits_a1Ai2 x_a1A6n of {
                           False -> jump fail_d1ADH void#;
                           True ->
                             case isSigned @ b_a1AhY $dBits1_a1Ai3 y_a1A6o of {
                               False ->
                                 case <=
                                        @ a_a1AhX
                                        $dOrd_a1Ayh
                                        (fromInteger @ a_a1AhX $dNum1_a1Ayg 0)
                                        x_a1A6n
                                 of {
                                   False -> GHC.Base.Nothing @ b_a1AhY;
                                   True -> jump $j_s1Bak
                                 };
                               True -> jump fail_d1ADH void#
                             }
                         } } in
                   join {
                     fail_d1AB3 :: Void# -> Maybe b_a1AhY
                     [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                     fail_d1AB3 _ [Occ=Dead, OS=OneShot]
                       = join {
                           fail1_d1AB1 [Occ=Once*!T[1]] :: Void# -> Maybe b_a1AhY
                           [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                           fail1_d1AB1 _ [Occ=Dead, OS=OneShot]
                             = join {
                                 fail2_d1AAZ [Occ=Once*!T[1]] :: Void# -> Maybe b_a1AhY
                                 [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                                 fail2_d1AAZ _ [Occ=Dead, OS=OneShot]
                                   = join {
                                       fail3_d1AAX :: Void# -> Maybe b_a1AhY
                                       [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                                       fail3_d1AAX _ [Occ=Dead, OS=OneShot]
                                         = case xSigned_a1A6A of {
                                             False ->
                                               case ySigned_a1A6C of {
                                                 False -> jump $j1_s1Bau;
                                                 True ->
                                                   case xWidth_a1A6z of {
                                                     Nothing -> jump $j1_s1Bau;
                                                     Just xW_a1A6F [Occ=Once] ->
                                                       case yWidth1_a1A6B of {
                                                         Nothing -> jump $j1_s1Bau;
                                                         Just yW_a1A6G [Occ=Once] ->
                                                           case ltInt xW_a1A6F yW_a1A6G of {
                                                             False -> jump $j1_s1Bau;
                                                             True -> jump $j_s1Bak
                                                           }
                                                       }
                                                   }
                                               };
                                             True -> jump $j1_s1Bau
                                           } } in
                                     join {
                                       $j2_s1B8j [Occ=Once*T[0]] :: Maybe b_a1AhY
                                       [LclId[JoinId(0)]]
                                       $j2_s1B8j
                                         = case xWidth_a1A6z of {
                                             Nothing -> jump fail3_d1AAX void#;
                                             Just xW_a1A6D [Occ=Once] ->
                                               case yWidth1_a1A6B of {
                                                 Nothing -> jump fail3_d1AAX void#;
                                                 Just yW_a1A6E [Occ=Once] ->
                                                   case leInt xW_a1A6D yW_a1A6E of {
                                                     False -> jump $j1_s1Bau;
                                                     True -> jump $j_s1Bak
                                                   }
                                               }
                                           } } in
                                     case xSigned_a1A6A of {
                                       False ->
                                         case ySigned_a1A6C of {
                                           False -> jump $j2_s1B8j;
                                           True -> jump fail3_d1AAX void#
                                         };
                                       True ->
                                         case ySigned_a1A6C of {
                                           False -> jump fail3_d1AAX void#;
                                           True -> jump $j2_s1B8j
                                         }
                                     } } in
                               case xSigned_a1A6A of {
                                 False ->
                                   case ySigned_a1A6C of {
                                     False ->
                                       case yWidth1_a1A6B of {
                                         Nothing -> jump $j_s1Bak;
                                         Just _ [Occ=Dead] -> jump fail2_d1AAZ void#
                                       };
                                     True -> jump fail2_d1AAZ void#
                                   };
                                 True -> jump fail2_d1AAZ void#
                               } } in
                         case ySigned_a1A6C of {
                           False -> jump fail1_d1AB1 void#;
                           True ->
                             case yWidth1_a1A6B of {
                               Nothing -> jump $j_s1Bak;
                               Just _ [Occ=Dead] -> jump fail1_d1AB1 void#
                             }
                         } } in
                   join {
                     $j2_s1B8x [Occ=Once*T[0]] :: Maybe b_a1AhY
                     [LclId[JoinId(0)]]
                     $j2_s1B8x
                       = case xSigned_a1A6A of {
                           False ->
                             case ySigned_a1A6C of {
                               False -> jump $j_s1Bak;
                               True -> jump fail_d1AB3 void#
                             };
                           True ->
                             case ySigned_a1A6C of {
                               False -> jump fail_d1AB3 void#;
                               True -> jump $j_s1Bak
                             }
                         } } in
                   case xWidth_a1A6z of {
                     Nothing ->
                       case yWidth1_a1A6B of {
                         Nothing -> jump $j2_s1B8x;
                         Just _ [Occ=Dead] -> jump fail_d1AB3 void#
                       };
                     Just a1_i1APF [Occ=Once] ->
                       case yWidth1_a1A6B of {
                         Nothing -> jump fail_d1AB3 void#;
                         Just b1_i1APK [Occ=Once] ->
                           case eqInt a1_i1APF b1_i1APK of {
                             False -> jump fail_d1AB3 void#;
                             True -> jump $j2_s1B8x
                           }
                       }
                   }}]
toIntegralSized
  = \ (@ a_a1AhX)
      (@ b_a1AhY)
      ($dIntegral_a1Ai0 :: Integral a_a1AhX)
      ($dIntegral1_a1Ai1 :: Integral b_a1AhY)
      ($dBits_a1Ai2 :: Bits a_a1AhX)
      ($dBits1_a1Ai3 :: Bits b_a1AhY)
      (eta_B1 :: a_a1AhX) ->
      let {
        xWidth_a1A6z [Dmd=<S,U>] :: Maybe Int
        [LclId]
        xWidth_a1A6z = bitSizeMaybe @ a_a1AhX $dBits_a1Ai2 eta_B1 } in
      let {
        y_s1B2C :: b_a1AhY
        [LclId]
        y_s1B2C
          = fromInteger
              @ b_a1AhY
              (GHC.Real.$p1Real
                 @ b_a1AhY (GHC.Real.$p1Integral @ b_a1AhY $dIntegral1_a1Ai1))
              (toInteger @ a_a1AhX $dIntegral_a1Ai0 eta_B1) } in
      let {
        ySigned_a1A6C [Dmd=<S,U>] :: Bool
        [LclId]
        ySigned_a1A6C = isSigned @ b_a1AhY $dBits1_a1Ai3 y_s1B2C } in
      let {
        yWidth_s1B2B [Dmd=<S,U>] :: Maybe Int
        [LclId]
        yWidth_s1B2B = bitSizeMaybe @ b_a1AhY $dBits1_a1Ai3 y_s1B2C } in
      let {
        xSigned_a1A6A :: Bool
        [LclId]
        xSigned_a1A6A = isSigned @ a_a1AhX $dBits_a1Ai2 eta_B1 } in
      let {
        $dReal_s1B2F [Dmd=<L,U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U)),1*U(A,A,A,C(C1(U)),A,A,A,A),A)>]
          :: Real a_a1AhX
        [LclId]
        $dReal_s1B2F = GHC.Real.$p1Integral @ a_a1AhX $dIntegral_a1Ai0 } in
      let {
        $dNum_s1B2E [Dmd=<L,U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U))>]
          :: Num a_a1AhX
        [LclId]
        $dNum_s1B2E = GHC.Real.$p1Real @ a_a1AhX $dReal_s1B2F } in
      let {
        $dOrd_s1B2D [Dmd=<L,U(A,A,A,C(C1(U)),A,A,A,A)>] :: Ord a_a1AhX
        [LclId]
        $dOrd_s1B2D = GHC.Real.$p2Real @ a_a1AhX $dReal_s1B2F } in
      join {
        $j_s1B9c [Dmd=<L,1*U>] :: Maybe b_a1AhY
        [LclId[JoinId(0)]]
        $j_s1B9c
          = join {
              fail_d1AB3 [Dmd=<L,1*C1(U)>] :: Void# -> Maybe b_a1AhY
              [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
              fail_d1AB3 _ [Occ=Dead, OS=OneShot]
                = join {
                    fail1_d1AB1 [Dmd=<L,1*C1(U)>] :: Void# -> Maybe b_a1AhY
                    [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                    fail1_d1AB1 _ [Occ=Dead, OS=OneShot]
                      = join {
                          fail2_d1AAZ [Dmd=<L,1*C1(U)>] :: Void# -> Maybe b_a1AhY
                          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                          fail2_d1AAZ _ [Occ=Dead, OS=OneShot]
                            = join {
                                $j1_s1B8O [Dmd=<L,1*U>] :: Maybe b_a1AhY
                                [LclId[JoinId(0)]]
                                $j1_s1B8O
                                  = join {
                                      fail3_s1B2J [Dmd=<L,1*C1(U)>] :: Void# -> Maybe b_a1AhY
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                                      fail3_s1B2J _ [Occ=Dead, OS=OneShot]
                                        = case yWidth_s1B2B of {
                                            Nothing -> GHC.Base.Just @ b_a1AhY y_s1B2C;
                                            Just yW_a1A6w ->
                                              case ySigned_a1A6C of {
                                                False ->
                                                  case <=
                                                         @ a_a1AhX
                                                         $dOrd_s1B2D
                                                         eta_B1
                                                         (- @ a_a1AhX
                                                            $dNum_s1B2E
                                                            (bit @ a_a1AhX $dBits_a1Ai2 yW_a1A6w)
                                                            (fromInteger
                                                               @ a_a1AhX
                                                               $dNum_s1B2E
                                                               Data.Bits.$fBitsInteger3))
                                                  of {
                                                    False -> GHC.Base.Nothing @ b_a1AhY;
                                                    True -> GHC.Base.Just @ b_a1AhY y_s1B2C
                                                  };
                                                True ->
                                                  case <=
                                                         @ a_a1AhX
                                                         $dOrd_s1B2D
                                                         eta_B1
                                                         (- @ a_a1AhX
                                                            $dNum_s1B2E
                                                            (bit
                                                               @ a_a1AhX
                                                               $dBits_a1Ai2
                                                               (case yW_a1A6w of { I# x_i1AMw ->
                                                                GHC.Types.I# (-# x_i1AMw 1#)
                                                                }))
                                                            (fromInteger
                                                               @ a_a1AhX
                                                               $dNum_s1B2E
                                                               Data.Bits.$fBitsInteger3))
                                                  of {
                                                    False -> GHC.Base.Nothing @ b_a1AhY;
                                                    True -> GHC.Base.Just @ b_a1AhY y_s1B2C
                                                  }
                                              }
                                          } } in
                                    case xSigned_a1A6A of {
                                      False -> jump fail3_s1B2J void#;
                                      True ->
                                        case ySigned_a1A6C of {
                                          False ->
                                            case xWidth_a1A6z of {
                                              Nothing -> jump fail3_s1B2J void#;
                                              Just xW_a1A6u ->
                                                case yWidth_s1B2B of {
                                                  Nothing -> jump fail3_s1B2J void#;
                                                  Just yW_a1A6v ->
                                                    case yW_a1A6v of { I# x_i1AMi ->
                                                    case xW_a1A6u of { I# x1_at1e ->
                                                    case <=# x1_at1e (+# x_i1AMi 1#) of {
                                                      __DEFAULT -> jump fail3_s1B2J void#;
                                                      1# -> GHC.Base.Just @ b_a1AhY y_s1B2C
                                                    }
                                                    }
                                                    }
                                                }
                                            };
                                          True -> jump fail3_s1B2J void#
                                        }
                                    } } in
                              join {
                                fail3_d1AAX [Dmd=<L,1*C1(U)>] :: Void# -> Maybe b_a1AhY
                                [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                                fail3_d1AAX _ [Occ=Dead, OS=OneShot]
                                  = case xSigned_a1A6A of {
                                      False ->
                                        case ySigned_a1A6C of {
                                          False -> jump $j1_s1B8O;
                                          True ->
                                            case xWidth_a1A6z of {
                                              Nothing -> jump $j1_s1B8O;
                                              Just xW_a1A6F ->
                                                case yWidth_s1B2B of {
                                                  Nothing -> jump $j1_s1B8O;
                                                  Just yW_a1A6G ->
                                                    case xW_a1A6F of { I# x_alN9 ->
                                                    case yW_a1A6G of { I# y1_alNd ->
                                                    case <# x_alN9 y1_alNd of {
                                                      __DEFAULT -> jump $j1_s1B8O;
                                                      1# -> GHC.Base.Just @ b_a1AhY y_s1B2C
                                                    }
                                                    }
                                                    }
                                                }
                                            }
                                        };
                                      True -> jump $j1_s1B8O
                                    } } in
                              join {
                                $j2_s1B8j [Dmd=<L,1*U>] :: Maybe b_a1AhY
                                [LclId[JoinId(0)]]
                                $j2_s1B8j
                                  = case xWidth_a1A6z of {
                                      Nothing -> jump fail3_d1AAX void#;
                                      Just xW_a1A6D ->
                                        case yWidth_s1B2B of {
                                          Nothing -> jump fail3_d1AAX void#;
                                          Just yW_a1A6E ->
                                            case xW_a1A6D of { I# x_at1e ->
                                            case yW_a1A6E of { I# y1_at1i ->
                                            case <=# x_at1e y1_at1i of {
                                              __DEFAULT -> jump $j1_s1B8O;
                                              1# -> GHC.Base.Just @ b_a1AhY y_s1B2C
                                            }
                                            }
                                            }
                                        }
                                    } } in
                              case xSigned_a1A6A of {
                                False ->
                                  case ySigned_a1A6C of {
                                    False -> jump $j2_s1B8j;
                                    True -> jump fail3_d1AAX void#
                                  };
                                True ->
                                  case ySigned_a1A6C of {
                                    False -> jump fail3_d1AAX void#;
                                    True -> jump $j2_s1B8j
                                  }
                              } } in
                        case xSigned_a1A6A of {
                          False ->
                            case ySigned_a1A6C of {
                              False ->
                                case yWidth_s1B2B of {
                                  Nothing -> GHC.Base.Just @ b_a1AhY y_s1B2C;
                                  Just ipv_i1APN -> jump fail2_d1AAZ void#
                                };
                              True -> jump fail2_d1AAZ void#
                            };
                          True -> jump fail2_d1AAZ void#
                        } } in
                  case ySigned_a1A6C of {
                    False -> jump fail1_d1AB1 void#;
                    True ->
                      case yWidth_s1B2B of {
                        Nothing -> GHC.Base.Just @ b_a1AhY y_s1B2C;
                        Just ipv_i1APN -> jump fail1_d1AB1 void#
                      }
                  } } in
            join {
              $j1_s1B8x [Dmd=<L,1*U>] :: Maybe b_a1AhY
              [LclId[JoinId(0)]]
              $j1_s1B8x
                = case xSigned_a1A6A of {
                    False ->
                      case ySigned_a1A6C of {
                        False -> GHC.Base.Just @ b_a1AhY y_s1B2C;
                        True -> jump fail_d1AB3 void#
                      };
                    True ->
                      case ySigned_a1A6C of {
                        False -> jump fail_d1AB3 void#;
                        True -> GHC.Base.Just @ b_a1AhY y_s1B2C
                      }
                  } } in
            case xWidth_a1A6z of {
              Nothing ->
                case yWidth_s1B2B of {
                  Nothing -> jump $j1_s1B8x;
                  Just ipv_i1APN -> jump fail_d1AB3 void#
                };
              Just a1_i1APF ->
                case yWidth_s1B2B of {
                  Nothing -> jump fail_d1AB3 void#;
                  Just b1_i1APK ->
                    case a1_i1APF of { I# x_a22G ->
                    case b1_i1APK of { I# y1_a22K ->
                    case ==# x_a22G y1_a22K of {
                      __DEFAULT -> jump fail_d1AB3 void#;
                      1# -> jump $j1_s1B8x
                    }
                    }
                    }
                }
            } } in
      join {
        fail_d1AB3 [Dmd=<L,1*C1(U)>] :: Void# -> Maybe b_a1AhY
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_d1AB3 _ [Occ=Dead, OS=OneShot]
          = join {
              fail1_d1AB1 [Dmd=<L,1*C1(U)>] :: Void# -> Maybe b_a1AhY
              [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
              fail1_d1AB1 _ [Occ=Dead, OS=OneShot]
                = join {
                    fail2_d1AAZ [Dmd=<L,1*C1(U)>] :: Void# -> Maybe b_a1AhY
                    [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                    fail2_d1AAZ _ [Occ=Dead, OS=OneShot]
                      = join {
                          $j1_s1B9m [Dmd=<L,1*U>] :: Maybe b_a1AhY
                          [LclId[JoinId(0)]]
                          $j1_s1B9m
                            = join {
                                fail3_s1B2H [Dmd=<L,1*C1(U)>] :: Void# -> Maybe b_a1AhY
                                [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                                fail3_s1B2H _ [Occ=Dead, OS=OneShot]
                                  = case xSigned_a1A6A of {
                                      False -> jump $j_s1B9c;
                                      True ->
                                        case ySigned_a1A6C of {
                                          False -> jump $j_s1B9c;
                                          True ->
                                            case yWidth_s1B2B of {
                                              Nothing -> jump $j_s1B9c;
                                              Just yW_a1A6t ->
                                                case <=
                                                       @ a_a1AhX
                                                       $dOrd_s1B2D
                                                       (negate
                                                          @ a_a1AhX
                                                          $dNum_s1B2E
                                                          (bit
                                                             @ a_a1AhX
                                                             $dBits_a1Ai2
                                                             (case yW_a1A6t of { I# x_i1AMw ->
                                                              GHC.Types.I# (-# x_i1AMw 1#)
                                                              })))
                                                       eta_B1
                                                of {
                                                  False -> GHC.Base.Nothing @ b_a1AhY;
                                                  True -> jump $j_s1B9c
                                                }
                                            }
                                        }
                                    } } in
                              case xSigned_a1A6A of {
                                False -> jump fail3_s1B2H void#;
                                True ->
                                  case ySigned_a1A6C of {
                                    False ->
                                      case <=
                                             @ a_a1AhX
                                             $dOrd_s1B2D
                                             (fromInteger
                                                @ a_a1AhX
                                                $dNum_s1B2E
                                                Data.Bits.$fBitsInteger_$czeroBits)
                                             eta_B1
                                      of {
                                        False -> GHC.Base.Nothing @ b_a1AhY;
                                        True -> jump $j_s1B9c
                                      };
                                    True -> jump fail3_s1B2H void#
                                  }
                              } } in
                        join {
                          fail3_d1AAX [Dmd=<L,1*C1(U)>] :: Void# -> Maybe b_a1AhY
                          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                          fail3_d1AAX _ [Occ=Dead, OS=OneShot]
                            = case xSigned_a1A6A of {
                                False ->
                                  case ySigned_a1A6C of {
                                    False -> jump $j1_s1B9m;
                                    True ->
                                      case xWidth_a1A6z of {
                                        Nothing -> jump $j1_s1B9m;
                                        Just xW_a1A6F ->
                                          case yWidth_s1B2B of {
                                            Nothing -> jump $j1_s1B9m;
                                            Just yW_a1A6G ->
                                              case xW_a1A6F of { I# x_alN9 ->
                                              case yW_a1A6G of { I# y1_alNd ->
                                              case <# x_alN9 y1_alNd of {
                                                __DEFAULT -> jump $j1_s1B9m;
                                                1# -> jump $j_s1B9c
                                              }
                                              }
                                              }
                                          }
                                      }
                                  };
                                True -> jump $j1_s1B9m
                              } } in
                        join {
                          $j2_s1B8j [Dmd=<L,1*U>] :: Maybe b_a1AhY
                          [LclId[JoinId(0)]]
                          $j2_s1B8j
                            = case xWidth_a1A6z of {
                                Nothing -> jump fail3_d1AAX void#;
                                Just xW_a1A6D ->
                                  case yWidth_s1B2B of {
                                    Nothing -> jump fail3_d1AAX void#;
                                    Just yW_a1A6E ->
                                      case xW_a1A6D of { I# x_at1e ->
                                      case yW_a1A6E of { I# y1_at1i ->
                                      case <=# x_at1e y1_at1i of {
                                        __DEFAULT -> jump $j1_s1B9m;
                                        1# -> jump $j_s1B9c
                                      }
                                      }
                                      }
                                  }
                              } } in
                        case xSigned_a1A6A of {
                          False ->
                            case ySigned_a1A6C of {
                              False -> jump $j2_s1B8j;
                              True -> jump fail3_d1AAX void#
                            };
                          True ->
                            case ySigned_a1A6C of {
                              False -> jump fail3_d1AAX void#;
                              True -> jump $j2_s1B8j
                            }
                        } } in
                  case xSigned_a1A6A of {
                    False ->
                      case ySigned_a1A6C of {
                        False ->
                          case yWidth_s1B2B of {
                            Nothing -> jump $j_s1B9c;
                            Just ipv_i1APN -> jump fail2_d1AAZ void#
                          };
                        True -> jump fail2_d1AAZ void#
                      };
                    True -> jump fail2_d1AAZ void#
                  } } in
            case ySigned_a1A6C of {
              False -> jump fail1_d1AB1 void#;
              True ->
                case yWidth_s1B2B of {
                  Nothing -> jump $j_s1B9c;
                  Just ipv_i1APN -> jump fail1_d1AB1 void#
                }
            } } in
      join {
        $j1_s1B8x [Dmd=<L,1*U>] :: Maybe b_a1AhY
        [LclId[JoinId(0)]]
        $j1_s1B8x
          = case xSigned_a1A6A of {
              False ->
                case ySigned_a1A6C of {
                  False -> jump $j_s1B9c;
                  True -> jump fail_d1AB3 void#
                };
              True ->
                case ySigned_a1A6C of {
                  False -> jump fail_d1AB3 void#;
                  True -> jump $j_s1B9c
                }
            } } in
      case xWidth_a1A6z of {
        Nothing ->
          case yWidth_s1B2B of {
            Nothing -> jump $j1_s1B8x;
            Just ipv_i1APN -> jump fail_d1AB3 void#
          };
        Just a1_i1APF ->
          case yWidth_s1B2B of {
            Nothing -> jump fail_d1AB3 void#;
            Just b1_i1APK ->
              case a1_i1APF of { I# x_a22G ->
              case b1_i1APK of { I# y1_a22K ->
              case ==# x_a22G y1_a22K of {
                __DEFAULT -> jump fail_d1AB3 void#;
                1# -> jump $j1_s1B8x
              }
              }
              }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Bits.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$trModule3 = GHC.Types.TrNameS Data.Bits.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Bits.$trModule2 = "Data.Bits"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$trModule1 = GHC.Types.TrNameS Data.Bits.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Bits.$trModule
  = GHC.Types.Module Data.Bits.$trModule3 Data.Bits.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r1CDE :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r1CDE
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcBool (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_r1CDF :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_r1CDF
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcInt (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2_r1CDG :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_r1CDG
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep3_r1CDH :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep3_r1CDH
  = GHC.Types.: @ KindRep $krep1_r1CDF (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_r1CDI :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_r1CDI
  = GHC.Types.KindRepTyConApp GHC.Base.$tcMaybe $krep3_r1CDH

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_r1CDJ :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep5_r1CDJ = GHC.Types.KindRepFun $krep1_r1CDF $krep_r1CDE

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tcBits1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Bits.$tcBits1
  = GHC.Types.KindRepFun GHC.Types.krep$* $krep2_r1CDG

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep6_r1CDK :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep6_r1CDK = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7_r1CDL :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep7_r1CDL = GHC.Types.KindRepFun $krep6_r1CDK $krep6_r1CDK

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_r1CDM :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep8_r1CDM = GHC.Types.KindRepFun $krep6_r1CDK $krep7_r1CDL

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_r1CDN :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep9_r1CDN = GHC.Types.KindRepFun $krep6_r1CDK $krep5_r1CDJ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_r1CDO :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep10_r1CDO = GHC.Types.KindRepFun $krep6_r1CDK $krep4_r1CDI

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_r1CDP :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep11_r1CDP = GHC.Types.KindRepFun $krep6_r1CDK $krep1_r1CDF

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_r1CDQ :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep12_r1CDQ = GHC.Types.KindRepFun $krep6_r1CDK $krep_r1CDE

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13_r1CDR :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep13_r1CDR = GHC.Types.KindRepFun $krep1_r1CDF $krep6_r1CDK

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep14_r1CDS :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep14_r1CDS = GHC.Types.KindRepFun $krep6_r1CDK $krep13_r1CDR

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep15_r1CDT :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep15_r1CDT
  = GHC.Types.: @ KindRep $krep6_r1CDK (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep16_r1CDU :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep16_r1CDU
  = GHC.Types.KindRepTyConApp GHC.Classes.$tcEq $krep15_r1CDT

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tcBits3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Bits.$tcBits3 = "Bits"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tcBits2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$tcBits2 = GHC.Types.TrNameS Data.Bits.$tcBits3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tcBits :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Bits.$tcBits
  = GHC.Types.TyCon
      7088815172979416363##
      4990916430057605838##
      Data.Bits.$trModule
      Data.Bits.$tcBits2
      0#
      Data.Bits.$tcBits1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep17_r1CDV :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep17_r1CDV
  = GHC.Types.KindRepTyConApp Data.Bits.$tcBits $krep15_r1CDT

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep18_r1CDW :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep18_r1CDW = GHC.Types.KindRepFun $krep11_r1CDP $krep17_r1CDV

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep19_r1CDX :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep19_r1CDX = GHC.Types.KindRepFun $krep14_r1CDS $krep18_r1CDW

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep20_r1CDY :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep20_r1CDY = GHC.Types.KindRepFun $krep14_r1CDS $krep19_r1CDX

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep21_r1CDZ :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep21_r1CDZ = GHC.Types.KindRepFun $krep14_r1CDS $krep20_r1CDY

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep22_r1CE0 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep22_r1CE0 = GHC.Types.KindRepFun $krep14_r1CDS $krep21_r1CDZ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep23_r1CE1 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep23_r1CE1 = GHC.Types.KindRepFun $krep14_r1CDS $krep22_r1CE0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep24_r1CE2 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep24_r1CE2 = GHC.Types.KindRepFun $krep14_r1CDS $krep23_r1CE1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep25_r1CE3 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep25_r1CE3 = GHC.Types.KindRepFun $krep12_r1CDQ $krep24_r1CE2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep26_r1CE4 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep26_r1CE4 = GHC.Types.KindRepFun $krep11_r1CDP $krep25_r1CE3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep27_r1CE5 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep27_r1CE5 = GHC.Types.KindRepFun $krep10_r1CDO $krep26_r1CE4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep28_r1CE6 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep28_r1CE6 = GHC.Types.KindRepFun $krep9_r1CDN $krep27_r1CE5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep29_r1CE7 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep29_r1CE7 = GHC.Types.KindRepFun $krep14_r1CDS $krep28_r1CE6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep30_r1CE8 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep30_r1CE8 = GHC.Types.KindRepFun $krep14_r1CDS $krep29_r1CE7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep31_r1CE9 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep31_r1CE9 = GHC.Types.KindRepFun $krep14_r1CDS $krep30_r1CE8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep32_r1CEa :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep32_r1CEa = GHC.Types.KindRepFun $krep13_r1CDR $krep31_r1CE9

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep33_r1CEb :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep33_r1CEb = GHC.Types.KindRepFun $krep6_r1CDK $krep32_r1CEa

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep34_r1CEc :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep34_r1CEc = GHC.Types.KindRepFun $krep14_r1CDS $krep33_r1CEb

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep35_r1CEd :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep35_r1CEd = GHC.Types.KindRepFun $krep14_r1CDS $krep34_r1CEc

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep36_r1CEe :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep36_r1CEe = GHC.Types.KindRepFun $krep7_r1CDL $krep35_r1CEd

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep37_r1CEf :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep37_r1CEf = GHC.Types.KindRepFun $krep8_r1CDM $krep36_r1CEe

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep38_r1CEg :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep38_r1CEg = GHC.Types.KindRepFun $krep8_r1CDM $krep37_r1CEf

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep39_r1CEh :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep39_r1CEh = GHC.Types.KindRepFun $krep8_r1CDM $krep38_r1CEg

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tc'C:Bits1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Bits.$tc'C:Bits1
  = GHC.Types.KindRepFun $krep16_r1CDU $krep39_r1CEh

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tc'C:Bits3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Bits.$tc'C:Bits3 = "'C:Bits"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tc'C:Bits2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$tc'C:Bits2 = GHC.Types.TrNameS Data.Bits.$tc'C:Bits3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tc'C:Bits :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Bits.$tc'C:Bits
  = GHC.Types.TyCon
      744071653035646959##
      2574978498160477882##
      Data.Bits.$trModule
      Data.Bits.$tc'C:Bits2
      1#
      Data.Bits.$tc'C:Bits1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tcFiniteBits2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Bits.$tcFiniteBits2 = "FiniteBits"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tcFiniteBits1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$tcFiniteBits1
  = GHC.Types.TrNameS Data.Bits.$tcFiniteBits2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tcFiniteBits :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Bits.$tcFiniteBits
  = GHC.Types.TyCon
      2363162769622202131##
      10110405838341883172##
      Data.Bits.$trModule
      Data.Bits.$tcFiniteBits1
      0#
      Data.Bits.$tcBits1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep40_r1CEi :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep40_r1CEi
  = GHC.Types.KindRepTyConApp Data.Bits.$tcFiniteBits $krep15_r1CDT

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep41_r1CEj :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep41_r1CEj = GHC.Types.KindRepFun $krep11_r1CDP $krep40_r1CEi

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep42_r1CEk :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep42_r1CEk = GHC.Types.KindRepFun $krep11_r1CDP $krep41_r1CEj

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep43_r1CEl :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep43_r1CEl = GHC.Types.KindRepFun $krep11_r1CDP $krep42_r1CEk

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tc'C:FiniteBits1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Bits.$tc'C:FiniteBits1
  = GHC.Types.KindRepFun $krep17_r1CDV $krep43_r1CEl

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tc'C:FiniteBits3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Bits.$tc'C:FiniteBits3 = "'C:FiniteBits"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tc'C:FiniteBits2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Bits.$tc'C:FiniteBits2
  = GHC.Types.TrNameS Data.Bits.$tc'C:FiniteBits3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Bits.$tc'C:FiniteBits :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Bits.$tc'C:FiniteBits
  = GHC.Types.TyCon
      7500562306525175158##
      16051895206261500648##
      Data.Bits.$trModule
      Data.Bits.$tc'C:FiniteBits2
      1#
      Data.Bits.$tc'C:FiniteBits1


