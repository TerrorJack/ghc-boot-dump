
==================== Pre unarise: ====================
2018-03-16 16:06:35.663079348 UTC

Data.Functor.Identity.$fReadIdentity4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Identity.$fReadIdentity6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity"#;

Data.Functor.Identity.$fReadIdentity5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Identity.$fReadIdentity6;

Data.Functor.Identity.$w$creadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Prim.Int#
     -> GHC.Base.String
     -> [(Data.Functor.Identity.Identity a, GHC.Base.String)]
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbJtb ww_sbJtc w1_sbJtd]
        let {
          go_sbJte [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(Data.Functor.Identity.Identity a_sbJqG, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sbJtb go_sbJte] \r [ds_sbJtf]
                  case ds_sbJtf of {
                    [] -> [] [];
                    : y_sbJth [Occ=Once!] ys_sbJti [Occ=Once*] ->
                        case y_sbJth of {
                          (,) ds1_sbJtk [Occ=Once] s_sbJtl [Occ=Once] ->
                              case
                                  GHC.Base.eqString ds1_sbJtk Data.Functor.Identity.$fReadIdentity5
                              of
                              { GHC.Types.False -> go_sbJte ys_sbJti;
                                GHC.Types.True ->
                                    let {
                                      z_sbJtn [Occ=OnceL]
                                        :: [(Data.Functor.Identity.Identity a_sbJqG,
                                             GHC.Base.String)]
                                      [LclId] =
                                          [go_sbJte ys_sbJti] \u [] go_sbJte ys_sbJti; } in
                                    let {
                                      go1_sbJto [Occ=LoopBreaker]
                                        :: [(a_sbJqG, GHC.Base.String)]
                                           -> [(Data.Functor.Identity.Identity a_sbJqG,
                                                GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [z_sbJtn go1_sbJto] \r [ds2_sbJtp]
                                              case ds2_sbJtp of {
                                                [] -> z_sbJtn;
                                                : y1_sbJtr [Occ=Once!] ys1_sbJts [Occ=Once] ->
                                                    case y1_sbJtr of {
                                                      (,) x_sbJtu [Occ=Once] t_sbJtv [Occ=Once] ->
                                                          let {
                                                            sat_sbJtx [Occ=Once]
                                                              :: [(Data.Functor.Identity.Identity
                                                                     a_sbJqG,
                                                                   GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sbJto ys1_sbJts] \u []
                                                                    go1_sbJto ys1_sbJts;
                                                          } in  : [wild4_sbJtt sat_sbJtx];
                                                    };
                                              };
                                    } in 
                                      case
                                          GHC.Read.readsPrec
                                              w_sbJtb Data.Functor.Identity.$fReadIdentity4 s_sbJtl
                                      of
                                      sat_sbJty
                                      { __DEFAULT -> go1_sbJto sat_sbJty;
                                      };
                              };
                        };
                  }; } in
        let {
          sat_sbJtD [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 (Data.Functor.Identity.Identity a_sbJqG)
          [LclId] =
              [go_sbJte] \r [r_sbJtB]
                  case
                      Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_sbJtB
                  of
                  sat_sbJtC
                  { __DEFAULT -> go_sbJte sat_sbJtC;
                  };
        } in 
          case ># [ww_sbJtc 10#] of sat_sbJtz {
            __DEFAULT ->
                case tagToEnum# [sat_sbJtz] of sat_sbJtA {
                  __DEFAULT -> GHC.Read.readParen sat_sbJtA sat_sbJtD w1_sbJtd;
                };
          };

Data.Functor.Identity.$fReadIdentity_$creadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbJtE w1_sbJtF w2_sbJtG]
        case w1_sbJtF of {
          GHC.Types.I# ww1_sbJtI [Occ=Once] ->
              Data.Functor.Identity.$w$creadsPrec w_sbJtE ww1_sbJtI w2_sbJtG;
        };

Data.Functor.Identity.$fReadIdentity3
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><L,U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [$dRead_sbJtJ n_sbJtK eta_sbJtL]
        let {
          sat_sbJtM [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 (Data.Functor.Identity.Identity a_abJ16)
          [LclId] =
              [$dRead_sbJtJ n_sbJtK] \r [eta_B1]
                  Data.Functor.Identity.$fReadIdentity_$creadsPrec
                      $dRead_sbJtJ n_sbJtK eta_B1;
        } in 
          case
              Text.ParserCombinators.ReadP.$wreadS_to_P sat_sbJtM eta_sbJtL
          of
          { Unit# ww1_sbJtO [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sbJtO];
          };

Data.Functor.Identity.$fReadIdentity2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Identity.$fReadIdentity_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Identity.Identity a]
[GblId, Arity=1, Str=<L,U(C(C1(U)),A,A,A)>, Unf=OtherCon []] =
    [] \r [$dRead_sbJtP]
        let {
          sat_sbJtR [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_XbJ2M]
          [LclId] =
              [$dRead_sbJtP] \u []
                  let {
                    sat_sbJtQ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_XbJ2M)
                    [LclId] =
                        [$dRead_sbJtP] \r [eta_B2 eta_B1]
                            Data.Functor.Identity.$fReadIdentity3 $dRead_sbJtP eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sbJtQ
                        Data.Functor.Identity.$fReadIdentity2
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sbJtR;

Data.Functor.Identity.$w$creadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall b.
     ([Data.Functor.Identity.Identity a]
      -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,U(C(C1(U)),A,A,A)>, Unf=OtherCon []] =
    [] \r [w_sbJtS]
        let {
          w1_sbJtT [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_sbJqP]
          [LclId] =
              [w_sbJtS] \u []
                  let {
                    sat_sbJtU
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sbJqP)
                    [LclId] =
                        [w_sbJtS] \r [eta_B2 eta_B1]
                            Data.Functor.Identity.$fReadIdentity3 w_sbJtS eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sbJtU
                        Data.Functor.Identity.$fReadIdentity2
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          w2_sbJtV [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Identity.Identity a_sbJqP]
          [LclId, Arity=1, Unf=OtherCon []] =
              [w1_sbJtT] \r [eta_B1]
                  Text.ParserCombinators.ReadP.run w1_sbJtT eta_B1; } in
        let {
          sat_sbJtZ [Occ=OnceT[0]]
            :: forall b.
               ([Data.Functor.Identity.Identity a_sbJqP]
                -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w2_sbJtV] \r [w3_sbJtW]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w2_sbJtV w3_sbJtW
                  of
                  { Unit# ww1_sbJtY [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sbJtY];
                  };
        } in  sat_sbJtZ;

Data.Functor.Identity.$fReadIdentity1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([Data.Functor.Identity.Identity a]
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,U(C(C1(U)),A,A,A)><L,A>, Unf=OtherCon []] =
    [] \r [w_sbJu0 w1_sbJu1]
        Data.Functor.Identity.$w$creadListPrec w_sbJu0;

Data.Functor.Identity.$fReadIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,A,A)>m] =
    [] \r [$dRead_sbJu2]
        let {
          lvl1_sbJu3 [Occ=OnceL]
            :: forall b.
               ([Data.Functor.Identity.Identity a_XbJ2R]
                -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sbJu2] \u []
                  Data.Functor.Identity.$w$creadListPrec $dRead_sbJu2; } in
        let {
          sat_sbJu8 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Identity.Identity a_XbJ2R]
          [LclId] =
              [lvl1_sbJu3] \r [w_sbJu7] lvl1_sbJu3; } in
        let {
          sat_sbJu6 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_XbJ2R)
          [LclId] =
              [$dRead_sbJu2] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fReadIdentity3
                      $dRead_sbJu2 eta_B2 eta_B1; } in
        let {
          sat_sbJu5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Identity.Identity a_XbJ2R]
          [LclId] =
              [$dRead_sbJu2] \u []
                  Data.Functor.Identity.$fReadIdentity_$creadList $dRead_sbJu2; } in
        let {
          sat_sbJu4 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Identity.Identity a_XbJ2R)
          [LclId] =
              [$dRead_sbJu2] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fReadIdentity_$creadsPrec
                      $dRead_sbJu2 eta_B2 eta_B1;
        } in  GHC.Read.C:Read [sat_sbJu4 sat_sbJu5 sat_sbJu6 sat_sbJu8];

Data.Functor.Identity.$fShowIdentity2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity "#;

Data.Functor.Identity.$fShowIdentity1 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Identity.$fShowIdentity2;

Data.Functor.Identity.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Functor.Identity.Identity a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbJu9 ww_sbJua w1_sbJub]
        let {
          g_sbJuc [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sbJu9 w1_sbJub] \u []
                  GHC.Show.showsPrec
                      w_sbJu9 Data.Functor.Identity.$fReadIdentity4 w1_sbJub;
        } in 
          case ># [ww_sbJua 10#] of {
            __DEFAULT ->
                let {
                  sat_sbJug [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [g_sbJuc] \r [x_sbJue]
                          let {
                            sat_sbJuf [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sbJuc x_sbJue] \s [] g_sbJuc x_sbJue;
                          } in  GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbJuf;
                } in  sat_sbJug;
            1# ->
                let {
                  sat_sbJul [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [g_sbJuc] \r [x_sbJuh]
                          let {
                            sat_sbJuk [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sbJuc x_sbJuh] \u []
                                    let {
                                      sat_sbJuj [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sbJuc x_sbJuh] \s []
                                              let {
                                                sat_sbJui [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sbJuh];
                                              } in  g_sbJuc sat_sbJui;
                                    } in 
                                      GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbJuj;
                          } in  : [GHC.Show.$fShow(,)4 sat_sbJuk];
                } in  sat_sbJul;
          };

Data.Functor.Identity.$fShowIdentity_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Functor.Identity.Identity a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbJum w1_sbJun w2_sbJuo]
        case w1_sbJun of {
          GHC.Types.I# ww1_sbJuq [Occ=Once] ->
              Data.Functor.Identity.$w$cshowsPrec w_sbJum ww1_sbJuq w2_sbJuo;
        };

Data.Functor.Identity.$fShowIdentity_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Identity.Identity a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbJur x_sbJus]
        let {
          sat_sbJut [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sbJur x_sbJus] \s []
                  GHC.Show.showsPrec
                      $dShow_sbJur
                      Data.Functor.Identity.$fReadIdentity4
                      x_sbJus
                      GHC.Types.[];
        } in  GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbJut;

Data.Functor.Identity.$fShowIdentity_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Functor.Identity.Identity a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbJuu ls_sbJuv s_sbJuw]
        let {
          sat_sbJuy [Occ=Once]
            :: Data.Functor.Identity.Identity a_abJ0D -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbJuu] \r [w_sbJux]
                  Data.Functor.Identity.$w$cshowsPrec $dShow_sbJuu 0# w_sbJux;
        } in  GHC.Show.showList__ sat_sbJuy ls_sbJuv s_sbJuw;

Data.Functor.Identity.$fShowIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sbJuz]
        let {
          sat_sbJuC [Occ=Once]
            :: [Data.Functor.Identity.Identity a_abJ0D] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbJuz] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshowList
                      $dShow_sbJuz eta_B2 eta_B1; } in
        let {
          sat_sbJuB [Occ=Once]
            :: Data.Functor.Identity.Identity a_abJ0D -> GHC.Base.String
          [LclId] =
              [$dShow_sbJuz] \r [eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshow
                      $dShow_sbJuz eta_B1; } in
        let {
          sat_sbJuA [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abJ0D -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbJuz] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshowsPrec
                      $dShow_sbJuz eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sbJuA sat_sbJuB sat_sbJuC];

Data.Functor.Identity.$fFoldableIdentity4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Functor.Identity.$fFoldableIdentity_$clength
  :: forall a. Data.Functor.Identity.Identity a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sbJuD] Data.Functor.Identity.$fFoldableIdentity4;

Data.Functor.Identity.$fFoldableIdentity_$cnull
  :: forall a. Data.Functor.Identity.Identity a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbJuE] GHC.Types.False [];

Data.Functor.Identity.$fFoldableIdentity_$ctoList
  :: forall a. Data.Functor.Identity.Identity a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_sbJuF] : [ds_sbJuF GHC.Types.[]];

Data.Functor.Identity.$fFoldableIdentity6
  :: forall b a. (b -> a -> b) -> b -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbJuG] v_sbJuG;

Data.Functor.Identity.$fFoldableIdentity_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Functor.Identity.Identity a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sbJuH z_sbJuI ds_sbJuJ] f_sbJuH ds_sbJuJ z_sbJuI;

Data.Functor.Identity.$fFoldableIdentity7
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> a -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sbJuK v_sbJuL] v_sbJuL;

Data.Functor.Identity.$fFunctorIdentity2
  :: forall a b. (a -> b) -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbJuM] v_sbJuM;

Data.Functor.Identity.$fFunctorIdentity1 :: forall b a. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sbJuN ds_sbJuO] x_sbJuN;

Data.Functor.Identity.$fFunctorIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Identity.$fFunctorIdentity2
                                       Data.Functor.Identity.$fFunctorIdentity1];

Data.Functor.Identity.$fApplicativeIdentity1
  :: forall a b c. (a -> b -> c) -> a -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbJuP] v_sbJuP;

Data.Functor.Identity.$fApplicativeIdentity2
  :: forall a b.
     Data.Functor.Identity.Identity (a -> b)
     -> Data.Functor.Identity.Identity (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbJuQ] v_sbJuQ;

Data.Functor.Identity.$fApplicativeIdentity3 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbJuR] v_sbJuR;

Data.Functor.Identity.$fApplicativeIdentity_$c*>
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sbJuS a2_sbJuT] a2_sbJuT;

Data.Functor.Identity.$fApplicativeIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Identity.$fFunctorIdentity
                                           Data.Functor.Identity.$fApplicativeIdentity3
                                           Data.Functor.Identity.$fApplicativeIdentity2
                                           Data.Functor.Identity.$fApplicativeIdentity1
                                           Data.Functor.Identity.$fApplicativeIdentity_$c*>
                                           GHC.Base.const];

Data.Functor.Identity.$fStorableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Foreign.Storable.Storable a =>
     Foreign.Storable.Storable (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dStorable_sbJuU]
        let {
          sat_sbJv2 [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> Data.Functor.Identity.Identity a_abITC -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.poke $dStorable_sbJuU; } in
        let {
          sat_sbJv1 [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.peek $dStorable_sbJuU; } in
        let {
          sat_sbJv0 [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abITC
               -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.pokeByteOff $dStorable_sbJuU; } in
        let {
          sat_sbJuZ [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.peekByteOff $dStorable_sbJuU; } in
        let {
          sat_sbJuY [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abITC
               -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.pokeElemOff $dStorable_sbJuU; } in
        let {
          sat_sbJuX [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.Int
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.peekElemOff $dStorable_sbJuU; } in
        let {
          sat_sbJuW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abITC -> GHC.Types.Int
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.alignment $dStorable_sbJuU; } in
        let {
          sat_sbJuV [Occ=Once]
            :: Data.Functor.Identity.Identity a_abITC -> GHC.Types.Int
          [LclId] =
              [$dStorable_sbJuU] \u [] Foreign.Storable.sizeOf $dStorable_sbJuU;
        } in 
          Foreign.Storable.C:Storable [sat_sbJuV
                                       sat_sbJuW
                                       sat_sbJuX
                                       sat_sbJuY
                                       sat_sbJuZ
                                       sat_sbJv0
                                       sat_sbJv1
                                       sat_sbJv2];

Data.Functor.Identity.$fNumIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_sbJv3]
        let {
          sat_sbJva [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.fromInteger $dNum_sbJv3; } in
        let {
          sat_sbJv9 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.signum $dNum_sbJv3; } in
        let {
          sat_sbJv8 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.abs $dNum_sbJv3; } in
        let {
          sat_sbJv7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.negate $dNum_sbJv3; } in
        let {
          sat_sbJv6 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.* $dNum_sbJv3; } in
        let {
          sat_sbJv5 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.- $dNum_sbJv3; } in
        let {
          sat_sbJv4 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.+ $dNum_sbJv3;
        } in 
          GHC.Num.C:Num [sat_sbJv4
                         sat_sbJv5
                         sat_sbJv6
                         sat_sbJv7
                         sat_sbJv8
                         sat_sbJv9
                         sat_sbJva];

Data.Functor.Identity.$fRealIdentity_$cp1Real
  :: forall a.
     GHC.Real.Real a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dReal_sbJvb]
        let {
          sat_sbJvc [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Num.Num a_abIOf
          [LclId] =
              [$dReal_sbJvb] \u [] GHC.Real.$p1Real $dReal_sbJvb;
        } in  Data.Functor.Identity.$fNumIdentity sat_sbJvc;

Data.Functor.Identity.$fSemigroupIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U,1*U)>m] =
    [] \r [$dSemigroup_sbJvd]
        let {
          sat_sbJvg [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbJvd] \u [] GHC.Base.stimes $dSemigroup_sbJvd; } in
        let {
          sat_sbJvf [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Identity.Identity a_abIJk)
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbJvd] \u [] GHC.Base.sconcat $dSemigroup_sbJvd; } in
        let {
          sat_sbJve [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbJvd] \u [] GHC.Base.<> $dSemigroup_sbJvd;
        } in  GHC.Base.C:Semigroup [sat_sbJve sat_sbJvf sat_sbJvg];

Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sbJvh]
        let {
          sat_sbJvi [Occ=Once, Dmd=<L,U(1*U,1*U,1*U)>]
            :: GHC.Base.Semigroup a_abIKg
          [LclId] =
              [$dMonoid_sbJvh] \u [] GHC.Base.$p1Monoid $dMonoid_sbJvh;
        } in  Data.Functor.Identity.$fSemigroupIdentity sat_sbJvi;

Data.Functor.Identity.$fMonoidIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dMonoid_sbJvj]
        let {
          sat_sbJvn [Occ=Once]
            :: [Data.Functor.Identity.Identity a_abIKg]
               -> Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbJvj] \u [] GHC.Base.mconcat $dMonoid_sbJvj; } in
        let {
          sat_sbJvm [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKg
               -> Data.Functor.Identity.Identity a_abIKg
               -> Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbJvj] \u [] GHC.Base.mappend $dMonoid_sbJvj; } in
        let {
          sat_sbJvl [Occ=Once] :: Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbJvj] \u [] GHC.Base.mempty $dMonoid_sbJvj; } in
        let {
          sat_sbJvk [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Identity.Identity a_abIKg)
          [LclId] =
              [$dMonoid_sbJvj] \u []
                  Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid $dMonoid_sbJvj;
        } in  GHC.Base.C:Monoid [sat_sbJvk sat_sbJvl sat_sbJvm sat_sbJvn];

Data.Functor.Identity.$fGeneric1Identity1
  :: forall a.
     GHC.Generics.Rep1 Data.Functor.Identity.Identity a
     -> GHC.Generics.Rep1 Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbJvo] ds_sbJvo;

Data.Functor.Identity.$fFoldableIdentity2
  :: forall a.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbJvp] x_sbJvp;

Data.Functor.Identity.$fGeneric1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Identity.$fFoldableIdentity2
                                            Data.Functor.Identity.$fGeneric1Identity1];

Data.Functor.Identity.$fGenericIdentity1
  :: forall a x.
     GHC.Generics.Rep (Data.Functor.Identity.Identity a) x
     -> GHC.Generics.Rep (Data.Functor.Identity.Identity a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbJvq] ds_sbJvq;

Data.Functor.Identity.$fGenericIdentity2
  :: forall a x.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbJvr] x1_sbJvr;

Data.Functor.Identity.$fGenericIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Generics.Generic (Data.Functor.Identity.Identity a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Identity.$fGenericIdentity2
                                           Data.Functor.Identity.$fGenericIdentity1];

Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
  :: forall a.
     GHC.Real.Fractional a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFractional_sbJvs]
        let {
          sat_sbJvt [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Num.Num a_abIDx
          [LclId] =
              [$dFractional_sbJvs] \u []
                  GHC.Real.$p1Fractional $dFractional_sbJvs;
        } in  Data.Functor.Identity.$fNumIdentity sat_sbJvt;

Data.Functor.Identity.$fFractionalIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Fractional a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dFractional_sbJvu]
        let {
          sat_sbJvy [Occ=Once]
            :: GHC.Real.Rational -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbJvu] \u []
                  GHC.Real.fromRational $dFractional_sbJvu; } in
        let {
          sat_sbJvx [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbJvu] \u [] GHC.Real.recip $dFractional_sbJvu; } in
        let {
          sat_sbJvw [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbJvu] \u [] GHC.Real./ $dFractional_sbJvu; } in
        let {
          sat_sbJvv [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Identity.Identity a_abIDx)
          [LclId] =
              [$dFractional_sbJvu] \u []
                  Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
                      $dFractional_sbJvu;
        } in 
          GHC.Real.C:Fractional [sat_sbJvv sat_sbJvw sat_sbJvx sat_sbJvy];

Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_sbJvz]
        let {
          sat_sbJvA [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>]
            :: GHC.Real.Fractional a_abIOC
          [LclId] =
              [$dRealFrac_sbJvz] \u [] GHC.Real.$p2RealFrac $dRealFrac_sbJvz;
        } in  Data.Functor.Identity.$fFractionalIdentity sat_sbJvA;

Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
  :: forall a.
     GHC.Float.Floating a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sbJvB]
        let {
          sat_sbJvC [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>]
            :: GHC.Real.Fractional a_abIzr
          [LclId] =
              [$dFloating_sbJvB] \u [] GHC.Float.$p1Floating $dFloating_sbJvB;
        } in  Data.Functor.Identity.$fFractionalIdentity sat_sbJvC;

Data.Functor.Identity.$fFloatingIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.Floating a =>
     GHC.Float.Floating (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dFloating_sbJvD]
        let {
          sat_sbJw0 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.log1mexp $dFloating_sbJvD; } in
        let {
          sat_sbJvZ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.log1pexp $dFloating_sbJvD; } in
        let {
          sat_sbJvY [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.expm1 $dFloating_sbJvD; } in
        let {
          sat_sbJvX [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.log1p $dFloating_sbJvD; } in
        let {
          sat_sbJvW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.atanh $dFloating_sbJvD; } in
        let {
          sat_sbJvV [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.acosh $dFloating_sbJvD; } in
        let {
          sat_sbJvU [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.asinh $dFloating_sbJvD; } in
        let {
          sat_sbJvT [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.tanh $dFloating_sbJvD; } in
        let {
          sat_sbJvS [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.cosh $dFloating_sbJvD; } in
        let {
          sat_sbJvR [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.sinh $dFloating_sbJvD; } in
        let {
          sat_sbJvQ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.atan $dFloating_sbJvD; } in
        let {
          sat_sbJvP [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.acos $dFloating_sbJvD; } in
        let {
          sat_sbJvO [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.asin $dFloating_sbJvD; } in
        let {
          sat_sbJvN [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.tan $dFloating_sbJvD; } in
        let {
          sat_sbJvM [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.cos $dFloating_sbJvD; } in
        let {
          sat_sbJvL [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.sin $dFloating_sbJvD; } in
        let {
          sat_sbJvK [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.logBase $dFloating_sbJvD; } in
        let {
          sat_sbJvJ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.** $dFloating_sbJvD; } in
        let {
          sat_sbJvI [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.sqrt $dFloating_sbJvD; } in
        let {
          sat_sbJvH [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.log $dFloating_sbJvD; } in
        let {
          sat_sbJvG [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.exp $dFloating_sbJvD; } in
        let {
          sat_sbJvF [Occ=Once] :: Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.pi $dFloating_sbJvD; } in
        let {
          sat_sbJvE [Occ=Once]
            :: GHC.Real.Fractional (Data.Functor.Identity.Identity a_abIzr)
          [LclId] =
              [$dFloating_sbJvD] \u []
                  Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
                      $dFloating_sbJvD;
        } in 
          GHC.Float.C:Floating [sat_sbJvE
                                sat_sbJvF
                                sat_sbJvG
                                sat_sbJvH
                                sat_sbJvI
                                sat_sbJvJ
                                sat_sbJvK
                                sat_sbJvL
                                sat_sbJvM
                                sat_sbJvN
                                sat_sbJvO
                                sat_sbJvP
                                sat_sbJvQ
                                sat_sbJvR
                                sat_sbJvS
                                sat_sbJvT
                                sat_sbJvU
                                sat_sbJvV
                                sat_sbJvW
                                sat_sbJvX
                                sat_sbJvY
                                sat_sbJvZ
                                sat_sbJw0];

Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.Floating (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sbJw1]
        let {
          sat_sbJw2 [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Float.Floating a_abIQK
          [LclId] =
              [$dRealFloat_sbJw1] \u [] GHC.Float.$p2RealFloat $dRealFloat_sbJw1;
        } in  Data.Functor.Identity.$fFloatingIdentity sat_sbJw2;

Data.Functor.Identity.$fEqIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sbJw3]
        let {
          sat_sbJw5 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIye
               -> Data.Functor.Identity.Identity a_abIye -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbJw3] \u [] GHC.Classes./= $dEq_sbJw3; } in
        let {
          sat_sbJw4 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIye
               -> Data.Functor.Identity.Identity a_abIye -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbJw3] \u [] GHC.Classes.== $dEq_sbJw3;
        } in  GHC.Classes.C:Eq [sat_sbJw4 sat_sbJw5];

Data.Functor.Identity.$fOrdIdentity_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sbJw6]
        let {
          sat_sbJw7 [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_abIMq
          [LclId] =
              [$dOrd_sbJw6] \u [] GHC.Classes.$p1Ord $dOrd_sbJw6;
        } in  Data.Functor.Identity.$fEqIdentity sat_sbJw7;

Data.Functor.Identity.$fOrdIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sbJw8]
        let {
          sat_sbJwg [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.min $dOrd_sbJw8; } in
        let {
          sat_sbJwf [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.max $dOrd_sbJw8; } in
        let {
          sat_sbJwe [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.>= $dOrd_sbJw8; } in
        let {
          sat_sbJwd [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.> $dOrd_sbJw8; } in
        let {
          sat_sbJwc [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.<= $dOrd_sbJw8; } in
        let {
          sat_sbJwb [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.< $dOrd_sbJw8; } in
        let {
          sat_sbJwa [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.compare $dOrd_sbJw8; } in
        let {
          sat_sbJw9 [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Identity.Identity a_abIMq)
          [LclId] =
              [$dOrd_sbJw8] \u []
                  Data.Functor.Identity.$fOrdIdentity_$cp1Ord $dOrd_sbJw8;
        } in 
          GHC.Classes.C:Ord [sat_sbJw9
                             sat_sbJwa
                             sat_sbJwb
                             sat_sbJwc
                             sat_sbJwd
                             sat_sbJwe
                             sat_sbJwf
                             sat_sbJwg];

Data.Functor.Identity.$fIxIdentity_$cp1Ix
  :: forall a.
     GHC.Arr.Ix a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIx_sbJwh]
        let {
          sat_sbJwi [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Classes.Ord a_abIHW
          [LclId] =
              [$dIx_sbJwh] \u [] GHC.Arr.$p1Ix $dIx_sbJwh;
        } in  Data.Functor.Identity.$fOrdIdentity sat_sbJwi;

Data.Functor.Identity.$fIxIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Arr.Ix a =>
     GHC.Arr.Ix (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dIx_sbJwj]
        let {
          sat_sbJwq [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> GHC.Types.Int
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.unsafeRangeSize $dIx_sbJwj; } in
        let {
          sat_sbJwp [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> GHC.Types.Int
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.rangeSize $dIx_sbJwj; } in
        let {
          sat_sbJwo [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Bool
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.inRange $dIx_sbJwj; } in
        let {
          sat_sbJwn [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Int
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.unsafeIndex $dIx_sbJwj; } in
        let {
          sat_sbJwm [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Int
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.index $dIx_sbJwj; } in
        let {
          sat_sbJwl [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> [Data.Functor.Identity.Identity a_abIHW]
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.range $dIx_sbJwj; } in
        let {
          sat_sbJwk [Occ=Once]
            :: GHC.Classes.Ord (Data.Functor.Identity.Identity a_abIHW)
          [LclId] =
              [$dIx_sbJwj] \u []
                  Data.Functor.Identity.$fIxIdentity_$cp1Ix $dIx_sbJwj;
        } in 
          GHC.Arr.C:Ix [sat_sbJwk
                        sat_sbJwl
                        sat_sbJwm
                        sat_sbJwn
                        sat_sbJwo
                        sat_sbJwp
                        sat_sbJwq];

Data.Functor.Identity.$fRealIdentity_$cp2Real
  :: forall a.
     GHC.Real.Real a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),A)>m,
 Unf=OtherCon []] =
    [] \r [$dReal_sbJwr]
        let {
          sat_sbJws [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Classes.Ord a_abIOf
          [LclId] =
              [$dReal_sbJwr] \u [] GHC.Real.$p2Real $dReal_sbJwr;
        } in  Data.Functor.Identity.$fOrdIdentity sat_sbJws;

Data.Functor.Identity.$fRealIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Real a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>m] =
    [] \r [$dReal_sbJwt]
        let {
          sat_sbJww [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIOf -> GHC.Real.Rational
          [LclId] =
              [$dReal_sbJwt] \u [] GHC.Real.toRational $dReal_sbJwt; } in
        let {
          sat_sbJwv [Occ=Once]
            :: GHC.Classes.Ord (Data.Functor.Identity.Identity a_abIOf)
          [LclId] =
              [$dReal_sbJwt] \u []
                  Data.Functor.Identity.$fRealIdentity_$cp2Real $dReal_sbJwt; } in
        let {
          sat_sbJwu [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Identity.Identity a_abIOf)
          [LclId] =
              [$dReal_sbJwt] \u []
                  Data.Functor.Identity.$fRealIdentity_$cp1Real $dReal_sbJwt;
        } in  GHC.Real.C:Real [sat_sbJwu sat_sbJwv sat_sbJww];

Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sbJwx]
        let {
          sat_sbJwy [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>]
            :: GHC.Real.Real a_abIG7
          [LclId] =
              [$dIntegral_sbJwx] \u [] GHC.Real.$p1Integral $dIntegral_sbJwx;
        } in  Data.Functor.Identity.$fRealIdentity sat_sbJwy;

Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_sbJwz]
        let {
          sat_sbJwA [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>]
            :: GHC.Real.Real a_abIOC
          [LclId] =
              [$dRealFrac_sbJwz] \u [] GHC.Real.$p1RealFrac $dRealFrac_sbJwz;
        } in  Data.Functor.Identity.$fRealIdentity sat_sbJwA;

Data.Functor.Identity.$fRealFracIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dRealFrac_sbJwB]
        let {
          sat_sbJwI [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbJwB] \u [] GHC.Real.floor $dRealFrac_sbJwB; } in
        let {
          sat_sbJwH [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbJwB] \u [] GHC.Real.ceiling $dRealFrac_sbJwB; } in
        let {
          sat_sbJwG [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbJwB] \u [] GHC.Real.round $dRealFrac_sbJwB; } in
        let {
          sat_sbJwF [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbJwB] \u [] GHC.Real.truncate $dRealFrac_sbJwB; } in
        let {
          sat_sbJwE [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC
               -> (b, Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbJwB] \u []
                  GHC.Real.properFraction $dRealFrac_sbJwB; } in
        let {
          sat_sbJwD [Occ=Once]
            :: GHC.Real.Fractional (Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbJwB] \u []
                  Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
                      $dRealFrac_sbJwB; } in
        let {
          sat_sbJwC [Occ=Once]
            :: GHC.Real.Real (Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbJwB] \u []
                  Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
                      $dRealFrac_sbJwB;
        } in 
          GHC.Real.C:RealFrac [sat_sbJwC
                               sat_sbJwD
                               sat_sbJwE
                               sat_sbJwF
                               sat_sbJwG
                               sat_sbJwH
                               sat_sbJwI];

Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sbJwJ]
        let {
          sat_sbJwK [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Real.RealFrac a_abIQK
          [LclId] =
              [$dRealFloat_sbJwJ] \u [] GHC.Float.$p1RealFloat $dRealFloat_sbJwJ;
        } in  Data.Functor.Identity.$fRealFracIdentity sat_sbJwK;

Data.Functor.Identity.$fRealFloatIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.RealFloat (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dRealFloat_sbJwL]
        let {
          sat_sbJx1 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbJwL] \u [] GHC.Float.atan2 $dRealFloat_sbJwL; } in
        let {
          sat_sbJx0 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbJwL] \u [] GHC.Float.isIEEE $dRealFloat_sbJwL; } in
        let {
          sat_sbJwZ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.isNegativeZero $dRealFloat_sbJwL; } in
        let {
          sat_sbJwY [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.isDenormalized $dRealFloat_sbJwL; } in
        let {
          sat_sbJwX [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.isInfinite $dRealFloat_sbJwL; } in
        let {
          sat_sbJwW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbJwL] \u [] GHC.Float.isNaN $dRealFloat_sbJwL; } in
        let {
          sat_sbJwV [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.scaleFloat $dRealFloat_sbJwL; } in
        let {
          sat_sbJwU [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.significand $dRealFloat_sbJwL; } in
        let {
          sat_sbJwT [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Int
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.exponent $dRealFloat_sbJwL; } in
        let {
          sat_sbJwS [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.encodeFloat $dRealFloat_sbJwL; } in
        let {
          sat_sbJwR [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> (GHC.Integer.Type.Integer, GHC.Types.Int)
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.decodeFloat $dRealFloat_sbJwL; } in
        let {
          sat_sbJwQ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> (GHC.Types.Int, GHC.Types.Int)
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.floatRange $dRealFloat_sbJwL; } in
        let {
          sat_sbJwP [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Int
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.floatDigits $dRealFloat_sbJwL; } in
        let {
          sat_sbJwO [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> GHC.Integer.Type.Integer
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.floatRadix $dRealFloat_sbJwL; } in
        let {
          sat_sbJwN [Occ=Once]
            :: GHC.Float.Floating (Data.Functor.Identity.Identity a_abIQK)
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
                      $dRealFloat_sbJwL; } in
        let {
          sat_sbJwM [Occ=Once]
            :: GHC.Real.RealFrac (Data.Functor.Identity.Identity a_abIQK)
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
                      $dRealFloat_sbJwL;
        } in 
          GHC.Float.C:RealFloat [sat_sbJwM
                                 sat_sbJwN
                                 sat_sbJwO
                                 sat_sbJwP
                                 sat_sbJwQ
                                 sat_sbJwR
                                 sat_sbJwS
                                 sat_sbJwT
                                 sat_sbJwU
                                 sat_sbJwV
                                 sat_sbJwW
                                 sat_sbJwX
                                 sat_sbJwY
                                 sat_sbJwZ
                                 sat_sbJx0
                                 sat_sbJx1];

Data.Functor.Identity.$fEnumIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dEnum_sbJx2]
        let {
          sat_sbJxa [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.enumFromThenTo $dEnum_sbJx2; } in
        let {
          sat_sbJx9 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.enumFromTo $dEnum_sbJx2; } in
        let {
          sat_sbJx8 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.enumFromThen $dEnum_sbJx2; } in
        let {
          sat_sbJx7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.enumFrom $dEnum_sbJx2; } in
        let {
          sat_sbJx6 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu -> GHC.Types.Int
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.fromEnum $dEnum_sbJx2; } in
        let {
          sat_sbJx5 [Occ=Once]
            :: GHC.Types.Int -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.toEnum $dEnum_sbJx2; } in
        let {
          sat_sbJx4 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.pred $dEnum_sbJx2; } in
        let {
          sat_sbJx3 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.succ $dEnum_sbJx2;
        } in 
          GHC.Enum.C:Enum [sat_sbJx3
                           sat_sbJx4
                           sat_sbJx5
                           sat_sbJx6
                           sat_sbJx7
                           sat_sbJx8
                           sat_sbJx9
                           sat_sbJxa];

Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Enum.Enum (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sbJxb]
        let {
          sat_sbJxc [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Enum.Enum a_abIG7
          [LclId] =
              [$dIntegral_sbJxb] \u [] GHC.Real.$p2Integral $dIntegral_sbJxb;
        } in  Data.Functor.Identity.$fEnumIdentity sat_sbJxc;

Data.Functor.Identity.$fIntegralIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Integral (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dIntegral_sbJxd]
        let {
          sat_sbJxm [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> GHC.Integer.Type.Integer
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.toInteger $dIntegral_sbJxd; } in
        let {
          sat_sbJxl [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> (Data.Functor.Identity.Identity a_abIG7,
                   Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.divMod $dIntegral_sbJxd; } in
        let {
          sat_sbJxk [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> (Data.Functor.Identity.Identity a_abIG7,
                   Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.quotRem $dIntegral_sbJxd; } in
        let {
          sat_sbJxj [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.mod $dIntegral_sbJxd; } in
        let {
          sat_sbJxi [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.div $dIntegral_sbJxd; } in
        let {
          sat_sbJxh [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.rem $dIntegral_sbJxd; } in
        let {
          sat_sbJxg [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.quot $dIntegral_sbJxd; } in
        let {
          sat_sbJxf [Occ=Once]
            :: GHC.Enum.Enum (Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbJxd] \u []
                  Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
                      $dIntegral_sbJxd; } in
        let {
          sat_sbJxe [Occ=Once]
            :: GHC.Real.Real (Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbJxd] \u []
                  Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
                      $dIntegral_sbJxd;
        } in 
          GHC.Real.C:Integral [sat_sbJxe
                               sat_sbJxf
                               sat_sbJxg
                               sat_sbJxh
                               sat_sbJxi
                               sat_sbJxj
                               sat_sbJxk
                               sat_sbJxl
                               sat_sbJxm];

Data.Functor.Identity.$fBoundedIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sbJxn]
        let {
          sat_sbJxp [Occ=Once] :: Data.Functor.Identity.Identity a_abIwc
          [LclId] =
              [$dBounded_sbJxn] \u [] GHC.Enum.maxBound $dBounded_sbJxn; } in
        let {
          sat_sbJxo [Occ=Once] :: Data.Functor.Identity.Identity a_abIwc
          [LclId] =
              [$dBounded_sbJxn] \u [] GHC.Enum.minBound $dBounded_sbJxn;
        } in  GHC.Enum.C:Bounded [sat_sbJxo sat_sbJxp];

Data.Functor.Identity.$fBitsIdentity_$cp1Bits
  :: forall a.
     Data.Bits.Bits a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dBits_sbJxq]
        let {
          sat_sbJxr [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_abIrg
          [LclId] =
              [$dBits_sbJxq] \u [] Data.Bits.$p1Bits $dBits_sbJxq;
        } in  Data.Functor.Identity.$fEqIdentity sat_sbJxr;

Data.Functor.Identity.$fBitsIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Bits.Bits a =>
     Data.Bits.Bits (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dBits_sbJxs]
        let {
          sat_sbJxP [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Int
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.popCount $dBits_sbJxs; } in
        let {
          sat_sbJxO [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.rotateR $dBits_sbJxs; } in
        let {
          sat_sbJxN [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.rotateL $dBits_sbJxs; } in
        let {
          sat_sbJxM [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.unsafeShiftR $dBits_sbJxs; } in
        let {
          sat_sbJxL [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.shiftR $dBits_sbJxs; } in
        let {
          sat_sbJxK [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.unsafeShiftL $dBits_sbJxs; } in
        let {
          sat_sbJxJ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.shiftL $dBits_sbJxs; } in
        let {
          sat_sbJxI [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Bool
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.isSigned $dBits_sbJxs; } in
        let {
          sat_sbJxH [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Int
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.bitSize $dBits_sbJxs; } in
        let {
          sat_sbJxG [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Base.Maybe GHC.Types.Int
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.bitSizeMaybe $dBits_sbJxs; } in
        let {
          sat_sbJxF [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> GHC.Types.Bool
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.testBit $dBits_sbJxs; } in
        let {
          sat_sbJxE [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.complementBit $dBits_sbJxs; } in
        let {
          sat_sbJxD [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.clearBit $dBits_sbJxs; } in
        let {
          sat_sbJxC [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.setBit $dBits_sbJxs; } in
        let {
          sat_sbJxB [Occ=Once]
            :: GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.bit $dBits_sbJxs; } in
        let {
          sat_sbJxA [Occ=Once] :: Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.zeroBits $dBits_sbJxs; } in
        let {
          sat_sbJxz [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.rotate $dBits_sbJxs; } in
        let {
          sat_sbJxy [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.shift $dBits_sbJxs; } in
        let {
          sat_sbJxx [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.complement $dBits_sbJxs; } in
        let {
          sat_sbJxw [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.xor $dBits_sbJxs; } in
        let {
          sat_sbJxv [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits..|. $dBits_sbJxs; } in
        let {
          sat_sbJxu [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits..&. $dBits_sbJxs; } in
        let {
          sat_sbJxt [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Identity.Identity a_abIrg)
          [LclId] =
              [$dBits_sbJxs] \u []
                  Data.Functor.Identity.$fBitsIdentity_$cp1Bits $dBits_sbJxs;
        } in 
          Data.Bits.C:Bits [sat_sbJxt
                            sat_sbJxu
                            sat_sbJxv
                            sat_sbJxw
                            sat_sbJxx
                            sat_sbJxy
                            sat_sbJxz
                            sat_sbJxA
                            sat_sbJxB
                            sat_sbJxC
                            sat_sbJxD
                            sat_sbJxE
                            sat_sbJxF
                            sat_sbJxG
                            sat_sbJxH
                            sat_sbJxI
                            sat_sbJxJ
                            sat_sbJxK
                            sat_sbJxL
                            sat_sbJxM
                            sat_sbJxN
                            sat_sbJxO
                            sat_sbJxP];

Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
  :: forall a.
     Data.Bits.FiniteBits a =>
     Data.Bits.Bits (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_sbJxQ]
        let {
          sat_sbJxR [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: Data.Bits.Bits a_abIyM
          [LclId] =
              [$dFiniteBits_sbJxQ] \u []
                  Data.Bits.$p1FiniteBits $dFiniteBits_sbJxQ;
        } in  Data.Functor.Identity.$fBitsIdentity sat_sbJxR;

Data.Functor.Identity.$fFiniteBitsIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Bits.FiniteBits a =>
     Data.Bits.FiniteBits (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dFiniteBits_sbJxS]
        let {
          sat_sbJxW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbJxS] \u []
                  Data.Bits.countTrailingZeros $dFiniteBits_sbJxS; } in
        let {
          sat_sbJxV [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbJxS] \u []
                  Data.Bits.countLeadingZeros $dFiniteBits_sbJxS; } in
        let {
          sat_sbJxU [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbJxS] \u []
                  Data.Bits.finiteBitSize $dFiniteBits_sbJxS; } in
        let {
          sat_sbJxT [Occ=Once]
            :: Data.Bits.Bits (Data.Functor.Identity.Identity a_abIyM)
          [LclId] =
              [$dFiniteBits_sbJxS] \u []
                  Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
                      $dFiniteBits_sbJxS;
        } in 
          Data.Bits.C:FiniteBits [sat_sbJxT sat_sbJxU sat_sbJxV sat_sbJxW];

Data.Functor.Identity.runIdentity
  :: forall a. Data.Functor.Identity.Identity a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fMonadFixIdentity_$cmfix
  :: forall a.
     (a -> Data.Functor.Identity.Identity a)
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sbJxX]
        let {
          x_sbJxY [Occ=LoopBreaker] :: Data.Functor.Identity.Identity a_abIVT
          [LclId] =
              [f_sbJxX x_sbJxY] \u [] f_sbJxX x_sbJxY;
        } in  x_sbJxY;

Data.Functor.Identity.$fMonadIdentity_$c>>=
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> (a -> Data.Functor.Identity.Identity b)
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_sbJxZ k_sbJy0] k_sbJy0 m_sbJxZ;

Data.Functor.Identity.$fMonadIdentity_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Functor.Identity.$fApplicativeIdentity_$c*> eta_B2 eta_B1;

lvl_rbJt6
  :: forall a. [GHC.Types.Char] -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sbJy1] GHC.Err.errorWithoutStackTrace eta_sbJy1;

Data.Functor.Identity.$fMonadIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Functor.Identity.$fApplicativeIdentity
                                     Data.Functor.Identity.$fMonadIdentity_$c>>=
                                     Data.Functor.Identity.$fMonadIdentity_$c>>
                                     Data.Functor.Identity.$fApplicativeIdentity3
                                     lvl_rbJt6];

Data.Functor.Identity.$fMonadFixIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Functor.Identity.$fMonadIdentity
                                                 Data.Functor.Identity.$fMonadFixIdentity_$cmfix];

Data.Functor.Identity.$fFoldableIdentity5
  :: forall a.
     (a -> a -> a)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbJy2 eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity3
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sbJy3 eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity1
  :: forall a.
     GHC.Num.Num a =>
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_sbJy4 eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity8
  :: forall m. GHC.Base.Monoid m => m -> m
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dMonoid_sbJy5 eta_B1] GHC.Base.id eta_B1;

Data.Functor.Identity.$fFoldableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Functor.Identity.$fFoldableIdentity8
                                             Data.Functor.Identity.$fFoldableIdentity7
                                             Data.Functor.Identity.$fFoldableIdentity_$cfoldr
                                             Data.Functor.Identity.$fFoldableIdentity_$cfoldr
                                             Data.Functor.Identity.$fFoldableIdentity6
                                             Data.Functor.Identity.$fFoldableIdentity6
                                             Data.Functor.Identity.$fFoldableIdentity5
                                             Data.Functor.Identity.$fFoldableIdentity5
                                             Data.Functor.Identity.$fFoldableIdentity_$ctoList
                                             Data.Functor.Identity.$fFoldableIdentity_$cnull
                                             Data.Functor.Identity.$fFoldableIdentity_$clength
                                             GHC.Classes.==
                                             Data.Functor.Identity.$fFoldableIdentity3
                                             Data.Functor.Identity.$fFoldableIdentity3
                                             Data.Functor.Identity.$fFoldableIdentity1
                                             Data.Functor.Identity.$fFoldableIdentity1];

Data.Functor.Identity.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Identity.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$trModule4];

Data.Functor.Identity.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Identity"#;

Data.Functor.Identity.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$trModule2];

Data.Functor.Identity.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Identity.$trModule3
                                     Data.Functor.Identity.$trModule1];

$krep_rbJt7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Functor.Identity.$tcIdentity1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$fReadIdentity6];

Data.Functor.Identity.$tcIdentity :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3410104521590905987##
                                    16392070908630191652##
                                    Data.Functor.Identity.$trModule
                                    Data.Functor.Identity.$tcIdentity1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep1_rbJt8 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rbJt7 GHC.Types.[]];

$krep2_rbJt9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Identity.$tcIdentity
                                              $krep1_rbJt8];

Data.Functor.Identity.$tc'Identity1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rbJt7 $krep2_rbJt9];

Data.Functor.Identity.$tc'Identity3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Identity"#;

Data.Functor.Identity.$tc'Identity2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$tc'Identity3];

Data.Functor.Identity.$tc'Identity :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11920310844698764515##
                                    3935129235072617509##
                                    Data.Functor.Identity.$trModule
                                    Data.Functor.Identity.$tc'Identity2
                                    1#
                                    Data.Functor.Identity.$tc'Identity1];


==================== STG syntax: ====================
2018-03-16 16:06:35.695028375 UTC

Data.Functor.Identity.$fReadIdentity4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Identity.$fReadIdentity6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity"#;

Data.Functor.Identity.$fReadIdentity5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Identity.$fReadIdentity6;

Data.Functor.Identity.$w$creadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Prim.Int#
     -> GHC.Base.String
     -> [(Data.Functor.Identity.Identity a, GHC.Base.String)]
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbJtb ww_sbJtc w1_sbJtd]
        let {
          go_sbJte [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(Data.Functor.Identity.Identity a_sbJqG, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sbJtb go_sbJte] \r [ds_sbJtf]
                  case ds_sbJtf of {
                    [] -> [] [];
                    : y_sbJth [Occ=Once!] ys_sbJti [Occ=Once*] ->
                        case y_sbJth of {
                          (,) ds1_sbJtk [Occ=Once] s_sbJtl [Occ=Once] ->
                              case
                                  GHC.Base.eqString ds1_sbJtk Data.Functor.Identity.$fReadIdentity5
                              of
                              { GHC.Types.False -> go_sbJte ys_sbJti;
                                GHC.Types.True ->
                                    let {
                                      z_sbJtn [Occ=OnceL]
                                        :: [(Data.Functor.Identity.Identity a_sbJqG,
                                             GHC.Base.String)]
                                      [LclId] =
                                          [go_sbJte ys_sbJti] \u [] go_sbJte ys_sbJti; } in
                                    let {
                                      go1_sbJto [Occ=LoopBreaker]
                                        :: [(a_sbJqG, GHC.Base.String)]
                                           -> [(Data.Functor.Identity.Identity a_sbJqG,
                                                GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [z_sbJtn go1_sbJto] \r [ds2_sbJtp]
                                              case ds2_sbJtp of {
                                                [] -> z_sbJtn;
                                                : y1_sbJtr [Occ=Once!] ys1_sbJts [Occ=Once] ->
                                                    case y1_sbJtr of {
                                                      (,) x_sbJtu [Occ=Once] t_sbJtv [Occ=Once] ->
                                                          let {
                                                            sat_sbJtx [Occ=Once]
                                                              :: [(Data.Functor.Identity.Identity
                                                                     a_sbJqG,
                                                                   GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sbJto ys1_sbJts] \u []
                                                                    go1_sbJto ys1_sbJts;
                                                          } in  : [wild4_sbJtt sat_sbJtx];
                                                    };
                                              };
                                    } in 
                                      case
                                          GHC.Read.readsPrec
                                              w_sbJtb Data.Functor.Identity.$fReadIdentity4 s_sbJtl
                                      of
                                      sat_sbJty
                                      { __DEFAULT -> go1_sbJto sat_sbJty;
                                      };
                              };
                        };
                  }; } in
        let {
          sat_sbJtD [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 (Data.Functor.Identity.Identity a_sbJqG)
          [LclId] =
              [go_sbJte] \r [r_sbJtB]
                  case
                      Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_sbJtB
                  of
                  sat_sbJtC
                  { __DEFAULT -> go_sbJte sat_sbJtC;
                  };
        } in 
          case ># [ww_sbJtc 10#] of sat_sbJtz {
            __DEFAULT ->
                case tagToEnum# [sat_sbJtz] of sat_sbJtA {
                  __DEFAULT -> GHC.Read.readParen sat_sbJtA sat_sbJtD w1_sbJtd;
                };
          };

Data.Functor.Identity.$fReadIdentity_$creadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbJtE w1_sbJtF w2_sbJtG]
        case w1_sbJtF of {
          GHC.Types.I# ww1_sbJtI [Occ=Once] ->
              Data.Functor.Identity.$w$creadsPrec w_sbJtE ww1_sbJtI w2_sbJtG;
        };

Data.Functor.Identity.$fReadIdentity3
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><L,U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [$dRead_sbJtJ n_sbJtK eta_sbJtL]
        let {
          sat_sbJtM [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 (Data.Functor.Identity.Identity a_abJ16)
          [LclId] =
              [$dRead_sbJtJ n_sbJtK] \r [eta_B1]
                  Data.Functor.Identity.$fReadIdentity_$creadsPrec
                      $dRead_sbJtJ n_sbJtK eta_B1;
        } in 
          case
              Text.ParserCombinators.ReadP.$wreadS_to_P sat_sbJtM eta_sbJtL
          of
          { Unit# ww1_sbJtO [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sbJtO];
          };

Data.Functor.Identity.$fReadIdentity2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Identity.$fReadIdentity_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Identity.Identity a]
[GblId, Arity=1, Str=<L,U(C(C1(U)),A,A,A)>, Unf=OtherCon []] =
    [] \r [$dRead_sbJtP]
        let {
          sat_sbJtR [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_XbJ2M]
          [LclId] =
              [$dRead_sbJtP] \u []
                  let {
                    sat_sbJtQ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_XbJ2M)
                    [LclId] =
                        [$dRead_sbJtP] \r [eta_B2 eta_B1]
                            Data.Functor.Identity.$fReadIdentity3 $dRead_sbJtP eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sbJtQ
                        Data.Functor.Identity.$fReadIdentity2
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sbJtR;

Data.Functor.Identity.$w$creadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall b.
     ([Data.Functor.Identity.Identity a]
      -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,U(C(C1(U)),A,A,A)>, Unf=OtherCon []] =
    [] \r [w_sbJtS]
        let {
          w1_sbJtT [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_sbJqP]
          [LclId] =
              [w_sbJtS] \u []
                  let {
                    sat_sbJtU
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sbJqP)
                    [LclId] =
                        [w_sbJtS] \r [eta_B2 eta_B1]
                            Data.Functor.Identity.$fReadIdentity3 w_sbJtS eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sbJtU
                        Data.Functor.Identity.$fReadIdentity2
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          w2_sbJtV [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Identity.Identity a_sbJqP]
          [LclId, Arity=1, Unf=OtherCon []] =
              [w1_sbJtT] \r [eta_B1]
                  Text.ParserCombinators.ReadP.run w1_sbJtT eta_B1; } in
        let {
          sat_sbJtZ [Occ=OnceT[0]]
            :: forall b.
               ([Data.Functor.Identity.Identity a_sbJqP]
                -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w2_sbJtV] \r [w3_sbJtW]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w2_sbJtV w3_sbJtW
                  of
                  { Unit# ww1_sbJtY [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sbJtY];
                  };
        } in  sat_sbJtZ;

Data.Functor.Identity.$fReadIdentity1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([Data.Functor.Identity.Identity a]
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,U(C(C1(U)),A,A,A)><L,A>, Unf=OtherCon []] =
    [] \r [w_sbJu0 w1_sbJu1]
        Data.Functor.Identity.$w$creadListPrec w_sbJu0;

Data.Functor.Identity.$fReadIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,A,A)>m] =
    [] \r [$dRead_sbJu2]
        let {
          lvl1_sbJu3 [Occ=OnceL]
            :: forall b.
               ([Data.Functor.Identity.Identity a_XbJ2R]
                -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sbJu2] \u []
                  Data.Functor.Identity.$w$creadListPrec $dRead_sbJu2; } in
        let {
          sat_sbJu8 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Identity.Identity a_XbJ2R]
          [LclId] =
              [lvl1_sbJu3] \r [w_sbJu7] lvl1_sbJu3; } in
        let {
          sat_sbJu6 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_XbJ2R)
          [LclId] =
              [$dRead_sbJu2] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fReadIdentity3
                      $dRead_sbJu2 eta_B2 eta_B1; } in
        let {
          sat_sbJu5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Identity.Identity a_XbJ2R]
          [LclId] =
              [$dRead_sbJu2] \u []
                  Data.Functor.Identity.$fReadIdentity_$creadList $dRead_sbJu2; } in
        let {
          sat_sbJu4 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Identity.Identity a_XbJ2R)
          [LclId] =
              [$dRead_sbJu2] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fReadIdentity_$creadsPrec
                      $dRead_sbJu2 eta_B2 eta_B1;
        } in  GHC.Read.C:Read [sat_sbJu4 sat_sbJu5 sat_sbJu6 sat_sbJu8];

Data.Functor.Identity.$fShowIdentity2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity "#;

Data.Functor.Identity.$fShowIdentity1 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Identity.$fShowIdentity2;

Data.Functor.Identity.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Functor.Identity.Identity a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbJu9 ww_sbJua w1_sbJub]
        let {
          g_sbJuc [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sbJu9 w1_sbJub] \u []
                  GHC.Show.showsPrec
                      w_sbJu9 Data.Functor.Identity.$fReadIdentity4 w1_sbJub;
        } in 
          case ># [ww_sbJua 10#] of {
            __DEFAULT ->
                let {
                  sat_sbJug [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [g_sbJuc] \r [x_sbJue]
                          let {
                            sat_sbJuf [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sbJuc x_sbJue] \s [] g_sbJuc x_sbJue;
                          } in  GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbJuf;
                } in  sat_sbJug;
            1# ->
                let {
                  sat_sbJul [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [g_sbJuc] \r [x_sbJuh]
                          let {
                            sat_sbJuk [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sbJuc x_sbJuh] \u []
                                    let {
                                      sat_sbJuj [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sbJuc x_sbJuh] \s []
                                              let {
                                                sat_sbJui [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sbJuh];
                                              } in  g_sbJuc sat_sbJui;
                                    } in 
                                      GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbJuj;
                          } in  : [GHC.Show.$fShow(,)4 sat_sbJuk];
                } in  sat_sbJul;
          };

Data.Functor.Identity.$fShowIdentity_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Functor.Identity.Identity a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbJum w1_sbJun w2_sbJuo]
        case w1_sbJun of {
          GHC.Types.I# ww1_sbJuq [Occ=Once] ->
              Data.Functor.Identity.$w$cshowsPrec w_sbJum ww1_sbJuq w2_sbJuo;
        };

Data.Functor.Identity.$fShowIdentity_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Identity.Identity a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbJur x_sbJus]
        let {
          sat_sbJut [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sbJur x_sbJus] \s []
                  GHC.Show.showsPrec
                      $dShow_sbJur
                      Data.Functor.Identity.$fReadIdentity4
                      x_sbJus
                      GHC.Types.[];
        } in  GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbJut;

Data.Functor.Identity.$fShowIdentity_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Functor.Identity.Identity a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbJuu ls_sbJuv s_sbJuw]
        let {
          sat_sbJuy [Occ=Once]
            :: Data.Functor.Identity.Identity a_abJ0D -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbJuu] \r [w_sbJux]
                  Data.Functor.Identity.$w$cshowsPrec $dShow_sbJuu 0# w_sbJux;
        } in  GHC.Show.showList__ sat_sbJuy ls_sbJuv s_sbJuw;

Data.Functor.Identity.$fShowIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sbJuz]
        let {
          sat_sbJuC [Occ=Once]
            :: [Data.Functor.Identity.Identity a_abJ0D] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbJuz] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshowList
                      $dShow_sbJuz eta_B2 eta_B1; } in
        let {
          sat_sbJuB [Occ=Once]
            :: Data.Functor.Identity.Identity a_abJ0D -> GHC.Base.String
          [LclId] =
              [$dShow_sbJuz] \r [eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshow
                      $dShow_sbJuz eta_B1; } in
        let {
          sat_sbJuA [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abJ0D -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbJuz] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshowsPrec
                      $dShow_sbJuz eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sbJuA sat_sbJuB sat_sbJuC];

Data.Functor.Identity.$fFoldableIdentity4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Functor.Identity.$fFoldableIdentity_$clength
  :: forall a. Data.Functor.Identity.Identity a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sbJuD] Data.Functor.Identity.$fFoldableIdentity4;

Data.Functor.Identity.$fFoldableIdentity_$cnull
  :: forall a. Data.Functor.Identity.Identity a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbJuE] GHC.Types.False [];

Data.Functor.Identity.$fFoldableIdentity_$ctoList
  :: forall a. Data.Functor.Identity.Identity a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_sbJuF] : [ds_sbJuF GHC.Types.[]];

Data.Functor.Identity.$fFoldableIdentity6
  :: forall b a. (b -> a -> b) -> b -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbJuG] v_sbJuG;

Data.Functor.Identity.$fFoldableIdentity_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Functor.Identity.Identity a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sbJuH z_sbJuI ds_sbJuJ] f_sbJuH ds_sbJuJ z_sbJuI;

Data.Functor.Identity.$fFoldableIdentity7
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> a -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sbJuK v_sbJuL] v_sbJuL;

Data.Functor.Identity.$fFunctorIdentity2
  :: forall a b. (a -> b) -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbJuM] v_sbJuM;

Data.Functor.Identity.$fFunctorIdentity1 :: forall b a. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sbJuN ds_sbJuO] x_sbJuN;

Data.Functor.Identity.$fFunctorIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Identity.$fFunctorIdentity2
                                       Data.Functor.Identity.$fFunctorIdentity1];

Data.Functor.Identity.$fApplicativeIdentity1
  :: forall a b c. (a -> b -> c) -> a -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbJuP] v_sbJuP;

Data.Functor.Identity.$fApplicativeIdentity2
  :: forall a b.
     Data.Functor.Identity.Identity (a -> b)
     -> Data.Functor.Identity.Identity (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbJuQ] v_sbJuQ;

Data.Functor.Identity.$fApplicativeIdentity3 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbJuR] v_sbJuR;

Data.Functor.Identity.$fApplicativeIdentity_$c*>
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sbJuS a2_sbJuT] a2_sbJuT;

Data.Functor.Identity.$fApplicativeIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Identity.$fFunctorIdentity
                                           Data.Functor.Identity.$fApplicativeIdentity3
                                           Data.Functor.Identity.$fApplicativeIdentity2
                                           Data.Functor.Identity.$fApplicativeIdentity1
                                           Data.Functor.Identity.$fApplicativeIdentity_$c*>
                                           GHC.Base.const];

Data.Functor.Identity.$fStorableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Foreign.Storable.Storable a =>
     Foreign.Storable.Storable (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dStorable_sbJuU]
        let {
          sat_sbJv2 [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> Data.Functor.Identity.Identity a_abITC -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.poke $dStorable_sbJuU; } in
        let {
          sat_sbJv1 [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.peek $dStorable_sbJuU; } in
        let {
          sat_sbJv0 [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abITC
               -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.pokeByteOff $dStorable_sbJuU; } in
        let {
          sat_sbJuZ [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.peekByteOff $dStorable_sbJuU; } in
        let {
          sat_sbJuY [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abITC
               -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.pokeElemOff $dStorable_sbJuU; } in
        let {
          sat_sbJuX [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.Int
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.peekElemOff $dStorable_sbJuU; } in
        let {
          sat_sbJuW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abITC -> GHC.Types.Int
          [LclId] =
              [$dStorable_sbJuU] \u []
                  Foreign.Storable.alignment $dStorable_sbJuU; } in
        let {
          sat_sbJuV [Occ=Once]
            :: Data.Functor.Identity.Identity a_abITC -> GHC.Types.Int
          [LclId] =
              [$dStorable_sbJuU] \u [] Foreign.Storable.sizeOf $dStorable_sbJuU;
        } in 
          Foreign.Storable.C:Storable [sat_sbJuV
                                       sat_sbJuW
                                       sat_sbJuX
                                       sat_sbJuY
                                       sat_sbJuZ
                                       sat_sbJv0
                                       sat_sbJv1
                                       sat_sbJv2];

Data.Functor.Identity.$fNumIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_sbJv3]
        let {
          sat_sbJva [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.fromInteger $dNum_sbJv3; } in
        let {
          sat_sbJv9 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.signum $dNum_sbJv3; } in
        let {
          sat_sbJv8 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.abs $dNum_sbJv3; } in
        let {
          sat_sbJv7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.negate $dNum_sbJv3; } in
        let {
          sat_sbJv6 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.* $dNum_sbJv3; } in
        let {
          sat_sbJv5 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.- $dNum_sbJv3; } in
        let {
          sat_sbJv4 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbJv3] \u [] GHC.Num.+ $dNum_sbJv3;
        } in 
          GHC.Num.C:Num [sat_sbJv4
                         sat_sbJv5
                         sat_sbJv6
                         sat_sbJv7
                         sat_sbJv8
                         sat_sbJv9
                         sat_sbJva];

Data.Functor.Identity.$fRealIdentity_$cp1Real
  :: forall a.
     GHC.Real.Real a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dReal_sbJvb]
        let {
          sat_sbJvc [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Num.Num a_abIOf
          [LclId] =
              [$dReal_sbJvb] \u [] GHC.Real.$p1Real $dReal_sbJvb;
        } in  Data.Functor.Identity.$fNumIdentity sat_sbJvc;

Data.Functor.Identity.$fSemigroupIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U,1*U)>m] =
    [] \r [$dSemigroup_sbJvd]
        let {
          sat_sbJvg [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbJvd] \u [] GHC.Base.stimes $dSemigroup_sbJvd; } in
        let {
          sat_sbJvf [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Identity.Identity a_abIJk)
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbJvd] \u [] GHC.Base.sconcat $dSemigroup_sbJvd; } in
        let {
          sat_sbJve [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbJvd] \u [] GHC.Base.<> $dSemigroup_sbJvd;
        } in  GHC.Base.C:Semigroup [sat_sbJve sat_sbJvf sat_sbJvg];

Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sbJvh]
        let {
          sat_sbJvi [Occ=Once, Dmd=<L,U(1*U,1*U,1*U)>]
            :: GHC.Base.Semigroup a_abIKg
          [LclId] =
              [$dMonoid_sbJvh] \u [] GHC.Base.$p1Monoid $dMonoid_sbJvh;
        } in  Data.Functor.Identity.$fSemigroupIdentity sat_sbJvi;

Data.Functor.Identity.$fMonoidIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dMonoid_sbJvj]
        let {
          sat_sbJvn [Occ=Once]
            :: [Data.Functor.Identity.Identity a_abIKg]
               -> Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbJvj] \u [] GHC.Base.mconcat $dMonoid_sbJvj; } in
        let {
          sat_sbJvm [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKg
               -> Data.Functor.Identity.Identity a_abIKg
               -> Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbJvj] \u [] GHC.Base.mappend $dMonoid_sbJvj; } in
        let {
          sat_sbJvl [Occ=Once] :: Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbJvj] \u [] GHC.Base.mempty $dMonoid_sbJvj; } in
        let {
          sat_sbJvk [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Identity.Identity a_abIKg)
          [LclId] =
              [$dMonoid_sbJvj] \u []
                  Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid $dMonoid_sbJvj;
        } in  GHC.Base.C:Monoid [sat_sbJvk sat_sbJvl sat_sbJvm sat_sbJvn];

Data.Functor.Identity.$fGeneric1Identity1
  :: forall a.
     GHC.Generics.Rep1 Data.Functor.Identity.Identity a
     -> GHC.Generics.Rep1 Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbJvo] ds_sbJvo;

Data.Functor.Identity.$fFoldableIdentity2
  :: forall a.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbJvp] x_sbJvp;

Data.Functor.Identity.$fGeneric1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Identity.$fFoldableIdentity2
                                            Data.Functor.Identity.$fGeneric1Identity1];

Data.Functor.Identity.$fGenericIdentity1
  :: forall a x.
     GHC.Generics.Rep (Data.Functor.Identity.Identity a) x
     -> GHC.Generics.Rep (Data.Functor.Identity.Identity a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbJvq] ds_sbJvq;

Data.Functor.Identity.$fGenericIdentity2
  :: forall a x.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbJvr] x1_sbJvr;

Data.Functor.Identity.$fGenericIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Generics.Generic (Data.Functor.Identity.Identity a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Identity.$fGenericIdentity2
                                           Data.Functor.Identity.$fGenericIdentity1];

Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
  :: forall a.
     GHC.Real.Fractional a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFractional_sbJvs]
        let {
          sat_sbJvt [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Num.Num a_abIDx
          [LclId] =
              [$dFractional_sbJvs] \u []
                  GHC.Real.$p1Fractional $dFractional_sbJvs;
        } in  Data.Functor.Identity.$fNumIdentity sat_sbJvt;

Data.Functor.Identity.$fFractionalIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Fractional a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dFractional_sbJvu]
        let {
          sat_sbJvy [Occ=Once]
            :: GHC.Real.Rational -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbJvu] \u []
                  GHC.Real.fromRational $dFractional_sbJvu; } in
        let {
          sat_sbJvx [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbJvu] \u [] GHC.Real.recip $dFractional_sbJvu; } in
        let {
          sat_sbJvw [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbJvu] \u [] GHC.Real./ $dFractional_sbJvu; } in
        let {
          sat_sbJvv [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Identity.Identity a_abIDx)
          [LclId] =
              [$dFractional_sbJvu] \u []
                  Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
                      $dFractional_sbJvu;
        } in 
          GHC.Real.C:Fractional [sat_sbJvv sat_sbJvw sat_sbJvx sat_sbJvy];

Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_sbJvz]
        let {
          sat_sbJvA [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>]
            :: GHC.Real.Fractional a_abIOC
          [LclId] =
              [$dRealFrac_sbJvz] \u [] GHC.Real.$p2RealFrac $dRealFrac_sbJvz;
        } in  Data.Functor.Identity.$fFractionalIdentity sat_sbJvA;

Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
  :: forall a.
     GHC.Float.Floating a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sbJvB]
        let {
          sat_sbJvC [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>]
            :: GHC.Real.Fractional a_abIzr
          [LclId] =
              [$dFloating_sbJvB] \u [] GHC.Float.$p1Floating $dFloating_sbJvB;
        } in  Data.Functor.Identity.$fFractionalIdentity sat_sbJvC;

Data.Functor.Identity.$fFloatingIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.Floating a =>
     GHC.Float.Floating (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dFloating_sbJvD]
        let {
          sat_sbJw0 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.log1mexp $dFloating_sbJvD; } in
        let {
          sat_sbJvZ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.log1pexp $dFloating_sbJvD; } in
        let {
          sat_sbJvY [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.expm1 $dFloating_sbJvD; } in
        let {
          sat_sbJvX [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.log1p $dFloating_sbJvD; } in
        let {
          sat_sbJvW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.atanh $dFloating_sbJvD; } in
        let {
          sat_sbJvV [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.acosh $dFloating_sbJvD; } in
        let {
          sat_sbJvU [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.asinh $dFloating_sbJvD; } in
        let {
          sat_sbJvT [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.tanh $dFloating_sbJvD; } in
        let {
          sat_sbJvS [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.cosh $dFloating_sbJvD; } in
        let {
          sat_sbJvR [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.sinh $dFloating_sbJvD; } in
        let {
          sat_sbJvQ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.atan $dFloating_sbJvD; } in
        let {
          sat_sbJvP [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.acos $dFloating_sbJvD; } in
        let {
          sat_sbJvO [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.asin $dFloating_sbJvD; } in
        let {
          sat_sbJvN [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.tan $dFloating_sbJvD; } in
        let {
          sat_sbJvM [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.cos $dFloating_sbJvD; } in
        let {
          sat_sbJvL [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.sin $dFloating_sbJvD; } in
        let {
          sat_sbJvK [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.logBase $dFloating_sbJvD; } in
        let {
          sat_sbJvJ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.** $dFloating_sbJvD; } in
        let {
          sat_sbJvI [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.sqrt $dFloating_sbJvD; } in
        let {
          sat_sbJvH [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.log $dFloating_sbJvD; } in
        let {
          sat_sbJvG [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.exp $dFloating_sbJvD; } in
        let {
          sat_sbJvF [Occ=Once] :: Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbJvD] \u [] GHC.Float.pi $dFloating_sbJvD; } in
        let {
          sat_sbJvE [Occ=Once]
            :: GHC.Real.Fractional (Data.Functor.Identity.Identity a_abIzr)
          [LclId] =
              [$dFloating_sbJvD] \u []
                  Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
                      $dFloating_sbJvD;
        } in 
          GHC.Float.C:Floating [sat_sbJvE
                                sat_sbJvF
                                sat_sbJvG
                                sat_sbJvH
                                sat_sbJvI
                                sat_sbJvJ
                                sat_sbJvK
                                sat_sbJvL
                                sat_sbJvM
                                sat_sbJvN
                                sat_sbJvO
                                sat_sbJvP
                                sat_sbJvQ
                                sat_sbJvR
                                sat_sbJvS
                                sat_sbJvT
                                sat_sbJvU
                                sat_sbJvV
                                sat_sbJvW
                                sat_sbJvX
                                sat_sbJvY
                                sat_sbJvZ
                                sat_sbJw0];

Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.Floating (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sbJw1]
        let {
          sat_sbJw2 [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Float.Floating a_abIQK
          [LclId] =
              [$dRealFloat_sbJw1] \u [] GHC.Float.$p2RealFloat $dRealFloat_sbJw1;
        } in  Data.Functor.Identity.$fFloatingIdentity sat_sbJw2;

Data.Functor.Identity.$fEqIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sbJw3]
        let {
          sat_sbJw5 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIye
               -> Data.Functor.Identity.Identity a_abIye -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbJw3] \u [] GHC.Classes./= $dEq_sbJw3; } in
        let {
          sat_sbJw4 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIye
               -> Data.Functor.Identity.Identity a_abIye -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbJw3] \u [] GHC.Classes.== $dEq_sbJw3;
        } in  GHC.Classes.C:Eq [sat_sbJw4 sat_sbJw5];

Data.Functor.Identity.$fOrdIdentity_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sbJw6]
        let {
          sat_sbJw7 [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_abIMq
          [LclId] =
              [$dOrd_sbJw6] \u [] GHC.Classes.$p1Ord $dOrd_sbJw6;
        } in  Data.Functor.Identity.$fEqIdentity sat_sbJw7;

Data.Functor.Identity.$fOrdIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sbJw8]
        let {
          sat_sbJwg [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.min $dOrd_sbJw8; } in
        let {
          sat_sbJwf [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.max $dOrd_sbJw8; } in
        let {
          sat_sbJwe [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.>= $dOrd_sbJw8; } in
        let {
          sat_sbJwd [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.> $dOrd_sbJw8; } in
        let {
          sat_sbJwc [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.<= $dOrd_sbJw8; } in
        let {
          sat_sbJwb [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.< $dOrd_sbJw8; } in
        let {
          sat_sbJwa [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sbJw8] \u [] GHC.Classes.compare $dOrd_sbJw8; } in
        let {
          sat_sbJw9 [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Identity.Identity a_abIMq)
          [LclId] =
              [$dOrd_sbJw8] \u []
                  Data.Functor.Identity.$fOrdIdentity_$cp1Ord $dOrd_sbJw8;
        } in 
          GHC.Classes.C:Ord [sat_sbJw9
                             sat_sbJwa
                             sat_sbJwb
                             sat_sbJwc
                             sat_sbJwd
                             sat_sbJwe
                             sat_sbJwf
                             sat_sbJwg];

Data.Functor.Identity.$fIxIdentity_$cp1Ix
  :: forall a.
     GHC.Arr.Ix a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIx_sbJwh]
        let {
          sat_sbJwi [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Classes.Ord a_abIHW
          [LclId] =
              [$dIx_sbJwh] \u [] GHC.Arr.$p1Ix $dIx_sbJwh;
        } in  Data.Functor.Identity.$fOrdIdentity sat_sbJwi;

Data.Functor.Identity.$fIxIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Arr.Ix a =>
     GHC.Arr.Ix (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dIx_sbJwj]
        let {
          sat_sbJwq [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> GHC.Types.Int
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.unsafeRangeSize $dIx_sbJwj; } in
        let {
          sat_sbJwp [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> GHC.Types.Int
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.rangeSize $dIx_sbJwj; } in
        let {
          sat_sbJwo [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Bool
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.inRange $dIx_sbJwj; } in
        let {
          sat_sbJwn [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Int
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.unsafeIndex $dIx_sbJwj; } in
        let {
          sat_sbJwm [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Int
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.index $dIx_sbJwj; } in
        let {
          sat_sbJwl [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> [Data.Functor.Identity.Identity a_abIHW]
          [LclId] =
              [$dIx_sbJwj] \u [] GHC.Arr.range $dIx_sbJwj; } in
        let {
          sat_sbJwk [Occ=Once]
            :: GHC.Classes.Ord (Data.Functor.Identity.Identity a_abIHW)
          [LclId] =
              [$dIx_sbJwj] \u []
                  Data.Functor.Identity.$fIxIdentity_$cp1Ix $dIx_sbJwj;
        } in 
          GHC.Arr.C:Ix [sat_sbJwk
                        sat_sbJwl
                        sat_sbJwm
                        sat_sbJwn
                        sat_sbJwo
                        sat_sbJwp
                        sat_sbJwq];

Data.Functor.Identity.$fRealIdentity_$cp2Real
  :: forall a.
     GHC.Real.Real a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),A)>m,
 Unf=OtherCon []] =
    [] \r [$dReal_sbJwr]
        let {
          sat_sbJws [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Classes.Ord a_abIOf
          [LclId] =
              [$dReal_sbJwr] \u [] GHC.Real.$p2Real $dReal_sbJwr;
        } in  Data.Functor.Identity.$fOrdIdentity sat_sbJws;

Data.Functor.Identity.$fRealIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Real a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>m] =
    [] \r [$dReal_sbJwt]
        let {
          sat_sbJww [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIOf -> GHC.Real.Rational
          [LclId] =
              [$dReal_sbJwt] \u [] GHC.Real.toRational $dReal_sbJwt; } in
        let {
          sat_sbJwv [Occ=Once]
            :: GHC.Classes.Ord (Data.Functor.Identity.Identity a_abIOf)
          [LclId] =
              [$dReal_sbJwt] \u []
                  Data.Functor.Identity.$fRealIdentity_$cp2Real $dReal_sbJwt; } in
        let {
          sat_sbJwu [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Identity.Identity a_abIOf)
          [LclId] =
              [$dReal_sbJwt] \u []
                  Data.Functor.Identity.$fRealIdentity_$cp1Real $dReal_sbJwt;
        } in  GHC.Real.C:Real [sat_sbJwu sat_sbJwv sat_sbJww];

Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sbJwx]
        let {
          sat_sbJwy [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>]
            :: GHC.Real.Real a_abIG7
          [LclId] =
              [$dIntegral_sbJwx] \u [] GHC.Real.$p1Integral $dIntegral_sbJwx;
        } in  Data.Functor.Identity.$fRealIdentity sat_sbJwy;

Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_sbJwz]
        let {
          sat_sbJwA [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>]
            :: GHC.Real.Real a_abIOC
          [LclId] =
              [$dRealFrac_sbJwz] \u [] GHC.Real.$p1RealFrac $dRealFrac_sbJwz;
        } in  Data.Functor.Identity.$fRealIdentity sat_sbJwA;

Data.Functor.Identity.$fRealFracIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dRealFrac_sbJwB]
        let {
          sat_sbJwI [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbJwB] \u [] GHC.Real.floor $dRealFrac_sbJwB; } in
        let {
          sat_sbJwH [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbJwB] \u [] GHC.Real.ceiling $dRealFrac_sbJwB; } in
        let {
          sat_sbJwG [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbJwB] \u [] GHC.Real.round $dRealFrac_sbJwB; } in
        let {
          sat_sbJwF [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbJwB] \u [] GHC.Real.truncate $dRealFrac_sbJwB; } in
        let {
          sat_sbJwE [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC
               -> (b, Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbJwB] \u []
                  GHC.Real.properFraction $dRealFrac_sbJwB; } in
        let {
          sat_sbJwD [Occ=Once]
            :: GHC.Real.Fractional (Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbJwB] \u []
                  Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
                      $dRealFrac_sbJwB; } in
        let {
          sat_sbJwC [Occ=Once]
            :: GHC.Real.Real (Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbJwB] \u []
                  Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
                      $dRealFrac_sbJwB;
        } in 
          GHC.Real.C:RealFrac [sat_sbJwC
                               sat_sbJwD
                               sat_sbJwE
                               sat_sbJwF
                               sat_sbJwG
                               sat_sbJwH
                               sat_sbJwI];

Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sbJwJ]
        let {
          sat_sbJwK [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Real.RealFrac a_abIQK
          [LclId] =
              [$dRealFloat_sbJwJ] \u [] GHC.Float.$p1RealFloat $dRealFloat_sbJwJ;
        } in  Data.Functor.Identity.$fRealFracIdentity sat_sbJwK;

Data.Functor.Identity.$fRealFloatIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.RealFloat (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dRealFloat_sbJwL]
        let {
          sat_sbJx1 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbJwL] \u [] GHC.Float.atan2 $dRealFloat_sbJwL; } in
        let {
          sat_sbJx0 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbJwL] \u [] GHC.Float.isIEEE $dRealFloat_sbJwL; } in
        let {
          sat_sbJwZ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.isNegativeZero $dRealFloat_sbJwL; } in
        let {
          sat_sbJwY [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.isDenormalized $dRealFloat_sbJwL; } in
        let {
          sat_sbJwX [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.isInfinite $dRealFloat_sbJwL; } in
        let {
          sat_sbJwW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbJwL] \u [] GHC.Float.isNaN $dRealFloat_sbJwL; } in
        let {
          sat_sbJwV [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.scaleFloat $dRealFloat_sbJwL; } in
        let {
          sat_sbJwU [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.significand $dRealFloat_sbJwL; } in
        let {
          sat_sbJwT [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Int
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.exponent $dRealFloat_sbJwL; } in
        let {
          sat_sbJwS [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.encodeFloat $dRealFloat_sbJwL; } in
        let {
          sat_sbJwR [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> (GHC.Integer.Type.Integer, GHC.Types.Int)
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.decodeFloat $dRealFloat_sbJwL; } in
        let {
          sat_sbJwQ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> (GHC.Types.Int, GHC.Types.Int)
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.floatRange $dRealFloat_sbJwL; } in
        let {
          sat_sbJwP [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Int
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.floatDigits $dRealFloat_sbJwL; } in
        let {
          sat_sbJwO [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> GHC.Integer.Type.Integer
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  GHC.Float.floatRadix $dRealFloat_sbJwL; } in
        let {
          sat_sbJwN [Occ=Once]
            :: GHC.Float.Floating (Data.Functor.Identity.Identity a_abIQK)
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
                      $dRealFloat_sbJwL; } in
        let {
          sat_sbJwM [Occ=Once]
            :: GHC.Real.RealFrac (Data.Functor.Identity.Identity a_abIQK)
          [LclId] =
              [$dRealFloat_sbJwL] \u []
                  Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
                      $dRealFloat_sbJwL;
        } in 
          GHC.Float.C:RealFloat [sat_sbJwM
                                 sat_sbJwN
                                 sat_sbJwO
                                 sat_sbJwP
                                 sat_sbJwQ
                                 sat_sbJwR
                                 sat_sbJwS
                                 sat_sbJwT
                                 sat_sbJwU
                                 sat_sbJwV
                                 sat_sbJwW
                                 sat_sbJwX
                                 sat_sbJwY
                                 sat_sbJwZ
                                 sat_sbJx0
                                 sat_sbJx1];

Data.Functor.Identity.$fEnumIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dEnum_sbJx2]
        let {
          sat_sbJxa [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.enumFromThenTo $dEnum_sbJx2; } in
        let {
          sat_sbJx9 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.enumFromTo $dEnum_sbJx2; } in
        let {
          sat_sbJx8 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.enumFromThen $dEnum_sbJx2; } in
        let {
          sat_sbJx7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.enumFrom $dEnum_sbJx2; } in
        let {
          sat_sbJx6 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu -> GHC.Types.Int
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.fromEnum $dEnum_sbJx2; } in
        let {
          sat_sbJx5 [Occ=Once]
            :: GHC.Types.Int -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.toEnum $dEnum_sbJx2; } in
        let {
          sat_sbJx4 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.pred $dEnum_sbJx2; } in
        let {
          sat_sbJx3 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbJx2] \u [] GHC.Enum.succ $dEnum_sbJx2;
        } in 
          GHC.Enum.C:Enum [sat_sbJx3
                           sat_sbJx4
                           sat_sbJx5
                           sat_sbJx6
                           sat_sbJx7
                           sat_sbJx8
                           sat_sbJx9
                           sat_sbJxa];

Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Enum.Enum (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sbJxb]
        let {
          sat_sbJxc [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Enum.Enum a_abIG7
          [LclId] =
              [$dIntegral_sbJxb] \u [] GHC.Real.$p2Integral $dIntegral_sbJxb;
        } in  Data.Functor.Identity.$fEnumIdentity sat_sbJxc;

Data.Functor.Identity.$fIntegralIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Integral (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dIntegral_sbJxd]
        let {
          sat_sbJxm [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> GHC.Integer.Type.Integer
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.toInteger $dIntegral_sbJxd; } in
        let {
          sat_sbJxl [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> (Data.Functor.Identity.Identity a_abIG7,
                   Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.divMod $dIntegral_sbJxd; } in
        let {
          sat_sbJxk [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> (Data.Functor.Identity.Identity a_abIG7,
                   Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.quotRem $dIntegral_sbJxd; } in
        let {
          sat_sbJxj [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.mod $dIntegral_sbJxd; } in
        let {
          sat_sbJxi [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.div $dIntegral_sbJxd; } in
        let {
          sat_sbJxh [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.rem $dIntegral_sbJxd; } in
        let {
          sat_sbJxg [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbJxd] \u [] GHC.Real.quot $dIntegral_sbJxd; } in
        let {
          sat_sbJxf [Occ=Once]
            :: GHC.Enum.Enum (Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbJxd] \u []
                  Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
                      $dIntegral_sbJxd; } in
        let {
          sat_sbJxe [Occ=Once]
            :: GHC.Real.Real (Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbJxd] \u []
                  Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
                      $dIntegral_sbJxd;
        } in 
          GHC.Real.C:Integral [sat_sbJxe
                               sat_sbJxf
                               sat_sbJxg
                               sat_sbJxh
                               sat_sbJxi
                               sat_sbJxj
                               sat_sbJxk
                               sat_sbJxl
                               sat_sbJxm];

Data.Functor.Identity.$fBoundedIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sbJxn]
        let {
          sat_sbJxp [Occ=Once] :: Data.Functor.Identity.Identity a_abIwc
          [LclId] =
              [$dBounded_sbJxn] \u [] GHC.Enum.maxBound $dBounded_sbJxn; } in
        let {
          sat_sbJxo [Occ=Once] :: Data.Functor.Identity.Identity a_abIwc
          [LclId] =
              [$dBounded_sbJxn] \u [] GHC.Enum.minBound $dBounded_sbJxn;
        } in  GHC.Enum.C:Bounded [sat_sbJxo sat_sbJxp];

Data.Functor.Identity.$fBitsIdentity_$cp1Bits
  :: forall a.
     Data.Bits.Bits a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dBits_sbJxq]
        let {
          sat_sbJxr [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_abIrg
          [LclId] =
              [$dBits_sbJxq] \u [] Data.Bits.$p1Bits $dBits_sbJxq;
        } in  Data.Functor.Identity.$fEqIdentity sat_sbJxr;

Data.Functor.Identity.$fBitsIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Bits.Bits a =>
     Data.Bits.Bits (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dBits_sbJxs]
        let {
          sat_sbJxP [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Int
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.popCount $dBits_sbJxs; } in
        let {
          sat_sbJxO [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.rotateR $dBits_sbJxs; } in
        let {
          sat_sbJxN [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.rotateL $dBits_sbJxs; } in
        let {
          sat_sbJxM [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.unsafeShiftR $dBits_sbJxs; } in
        let {
          sat_sbJxL [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.shiftR $dBits_sbJxs; } in
        let {
          sat_sbJxK [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.unsafeShiftL $dBits_sbJxs; } in
        let {
          sat_sbJxJ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.shiftL $dBits_sbJxs; } in
        let {
          sat_sbJxI [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Bool
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.isSigned $dBits_sbJxs; } in
        let {
          sat_sbJxH [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Int
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.bitSize $dBits_sbJxs; } in
        let {
          sat_sbJxG [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Base.Maybe GHC.Types.Int
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.bitSizeMaybe $dBits_sbJxs; } in
        let {
          sat_sbJxF [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> GHC.Types.Bool
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.testBit $dBits_sbJxs; } in
        let {
          sat_sbJxE [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.complementBit $dBits_sbJxs; } in
        let {
          sat_sbJxD [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.clearBit $dBits_sbJxs; } in
        let {
          sat_sbJxC [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.setBit $dBits_sbJxs; } in
        let {
          sat_sbJxB [Occ=Once]
            :: GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.bit $dBits_sbJxs; } in
        let {
          sat_sbJxA [Occ=Once] :: Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.zeroBits $dBits_sbJxs; } in
        let {
          sat_sbJxz [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.rotate $dBits_sbJxs; } in
        let {
          sat_sbJxy [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.shift $dBits_sbJxs; } in
        let {
          sat_sbJxx [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.complement $dBits_sbJxs; } in
        let {
          sat_sbJxw [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits.xor $dBits_sbJxs; } in
        let {
          sat_sbJxv [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits..|. $dBits_sbJxs; } in
        let {
          sat_sbJxu [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbJxs] \u [] Data.Bits..&. $dBits_sbJxs; } in
        let {
          sat_sbJxt [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Identity.Identity a_abIrg)
          [LclId] =
              [$dBits_sbJxs] \u []
                  Data.Functor.Identity.$fBitsIdentity_$cp1Bits $dBits_sbJxs;
        } in 
          Data.Bits.C:Bits [sat_sbJxt
                            sat_sbJxu
                            sat_sbJxv
                            sat_sbJxw
                            sat_sbJxx
                            sat_sbJxy
                            sat_sbJxz
                            sat_sbJxA
                            sat_sbJxB
                            sat_sbJxC
                            sat_sbJxD
                            sat_sbJxE
                            sat_sbJxF
                            sat_sbJxG
                            sat_sbJxH
                            sat_sbJxI
                            sat_sbJxJ
                            sat_sbJxK
                            sat_sbJxL
                            sat_sbJxM
                            sat_sbJxN
                            sat_sbJxO
                            sat_sbJxP];

Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
  :: forall a.
     Data.Bits.FiniteBits a =>
     Data.Bits.Bits (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_sbJxQ]
        let {
          sat_sbJxR [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: Data.Bits.Bits a_abIyM
          [LclId] =
              [$dFiniteBits_sbJxQ] \u []
                  Data.Bits.$p1FiniteBits $dFiniteBits_sbJxQ;
        } in  Data.Functor.Identity.$fBitsIdentity sat_sbJxR;

Data.Functor.Identity.$fFiniteBitsIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Bits.FiniteBits a =>
     Data.Bits.FiniteBits (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dFiniteBits_sbJxS]
        let {
          sat_sbJxW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbJxS] \u []
                  Data.Bits.countTrailingZeros $dFiniteBits_sbJxS; } in
        let {
          sat_sbJxV [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbJxS] \u []
                  Data.Bits.countLeadingZeros $dFiniteBits_sbJxS; } in
        let {
          sat_sbJxU [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbJxS] \u []
                  Data.Bits.finiteBitSize $dFiniteBits_sbJxS; } in
        let {
          sat_sbJxT [Occ=Once]
            :: Data.Bits.Bits (Data.Functor.Identity.Identity a_abIyM)
          [LclId] =
              [$dFiniteBits_sbJxS] \u []
                  Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
                      $dFiniteBits_sbJxS;
        } in 
          Data.Bits.C:FiniteBits [sat_sbJxT sat_sbJxU sat_sbJxV sat_sbJxW];

Data.Functor.Identity.runIdentity
  :: forall a. Data.Functor.Identity.Identity a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fMonadFixIdentity_$cmfix
  :: forall a.
     (a -> Data.Functor.Identity.Identity a)
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sbJxX]
        let {
          x_sbJxY [Occ=LoopBreaker] :: Data.Functor.Identity.Identity a_abIVT
          [LclId] =
              [f_sbJxX x_sbJxY] \u [] f_sbJxX x_sbJxY;
        } in  x_sbJxY;

Data.Functor.Identity.$fMonadIdentity_$c>>=
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> (a -> Data.Functor.Identity.Identity b)
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_sbJxZ k_sbJy0] k_sbJy0 m_sbJxZ;

Data.Functor.Identity.$fMonadIdentity_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Functor.Identity.$fApplicativeIdentity_$c*> eta_B2 eta_B1;

lvl_rbJt6
  :: forall a. [GHC.Types.Char] -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sbJy1] GHC.Err.errorWithoutStackTrace eta_sbJy1;

Data.Functor.Identity.$fMonadIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Functor.Identity.$fApplicativeIdentity
                                     Data.Functor.Identity.$fMonadIdentity_$c>>=
                                     Data.Functor.Identity.$fMonadIdentity_$c>>
                                     Data.Functor.Identity.$fApplicativeIdentity3
                                     lvl_rbJt6];

Data.Functor.Identity.$fMonadFixIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Functor.Identity.$fMonadIdentity
                                                 Data.Functor.Identity.$fMonadFixIdentity_$cmfix];

Data.Functor.Identity.$fFoldableIdentity5
  :: forall a.
     (a -> a -> a)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbJy2 eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity3
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sbJy3 eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity1
  :: forall a.
     GHC.Num.Num a =>
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_sbJy4 eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity8
  :: forall m. GHC.Base.Monoid m => m -> m
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dMonoid_sbJy5 eta_B1] GHC.Base.id eta_B1;

Data.Functor.Identity.$fFoldableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Functor.Identity.$fFoldableIdentity8
                                             Data.Functor.Identity.$fFoldableIdentity7
                                             Data.Functor.Identity.$fFoldableIdentity_$cfoldr
                                             Data.Functor.Identity.$fFoldableIdentity_$cfoldr
                                             Data.Functor.Identity.$fFoldableIdentity6
                                             Data.Functor.Identity.$fFoldableIdentity6
                                             Data.Functor.Identity.$fFoldableIdentity5
                                             Data.Functor.Identity.$fFoldableIdentity5
                                             Data.Functor.Identity.$fFoldableIdentity_$ctoList
                                             Data.Functor.Identity.$fFoldableIdentity_$cnull
                                             Data.Functor.Identity.$fFoldableIdentity_$clength
                                             GHC.Classes.==
                                             Data.Functor.Identity.$fFoldableIdentity3
                                             Data.Functor.Identity.$fFoldableIdentity3
                                             Data.Functor.Identity.$fFoldableIdentity1
                                             Data.Functor.Identity.$fFoldableIdentity1];

Data.Functor.Identity.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Identity.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$trModule4];

Data.Functor.Identity.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Identity"#;

Data.Functor.Identity.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$trModule2];

Data.Functor.Identity.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Identity.$trModule3
                                     Data.Functor.Identity.$trModule1];

$krep_rbJt7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Functor.Identity.$tcIdentity1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$fReadIdentity6];

Data.Functor.Identity.$tcIdentity :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3410104521590905987##
                                    16392070908630191652##
                                    Data.Functor.Identity.$trModule
                                    Data.Functor.Identity.$tcIdentity1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep1_rbJt8 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rbJt7 GHC.Types.[]];

$krep2_rbJt9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Identity.$tcIdentity
                                              $krep1_rbJt8];

Data.Functor.Identity.$tc'Identity1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rbJt7 $krep2_rbJt9];

Data.Functor.Identity.$tc'Identity3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Identity"#;

Data.Functor.Identity.$tc'Identity2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$tc'Identity3];

Data.Functor.Identity.$tc'Identity :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11920310844698764515##
                                    3935129235072617509##
                                    Data.Functor.Identity.$trModule
                                    Data.Functor.Identity.$tc'Identity2
                                    1#
                                    Data.Functor.Identity.$tc'Identity1];


==================== Pre unarise: ====================
2018-03-16 16:06:38.679411972 UTC

Data.Functor.Identity.$fReadIdentity4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Identity.$fReadIdentity6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity"#;

Data.Functor.Identity.$fReadIdentity5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Identity.$fReadIdentity6;

Data.Functor.Identity.$w$creadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Prim.Int#
     -> GHC.Base.String
     -> [(Data.Functor.Identity.Identity a, GHC.Base.String)]
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbLrm ww_sbLrn w1_sbLro]
        let {
          go_sbLrp [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(Data.Functor.Identity.Identity a_sbJqG, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sbLrm go_sbLrp] \r [ds_sbLrq]
                  case ds_sbLrq of {
                    [] -> [] [];
                    : y_sbLrs [Occ=Once!] ys_sbLrt [Occ=Once*] ->
                        case y_sbLrs of {
                          (,) ds1_sbLrv [Occ=Once] s_sbLrw [Occ=Once] ->
                              case
                                  GHC.Base.eqString ds1_sbLrv Data.Functor.Identity.$fReadIdentity5
                              of
                              { GHC.Types.False -> go_sbLrp ys_sbLrt;
                                GHC.Types.True ->
                                    let {
                                      z_sbLry [Occ=OnceL]
                                        :: [(Data.Functor.Identity.Identity a_sbJqG,
                                             GHC.Base.String)]
                                      [LclId] =
                                          [go_sbLrp ys_sbLrt] \u [] go_sbLrp ys_sbLrt; } in
                                    let {
                                      go1_sbLrz [Occ=LoopBreaker]
                                        :: [(a_sbJqG, GHC.Base.String)]
                                           -> [(Data.Functor.Identity.Identity a_sbJqG,
                                                GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [z_sbLry go1_sbLrz] \r [ds2_sbLrA]
                                              case ds2_sbLrA of {
                                                [] -> z_sbLry;
                                                : y1_sbLrC [Occ=Once!] ys1_sbLrD [Occ=Once] ->
                                                    case y1_sbLrC of {
                                                      (,) x_sbLrF [Occ=Once] t_sbLrG [Occ=Once] ->
                                                          let {
                                                            sat_sbLrI [Occ=Once]
                                                              :: [(Data.Functor.Identity.Identity
                                                                     a_sbJqG,
                                                                   GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sbLrz ys1_sbLrD] \u []
                                                                    go1_sbLrz ys1_sbLrD;
                                                          } in  : [wild4_sbLrE sat_sbLrI];
                                                    };
                                              };
                                    } in 
                                      case
                                          GHC.Read.readsPrec
                                              w_sbLrm Data.Functor.Identity.$fReadIdentity4 s_sbLrw
                                      of
                                      sat_sbLrJ
                                      { __DEFAULT -> go1_sbLrz sat_sbLrJ;
                                      };
                              };
                        };
                  }; } in
        let {
          sat_sbLrO [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 (Data.Functor.Identity.Identity a_sbJqG)
          [LclId] =
              [go_sbLrp] \r [r_sbLrM]
                  case
                      Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_sbLrM
                  of
                  sat_sbLrN
                  { __DEFAULT -> go_sbLrp sat_sbLrN;
                  };
        } in 
          case ># [ww_sbLrn 10#] of sat_sbLrK {
            __DEFAULT ->
                case tagToEnum# [sat_sbLrK] of sat_sbLrL {
                  __DEFAULT -> GHC.Read.readParen sat_sbLrL sat_sbLrO w1_sbLro;
                };
          };

Data.Functor.Identity.$fReadIdentity_$creadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbLrP w1_sbLrQ w2_sbLrR]
        case w1_sbLrQ of {
          GHC.Types.I# ww1_sbLrT [Occ=Once] ->
              Data.Functor.Identity.$w$creadsPrec w_sbLrP ww1_sbLrT w2_sbLrR;
        };

Data.Functor.Identity.$fReadIdentity3
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><L,U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [$dRead_sbLrU n_sbLrV eta_sbLrW]
        let {
          sat_sbLrX [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 (Data.Functor.Identity.Identity a_abJ16)
          [LclId] =
              [$dRead_sbLrU n_sbLrV] \r [eta_B1]
                  Data.Functor.Identity.$fReadIdentity_$creadsPrec
                      $dRead_sbLrU n_sbLrV eta_B1;
        } in 
          case
              Text.ParserCombinators.ReadP.$wreadS_to_P sat_sbLrX eta_sbLrW
          of
          { Unit# ww1_sbLrZ [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sbLrZ];
          };

Data.Functor.Identity.$fReadIdentity2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Identity.$fReadIdentity_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Identity.Identity a]
[GblId, Arity=1, Str=<L,U(C(C1(U)),A,A,A)>, Unf=OtherCon []] =
    [] \r [$dRead_sbLs0]
        let {
          sat_sbLs2 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_XbJ2M]
          [LclId] =
              [$dRead_sbLs0] \u []
                  let {
                    sat_sbLs1 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_XbJ2M)
                    [LclId] =
                        [$dRead_sbLs0] \r [eta_B2 eta_B1]
                            Data.Functor.Identity.$fReadIdentity3 $dRead_sbLs0 eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sbLs1
                        Data.Functor.Identity.$fReadIdentity2
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sbLs2;

Data.Functor.Identity.$w$creadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall b.
     ([Data.Functor.Identity.Identity a]
      -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,U(C(C1(U)),A,A,A)>, Unf=OtherCon []] =
    [] \r [w_sbLs3]
        let {
          w1_sbLs4 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_sbJqP]
          [LclId] =
              [w_sbLs3] \u []
                  let {
                    sat_sbLs5
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sbJqP)
                    [LclId] =
                        [w_sbLs3] \r [eta_B2 eta_B1]
                            Data.Functor.Identity.$fReadIdentity3 w_sbLs3 eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sbLs5
                        Data.Functor.Identity.$fReadIdentity2
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          w2_sbLs6 [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Identity.Identity a_sbJqP]
          [LclId, Arity=1, Unf=OtherCon []] =
              [w1_sbLs4] \r [eta_B1]
                  Text.ParserCombinators.ReadP.run w1_sbLs4 eta_B1; } in
        let {
          sat_sbLsa [Occ=OnceT[0]]
            :: forall b.
               ([Data.Functor.Identity.Identity a_sbJqP]
                -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w2_sbLs6] \r [w3_sbLs7]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w2_sbLs6 w3_sbLs7
                  of
                  { Unit# ww1_sbLs9 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sbLs9];
                  };
        } in  sat_sbLsa;

Data.Functor.Identity.$fReadIdentity1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([Data.Functor.Identity.Identity a]
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,U(C(C1(U)),A,A,A)><L,A>, Unf=OtherCon []] =
    [] \r [w_sbLsb w1_sbLsc]
        Data.Functor.Identity.$w$creadListPrec w_sbLsb;

Data.Functor.Identity.$fReadIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,A,A)>m] =
    [] \r [$dRead_sbLsd]
        let {
          lvl1_sbLse [Occ=OnceL]
            :: forall b.
               ([Data.Functor.Identity.Identity a_XbJ2R]
                -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sbLsd] \u []
                  Data.Functor.Identity.$w$creadListPrec $dRead_sbLsd; } in
        let {
          sat_sbLsj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Identity.Identity a_XbJ2R]
          [LclId] =
              [lvl1_sbLse] \r [w_sbLsi] lvl1_sbLse; } in
        let {
          sat_sbLsh [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_XbJ2R)
          [LclId] =
              [$dRead_sbLsd] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fReadIdentity3
                      $dRead_sbLsd eta_B2 eta_B1; } in
        let {
          sat_sbLsg [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Identity.Identity a_XbJ2R]
          [LclId] =
              [$dRead_sbLsd] \u []
                  Data.Functor.Identity.$fReadIdentity_$creadList $dRead_sbLsd; } in
        let {
          sat_sbLsf [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Identity.Identity a_XbJ2R)
          [LclId] =
              [$dRead_sbLsd] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fReadIdentity_$creadsPrec
                      $dRead_sbLsd eta_B2 eta_B1;
        } in  GHC.Read.C:Read [sat_sbLsf sat_sbLsg sat_sbLsh sat_sbLsj];

Data.Functor.Identity.$fShowIdentity2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity "#;

Data.Functor.Identity.$fShowIdentity1 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Identity.$fShowIdentity2;

Data.Functor.Identity.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Functor.Identity.Identity a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbLsk ww_sbLsl w1_sbLsm]
        let {
          g_sbLsn [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sbLsk w1_sbLsm] \u []
                  GHC.Show.showsPrec
                      w_sbLsk Data.Functor.Identity.$fReadIdentity4 w1_sbLsm;
        } in 
          case ># [ww_sbLsl 10#] of {
            __DEFAULT ->
                let {
                  sat_sbLsr [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [g_sbLsn] \r [x_sbLsp]
                          let {
                            sat_sbLsq [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sbLsn x_sbLsp] \s [] g_sbLsn x_sbLsp;
                          } in  GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbLsq;
                } in  sat_sbLsr;
            1# ->
                let {
                  sat_sbLsw [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [g_sbLsn] \r [x_sbLss]
                          let {
                            sat_sbLsv [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sbLsn x_sbLss] \u []
                                    let {
                                      sat_sbLsu [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sbLsn x_sbLss] \s []
                                              let {
                                                sat_sbLst [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sbLss];
                                              } in  g_sbLsn sat_sbLst;
                                    } in 
                                      GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbLsu;
                          } in  : [GHC.Show.$fShow(,)4 sat_sbLsv];
                } in  sat_sbLsw;
          };

Data.Functor.Identity.$fShowIdentity_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Functor.Identity.Identity a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbLsx w1_sbLsy w2_sbLsz]
        case w1_sbLsy of {
          GHC.Types.I# ww1_sbLsB [Occ=Once] ->
              Data.Functor.Identity.$w$cshowsPrec w_sbLsx ww1_sbLsB w2_sbLsz;
        };

Data.Functor.Identity.$fShowIdentity_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Identity.Identity a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbLsC x_sbLsD]
        let {
          sat_sbLsE [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sbLsC x_sbLsD] \s []
                  GHC.Show.showsPrec
                      $dShow_sbLsC
                      Data.Functor.Identity.$fReadIdentity4
                      x_sbLsD
                      GHC.Types.[];
        } in  GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbLsE;

Data.Functor.Identity.$fShowIdentity_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Functor.Identity.Identity a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbLsF ls_sbLsG s_sbLsH]
        let {
          sat_sbLsJ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abJ0D -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbLsF] \r [w_sbLsI]
                  Data.Functor.Identity.$w$cshowsPrec $dShow_sbLsF 0# w_sbLsI;
        } in  GHC.Show.showList__ sat_sbLsJ ls_sbLsG s_sbLsH;

Data.Functor.Identity.$fShowIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sbLsK]
        let {
          sat_sbLsN [Occ=Once]
            :: [Data.Functor.Identity.Identity a_abJ0D] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbLsK] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshowList
                      $dShow_sbLsK eta_B2 eta_B1; } in
        let {
          sat_sbLsM [Occ=Once]
            :: Data.Functor.Identity.Identity a_abJ0D -> GHC.Base.String
          [LclId] =
              [$dShow_sbLsK] \r [eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshow
                      $dShow_sbLsK eta_B1; } in
        let {
          sat_sbLsL [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abJ0D -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbLsK] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshowsPrec
                      $dShow_sbLsK eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sbLsL sat_sbLsM sat_sbLsN];

Data.Functor.Identity.$fFoldableIdentity4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Functor.Identity.$fFoldableIdentity_$clength
  :: forall a. Data.Functor.Identity.Identity a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sbLsO] Data.Functor.Identity.$fFoldableIdentity4;

Data.Functor.Identity.$fFoldableIdentity_$cnull
  :: forall a. Data.Functor.Identity.Identity a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbLsP] GHC.Types.False [];

Data.Functor.Identity.$fFoldableIdentity_$ctoList
  :: forall a. Data.Functor.Identity.Identity a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_sbLsQ] : [ds_sbLsQ GHC.Types.[]];

Data.Functor.Identity.$fFoldableIdentity6
  :: forall b a. (b -> a -> b) -> b -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbLsR] v_sbLsR;

Data.Functor.Identity.$fFoldableIdentity_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Functor.Identity.Identity a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sbLsS z_sbLsT ds_sbLsU] f_sbLsS ds_sbLsU z_sbLsT;

Data.Functor.Identity.$fFoldableIdentity7
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> a -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sbLsV v_sbLsW] v_sbLsW;

Data.Functor.Identity.$fFunctorIdentity2
  :: forall a b. (a -> b) -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbLsX] v_sbLsX;

Data.Functor.Identity.$fFunctorIdentity1 :: forall b a. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sbLsY ds_sbLsZ] x_sbLsY;

Data.Functor.Identity.$fFunctorIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Identity.$fFunctorIdentity2
                                       Data.Functor.Identity.$fFunctorIdentity1];

Data.Functor.Identity.$fApplicativeIdentity1
  :: forall a b c. (a -> b -> c) -> a -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbLt0] v_sbLt0;

Data.Functor.Identity.$fApplicativeIdentity2
  :: forall a b.
     Data.Functor.Identity.Identity (a -> b)
     -> Data.Functor.Identity.Identity (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbLt1] v_sbLt1;

Data.Functor.Identity.$fApplicativeIdentity3 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbLt2] v_sbLt2;

Data.Functor.Identity.$fApplicativeIdentity_$c*>
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sbLt3 a2_sbLt4] a2_sbLt4;

Data.Functor.Identity.$fApplicativeIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Identity.$fFunctorIdentity
                                           Data.Functor.Identity.$fApplicativeIdentity3
                                           Data.Functor.Identity.$fApplicativeIdentity2
                                           Data.Functor.Identity.$fApplicativeIdentity1
                                           Data.Functor.Identity.$fApplicativeIdentity_$c*>
                                           GHC.Base.const];

Data.Functor.Identity.$fStorableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Foreign.Storable.Storable a =>
     Foreign.Storable.Storable (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dStorable_sbLt5]
        let {
          sat_sbLtd [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> Data.Functor.Identity.Identity a_abITC -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.poke $dStorable_sbLt5; } in
        let {
          sat_sbLtc [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.peek $dStorable_sbLt5; } in
        let {
          sat_sbLtb [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abITC
               -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.pokeByteOff $dStorable_sbLt5; } in
        let {
          sat_sbLta [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.peekByteOff $dStorable_sbLt5; } in
        let {
          sat_sbLt9 [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abITC
               -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.pokeElemOff $dStorable_sbLt5; } in
        let {
          sat_sbLt8 [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.Int
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.peekElemOff $dStorable_sbLt5; } in
        let {
          sat_sbLt7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abITC -> GHC.Types.Int
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.alignment $dStorable_sbLt5; } in
        let {
          sat_sbLt6 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abITC -> GHC.Types.Int
          [LclId] =
              [$dStorable_sbLt5] \u [] Foreign.Storable.sizeOf $dStorable_sbLt5;
        } in 
          Foreign.Storable.C:Storable [sat_sbLt6
                                       sat_sbLt7
                                       sat_sbLt8
                                       sat_sbLt9
                                       sat_sbLta
                                       sat_sbLtb
                                       sat_sbLtc
                                       sat_sbLtd];

Data.Functor.Identity.$fNumIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_sbLte]
        let {
          sat_sbLtl [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.fromInteger $dNum_sbLte; } in
        let {
          sat_sbLtk [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.signum $dNum_sbLte; } in
        let {
          sat_sbLtj [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.abs $dNum_sbLte; } in
        let {
          sat_sbLti [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.negate $dNum_sbLte; } in
        let {
          sat_sbLth [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.* $dNum_sbLte; } in
        let {
          sat_sbLtg [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.- $dNum_sbLte; } in
        let {
          sat_sbLtf [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.+ $dNum_sbLte;
        } in 
          GHC.Num.C:Num [sat_sbLtf
                         sat_sbLtg
                         sat_sbLth
                         sat_sbLti
                         sat_sbLtj
                         sat_sbLtk
                         sat_sbLtl];

Data.Functor.Identity.$fRealIdentity_$cp1Real
  :: forall a.
     GHC.Real.Real a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dReal_sbLtm]
        let {
          sat_sbLtn [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Num.Num a_abIOf
          [LclId] =
              [$dReal_sbLtm] \u [] GHC.Real.$p1Real $dReal_sbLtm;
        } in  Data.Functor.Identity.$fNumIdentity sat_sbLtn;

Data.Functor.Identity.$fSemigroupIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U,1*U)>m] =
    [] \r [$dSemigroup_sbLto]
        let {
          sat_sbLtr [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbLto] \u [] GHC.Base.stimes $dSemigroup_sbLto; } in
        let {
          sat_sbLtq [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Identity.Identity a_abIJk)
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbLto] \u [] GHC.Base.sconcat $dSemigroup_sbLto; } in
        let {
          sat_sbLtp [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbLto] \u [] GHC.Base.<> $dSemigroup_sbLto;
        } in  GHC.Base.C:Semigroup [sat_sbLtp sat_sbLtq sat_sbLtr];

Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sbLts]
        let {
          sat_sbLtt [Occ=Once, Dmd=<L,U(1*U,1*U,1*U)>]
            :: GHC.Base.Semigroup a_abIKg
          [LclId] =
              [$dMonoid_sbLts] \u [] GHC.Base.$p1Monoid $dMonoid_sbLts;
        } in  Data.Functor.Identity.$fSemigroupIdentity sat_sbLtt;

Data.Functor.Identity.$fMonoidIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dMonoid_sbLtu]
        let {
          sat_sbLty [Occ=Once]
            :: [Data.Functor.Identity.Identity a_abIKg]
               -> Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbLtu] \u [] GHC.Base.mconcat $dMonoid_sbLtu; } in
        let {
          sat_sbLtx [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKg
               -> Data.Functor.Identity.Identity a_abIKg
               -> Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbLtu] \u [] GHC.Base.mappend $dMonoid_sbLtu; } in
        let {
          sat_sbLtw [Occ=Once] :: Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbLtu] \u [] GHC.Base.mempty $dMonoid_sbLtu; } in
        let {
          sat_sbLtv [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Identity.Identity a_abIKg)
          [LclId] =
              [$dMonoid_sbLtu] \u []
                  Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid $dMonoid_sbLtu;
        } in  GHC.Base.C:Monoid [sat_sbLtv sat_sbLtw sat_sbLtx sat_sbLty];

Data.Functor.Identity.$fGeneric1Identity1
  :: forall a.
     GHC.Generics.Rep1 Data.Functor.Identity.Identity a
     -> GHC.Generics.Rep1 Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbLtz] ds_sbLtz;

Data.Functor.Identity.$fFoldableIdentity2
  :: forall a.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbLtA] x_sbLtA;

Data.Functor.Identity.$fGeneric1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Identity.$fFoldableIdentity2
                                            Data.Functor.Identity.$fGeneric1Identity1];

Data.Functor.Identity.$fGenericIdentity1
  :: forall a x.
     GHC.Generics.Rep (Data.Functor.Identity.Identity a) x
     -> GHC.Generics.Rep (Data.Functor.Identity.Identity a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbLtB] ds_sbLtB;

Data.Functor.Identity.$fGenericIdentity2
  :: forall a x.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbLtC] x1_sbLtC;

Data.Functor.Identity.$fGenericIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Generics.Generic (Data.Functor.Identity.Identity a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Identity.$fGenericIdentity2
                                           Data.Functor.Identity.$fGenericIdentity1];

Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
  :: forall a.
     GHC.Real.Fractional a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFractional_sbLtD]
        let {
          sat_sbLtE [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Num.Num a_abIDx
          [LclId] =
              [$dFractional_sbLtD] \u []
                  GHC.Real.$p1Fractional $dFractional_sbLtD;
        } in  Data.Functor.Identity.$fNumIdentity sat_sbLtE;

Data.Functor.Identity.$fFractionalIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Fractional a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dFractional_sbLtF]
        let {
          sat_sbLtJ [Occ=Once]
            :: GHC.Real.Rational -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbLtF] \u []
                  GHC.Real.fromRational $dFractional_sbLtF; } in
        let {
          sat_sbLtI [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbLtF] \u [] GHC.Real.recip $dFractional_sbLtF; } in
        let {
          sat_sbLtH [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbLtF] \u [] GHC.Real./ $dFractional_sbLtF; } in
        let {
          sat_sbLtG [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Identity.Identity a_abIDx)
          [LclId] =
              [$dFractional_sbLtF] \u []
                  Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
                      $dFractional_sbLtF;
        } in 
          GHC.Real.C:Fractional [sat_sbLtG sat_sbLtH sat_sbLtI sat_sbLtJ];

Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_sbLtK]
        let {
          sat_sbLtL [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>]
            :: GHC.Real.Fractional a_abIOC
          [LclId] =
              [$dRealFrac_sbLtK] \u [] GHC.Real.$p2RealFrac $dRealFrac_sbLtK;
        } in  Data.Functor.Identity.$fFractionalIdentity sat_sbLtL;

Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
  :: forall a.
     GHC.Float.Floating a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sbLtM]
        let {
          sat_sbLtN [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>]
            :: GHC.Real.Fractional a_abIzr
          [LclId] =
              [$dFloating_sbLtM] \u [] GHC.Float.$p1Floating $dFloating_sbLtM;
        } in  Data.Functor.Identity.$fFractionalIdentity sat_sbLtN;

Data.Functor.Identity.$fFloatingIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.Floating a =>
     GHC.Float.Floating (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dFloating_sbLtO]
        let {
          sat_sbLub [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.log1mexp $dFloating_sbLtO; } in
        let {
          sat_sbLua [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.log1pexp $dFloating_sbLtO; } in
        let {
          sat_sbLu9 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.expm1 $dFloating_sbLtO; } in
        let {
          sat_sbLu8 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.log1p $dFloating_sbLtO; } in
        let {
          sat_sbLu7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.atanh $dFloating_sbLtO; } in
        let {
          sat_sbLu6 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.acosh $dFloating_sbLtO; } in
        let {
          sat_sbLu5 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.asinh $dFloating_sbLtO; } in
        let {
          sat_sbLu4 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.tanh $dFloating_sbLtO; } in
        let {
          sat_sbLu3 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.cosh $dFloating_sbLtO; } in
        let {
          sat_sbLu2 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.sinh $dFloating_sbLtO; } in
        let {
          sat_sbLu1 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.atan $dFloating_sbLtO; } in
        let {
          sat_sbLu0 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.acos $dFloating_sbLtO; } in
        let {
          sat_sbLtZ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.asin $dFloating_sbLtO; } in
        let {
          sat_sbLtY [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.tan $dFloating_sbLtO; } in
        let {
          sat_sbLtX [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.cos $dFloating_sbLtO; } in
        let {
          sat_sbLtW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.sin $dFloating_sbLtO; } in
        let {
          sat_sbLtV [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.logBase $dFloating_sbLtO; } in
        let {
          sat_sbLtU [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.** $dFloating_sbLtO; } in
        let {
          sat_sbLtT [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.sqrt $dFloating_sbLtO; } in
        let {
          sat_sbLtS [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.log $dFloating_sbLtO; } in
        let {
          sat_sbLtR [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.exp $dFloating_sbLtO; } in
        let {
          sat_sbLtQ [Occ=Once] :: Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.pi $dFloating_sbLtO; } in
        let {
          sat_sbLtP [Occ=Once]
            :: GHC.Real.Fractional (Data.Functor.Identity.Identity a_abIzr)
          [LclId] =
              [$dFloating_sbLtO] \u []
                  Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
                      $dFloating_sbLtO;
        } in 
          GHC.Float.C:Floating [sat_sbLtP
                                sat_sbLtQ
                                sat_sbLtR
                                sat_sbLtS
                                sat_sbLtT
                                sat_sbLtU
                                sat_sbLtV
                                sat_sbLtW
                                sat_sbLtX
                                sat_sbLtY
                                sat_sbLtZ
                                sat_sbLu0
                                sat_sbLu1
                                sat_sbLu2
                                sat_sbLu3
                                sat_sbLu4
                                sat_sbLu5
                                sat_sbLu6
                                sat_sbLu7
                                sat_sbLu8
                                sat_sbLu9
                                sat_sbLua
                                sat_sbLub];

Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.Floating (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sbLuc]
        let {
          sat_sbLud [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Float.Floating a_abIQK
          [LclId] =
              [$dRealFloat_sbLuc] \u [] GHC.Float.$p2RealFloat $dRealFloat_sbLuc;
        } in  Data.Functor.Identity.$fFloatingIdentity sat_sbLud;

Data.Functor.Identity.$fEqIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sbLue]
        let {
          sat_sbLug [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIye
               -> Data.Functor.Identity.Identity a_abIye -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbLue] \u [] GHC.Classes./= $dEq_sbLue; } in
        let {
          sat_sbLuf [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIye
               -> Data.Functor.Identity.Identity a_abIye -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbLue] \u [] GHC.Classes.== $dEq_sbLue;
        } in  GHC.Classes.C:Eq [sat_sbLuf sat_sbLug];

Data.Functor.Identity.$fOrdIdentity_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sbLuh]
        let {
          sat_sbLui [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_abIMq
          [LclId] =
              [$dOrd_sbLuh] \u [] GHC.Classes.$p1Ord $dOrd_sbLuh;
        } in  Data.Functor.Identity.$fEqIdentity sat_sbLui;

Data.Functor.Identity.$fOrdIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sbLuj]
        let {
          sat_sbLur [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.min $dOrd_sbLuj; } in
        let {
          sat_sbLuq [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.max $dOrd_sbLuj; } in
        let {
          sat_sbLup [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.>= $dOrd_sbLuj; } in
        let {
          sat_sbLuo [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.> $dOrd_sbLuj; } in
        let {
          sat_sbLun [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.<= $dOrd_sbLuj; } in
        let {
          sat_sbLum [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.< $dOrd_sbLuj; } in
        let {
          sat_sbLul [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.compare $dOrd_sbLuj; } in
        let {
          sat_sbLuk [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Identity.Identity a_abIMq)
          [LclId] =
              [$dOrd_sbLuj] \u []
                  Data.Functor.Identity.$fOrdIdentity_$cp1Ord $dOrd_sbLuj;
        } in 
          GHC.Classes.C:Ord [sat_sbLuk
                             sat_sbLul
                             sat_sbLum
                             sat_sbLun
                             sat_sbLuo
                             sat_sbLup
                             sat_sbLuq
                             sat_sbLur];

Data.Functor.Identity.$fIxIdentity_$cp1Ix
  :: forall a.
     GHC.Arr.Ix a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIx_sbLus]
        let {
          sat_sbLut [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Classes.Ord a_abIHW
          [LclId] =
              [$dIx_sbLus] \u [] GHC.Arr.$p1Ix $dIx_sbLus;
        } in  Data.Functor.Identity.$fOrdIdentity sat_sbLut;

Data.Functor.Identity.$fIxIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Arr.Ix a =>
     GHC.Arr.Ix (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dIx_sbLuu]
        let {
          sat_sbLuB [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> GHC.Types.Int
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.unsafeRangeSize $dIx_sbLuu; } in
        let {
          sat_sbLuA [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> GHC.Types.Int
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.rangeSize $dIx_sbLuu; } in
        let {
          sat_sbLuz [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Bool
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.inRange $dIx_sbLuu; } in
        let {
          sat_sbLuy [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Int
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.unsafeIndex $dIx_sbLuu; } in
        let {
          sat_sbLux [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Int
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.index $dIx_sbLuu; } in
        let {
          sat_sbLuw [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> [Data.Functor.Identity.Identity a_abIHW]
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.range $dIx_sbLuu; } in
        let {
          sat_sbLuv [Occ=Once]
            :: GHC.Classes.Ord (Data.Functor.Identity.Identity a_abIHW)
          [LclId] =
              [$dIx_sbLuu] \u []
                  Data.Functor.Identity.$fIxIdentity_$cp1Ix $dIx_sbLuu;
        } in 
          GHC.Arr.C:Ix [sat_sbLuv
                        sat_sbLuw
                        sat_sbLux
                        sat_sbLuy
                        sat_sbLuz
                        sat_sbLuA
                        sat_sbLuB];

Data.Functor.Identity.$fRealIdentity_$cp2Real
  :: forall a.
     GHC.Real.Real a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),A)>m,
 Unf=OtherCon []] =
    [] \r [$dReal_sbLuC]
        let {
          sat_sbLuD [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Classes.Ord a_abIOf
          [LclId] =
              [$dReal_sbLuC] \u [] GHC.Real.$p2Real $dReal_sbLuC;
        } in  Data.Functor.Identity.$fOrdIdentity sat_sbLuD;

Data.Functor.Identity.$fRealIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Real a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>m] =
    [] \r [$dReal_sbLuE]
        let {
          sat_sbLuH [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIOf -> GHC.Real.Rational
          [LclId] =
              [$dReal_sbLuE] \u [] GHC.Real.toRational $dReal_sbLuE; } in
        let {
          sat_sbLuG [Occ=Once]
            :: GHC.Classes.Ord (Data.Functor.Identity.Identity a_abIOf)
          [LclId] =
              [$dReal_sbLuE] \u []
                  Data.Functor.Identity.$fRealIdentity_$cp2Real $dReal_sbLuE; } in
        let {
          sat_sbLuF [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Identity.Identity a_abIOf)
          [LclId] =
              [$dReal_sbLuE] \u []
                  Data.Functor.Identity.$fRealIdentity_$cp1Real $dReal_sbLuE;
        } in  GHC.Real.C:Real [sat_sbLuF sat_sbLuG sat_sbLuH];

Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sbLuI]
        let {
          sat_sbLuJ [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>]
            :: GHC.Real.Real a_abIG7
          [LclId] =
              [$dIntegral_sbLuI] \u [] GHC.Real.$p1Integral $dIntegral_sbLuI;
        } in  Data.Functor.Identity.$fRealIdentity sat_sbLuJ;

Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_sbLuK]
        let {
          sat_sbLuL [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>]
            :: GHC.Real.Real a_abIOC
          [LclId] =
              [$dRealFrac_sbLuK] \u [] GHC.Real.$p1RealFrac $dRealFrac_sbLuK;
        } in  Data.Functor.Identity.$fRealIdentity sat_sbLuL;

Data.Functor.Identity.$fRealFracIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dRealFrac_sbLuM]
        let {
          sat_sbLuT [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbLuM] \u [] GHC.Real.floor $dRealFrac_sbLuM; } in
        let {
          sat_sbLuS [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbLuM] \u [] GHC.Real.ceiling $dRealFrac_sbLuM; } in
        let {
          sat_sbLuR [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbLuM] \u [] GHC.Real.round $dRealFrac_sbLuM; } in
        let {
          sat_sbLuQ [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbLuM] \u [] GHC.Real.truncate $dRealFrac_sbLuM; } in
        let {
          sat_sbLuP [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC
               -> (b, Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbLuM] \u []
                  GHC.Real.properFraction $dRealFrac_sbLuM; } in
        let {
          sat_sbLuO [Occ=Once]
            :: GHC.Real.Fractional (Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbLuM] \u []
                  Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
                      $dRealFrac_sbLuM; } in
        let {
          sat_sbLuN [Occ=Once]
            :: GHC.Real.Real (Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbLuM] \u []
                  Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
                      $dRealFrac_sbLuM;
        } in 
          GHC.Real.C:RealFrac [sat_sbLuN
                               sat_sbLuO
                               sat_sbLuP
                               sat_sbLuQ
                               sat_sbLuR
                               sat_sbLuS
                               sat_sbLuT];

Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sbLuU]
        let {
          sat_sbLuV [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Real.RealFrac a_abIQK
          [LclId] =
              [$dRealFloat_sbLuU] \u [] GHC.Float.$p1RealFloat $dRealFloat_sbLuU;
        } in  Data.Functor.Identity.$fRealFracIdentity sat_sbLuV;

Data.Functor.Identity.$fRealFloatIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.RealFloat (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dRealFloat_sbLuW]
        let {
          sat_sbLvc [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbLuW] \u [] GHC.Float.atan2 $dRealFloat_sbLuW; } in
        let {
          sat_sbLvb [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbLuW] \u [] GHC.Float.isIEEE $dRealFloat_sbLuW; } in
        let {
          sat_sbLva [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.isNegativeZero $dRealFloat_sbLuW; } in
        let {
          sat_sbLv9 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.isDenormalized $dRealFloat_sbLuW; } in
        let {
          sat_sbLv8 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.isInfinite $dRealFloat_sbLuW; } in
        let {
          sat_sbLv7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbLuW] \u [] GHC.Float.isNaN $dRealFloat_sbLuW; } in
        let {
          sat_sbLv6 [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.scaleFloat $dRealFloat_sbLuW; } in
        let {
          sat_sbLv5 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.significand $dRealFloat_sbLuW; } in
        let {
          sat_sbLv4 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Int
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.exponent $dRealFloat_sbLuW; } in
        let {
          sat_sbLv3 [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.encodeFloat $dRealFloat_sbLuW; } in
        let {
          sat_sbLv2 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> (GHC.Integer.Type.Integer, GHC.Types.Int)
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.decodeFloat $dRealFloat_sbLuW; } in
        let {
          sat_sbLv1 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> (GHC.Types.Int, GHC.Types.Int)
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.floatRange $dRealFloat_sbLuW; } in
        let {
          sat_sbLv0 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Int
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.floatDigits $dRealFloat_sbLuW; } in
        let {
          sat_sbLuZ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> GHC.Integer.Type.Integer
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.floatRadix $dRealFloat_sbLuW; } in
        let {
          sat_sbLuY [Occ=Once]
            :: GHC.Float.Floating (Data.Functor.Identity.Identity a_abIQK)
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
                      $dRealFloat_sbLuW; } in
        let {
          sat_sbLuX [Occ=Once]
            :: GHC.Real.RealFrac (Data.Functor.Identity.Identity a_abIQK)
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
                      $dRealFloat_sbLuW;
        } in 
          GHC.Float.C:RealFloat [sat_sbLuX
                                 sat_sbLuY
                                 sat_sbLuZ
                                 sat_sbLv0
                                 sat_sbLv1
                                 sat_sbLv2
                                 sat_sbLv3
                                 sat_sbLv4
                                 sat_sbLv5
                                 sat_sbLv6
                                 sat_sbLv7
                                 sat_sbLv8
                                 sat_sbLv9
                                 sat_sbLva
                                 sat_sbLvb
                                 sat_sbLvc];

Data.Functor.Identity.$fEnumIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dEnum_sbLvd]
        let {
          sat_sbLvl [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.enumFromThenTo $dEnum_sbLvd; } in
        let {
          sat_sbLvk [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.enumFromTo $dEnum_sbLvd; } in
        let {
          sat_sbLvj [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.enumFromThen $dEnum_sbLvd; } in
        let {
          sat_sbLvi [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.enumFrom $dEnum_sbLvd; } in
        let {
          sat_sbLvh [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu -> GHC.Types.Int
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.fromEnum $dEnum_sbLvd; } in
        let {
          sat_sbLvg [Occ=Once]
            :: GHC.Types.Int -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.toEnum $dEnum_sbLvd; } in
        let {
          sat_sbLvf [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.pred $dEnum_sbLvd; } in
        let {
          sat_sbLve [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.succ $dEnum_sbLvd;
        } in 
          GHC.Enum.C:Enum [sat_sbLve
                           sat_sbLvf
                           sat_sbLvg
                           sat_sbLvh
                           sat_sbLvi
                           sat_sbLvj
                           sat_sbLvk
                           sat_sbLvl];

Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Enum.Enum (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sbLvm]
        let {
          sat_sbLvn [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Enum.Enum a_abIG7
          [LclId] =
              [$dIntegral_sbLvm] \u [] GHC.Real.$p2Integral $dIntegral_sbLvm;
        } in  Data.Functor.Identity.$fEnumIdentity sat_sbLvn;

Data.Functor.Identity.$fIntegralIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Integral (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dIntegral_sbLvo]
        let {
          sat_sbLvx [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> GHC.Integer.Type.Integer
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.toInteger $dIntegral_sbLvo; } in
        let {
          sat_sbLvw [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> (Data.Functor.Identity.Identity a_abIG7,
                   Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.divMod $dIntegral_sbLvo; } in
        let {
          sat_sbLvv [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> (Data.Functor.Identity.Identity a_abIG7,
                   Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.quotRem $dIntegral_sbLvo; } in
        let {
          sat_sbLvu [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.mod $dIntegral_sbLvo; } in
        let {
          sat_sbLvt [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.div $dIntegral_sbLvo; } in
        let {
          sat_sbLvs [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.rem $dIntegral_sbLvo; } in
        let {
          sat_sbLvr [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.quot $dIntegral_sbLvo; } in
        let {
          sat_sbLvq [Occ=Once]
            :: GHC.Enum.Enum (Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbLvo] \u []
                  Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
                      $dIntegral_sbLvo; } in
        let {
          sat_sbLvp [Occ=Once]
            :: GHC.Real.Real (Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbLvo] \u []
                  Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
                      $dIntegral_sbLvo;
        } in 
          GHC.Real.C:Integral [sat_sbLvp
                               sat_sbLvq
                               sat_sbLvr
                               sat_sbLvs
                               sat_sbLvt
                               sat_sbLvu
                               sat_sbLvv
                               sat_sbLvw
                               sat_sbLvx];

Data.Functor.Identity.$fBoundedIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sbLvy]
        let {
          sat_sbLvA [Occ=Once] :: Data.Functor.Identity.Identity a_abIwc
          [LclId] =
              [$dBounded_sbLvy] \u [] GHC.Enum.maxBound $dBounded_sbLvy; } in
        let {
          sat_sbLvz [Occ=Once] :: Data.Functor.Identity.Identity a_abIwc
          [LclId] =
              [$dBounded_sbLvy] \u [] GHC.Enum.minBound $dBounded_sbLvy;
        } in  GHC.Enum.C:Bounded [sat_sbLvz sat_sbLvA];

Data.Functor.Identity.$fBitsIdentity_$cp1Bits
  :: forall a.
     Data.Bits.Bits a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dBits_sbLvB]
        let {
          sat_sbLvC [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_abIrg
          [LclId] =
              [$dBits_sbLvB] \u [] Data.Bits.$p1Bits $dBits_sbLvB;
        } in  Data.Functor.Identity.$fEqIdentity sat_sbLvC;

Data.Functor.Identity.$fBitsIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Bits.Bits a =>
     Data.Bits.Bits (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dBits_sbLvD]
        let {
          sat_sbLw0 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Int
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.popCount $dBits_sbLvD; } in
        let {
          sat_sbLvZ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.rotateR $dBits_sbLvD; } in
        let {
          sat_sbLvY [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.rotateL $dBits_sbLvD; } in
        let {
          sat_sbLvX [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.unsafeShiftR $dBits_sbLvD; } in
        let {
          sat_sbLvW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.shiftR $dBits_sbLvD; } in
        let {
          sat_sbLvV [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.unsafeShiftL $dBits_sbLvD; } in
        let {
          sat_sbLvU [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.shiftL $dBits_sbLvD; } in
        let {
          sat_sbLvT [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Bool
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.isSigned $dBits_sbLvD; } in
        let {
          sat_sbLvS [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Int
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.bitSize $dBits_sbLvD; } in
        let {
          sat_sbLvR [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Base.Maybe GHC.Types.Int
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.bitSizeMaybe $dBits_sbLvD; } in
        let {
          sat_sbLvQ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> GHC.Types.Bool
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.testBit $dBits_sbLvD; } in
        let {
          sat_sbLvP [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.complementBit $dBits_sbLvD; } in
        let {
          sat_sbLvO [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.clearBit $dBits_sbLvD; } in
        let {
          sat_sbLvN [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.setBit $dBits_sbLvD; } in
        let {
          sat_sbLvM [Occ=Once]
            :: GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.bit $dBits_sbLvD; } in
        let {
          sat_sbLvL [Occ=Once] :: Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.zeroBits $dBits_sbLvD; } in
        let {
          sat_sbLvK [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.rotate $dBits_sbLvD; } in
        let {
          sat_sbLvJ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.shift $dBits_sbLvD; } in
        let {
          sat_sbLvI [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.complement $dBits_sbLvD; } in
        let {
          sat_sbLvH [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.xor $dBits_sbLvD; } in
        let {
          sat_sbLvG [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits..|. $dBits_sbLvD; } in
        let {
          sat_sbLvF [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits..&. $dBits_sbLvD; } in
        let {
          sat_sbLvE [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Identity.Identity a_abIrg)
          [LclId] =
              [$dBits_sbLvD] \u []
                  Data.Functor.Identity.$fBitsIdentity_$cp1Bits $dBits_sbLvD;
        } in 
          Data.Bits.C:Bits [sat_sbLvE
                            sat_sbLvF
                            sat_sbLvG
                            sat_sbLvH
                            sat_sbLvI
                            sat_sbLvJ
                            sat_sbLvK
                            sat_sbLvL
                            sat_sbLvM
                            sat_sbLvN
                            sat_sbLvO
                            sat_sbLvP
                            sat_sbLvQ
                            sat_sbLvR
                            sat_sbLvS
                            sat_sbLvT
                            sat_sbLvU
                            sat_sbLvV
                            sat_sbLvW
                            sat_sbLvX
                            sat_sbLvY
                            sat_sbLvZ
                            sat_sbLw0];

Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
  :: forall a.
     Data.Bits.FiniteBits a =>
     Data.Bits.Bits (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_sbLw1]
        let {
          sat_sbLw2 [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: Data.Bits.Bits a_abIyM
          [LclId] =
              [$dFiniteBits_sbLw1] \u []
                  Data.Bits.$p1FiniteBits $dFiniteBits_sbLw1;
        } in  Data.Functor.Identity.$fBitsIdentity sat_sbLw2;

Data.Functor.Identity.$fFiniteBitsIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Bits.FiniteBits a =>
     Data.Bits.FiniteBits (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dFiniteBits_sbLw3]
        let {
          sat_sbLw7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbLw3] \u []
                  Data.Bits.countTrailingZeros $dFiniteBits_sbLw3; } in
        let {
          sat_sbLw6 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbLw3] \u []
                  Data.Bits.countLeadingZeros $dFiniteBits_sbLw3; } in
        let {
          sat_sbLw5 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbLw3] \u []
                  Data.Bits.finiteBitSize $dFiniteBits_sbLw3; } in
        let {
          sat_sbLw4 [Occ=Once]
            :: Data.Bits.Bits (Data.Functor.Identity.Identity a_abIyM)
          [LclId] =
              [$dFiniteBits_sbLw3] \u []
                  Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
                      $dFiniteBits_sbLw3;
        } in 
          Data.Bits.C:FiniteBits [sat_sbLw4 sat_sbLw5 sat_sbLw6 sat_sbLw7];

Data.Functor.Identity.runIdentity
  :: forall a. Data.Functor.Identity.Identity a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fMonadFixIdentity_$cmfix
  :: forall a.
     (a -> Data.Functor.Identity.Identity a)
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sbLw8]
        let {
          x_sbLw9 [Occ=LoopBreaker] :: Data.Functor.Identity.Identity a_abIVT
          [LclId] =
              [f_sbLw8 x_sbLw9] \u [] f_sbLw8 x_sbLw9;
        } in  x_sbLw9;

Data.Functor.Identity.$fMonadIdentity_$c>>=
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> (a -> Data.Functor.Identity.Identity b)
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_sbLwa k_sbLwb] k_sbLwb m_sbLwa;

Data.Functor.Identity.$fMonadIdentity_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Functor.Identity.$fApplicativeIdentity_$c*> eta_B2 eta_B1;

lvl_rbJt6
  :: forall a. [GHC.Types.Char] -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sbLwc] GHC.Err.errorWithoutStackTrace eta_sbLwc;

Data.Functor.Identity.$fMonadIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Functor.Identity.$fApplicativeIdentity
                                     Data.Functor.Identity.$fMonadIdentity_$c>>=
                                     Data.Functor.Identity.$fMonadIdentity_$c>>
                                     Data.Functor.Identity.$fApplicativeIdentity3
                                     lvl_rbJt6];

Data.Functor.Identity.$fMonadFixIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Functor.Identity.$fMonadIdentity
                                                 Data.Functor.Identity.$fMonadFixIdentity_$cmfix];

Data.Functor.Identity.$fFoldableIdentity5
  :: forall a.
     (a -> a -> a)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbLwd eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity3
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sbLwe eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity1
  :: forall a.
     GHC.Num.Num a =>
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_sbLwf eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity8
  :: forall m. GHC.Base.Monoid m => m -> m
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dMonoid_sbLwg eta_B1] GHC.Base.id eta_B1;

Data.Functor.Identity.$fFoldableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Functor.Identity.$fFoldableIdentity8
                                             Data.Functor.Identity.$fFoldableIdentity7
                                             Data.Functor.Identity.$fFoldableIdentity_$cfoldr
                                             Data.Functor.Identity.$fFoldableIdentity_$cfoldr
                                             Data.Functor.Identity.$fFoldableIdentity6
                                             Data.Functor.Identity.$fFoldableIdentity6
                                             Data.Functor.Identity.$fFoldableIdentity5
                                             Data.Functor.Identity.$fFoldableIdentity5
                                             Data.Functor.Identity.$fFoldableIdentity_$ctoList
                                             Data.Functor.Identity.$fFoldableIdentity_$cnull
                                             Data.Functor.Identity.$fFoldableIdentity_$clength
                                             GHC.Classes.==
                                             Data.Functor.Identity.$fFoldableIdentity3
                                             Data.Functor.Identity.$fFoldableIdentity3
                                             Data.Functor.Identity.$fFoldableIdentity1
                                             Data.Functor.Identity.$fFoldableIdentity1];

Data.Functor.Identity.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Identity.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$trModule4];

Data.Functor.Identity.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Identity"#;

Data.Functor.Identity.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$trModule2];

Data.Functor.Identity.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Identity.$trModule3
                                     Data.Functor.Identity.$trModule1];

$krep_rbJt7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Functor.Identity.$tcIdentity1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$fReadIdentity6];

Data.Functor.Identity.$tcIdentity :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3410104521590905987##
                                    16392070908630191652##
                                    Data.Functor.Identity.$trModule
                                    Data.Functor.Identity.$tcIdentity1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep1_rbJt8 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rbJt7 GHC.Types.[]];

$krep2_rbJt9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Identity.$tcIdentity
                                              $krep1_rbJt8];

Data.Functor.Identity.$tc'Identity1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rbJt7 $krep2_rbJt9];

Data.Functor.Identity.$tc'Identity3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Identity"#;

Data.Functor.Identity.$tc'Identity2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$tc'Identity3];

Data.Functor.Identity.$tc'Identity :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11920310844698764515##
                                    3935129235072617509##
                                    Data.Functor.Identity.$trModule
                                    Data.Functor.Identity.$tc'Identity2
                                    1#
                                    Data.Functor.Identity.$tc'Identity1];


==================== STG syntax: ====================
2018-03-16 16:06:38.739251717 UTC

Data.Functor.Identity.$fReadIdentity4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Identity.$fReadIdentity6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity"#;

Data.Functor.Identity.$fReadIdentity5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Identity.$fReadIdentity6;

Data.Functor.Identity.$w$creadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Prim.Int#
     -> GHC.Base.String
     -> [(Data.Functor.Identity.Identity a, GHC.Base.String)]
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbLrm ww_sbLrn w1_sbLro]
        let {
          go_sbLrp [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(Data.Functor.Identity.Identity a_sbJqG, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sbLrm go_sbLrp] \r [ds_sbLrq]
                  case ds_sbLrq of {
                    [] -> [] [];
                    : y_sbLrs [Occ=Once!] ys_sbLrt [Occ=Once*] ->
                        case y_sbLrs of {
                          (,) ds1_sbLrv [Occ=Once] s_sbLrw [Occ=Once] ->
                              case
                                  GHC.Base.eqString ds1_sbLrv Data.Functor.Identity.$fReadIdentity5
                              of
                              { GHC.Types.False -> go_sbLrp ys_sbLrt;
                                GHC.Types.True ->
                                    let {
                                      z_sbLry [Occ=OnceL]
                                        :: [(Data.Functor.Identity.Identity a_sbJqG,
                                             GHC.Base.String)]
                                      [LclId] =
                                          [go_sbLrp ys_sbLrt] \u [] go_sbLrp ys_sbLrt; } in
                                    let {
                                      go1_sbLrz [Occ=LoopBreaker]
                                        :: [(a_sbJqG, GHC.Base.String)]
                                           -> [(Data.Functor.Identity.Identity a_sbJqG,
                                                GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [z_sbLry go1_sbLrz] \r [ds2_sbLrA]
                                              case ds2_sbLrA of {
                                                [] -> z_sbLry;
                                                : y1_sbLrC [Occ=Once!] ys1_sbLrD [Occ=Once] ->
                                                    case y1_sbLrC of {
                                                      (,) x_sbLrF [Occ=Once] t_sbLrG [Occ=Once] ->
                                                          let {
                                                            sat_sbLrI [Occ=Once]
                                                              :: [(Data.Functor.Identity.Identity
                                                                     a_sbJqG,
                                                                   GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sbLrz ys1_sbLrD] \u []
                                                                    go1_sbLrz ys1_sbLrD;
                                                          } in  : [wild4_sbLrE sat_sbLrI];
                                                    };
                                              };
                                    } in 
                                      case
                                          GHC.Read.readsPrec
                                              w_sbLrm Data.Functor.Identity.$fReadIdentity4 s_sbLrw
                                      of
                                      sat_sbLrJ
                                      { __DEFAULT -> go1_sbLrz sat_sbLrJ;
                                      };
                              };
                        };
                  }; } in
        let {
          sat_sbLrO [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 (Data.Functor.Identity.Identity a_sbJqG)
          [LclId] =
              [go_sbLrp] \r [r_sbLrM]
                  case
                      Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_sbLrM
                  of
                  sat_sbLrN
                  { __DEFAULT -> go_sbLrp sat_sbLrN;
                  };
        } in 
          case ># [ww_sbLrn 10#] of sat_sbLrK {
            __DEFAULT ->
                case tagToEnum# [sat_sbLrK] of sat_sbLrL {
                  __DEFAULT -> GHC.Read.readParen sat_sbLrL sat_sbLrO w1_sbLro;
                };
          };

Data.Functor.Identity.$fReadIdentity_$creadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbLrP w1_sbLrQ w2_sbLrR]
        case w1_sbLrQ of {
          GHC.Types.I# ww1_sbLrT [Occ=Once] ->
              Data.Functor.Identity.$w$creadsPrec w_sbLrP ww1_sbLrT w2_sbLrR;
        };

Data.Functor.Identity.$fReadIdentity3
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(C(C1(U)),A,A,A)><L,U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [$dRead_sbLrU n_sbLrV eta_sbLrW]
        let {
          sat_sbLrX [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 (Data.Functor.Identity.Identity a_abJ16)
          [LclId] =
              [$dRead_sbLrU n_sbLrV] \r [eta_B1]
                  Data.Functor.Identity.$fReadIdentity_$creadsPrec
                      $dRead_sbLrU n_sbLrV eta_B1;
        } in 
          case
              Text.ParserCombinators.ReadP.$wreadS_to_P sat_sbLrX eta_sbLrW
          of
          { Unit# ww1_sbLrZ [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sbLrZ];
          };

Data.Functor.Identity.$fReadIdentity2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Identity.$fReadIdentity_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Identity.Identity a]
[GblId, Arity=1, Str=<L,U(C(C1(U)),A,A,A)>, Unf=OtherCon []] =
    [] \r [$dRead_sbLs0]
        let {
          sat_sbLs2 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_XbJ2M]
          [LclId] =
              [$dRead_sbLs0] \u []
                  let {
                    sat_sbLs1 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_XbJ2M)
                    [LclId] =
                        [$dRead_sbLs0] \r [eta_B2 eta_B1]
                            Data.Functor.Identity.$fReadIdentity3 $dRead_sbLs0 eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sbLs1
                        Data.Functor.Identity.$fReadIdentity2
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sbLs2;

Data.Functor.Identity.$w$creadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall b.
     ([Data.Functor.Identity.Identity a]
      -> Text.ParserCombinators.ReadP.P b)
     -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,U(C(C1(U)),A,A,A)>, Unf=OtherCon []] =
    [] \r [w_sbLs3]
        let {
          w1_sbLs4 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_sbJqP]
          [LclId] =
              [w_sbLs3] \u []
                  let {
                    sat_sbLs5
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sbJqP)
                    [LclId] =
                        [w_sbLs3] \r [eta_B2 eta_B1]
                            Data.Functor.Identity.$fReadIdentity3 w_sbLs3 eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sbLs5
                        Data.Functor.Identity.$fReadIdentity2
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          w2_sbLs6 [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Identity.Identity a_sbJqP]
          [LclId, Arity=1, Unf=OtherCon []] =
              [w1_sbLs4] \r [eta_B1]
                  Text.ParserCombinators.ReadP.run w1_sbLs4 eta_B1; } in
        let {
          sat_sbLsa [Occ=OnceT[0]]
            :: forall b.
               ([Data.Functor.Identity.Identity a_sbJqP]
                -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w2_sbLs6] \r [w3_sbLs7]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w2_sbLs6 w3_sbLs7
                  of
                  { Unit# ww1_sbLs9 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sbLs9];
                  };
        } in  sat_sbLsa;

Data.Functor.Identity.$fReadIdentity1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([Data.Functor.Identity.Identity a]
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,U(C(C1(U)),A,A,A)><L,A>, Unf=OtherCon []] =
    [] \r [w_sbLsb w1_sbLsc]
        Data.Functor.Identity.$w$creadListPrec w_sbLsb;

Data.Functor.Identity.$fReadIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,A,A)>m] =
    [] \r [$dRead_sbLsd]
        let {
          lvl1_sbLse [Occ=OnceL]
            :: forall b.
               ([Data.Functor.Identity.Identity a_XbJ2R]
                -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sbLsd] \u []
                  Data.Functor.Identity.$w$creadListPrec $dRead_sbLsd; } in
        let {
          sat_sbLsj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Identity.Identity a_XbJ2R]
          [LclId] =
              [lvl1_sbLse] \r [w_sbLsi] lvl1_sbLse; } in
        let {
          sat_sbLsh [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_XbJ2R)
          [LclId] =
              [$dRead_sbLsd] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fReadIdentity3
                      $dRead_sbLsd eta_B2 eta_B1; } in
        let {
          sat_sbLsg [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Identity.Identity a_XbJ2R]
          [LclId] =
              [$dRead_sbLsd] \u []
                  Data.Functor.Identity.$fReadIdentity_$creadList $dRead_sbLsd; } in
        let {
          sat_sbLsf [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Identity.Identity a_XbJ2R)
          [LclId] =
              [$dRead_sbLsd] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fReadIdentity_$creadsPrec
                      $dRead_sbLsd eta_B2 eta_B1;
        } in  GHC.Read.C:Read [sat_sbLsf sat_sbLsg sat_sbLsh sat_sbLsj];

Data.Functor.Identity.$fShowIdentity2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity "#;

Data.Functor.Identity.$fShowIdentity1 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Identity.$fShowIdentity2;

Data.Functor.Identity.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Functor.Identity.Identity a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbLsk ww_sbLsl w1_sbLsm]
        let {
          g_sbLsn [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sbLsk w1_sbLsm] \u []
                  GHC.Show.showsPrec
                      w_sbLsk Data.Functor.Identity.$fReadIdentity4 w1_sbLsm;
        } in 
          case ># [ww_sbLsl 10#] of {
            __DEFAULT ->
                let {
                  sat_sbLsr [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [g_sbLsn] \r [x_sbLsp]
                          let {
                            sat_sbLsq [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sbLsn x_sbLsp] \s [] g_sbLsn x_sbLsp;
                          } in  GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbLsq;
                } in  sat_sbLsr;
            1# ->
                let {
                  sat_sbLsw [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [g_sbLsn] \r [x_sbLss]
                          let {
                            sat_sbLsv [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sbLsn x_sbLss] \u []
                                    let {
                                      sat_sbLsu [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sbLsn x_sbLss] \s []
                                              let {
                                                sat_sbLst [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sbLss];
                                              } in  g_sbLsn sat_sbLst;
                                    } in 
                                      GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbLsu;
                          } in  : [GHC.Show.$fShow(,)4 sat_sbLsv];
                } in  sat_sbLsw;
          };

Data.Functor.Identity.$fShowIdentity_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Functor.Identity.Identity a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbLsx w1_sbLsy w2_sbLsz]
        case w1_sbLsy of {
          GHC.Types.I# ww1_sbLsB [Occ=Once] ->
              Data.Functor.Identity.$w$cshowsPrec w_sbLsx ww1_sbLsB w2_sbLsz;
        };

Data.Functor.Identity.$fShowIdentity_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Identity.Identity a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbLsC x_sbLsD]
        let {
          sat_sbLsE [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sbLsC x_sbLsD] \s []
                  GHC.Show.showsPrec
                      $dShow_sbLsC
                      Data.Functor.Identity.$fReadIdentity4
                      x_sbLsD
                      GHC.Types.[];
        } in  GHC.Base.++ Data.Functor.Identity.$fShowIdentity1 sat_sbLsE;

Data.Functor.Identity.$fShowIdentity_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Functor.Identity.Identity a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sbLsF ls_sbLsG s_sbLsH]
        let {
          sat_sbLsJ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abJ0D -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbLsF] \r [w_sbLsI]
                  Data.Functor.Identity.$w$cshowsPrec $dShow_sbLsF 0# w_sbLsI;
        } in  GHC.Show.showList__ sat_sbLsJ ls_sbLsG s_sbLsH;

Data.Functor.Identity.$fShowIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sbLsK]
        let {
          sat_sbLsN [Occ=Once]
            :: [Data.Functor.Identity.Identity a_abJ0D] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbLsK] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshowList
                      $dShow_sbLsK eta_B2 eta_B1; } in
        let {
          sat_sbLsM [Occ=Once]
            :: Data.Functor.Identity.Identity a_abJ0D -> GHC.Base.String
          [LclId] =
              [$dShow_sbLsK] \r [eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshow
                      $dShow_sbLsK eta_B1; } in
        let {
          sat_sbLsL [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abJ0D -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sbLsK] \r [eta_B2 eta_B1]
                  Data.Functor.Identity.$fShowIdentity_$cshowsPrec
                      $dShow_sbLsK eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sbLsL sat_sbLsM sat_sbLsN];

Data.Functor.Identity.$fFoldableIdentity4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Functor.Identity.$fFoldableIdentity_$clength
  :: forall a. Data.Functor.Identity.Identity a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sbLsO] Data.Functor.Identity.$fFoldableIdentity4;

Data.Functor.Identity.$fFoldableIdentity_$cnull
  :: forall a. Data.Functor.Identity.Identity a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbLsP] GHC.Types.False [];

Data.Functor.Identity.$fFoldableIdentity_$ctoList
  :: forall a. Data.Functor.Identity.Identity a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [ds_sbLsQ] : [ds_sbLsQ GHC.Types.[]];

Data.Functor.Identity.$fFoldableIdentity6
  :: forall b a. (b -> a -> b) -> b -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbLsR] v_sbLsR;

Data.Functor.Identity.$fFoldableIdentity_$cfoldr
  :: forall a b.
     (a -> b -> b) -> b -> Data.Functor.Identity.Identity a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sbLsS z_sbLsT ds_sbLsU] f_sbLsS ds_sbLsU z_sbLsT;

Data.Functor.Identity.$fFoldableIdentity7
  :: forall m a. GHC.Base.Monoid m => (a -> m) -> a -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sbLsV v_sbLsW] v_sbLsW;

Data.Functor.Identity.$fFunctorIdentity2
  :: forall a b. (a -> b) -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbLsX] v_sbLsX;

Data.Functor.Identity.$fFunctorIdentity1 :: forall b a. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sbLsY ds_sbLsZ] x_sbLsY;

Data.Functor.Identity.$fFunctorIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Functor.Identity.$fFunctorIdentity2
                                       Data.Functor.Identity.$fFunctorIdentity1];

Data.Functor.Identity.$fApplicativeIdentity1
  :: forall a b c. (a -> b -> c) -> a -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbLt0] v_sbLt0;

Data.Functor.Identity.$fApplicativeIdentity2
  :: forall a b.
     Data.Functor.Identity.Identity (a -> b)
     -> Data.Functor.Identity.Identity (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbLt1] v_sbLt1;

Data.Functor.Identity.$fApplicativeIdentity3 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbLt2] v_sbLt2;

Data.Functor.Identity.$fApplicativeIdentity_$c*>
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sbLt3 a2_sbLt4] a2_sbLt4;

Data.Functor.Identity.$fApplicativeIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Functor.Identity.$fFunctorIdentity
                                           Data.Functor.Identity.$fApplicativeIdentity3
                                           Data.Functor.Identity.$fApplicativeIdentity2
                                           Data.Functor.Identity.$fApplicativeIdentity1
                                           Data.Functor.Identity.$fApplicativeIdentity_$c*>
                                           GHC.Base.const];

Data.Functor.Identity.$fStorableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Foreign.Storable.Storable a =>
     Foreign.Storable.Storable (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dStorable_sbLt5]
        let {
          sat_sbLtd [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> Data.Functor.Identity.Identity a_abITC -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.poke $dStorable_sbLt5; } in
        let {
          sat_sbLtc [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.peek $dStorable_sbLt5; } in
        let {
          sat_sbLtb [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abITC
               -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.pokeByteOff $dStorable_sbLt5; } in
        let {
          sat_sbLta [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.peekByteOff $dStorable_sbLt5; } in
        let {
          sat_sbLt9 [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abITC
               -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.pokeElemOff $dStorable_sbLt5; } in
        let {
          sat_sbLt8 [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Functor.Identity.Identity a_abITC)
               -> GHC.Types.Int
               -> GHC.Types.IO (Data.Functor.Identity.Identity a_abITC)
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.peekElemOff $dStorable_sbLt5; } in
        let {
          sat_sbLt7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abITC -> GHC.Types.Int
          [LclId] =
              [$dStorable_sbLt5] \u []
                  Foreign.Storable.alignment $dStorable_sbLt5; } in
        let {
          sat_sbLt6 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abITC -> GHC.Types.Int
          [LclId] =
              [$dStorable_sbLt5] \u [] Foreign.Storable.sizeOf $dStorable_sbLt5;
        } in 
          Foreign.Storable.C:Storable [sat_sbLt6
                                       sat_sbLt7
                                       sat_sbLt8
                                       sat_sbLt9
                                       sat_sbLta
                                       sat_sbLtb
                                       sat_sbLtc
                                       sat_sbLtd];

Data.Functor.Identity.$fNumIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_sbLte]
        let {
          sat_sbLtl [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.fromInteger $dNum_sbLte; } in
        let {
          sat_sbLtk [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.signum $dNum_sbLte; } in
        let {
          sat_sbLtj [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.abs $dNum_sbLte; } in
        let {
          sat_sbLti [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.negate $dNum_sbLte; } in
        let {
          sat_sbLth [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.* $dNum_sbLte; } in
        let {
          sat_sbLtg [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.- $dNum_sbLte; } in
        let {
          sat_sbLtf [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
               -> Data.Functor.Identity.Identity a_abIKV
          [LclId] =
              [$dNum_sbLte] \u [] GHC.Num.+ $dNum_sbLte;
        } in 
          GHC.Num.C:Num [sat_sbLtf
                         sat_sbLtg
                         sat_sbLth
                         sat_sbLti
                         sat_sbLtj
                         sat_sbLtk
                         sat_sbLtl];

Data.Functor.Identity.$fRealIdentity_$cp1Real
  :: forall a.
     GHC.Real.Real a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dReal_sbLtm]
        let {
          sat_sbLtn [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Num.Num a_abIOf
          [LclId] =
              [$dReal_sbLtm] \u [] GHC.Real.$p1Real $dReal_sbLtm;
        } in  Data.Functor.Identity.$fNumIdentity sat_sbLtn;

Data.Functor.Identity.$fSemigroupIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U,1*U)>m] =
    [] \r [$dSemigroup_sbLto]
        let {
          sat_sbLtr [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbLto] \u [] GHC.Base.stimes $dSemigroup_sbLto; } in
        let {
          sat_sbLtq [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Functor.Identity.Identity a_abIJk)
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbLto] \u [] GHC.Base.sconcat $dSemigroup_sbLto; } in
        let {
          sat_sbLtp [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
               -> Data.Functor.Identity.Identity a_abIJk
          [LclId] =
              [$dSemigroup_sbLto] \u [] GHC.Base.<> $dSemigroup_sbLto;
        } in  GHC.Base.C:Semigroup [sat_sbLtp sat_sbLtq sat_sbLtr];

Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sbLts]
        let {
          sat_sbLtt [Occ=Once, Dmd=<L,U(1*U,1*U,1*U)>]
            :: GHC.Base.Semigroup a_abIKg
          [LclId] =
              [$dMonoid_sbLts] \u [] GHC.Base.$p1Monoid $dMonoid_sbLts;
        } in  Data.Functor.Identity.$fSemigroupIdentity sat_sbLtt;

Data.Functor.Identity.$fMonoidIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dMonoid_sbLtu]
        let {
          sat_sbLty [Occ=Once]
            :: [Data.Functor.Identity.Identity a_abIKg]
               -> Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbLtu] \u [] GHC.Base.mconcat $dMonoid_sbLtu; } in
        let {
          sat_sbLtx [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIKg
               -> Data.Functor.Identity.Identity a_abIKg
               -> Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbLtu] \u [] GHC.Base.mappend $dMonoid_sbLtu; } in
        let {
          sat_sbLtw [Occ=Once] :: Data.Functor.Identity.Identity a_abIKg
          [LclId] =
              [$dMonoid_sbLtu] \u [] GHC.Base.mempty $dMonoid_sbLtu; } in
        let {
          sat_sbLtv [Occ=Once]
            :: GHC.Base.Semigroup (Data.Functor.Identity.Identity a_abIKg)
          [LclId] =
              [$dMonoid_sbLtu] \u []
                  Data.Functor.Identity.$fMonoidIdentity_$cp1Monoid $dMonoid_sbLtu;
        } in  GHC.Base.C:Monoid [sat_sbLtv sat_sbLtw sat_sbLtx sat_sbLty];

Data.Functor.Identity.$fGeneric1Identity1
  :: forall a.
     GHC.Generics.Rep1 Data.Functor.Identity.Identity a
     -> GHC.Generics.Rep1 Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbLtz] ds_sbLtz;

Data.Functor.Identity.$fFoldableIdentity2
  :: forall a.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sbLtA] x_sbLtA;

Data.Functor.Identity.$fGeneric1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Functor.Identity.$fFoldableIdentity2
                                            Data.Functor.Identity.$fGeneric1Identity1];

Data.Functor.Identity.$fGenericIdentity1
  :: forall a x.
     GHC.Generics.Rep (Data.Functor.Identity.Identity a) x
     -> GHC.Generics.Rep (Data.Functor.Identity.Identity a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sbLtB] ds_sbLtB;

Data.Functor.Identity.$fGenericIdentity2
  :: forall a x.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sbLtC] x1_sbLtC;

Data.Functor.Identity.$fGenericIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Generics.Generic (Data.Functor.Identity.Identity a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Identity.$fGenericIdentity2
                                           Data.Functor.Identity.$fGenericIdentity1];

Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
  :: forall a.
     GHC.Real.Fractional a =>
     GHC.Num.Num (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFractional_sbLtD]
        let {
          sat_sbLtE [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Num.Num a_abIDx
          [LclId] =
              [$dFractional_sbLtD] \u []
                  GHC.Real.$p1Fractional $dFractional_sbLtD;
        } in  Data.Functor.Identity.$fNumIdentity sat_sbLtE;

Data.Functor.Identity.$fFractionalIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Fractional a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dFractional_sbLtF]
        let {
          sat_sbLtJ [Occ=Once]
            :: GHC.Real.Rational -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbLtF] \u []
                  GHC.Real.fromRational $dFractional_sbLtF; } in
        let {
          sat_sbLtI [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbLtF] \u [] GHC.Real.recip $dFractional_sbLtF; } in
        let {
          sat_sbLtH [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
               -> Data.Functor.Identity.Identity a_abIDx
          [LclId] =
              [$dFractional_sbLtF] \u [] GHC.Real./ $dFractional_sbLtF; } in
        let {
          sat_sbLtG [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Identity.Identity a_abIDx)
          [LclId] =
              [$dFractional_sbLtF] \u []
                  Data.Functor.Identity.$fFractionalIdentity_$cp1Fractional
                      $dFractional_sbLtF;
        } in 
          GHC.Real.C:Fractional [sat_sbLtG sat_sbLtH sat_sbLtI sat_sbLtJ];

Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_sbLtK]
        let {
          sat_sbLtL [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>]
            :: GHC.Real.Fractional a_abIOC
          [LclId] =
              [$dRealFrac_sbLtK] \u [] GHC.Real.$p2RealFrac $dRealFrac_sbLtK;
        } in  Data.Functor.Identity.$fFractionalIdentity sat_sbLtL;

Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
  :: forall a.
     GHC.Float.Floating a =>
     GHC.Real.Fractional (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sbLtM]
        let {
          sat_sbLtN [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>]
            :: GHC.Real.Fractional a_abIzr
          [LclId] =
              [$dFloating_sbLtM] \u [] GHC.Float.$p1Floating $dFloating_sbLtM;
        } in  Data.Functor.Identity.$fFractionalIdentity sat_sbLtN;

Data.Functor.Identity.$fFloatingIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.Floating a =>
     GHC.Float.Floating (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dFloating_sbLtO]
        let {
          sat_sbLub [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.log1mexp $dFloating_sbLtO; } in
        let {
          sat_sbLua [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.log1pexp $dFloating_sbLtO; } in
        let {
          sat_sbLu9 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.expm1 $dFloating_sbLtO; } in
        let {
          sat_sbLu8 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.log1p $dFloating_sbLtO; } in
        let {
          sat_sbLu7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.atanh $dFloating_sbLtO; } in
        let {
          sat_sbLu6 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.acosh $dFloating_sbLtO; } in
        let {
          sat_sbLu5 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.asinh $dFloating_sbLtO; } in
        let {
          sat_sbLu4 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.tanh $dFloating_sbLtO; } in
        let {
          sat_sbLu3 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.cosh $dFloating_sbLtO; } in
        let {
          sat_sbLu2 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.sinh $dFloating_sbLtO; } in
        let {
          sat_sbLu1 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.atan $dFloating_sbLtO; } in
        let {
          sat_sbLu0 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.acos $dFloating_sbLtO; } in
        let {
          sat_sbLtZ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.asin $dFloating_sbLtO; } in
        let {
          sat_sbLtY [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.tan $dFloating_sbLtO; } in
        let {
          sat_sbLtX [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.cos $dFloating_sbLtO; } in
        let {
          sat_sbLtW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.sin $dFloating_sbLtO; } in
        let {
          sat_sbLtV [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.logBase $dFloating_sbLtO; } in
        let {
          sat_sbLtU [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.** $dFloating_sbLtO; } in
        let {
          sat_sbLtT [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.sqrt $dFloating_sbLtO; } in
        let {
          sat_sbLtS [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.log $dFloating_sbLtO; } in
        let {
          sat_sbLtR [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIzr
               -> Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.exp $dFloating_sbLtO; } in
        let {
          sat_sbLtQ [Occ=Once] :: Data.Functor.Identity.Identity a_abIzr
          [LclId] =
              [$dFloating_sbLtO] \u [] GHC.Float.pi $dFloating_sbLtO; } in
        let {
          sat_sbLtP [Occ=Once]
            :: GHC.Real.Fractional (Data.Functor.Identity.Identity a_abIzr)
          [LclId] =
              [$dFloating_sbLtO] \u []
                  Data.Functor.Identity.$fFloatingIdentity_$cp1Floating
                      $dFloating_sbLtO;
        } in 
          GHC.Float.C:Floating [sat_sbLtP
                                sat_sbLtQ
                                sat_sbLtR
                                sat_sbLtS
                                sat_sbLtT
                                sat_sbLtU
                                sat_sbLtV
                                sat_sbLtW
                                sat_sbLtX
                                sat_sbLtY
                                sat_sbLtZ
                                sat_sbLu0
                                sat_sbLu1
                                sat_sbLu2
                                sat_sbLu3
                                sat_sbLu4
                                sat_sbLu5
                                sat_sbLu6
                                sat_sbLu7
                                sat_sbLu8
                                sat_sbLu9
                                sat_sbLua
                                sat_sbLub];

Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.Floating (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sbLuc]
        let {
          sat_sbLud [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Float.Floating a_abIQK
          [LclId] =
              [$dRealFloat_sbLuc] \u [] GHC.Float.$p2RealFloat $dRealFloat_sbLuc;
        } in  Data.Functor.Identity.$fFloatingIdentity sat_sbLud;

Data.Functor.Identity.$fEqIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sbLue]
        let {
          sat_sbLug [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIye
               -> Data.Functor.Identity.Identity a_abIye -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbLue] \u [] GHC.Classes./= $dEq_sbLue; } in
        let {
          sat_sbLuf [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIye
               -> Data.Functor.Identity.Identity a_abIye -> GHC.Types.Bool
          [LclId] =
              [$dEq_sbLue] \u [] GHC.Classes.== $dEq_sbLue;
        } in  GHC.Classes.C:Eq [sat_sbLuf sat_sbLug];

Data.Functor.Identity.$fOrdIdentity_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sbLuh]
        let {
          sat_sbLui [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_abIMq
          [LclId] =
              [$dOrd_sbLuh] \u [] GHC.Classes.$p1Ord $dOrd_sbLuh;
        } in  Data.Functor.Identity.$fEqIdentity sat_sbLui;

Data.Functor.Identity.$fOrdIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sbLuj]
        let {
          sat_sbLur [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.min $dOrd_sbLuj; } in
        let {
          sat_sbLuq [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.max $dOrd_sbLuj; } in
        let {
          sat_sbLup [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.>= $dOrd_sbLuj; } in
        let {
          sat_sbLuo [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.> $dOrd_sbLuj; } in
        let {
          sat_sbLun [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.<= $dOrd_sbLuj; } in
        let {
          sat_sbLum [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.< $dOrd_sbLuj; } in
        let {
          sat_sbLul [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIMq
               -> Data.Functor.Identity.Identity a_abIMq -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sbLuj] \u [] GHC.Classes.compare $dOrd_sbLuj; } in
        let {
          sat_sbLuk [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Identity.Identity a_abIMq)
          [LclId] =
              [$dOrd_sbLuj] \u []
                  Data.Functor.Identity.$fOrdIdentity_$cp1Ord $dOrd_sbLuj;
        } in 
          GHC.Classes.C:Ord [sat_sbLuk
                             sat_sbLul
                             sat_sbLum
                             sat_sbLun
                             sat_sbLuo
                             sat_sbLup
                             sat_sbLuq
                             sat_sbLur];

Data.Functor.Identity.$fIxIdentity_$cp1Ix
  :: forall a.
     GHC.Arr.Ix a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIx_sbLus]
        let {
          sat_sbLut [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Classes.Ord a_abIHW
          [LclId] =
              [$dIx_sbLus] \u [] GHC.Arr.$p1Ix $dIx_sbLus;
        } in  Data.Functor.Identity.$fOrdIdentity sat_sbLut;

Data.Functor.Identity.$fIxIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Arr.Ix a =>
     GHC.Arr.Ix (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dIx_sbLuu]
        let {
          sat_sbLuB [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> GHC.Types.Int
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.unsafeRangeSize $dIx_sbLuu; } in
        let {
          sat_sbLuA [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> GHC.Types.Int
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.rangeSize $dIx_sbLuu; } in
        let {
          sat_sbLuz [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Bool
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.inRange $dIx_sbLuu; } in
        let {
          sat_sbLuy [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Int
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.unsafeIndex $dIx_sbLuu; } in
        let {
          sat_sbLux [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> Data.Functor.Identity.Identity a_abIHW -> GHC.Types.Int
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.index $dIx_sbLuu; } in
        let {
          sat_sbLuw [Occ=Once]
            :: (Data.Functor.Identity.Identity a_abIHW,
                Data.Functor.Identity.Identity a_abIHW)
               -> [Data.Functor.Identity.Identity a_abIHW]
          [LclId] =
              [$dIx_sbLuu] \u [] GHC.Arr.range $dIx_sbLuu; } in
        let {
          sat_sbLuv [Occ=Once]
            :: GHC.Classes.Ord (Data.Functor.Identity.Identity a_abIHW)
          [LclId] =
              [$dIx_sbLuu] \u []
                  Data.Functor.Identity.$fIxIdentity_$cp1Ix $dIx_sbLuu;
        } in 
          GHC.Arr.C:Ix [sat_sbLuv
                        sat_sbLuw
                        sat_sbLux
                        sat_sbLuy
                        sat_sbLuz
                        sat_sbLuA
                        sat_sbLuB];

Data.Functor.Identity.$fRealIdentity_$cp2Real
  :: forall a.
     GHC.Real.Real a =>
     GHC.Classes.Ord (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),A)>m,
 Unf=OtherCon []] =
    [] \r [$dReal_sbLuC]
        let {
          sat_sbLuD [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Classes.Ord a_abIOf
          [LclId] =
              [$dReal_sbLuC] \u [] GHC.Real.$p2Real $dReal_sbLuC;
        } in  Data.Functor.Identity.$fOrdIdentity sat_sbLuD;

Data.Functor.Identity.$fRealIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Real a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>m] =
    [] \r [$dReal_sbLuE]
        let {
          sat_sbLuH [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIOf -> GHC.Real.Rational
          [LclId] =
              [$dReal_sbLuE] \u [] GHC.Real.toRational $dReal_sbLuE; } in
        let {
          sat_sbLuG [Occ=Once]
            :: GHC.Classes.Ord (Data.Functor.Identity.Identity a_abIOf)
          [LclId] =
              [$dReal_sbLuE] \u []
                  Data.Functor.Identity.$fRealIdentity_$cp2Real $dReal_sbLuE; } in
        let {
          sat_sbLuF [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Identity.Identity a_abIOf)
          [LclId] =
              [$dReal_sbLuE] \u []
                  Data.Functor.Identity.$fRealIdentity_$cp1Real $dReal_sbLuE;
        } in  GHC.Real.C:Real [sat_sbLuF sat_sbLuG sat_sbLuH];

Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sbLuI]
        let {
          sat_sbLuJ [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>]
            :: GHC.Real.Real a_abIG7
          [LclId] =
              [$dIntegral_sbLuI] \u [] GHC.Real.$p1Integral $dIntegral_sbLuI;
        } in  Data.Functor.Identity.$fRealIdentity sat_sbLuJ;

Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.Real (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_sbLuK]
        let {
          sat_sbLuL [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>]
            :: GHC.Real.Real a_abIOC
          [LclId] =
              [$dRealFrac_sbLuK] \u [] GHC.Real.$p1RealFrac $dRealFrac_sbLuK;
        } in  Data.Functor.Identity.$fRealIdentity sat_sbLuL;

Data.Functor.Identity.$fRealFracIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.RealFrac a =>
     GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dRealFrac_sbLuM]
        let {
          sat_sbLuT [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbLuM] \u [] GHC.Real.floor $dRealFrac_sbLuM; } in
        let {
          sat_sbLuS [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbLuM] \u [] GHC.Real.ceiling $dRealFrac_sbLuM; } in
        let {
          sat_sbLuR [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbLuM] \u [] GHC.Real.round $dRealFrac_sbLuM; } in
        let {
          sat_sbLuQ [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC -> b
          [LclId] =
              [$dRealFrac_sbLuM] \u [] GHC.Real.truncate $dRealFrac_sbLuM; } in
        let {
          sat_sbLuP [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Functor.Identity.Identity a_abIOC
               -> (b, Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbLuM] \u []
                  GHC.Real.properFraction $dRealFrac_sbLuM; } in
        let {
          sat_sbLuO [Occ=Once]
            :: GHC.Real.Fractional (Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbLuM] \u []
                  Data.Functor.Identity.$fRealFracIdentity_$cp2RealFrac
                      $dRealFrac_sbLuM; } in
        let {
          sat_sbLuN [Occ=Once]
            :: GHC.Real.Real (Data.Functor.Identity.Identity a_abIOC)
          [LclId] =
              [$dRealFrac_sbLuM] \u []
                  Data.Functor.Identity.$fRealFracIdentity_$cp1RealFrac
                      $dRealFrac_sbLuM;
        } in 
          GHC.Real.C:RealFrac [sat_sbLuN
                               sat_sbLuO
                               sat_sbLuP
                               sat_sbLuQ
                               sat_sbLuR
                               sat_sbLuS
                               sat_sbLuT];

Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sbLuU]
        let {
          sat_sbLuV [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Real.RealFrac a_abIQK
          [LclId] =
              [$dRealFloat_sbLuU] \u [] GHC.Float.$p1RealFloat $dRealFloat_sbLuU;
        } in  Data.Functor.Identity.$fRealFracIdentity sat_sbLuV;

Data.Functor.Identity.$fRealFloatIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.RealFloat (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dRealFloat_sbLuW]
        let {
          sat_sbLvc [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbLuW] \u [] GHC.Float.atan2 $dRealFloat_sbLuW; } in
        let {
          sat_sbLvb [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbLuW] \u [] GHC.Float.isIEEE $dRealFloat_sbLuW; } in
        let {
          sat_sbLva [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.isNegativeZero $dRealFloat_sbLuW; } in
        let {
          sat_sbLv9 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.isDenormalized $dRealFloat_sbLuW; } in
        let {
          sat_sbLv8 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.isInfinite $dRealFloat_sbLuW; } in
        let {
          sat_sbLv7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Bool
          [LclId] =
              [$dRealFloat_sbLuW] \u [] GHC.Float.isNaN $dRealFloat_sbLuW; } in
        let {
          sat_sbLv6 [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.scaleFloat $dRealFloat_sbLuW; } in
        let {
          sat_sbLv5 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.significand $dRealFloat_sbLuW; } in
        let {
          sat_sbLv4 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Int
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.exponent $dRealFloat_sbLuW; } in
        let {
          sat_sbLv3 [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIQK
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.encodeFloat $dRealFloat_sbLuW; } in
        let {
          sat_sbLv2 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> (GHC.Integer.Type.Integer, GHC.Types.Int)
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.decodeFloat $dRealFloat_sbLuW; } in
        let {
          sat_sbLv1 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> (GHC.Types.Int, GHC.Types.Int)
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.floatRange $dRealFloat_sbLuW; } in
        let {
          sat_sbLv0 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK -> GHC.Types.Int
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.floatDigits $dRealFloat_sbLuW; } in
        let {
          sat_sbLuZ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIQK
               -> GHC.Integer.Type.Integer
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  GHC.Float.floatRadix $dRealFloat_sbLuW; } in
        let {
          sat_sbLuY [Occ=Once]
            :: GHC.Float.Floating (Data.Functor.Identity.Identity a_abIQK)
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  Data.Functor.Identity.$fRealFloatIdentity_$cp2RealFloat
                      $dRealFloat_sbLuW; } in
        let {
          sat_sbLuX [Occ=Once]
            :: GHC.Real.RealFrac (Data.Functor.Identity.Identity a_abIQK)
          [LclId] =
              [$dRealFloat_sbLuW] \u []
                  Data.Functor.Identity.$fRealFloatIdentity_$cp1RealFloat
                      $dRealFloat_sbLuW;
        } in 
          GHC.Float.C:RealFloat [sat_sbLuX
                                 sat_sbLuY
                                 sat_sbLuZ
                                 sat_sbLv0
                                 sat_sbLv1
                                 sat_sbLv2
                                 sat_sbLv3
                                 sat_sbLv4
                                 sat_sbLv5
                                 sat_sbLv6
                                 sat_sbLv7
                                 sat_sbLv8
                                 sat_sbLv9
                                 sat_sbLva
                                 sat_sbLvb
                                 sat_sbLvc];

Data.Functor.Identity.$fEnumIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dEnum_sbLvd]
        let {
          sat_sbLvl [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.enumFromThenTo $dEnum_sbLvd; } in
        let {
          sat_sbLvk [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.enumFromTo $dEnum_sbLvd; } in
        let {
          sat_sbLvj [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.enumFromThen $dEnum_sbLvd; } in
        let {
          sat_sbLvi [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> [Data.Functor.Identity.Identity a_abIwu]
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.enumFrom $dEnum_sbLvd; } in
        let {
          sat_sbLvh [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu -> GHC.Types.Int
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.fromEnum $dEnum_sbLvd; } in
        let {
          sat_sbLvg [Occ=Once]
            :: GHC.Types.Int -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.toEnum $dEnum_sbLvd; } in
        let {
          sat_sbLvf [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.pred $dEnum_sbLvd; } in
        let {
          sat_sbLve [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIwu
               -> Data.Functor.Identity.Identity a_abIwu
          [LclId] =
              [$dEnum_sbLvd] \u [] GHC.Enum.succ $dEnum_sbLvd;
        } in 
          GHC.Enum.C:Enum [sat_sbLve
                           sat_sbLvf
                           sat_sbLvg
                           sat_sbLvh
                           sat_sbLvi
                           sat_sbLvj
                           sat_sbLvk
                           sat_sbLvl];

Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Enum.Enum (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sbLvm]
        let {
          sat_sbLvn [Occ=Once, Dmd=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Enum.Enum a_abIG7
          [LclId] =
              [$dIntegral_sbLvm] \u [] GHC.Real.$p2Integral $dIntegral_sbLvm;
        } in  Data.Functor.Identity.$fEnumIdentity sat_sbLvn;

Data.Functor.Identity.$fIntegralIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Real.Integral a =>
     GHC.Real.Integral (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dIntegral_sbLvo]
        let {
          sat_sbLvx [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> GHC.Integer.Type.Integer
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.toInteger $dIntegral_sbLvo; } in
        let {
          sat_sbLvw [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> (Data.Functor.Identity.Identity a_abIG7,
                   Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.divMod $dIntegral_sbLvo; } in
        let {
          sat_sbLvv [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> (Data.Functor.Identity.Identity a_abIG7,
                   Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.quotRem $dIntegral_sbLvo; } in
        let {
          sat_sbLvu [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.mod $dIntegral_sbLvo; } in
        let {
          sat_sbLvt [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.div $dIntegral_sbLvo; } in
        let {
          sat_sbLvs [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.rem $dIntegral_sbLvo; } in
        let {
          sat_sbLvr [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
               -> Data.Functor.Identity.Identity a_abIG7
          [LclId] =
              [$dIntegral_sbLvo] \u [] GHC.Real.quot $dIntegral_sbLvo; } in
        let {
          sat_sbLvq [Occ=Once]
            :: GHC.Enum.Enum (Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbLvo] \u []
                  Data.Functor.Identity.$fIntegralIdentity_$cp2Integral
                      $dIntegral_sbLvo; } in
        let {
          sat_sbLvp [Occ=Once]
            :: GHC.Real.Real (Data.Functor.Identity.Identity a_abIG7)
          [LclId] =
              [$dIntegral_sbLvo] \u []
                  Data.Functor.Identity.$fIntegralIdentity_$cp1Integral
                      $dIntegral_sbLvo;
        } in 
          GHC.Real.C:Integral [sat_sbLvp
                               sat_sbLvq
                               sat_sbLvr
                               sat_sbLvs
                               sat_sbLvt
                               sat_sbLvu
                               sat_sbLvv
                               sat_sbLvw
                               sat_sbLvx];

Data.Functor.Identity.$fBoundedIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Functor.Identity.Identity a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sbLvy]
        let {
          sat_sbLvA [Occ=Once] :: Data.Functor.Identity.Identity a_abIwc
          [LclId] =
              [$dBounded_sbLvy] \u [] GHC.Enum.maxBound $dBounded_sbLvy; } in
        let {
          sat_sbLvz [Occ=Once] :: Data.Functor.Identity.Identity a_abIwc
          [LclId] =
              [$dBounded_sbLvy] \u [] GHC.Enum.minBound $dBounded_sbLvy;
        } in  GHC.Enum.C:Bounded [sat_sbLvz sat_sbLvA];

Data.Functor.Identity.$fBitsIdentity_$cp1Bits
  :: forall a.
     Data.Bits.Bits a =>
     GHC.Classes.Eq (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dBits_sbLvB]
        let {
          sat_sbLvC [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_abIrg
          [LclId] =
              [$dBits_sbLvB] \u [] Data.Bits.$p1Bits $dBits_sbLvB;
        } in  Data.Functor.Identity.$fEqIdentity sat_sbLvC;

Data.Functor.Identity.$fBitsIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Bits.Bits a =>
     Data.Bits.Bits (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>] =
    [] \r [$dBits_sbLvD]
        let {
          sat_sbLw0 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Int
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.popCount $dBits_sbLvD; } in
        let {
          sat_sbLvZ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.rotateR $dBits_sbLvD; } in
        let {
          sat_sbLvY [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.rotateL $dBits_sbLvD; } in
        let {
          sat_sbLvX [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.unsafeShiftR $dBits_sbLvD; } in
        let {
          sat_sbLvW [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.shiftR $dBits_sbLvD; } in
        let {
          sat_sbLvV [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.unsafeShiftL $dBits_sbLvD; } in
        let {
          sat_sbLvU [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.shiftL $dBits_sbLvD; } in
        let {
          sat_sbLvT [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Bool
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.isSigned $dBits_sbLvD; } in
        let {
          sat_sbLvS [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg -> GHC.Types.Int
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.bitSize $dBits_sbLvD; } in
        let {
          sat_sbLvR [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Base.Maybe GHC.Types.Int
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.bitSizeMaybe $dBits_sbLvD; } in
        let {
          sat_sbLvQ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> GHC.Types.Bool
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.testBit $dBits_sbLvD; } in
        let {
          sat_sbLvP [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.complementBit $dBits_sbLvD; } in
        let {
          sat_sbLvO [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.clearBit $dBits_sbLvD; } in
        let {
          sat_sbLvN [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.setBit $dBits_sbLvD; } in
        let {
          sat_sbLvM [Occ=Once]
            :: GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.bit $dBits_sbLvD; } in
        let {
          sat_sbLvL [Occ=Once] :: Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.zeroBits $dBits_sbLvD; } in
        let {
          sat_sbLvK [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.rotate $dBits_sbLvD; } in
        let {
          sat_sbLvJ [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> GHC.Types.Int -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.shift $dBits_sbLvD; } in
        let {
          sat_sbLvI [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.complement $dBits_sbLvD; } in
        let {
          sat_sbLvH [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits.xor $dBits_sbLvD; } in
        let {
          sat_sbLvG [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits..|. $dBits_sbLvD; } in
        let {
          sat_sbLvF [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
               -> Data.Functor.Identity.Identity a_abIrg
          [LclId] =
              [$dBits_sbLvD] \u [] Data.Bits..&. $dBits_sbLvD; } in
        let {
          sat_sbLvE [Occ=Once]
            :: GHC.Classes.Eq (Data.Functor.Identity.Identity a_abIrg)
          [LclId] =
              [$dBits_sbLvD] \u []
                  Data.Functor.Identity.$fBitsIdentity_$cp1Bits $dBits_sbLvD;
        } in 
          Data.Bits.C:Bits [sat_sbLvE
                            sat_sbLvF
                            sat_sbLvG
                            sat_sbLvH
                            sat_sbLvI
                            sat_sbLvJ
                            sat_sbLvK
                            sat_sbLvL
                            sat_sbLvM
                            sat_sbLvN
                            sat_sbLvO
                            sat_sbLvP
                            sat_sbLvQ
                            sat_sbLvR
                            sat_sbLvS
                            sat_sbLvT
                            sat_sbLvU
                            sat_sbLvV
                            sat_sbLvW
                            sat_sbLvX
                            sat_sbLvY
                            sat_sbLvZ
                            sat_sbLw0];

Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
  :: forall a.
     Data.Bits.FiniteBits a =>
     Data.Bits.Bits (Data.Functor.Identity.Identity a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_sbLw1]
        let {
          sat_sbLw2 [Occ=Once,
                     Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>]
            :: Data.Bits.Bits a_abIyM
          [LclId] =
              [$dFiniteBits_sbLw1] \u []
                  Data.Bits.$p1FiniteBits $dFiniteBits_sbLw1;
        } in  Data.Functor.Identity.$fBitsIdentity sat_sbLw2;

Data.Functor.Identity.$fFiniteBitsIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Bits.FiniteBits a =>
     Data.Bits.FiniteBits (Data.Functor.Identity.Identity a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U)>m] =
    [] \r [$dFiniteBits_sbLw3]
        let {
          sat_sbLw7 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbLw3] \u []
                  Data.Bits.countTrailingZeros $dFiniteBits_sbLw3; } in
        let {
          sat_sbLw6 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbLw3] \u []
                  Data.Bits.countLeadingZeros $dFiniteBits_sbLw3; } in
        let {
          sat_sbLw5 [Occ=Once]
            :: Data.Functor.Identity.Identity a_abIyM -> GHC.Types.Int
          [LclId] =
              [$dFiniteBits_sbLw3] \u []
                  Data.Bits.finiteBitSize $dFiniteBits_sbLw3; } in
        let {
          sat_sbLw4 [Occ=Once]
            :: Data.Bits.Bits (Data.Functor.Identity.Identity a_abIyM)
          [LclId] =
              [$dFiniteBits_sbLw3] \u []
                  Data.Functor.Identity.$fFiniteBitsIdentity_$cp1FiniteBits
                      $dFiniteBits_sbLw3;
        } in 
          Data.Bits.C:FiniteBits [sat_sbLw4 sat_sbLw5 sat_sbLw6 sat_sbLw7];

Data.Functor.Identity.runIdentity
  :: forall a. Data.Functor.Identity.Identity a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fMonadFixIdentity_$cmfix
  :: forall a.
     (a -> Data.Functor.Identity.Identity a)
     -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sbLw8]
        let {
          x_sbLw9 [Occ=LoopBreaker] :: Data.Functor.Identity.Identity a_abIVT
          [LclId] =
              [f_sbLw8 x_sbLw9] \u [] f_sbLw8 x_sbLw9;
        } in  x_sbLw9;

Data.Functor.Identity.$fMonadIdentity_$c>>=
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> (a -> Data.Functor.Identity.Identity b)
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_sbLwa k_sbLwb] k_sbLwb m_sbLwa;

Data.Functor.Identity.$fMonadIdentity_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> Data.Functor.Identity.Identity b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Functor.Identity.$fApplicativeIdentity_$c*> eta_B2 eta_B1;

lvl_rbJt6
  :: forall a. [GHC.Types.Char] -> Data.Functor.Identity.Identity a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sbLwc] GHC.Err.errorWithoutStackTrace eta_sbLwc;

Data.Functor.Identity.$fMonadIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Functor.Identity.$fApplicativeIdentity
                                     Data.Functor.Identity.$fMonadIdentity_$c>>=
                                     Data.Functor.Identity.$fMonadIdentity_$c>>
                                     Data.Functor.Identity.$fApplicativeIdentity3
                                     lvl_rbJt6];

Data.Functor.Identity.$fMonadFixIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Functor.Identity.$fMonadIdentity
                                                 Data.Functor.Identity.$fMonadFixIdentity_$cmfix];

Data.Functor.Identity.$fFoldableIdentity5
  :: forall a.
     (a -> a -> a)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sbLwd eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity3
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sbLwe eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity1
  :: forall a.
     GHC.Num.Num a =>
     Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dNum_sbLwf eta_B1]
        Data.Functor.Identity.$fFoldableIdentity2 eta_B1;

Data.Functor.Identity.$fFoldableIdentity8
  :: forall m. GHC.Base.Monoid m => m -> m
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dMonoid_sbLwg eta_B1] GHC.Base.id eta_B1;

Data.Functor.Identity.$fFoldableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Functor.Identity.$fFoldableIdentity8
                                             Data.Functor.Identity.$fFoldableIdentity7
                                             Data.Functor.Identity.$fFoldableIdentity_$cfoldr
                                             Data.Functor.Identity.$fFoldableIdentity_$cfoldr
                                             Data.Functor.Identity.$fFoldableIdentity6
                                             Data.Functor.Identity.$fFoldableIdentity6
                                             Data.Functor.Identity.$fFoldableIdentity5
                                             Data.Functor.Identity.$fFoldableIdentity5
                                             Data.Functor.Identity.$fFoldableIdentity_$ctoList
                                             Data.Functor.Identity.$fFoldableIdentity_$cnull
                                             Data.Functor.Identity.$fFoldableIdentity_$clength
                                             GHC.Classes.==
                                             Data.Functor.Identity.$fFoldableIdentity3
                                             Data.Functor.Identity.$fFoldableIdentity3
                                             Data.Functor.Identity.$fFoldableIdentity1
                                             Data.Functor.Identity.$fFoldableIdentity1];

Data.Functor.Identity.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Identity.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$trModule4];

Data.Functor.Identity.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Identity"#;

Data.Functor.Identity.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$trModule2];

Data.Functor.Identity.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Identity.$trModule3
                                     Data.Functor.Identity.$trModule1];

$krep_rbJt7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Functor.Identity.$tcIdentity1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$fReadIdentity6];

Data.Functor.Identity.$tcIdentity :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3410104521590905987##
                                    16392070908630191652##
                                    Data.Functor.Identity.$trModule
                                    Data.Functor.Identity.$tcIdentity1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep1_rbJt8 :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rbJt7 GHC.Types.[]];

$krep2_rbJt9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Identity.$tcIdentity
                                              $krep1_rbJt8];

Data.Functor.Identity.$tc'Identity1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rbJt7 $krep2_rbJt9];

Data.Functor.Identity.$tc'Identity3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Identity"#;

Data.Functor.Identity.$tc'Identity2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Identity.$tc'Identity3];

Data.Functor.Identity.$tc'Identity :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11920310844698764515##
                                    3935129235072617509##
                                    Data.Functor.Identity.$trModule
                                    Data.Functor.Identity.$tc'Identity2
                                    1#
                                    Data.Functor.Identity.$tc'Identity1];

