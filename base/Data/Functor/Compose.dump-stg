
==================== Pre unarise: ====================
2018-03-16 16:12:06.267941915 UTC

$fEq1Compose1_rgdPP
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dEq1_sgdQm
                    $dEq2_sgdQn
                    eq_sgdQo
                    ds_sgdQp
                    ds1_sgdQq]
        let {
          sat_sgdQr [Occ=Once]
            :: g_agdsJ a_agdsP -> g_agdsJ b_agdsQ -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sgdQn eq_sgdQo] \u [] $dEq2_sgdQn eq_sgdQo;
        } in  $dEq1_sgdQm sat_sgdQr ds_sgdQp ds1_sgdQq;

Data.Functor.Compose.$fEq1Compose [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        $fEq1Compose1_rgdPP eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Compose.$fOrd1Compose_$cliftCompare
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdQs $dOrd2_sgdQt comp_sgdQu ds_sgdQv ds1_sgdQw]
        let {
          sat_sgdQx [Occ=Once]
            :: g_agdsk a_agdsu -> g_agdsk b_agdsv -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdQt comp_sgdQu] \u []
                  Data.Functor.Classes.liftCompare $dOrd2_sgdQt comp_sgdQu;
        } in 
          Data.Functor.Classes.liftCompare
              $dOrd1_sgdQs sat_sgdQx ds_sgdQv ds1_sgdQw;

Data.Functor.Compose.$fOrd1Compose1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(U),A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdQy $dOrd2_sgdQz eta_sgdQA eta1_sgdQB eta2_sgdQC]
        let {
          sat_sgdQD [Occ=Once]
            :: g_agdsk a_adwad -> g_agdsk b_adwae -> GHC.Types.Bool
          [LclId] =
              [$dOrd2_sgdQz eta_sgdQA] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sgdQz eta_sgdQA;
        } in 
          Data.Functor.Classes.$p1Ord1
              $dOrd1_sgdQy sat_sgdQD eta1_sgdQB eta2_sgdQC;

Data.Functor.Compose.$fOrd1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(U),C(U))>m] =
    [] \r [$dOrd1_sgdQE $dOrd2_sgdQF]
        let {
          sat_sgdQH [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Compose.Compose f_Xgdux g_Xgduz a
               -> Data.Functor.Compose.Compose f_Xgdux g_Xgduz b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sgdQE $dOrd2_sgdQF] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrd1Compose_$cliftCompare
                      $dOrd1_sgdQE $dOrd2_sgdQF eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdQG [Occ=Once]
            :: Data.Functor.Classes.Eq1
                 (Data.Functor.Compose.Compose f_Xgdux g_Xgduz)
          [LclId] =
              [$dOrd1_sgdQE $dOrd2_sgdQF] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrd1Compose1
                      $dOrd1_sgdQE $dOrd2_sgdQF eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sgdQG sat_sgdQH];

Data.Functor.Compose.$fDataCompose7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Compose"#;

Data.Functor.Compose.$fDataCompose6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Compose.$fDataCompose7;

Data.Functor.Compose.$fRead1Compose2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Compose.$fDataCompose6];

Data.Functor.Compose.$fRead1Compose1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*C1(C1(U)),1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdQI $dRead2_sgdQJ rp_sgdQK rl_sgdQL]
        let {
          reader_sgdQM [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_agdr6 (g_agdr7 a_agdru))
          [LclId] =
              [$dRead1_sgdQI $dRead2_sgdQJ rp_sgdQK rl_sgdQL] \u []
                  let {
                    sat_sgdQO [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [g_agdr7 a_agdru]
                    [LclId] =
                        [$dRead2_sgdQJ rp_sgdQK rl_sgdQL] \u []
                            Data.Functor.Classes.liftReadListPrec
                                $dRead2_sgdQJ rp_sgdQK rl_sgdQL; } in
                  let {
                    sat_sgdQN [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec (g_agdr7 a_agdru)
                    [LclId] =
                        [$dRead2_sgdQJ rp_sgdQK rl_sgdQL] \u []
                            Data.Functor.Classes.liftReadPrec $dRead2_sgdQJ rp_sgdQK rl_sgdQL;
                  } in 
                    Data.Functor.Classes.liftReadPrec
                        $dRead1_sgdQI sat_sgdQN sat_sgdQO; } in
        let {
          $wlvl_sgdQP [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [reader_sgdQM] \r [ww_sgdQQ w_sgdQR]
                  case <=# [ww_sgdQQ 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sgdQW [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sgdH3
                          [LclId] =
                              [reader_sgdQM w_sgdQR] \r [a1_sgdQT]
                                  let {
                                    sat_sgdQV [Occ=Once]
                                      :: f_agdr6 (g_agdr7 a_agdru)
                                         -> Text.ParserCombinators.ReadP.P b_sgdH3
                                    [LclId] =
                                        [w_sgdQR] \r [a2_sgdQU] w_sgdQR a2_sgdQU;
                                  } in  reader_sgdQM Data.Functor.Compose.$fRead1Compose1 sat_sgdQV;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Functor.Compose.$fRead1Compose2 sat_sgdQW
                          of
                          { Unit# ww2_sgdQY [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_sgdQY];
                          };
                  }; } in
        let {
          lvl8_sgdQZ [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sgdQP] \r [w_sgdR0 w1_sgdR1]
                  case w_sgdR0 of {
                    GHC.Types.I# ww1_sgdR3 [Occ=Once] ->
                        $wlvl_sgdQP ww1_sgdR3 w1_sgdR1;
                  }; } in
        let {
          sat_sgdR6 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl8_sgdQZ] \r [eta_sgdR4 eta1_sgdR5]
                  GHC.Read.list3 lvl8_sgdQZ eta_sgdR4 eta1_sgdR5;
        } in  sat_sgdR6;

Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdR7 $dRead2_sgdR8 rp_sgdR9 rl_sgdRa]
        let {
          ds_sgdRb [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
          [LclId] =
              [$dRead1_sgdR7 $dRead2_sgdR8 rp_sgdR9 rl_sgdRa] \u []
                  let {
                    sat_sgdRh [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdrd]
                    [LclId] =
                        [rl_sgdRa] \r [n_sgdRd w1_sgdRe]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sgdRa w1_sgdRe
                            of
                            { Unit# ww1_sgdRg [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sgdRg];
                            }; } in
                  let {
                    sat_sgdRc [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdrd
                    [LclId] =
                        [rp_sgdR9] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sgdR9 eta_B1;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sgdR7 $dRead2_sgdR8 sat_sgdRc sat_sgdRh; } in
        let {
          sat_sgdRk [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
          [LclId] =
              [ds_sgdRb] \r [n_sgdRi]
                  let {
                    sat_sgdRj [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
                    [LclId] =
                        [ds_sgdRb n_sgdRi] \u []
                            ds_sgdRb
                                n_sgdRi Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgdRj;
        } in  sat_sgdRk;

Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdRl $dRead2_sgdRm rp_sgdRn rl_sgdRo]
        let {
          sat_sgdRp [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdsb)
          [LclId] =
              [$dRead1_sgdRl $dRead2_sgdRm rp_sgdRn rl_sgdRo] \s []
                  Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                      $dRead1_sgdRl $dRead2_sgdRm rp_sgdRn rl_sgdRo;
        } in  GHC.Read.list sat_sgdRp;

Data.Functor.Compose.$fRead1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))>m] =
    [] \r [$dRead1_sgdRq $dRead2_sgdRr]
        let {
          sat_sgdRv [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Compose.Compose f_agdr6 g_agdr7 a]
          [LclId] =
              [$dRead1_sgdRq $dRead2_sgdRr] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec
                      $dRead1_sgdRq $dRead2_sgdRr eta_B2 eta_B1; } in
        let {
          sat_sgdRu [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a)
          [LclId] =
              [$dRead1_sgdRq $dRead2_sgdRr] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                      $dRead1_sgdRq $dRead2_sgdRr eta_B2 eta_B1; } in
        let {
          sat_sgdRt [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Compose.Compose f_agdr6 g_agdr7 a]
          [LclId] =
              [$dRead1_sgdRq $dRead2_sgdRr] \u []
                  Data.Functor.Compose.$fRead1Compose_$cliftReadList
                      $dRead1_sgdRq $dRead2_sgdRr; } in
        let {
          sat_sgdRs [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a)
          [LclId] =
              [$dRead1_sgdRq $dRead2_sgdRr] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec
                      $dRead1_sgdRq $dRead2_sgdRr eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sgdRs
                                        sat_sgdRt
                                        sat_sgdRu
                                        sat_sgdRv];
Data.Functor.Compose.$fRead1Compose_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdRw $dRead2_sgdRx]
        let {
          sat_sgdRy [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7)
          [LclId] =
              [$dRead1_sgdRw $dRead2_sgdRx] \u []
                  Data.Functor.Compose.$fRead1Compose $dRead1_sgdRw $dRead2_sgdRx;
        } in  Data.Functor.Classes.liftReadListDefault sat_sgdRy;

Data.Functor.Compose.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> Data.Functor.Compose.Compose f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*C1(C1(U)),1*C1(C1(U)))><L,U><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgdRz w1_sgdRA w2_sgdRB w3_sgdRC ww_sgdRD w4_sgdRE]
        let {
          sat_sgdRH [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sgdHs (g_sgdHt a_sgdHw) -> GHC.Show.ShowS
          [LclId] =
              [w_sgdRz w1_sgdRA w2_sgdRB w3_sgdRC] \s []
                  let {
                    sat_sgdRG [Occ=Once] :: [g_sgdHt a_sgdHw] -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sgdRA w2_sgdRB w3_sgdRC] \u []
                            Data.Functor.Classes.liftShowList w1_sgdRA w2_sgdRB w3_sgdRC; } in
                  let {
                    sat_sgdRF [Occ=Once]
                      :: GHC.Types.Int -> g_sgdHt a_sgdHw -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sgdRA w2_sgdRB w3_sgdRC] \u []
                            Data.Functor.Classes.liftShowsPrec w1_sgdRA w2_sgdRB w3_sgdRC;
                  } in 
                    Data.Functor.Classes.liftShowsPrec w_sgdRz sat_sgdRF sat_sgdRG;
        } in 
          Data.Functor.Classes.$wshowsUnaryWith
              sat_sgdRH Data.Functor.Compose.$fDataCompose6 ww_sgdRD w4_sgdRE;

Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Compose.Compose f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgdRI w1_sgdRJ w2_sgdRK w3_sgdRL w4_sgdRM w5_sgdRN]
        case w4_sgdRM of {
          GHC.Types.I# ww1_sgdRP [Occ=Once] ->
              Data.Functor.Compose.$w$cliftShowsPrec
                  w_sgdRI w1_sgdRJ w2_sgdRK w3_sgdRL ww1_sgdRP w5_sgdRN;
        };

Data.Functor.Compose.$fDataCompose3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Compose.$fShow1Compose_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Compose.Compose f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgdRQ
           $dShow2_sgdRR
           sp_sgdRS
           sl_sgdRT
           eta_sgdRU
           eta1_sgdRV]
        let {
          sat_sgdRX [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdqk g_agdql a_agdqZ
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdRQ $dShow2_sgdRR sp_sgdRS sl_sgdRT] \r [w_sgdRW]
                  Data.Functor.Compose.$w$cliftShowsPrec
                      $dShow1_sgdRQ $dShow2_sgdRR sp_sgdRS sl_sgdRT 0# w_sgdRW;
        } in  GHC.Show.showList__ sat_sgdRX eta_sgdRU eta1_sgdRV;

Data.Functor.Compose.$fShow1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))>m] =
    [] \r [$dShow1_sgdRY $dShow2_sgdRZ]
        let {
          sat_sgdS1 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Compose.Compose f_agdqk g_agdql a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdRY $dShow2_sgdRZ] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fShow1Compose_$cliftShowList
                      $dShow1_sgdRY $dShow2_sgdRZ eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdS0 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Compose.Compose f_agdqk g_agdql a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdRY $dShow2_sgdRZ] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec
                      $dShow1_sgdRY $dShow2_sgdRZ eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sgdS0 sat_sgdS1];

Data.Functor.Compose.$fEqCompose_$c==
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,1*U(1*U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgdS2 $dEq2_sgdS3 $dEq_sgdS4 eta_sgdS5 eta1_sgdS6]
        let {
          sat_sgdS8 [Occ=Once]
            :: g_agdq0 a_agdq1 -> g_agdq0 a_agdq1 -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sgdS3 $dEq_sgdS4] \u []
                  let {
                    sat_sgdS7 [Occ=Once] :: a_agdq1 -> a_agdq1 -> GHC.Types.Bool
                    [LclId] =
                        [$dEq_sgdS4] \u [] GHC.Classes.== $dEq_sgdS4;
                  } in  $dEq2_sgdS3 sat_sgdS7;
        } in  $dEq1_sgdS2 sat_sgdS8 eta_sgdS5 eta1_sgdS6;

Data.Functor.Compose.$fEqCompose_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,1*U(1*U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgdS9 $dEq2_sgdSa $dEq_sgdSb eta_sgdSc eta1_sgdSd]
        let {
          sat_sgdSf [Occ=Once]
            :: g_agdq0 a_agdq1 -> g_agdq0 a_agdq1 -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sgdSa $dEq_sgdSb] \u []
                  let {
                    sat_sgdSe [Occ=Once] :: a_agdq1 -> a_agdq1 -> GHC.Types.Bool
                    [LclId] =
                        [$dEq_sgdSb] \u [] GHC.Classes.== $dEq_sgdSb;
                  } in  $dEq2_sgdSa sat_sgdSe;
        } in 
          case $dEq1_sgdS9 sat_sgdSf eta_sgdSc eta1_sgdSd of {
            GHC.Types.False -> GHC.Types.True [];
            GHC.Types.True -> GHC.Types.False [];
          };

Data.Functor.Compose.$fEqCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(U)><L,U(U,A)>m] =
    [] \r [$dEq1_sgdSh $dEq2_sgdSi $dEq_sgdSj]
        let {
          sat_sgdSl [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgdSh $dEq2_sgdSi $dEq_sgdSj] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fEqCompose_$c/=
                      $dEq1_sgdSh $dEq2_sgdSi $dEq_sgdSj eta_B2 eta_B1; } in
        let {
          sat_sgdSk [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgdSh $dEq2_sgdSi $dEq_sgdSj] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fEqCompose_$c==
                      $dEq1_sgdSh $dEq2_sgdSi $dEq_sgdSj eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sgdSk sat_sgdSl];

Data.Functor.Compose.$fOrdCompose_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSm $dOrd2_sgdSn $dOrd_sgdSo eta_sgdSp eta1_sgdSq]
        let {
          sat_sgdSs [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdSn $dOrd_sgdSo] \u []
                  let {
                    sat_sgdSr [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdSo] \u [] GHC.Classes.compare $dOrd_sgdSo;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdSn sat_sgdSr;
        } in 
          Data.Functor.Classes.liftCompare
              $dOrd1_sgdSm sat_sgdSs eta_sgdSp eta1_sgdSq;

Data.Functor.Compose.$fOrdCompose_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(U),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSt $dOrd2_sgdSu $dOrd_sgdSv]
        let {
          sat_sgdSy [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_agdpd
          [LclId] =
              [$dOrd_sgdSv] \u [] GHC.Classes.$p1Ord $dOrd_sgdSv; } in
        let {
          sat_sgdSx [Occ=Once, Dmd=<L,C(U)>]
            :: Data.Functor.Classes.Eq1 g_agdpc
          [LclId] =
              [$dOrd2_sgdSu] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sgdSu; } in
        let {
          sat_sgdSw [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_agdpb
          [LclId] =
              [$dOrd1_sgdSt] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sgdSt;
        } in 
          Data.Functor.Compose.$fEqCompose sat_sgdSw sat_sgdSx sat_sgdSy;

Data.Functor.Compose.$fOrdCompose_$c<
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSz $dOrd2_sgdSA $dOrd_sgdSB x_sgdSC y_sgdSD]
        let {
          sat_sgdSF [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdSA $dOrd_sgdSB] \u []
                  let {
                    sat_sgdSE [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdSB] \u [] GHC.Classes.compare $dOrd_sgdSB;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdSA sat_sgdSE;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdSz sat_sgdSF x_sgdSC y_sgdSD
          of
          { __DEFAULT -> GHC.Types.False [];
            GHC.Types.LT -> GHC.Types.True [];
          };

Data.Functor.Compose.$fOrdCompose_$c>=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSH $dOrd2_sgdSI $dOrd_sgdSJ x_sgdSK y_sgdSL]
        let {
          sat_sgdSN [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdSI $dOrd_sgdSJ] \u []
                  let {
                    sat_sgdSM [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdSJ] \u [] GHC.Classes.compare $dOrd_sgdSJ;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdSI sat_sgdSM;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdSH sat_sgdSN x_sgdSK y_sgdSL
          of
          { __DEFAULT -> GHC.Types.True [];
            GHC.Types.LT -> GHC.Types.False [];
          };

Data.Functor.Compose.$fOrdCompose_$c>
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSP $dOrd2_sgdSQ $dOrd_sgdSR x_sgdSS y_sgdST]
        let {
          sat_sgdSV [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdSQ $dOrd_sgdSR] \u []
                  let {
                    sat_sgdSU [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdSR] \u [] GHC.Classes.compare $dOrd_sgdSR;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdSQ sat_sgdSU;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdSP sat_sgdSV x_sgdSS y_sgdST
          of
          { __DEFAULT -> GHC.Types.False [];
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Compose.$fOrdCompose_$c<=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSX $dOrd2_sgdSY $dOrd_sgdSZ x_sgdT0 y_sgdT1]
        let {
          sat_sgdT3 [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdSY $dOrd_sgdSZ] \u []
                  let {
                    sat_sgdT2 [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdSZ] \u [] GHC.Classes.compare $dOrd_sgdSZ;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdSY sat_sgdT2;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdSX sat_sgdT3 x_sgdT0 y_sgdT1
          of
          { __DEFAULT -> GHC.Types.True [];
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Compose.$fOrdCompose_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdT5 $dOrd2_sgdT6 $dOrd_sgdT7 x_sgdT8 y_sgdT9]
        let {
          sat_sgdTb [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdT6 $dOrd_sgdT7] \u []
                  let {
                    sat_sgdTa [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdT7] \u [] GHC.Classes.compare $dOrd_sgdT7;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdT6 sat_sgdTa;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdT5 sat_sgdTb x_sgdT8 y_sgdT9
          of
          { __DEFAULT -> y_sgdT9;
            GHC.Types.GT -> x_sgdT8;
          };

Data.Functor.Compose.$fOrdCompose_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdTd $dOrd2_sgdTe $dOrd_sgdTf x_sgdTg y_sgdTh]
        let {
          sat_sgdTj [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdTe $dOrd_sgdTf] \u []
                  let {
                    sat_sgdTi [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdTf] \u [] GHC.Classes.compare $dOrd_sgdTf;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdTe sat_sgdTi;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdTd sat_sgdTj x_sgdTg y_sgdTh
          of
          { __DEFAULT -> x_sgdTg;
            GHC.Types.GT -> y_sgdTh;
          };

Data.Functor.Compose.$fOrdCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(U),C(U))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn]
        let {
          sat_sgdTv [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$cmin
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTu [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$cmax
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTt [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c>=
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTs [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c>
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTr [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c<=
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTq [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c<
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTp [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$ccompare
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTo [Occ=Once]
            :: GHC.Classes.Eq
                 (Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd)
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \u []
                  Data.Functor.Compose.$fOrdCompose_$cp1Ord
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn;
        } in 
          GHC.Classes.C:Ord [sat_sgdTo
                             sat_sgdTp
                             sat_sgdTq
                             sat_sgdTr
                             sat_sgdTs
                             sat_sgdTt
                             sat_sgdTu
                             sat_sgdTv];

Data.Functor.Compose.$fReadCompose_$creadPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdTw $dRead2_sgdTx $dRead_sgdTy]
        let {
          sat_sgdTA [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
          [LclId] =
              [$dRead_sgdTy] \u [] GHC.Read.readListPrec $dRead_sgdTy; } in
        let {
          sat_sgdTz [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
          [LclId] =
              [$dRead_sgdTy] \u [] GHC.Read.readPrec $dRead_sgdTy;
        } in 
          Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
              $dRead1_sgdTw $dRead2_sgdTx sat_sgdTz sat_sgdTA;

Data.Functor.Compose.$fReadCompose_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdTB $dRead2_sgdTC $dRead_sgdTD]
        let {
          ds_sgdTE [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgdTB $dRead2_sgdTC $dRead_sgdTD] \u []
                  let {
                    sat_sgdTG [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
                    [LclId] =
                        [$dRead_sgdTD] \u [] GHC.Read.readListPrec $dRead_sgdTD; } in
                  let {
                    sat_sgdTF [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
                    [LclId] =
                        [$dRead_sgdTD] \u [] GHC.Read.readPrec $dRead_sgdTD;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sgdTB $dRead2_sgdTC sat_sgdTF sat_sgdTG; } in
        let {
          sat_sgdTJ [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [ds_sgdTE] \r [n_sgdTH]
                  let {
                    sat_sgdTI [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
                    [LclId] =
                        [ds_sgdTE n_sgdTH] \u []
                            ds_sgdTE
                                n_sgdTH Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgdTI;
        } in  sat_sgdTJ;

Data.Functor.Compose.$fReadCompose_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdTK $dRead2_sgdTL $dRead_sgdTM]
        let {
          sat_sgdTP [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgdTK $dRead2_sgdTL $dRead_sgdTM] \s []
                  let {
                    sat_sgdTO [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
                    [LclId] =
                        [$dRead_sgdTM] \u [] GHC.Read.readListPrec $dRead_sgdTM; } in
                  let {
                    sat_sgdTN [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
                    [LclId] =
                        [$dRead_sgdTM] \u [] GHC.Read.readPrec $dRead_sgdTM;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sgdTK $dRead2_sgdTL sat_sgdTN sat_sgdTO;
        } in  GHC.Read.list sat_sgdTP;

Data.Functor.Compose.$fReadCompose_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdTQ $dRead2_sgdTR $dRead_sgdTS]
        let {
          sat_sgdTT [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgdTQ $dRead2_sgdTR $dRead_sgdTS] \u []
                  Data.Functor.Compose.$fReadCompose_$creadListPrec
                      $dRead1_sgdTQ
                      $dRead2_sgdTR
                      $dRead_sgdTS
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgdTT;

Data.Functor.Compose.$fReadCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW]
        let {
          sat_sgdU0 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW] \u []
                  Data.Functor.Compose.$fReadCompose_$creadListPrec
                      $dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW; } in
        let {
          sat_sgdTZ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW] \u []
                  Data.Functor.Compose.$fReadCompose_$creadPrec
                      $dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW; } in
        let {
          sat_sgdTY [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW] \u []
                  Data.Functor.Compose.$fReadCompose_$creadList
                      $dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW; } in
        let {
          sat_sgdTX [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW] \u []
                  Data.Functor.Compose.$fReadCompose_$creadsPrec
                      $dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW;
        } in  GHC.Read.C:Read [sat_sgdTX sat_sgdTY sat_sgdTZ sat_sgdU0];

Data.Functor.Compose.$fShowCompose_$cshowsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int
     -> Data.Functor.Compose.Compose f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(1*U,A,1*U)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgdU1
           $dShow2_sgdU2
           $dShow_sgdU3
           eta_sgdU4
           eta1_sgdU5]
        case eta_sgdU4 of {
          GHC.Types.I# ww1_sgdU7 [Occ=Once] ->
              let {
                sat_sgdU9 [Occ=Once] :: [a_agdog] -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sgdU3] \u [] GHC.Show.showList $dShow_sgdU3; } in
              let {
                sat_sgdU8 [Occ=Once] :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sgdU3] \u [] GHC.Show.showsPrec $dShow_sgdU3;
              } in 
                Data.Functor.Compose.$w$cliftShowsPrec
                    $dShow1_sgdU1
                    $dShow2_sgdU2
                    sat_sgdU8
                    sat_sgdU9
                    ww1_sgdU7
                    eta1_sgdU5;
        };

Data.Functor.Compose.$fShowCompose_$cshow
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Compose.Compose f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*C1(C1(U)),1*C1(C1(U)))><L,U(1*U,A,1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgdUa $dShow2_sgdUb $dShow_sgdUc x_sgdUd]
        let {
          sp_sgdUe :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgdUc] \u [] GHC.Show.showsPrec $dShow_sgdUc; } in
        let {
          sl_sgdUf :: [a_agdog] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgdUc] \u [] GHC.Show.showList $dShow_sgdUc; } in
        let {
          sat_sgdUi [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow1_sgdUa $dShow2_sgdUb x_sgdUd sp_sgdUe sl_sgdUf] \u []
                  let {
                    sat_sgdUh [Occ=Once] :: [g_agdof a_agdog] -> GHC.Show.ShowS
                    [LclId] =
                        [$dShow2_sgdUb sp_sgdUe sl_sgdUf] \u []
                            Data.Functor.Classes.liftShowList
                                $dShow2_sgdUb sp_sgdUe sl_sgdUf; } in
                  let {
                    sat_sgdUg [Occ=Once]
                      :: GHC.Types.Int -> g_agdof a_agdog -> GHC.Show.ShowS
                    [LclId] =
                        [$dShow2_sgdUb sp_sgdUe sl_sgdUf] \u []
                            Data.Functor.Classes.liftShowsPrec $dShow2_sgdUb sp_sgdUe sl_sgdUf;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        $dShow1_sgdUa
                        sat_sgdUg
                        sat_sgdUh
                        Data.Functor.Classes.$fRead1Const1
                        x_sgdUd
                        GHC.Types.[]; } in
        let {
          sat_sgdUj [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sgdUi];
        } in  GHC.Base.++ Data.Functor.Compose.$fDataCompose6 sat_sgdUj;

Data.Functor.Compose.$fShowCompose_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Compose.Compose f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgdUk $dShow2_sgdUl $dShow_sgdUm ls_sgdUn s_sgdUo]
        let {
          lvl8_sgdUp [Occ=OnceL]
            :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgdUm] \u [] GHC.Show.showsPrec $dShow_sgdUm; } in
        let {
          lvl9_sgdUq [Occ=OnceL] :: [a_agdog] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgdUm] \u [] GHC.Show.showList $dShow_sgdUm; } in
        let {
          sat_sgdUs [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdUk $dShow2_sgdUl lvl8_sgdUp lvl9_sgdUq] \r [eta_sgdUr]
                  Data.Functor.Compose.$w$cliftShowsPrec
                      $dShow1_sgdUk $dShow2_sgdUl lvl8_sgdUp lvl9_sgdUq 0# eta_sgdUr;
        } in  GHC.Show.showList__ sat_sgdUs ls_sgdUn s_sgdUo;

Data.Functor.Compose.$fShowCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(U,A,U)>m] =
    [] \r [$dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv]
        let {
          sat_sgdUy [Occ=Once]
            :: [Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshowList
                      $dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv eta_B2 eta_B1; } in
        let {
          sat_sgdUx [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Base.String
          [LclId] =
              [$dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv] \r [eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshow
                      $dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv eta_B1; } in
        let {
          sat_sgdUw [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshowsPrec
                      $dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgdUw sat_sgdUx sat_sgdUy];

Data.Functor.Compose.$fFunctorCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b) -> Data.Functor.Compose.Compose f g a -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgdUz $dFunctor1_sgdUA f1_sgdUB ds_sgdUC]
        let {
          sat_sgdUD [Occ=Once] :: g_agdnF a_agdnL -> g_agdnF b_agdnM
          [LclId] =
              [$dFunctor1_sgdUA f1_sgdUB] \u []
                  GHC.Base.fmap $dFunctor1_sgdUA f1_sgdUB;
        } in  GHC.Base.fmap $dFunctor_sgdUz sat_sgdUD ds_sgdUC;

Data.Functor.Compose.$fFunctorCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b. a -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgdUE $dFunctor1_sgdUF x_sgdUG eta_sgdUH]
        let {
          sat_sgdUK [Occ=Once] :: g_Xgdqn b_agdo6 -> g_Xgdqn a_agdo5
          [LclId] =
              [$dFunctor1_sgdUF x_sgdUG] \u []
                  let {
                    sat_sgdUJ [Occ=Once] :: b_agdo6 -> a_agdo5
                    [LclId] =
                        [x_sgdUG] \r [ds_sgdUI] x_sgdUG;
                  } in  GHC.Base.fmap $dFunctor1_sgdUF sat_sgdUJ;
        } in  GHC.Base.fmap $dFunctor_sgdUE sat_sgdUK eta_sgdUH;

Data.Functor.Compose.$fFunctorCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgdUL $dFunctor1_sgdUM]
        let {
          sat_sgdUO [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm b
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm a
          [LclId] =
              [$dFunctor_sgdUL $dFunctor1_sgdUM] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFunctorCompose1
                      $dFunctor_sgdUL $dFunctor1_sgdUM eta_B2 eta_B1; } in
        let {
          sat_sgdUN [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm a
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm b
          [LclId] =
              [$dFunctor_sgdUL $dFunctor1_sgdUM] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFunctorCompose2
                      $dFunctor_sgdUL $dFunctor1_sgdUM eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sgdUN sat_sgdUO];

Data.Functor.Compose.$fFoldableCompose_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Compose.Compose f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdUP
           $dFoldable1_sgdUQ
           $dMonoid_sgdUR
           f1_sgdUS
           ds_sgdUT]
        let {
          sat_sgdUU [Occ=Once] :: g_agdl1 a_agdli -> m_agdlh
          [LclId] =
              [$dFoldable1_sgdUQ $dMonoid_sgdUR f1_sgdUS] \u []
                  Data.Foldable.foldMap $dFoldable1_sgdUQ $dMonoid_sgdUR f1_sgdUS;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdUP $dMonoid_sgdUR sat_sgdUU ds_sgdUT;

Data.Functor.Compose.$fFoldableCompose_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Compose.Compose f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdUV $dFoldable1_sgdUW $dMonoid_sgdUX ds_sgdUY]
        let {
          sat_sgdUZ [Occ=Once] :: g_agdl1 m_agdl7 -> m_agdl7
          [LclId] =
              [$dFoldable1_sgdUW $dMonoid_sgdUX] \u []
                  Data.Foldable.foldMap $dFoldable1_sgdUW $dMonoid_sgdUX GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdUV $dMonoid_sgdUX sat_sgdUZ ds_sgdUY;

Data.Functor.Compose.$fFoldableCompose1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgdV0] v_sgdV0;

Data.Functor.Compose.$fFoldableCompose_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdV1 $dFoldable1_sgdV2 $dNum_sgdV3]
        let {
          $dMonoid_sgdV4
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_agdnl)
          [LclId] =
              [$dNum_sgdV3] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sgdV3; } in
        let {
          lvl8_sgdV5 [Occ=OnceL]
            :: g_agdl1 a_agdnl -> Data.Semigroup.Internal.Sum a_agdnl
          [LclId] =
              [$dFoldable1_sgdV2 $dMonoid_sgdV4] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdV2
                      $dMonoid_sgdV4
                      Data.Functor.Compose.$fFoldableCompose1; } in
        let {
          sat_sgdV7 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnl
               -> Data.Semigroup.Internal.Sum a_agdnl
          [LclId] =
              [$dFoldable_sgdV1 $dMonoid_sgdV4 lvl8_sgdV5] \r [ds_sgdV6]
                  Data.Foldable.foldMap
                      $dFoldable_sgdV1 $dMonoid_sgdV4 lvl8_sgdV5 ds_sgdV6;
        } in  sat_sgdV7;

lvl_rgdPQ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Compose.$fFoldableCompose2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rgdPQ of sat_sgdV8 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgdV8;
        };

Data.Functor.Compose.$fFoldableCompose_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdV9 $dFoldable1_sgdVa $dOrd_sgdVb]
        let {
          $dMonoid_sgdVc :: GHC.Base.Monoid (Data.Functor.Utils.Min a_agdnb)
          [LclId] =
              [$dOrd_sgdVb] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sgdVb; } in
        let {
          lvl8_sgdVd [Occ=OnceL]
            :: g_agdl1 a_agdnb -> Data.Functor.Utils.Min a_agdnb
          [LclId] =
              [$dFoldable1_sgdVa $dMonoid_sgdVc] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdVa $dMonoid_sgdVc GHC.Base.Just; } in
        let {
          sat_sgdVh [Occ=OnceT[0]]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnb -> a_agdnb
          [LclId] =
              [$dFoldable_sgdV9 $dMonoid_sgdVc lvl8_sgdVd] \r [x_sgdVe]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_sgdV9 $dMonoid_sgdVc lvl8_sgdVd x_sgdVe
                  of
                  { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose2;
                    GHC.Base.Just v_sgdVg [Occ=Once] -> v_sgdVg;
                  };
        } in  sat_sgdVh;

lvl1_rgdPR :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Compose.$fFoldableCompose3 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rgdPR of sat_sgdVi {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgdVi;
        };

Data.Functor.Compose.$fFoldableCompose_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdVj $dFoldable1_sgdVk $dOrd_sgdVl]
        let {
          $dMonoid_sgdVm :: GHC.Base.Monoid (Data.Functor.Utils.Max a_agdn1)
          [LclId] =
              [$dOrd_sgdVl] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sgdVl; } in
        let {
          lvl8_sgdVn [Occ=OnceL]
            :: g_agdl1 a_agdn1 -> Data.Functor.Utils.Max a_agdn1
          [LclId] =
              [$dFoldable1_sgdVk $dMonoid_sgdVm] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdVk $dMonoid_sgdVm GHC.Base.Just; } in
        let {
          sat_sgdVr [Occ=OnceT[0]]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdn1 -> a_agdn1
          [LclId] =
              [$dFoldable_sgdVj $dMonoid_sgdVm lvl8_sgdVn] \r [x_sgdVo]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_sgdVj $dMonoid_sgdVm lvl8_sgdVn x_sgdVo
                  of
                  { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose3;
                    GHC.Base.Just v_sgdVq [Occ=Once] -> v_sgdVq;
                  };
        } in  sat_sgdVr;

Data.Functor.Compose.$fFoldableCompose_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdVs $dFoldable1_sgdVt $dEq_sgdVu eta_sgdVv]
        let {
          lvl8_sgdVw [Occ=OnceL]
            :: g_agdl1 a_agdmR -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable1_sgdVt $dEq_sgdVu eta_sgdVv] \u []
                  let {
                    sat_sgdVx [Occ=Once] :: a_agdmR -> Data.Semigroup.Internal.Any
                    [LclId] =
                        [$dEq_sgdVu eta_sgdVv] \u [] GHC.Classes.== $dEq_sgdVu eta_sgdVv;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdVt
                        Data.Semigroup.Internal.$fMonoidAny
                        sat_sgdVx; } in
        let {
          sat_sgdVz [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdmR
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sgdVs lvl8_sgdVw] \r [ds_sgdVy]
                  Data.Foldable.foldMap
                      $dFoldable_sgdVs
                      Data.Semigroup.Internal.$fMonoidAny
                      lvl8_sgdVw
                      ds_sgdVy;
        } in  sat_sgdVz;

Data.Functor.Compose.$fFoldableCompose7
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Compose.$fFoldableCompose_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdVA
           $dFoldable1_sgdVB
           f1_sgdVC
           z_sgdVD
           t1_sgdVE]
        let {
          sat_sgdVI [Occ=Once]
            :: g_agdl1 a_agdlU
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_agdlT)
          [LclId] =
              [$dFoldable1_sgdVB f1_sgdVC] \u []
                  let {
                    sat_sgdVH [Occ=Once]
                      :: a_agdlU
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo b_agdlT)
                    [LclId] =
                        [f1_sgdVC] \r [x_sgdVF y_sgdVG] f1_sgdVC y_sgdVG x_sgdVF;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdVB
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgdVH;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdVA
              Data.Functor.Compose.$fFoldableCompose7
              sat_sgdVI
              t1_sgdVE
              z_sgdVD;

lvl2_rgdPS :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Compose.$fFoldableCompose6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rgdPS of sat_sgdVJ {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgdVJ;
        };

Data.Functor.Compose.$fFoldableCompose_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdVK $dFoldable1_sgdVL f1_sgdVM xs_sgdVN]
        let {
          sat_sgdVU [Occ=Once]
            :: g_agdl1 a_agdml
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdml))
          [LclId] =
              [$dFoldable1_sgdVL f1_sgdVM] \u []
                  let {
                    sat_sgdVT [Occ=Once]
                      :: a_agdml
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdml))
                    [LclId] =
                        [f1_sgdVM] \r [x_sgdVO y_sgdVP]
                            let {
                              sat_sgdVS [Occ=Once] :: a_agdml
                              [LclId] =
                                  [f1_sgdVM x_sgdVO y_sgdVP] \u []
                                      case y_sgdVP of {
                                        GHC.Base.Nothing -> x_sgdVO;
                                        GHC.Base.Just x1_sgdVR [Occ=Once] ->
                                            f1_sgdVM x1_sgdVR x_sgdVO;
                                      };
                            } in  GHC.Base.Just [sat_sgdVS];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdVL
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgdVT;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_sgdVK
                  Data.Functor.Compose.$fFoldableCompose7
                  sat_sgdVU
                  xs_sgdVN
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose6;
            GHC.Base.Just v_sgdVW [Occ=Once] -> v_sgdVW;
          };

Data.Functor.Compose.$fFoldableCompose_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdVX
           $dFoldable1_sgdVY
           f1_sgdVZ
           z0_sgdW0
           xs_sgdW1]
        let {
          sat_sgdW7 [Occ=Once]
            :: g_agdl1 a_agdlJ
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_agdlK -> b_agdlK))
          [LclId] =
              [$dFoldable1_sgdVY f1_sgdVZ] \u []
                  let {
                    sat_sgdW6 [Occ=Once]
                      :: a_agdlJ
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (b_agdlK -> b_agdlK))
                    [LclId] =
                        [f1_sgdVZ] \r [x_sgdW2 y_sgdW3 z_sgdW4]
                            case f1_sgdVZ x_sgdW2 z_sgdW4 of vx_sgdW5 {
                              __DEFAULT -> y_sgdW3 vx_sgdW5;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdVY
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgdW6;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdVX
              Data.Functor.Compose.$fFoldableCompose7
              sat_sgdW7
              xs_sgdW1
              GHC.Base.id
              z0_sgdW0;

Data.Functor.Compose.$fFoldableCompose_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdW8
           $dFoldable1_sgdW9
           f1_sgdWa
           z_sgdWb
           t1_sgdWc]
        let {
          sat_sgdWd [Occ=Once]
            :: g_agdl1 a_agdlz -> Data.Semigroup.Internal.Endo b_agdlA
          [LclId] =
              [$dFoldable1_sgdW9 f1_sgdWa] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdW9 Data.Semigroup.Internal.$fMonoidEndo f1_sgdWa;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdW8
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgdWd
              t1_sgdWc
              z_sgdWb;

Data.Functor.Compose.$fFoldableCompose_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdWe
           $dFoldable1_sgdWf
           f1_sgdWg
           z0_sgdWh
           xs_sgdWi]
        let {
          sat_sgdWo [Occ=Once]
            :: g_agdl1 a_agdm4
               -> Data.Semigroup.Internal.Endo (b_agdm3 -> b_agdm3)
          [LclId] =
              [$dFoldable1_sgdWf f1_sgdWg] \u []
                  let {
                    sat_sgdWn [Occ=Once]
                      :: a_agdm4 -> Data.Semigroup.Internal.Endo (b_agdm3 -> b_agdm3)
                    [LclId] =
                        [f1_sgdWg] \r [x_sgdWj k_sgdWk z_sgdWl]
                            case f1_sgdWg z_sgdWl x_sgdWj of vx_sgdWm {
                              __DEFAULT -> k_sgdWk vx_sgdWm;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdWf Data.Semigroup.Internal.$fMonoidEndo sat_sgdWn;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdWe
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgdWo
              xs_sgdWi
              GHC.Base.id
              z0_sgdWh;

Data.Functor.Compose.$fFoldableCompose4
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sgdWp k_sgdWq z_sgdWr]
        case z_sgdWr of {
          GHC.Types.I# x1_sgdWt [Occ=Once] ->
              case +# [x1_sgdWt 1#] of sat_sgdWu {
                __DEFAULT ->
                    let {
                      sat_sgdWv [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sgdWu];
                    } in  k_sgdWq sat_sgdWv;
              };
        };

Data.Functor.Compose.$fFoldableCompose_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdWw $dFoldable1_sgdWx eta_sgdWy]
        let {
          sat_sgdWz [Occ=Once]
            :: g_agdl1 a_agdmJ
               -> Data.Semigroup.Internal.Endo (GHC.Types.Int -> GHC.Types.Int)
          [LclId] =
              [$dFoldable1_sgdWx] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdWx
                      Data.Semigroup.Internal.$fMonoidEndo
                      Data.Functor.Compose.$fFoldableCompose4;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdWw
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgdWz
              eta_sgdWy
              GHC.Base.id
              Data.Functor.Compose.$fDataCompose3;

lvl3_rgdPT :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Compose.$fFoldableCompose8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rgdPT of sat_sgdWA {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgdWA;
        };

Data.Functor.Compose.$fFoldableCompose_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdWB $dFoldable1_sgdWC f1_sgdWD xs_sgdWE]
        let {
          sat_sgdWL [Occ=Once]
            :: g_agdl1 a_agdmd
               -> Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdmd)
          [LclId] =
              [$dFoldable1_sgdWC f1_sgdWD] \u []
                  let {
                    sat_sgdWK [Occ=Once]
                      :: a_agdmd -> Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdmd)
                    [LclId] =
                        [f1_sgdWD] \r [x_sgdWF m_sgdWG]
                            let {
                              sat_sgdWJ [Occ=Once] :: a_agdmd
                              [LclId] =
                                  [f1_sgdWD x_sgdWF m_sgdWG] \u []
                                      case m_sgdWG of {
                                        GHC.Base.Nothing -> x_sgdWF;
                                        GHC.Base.Just y_sgdWI [Occ=Once] ->
                                            f1_sgdWD x_sgdWF y_sgdWI;
                                      };
                            } in  GHC.Base.Just [sat_sgdWJ];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdWC Data.Semigroup.Internal.$fMonoidEndo sat_sgdWK;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_sgdWB
                  Data.Semigroup.Internal.$fMonoidEndo
                  sat_sgdWL
                  xs_sgdWE
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose8;
            GHC.Base.Just v_sgdWN [Occ=Once] -> v_sgdWN;
          };

Data.Functor.Compose.$fFoldableCompose5
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgdWO ds1_sgdWP] GHC.Types.False [];

Data.Functor.Compose.$fFoldableCompose_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdWQ $dFoldable1_sgdWR eta_sgdWS]
        let {
          sat_sgdWT [Occ=Once]
            :: g_agdl1 a_agdmB -> Data.Semigroup.Internal.Endo GHC.Types.Bool
          [LclId] =
              [$dFoldable1_sgdWR] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdWR
                      Data.Semigroup.Internal.$fMonoidEndo
                      Data.Functor.Compose.$fFoldableCompose5;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdWQ
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgdWT
              eta_sgdWS
              GHC.Types.True;

Data.Functor.Compose.$fFoldableCompose_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdWU $dFoldable1_sgdWV $dNum_sgdWW]
        let {
          $dMonoid_sgdWX
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_agdnv)
          [LclId] =
              [$dNum_sgdWW] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sgdWW; } in
        let {
          lvl8_sgdWY [Occ=OnceL]
            :: g_agdl1 a_agdnv -> Data.Semigroup.Internal.Product a_agdnv
          [LclId] =
              [$dFoldable1_sgdWV $dMonoid_sgdWX] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdWV
                      $dMonoid_sgdWX
                      Data.Functor.Compose.$fFoldableCompose1; } in
        let {
          sat_sgdX0 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnv
               -> Data.Semigroup.Internal.Product a_agdnv
          [LclId] =
              [$dFoldable_sgdWU $dMonoid_sgdWX lvl8_sgdWY] \r [ds_sgdWZ]
                  Data.Foldable.foldMap
                      $dFoldable_sgdWU $dMonoid_sgdWX lvl8_sgdWY ds_sgdWZ;
        } in  sat_sgdX0;

Data.Functor.Compose.$fFoldableCompose_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> [a]
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdX1 $dFoldable1_sgdX2 eta_sgdX3]
        let {
          sat_sgdX4 [Occ=Once]
            :: g_agdl1 a_agdmt -> Data.Semigroup.Internal.Endo [a_agdmt]
          [LclId] =
              [$dFoldable1_sgdX2] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdX2 Data.Semigroup.Internal.$fMonoidEndo GHC.Types.:;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdX1
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgdX4
              eta_sgdX3
              GHC.Types.[];

Data.Functor.Compose.$fFoldableCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sgdX5 $dFoldable1_sgdX6]
        let {
          sat_sgdXm [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cproduct
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXl [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$csum
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXk [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cminimum
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXj [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cmaximum
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXi [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$celem
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B2 eta_B1; } in
        let {
          sat_sgdXh [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$clength
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXg [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cnull
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXf [Occ=Once]
            :: forall a. Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> [a]
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$ctoList
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXe [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl1
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B2 eta_B1; } in
        let {
          sat_sgdXd [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr1
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B2 eta_B1; } in
        let {
          sat_sgdXc [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl'
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdXb [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdXa [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr'
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdX9 [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdX8 [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> m
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldMap
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdX7 [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 m -> m
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfold
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sgdX7
                                    sat_sgdX8
                                    sat_sgdX9
                                    sat_sgdXa
                                    sat_sgdXb
                                    sat_sgdXc
                                    sat_sgdXd
                                    sat_sgdXe
                                    sat_sgdXf
                                    sat_sgdXg
                                    sat_sgdXh
                                    sat_sgdXi
                                    sat_sgdXj
                                    sat_sgdXk
                                    sat_sgdXl
                                    sat_sgdXm];

Data.Functor.Compose.$fTraversableCompose1
  :: forall (f :: * -> *) (g :: * -> *) b. f (g b) -> f (g b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgdXn] v_sgdXn;

Data.Functor.Compose.$fTraversableCompose_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Compose.Compose f g a
     -> f1 (Data.Functor.Compose.Compose f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXo
           $dTraversable1_sgdXp
           $dApplicative_sgdXq
           eta_sgdXr
           eta1_sgdXs]
        let {
          sat_sgdXv [Occ=Once] :: f1_agdjV (f_agdjG (g_agdjH b_agdjX))
          [LclId] =
              [$dTraversable_sgdXo
               $dTraversable1_sgdXp
               $dApplicative_sgdXq
               eta_sgdXr
               eta1_sgdXs] \u []
                  let {
                    sat_sgdXu [Occ=Once]
                      :: g_agdjH a_agdjW -> f1_agdjV (g_agdjH b_agdjX)
                    [LclId] =
                        [$dTraversable1_sgdXp $dApplicative_sgdXq eta_sgdXr] \u []
                            Data.Traversable.traverse
                                $dTraversable1_sgdXp $dApplicative_sgdXq eta_sgdXr;
                  } in 
                    Data.Traversable.traverse
                        $dTraversable_sgdXo $dApplicative_sgdXq sat_sgdXu eta1_sgdXs;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sgdXq of sat_sgdXt {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sgdXt Data.Functor.Compose.$fTraversableCompose1 sat_sgdXv;
          };

Data.Functor.Compose.$fTraversableCompose_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXw $dTraversable1_sgdXx]
        let {
          sat_sgdXz [Occ=Once,
                     Dmd=<L,U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_agdjH
          [LclId] =
              [$dTraversable1_sgdXx] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sgdXx; } in
        let {
          sat_sgdXy [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_agdjG
          [LclId] =
              [$dTraversable_sgdXw] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sgdXw;
        } in  Data.Functor.Compose.$fFoldableCompose sat_sgdXy sat_sgdXz;

Data.Functor.Compose.$fTraversableCompose_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXA $dTraversable1_sgdXB]
        let {
          sat_sgdXD [Occ=Once, Dmd=<L,U(C(U),A)>] :: GHC.Base.Functor g_agdjH
          [LclId] =
              [$dTraversable1_sgdXB] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sgdXB; } in
        let {
          sat_sgdXC [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_agdjG
          [LclId] =
              [$dTraversable_sgdXA] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sgdXA;
        } in  Data.Functor.Compose.$fFunctorCompose sat_sgdXC sat_sgdXD;

Data.Functor.Compose.$fTraversableCompose_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Compose.Compose f g (f1 a)
     -> f1 (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(U)),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXE
           $dTraversable1_sgdXF
           $dApplicative_sgdXG
           eta_B1]
        Data.Functor.Compose.$fTraversableCompose_$ctraverse
            $dTraversable_sgdXE
            $dTraversable1_sgdXF
            $dApplicative_sgdXG
            GHC.Base.id
            eta_B1;

Data.Functor.Compose.$fTraversableCompose_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXH
           $dTraversable1_sgdXI
           $dMonad_sgdXJ
           eta_sgdXK
           eta1_sgdXL]
        case GHC.Base.$p1Monad $dMonad_sgdXJ of sat_sgdXM {
          __DEFAULT ->
              Data.Functor.Compose.$fTraversableCompose_$ctraverse
                  $dTraversable_sgdXH
                  $dTraversable1_sgdXI
                  sat_sgdXM
                  eta_sgdXK
                  eta1_sgdXL;
        };

Data.Functor.Compose.$fTraversableCompose_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Compose.Compose f g (m a)
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXN
           $dTraversable1_sgdXO
           $dMonad_sgdXP
           eta_sgdXQ]
        case GHC.Base.$p1Monad $dMonad_sgdXP of sat_sgdXR {
          __DEFAULT ->
              Data.Functor.Compose.$fTraversableCompose_$ctraverse
                  $dTraversable_sgdXN
                  $dTraversable1_sgdXO
                  sat_sgdXR
                  GHC.Base.id
                  eta_sgdXQ;
        };

Data.Functor.Compose.$fTraversableCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(U),A),1*U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dTraversable_sgdXS $dTraversable1_sgdXT]
        let {
          sat_sgdXZ [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Compose.Compose f_agdjG g_agdjH (m a)
               -> m (Data.Functor.Compose.Compose f_agdjG g_agdjH a)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$csequence
                      $dTraversable_sgdXS $dTraversable1_sgdXT eta_B2 eta_B1; } in
        let {
          sat_sgdXY [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Compose.Compose f_agdjG g_agdjH a
               -> m (Data.Functor.Compose.Compose f_agdjG g_agdjH b)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$cmapM
                      $dTraversable_sgdXS $dTraversable1_sgdXT eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdXX [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Compose.Compose f_agdjG g_agdjH (f a)
               -> f (Data.Functor.Compose.Compose f_agdjG g_agdjH a)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$csequenceA
                      $dTraversable_sgdXS $dTraversable1_sgdXT eta_B2 eta_B1; } in
        let {
          sat_sgdXW [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Compose.Compose f_agdjG g_agdjH a
               -> f (Data.Functor.Compose.Compose f_agdjG g_agdjH b)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$ctraverse
                      $dTraversable_sgdXS $dTraversable1_sgdXT eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdXV [Occ=Once]
            :: Data.Foldable.Foldable
                 (Data.Functor.Compose.Compose f_agdjG g_agdjH)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \u []
                  Data.Functor.Compose.$fTraversableCompose_$cp2Traversable
                      $dTraversable_sgdXS $dTraversable1_sgdXT; } in
        let {
          sat_sgdXU [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Compose.Compose f_agdjG g_agdjH)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \u []
                  Data.Functor.Compose.$fTraversableCompose_$cp1Traversable
                      $dTraversable_sgdXS $dTraversable1_sgdXT;
        } in 
          Data.Traversable.C:Traversable [sat_sgdXU
                                          sat_sgdXV
                                          sat_sgdXW
                                          sat_sgdXX
                                          sat_sgdXY
                                          sat_sgdXZ];

Data.Functor.Compose.$fApplicativeCompose4
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> f (g c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(U),A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdY0
           $dApplicative1_sgdY1
           f1_sgdY2
           ds_sgdY3
           ds1_sgdY4]
        let {
          sat_sgdY5 [Occ=Once]
            :: g_agdie a_agdj0 -> g_agdie b_agdj1 -> g_agdie c_agdj2
          [LclId] =
              [$dApplicative1_sgdY1 f1_sgdY2] \u []
                  GHC.Base.liftA2 $dApplicative1_sgdY1 f1_sgdY2;
        } in 
          GHC.Base.liftA2 $dApplicative_sgdY0 sat_sgdY5 ds_sgdY3 ds1_sgdY4;

Data.Functor.Compose.$fApplicativeCompose5
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g (a -> b)
     -> Data.Functor.Compose.Compose f g a -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,1*U,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdY6 $dApplicative1_sgdY7 ds_sgdY8 ds1_sgdY9]
        let {
          sat_sgdYa [Occ=Once]
            :: g_Xgdlx (a_agdiF -> b_agdiG)
               -> g_Xgdlx a_agdiF -> g_Xgdlx b_agdiG
          [LclId] =
              [$dApplicative1_sgdY7] \u [] GHC.Base.<*> $dApplicative1_sgdY7;
        } in 
          GHC.Base.liftA2 $dApplicative_sgdY6 sat_sgdYa ds_sgdY8 ds1_sgdY9;

Data.Functor.Compose.$fApplicativeCompose6
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a. a -> f (g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdYb $dApplicative1_sgdYc x_sgdYd]
        let {
          sat_sgdYe [Occ=Once] :: g_XgdlH a_agdio
          [LclId] =
              [$dApplicative1_sgdYc x_sgdYd] \u []
                  GHC.Base.pure $dApplicative1_sgdYc x_sgdYd;
        } in  GHC.Base.pure $dApplicative_sgdYb sat_sgdYe;

Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdYf $dApplicative1_sgdYg]
        let {
          sat_sgdYi [Occ=Once, Dmd=<L,U(C(U),A)>] :: GHC.Base.Functor g_XgdlP
          [LclId] =
              [$dApplicative1_sgdYg] \u []
                  GHC.Base.$p1Applicative $dApplicative1_sgdYg; } in
        let {
          sat_sgdYh [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_XgdlN
          [LclId] =
              [$dApplicative_sgdYf] \u []
                  GHC.Base.$p1Applicative $dApplicative_sgdYf;
        } in  Data.Functor.Compose.$fFunctorCompose sat_sgdYh sat_sgdYi;

Data.Functor.Compose.$fApplicativeCompose3
  :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgdYj eta_sgdYk] eta_sgdYk;

Data.Functor.Compose.$fApplicativeCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),U(1*U(1*C1(C1(U)),A),A,A,1*C1(C1(C1(U))),A,A)><L,U(1*U(1*C1(U),A),A,1*U,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdYl
           $dApplicative1_sgdYm
           eta_sgdYn
           eta1_sgdYo]
        let {
          sat_sgdYt [Occ=Once] :: f_XgdlX (g_XgdlZ (b_agdjo -> b_agdjo))
          [LclId] =
              [$dApplicative_sgdYl $dApplicative1_sgdYm eta_sgdYn] \u []
                  let {
                    sat_sgdYs [Occ=Once]
                      :: g_XgdlZ a_agdjn -> g_XgdlZ (b_agdjo -> b_agdjo)
                    [LclId] =
                        [$dApplicative1_sgdYm] \u []
                            case GHC.Base.$p1Applicative $dApplicative1_sgdYm of sat_sgdYr {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sgdYr Data.Functor.Compose.$fApplicativeCompose3;
                            };
                  } in 
                    case GHC.Base.$p1Applicative $dApplicative_sgdYl of sat_sgdYq {
                      __DEFAULT -> GHC.Base.fmap sat_sgdYq sat_sgdYs eta_sgdYn;
                    }; } in
        let {
          sat_sgdYp [Occ=Once]
            :: g_XgdlZ (b_agdjo -> b_agdjo)
               -> g_XgdlZ b_agdjo -> g_XgdlZ b_agdjo
          [LclId] =
              [$dApplicative1_sgdYm] \u [] GHC.Base.<*> $dApplicative1_sgdYm;
        } in 
          GHC.Base.liftA2 $dApplicative_sgdYl sat_sgdYp sat_sgdYt eta1_sgdYo;

Data.Functor.Compose.$fApplicativeCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdYu $dApplicative1_sgdYv ds_sgdYw ds1_sgdYx]
        let {
          sat_sgdYy [Occ=Once]
            :: g_XgdlR a_agdjx -> g_XgdlR b_agdjy -> g_XgdlR a_agdjx
          [LclId] =
              [$dApplicative1_sgdYv] \u []
                  GHC.Base.liftA2 $dApplicative1_sgdYv GHC.Base.const;
        } in 
          GHC.Base.liftA2 $dApplicative_sgdYu sat_sgdYy ds_sgdYw ds1_sgdYx;

Data.Functor.Compose.$fApplicativeCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m] =
    [] \r [$dApplicative_sgdYz $dApplicative1_sgdYA]
        let {
          sat_sgdYG [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose1
                      $dApplicative_sgdYz $dApplicative1_sgdYA eta_B2 eta_B1; } in
        let {
          sat_sgdYF [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose2
                      $dApplicative_sgdYz $dApplicative1_sgdYA eta_B2 eta_B1; } in
        let {
          sat_sgdYE [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ c
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose4
                      $dApplicative_sgdYz $dApplicative1_sgdYA eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdYD [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ (a -> b)
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose5
                      $dApplicative_sgdYz $dApplicative1_sgdYA eta_B2 eta_B1; } in
        let {
          sat_sgdYC [Occ=Once]
            :: forall a. a -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \r [eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose6
                      $dApplicative_sgdYz $dApplicative1_sgdYA eta_B1; } in
        let {
          sat_sgdYB [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Compose.Compose f_XgdlO g_XgdlQ)
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \u []
                  Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative
                      $dApplicative_sgdYz $dApplicative1_sgdYA;
        } in 
          GHC.Base.C:Applicative [sat_sgdYB
                                  sat_sgdYC
                                  sat_sgdYD
                                  sat_sgdYE
                                  sat_sgdYF
                                  sat_sgdYG];

Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgdYH $dApplicative_sgdYI]
        let {
          sat_sgdYJ [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_XgdkR
          [LclId] =
              [$dAlternative_sgdYH] \u []
                  GHC.Base.$p1Alternative $dAlternative_sgdYH;
        } in 
          Data.Functor.Compose.$fApplicativeCompose
              sat_sgdYJ $dApplicative_sgdYI;

Data.Functor.Compose.$fAlternativeCompose_$csome
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     forall a.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U(A,C(U),A,C(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgdYK $dApplicative_sgdYL eta_sgdYM]
        let {
          some_v_sgdYN [Occ=LoopBreaker] :: f_XgdkU (g_XgdkW [a_agdhY])
          [LclId] =
              [$dAlternative_sgdYK
               $dApplicative_sgdYL
               eta_sgdYM
               some_v_sgdYN] \u []
                  case
                      GHC.Base.$p1Alternative $dAlternative_sgdYK
                  of
                  $dApplicative1_sgdYO [Dmd=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                  { __DEFAULT ->
                        let {
                          sat_sgdYS [Occ=Once] :: f_XgdkU (g_XgdkW [a_agdhY])
                          [LclId] =
                              [$dAlternative_sgdYK
                               $dApplicative_sgdYL
                               some_v_sgdYN
                               $dApplicative1_sgdYO] \u []
                                  let {
                                    sat_sgdYR [Occ=Once] :: f_XgdkU (g_XgdkW [a_agdhY])
                                    [LclId] =
                                        [$dApplicative_sgdYL $dApplicative1_sgdYO] \u []
                                            let {
                                              sat_sgdYQ [Occ=Once] :: g_XgdkW [a_agdhY]
                                              [LclId] =
                                                  [$dApplicative_sgdYL] \u []
                                                      GHC.Base.pure
                                                          $dApplicative_sgdYL GHC.Types.[];
                                            } in  GHC.Base.pure $dApplicative1_sgdYO sat_sgdYQ;
                                  } in 
                                    GHC.Base.<|> $dAlternative_sgdYK some_v_sgdYN sat_sgdYR; } in
                        let {
                          sat_sgdYP [Occ=Once]
                            :: g_XgdkW a_agdhY -> g_XgdkW [a_agdhY] -> g_XgdkW [a_agdhY]
                          [LclId] =
                              [$dApplicative_sgdYL] \u []
                                  GHC.Base.liftA2 $dApplicative_sgdYL GHC.Types.:;
                        } in 
                          GHC.Base.liftA2 $dApplicative1_sgdYO sat_sgdYP eta_sgdYM sat_sgdYS;
                  };
        } in  some_v_sgdYN;

Data.Functor.Compose.$fAlternativeCompose_$cmany
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     forall a.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U(A,C(U),A,C(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgdYT $dApplicative_sgdYU eta_sgdYV]
        let {
          many_v_sgdYW [Occ=LoopBreaker] :: f_XgdkT (g_XgdkV [a_agdi6])
          [LclId] =
              [$dAlternative_sgdYT
               $dApplicative_sgdYU
               eta_sgdYV
               many_v_sgdYW] \u []
                  let {
                    $dApplicative1_sgdYX [Dmd=<L,U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                      :: GHC.Base.Applicative f_XgdkT
                    [LclId] =
                        [$dAlternative_sgdYT] \u []
                            GHC.Base.$p1Alternative $dAlternative_sgdYT; } in
                  let {
                    sat_sgdZ1 [Occ=Once] :: f_XgdkT (g_XgdkV [a_agdi6])
                    [LclId] =
                        [$dApplicative_sgdYU $dApplicative1_sgdYX] \u []
                            let {
                              sat_sgdZ0 [Occ=Once] :: g_XgdkV [a_agdi6]
                              [LclId] =
                                  [$dApplicative_sgdYU] \u []
                                      GHC.Base.pure $dApplicative_sgdYU GHC.Types.[];
                            } in  GHC.Base.pure $dApplicative1_sgdYX sat_sgdZ0; } in
                  let {
                    sat_sgdYZ [Occ=Once] :: f_XgdkT (g_XgdkV [a_agdi6])
                    [LclId] =
                        [$dApplicative_sgdYU
                         eta_sgdYV
                         many_v_sgdYW
                         $dApplicative1_sgdYX] \u []
                            let {
                              sat_sgdYY [Occ=Once]
                                :: g_XgdkV a_agdi6 -> g_XgdkV [a_agdi6] -> g_XgdkV [a_agdi6]
                              [LclId] =
                                  [$dApplicative_sgdYU] \u []
                                      GHC.Base.liftA2 $dApplicative_sgdYU GHC.Types.:;
                            } in 
                              GHC.Base.liftA2
                                  $dApplicative1_sgdYX sat_sgdYY eta_sgdYV many_v_sgdYW;
                  } in  GHC.Base.<|> $dAlternative_sgdYT sat_sgdYZ sat_sgdZ1;
        } in  many_v_sgdYW;

Data.Functor.Compose.$fAlternativeCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     GHC.Base.Alternative (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A),1*U,U,A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m] =
    [] \r [$dAlternative_sgdZ2 $dApplicative_sgdZ3]
        let {
          sat_sgdZ8 [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU [a]
          [LclId] =
              [$dAlternative_sgdZ2 $dApplicative_sgdZ3] \r [eta_B1]
                  Data.Functor.Compose.$fAlternativeCompose_$cmany
                      $dAlternative_sgdZ2 $dApplicative_sgdZ3 eta_B1; } in
        let {
          sat_sgdZ7 [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU [a]
          [LclId] =
              [$dAlternative_sgdZ2 $dApplicative_sgdZ3] \r [eta_B1]
                  Data.Functor.Compose.$fAlternativeCompose_$csome
                      $dAlternative_sgdZ2 $dApplicative_sgdZ3 eta_B1; } in
        let {
          sat_sgdZ6 [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
          [LclId] =
              [$dAlternative_sgdZ2] \u [] GHC.Base.<|> $dAlternative_sgdZ2; } in
        let {
          sat_sgdZ5 [Occ=Once]
            :: forall a. Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
          [LclId] =
              [$dAlternative_sgdZ2] \u []
                  GHC.Base.empty $dAlternative_sgdZ2; } in
        let {
          sat_sgdZ4 [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Compose.Compose f_XgdkS g_XgdkU)
          [LclId] =
              [$dAlternative_sgdZ2 $dApplicative_sgdZ3] \u []
                  Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative
                      $dAlternative_sgdZ2 $dApplicative_sgdZ3;
        } in 
          GHC.Base.C:Alternative [sat_sgdZ4
                                  sat_sgdZ5
                                  sat_sgdZ6
                                  sat_sgdZ7
                                  sat_sgdZ8];

Data.Functor.Compose.$fGeneric1Compose1
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     forall (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Compose.Compose f g) a -> f (g a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgdZ9 ds_sgdZa]
        GHC.Base.fmap $dFunctor_sgdZ9 GHC.Generics.$fGeneric1:.:2 ds_sgdZa;

Data.Functor.Compose.$fGeneric1Compose3
  :: forall k (g :: k -> *) (a :: k). g a -> g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgdZb] v_sgdZb;

Data.Functor.Compose.$fGeneric1Compose2
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     forall (a :: k).
     Data.Functor.Compose.Compose f g a -> f (GHC.Generics.Rec1 g a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgdZc x_sgdZd]
        GHC.Base.fmap
            $dFunctor_sgdZc Data.Functor.Compose.$fGeneric1Compose3 x_sgdZd;

Data.Functor.Compose.$fGeneric1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     GHC.Generics.Generic1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sgdZe]
        let {
          sat_sgdZg [Occ=Once]
            :: forall (a :: k).
               GHC.Generics.Rep1 (Data.Functor.Compose.Compose f_XgdjE g_XgdjI) a
               -> Data.Functor.Compose.Compose f_XgdjE g_XgdjI a
          [LclId] =
              [$dFunctor_sgdZe] \r [eta_B1]
                  Data.Functor.Compose.$fGeneric1Compose1
                      $dFunctor_sgdZe eta_B1; } in
        let {
          sat_sgdZf [Occ=Once]
            :: forall (a :: k).
               Data.Functor.Compose.Compose f_XgdjE g_XgdjI a
               -> GHC.Generics.Rep1
                    (Data.Functor.Compose.Compose f_XgdjE g_XgdjI) a
          [LclId] =
              [$dFunctor_sgdZe] \r [eta_B1]
                  Data.Functor.Compose.$fGeneric1Compose2 $dFunctor_sgdZe eta_B1;
        } in  GHC.Generics.C:Generic1 [sat_sgdZf sat_sgdZg];

Data.Functor.Compose.$fGenericCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) x.
     GHC.Generics.Rep (Data.Functor.Compose.Compose f g a) x
     -> GHC.Generics.Rep (Data.Functor.Compose.Compose f g a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgdZh] ds_sgdZh;

Data.Functor.Compose.$fGenericCompose2
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) x.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sgdZi] x1_sgdZi;

Data.Functor.Compose.$fGenericCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     GHC.Generics.Generic (Data.Functor.Compose.Compose f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Compose.$fGenericCompose2
                                           Data.Functor.Compose.$fGenericCompose1];

Data.Functor.Compose.getCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgdZj] ds_sgdZj;

Data.Functor.Compose.getCompose
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> f (g a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Compose.getCompose1 eta_B1;

$cCompose1_rgdPU :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getCompose"#;

$cCompose2_rgdPV :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $cCompose1_rgdPU;

$cCompose3_rgdPW :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$cCompose2_rgdPV GHC.Types.[]];

go61_rgdPX
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgdZk _ys_sgdZl]
        case ds2_sgdZk of {
          [] -> GHC.List.badHead;
          : ipv_sgdZn [Occ=Once!] ipv1_sgdZo [Occ=Once] ->
              case _ys_sgdZl of {
                [] -> GHC.List.badHead;
                : ipv2_sgdZq [Occ=Once] ipv3_sgdZr [Occ=Once] ->
                    case ipv_sgdZn of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgdZu [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sgdZu Data.Functor.Compose.$fDataCompose6
                          of
                          { GHC.Types.False -> go61_rgdPX ipv1_sgdZo ipv3_sgdZr;
                            GHC.Types.True -> ipv2_sgdZq;
                          };
                    };
              };
        };

$cCompose4_rgdPY :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cCompose5_rgdPZ];
Data.Functor.Compose.$fDataCompose5 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Compose.$cCompose GHC.Types.[]];
Data.Functor.Compose.$fDataCompose4 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Functor.Compose.$fDataCompose5];
Data.Functor.Compose.$tCompose :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Functor.Compose.$fDataCompose6
                                       Data.Functor.Compose.$fDataCompose4];
Data.Functor.Compose.$cCompose [Occ=LoopBreaker]
  :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cCompose4_rgdPY
                                     Data.Functor.Compose.$fDataCompose6
                                     $cCompose3_rgdPW
                                     Data.Data.Prefix
                                     Data.Functor.Compose.$tCompose];
$cCompose5_rgdPZ :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rgdPX Data.Functor.Compose.$fDataCompose5 Data.Data.mkConstr1;

Data.Functor.Compose.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Compose.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$trModule4];

Data.Functor.Compose.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Compose"#;

Data.Functor.Compose.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$trModule2];

Data.Functor.Compose.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Compose.$trModule3
                                     Data.Functor.Compose.$trModule1];

$krep_rgdQ0 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_rgdQ1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgdQ0 GHC.Types.krep$*];

$krep2_rgdQ2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_rgdQ3 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_rgdQ2
                                         GHC.Types.krep$*];

$krep4_rgdQ4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgdQ0 $krep2_rgdQ2];

$krep5_rgdQ5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_rgdQ4 $krep1_rgdQ1];

Data.Functor.Compose.$fDataCompose9 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rgdQ3 $krep5_rgdQ5];

$krep6_rgdQ6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep7_rgdQ7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep8_rgdQ8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [4#];

$krep9_rgdQ9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep6_rgdQ6 $krep8_rgdQ8];

$krep10_rgdQa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep7_rgdQ7 $krep9_rgdQ9];

Data.Functor.Compose.$fDataCompose10 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$fDataCompose7];

Data.Functor.Compose.$tcCompose :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6729400645769595507##
                                    7487202375031942550##
                                    Data.Functor.Compose.$trModule
                                    Data.Functor.Compose.$fDataCompose10
                                    2#
                                    Data.Functor.Compose.$fDataCompose9];

$krep11_rgdQb :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep8_rgdQ8 GHC.Types.[]];

$krep12_rgdQc :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_rgdQ6 $krep11_rgdQb];

$krep13_rgdQd :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep7_rgdQ7 $krep12_rgdQc];

$krep14_rgdQe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgdQ0 $krep13_rgdQd];

$krep15_rgdQf :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgdQ2 $krep14_rgdQe];

$krep16_rgdQg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Compose.$tcCompose
                                              $krep15_rgdQf];

Data.Functor.Compose.$tc'Compose1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_rgdQa $krep16_rgdQg];

Data.Functor.Compose.$tc'Compose3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Compose"#;

Data.Functor.Compose.$tc'Compose2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$tc'Compose3];

Data.Functor.Compose.$tc'Compose :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7236514282653524344##
                                    13791541438620948974##
                                    Data.Functor.Compose.$trModule
                                    Data.Functor.Compose.$tc'Compose2
                                    5#
                                    Data.Functor.Compose.$tc'Compose1];

Data.Functor.Compose.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Compose.Compose f g a)
[GblId, Arity=5, Str=<S,U><S,U><S,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sgdZz w1_sgdZA w2_sgdZB w3_sgdZC w4_sgdZD]
        let {
          sat_sgdZF [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w4_sgdZD]; } in
        let {
          sat_sgdZG [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sgdZF GHC.Types.[]]; } in
        let {
          sat_sgdZE [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sgdZC]; } in
        let {
          sat_sgdZH [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sgdZE sat_sgdZG];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  6729400645769595507##
                  7487202375031942550##
                  Data.Functor.Compose.$trModule
                  Data.Functor.Compose.$fDataCompose10
                  2#
                  Data.Functor.Compose.$fDataCompose9
                  sat_sgdZH
          of
          { (#,,,,#) ww8_sgdZJ [Occ=Once]
                     ww9_sgdZK [Occ=Once]
                     ww10_sgdZL [Occ=Once]
                     ww11_sgdZM [Occ=Once]
                     ww12_sgdZN [Occ=Once] ->
                let {
                  sat_sgdZO [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Compose.Compose
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sgdZJ
                                                            ww9_sgdZK
                                                            ww10_sgdZL
                                                            ww11_sgdZM
                                                            ww12_sgdZN];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sgdZO w1_sgdZA
                  of
                  sat_sgdZP
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sgdZP w2_sgdZB
                        of
                        sat_sgdZQ
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sgdZQ w_sgdZz;
                        };
                  };
          };

Data.Functor.Compose.$fDataCompose8 [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,U><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sgdZR w1_sgdZS w2_sgdZT w3_sgdZU w4_sgdZV w5_sgdZW]
        Data.Functor.Compose.$w$cp1Data
            w_sgdZR w1_sgdZS w2_sgdZT w3_sgdZU w4_sgdZV;

Data.Functor.Compose.$fDataCompose2
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     f (g a) -> f (g a)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgdZX] v_sgdZX;

Data.Functor.Compose.$fDataCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (f (g a) -> Data.Functor.Compose.Compose f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Compose.$fDataCompose2
                        GHC.Types.False];

Data.Functor.Compose.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgdZY w1_sgdZZ w2_sge00 w3_sge01]
        let {
          lvl8_sge02 [Occ=OnceL]
            :: m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9)
          [LclId] =
              [w1_sgdZZ] \u [] GHC.Base.mzero w1_sgdZZ;
        } in 
          case
              GHC.Base.$p2MonadPlus w1_sgdZZ
          of
          $dMonad_sge03 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sge0p [Occ=Once]
                    :: (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                        GHC.Types.Bool)
                       -> m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9)
                  [LclId] =
                      [lvl8_sge02 $dMonad_sge03] \r [ds_sge0k]
                          case ds_sge0k of {
                            (,) x'_sge0m [Occ=Once] b_sge0n [Occ=Once!] ->
                                case b_sge0n of {
                                  GHC.Types.False -> lvl8_sge02;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sge03 x'_sge0m;
                                };
                          }; } in
                let {
                  sat_sge0j [Occ=Once]
                    :: m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sgdZY w1_sgdZZ w2_sge00 w3_sge01 $dMonad_sge03] \u []
                          let {
                            lvl9_sge04 [Occ=OnceL] :: m_sgdKg (f_sgdK6 (g_sgdK8 a_sgdK9))
                            [LclId] =
                                [w_sgdZY w2_sge00 w3_sge01] \u [] w2_sge00 w_sgdZY w3_sge01; } in
                          let {
                            sat_sge0i [Occ=Once]
                              :: (f_sgdK6 (g_sgdK8 a_sgdK9)
                                  -> Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                  GHC.Types.Bool)
                                 -> m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                             GHC.Types.Bool)
                            [LclId] =
                                [w1_sgdZZ w3_sge01 $dMonad_sge03 lvl9_sge04] \r [ds1_sge06]
                                    case ds1_sge06 of {
                                      (,) h_sge08 b1_sge09 [Occ=Once] ->
                                          let {
                                            sat_sge0h [Occ=Once]
                                              :: m_sgdKg (Data.Functor.Compose.Compose
                                                            f_sgdK6 g_sgdK8 a_sgdK9,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [w3_sge01 $dMonad_sge03 h_sge08 b1_sge09] \u []
                                                    let {
                                                      sat_sge0f [Occ=Once]
                                                        :: Data.Functor.Compose.Compose
                                                             f_sgdK6 g_sgdK8 a_sgdK9
                                                      [LclId] =
                                                          [w3_sge01 h_sge08] \u []
                                                              h_sge08 w3_sge01; } in
                                                    let {
                                                      sat_sge0g [Occ=Once]
                                                        :: (Data.Functor.Compose.Compose
                                                              f_sgdK6 g_sgdK8 a_sgdK9,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sge0f b1_sge09];
                                                    } in 
                                                      GHC.Base.return $dMonad_sge03 sat_sge0g; } in
                                          let {
                                            sat_sge0e [Occ=Once]
                                              :: m_sgdKg (Data.Functor.Compose.Compose
                                                            f_sgdK6 g_sgdK8 a_sgdK9,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sge03 lvl9_sge04 h_sge08] \u []
                                                    let {
                                                      sat_sge0d [Occ=Once]
                                                        :: f_sgdK6 (g_sgdK8 a_sgdK9)
                                                           -> m_sgdKg (Data.Functor.Compose.Compose
                                                                         f_sgdK6 g_sgdK8 a_sgdK9,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sge03 h_sge08] \r [y'_sge0a]
                                                              let {
                                                                sat_sge0b [Occ=Once]
                                                                  :: Data.Functor.Compose.Compose
                                                                       f_sgdK6 g_sgdK8 a_sgdK9
                                                                [LclId] =
                                                                    [h_sge08 y'_sge0a] \u []
                                                                        h_sge08 y'_sge0a; } in
                                                              let {
                                                                sat_sge0c [Occ=Once]
                                                                  :: (Data.Functor.Compose.Compose
                                                                        f_sgdK6 g_sgdK8 a_sgdK9,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sge0b
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sge03 sat_sge0c;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sge03 lvl9_sge04 sat_sge0d;
                                          } in  GHC.Base.mplus w1_sgdZZ sat_sge0e sat_sge0h;
                                    }; } in
                          let {
                            sat_sge05 [Occ=Once]
                              :: m_sgdKg (f_sgdK6 (g_sgdK8 a_sgdK9)
                                          -> Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sge03] \u []
                                    GHC.Base.return
                                        $dMonad_sge03 Data.Functor.Compose.$fDataCompose1;
                          } in  GHC.Base.>>= $dMonad_sge03 sat_sge05 sat_sge0i;
                } in  GHC.Base.>>= $dMonad_sge03 sat_sge0j sat_sge0p;
          };

Data.Functor.Compose.$fDataCompose_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sge0q
           w1_sge0r
           w2_sge0s
           w3_sge0t
           w4_sge0u
           w5_sge0v
           w6_sge0w
           w7_sge0x
           w8_sge0y]
        Data.Functor.Compose.$w$cgmapMp
            w5_sge0v w6_sge0w w7_sge0x w8_sge0y;

Data.Functor.Compose.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sge0z w1_sge0A w2_sge0B w3_sge0C]
        let {
          lvl8_sge0D [Occ=OnceL] :: m_sgdKw (f_sgdKm (g_sgdKo a_sgdKp))
          [LclId] =
              [w_sge0z w2_sge0B w3_sge0C] \u [] w2_sge0B w_sge0z w3_sge0C; } in
        let {
          sat_sge0J [Occ=Once]
            :: (f_sgdKm (g_sgdKo a_sgdKp)
                -> Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
               -> m_sgdKw (Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
          [LclId] =
              [w1_sge0A lvl8_sge0D] \r [c'_sge0F]
                  let {
                    sat_sge0I [Occ=Once]
                      :: f_sgdKm (g_sgdKo a_sgdKp)
                         -> m_sgdKw (Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
                    [LclId] =
                        [w1_sge0A c'_sge0F] \r [x'_sge0G]
                            let {
                              sat_sge0H [Occ=Once]
                                :: Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp
                              [LclId] =
                                  [c'_sge0F x'_sge0G] \u [] c'_sge0F x'_sge0G;
                            } in  GHC.Base.return w1_sge0A sat_sge0H;
                  } in  GHC.Base.>>= w1_sge0A lvl8_sge0D sat_sge0I; } in
        let {
          sat_sge0E [Occ=Once]
            :: m_sgdKw (f_sgdKm (g_sgdKo a_sgdKp)
                        -> Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
          [LclId] =
              [w1_sge0A] \u []
                  GHC.Base.return w1_sge0A Data.Functor.Compose.$fDataCompose2;
        } in  GHC.Base.>>= w1_sge0A sat_sge0E sat_sge0J;

Data.Functor.Compose.$fDataCompose_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sge0K
           w1_sge0L
           w2_sge0M
           w3_sge0N
           w4_sge0O
           w5_sge0P
           w6_sge0Q
           w7_sge0R
           w8_sge0S]
        Data.Functor.Compose.$w$cgmapM w5_sge0P w6_sge0Q w7_sge0R w8_sge0S;

Data.Functor.Compose.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sge0T w1_sge0U w2_sge0V w3_sge0W]
        let {
          lvl8_sge0X [Occ=OnceL]
            :: m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF)
          [LclId] =
              [w1_sge0U] \u [] GHC.Base.mzero w1_sge0U;
        } in 
          case
              GHC.Base.$p2MonadPlus w1_sge0U
          of
          $dMonad_sge0Y [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sge1n [Occ=Once]
                    :: (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                        GHC.Types.Bool)
                       -> m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF)
                  [LclId] =
                      [lvl8_sge0X $dMonad_sge0Y] \r [ds_sge1i]
                          case ds_sge1i of {
                            (,) x'_sge1k [Occ=Once] b_sge1l [Occ=Once!] ->
                                case b_sge1l of {
                                  GHC.Types.False -> lvl8_sge0X;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sge0Y x'_sge1k;
                                };
                          }; } in
                let {
                  sat_sge1h [Occ=Once]
                    :: m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sge0T w1_sge0U w2_sge0V w3_sge0W $dMonad_sge0Y] \u []
                          let {
                            lvl9_sge0Z [Occ=OnceL] :: m_sgdKM (f_sgdKC (g_sgdKE a_sgdKF))
                            [LclId] =
                                [w_sge0T w2_sge0V w3_sge0W] \u [] w2_sge0V w_sge0T w3_sge0W; } in
                          let {
                            sat_sge1g [Occ=Once]
                              :: (f_sgdKC (g_sgdKE a_sgdKF)
                                  -> Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                  GHC.Types.Bool)
                                 -> m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                             GHC.Types.Bool)
                            [LclId] =
                                [w1_sge0U w3_sge0W $dMonad_sge0Y lvl9_sge0Z] \r [ds1_sge11]
                                    case ds1_sge11 of {
                                      (,) h_sge13 b1_sge14 [Occ=Once!] ->
                                          case b1_sge14 of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sge1d [Occ=Once]
                                                    :: m_sgdKM (Data.Functor.Compose.Compose
                                                                  f_sgdKC g_sgdKE a_sgdKF,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [w3_sge0W $dMonad_sge0Y h_sge13] \u []
                                                          let {
                                                            sat_sge1b [Occ=Once]
                                                              :: Data.Functor.Compose.Compose
                                                                   f_sgdKC g_sgdKE a_sgdKF
                                                            [LclId] =
                                                                [w3_sge0W h_sge13] \u []
                                                                    h_sge13 w3_sge0W; } in
                                                          let {
                                                            sat_sge1c [Occ=Once]
                                                              :: (Data.Functor.Compose.Compose
                                                                    f_sgdKC g_sgdKE a_sgdKF,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sge1b
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sge0Y sat_sge1c; } in
                                                let {
                                                  sat_sge1a [Occ=Once]
                                                    :: m_sgdKM (Data.Functor.Compose.Compose
                                                                  f_sgdKC g_sgdKE a_sgdKF,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sge0Y lvl9_sge0Z h_sge13] \u []
                                                          let {
                                                            sat_sge19 [Occ=Once]
                                                              :: f_sgdKC (g_sgdKE a_sgdKF)
                                                                 -> m_sgdKM (Data.Functor.Compose.Compose
                                                                               f_sgdKC
                                                                               g_sgdKE
                                                                               a_sgdKF,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sge0Y
                                                                 h_sge13] \r [y'_sge16]
                                                                    let {
                                                                      sat_sge17 [Occ=Once]
                                                                        :: Data.Functor.Compose.Compose
                                                                             f_sgdKC g_sgdKE a_sgdKF
                                                                      [LclId] =
                                                                          [h_sge13 y'_sge16] \u []
                                                                              h_sge13 y'_sge16; } in
                                                                    let {
                                                                      sat_sge18 [Occ=Once]
                                                                        :: (Data.Functor.Compose.Compose
                                                                              f_sgdKC
                                                                              g_sgdKE
                                                                              a_sgdKF,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sge17
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sge0Y sat_sge18;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sge0Y lvl9_sge0Z sat_sge19;
                                                } in  GHC.Base.mplus w1_sge0U sat_sge1a sat_sge1d;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sge1e [Occ=Once]
                                                    :: Data.Functor.Compose.Compose
                                                         f_sgdKC g_sgdKE a_sgdKF
                                                  [LclId] =
                                                      [w3_sge0W h_sge13] \u []
                                                          h_sge13 w3_sge0W; } in
                                                let {
                                                  sat_sge1f [Occ=Once]
                                                    :: (Data.Functor.Compose.Compose
                                                          f_sgdKC g_sgdKE a_sgdKF,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sge1e GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sge0Y sat_sge1f;
                                          };
                                    }; } in
                          let {
                            sat_sge10 [Occ=Once]
                              :: m_sgdKM (f_sgdKC (g_sgdKE a_sgdKF)
                                          -> Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sge0Y] \u []
                                    GHC.Base.return
                                        $dMonad_sge0Y Data.Functor.Compose.$fDataCompose1;
                          } in  GHC.Base.>>= $dMonad_sge0Y sat_sge10 sat_sge1g;
                } in  GHC.Base.>>= $dMonad_sge0Y sat_sge1h sat_sge1n;
          };

Data.Functor.Compose.$fDataCompose_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sge1o
           w1_sge1p
           w2_sge1q
           w3_sge1r
           w4_sge1s
           w5_sge1t
           w6_sge1u
           w7_sge1v
           w8_sge1w]
        Data.Functor.Compose.$w$cgmapMo
            w5_sge1t w6_sge1u w7_sge1v w8_sge1w;

lvl4_rgdQh
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sge1x] Data.Functor.Compose.$cCompose;

lvl5_rgdQi
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sge1y] Data.Functor.Compose.$tCompose;

lvl6_rgdQj
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) (t :: *
                                                                 -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Compose.Compose f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sge1z ds_sge1A] GHC.Base.Nothing [];

lvl7_rgdQk
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) (t :: *
                                                                 -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Compose.Compose f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sge1B ds_sge1C] GHC.Base.Nothing [];

Data.Functor.Compose.$fDataCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     Data.Data.Data (Data.Functor.Compose.Compose f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sge1D
           $dTypeable1_sge1E
           $dTypeable2_sge1F
           $dTypeable3_sge1G
           $dTypeable4_sge1H
           $dData_sge1I]
        let {
          sat_sge2v [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sge1I] \r [w_sge2s w1_sge2t w2_sge2u]
                  Data.Functor.Compose.$w$cgmapMo
                      $dData_sge1I w_sge2s w1_sge2t w2_sge2u; } in
        let {
          sat_sge2r [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sge1I] \r [w_sge2o w1_sge2p w2_sge2q]
                  Data.Functor.Compose.$w$cgmapMp
                      $dData_sge1I w_sge2o w1_sge2p w2_sge2q; } in
        let {
          sat_sge2n [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sge1I] \r [w_sge2k w1_sge2l w2_sge2m]
                  Data.Functor.Compose.$w$cgmapM
                      $dData_sge1I w_sge2k w1_sge2l w2_sge2m; } in
        let {
          sat_sge2j [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> u
          [LclId] =
              [$dData_sge1I] \r [ds_sge2d ds1_sge2e x_sge2f]
                  case ds_sge2d of {
                    GHC.Types.I# x1_sge2h [Occ=Once!] ->
                        case x1_sge2h of {
                          __DEFAULT -> Data.Maybe.fromJust1;
                          0# -> ds1_sge2e $dData_sge1I x_sge2f;
                        };
                  }; } in
        let {
          sat_sge2c [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs -> [u]
          [LclId] =
              [$dData_sge1I] \r [ds_sge29 x0_sge2a]
                  let {
                    sat_sge2b [Occ=Once] :: u_agdd2
                    [LclId] =
                        [$dData_sge1I ds_sge29 x0_sge2a] \u []
                            ds_sge29 $dData_sge1I x0_sge2a;
                  } in  : [sat_sge2b GHC.Types.[]]; } in
        let {
          sat_sge28 [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> r
          [LclId] =
              [$dData_sge1I] \r [ds_sge23 ds1_sge24 ds2_sge25 x0_sge26]
                  let {
                    sat_sge27 [Occ=Once] :: r'_agdcM
                    [LclId] =
                        [$dData_sge1I ds2_sge25 x0_sge26] \u []
                            ds2_sge25 $dData_sge1I x0_sge26;
                  } in  ds_sge23 sat_sge27 ds1_sge24; } in
        let {
          sat_sge22 [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> r
          [LclId] =
              [$dData_sge1I] \r [ds_sge1X ds1_sge1Y ds2_sge1Z eta_sge20]
                  let {
                    sat_sge21 [Occ=Once] :: r'_agdcv
                    [LclId] =
                        [$dData_sge1I ds2_sge1Z eta_sge20] \u []
                            ds2_sge1Z $dData_sge1I eta_sge20;
                  } in  ds_sge1X ds1_sge1Y sat_sge21; } in
        let {
          sat_sge1W [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
          [LclId] =
              [$dData_sge1I] \r [ds_sge1U x0_sge1V]
                  ds_sge1U $dData_sge1I x0_sge1V; } in
        let {
          sat_sge1T [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sge1I] \r [k2_sge1P z_sge1Q ds_sge1R]
                  let {
                    sat_sge1S [Occ=Once]
                      :: c_agdbg (f_Xgdgm (g_Xgdgq a_Xgdgs)
                                  -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
                    [LclId] =
                        [z_sge1Q] \u [] z_sge1Q Data.Functor.Compose.$fDataCompose2;
                  } in  k2_sge1P $dData_sge1I sat_sge1S; } in
        let {
          sat_sge1O [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> c (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sge1I] \r [k2_sge1K z_sge1L ds_sge1M]
                  let {
                    sat_sge1N [Occ=Once]
                      :: c_agdb1 (f_Xgdgm (g_Xgdgq a_Xgdgs)
                                  -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
                    [LclId] =
                        [z_sge1L] \u [] z_sge1L Data.Functor.Compose.$fDataCompose2;
                  } in  k2_sge1K $dData_sge1I sat_sge1N ds_sge1M; } in
        let {
          sat_sge1J [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dTypeable_sge1D
               $dTypeable1_sge1E
               $dTypeable2_sge1F
               $dTypeable3_sge1G
               $dTypeable4_sge1H] \u []
                  Data.Functor.Compose.$w$cp1Data
                      $dTypeable_sge1D
                      $dTypeable1_sge1E
                      $dTypeable2_sge1F
                      $dTypeable3_sge1G
                      $dTypeable4_sge1H;
        } in 
          Data.Data.C:Data [sat_sge1J
                            sat_sge1O
                            sat_sge1T
                            lvl4_rgdQh
                            lvl5_rgdQi
                            lvl6_rgdQj
                            lvl7_rgdQk
                            sat_sge1W
                            sat_sge22
                            sat_sge28
                            sat_sge2c
                            sat_sge2j
                            sat_sge2n
                            sat_sge2r
                            sat_sge2v];


==================== STG syntax: ====================
2018-03-16 16:12:06.333677483 UTC

$fEq1Compose1_rgdPP
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dEq1_sgdQm
                    $dEq2_sgdQn
                    eq_sgdQo
                    ds_sgdQp
                    ds1_sgdQq]
        let {
          sat_sgdQr [Occ=Once]
            :: g_agdsJ a_agdsP -> g_agdsJ b_agdsQ -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sgdQn eq_sgdQo] \u [] $dEq2_sgdQn eq_sgdQo;
        } in  $dEq1_sgdQm sat_sgdQr ds_sgdQp ds1_sgdQq;

Data.Functor.Compose.$fEq1Compose [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        $fEq1Compose1_rgdPP eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Compose.$fOrd1Compose_$cliftCompare
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdQs $dOrd2_sgdQt comp_sgdQu ds_sgdQv ds1_sgdQw]
        let {
          sat_sgdQx [Occ=Once]
            :: g_agdsk a_agdsu -> g_agdsk b_agdsv -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdQt comp_sgdQu] \u []
                  Data.Functor.Classes.liftCompare $dOrd2_sgdQt comp_sgdQu;
        } in 
          Data.Functor.Classes.liftCompare
              $dOrd1_sgdQs sat_sgdQx ds_sgdQv ds1_sgdQw;

Data.Functor.Compose.$fOrd1Compose1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(U),A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdQy $dOrd2_sgdQz eta_sgdQA eta1_sgdQB eta2_sgdQC]
        let {
          sat_sgdQD [Occ=Once]
            :: g_agdsk a_adwad -> g_agdsk b_adwae -> GHC.Types.Bool
          [LclId] =
              [$dOrd2_sgdQz eta_sgdQA] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sgdQz eta_sgdQA;
        } in 
          Data.Functor.Classes.$p1Ord1
              $dOrd1_sgdQy sat_sgdQD eta1_sgdQB eta2_sgdQC;

Data.Functor.Compose.$fOrd1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(U),C(U))>m] =
    [] \r [$dOrd1_sgdQE $dOrd2_sgdQF]
        let {
          sat_sgdQH [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Compose.Compose f_Xgdux g_Xgduz a
               -> Data.Functor.Compose.Compose f_Xgdux g_Xgduz b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sgdQE $dOrd2_sgdQF] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrd1Compose_$cliftCompare
                      $dOrd1_sgdQE $dOrd2_sgdQF eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdQG [Occ=Once]
            :: Data.Functor.Classes.Eq1
                 (Data.Functor.Compose.Compose f_Xgdux g_Xgduz)
          [LclId] =
              [$dOrd1_sgdQE $dOrd2_sgdQF] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrd1Compose1
                      $dOrd1_sgdQE $dOrd2_sgdQF eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sgdQG sat_sgdQH];

Data.Functor.Compose.$fDataCompose7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Compose"#;

Data.Functor.Compose.$fDataCompose6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Compose.$fDataCompose7;

Data.Functor.Compose.$fRead1Compose2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Compose.$fDataCompose6];

Data.Functor.Compose.$fRead1Compose1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*C1(C1(U)),1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdQI $dRead2_sgdQJ rp_sgdQK rl_sgdQL]
        let {
          reader_sgdQM [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_agdr6 (g_agdr7 a_agdru))
          [LclId] =
              [$dRead1_sgdQI $dRead2_sgdQJ rp_sgdQK rl_sgdQL] \u []
                  let {
                    sat_sgdQO [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [g_agdr7 a_agdru]
                    [LclId] =
                        [$dRead2_sgdQJ rp_sgdQK rl_sgdQL] \u []
                            Data.Functor.Classes.liftReadListPrec
                                $dRead2_sgdQJ rp_sgdQK rl_sgdQL; } in
                  let {
                    sat_sgdQN [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec (g_agdr7 a_agdru)
                    [LclId] =
                        [$dRead2_sgdQJ rp_sgdQK rl_sgdQL] \u []
                            Data.Functor.Classes.liftReadPrec $dRead2_sgdQJ rp_sgdQK rl_sgdQL;
                  } in 
                    Data.Functor.Classes.liftReadPrec
                        $dRead1_sgdQI sat_sgdQN sat_sgdQO; } in
        let {
          $wlvl_sgdQP [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [reader_sgdQM] \r [ww_sgdQQ w_sgdQR]
                  case <=# [ww_sgdQQ 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sgdQW [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sgdH3
                          [LclId] =
                              [reader_sgdQM w_sgdQR] \r [a1_sgdQT]
                                  let {
                                    sat_sgdQV [Occ=Once]
                                      :: f_agdr6 (g_agdr7 a_agdru)
                                         -> Text.ParserCombinators.ReadP.P b_sgdH3
                                    [LclId] =
                                        [w_sgdQR] \r [a2_sgdQU] w_sgdQR a2_sgdQU;
                                  } in  reader_sgdQM Data.Functor.Compose.$fRead1Compose1 sat_sgdQV;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Functor.Compose.$fRead1Compose2 sat_sgdQW
                          of
                          { Unit# ww2_sgdQY [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_sgdQY];
                          };
                  }; } in
        let {
          lvl8_sgdQZ [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sgdQP] \r [w_sgdR0 w1_sgdR1]
                  case w_sgdR0 of {
                    GHC.Types.I# ww1_sgdR3 [Occ=Once] ->
                        $wlvl_sgdQP ww1_sgdR3 w1_sgdR1;
                  }; } in
        let {
          sat_sgdR6 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl8_sgdQZ] \r [eta_sgdR4 eta1_sgdR5]
                  GHC.Read.list3 lvl8_sgdQZ eta_sgdR4 eta1_sgdR5;
        } in  sat_sgdR6;

Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdR7 $dRead2_sgdR8 rp_sgdR9 rl_sgdRa]
        let {
          ds_sgdRb [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
          [LclId] =
              [$dRead1_sgdR7 $dRead2_sgdR8 rp_sgdR9 rl_sgdRa] \u []
                  let {
                    sat_sgdRh [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdrd]
                    [LclId] =
                        [rl_sgdRa] \r [n_sgdRd w1_sgdRe]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sgdRa w1_sgdRe
                            of
                            { Unit# ww1_sgdRg [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sgdRg];
                            }; } in
                  let {
                    sat_sgdRc [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdrd
                    [LclId] =
                        [rp_sgdR9] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sgdR9 eta_B1;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sgdR7 $dRead2_sgdR8 sat_sgdRc sat_sgdRh; } in
        let {
          sat_sgdRk [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
          [LclId] =
              [ds_sgdRb] \r [n_sgdRi]
                  let {
                    sat_sgdRj [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
                    [LclId] =
                        [ds_sgdRb n_sgdRi] \u []
                            ds_sgdRb
                                n_sgdRi Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgdRj;
        } in  sat_sgdRk;

Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdRl $dRead2_sgdRm rp_sgdRn rl_sgdRo]
        let {
          sat_sgdRp [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdsb)
          [LclId] =
              [$dRead1_sgdRl $dRead2_sgdRm rp_sgdRn rl_sgdRo] \s []
                  Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                      $dRead1_sgdRl $dRead2_sgdRm rp_sgdRn rl_sgdRo;
        } in  GHC.Read.list sat_sgdRp;

Data.Functor.Compose.$fRead1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))>m] =
    [] \r [$dRead1_sgdRq $dRead2_sgdRr]
        let {
          sat_sgdRv [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Compose.Compose f_agdr6 g_agdr7 a]
          [LclId] =
              [$dRead1_sgdRq $dRead2_sgdRr] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec
                      $dRead1_sgdRq $dRead2_sgdRr eta_B2 eta_B1; } in
        let {
          sat_sgdRu [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a)
          [LclId] =
              [$dRead1_sgdRq $dRead2_sgdRr] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                      $dRead1_sgdRq $dRead2_sgdRr eta_B2 eta_B1; } in
        let {
          sat_sgdRt [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Compose.Compose f_agdr6 g_agdr7 a]
          [LclId] =
              [$dRead1_sgdRq $dRead2_sgdRr] \u []
                  Data.Functor.Compose.$fRead1Compose_$cliftReadList
                      $dRead1_sgdRq $dRead2_sgdRr; } in
        let {
          sat_sgdRs [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a)
          [LclId] =
              [$dRead1_sgdRq $dRead2_sgdRr] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec
                      $dRead1_sgdRq $dRead2_sgdRr eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sgdRs
                                        sat_sgdRt
                                        sat_sgdRu
                                        sat_sgdRv];
Data.Functor.Compose.$fRead1Compose_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdRw $dRead2_sgdRx]
        let {
          sat_sgdRy [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7)
          [LclId] =
              [$dRead1_sgdRw $dRead2_sgdRx] \u []
                  Data.Functor.Compose.$fRead1Compose $dRead1_sgdRw $dRead2_sgdRx;
        } in  Data.Functor.Classes.liftReadListDefault sat_sgdRy;

Data.Functor.Compose.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> Data.Functor.Compose.Compose f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*C1(C1(U)),1*C1(C1(U)))><L,U><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgdRz w1_sgdRA w2_sgdRB w3_sgdRC ww_sgdRD w4_sgdRE]
        let {
          sat_sgdRH [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sgdHs (g_sgdHt a_sgdHw) -> GHC.Show.ShowS
          [LclId] =
              [w_sgdRz w1_sgdRA w2_sgdRB w3_sgdRC] \s []
                  let {
                    sat_sgdRG [Occ=Once] :: [g_sgdHt a_sgdHw] -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sgdRA w2_sgdRB w3_sgdRC] \u []
                            Data.Functor.Classes.liftShowList w1_sgdRA w2_sgdRB w3_sgdRC; } in
                  let {
                    sat_sgdRF [Occ=Once]
                      :: GHC.Types.Int -> g_sgdHt a_sgdHw -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sgdRA w2_sgdRB w3_sgdRC] \u []
                            Data.Functor.Classes.liftShowsPrec w1_sgdRA w2_sgdRB w3_sgdRC;
                  } in 
                    Data.Functor.Classes.liftShowsPrec w_sgdRz sat_sgdRF sat_sgdRG;
        } in 
          Data.Functor.Classes.$wshowsUnaryWith
              sat_sgdRH Data.Functor.Compose.$fDataCompose6 ww_sgdRD w4_sgdRE;

Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Compose.Compose f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgdRI w1_sgdRJ w2_sgdRK w3_sgdRL w4_sgdRM w5_sgdRN]
        case w4_sgdRM of {
          GHC.Types.I# ww1_sgdRP [Occ=Once] ->
              Data.Functor.Compose.$w$cliftShowsPrec
                  w_sgdRI w1_sgdRJ w2_sgdRK w3_sgdRL ww1_sgdRP w5_sgdRN;
        };

Data.Functor.Compose.$fDataCompose3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Compose.$fShow1Compose_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Compose.Compose f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgdRQ
           $dShow2_sgdRR
           sp_sgdRS
           sl_sgdRT
           eta_sgdRU
           eta1_sgdRV]
        let {
          sat_sgdRX [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdqk g_agdql a_agdqZ
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdRQ $dShow2_sgdRR sp_sgdRS sl_sgdRT] \r [w_sgdRW]
                  Data.Functor.Compose.$w$cliftShowsPrec
                      $dShow1_sgdRQ $dShow2_sgdRR sp_sgdRS sl_sgdRT 0# w_sgdRW;
        } in  GHC.Show.showList__ sat_sgdRX eta_sgdRU eta1_sgdRV;

Data.Functor.Compose.$fShow1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))>m] =
    [] \r [$dShow1_sgdRY $dShow2_sgdRZ]
        let {
          sat_sgdS1 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Compose.Compose f_agdqk g_agdql a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdRY $dShow2_sgdRZ] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fShow1Compose_$cliftShowList
                      $dShow1_sgdRY $dShow2_sgdRZ eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdS0 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Compose.Compose f_agdqk g_agdql a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdRY $dShow2_sgdRZ] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec
                      $dShow1_sgdRY $dShow2_sgdRZ eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sgdS0 sat_sgdS1];

Data.Functor.Compose.$fEqCompose_$c==
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,1*U(1*U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgdS2 $dEq2_sgdS3 $dEq_sgdS4 eta_sgdS5 eta1_sgdS6]
        let {
          sat_sgdS8 [Occ=Once]
            :: g_agdq0 a_agdq1 -> g_agdq0 a_agdq1 -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sgdS3 $dEq_sgdS4] \u []
                  let {
                    sat_sgdS7 [Occ=Once] :: a_agdq1 -> a_agdq1 -> GHC.Types.Bool
                    [LclId] =
                        [$dEq_sgdS4] \u [] GHC.Classes.== $dEq_sgdS4;
                  } in  $dEq2_sgdS3 sat_sgdS7;
        } in  $dEq1_sgdS2 sat_sgdS8 eta_sgdS5 eta1_sgdS6;

Data.Functor.Compose.$fEqCompose_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,1*U(1*U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgdS9 $dEq2_sgdSa $dEq_sgdSb eta_sgdSc eta1_sgdSd]
        let {
          sat_sgdSf [Occ=Once]
            :: g_agdq0 a_agdq1 -> g_agdq0 a_agdq1 -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sgdSa $dEq_sgdSb] \u []
                  let {
                    sat_sgdSe [Occ=Once] :: a_agdq1 -> a_agdq1 -> GHC.Types.Bool
                    [LclId] =
                        [$dEq_sgdSb] \u [] GHC.Classes.== $dEq_sgdSb;
                  } in  $dEq2_sgdSa sat_sgdSe;
        } in 
          case $dEq1_sgdS9 sat_sgdSf eta_sgdSc eta1_sgdSd of {
            GHC.Types.False -> GHC.Types.True [];
            GHC.Types.True -> GHC.Types.False [];
          };

Data.Functor.Compose.$fEqCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(U)><L,U(U,A)>m] =
    [] \r [$dEq1_sgdSh $dEq2_sgdSi $dEq_sgdSj]
        let {
          sat_sgdSl [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgdSh $dEq2_sgdSi $dEq_sgdSj] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fEqCompose_$c/=
                      $dEq1_sgdSh $dEq2_sgdSi $dEq_sgdSj eta_B2 eta_B1; } in
        let {
          sat_sgdSk [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgdSh $dEq2_sgdSi $dEq_sgdSj] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fEqCompose_$c==
                      $dEq1_sgdSh $dEq2_sgdSi $dEq_sgdSj eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sgdSk sat_sgdSl];

Data.Functor.Compose.$fOrdCompose_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSm $dOrd2_sgdSn $dOrd_sgdSo eta_sgdSp eta1_sgdSq]
        let {
          sat_sgdSs [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdSn $dOrd_sgdSo] \u []
                  let {
                    sat_sgdSr [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdSo] \u [] GHC.Classes.compare $dOrd_sgdSo;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdSn sat_sgdSr;
        } in 
          Data.Functor.Classes.liftCompare
              $dOrd1_sgdSm sat_sgdSs eta_sgdSp eta1_sgdSq;

Data.Functor.Compose.$fOrdCompose_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(U),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSt $dOrd2_sgdSu $dOrd_sgdSv]
        let {
          sat_sgdSy [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_agdpd
          [LclId] =
              [$dOrd_sgdSv] \u [] GHC.Classes.$p1Ord $dOrd_sgdSv; } in
        let {
          sat_sgdSx [Occ=Once, Dmd=<L,C(U)>]
            :: Data.Functor.Classes.Eq1 g_agdpc
          [LclId] =
              [$dOrd2_sgdSu] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sgdSu; } in
        let {
          sat_sgdSw [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_agdpb
          [LclId] =
              [$dOrd1_sgdSt] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sgdSt;
        } in 
          Data.Functor.Compose.$fEqCompose sat_sgdSw sat_sgdSx sat_sgdSy;

Data.Functor.Compose.$fOrdCompose_$c<
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSz $dOrd2_sgdSA $dOrd_sgdSB x_sgdSC y_sgdSD]
        let {
          sat_sgdSF [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdSA $dOrd_sgdSB] \u []
                  let {
                    sat_sgdSE [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdSB] \u [] GHC.Classes.compare $dOrd_sgdSB;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdSA sat_sgdSE;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdSz sat_sgdSF x_sgdSC y_sgdSD
          of
          { __DEFAULT -> GHC.Types.False [];
            GHC.Types.LT -> GHC.Types.True [];
          };

Data.Functor.Compose.$fOrdCompose_$c>=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSH $dOrd2_sgdSI $dOrd_sgdSJ x_sgdSK y_sgdSL]
        let {
          sat_sgdSN [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdSI $dOrd_sgdSJ] \u []
                  let {
                    sat_sgdSM [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdSJ] \u [] GHC.Classes.compare $dOrd_sgdSJ;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdSI sat_sgdSM;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdSH sat_sgdSN x_sgdSK y_sgdSL
          of
          { __DEFAULT -> GHC.Types.True [];
            GHC.Types.LT -> GHC.Types.False [];
          };

Data.Functor.Compose.$fOrdCompose_$c>
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSP $dOrd2_sgdSQ $dOrd_sgdSR x_sgdSS y_sgdST]
        let {
          sat_sgdSV [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdSQ $dOrd_sgdSR] \u []
                  let {
                    sat_sgdSU [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdSR] \u [] GHC.Classes.compare $dOrd_sgdSR;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdSQ sat_sgdSU;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdSP sat_sgdSV x_sgdSS y_sgdST
          of
          { __DEFAULT -> GHC.Types.False [];
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Compose.$fOrdCompose_$c<=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdSX $dOrd2_sgdSY $dOrd_sgdSZ x_sgdT0 y_sgdT1]
        let {
          sat_sgdT3 [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdSY $dOrd_sgdSZ] \u []
                  let {
                    sat_sgdT2 [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdSZ] \u [] GHC.Classes.compare $dOrd_sgdSZ;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdSY sat_sgdT2;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdSX sat_sgdT3 x_sgdT0 y_sgdT1
          of
          { __DEFAULT -> GHC.Types.True [];
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Compose.$fOrdCompose_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdT5 $dOrd2_sgdT6 $dOrd_sgdT7 x_sgdT8 y_sgdT9]
        let {
          sat_sgdTb [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdT6 $dOrd_sgdT7] \u []
                  let {
                    sat_sgdTa [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdT7] \u [] GHC.Classes.compare $dOrd_sgdT7;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdT6 sat_sgdTa;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdT5 sat_sgdTb x_sgdT8 y_sgdT9
          of
          { __DEFAULT -> y_sgdT9;
            GHC.Types.GT -> x_sgdT8;
          };

Data.Functor.Compose.$fOrdCompose_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgdTd $dOrd2_sgdTe $dOrd_sgdTf x_sgdTg y_sgdTh]
        let {
          sat_sgdTj [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgdTe $dOrd_sgdTf] \u []
                  let {
                    sat_sgdTi [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgdTf] \u [] GHC.Classes.compare $dOrd_sgdTf;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgdTe sat_sgdTi;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgdTd sat_sgdTj x_sgdTg y_sgdTh
          of
          { __DEFAULT -> x_sgdTg;
            GHC.Types.GT -> y_sgdTh;
          };

Data.Functor.Compose.$fOrdCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(U),C(U))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn]
        let {
          sat_sgdTv [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$cmin
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTu [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$cmax
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTt [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c>=
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTs [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c>
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTr [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c<=
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTq [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c<
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTp [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$ccompare
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn eta_B2 eta_B1; } in
        let {
          sat_sgdTo [Occ=Once]
            :: GHC.Classes.Eq
                 (Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd)
          [LclId] =
              [$dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn] \u []
                  Data.Functor.Compose.$fOrdCompose_$cp1Ord
                      $dOrd1_sgdTl $dOrd2_sgdTm $dOrd_sgdTn;
        } in 
          GHC.Classes.C:Ord [sat_sgdTo
                             sat_sgdTp
                             sat_sgdTq
                             sat_sgdTr
                             sat_sgdTs
                             sat_sgdTt
                             sat_sgdTu
                             sat_sgdTv];

Data.Functor.Compose.$fReadCompose_$creadPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdTw $dRead2_sgdTx $dRead_sgdTy]
        let {
          sat_sgdTA [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
          [LclId] =
              [$dRead_sgdTy] \u [] GHC.Read.readListPrec $dRead_sgdTy; } in
        let {
          sat_sgdTz [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
          [LclId] =
              [$dRead_sgdTy] \u [] GHC.Read.readPrec $dRead_sgdTy;
        } in 
          Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
              $dRead1_sgdTw $dRead2_sgdTx sat_sgdTz sat_sgdTA;

Data.Functor.Compose.$fReadCompose_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdTB $dRead2_sgdTC $dRead_sgdTD]
        let {
          ds_sgdTE [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgdTB $dRead2_sgdTC $dRead_sgdTD] \u []
                  let {
                    sat_sgdTG [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
                    [LclId] =
                        [$dRead_sgdTD] \u [] GHC.Read.readListPrec $dRead_sgdTD; } in
                  let {
                    sat_sgdTF [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
                    [LclId] =
                        [$dRead_sgdTD] \u [] GHC.Read.readPrec $dRead_sgdTD;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sgdTB $dRead2_sgdTC sat_sgdTF sat_sgdTG; } in
        let {
          sat_sgdTJ [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [ds_sgdTE] \r [n_sgdTH]
                  let {
                    sat_sgdTI [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
                    [LclId] =
                        [ds_sgdTE n_sgdTH] \u []
                            ds_sgdTE
                                n_sgdTH Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgdTI;
        } in  sat_sgdTJ;

Data.Functor.Compose.$fReadCompose_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdTK $dRead2_sgdTL $dRead_sgdTM]
        let {
          sat_sgdTP [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgdTK $dRead2_sgdTL $dRead_sgdTM] \s []
                  let {
                    sat_sgdTO [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
                    [LclId] =
                        [$dRead_sgdTM] \u [] GHC.Read.readListPrec $dRead_sgdTM; } in
                  let {
                    sat_sgdTN [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
                    [LclId] =
                        [$dRead_sgdTM] \u [] GHC.Read.readPrec $dRead_sgdTM;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sgdTK $dRead2_sgdTL sat_sgdTN sat_sgdTO;
        } in  GHC.Read.list sat_sgdTP;

Data.Functor.Compose.$fReadCompose_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgdTQ $dRead2_sgdTR $dRead_sgdTS]
        let {
          sat_sgdTT [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgdTQ $dRead2_sgdTR $dRead_sgdTS] \u []
                  Data.Functor.Compose.$fReadCompose_$creadListPrec
                      $dRead1_sgdTQ
                      $dRead2_sgdTR
                      $dRead_sgdTS
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgdTT;

Data.Functor.Compose.$fReadCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW]
        let {
          sat_sgdU0 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW] \u []
                  Data.Functor.Compose.$fReadCompose_$creadListPrec
                      $dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW; } in
        let {
          sat_sgdTZ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW] \u []
                  Data.Functor.Compose.$fReadCompose_$creadPrec
                      $dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW; } in
        let {
          sat_sgdTY [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW] \u []
                  Data.Functor.Compose.$fReadCompose_$creadList
                      $dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW; } in
        let {
          sat_sgdTX [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW] \u []
                  Data.Functor.Compose.$fReadCompose_$creadsPrec
                      $dRead1_sgdTU $dRead2_sgdTV $dRead_sgdTW;
        } in  GHC.Read.C:Read [sat_sgdTX sat_sgdTY sat_sgdTZ sat_sgdU0];

Data.Functor.Compose.$fShowCompose_$cshowsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int
     -> Data.Functor.Compose.Compose f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(1*U,A,1*U)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgdU1
           $dShow2_sgdU2
           $dShow_sgdU3
           eta_sgdU4
           eta1_sgdU5]
        case eta_sgdU4 of {
          GHC.Types.I# ww1_sgdU7 [Occ=Once] ->
              let {
                sat_sgdU9 [Occ=Once] :: [a_agdog] -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sgdU3] \u [] GHC.Show.showList $dShow_sgdU3; } in
              let {
                sat_sgdU8 [Occ=Once] :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sgdU3] \u [] GHC.Show.showsPrec $dShow_sgdU3;
              } in 
                Data.Functor.Compose.$w$cliftShowsPrec
                    $dShow1_sgdU1
                    $dShow2_sgdU2
                    sat_sgdU8
                    sat_sgdU9
                    ww1_sgdU7
                    eta1_sgdU5;
        };

Data.Functor.Compose.$fShowCompose_$cshow
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Compose.Compose f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*C1(C1(U)),1*C1(C1(U)))><L,U(1*U,A,1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgdUa $dShow2_sgdUb $dShow_sgdUc x_sgdUd]
        let {
          sp_sgdUe :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgdUc] \u [] GHC.Show.showsPrec $dShow_sgdUc; } in
        let {
          sl_sgdUf :: [a_agdog] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgdUc] \u [] GHC.Show.showList $dShow_sgdUc; } in
        let {
          sat_sgdUi [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow1_sgdUa $dShow2_sgdUb x_sgdUd sp_sgdUe sl_sgdUf] \u []
                  let {
                    sat_sgdUh [Occ=Once] :: [g_agdof a_agdog] -> GHC.Show.ShowS
                    [LclId] =
                        [$dShow2_sgdUb sp_sgdUe sl_sgdUf] \u []
                            Data.Functor.Classes.liftShowList
                                $dShow2_sgdUb sp_sgdUe sl_sgdUf; } in
                  let {
                    sat_sgdUg [Occ=Once]
                      :: GHC.Types.Int -> g_agdof a_agdog -> GHC.Show.ShowS
                    [LclId] =
                        [$dShow2_sgdUb sp_sgdUe sl_sgdUf] \u []
                            Data.Functor.Classes.liftShowsPrec $dShow2_sgdUb sp_sgdUe sl_sgdUf;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        $dShow1_sgdUa
                        sat_sgdUg
                        sat_sgdUh
                        Data.Functor.Classes.$fRead1Const1
                        x_sgdUd
                        GHC.Types.[]; } in
        let {
          sat_sgdUj [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sgdUi];
        } in  GHC.Base.++ Data.Functor.Compose.$fDataCompose6 sat_sgdUj;

Data.Functor.Compose.$fShowCompose_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Compose.Compose f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgdUk $dShow2_sgdUl $dShow_sgdUm ls_sgdUn s_sgdUo]
        let {
          lvl8_sgdUp [Occ=OnceL]
            :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgdUm] \u [] GHC.Show.showsPrec $dShow_sgdUm; } in
        let {
          lvl9_sgdUq [Occ=OnceL] :: [a_agdog] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgdUm] \u [] GHC.Show.showList $dShow_sgdUm; } in
        let {
          sat_sgdUs [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdUk $dShow2_sgdUl lvl8_sgdUp lvl9_sgdUq] \r [eta_sgdUr]
                  Data.Functor.Compose.$w$cliftShowsPrec
                      $dShow1_sgdUk $dShow2_sgdUl lvl8_sgdUp lvl9_sgdUq 0# eta_sgdUr;
        } in  GHC.Show.showList__ sat_sgdUs ls_sgdUn s_sgdUo;

Data.Functor.Compose.$fShowCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(U,A,U)>m] =
    [] \r [$dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv]
        let {
          sat_sgdUy [Occ=Once]
            :: [Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshowList
                      $dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv eta_B2 eta_B1; } in
        let {
          sat_sgdUx [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Base.String
          [LclId] =
              [$dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv] \r [eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshow
                      $dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv eta_B1; } in
        let {
          sat_sgdUw [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshowsPrec
                      $dShow1_sgdUt $dShow2_sgdUu $dShow_sgdUv eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgdUw sat_sgdUx sat_sgdUy];

Data.Functor.Compose.$fFunctorCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b) -> Data.Functor.Compose.Compose f g a -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgdUz $dFunctor1_sgdUA f1_sgdUB ds_sgdUC]
        let {
          sat_sgdUD [Occ=Once] :: g_agdnF a_agdnL -> g_agdnF b_agdnM
          [LclId] =
              [$dFunctor1_sgdUA f1_sgdUB] \u []
                  GHC.Base.fmap $dFunctor1_sgdUA f1_sgdUB;
        } in  GHC.Base.fmap $dFunctor_sgdUz sat_sgdUD ds_sgdUC;

Data.Functor.Compose.$fFunctorCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b. a -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgdUE $dFunctor1_sgdUF x_sgdUG eta_sgdUH]
        let {
          sat_sgdUK [Occ=Once] :: g_Xgdqn b_agdo6 -> g_Xgdqn a_agdo5
          [LclId] =
              [$dFunctor1_sgdUF x_sgdUG] \u []
                  let {
                    sat_sgdUJ [Occ=Once] :: b_agdo6 -> a_agdo5
                    [LclId] =
                        [x_sgdUG] \r [ds_sgdUI] x_sgdUG;
                  } in  GHC.Base.fmap $dFunctor1_sgdUF sat_sgdUJ;
        } in  GHC.Base.fmap $dFunctor_sgdUE sat_sgdUK eta_sgdUH;

Data.Functor.Compose.$fFunctorCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgdUL $dFunctor1_sgdUM]
        let {
          sat_sgdUO [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm b
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm a
          [LclId] =
              [$dFunctor_sgdUL $dFunctor1_sgdUM] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFunctorCompose1
                      $dFunctor_sgdUL $dFunctor1_sgdUM eta_B2 eta_B1; } in
        let {
          sat_sgdUN [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm a
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm b
          [LclId] =
              [$dFunctor_sgdUL $dFunctor1_sgdUM] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFunctorCompose2
                      $dFunctor_sgdUL $dFunctor1_sgdUM eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sgdUN sat_sgdUO];

Data.Functor.Compose.$fFoldableCompose_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Compose.Compose f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdUP
           $dFoldable1_sgdUQ
           $dMonoid_sgdUR
           f1_sgdUS
           ds_sgdUT]
        let {
          sat_sgdUU [Occ=Once] :: g_agdl1 a_agdli -> m_agdlh
          [LclId] =
              [$dFoldable1_sgdUQ $dMonoid_sgdUR f1_sgdUS] \u []
                  Data.Foldable.foldMap $dFoldable1_sgdUQ $dMonoid_sgdUR f1_sgdUS;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdUP $dMonoid_sgdUR sat_sgdUU ds_sgdUT;

Data.Functor.Compose.$fFoldableCompose_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Compose.Compose f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdUV $dFoldable1_sgdUW $dMonoid_sgdUX ds_sgdUY]
        let {
          sat_sgdUZ [Occ=Once] :: g_agdl1 m_agdl7 -> m_agdl7
          [LclId] =
              [$dFoldable1_sgdUW $dMonoid_sgdUX] \u []
                  Data.Foldable.foldMap $dFoldable1_sgdUW $dMonoid_sgdUX GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdUV $dMonoid_sgdUX sat_sgdUZ ds_sgdUY;

Data.Functor.Compose.$fFoldableCompose1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgdV0] v_sgdV0;

Data.Functor.Compose.$fFoldableCompose_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdV1 $dFoldable1_sgdV2 $dNum_sgdV3]
        let {
          $dMonoid_sgdV4
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_agdnl)
          [LclId] =
              [$dNum_sgdV3] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sgdV3; } in
        let {
          lvl8_sgdV5 [Occ=OnceL]
            :: g_agdl1 a_agdnl -> Data.Semigroup.Internal.Sum a_agdnl
          [LclId] =
              [$dFoldable1_sgdV2 $dMonoid_sgdV4] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdV2
                      $dMonoid_sgdV4
                      Data.Functor.Compose.$fFoldableCompose1; } in
        let {
          sat_sgdV7 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnl
               -> Data.Semigroup.Internal.Sum a_agdnl
          [LclId] =
              [$dFoldable_sgdV1 $dMonoid_sgdV4 lvl8_sgdV5] \r [ds_sgdV6]
                  Data.Foldable.foldMap
                      $dFoldable_sgdV1 $dMonoid_sgdV4 lvl8_sgdV5 ds_sgdV6;
        } in  sat_sgdV7;

lvl_rgdPQ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Compose.$fFoldableCompose2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rgdPQ of sat_sgdV8 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgdV8;
        };

Data.Functor.Compose.$fFoldableCompose_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdV9 $dFoldable1_sgdVa $dOrd_sgdVb]
        let {
          $dMonoid_sgdVc :: GHC.Base.Monoid (Data.Functor.Utils.Min a_agdnb)
          [LclId] =
              [$dOrd_sgdVb] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sgdVb; } in
        let {
          lvl8_sgdVd [Occ=OnceL]
            :: g_agdl1 a_agdnb -> Data.Functor.Utils.Min a_agdnb
          [LclId] =
              [$dFoldable1_sgdVa $dMonoid_sgdVc] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdVa $dMonoid_sgdVc GHC.Base.Just; } in
        let {
          sat_sgdVh [Occ=OnceT[0]]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnb -> a_agdnb
          [LclId] =
              [$dFoldable_sgdV9 $dMonoid_sgdVc lvl8_sgdVd] \r [x_sgdVe]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_sgdV9 $dMonoid_sgdVc lvl8_sgdVd x_sgdVe
                  of
                  { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose2;
                    GHC.Base.Just v_sgdVg [Occ=Once] -> v_sgdVg;
                  };
        } in  sat_sgdVh;

lvl1_rgdPR :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Compose.$fFoldableCompose3 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rgdPR of sat_sgdVi {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgdVi;
        };

Data.Functor.Compose.$fFoldableCompose_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdVj $dFoldable1_sgdVk $dOrd_sgdVl]
        let {
          $dMonoid_sgdVm :: GHC.Base.Monoid (Data.Functor.Utils.Max a_agdn1)
          [LclId] =
              [$dOrd_sgdVl] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sgdVl; } in
        let {
          lvl8_sgdVn [Occ=OnceL]
            :: g_agdl1 a_agdn1 -> Data.Functor.Utils.Max a_agdn1
          [LclId] =
              [$dFoldable1_sgdVk $dMonoid_sgdVm] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdVk $dMonoid_sgdVm GHC.Base.Just; } in
        let {
          sat_sgdVr [Occ=OnceT[0]]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdn1 -> a_agdn1
          [LclId] =
              [$dFoldable_sgdVj $dMonoid_sgdVm lvl8_sgdVn] \r [x_sgdVo]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_sgdVj $dMonoid_sgdVm lvl8_sgdVn x_sgdVo
                  of
                  { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose3;
                    GHC.Base.Just v_sgdVq [Occ=Once] -> v_sgdVq;
                  };
        } in  sat_sgdVr;

Data.Functor.Compose.$fFoldableCompose_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdVs $dFoldable1_sgdVt $dEq_sgdVu eta_sgdVv]
        let {
          lvl8_sgdVw [Occ=OnceL]
            :: g_agdl1 a_agdmR -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable1_sgdVt $dEq_sgdVu eta_sgdVv] \u []
                  let {
                    sat_sgdVx [Occ=Once] :: a_agdmR -> Data.Semigroup.Internal.Any
                    [LclId] =
                        [$dEq_sgdVu eta_sgdVv] \u [] GHC.Classes.== $dEq_sgdVu eta_sgdVv;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdVt
                        Data.Semigroup.Internal.$fMonoidAny
                        sat_sgdVx; } in
        let {
          sat_sgdVz [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdmR
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sgdVs lvl8_sgdVw] \r [ds_sgdVy]
                  Data.Foldable.foldMap
                      $dFoldable_sgdVs
                      Data.Semigroup.Internal.$fMonoidAny
                      lvl8_sgdVw
                      ds_sgdVy;
        } in  sat_sgdVz;

Data.Functor.Compose.$fFoldableCompose7
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Compose.$fFoldableCompose_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdVA
           $dFoldable1_sgdVB
           f1_sgdVC
           z_sgdVD
           t1_sgdVE]
        let {
          sat_sgdVI [Occ=Once]
            :: g_agdl1 a_agdlU
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_agdlT)
          [LclId] =
              [$dFoldable1_sgdVB f1_sgdVC] \u []
                  let {
                    sat_sgdVH [Occ=Once]
                      :: a_agdlU
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo b_agdlT)
                    [LclId] =
                        [f1_sgdVC] \r [x_sgdVF y_sgdVG] f1_sgdVC y_sgdVG x_sgdVF;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdVB
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgdVH;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdVA
              Data.Functor.Compose.$fFoldableCompose7
              sat_sgdVI
              t1_sgdVE
              z_sgdVD;

lvl2_rgdPS :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Compose.$fFoldableCompose6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rgdPS of sat_sgdVJ {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgdVJ;
        };

Data.Functor.Compose.$fFoldableCompose_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdVK $dFoldable1_sgdVL f1_sgdVM xs_sgdVN]
        let {
          sat_sgdVU [Occ=Once]
            :: g_agdl1 a_agdml
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdml))
          [LclId] =
              [$dFoldable1_sgdVL f1_sgdVM] \u []
                  let {
                    sat_sgdVT [Occ=Once]
                      :: a_agdml
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdml))
                    [LclId] =
                        [f1_sgdVM] \r [x_sgdVO y_sgdVP]
                            let {
                              sat_sgdVS [Occ=Once] :: a_agdml
                              [LclId] =
                                  [f1_sgdVM x_sgdVO y_sgdVP] \u []
                                      case y_sgdVP of {
                                        GHC.Base.Nothing -> x_sgdVO;
                                        GHC.Base.Just x1_sgdVR [Occ=Once] ->
                                            f1_sgdVM x1_sgdVR x_sgdVO;
                                      };
                            } in  GHC.Base.Just [sat_sgdVS];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdVL
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgdVT;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_sgdVK
                  Data.Functor.Compose.$fFoldableCompose7
                  sat_sgdVU
                  xs_sgdVN
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose6;
            GHC.Base.Just v_sgdVW [Occ=Once] -> v_sgdVW;
          };

Data.Functor.Compose.$fFoldableCompose_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdVX
           $dFoldable1_sgdVY
           f1_sgdVZ
           z0_sgdW0
           xs_sgdW1]
        let {
          sat_sgdW7 [Occ=Once]
            :: g_agdl1 a_agdlJ
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_agdlK -> b_agdlK))
          [LclId] =
              [$dFoldable1_sgdVY f1_sgdVZ] \u []
                  let {
                    sat_sgdW6 [Occ=Once]
                      :: a_agdlJ
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (b_agdlK -> b_agdlK))
                    [LclId] =
                        [f1_sgdVZ] \r [x_sgdW2 y_sgdW3 z_sgdW4]
                            case f1_sgdVZ x_sgdW2 z_sgdW4 of vx_sgdW5 {
                              __DEFAULT -> y_sgdW3 vx_sgdW5;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdVY
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgdW6;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdVX
              Data.Functor.Compose.$fFoldableCompose7
              sat_sgdW7
              xs_sgdW1
              GHC.Base.id
              z0_sgdW0;

Data.Functor.Compose.$fFoldableCompose_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdW8
           $dFoldable1_sgdW9
           f1_sgdWa
           z_sgdWb
           t1_sgdWc]
        let {
          sat_sgdWd [Occ=Once]
            :: g_agdl1 a_agdlz -> Data.Semigroup.Internal.Endo b_agdlA
          [LclId] =
              [$dFoldable1_sgdW9 f1_sgdWa] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdW9 Data.Semigroup.Internal.$fMonoidEndo f1_sgdWa;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdW8
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgdWd
              t1_sgdWc
              z_sgdWb;

Data.Functor.Compose.$fFoldableCompose_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdWe
           $dFoldable1_sgdWf
           f1_sgdWg
           z0_sgdWh
           xs_sgdWi]
        let {
          sat_sgdWo [Occ=Once]
            :: g_agdl1 a_agdm4
               -> Data.Semigroup.Internal.Endo (b_agdm3 -> b_agdm3)
          [LclId] =
              [$dFoldable1_sgdWf f1_sgdWg] \u []
                  let {
                    sat_sgdWn [Occ=Once]
                      :: a_agdm4 -> Data.Semigroup.Internal.Endo (b_agdm3 -> b_agdm3)
                    [LclId] =
                        [f1_sgdWg] \r [x_sgdWj k_sgdWk z_sgdWl]
                            case f1_sgdWg z_sgdWl x_sgdWj of vx_sgdWm {
                              __DEFAULT -> k_sgdWk vx_sgdWm;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdWf Data.Semigroup.Internal.$fMonoidEndo sat_sgdWn;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdWe
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgdWo
              xs_sgdWi
              GHC.Base.id
              z0_sgdWh;

Data.Functor.Compose.$fFoldableCompose4
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sgdWp k_sgdWq z_sgdWr]
        case z_sgdWr of {
          GHC.Types.I# x1_sgdWt [Occ=Once] ->
              case +# [x1_sgdWt 1#] of sat_sgdWu {
                __DEFAULT ->
                    let {
                      sat_sgdWv [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sgdWu];
                    } in  k_sgdWq sat_sgdWv;
              };
        };

Data.Functor.Compose.$fFoldableCompose_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdWw $dFoldable1_sgdWx eta_sgdWy]
        let {
          sat_sgdWz [Occ=Once]
            :: g_agdl1 a_agdmJ
               -> Data.Semigroup.Internal.Endo (GHC.Types.Int -> GHC.Types.Int)
          [LclId] =
              [$dFoldable1_sgdWx] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdWx
                      Data.Semigroup.Internal.$fMonoidEndo
                      Data.Functor.Compose.$fFoldableCompose4;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdWw
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgdWz
              eta_sgdWy
              GHC.Base.id
              Data.Functor.Compose.$fDataCompose3;

lvl3_rgdPT :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Compose.$fFoldableCompose8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rgdPT of sat_sgdWA {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgdWA;
        };

Data.Functor.Compose.$fFoldableCompose_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdWB $dFoldable1_sgdWC f1_sgdWD xs_sgdWE]
        let {
          sat_sgdWL [Occ=Once]
            :: g_agdl1 a_agdmd
               -> Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdmd)
          [LclId] =
              [$dFoldable1_sgdWC f1_sgdWD] \u []
                  let {
                    sat_sgdWK [Occ=Once]
                      :: a_agdmd -> Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdmd)
                    [LclId] =
                        [f1_sgdWD] \r [x_sgdWF m_sgdWG]
                            let {
                              sat_sgdWJ [Occ=Once] :: a_agdmd
                              [LclId] =
                                  [f1_sgdWD x_sgdWF m_sgdWG] \u []
                                      case m_sgdWG of {
                                        GHC.Base.Nothing -> x_sgdWF;
                                        GHC.Base.Just y_sgdWI [Occ=Once] ->
                                            f1_sgdWD x_sgdWF y_sgdWI;
                                      };
                            } in  GHC.Base.Just [sat_sgdWJ];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgdWC Data.Semigroup.Internal.$fMonoidEndo sat_sgdWK;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_sgdWB
                  Data.Semigroup.Internal.$fMonoidEndo
                  sat_sgdWL
                  xs_sgdWE
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose8;
            GHC.Base.Just v_sgdWN [Occ=Once] -> v_sgdWN;
          };

Data.Functor.Compose.$fFoldableCompose5
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgdWO ds1_sgdWP] GHC.Types.False [];

Data.Functor.Compose.$fFoldableCompose_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdWQ $dFoldable1_sgdWR eta_sgdWS]
        let {
          sat_sgdWT [Occ=Once]
            :: g_agdl1 a_agdmB -> Data.Semigroup.Internal.Endo GHC.Types.Bool
          [LclId] =
              [$dFoldable1_sgdWR] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdWR
                      Data.Semigroup.Internal.$fMonoidEndo
                      Data.Functor.Compose.$fFoldableCompose5;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdWQ
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgdWT
              eta_sgdWS
              GHC.Types.True;

Data.Functor.Compose.$fFoldableCompose_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdWU $dFoldable1_sgdWV $dNum_sgdWW]
        let {
          $dMonoid_sgdWX
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_agdnv)
          [LclId] =
              [$dNum_sgdWW] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sgdWW; } in
        let {
          lvl8_sgdWY [Occ=OnceL]
            :: g_agdl1 a_agdnv -> Data.Semigroup.Internal.Product a_agdnv
          [LclId] =
              [$dFoldable1_sgdWV $dMonoid_sgdWX] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdWV
                      $dMonoid_sgdWX
                      Data.Functor.Compose.$fFoldableCompose1; } in
        let {
          sat_sgdX0 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnv
               -> Data.Semigroup.Internal.Product a_agdnv
          [LclId] =
              [$dFoldable_sgdWU $dMonoid_sgdWX lvl8_sgdWY] \r [ds_sgdWZ]
                  Data.Foldable.foldMap
                      $dFoldable_sgdWU $dMonoid_sgdWX lvl8_sgdWY ds_sgdWZ;
        } in  sat_sgdX0;

Data.Functor.Compose.$fFoldableCompose_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> [a]
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgdX1 $dFoldable1_sgdX2 eta_sgdX3]
        let {
          sat_sgdX4 [Occ=Once]
            :: g_agdl1 a_agdmt -> Data.Semigroup.Internal.Endo [a_agdmt]
          [LclId] =
              [$dFoldable1_sgdX2] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgdX2 Data.Semigroup.Internal.$fMonoidEndo GHC.Types.:;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgdX1
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgdX4
              eta_sgdX3
              GHC.Types.[];

Data.Functor.Compose.$fFoldableCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sgdX5 $dFoldable1_sgdX6]
        let {
          sat_sgdXm [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cproduct
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXl [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$csum
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXk [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cminimum
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXj [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cmaximum
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXi [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$celem
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B2 eta_B1; } in
        let {
          sat_sgdXh [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$clength
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXg [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cnull
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXf [Occ=Once]
            :: forall a. Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> [a]
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$ctoList
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B1; } in
        let {
          sat_sgdXe [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl1
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B2 eta_B1; } in
        let {
          sat_sgdXd [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr1
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B2 eta_B1; } in
        let {
          sat_sgdXc [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl'
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdXb [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdXa [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr'
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdX9 [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdX8 [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> m
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldMap
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdX7 [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 m -> m
          [LclId] =
              [$dFoldable_sgdX5 $dFoldable1_sgdX6] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfold
                      $dFoldable_sgdX5 $dFoldable1_sgdX6 eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sgdX7
                                    sat_sgdX8
                                    sat_sgdX9
                                    sat_sgdXa
                                    sat_sgdXb
                                    sat_sgdXc
                                    sat_sgdXd
                                    sat_sgdXe
                                    sat_sgdXf
                                    sat_sgdXg
                                    sat_sgdXh
                                    sat_sgdXi
                                    sat_sgdXj
                                    sat_sgdXk
                                    sat_sgdXl
                                    sat_sgdXm];

Data.Functor.Compose.$fTraversableCompose1
  :: forall (f :: * -> *) (g :: * -> *) b. f (g b) -> f (g b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgdXn] v_sgdXn;

Data.Functor.Compose.$fTraversableCompose_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Compose.Compose f g a
     -> f1 (Data.Functor.Compose.Compose f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXo
           $dTraversable1_sgdXp
           $dApplicative_sgdXq
           eta_sgdXr
           eta1_sgdXs]
        let {
          sat_sgdXv [Occ=Once] :: f1_agdjV (f_agdjG (g_agdjH b_agdjX))
          [LclId] =
              [$dTraversable_sgdXo
               $dTraversable1_sgdXp
               $dApplicative_sgdXq
               eta_sgdXr
               eta1_sgdXs] \u []
                  let {
                    sat_sgdXu [Occ=Once]
                      :: g_agdjH a_agdjW -> f1_agdjV (g_agdjH b_agdjX)
                    [LclId] =
                        [$dTraversable1_sgdXp $dApplicative_sgdXq eta_sgdXr] \u []
                            Data.Traversable.traverse
                                $dTraversable1_sgdXp $dApplicative_sgdXq eta_sgdXr;
                  } in 
                    Data.Traversable.traverse
                        $dTraversable_sgdXo $dApplicative_sgdXq sat_sgdXu eta1_sgdXs;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sgdXq of sat_sgdXt {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sgdXt Data.Functor.Compose.$fTraversableCompose1 sat_sgdXv;
          };

Data.Functor.Compose.$fTraversableCompose_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXw $dTraversable1_sgdXx]
        let {
          sat_sgdXz [Occ=Once,
                     Dmd=<L,U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_agdjH
          [LclId] =
              [$dTraversable1_sgdXx] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sgdXx; } in
        let {
          sat_sgdXy [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_agdjG
          [LclId] =
              [$dTraversable_sgdXw] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sgdXw;
        } in  Data.Functor.Compose.$fFoldableCompose sat_sgdXy sat_sgdXz;

Data.Functor.Compose.$fTraversableCompose_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXA $dTraversable1_sgdXB]
        let {
          sat_sgdXD [Occ=Once, Dmd=<L,U(C(U),A)>] :: GHC.Base.Functor g_agdjH
          [LclId] =
              [$dTraversable1_sgdXB] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sgdXB; } in
        let {
          sat_sgdXC [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_agdjG
          [LclId] =
              [$dTraversable_sgdXA] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sgdXA;
        } in  Data.Functor.Compose.$fFunctorCompose sat_sgdXC sat_sgdXD;

Data.Functor.Compose.$fTraversableCompose_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Compose.Compose f g (f1 a)
     -> f1 (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(U)),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXE
           $dTraversable1_sgdXF
           $dApplicative_sgdXG
           eta_B1]
        Data.Functor.Compose.$fTraversableCompose_$ctraverse
            $dTraversable_sgdXE
            $dTraversable1_sgdXF
            $dApplicative_sgdXG
            GHC.Base.id
            eta_B1;

Data.Functor.Compose.$fTraversableCompose_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXH
           $dTraversable1_sgdXI
           $dMonad_sgdXJ
           eta_sgdXK
           eta1_sgdXL]
        case GHC.Base.$p1Monad $dMonad_sgdXJ of sat_sgdXM {
          __DEFAULT ->
              Data.Functor.Compose.$fTraversableCompose_$ctraverse
                  $dTraversable_sgdXH
                  $dTraversable1_sgdXI
                  sat_sgdXM
                  eta_sgdXK
                  eta1_sgdXL;
        };

Data.Functor.Compose.$fTraversableCompose_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Compose.Compose f g (m a)
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgdXN
           $dTraversable1_sgdXO
           $dMonad_sgdXP
           eta_sgdXQ]
        case GHC.Base.$p1Monad $dMonad_sgdXP of sat_sgdXR {
          __DEFAULT ->
              Data.Functor.Compose.$fTraversableCompose_$ctraverse
                  $dTraversable_sgdXN
                  $dTraversable1_sgdXO
                  sat_sgdXR
                  GHC.Base.id
                  eta_sgdXQ;
        };

Data.Functor.Compose.$fTraversableCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(U),A),1*U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dTraversable_sgdXS $dTraversable1_sgdXT]
        let {
          sat_sgdXZ [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Compose.Compose f_agdjG g_agdjH (m a)
               -> m (Data.Functor.Compose.Compose f_agdjG g_agdjH a)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$csequence
                      $dTraversable_sgdXS $dTraversable1_sgdXT eta_B2 eta_B1; } in
        let {
          sat_sgdXY [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Compose.Compose f_agdjG g_agdjH a
               -> m (Data.Functor.Compose.Compose f_agdjG g_agdjH b)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$cmapM
                      $dTraversable_sgdXS $dTraversable1_sgdXT eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdXX [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Compose.Compose f_agdjG g_agdjH (f a)
               -> f (Data.Functor.Compose.Compose f_agdjG g_agdjH a)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$csequenceA
                      $dTraversable_sgdXS $dTraversable1_sgdXT eta_B2 eta_B1; } in
        let {
          sat_sgdXW [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Compose.Compose f_agdjG g_agdjH a
               -> f (Data.Functor.Compose.Compose f_agdjG g_agdjH b)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$ctraverse
                      $dTraversable_sgdXS $dTraversable1_sgdXT eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdXV [Occ=Once]
            :: Data.Foldable.Foldable
                 (Data.Functor.Compose.Compose f_agdjG g_agdjH)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \u []
                  Data.Functor.Compose.$fTraversableCompose_$cp2Traversable
                      $dTraversable_sgdXS $dTraversable1_sgdXT; } in
        let {
          sat_sgdXU [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Compose.Compose f_agdjG g_agdjH)
          [LclId] =
              [$dTraversable_sgdXS $dTraversable1_sgdXT] \u []
                  Data.Functor.Compose.$fTraversableCompose_$cp1Traversable
                      $dTraversable_sgdXS $dTraversable1_sgdXT;
        } in 
          Data.Traversable.C:Traversable [sat_sgdXU
                                          sat_sgdXV
                                          sat_sgdXW
                                          sat_sgdXX
                                          sat_sgdXY
                                          sat_sgdXZ];

Data.Functor.Compose.$fApplicativeCompose4
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> f (g c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(U),A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdY0
           $dApplicative1_sgdY1
           f1_sgdY2
           ds_sgdY3
           ds1_sgdY4]
        let {
          sat_sgdY5 [Occ=Once]
            :: g_agdie a_agdj0 -> g_agdie b_agdj1 -> g_agdie c_agdj2
          [LclId] =
              [$dApplicative1_sgdY1 f1_sgdY2] \u []
                  GHC.Base.liftA2 $dApplicative1_sgdY1 f1_sgdY2;
        } in 
          GHC.Base.liftA2 $dApplicative_sgdY0 sat_sgdY5 ds_sgdY3 ds1_sgdY4;

Data.Functor.Compose.$fApplicativeCompose5
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g (a -> b)
     -> Data.Functor.Compose.Compose f g a -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,1*U,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdY6 $dApplicative1_sgdY7 ds_sgdY8 ds1_sgdY9]
        let {
          sat_sgdYa [Occ=Once]
            :: g_Xgdlx (a_agdiF -> b_agdiG)
               -> g_Xgdlx a_agdiF -> g_Xgdlx b_agdiG
          [LclId] =
              [$dApplicative1_sgdY7] \u [] GHC.Base.<*> $dApplicative1_sgdY7;
        } in 
          GHC.Base.liftA2 $dApplicative_sgdY6 sat_sgdYa ds_sgdY8 ds1_sgdY9;

Data.Functor.Compose.$fApplicativeCompose6
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a. a -> f (g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdYb $dApplicative1_sgdYc x_sgdYd]
        let {
          sat_sgdYe [Occ=Once] :: g_XgdlH a_agdio
          [LclId] =
              [$dApplicative1_sgdYc x_sgdYd] \u []
                  GHC.Base.pure $dApplicative1_sgdYc x_sgdYd;
        } in  GHC.Base.pure $dApplicative_sgdYb sat_sgdYe;

Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdYf $dApplicative1_sgdYg]
        let {
          sat_sgdYi [Occ=Once, Dmd=<L,U(C(U),A)>] :: GHC.Base.Functor g_XgdlP
          [LclId] =
              [$dApplicative1_sgdYg] \u []
                  GHC.Base.$p1Applicative $dApplicative1_sgdYg; } in
        let {
          sat_sgdYh [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_XgdlN
          [LclId] =
              [$dApplicative_sgdYf] \u []
                  GHC.Base.$p1Applicative $dApplicative_sgdYf;
        } in  Data.Functor.Compose.$fFunctorCompose sat_sgdYh sat_sgdYi;

Data.Functor.Compose.$fApplicativeCompose3
  :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgdYj eta_sgdYk] eta_sgdYk;

Data.Functor.Compose.$fApplicativeCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),U(1*U(1*C1(C1(U)),A),A,A,1*C1(C1(C1(U))),A,A)><L,U(1*U(1*C1(U),A),A,1*U,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdYl
           $dApplicative1_sgdYm
           eta_sgdYn
           eta1_sgdYo]
        let {
          sat_sgdYt [Occ=Once] :: f_XgdlX (g_XgdlZ (b_agdjo -> b_agdjo))
          [LclId] =
              [$dApplicative_sgdYl $dApplicative1_sgdYm eta_sgdYn] \u []
                  let {
                    sat_sgdYs [Occ=Once]
                      :: g_XgdlZ a_agdjn -> g_XgdlZ (b_agdjo -> b_agdjo)
                    [LclId] =
                        [$dApplicative1_sgdYm] \u []
                            case GHC.Base.$p1Applicative $dApplicative1_sgdYm of sat_sgdYr {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sgdYr Data.Functor.Compose.$fApplicativeCompose3;
                            };
                  } in 
                    case GHC.Base.$p1Applicative $dApplicative_sgdYl of sat_sgdYq {
                      __DEFAULT -> GHC.Base.fmap sat_sgdYq sat_sgdYs eta_sgdYn;
                    }; } in
        let {
          sat_sgdYp [Occ=Once]
            :: g_XgdlZ (b_agdjo -> b_agdjo)
               -> g_XgdlZ b_agdjo -> g_XgdlZ b_agdjo
          [LclId] =
              [$dApplicative1_sgdYm] \u [] GHC.Base.<*> $dApplicative1_sgdYm;
        } in 
          GHC.Base.liftA2 $dApplicative_sgdYl sat_sgdYp sat_sgdYt eta1_sgdYo;

Data.Functor.Compose.$fApplicativeCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgdYu $dApplicative1_sgdYv ds_sgdYw ds1_sgdYx]
        let {
          sat_sgdYy [Occ=Once]
            :: g_XgdlR a_agdjx -> g_XgdlR b_agdjy -> g_XgdlR a_agdjx
          [LclId] =
              [$dApplicative1_sgdYv] \u []
                  GHC.Base.liftA2 $dApplicative1_sgdYv GHC.Base.const;
        } in 
          GHC.Base.liftA2 $dApplicative_sgdYu sat_sgdYy ds_sgdYw ds1_sgdYx;

Data.Functor.Compose.$fApplicativeCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m] =
    [] \r [$dApplicative_sgdYz $dApplicative1_sgdYA]
        let {
          sat_sgdYG [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose1
                      $dApplicative_sgdYz $dApplicative1_sgdYA eta_B2 eta_B1; } in
        let {
          sat_sgdYF [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose2
                      $dApplicative_sgdYz $dApplicative1_sgdYA eta_B2 eta_B1; } in
        let {
          sat_sgdYE [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ c
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose4
                      $dApplicative_sgdYz $dApplicative1_sgdYA eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgdYD [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ (a -> b)
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose5
                      $dApplicative_sgdYz $dApplicative1_sgdYA eta_B2 eta_B1; } in
        let {
          sat_sgdYC [Occ=Once]
            :: forall a. a -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \r [eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose6
                      $dApplicative_sgdYz $dApplicative1_sgdYA eta_B1; } in
        let {
          sat_sgdYB [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Compose.Compose f_XgdlO g_XgdlQ)
          [LclId] =
              [$dApplicative_sgdYz $dApplicative1_sgdYA] \u []
                  Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative
                      $dApplicative_sgdYz $dApplicative1_sgdYA;
        } in 
          GHC.Base.C:Applicative [sat_sgdYB
                                  sat_sgdYC
                                  sat_sgdYD
                                  sat_sgdYE
                                  sat_sgdYF
                                  sat_sgdYG];

Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgdYH $dApplicative_sgdYI]
        let {
          sat_sgdYJ [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_XgdkR
          [LclId] =
              [$dAlternative_sgdYH] \u []
                  GHC.Base.$p1Alternative $dAlternative_sgdYH;
        } in 
          Data.Functor.Compose.$fApplicativeCompose
              sat_sgdYJ $dApplicative_sgdYI;

Data.Functor.Compose.$fAlternativeCompose_$csome
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     forall a.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U(A,C(U),A,C(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgdYK $dApplicative_sgdYL eta_sgdYM]
        let {
          some_v_sgdYN [Occ=LoopBreaker] :: f_XgdkU (g_XgdkW [a_agdhY])
          [LclId] =
              [$dAlternative_sgdYK
               $dApplicative_sgdYL
               eta_sgdYM
               some_v_sgdYN] \u []
                  case
                      GHC.Base.$p1Alternative $dAlternative_sgdYK
                  of
                  $dApplicative1_sgdYO [Dmd=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                  { __DEFAULT ->
                        let {
                          sat_sgdYS [Occ=Once] :: f_XgdkU (g_XgdkW [a_agdhY])
                          [LclId] =
                              [$dAlternative_sgdYK
                               $dApplicative_sgdYL
                               some_v_sgdYN
                               $dApplicative1_sgdYO] \u []
                                  let {
                                    sat_sgdYR [Occ=Once] :: f_XgdkU (g_XgdkW [a_agdhY])
                                    [LclId] =
                                        [$dApplicative_sgdYL $dApplicative1_sgdYO] \u []
                                            let {
                                              sat_sgdYQ [Occ=Once] :: g_XgdkW [a_agdhY]
                                              [LclId] =
                                                  [$dApplicative_sgdYL] \u []
                                                      GHC.Base.pure
                                                          $dApplicative_sgdYL GHC.Types.[];
                                            } in  GHC.Base.pure $dApplicative1_sgdYO sat_sgdYQ;
                                  } in 
                                    GHC.Base.<|> $dAlternative_sgdYK some_v_sgdYN sat_sgdYR; } in
                        let {
                          sat_sgdYP [Occ=Once]
                            :: g_XgdkW a_agdhY -> g_XgdkW [a_agdhY] -> g_XgdkW [a_agdhY]
                          [LclId] =
                              [$dApplicative_sgdYL] \u []
                                  GHC.Base.liftA2 $dApplicative_sgdYL GHC.Types.:;
                        } in 
                          GHC.Base.liftA2 $dApplicative1_sgdYO sat_sgdYP eta_sgdYM sat_sgdYS;
                  };
        } in  some_v_sgdYN;

Data.Functor.Compose.$fAlternativeCompose_$cmany
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     forall a.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U(A,C(U),A,C(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgdYT $dApplicative_sgdYU eta_sgdYV]
        let {
          many_v_sgdYW [Occ=LoopBreaker] :: f_XgdkT (g_XgdkV [a_agdi6])
          [LclId] =
              [$dAlternative_sgdYT
               $dApplicative_sgdYU
               eta_sgdYV
               many_v_sgdYW] \u []
                  let {
                    $dApplicative1_sgdYX [Dmd=<L,U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                      :: GHC.Base.Applicative f_XgdkT
                    [LclId] =
                        [$dAlternative_sgdYT] \u []
                            GHC.Base.$p1Alternative $dAlternative_sgdYT; } in
                  let {
                    sat_sgdZ1 [Occ=Once] :: f_XgdkT (g_XgdkV [a_agdi6])
                    [LclId] =
                        [$dApplicative_sgdYU $dApplicative1_sgdYX] \u []
                            let {
                              sat_sgdZ0 [Occ=Once] :: g_XgdkV [a_agdi6]
                              [LclId] =
                                  [$dApplicative_sgdYU] \u []
                                      GHC.Base.pure $dApplicative_sgdYU GHC.Types.[];
                            } in  GHC.Base.pure $dApplicative1_sgdYX sat_sgdZ0; } in
                  let {
                    sat_sgdYZ [Occ=Once] :: f_XgdkT (g_XgdkV [a_agdi6])
                    [LclId] =
                        [$dApplicative_sgdYU
                         eta_sgdYV
                         many_v_sgdYW
                         $dApplicative1_sgdYX] \u []
                            let {
                              sat_sgdYY [Occ=Once]
                                :: g_XgdkV a_agdi6 -> g_XgdkV [a_agdi6] -> g_XgdkV [a_agdi6]
                              [LclId] =
                                  [$dApplicative_sgdYU] \u []
                                      GHC.Base.liftA2 $dApplicative_sgdYU GHC.Types.:;
                            } in 
                              GHC.Base.liftA2
                                  $dApplicative1_sgdYX sat_sgdYY eta_sgdYV many_v_sgdYW;
                  } in  GHC.Base.<|> $dAlternative_sgdYT sat_sgdYZ sat_sgdZ1;
        } in  many_v_sgdYW;

Data.Functor.Compose.$fAlternativeCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     GHC.Base.Alternative (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A),1*U,U,A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m] =
    [] \r [$dAlternative_sgdZ2 $dApplicative_sgdZ3]
        let {
          sat_sgdZ8 [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU [a]
          [LclId] =
              [$dAlternative_sgdZ2 $dApplicative_sgdZ3] \r [eta_B1]
                  Data.Functor.Compose.$fAlternativeCompose_$cmany
                      $dAlternative_sgdZ2 $dApplicative_sgdZ3 eta_B1; } in
        let {
          sat_sgdZ7 [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU [a]
          [LclId] =
              [$dAlternative_sgdZ2 $dApplicative_sgdZ3] \r [eta_B1]
                  Data.Functor.Compose.$fAlternativeCompose_$csome
                      $dAlternative_sgdZ2 $dApplicative_sgdZ3 eta_B1; } in
        let {
          sat_sgdZ6 [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
          [LclId] =
              [$dAlternative_sgdZ2] \u [] GHC.Base.<|> $dAlternative_sgdZ2; } in
        let {
          sat_sgdZ5 [Occ=Once]
            :: forall a. Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
          [LclId] =
              [$dAlternative_sgdZ2] \u []
                  GHC.Base.empty $dAlternative_sgdZ2; } in
        let {
          sat_sgdZ4 [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Compose.Compose f_XgdkS g_XgdkU)
          [LclId] =
              [$dAlternative_sgdZ2 $dApplicative_sgdZ3] \u []
                  Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative
                      $dAlternative_sgdZ2 $dApplicative_sgdZ3;
        } in 
          GHC.Base.C:Alternative [sat_sgdZ4
                                  sat_sgdZ5
                                  sat_sgdZ6
                                  sat_sgdZ7
                                  sat_sgdZ8];

Data.Functor.Compose.$fGeneric1Compose1
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     forall (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Compose.Compose f g) a -> f (g a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgdZ9 ds_sgdZa]
        GHC.Base.fmap $dFunctor_sgdZ9 GHC.Generics.$fGeneric1:.:2 ds_sgdZa;

Data.Functor.Compose.$fGeneric1Compose3
  :: forall k (g :: k -> *) (a :: k). g a -> g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgdZb] v_sgdZb;

Data.Functor.Compose.$fGeneric1Compose2
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     forall (a :: k).
     Data.Functor.Compose.Compose f g a -> f (GHC.Generics.Rec1 g a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgdZc x_sgdZd]
        GHC.Base.fmap
            $dFunctor_sgdZc Data.Functor.Compose.$fGeneric1Compose3 x_sgdZd;

Data.Functor.Compose.$fGeneric1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     GHC.Generics.Generic1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sgdZe]
        let {
          sat_sgdZg [Occ=Once]
            :: forall (a :: k).
               GHC.Generics.Rep1 (Data.Functor.Compose.Compose f_XgdjE g_XgdjI) a
               -> Data.Functor.Compose.Compose f_XgdjE g_XgdjI a
          [LclId] =
              [$dFunctor_sgdZe] \r [eta_B1]
                  Data.Functor.Compose.$fGeneric1Compose1
                      $dFunctor_sgdZe eta_B1; } in
        let {
          sat_sgdZf [Occ=Once]
            :: forall (a :: k).
               Data.Functor.Compose.Compose f_XgdjE g_XgdjI a
               -> GHC.Generics.Rep1
                    (Data.Functor.Compose.Compose f_XgdjE g_XgdjI) a
          [LclId] =
              [$dFunctor_sgdZe] \r [eta_B1]
                  Data.Functor.Compose.$fGeneric1Compose2 $dFunctor_sgdZe eta_B1;
        } in  GHC.Generics.C:Generic1 [sat_sgdZf sat_sgdZg];

Data.Functor.Compose.$fGenericCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) x.
     GHC.Generics.Rep (Data.Functor.Compose.Compose f g a) x
     -> GHC.Generics.Rep (Data.Functor.Compose.Compose f g a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgdZh] ds_sgdZh;

Data.Functor.Compose.$fGenericCompose2
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) x.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sgdZi] x1_sgdZi;

Data.Functor.Compose.$fGenericCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     GHC.Generics.Generic (Data.Functor.Compose.Compose f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Compose.$fGenericCompose2
                                           Data.Functor.Compose.$fGenericCompose1];

Data.Functor.Compose.getCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgdZj] ds_sgdZj;

Data.Functor.Compose.getCompose
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> f (g a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Compose.getCompose1 eta_B1;

$cCompose1_rgdPU :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getCompose"#;

$cCompose2_rgdPV :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $cCompose1_rgdPU;

$cCompose3_rgdPW :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$cCompose2_rgdPV GHC.Types.[]];

go61_rgdPX
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgdZk _ys_sgdZl]
        case ds2_sgdZk of {
          [] -> GHC.List.badHead;
          : ipv_sgdZn [Occ=Once!] ipv1_sgdZo [Occ=Once] ->
              case _ys_sgdZl of {
                [] -> GHC.List.badHead;
                : ipv2_sgdZq [Occ=Once] ipv3_sgdZr [Occ=Once] ->
                    case ipv_sgdZn of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgdZu [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sgdZu Data.Functor.Compose.$fDataCompose6
                          of
                          { GHC.Types.False -> go61_rgdPX ipv1_sgdZo ipv3_sgdZr;
                            GHC.Types.True -> ipv2_sgdZq;
                          };
                    };
              };
        };

$cCompose4_rgdPY :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cCompose5_rgdPZ];
Data.Functor.Compose.$fDataCompose5 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Compose.$cCompose GHC.Types.[]];
Data.Functor.Compose.$fDataCompose4 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Functor.Compose.$fDataCompose5];
Data.Functor.Compose.$tCompose :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Functor.Compose.$fDataCompose6
                                       Data.Functor.Compose.$fDataCompose4];
Data.Functor.Compose.$cCompose [Occ=LoopBreaker]
  :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cCompose4_rgdPY
                                     Data.Functor.Compose.$fDataCompose6
                                     $cCompose3_rgdPW
                                     Data.Data.Prefix
                                     Data.Functor.Compose.$tCompose];
$cCompose5_rgdPZ :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rgdPX Data.Functor.Compose.$fDataCompose5 Data.Data.mkConstr1;

Data.Functor.Compose.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Compose.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$trModule4];

Data.Functor.Compose.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Compose"#;

Data.Functor.Compose.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$trModule2];

Data.Functor.Compose.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Compose.$trModule3
                                     Data.Functor.Compose.$trModule1];

$krep_rgdQ0 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_rgdQ1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgdQ0 GHC.Types.krep$*];

$krep2_rgdQ2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_rgdQ3 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_rgdQ2
                                         GHC.Types.krep$*];

$krep4_rgdQ4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgdQ0 $krep2_rgdQ2];

$krep5_rgdQ5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_rgdQ4 $krep1_rgdQ1];

Data.Functor.Compose.$fDataCompose9 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rgdQ3 $krep5_rgdQ5];

$krep6_rgdQ6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep7_rgdQ7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep8_rgdQ8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [4#];

$krep9_rgdQ9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep6_rgdQ6 $krep8_rgdQ8];

$krep10_rgdQa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep7_rgdQ7 $krep9_rgdQ9];

Data.Functor.Compose.$fDataCompose10 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$fDataCompose7];

Data.Functor.Compose.$tcCompose :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6729400645769595507##
                                    7487202375031942550##
                                    Data.Functor.Compose.$trModule
                                    Data.Functor.Compose.$fDataCompose10
                                    2#
                                    Data.Functor.Compose.$fDataCompose9];

$krep11_rgdQb :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep8_rgdQ8 GHC.Types.[]];

$krep12_rgdQc :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_rgdQ6 $krep11_rgdQb];

$krep13_rgdQd :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep7_rgdQ7 $krep12_rgdQc];

$krep14_rgdQe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgdQ0 $krep13_rgdQd];

$krep15_rgdQf :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgdQ2 $krep14_rgdQe];

$krep16_rgdQg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Compose.$tcCompose
                                              $krep15_rgdQf];

Data.Functor.Compose.$tc'Compose1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_rgdQa $krep16_rgdQg];

Data.Functor.Compose.$tc'Compose3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Compose"#;

Data.Functor.Compose.$tc'Compose2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$tc'Compose3];

Data.Functor.Compose.$tc'Compose :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7236514282653524344##
                                    13791541438620948974##
                                    Data.Functor.Compose.$trModule
                                    Data.Functor.Compose.$tc'Compose2
                                    5#
                                    Data.Functor.Compose.$tc'Compose1];

Data.Functor.Compose.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Compose.Compose f g a)
[GblId, Arity=5, Str=<S,U><S,U><S,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sgdZz w1_sgdZA w2_sgdZB w3_sgdZC w4_sgdZD]
        let {
          sat_sgdZF [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w4_sgdZD]; } in
        let {
          sat_sgdZG [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sgdZF GHC.Types.[]]; } in
        let {
          sat_sgdZE [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sgdZC]; } in
        let {
          sat_sgdZH [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sgdZE sat_sgdZG];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  6729400645769595507##
                  7487202375031942550##
                  Data.Functor.Compose.$trModule
                  Data.Functor.Compose.$fDataCompose10
                  2#
                  Data.Functor.Compose.$fDataCompose9
                  sat_sgdZH
          of
          { (#,,,,#) ww8_sgdZJ [Occ=Once]
                     ww9_sgdZK [Occ=Once]
                     ww10_sgdZL [Occ=Once]
                     ww11_sgdZM [Occ=Once]
                     ww12_sgdZN [Occ=Once] ->
                let {
                  sat_sgdZO [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Compose.Compose
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sgdZJ
                                                            ww9_sgdZK
                                                            ww10_sgdZL
                                                            ww11_sgdZM
                                                            ww12_sgdZN];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sgdZO w1_sgdZA
                  of
                  sat_sgdZP
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sgdZP w2_sgdZB
                        of
                        sat_sgdZQ
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sgdZQ w_sgdZz;
                        };
                  };
          };

Data.Functor.Compose.$fDataCompose8 [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,U><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sgdZR w1_sgdZS w2_sgdZT w3_sgdZU w4_sgdZV w5_sgdZW]
        Data.Functor.Compose.$w$cp1Data
            w_sgdZR w1_sgdZS w2_sgdZT w3_sgdZU w4_sgdZV;

Data.Functor.Compose.$fDataCompose2
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     f (g a) -> f (g a)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgdZX] v_sgdZX;

Data.Functor.Compose.$fDataCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (f (g a) -> Data.Functor.Compose.Compose f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Compose.$fDataCompose2
                        GHC.Types.False];

Data.Functor.Compose.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgdZY w1_sgdZZ w2_sge00 w3_sge01]
        let {
          lvl8_sge02 [Occ=OnceL]
            :: m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9)
          [LclId] =
              [w1_sgdZZ] \u [] GHC.Base.mzero w1_sgdZZ;
        } in 
          case
              GHC.Base.$p2MonadPlus w1_sgdZZ
          of
          $dMonad_sge03 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sge0p [Occ=Once]
                    :: (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                        GHC.Types.Bool)
                       -> m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9)
                  [LclId] =
                      [lvl8_sge02 $dMonad_sge03] \r [ds_sge0k]
                          case ds_sge0k of {
                            (,) x'_sge0m [Occ=Once] b_sge0n [Occ=Once!] ->
                                case b_sge0n of {
                                  GHC.Types.False -> lvl8_sge02;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sge03 x'_sge0m;
                                };
                          }; } in
                let {
                  sat_sge0j [Occ=Once]
                    :: m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sgdZY w1_sgdZZ w2_sge00 w3_sge01 $dMonad_sge03] \u []
                          let {
                            lvl9_sge04 [Occ=OnceL] :: m_sgdKg (f_sgdK6 (g_sgdK8 a_sgdK9))
                            [LclId] =
                                [w_sgdZY w2_sge00 w3_sge01] \u [] w2_sge00 w_sgdZY w3_sge01; } in
                          let {
                            sat_sge0i [Occ=Once]
                              :: (f_sgdK6 (g_sgdK8 a_sgdK9)
                                  -> Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                  GHC.Types.Bool)
                                 -> m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                             GHC.Types.Bool)
                            [LclId] =
                                [w1_sgdZZ w3_sge01 $dMonad_sge03 lvl9_sge04] \r [ds1_sge06]
                                    case ds1_sge06 of {
                                      (,) h_sge08 b1_sge09 [Occ=Once] ->
                                          let {
                                            sat_sge0h [Occ=Once]
                                              :: m_sgdKg (Data.Functor.Compose.Compose
                                                            f_sgdK6 g_sgdK8 a_sgdK9,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [w3_sge01 $dMonad_sge03 h_sge08 b1_sge09] \u []
                                                    let {
                                                      sat_sge0f [Occ=Once]
                                                        :: Data.Functor.Compose.Compose
                                                             f_sgdK6 g_sgdK8 a_sgdK9
                                                      [LclId] =
                                                          [w3_sge01 h_sge08] \u []
                                                              h_sge08 w3_sge01; } in
                                                    let {
                                                      sat_sge0g [Occ=Once]
                                                        :: (Data.Functor.Compose.Compose
                                                              f_sgdK6 g_sgdK8 a_sgdK9,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sge0f b1_sge09];
                                                    } in 
                                                      GHC.Base.return $dMonad_sge03 sat_sge0g; } in
                                          let {
                                            sat_sge0e [Occ=Once]
                                              :: m_sgdKg (Data.Functor.Compose.Compose
                                                            f_sgdK6 g_sgdK8 a_sgdK9,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sge03 lvl9_sge04 h_sge08] \u []
                                                    let {
                                                      sat_sge0d [Occ=Once]
                                                        :: f_sgdK6 (g_sgdK8 a_sgdK9)
                                                           -> m_sgdKg (Data.Functor.Compose.Compose
                                                                         f_sgdK6 g_sgdK8 a_sgdK9,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sge03 h_sge08] \r [y'_sge0a]
                                                              let {
                                                                sat_sge0b [Occ=Once]
                                                                  :: Data.Functor.Compose.Compose
                                                                       f_sgdK6 g_sgdK8 a_sgdK9
                                                                [LclId] =
                                                                    [h_sge08 y'_sge0a] \u []
                                                                        h_sge08 y'_sge0a; } in
                                                              let {
                                                                sat_sge0c [Occ=Once]
                                                                  :: (Data.Functor.Compose.Compose
                                                                        f_sgdK6 g_sgdK8 a_sgdK9,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sge0b
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sge03 sat_sge0c;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sge03 lvl9_sge04 sat_sge0d;
                                          } in  GHC.Base.mplus w1_sgdZZ sat_sge0e sat_sge0h;
                                    }; } in
                          let {
                            sat_sge05 [Occ=Once]
                              :: m_sgdKg (f_sgdK6 (g_sgdK8 a_sgdK9)
                                          -> Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sge03] \u []
                                    GHC.Base.return
                                        $dMonad_sge03 Data.Functor.Compose.$fDataCompose1;
                          } in  GHC.Base.>>= $dMonad_sge03 sat_sge05 sat_sge0i;
                } in  GHC.Base.>>= $dMonad_sge03 sat_sge0j sat_sge0p;
          };

Data.Functor.Compose.$fDataCompose_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sge0q
           w1_sge0r
           w2_sge0s
           w3_sge0t
           w4_sge0u
           w5_sge0v
           w6_sge0w
           w7_sge0x
           w8_sge0y]
        Data.Functor.Compose.$w$cgmapMp
            w5_sge0v w6_sge0w w7_sge0x w8_sge0y;

Data.Functor.Compose.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sge0z w1_sge0A w2_sge0B w3_sge0C]
        let {
          lvl8_sge0D [Occ=OnceL] :: m_sgdKw (f_sgdKm (g_sgdKo a_sgdKp))
          [LclId] =
              [w_sge0z w2_sge0B w3_sge0C] \u [] w2_sge0B w_sge0z w3_sge0C; } in
        let {
          sat_sge0J [Occ=Once]
            :: (f_sgdKm (g_sgdKo a_sgdKp)
                -> Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
               -> m_sgdKw (Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
          [LclId] =
              [w1_sge0A lvl8_sge0D] \r [c'_sge0F]
                  let {
                    sat_sge0I [Occ=Once]
                      :: f_sgdKm (g_sgdKo a_sgdKp)
                         -> m_sgdKw (Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
                    [LclId] =
                        [w1_sge0A c'_sge0F] \r [x'_sge0G]
                            let {
                              sat_sge0H [Occ=Once]
                                :: Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp
                              [LclId] =
                                  [c'_sge0F x'_sge0G] \u [] c'_sge0F x'_sge0G;
                            } in  GHC.Base.return w1_sge0A sat_sge0H;
                  } in  GHC.Base.>>= w1_sge0A lvl8_sge0D sat_sge0I; } in
        let {
          sat_sge0E [Occ=Once]
            :: m_sgdKw (f_sgdKm (g_sgdKo a_sgdKp)
                        -> Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
          [LclId] =
              [w1_sge0A] \u []
                  GHC.Base.return w1_sge0A Data.Functor.Compose.$fDataCompose2;
        } in  GHC.Base.>>= w1_sge0A sat_sge0E sat_sge0J;

Data.Functor.Compose.$fDataCompose_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sge0K
           w1_sge0L
           w2_sge0M
           w3_sge0N
           w4_sge0O
           w5_sge0P
           w6_sge0Q
           w7_sge0R
           w8_sge0S]
        Data.Functor.Compose.$w$cgmapM w5_sge0P w6_sge0Q w7_sge0R w8_sge0S;

Data.Functor.Compose.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sge0T w1_sge0U w2_sge0V w3_sge0W]
        let {
          lvl8_sge0X [Occ=OnceL]
            :: m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF)
          [LclId] =
              [w1_sge0U] \u [] GHC.Base.mzero w1_sge0U;
        } in 
          case
              GHC.Base.$p2MonadPlus w1_sge0U
          of
          $dMonad_sge0Y [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sge1n [Occ=Once]
                    :: (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                        GHC.Types.Bool)
                       -> m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF)
                  [LclId] =
                      [lvl8_sge0X $dMonad_sge0Y] \r [ds_sge1i]
                          case ds_sge1i of {
                            (,) x'_sge1k [Occ=Once] b_sge1l [Occ=Once!] ->
                                case b_sge1l of {
                                  GHC.Types.False -> lvl8_sge0X;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sge0Y x'_sge1k;
                                };
                          }; } in
                let {
                  sat_sge1h [Occ=Once]
                    :: m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sge0T w1_sge0U w2_sge0V w3_sge0W $dMonad_sge0Y] \u []
                          let {
                            lvl9_sge0Z [Occ=OnceL] :: m_sgdKM (f_sgdKC (g_sgdKE a_sgdKF))
                            [LclId] =
                                [w_sge0T w2_sge0V w3_sge0W] \u [] w2_sge0V w_sge0T w3_sge0W; } in
                          let {
                            sat_sge1g [Occ=Once]
                              :: (f_sgdKC (g_sgdKE a_sgdKF)
                                  -> Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                  GHC.Types.Bool)
                                 -> m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                             GHC.Types.Bool)
                            [LclId] =
                                [w1_sge0U w3_sge0W $dMonad_sge0Y lvl9_sge0Z] \r [ds1_sge11]
                                    case ds1_sge11 of {
                                      (,) h_sge13 b1_sge14 [Occ=Once!] ->
                                          case b1_sge14 of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sge1d [Occ=Once]
                                                    :: m_sgdKM (Data.Functor.Compose.Compose
                                                                  f_sgdKC g_sgdKE a_sgdKF,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [w3_sge0W $dMonad_sge0Y h_sge13] \u []
                                                          let {
                                                            sat_sge1b [Occ=Once]
                                                              :: Data.Functor.Compose.Compose
                                                                   f_sgdKC g_sgdKE a_sgdKF
                                                            [LclId] =
                                                                [w3_sge0W h_sge13] \u []
                                                                    h_sge13 w3_sge0W; } in
                                                          let {
                                                            sat_sge1c [Occ=Once]
                                                              :: (Data.Functor.Compose.Compose
                                                                    f_sgdKC g_sgdKE a_sgdKF,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sge1b
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sge0Y sat_sge1c; } in
                                                let {
                                                  sat_sge1a [Occ=Once]
                                                    :: m_sgdKM (Data.Functor.Compose.Compose
                                                                  f_sgdKC g_sgdKE a_sgdKF,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sge0Y lvl9_sge0Z h_sge13] \u []
                                                          let {
                                                            sat_sge19 [Occ=Once]
                                                              :: f_sgdKC (g_sgdKE a_sgdKF)
                                                                 -> m_sgdKM (Data.Functor.Compose.Compose
                                                                               f_sgdKC
                                                                               g_sgdKE
                                                                               a_sgdKF,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sge0Y
                                                                 h_sge13] \r [y'_sge16]
                                                                    let {
                                                                      sat_sge17 [Occ=Once]
                                                                        :: Data.Functor.Compose.Compose
                                                                             f_sgdKC g_sgdKE a_sgdKF
                                                                      [LclId] =
                                                                          [h_sge13 y'_sge16] \u []
                                                                              h_sge13 y'_sge16; } in
                                                                    let {
                                                                      sat_sge18 [Occ=Once]
                                                                        :: (Data.Functor.Compose.Compose
                                                                              f_sgdKC
                                                                              g_sgdKE
                                                                              a_sgdKF,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sge17
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sge0Y sat_sge18;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sge0Y lvl9_sge0Z sat_sge19;
                                                } in  GHC.Base.mplus w1_sge0U sat_sge1a sat_sge1d;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sge1e [Occ=Once]
                                                    :: Data.Functor.Compose.Compose
                                                         f_sgdKC g_sgdKE a_sgdKF
                                                  [LclId] =
                                                      [w3_sge0W h_sge13] \u []
                                                          h_sge13 w3_sge0W; } in
                                                let {
                                                  sat_sge1f [Occ=Once]
                                                    :: (Data.Functor.Compose.Compose
                                                          f_sgdKC g_sgdKE a_sgdKF,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sge1e GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sge0Y sat_sge1f;
                                          };
                                    }; } in
                          let {
                            sat_sge10 [Occ=Once]
                              :: m_sgdKM (f_sgdKC (g_sgdKE a_sgdKF)
                                          -> Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sge0Y] \u []
                                    GHC.Base.return
                                        $dMonad_sge0Y Data.Functor.Compose.$fDataCompose1;
                          } in  GHC.Base.>>= $dMonad_sge0Y sat_sge10 sat_sge1g;
                } in  GHC.Base.>>= $dMonad_sge0Y sat_sge1h sat_sge1n;
          };

Data.Functor.Compose.$fDataCompose_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sge1o
           w1_sge1p
           w2_sge1q
           w3_sge1r
           w4_sge1s
           w5_sge1t
           w6_sge1u
           w7_sge1v
           w8_sge1w]
        Data.Functor.Compose.$w$cgmapMo
            w5_sge1t w6_sge1u w7_sge1v w8_sge1w;

lvl4_rgdQh
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sge1x] Data.Functor.Compose.$cCompose;

lvl5_rgdQi
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sge1y] Data.Functor.Compose.$tCompose;

lvl6_rgdQj
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) (t :: *
                                                                 -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Compose.Compose f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sge1z ds_sge1A] GHC.Base.Nothing [];

lvl7_rgdQk
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) (t :: *
                                                                 -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Compose.Compose f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sge1B ds_sge1C] GHC.Base.Nothing [];

Data.Functor.Compose.$fDataCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     Data.Data.Data (Data.Functor.Compose.Compose f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sge1D
           $dTypeable1_sge1E
           $dTypeable2_sge1F
           $dTypeable3_sge1G
           $dTypeable4_sge1H
           $dData_sge1I]
        let {
          sat_sge2v [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sge1I] \r [w_sge2s w1_sge2t w2_sge2u]
                  Data.Functor.Compose.$w$cgmapMo
                      $dData_sge1I w_sge2s w1_sge2t w2_sge2u; } in
        let {
          sat_sge2r [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sge1I] \r [w_sge2o w1_sge2p w2_sge2q]
                  Data.Functor.Compose.$w$cgmapMp
                      $dData_sge1I w_sge2o w1_sge2p w2_sge2q; } in
        let {
          sat_sge2n [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sge1I] \r [w_sge2k w1_sge2l w2_sge2m]
                  Data.Functor.Compose.$w$cgmapM
                      $dData_sge1I w_sge2k w1_sge2l w2_sge2m; } in
        let {
          sat_sge2j [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> u
          [LclId] =
              [$dData_sge1I] \r [ds_sge2d ds1_sge2e x_sge2f]
                  case ds_sge2d of {
                    GHC.Types.I# x1_sge2h [Occ=Once!] ->
                        case x1_sge2h of {
                          __DEFAULT -> Data.Maybe.fromJust1;
                          0# -> ds1_sge2e $dData_sge1I x_sge2f;
                        };
                  }; } in
        let {
          sat_sge2c [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs -> [u]
          [LclId] =
              [$dData_sge1I] \r [ds_sge29 x0_sge2a]
                  let {
                    sat_sge2b [Occ=Once] :: u_agdd2
                    [LclId] =
                        [$dData_sge1I ds_sge29 x0_sge2a] \u []
                            ds_sge29 $dData_sge1I x0_sge2a;
                  } in  : [sat_sge2b GHC.Types.[]]; } in
        let {
          sat_sge28 [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> r
          [LclId] =
              [$dData_sge1I] \r [ds_sge23 ds1_sge24 ds2_sge25 x0_sge26]
                  let {
                    sat_sge27 [Occ=Once] :: r'_agdcM
                    [LclId] =
                        [$dData_sge1I ds2_sge25 x0_sge26] \u []
                            ds2_sge25 $dData_sge1I x0_sge26;
                  } in  ds_sge23 sat_sge27 ds1_sge24; } in
        let {
          sat_sge22 [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> r
          [LclId] =
              [$dData_sge1I] \r [ds_sge1X ds1_sge1Y ds2_sge1Z eta_sge20]
                  let {
                    sat_sge21 [Occ=Once] :: r'_agdcv
                    [LclId] =
                        [$dData_sge1I ds2_sge1Z eta_sge20] \u []
                            ds2_sge1Z $dData_sge1I eta_sge20;
                  } in  ds_sge1X ds1_sge1Y sat_sge21; } in
        let {
          sat_sge1W [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
          [LclId] =
              [$dData_sge1I] \r [ds_sge1U x0_sge1V]
                  ds_sge1U $dData_sge1I x0_sge1V; } in
        let {
          sat_sge1T [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sge1I] \r [k2_sge1P z_sge1Q ds_sge1R]
                  let {
                    sat_sge1S [Occ=Once]
                      :: c_agdbg (f_Xgdgm (g_Xgdgq a_Xgdgs)
                                  -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
                    [LclId] =
                        [z_sge1Q] \u [] z_sge1Q Data.Functor.Compose.$fDataCompose2;
                  } in  k2_sge1P $dData_sge1I sat_sge1S; } in
        let {
          sat_sge1O [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> c (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sge1I] \r [k2_sge1K z_sge1L ds_sge1M]
                  let {
                    sat_sge1N [Occ=Once]
                      :: c_agdb1 (f_Xgdgm (g_Xgdgq a_Xgdgs)
                                  -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
                    [LclId] =
                        [z_sge1L] \u [] z_sge1L Data.Functor.Compose.$fDataCompose2;
                  } in  k2_sge1K $dData_sge1I sat_sge1N ds_sge1M; } in
        let {
          sat_sge1J [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dTypeable_sge1D
               $dTypeable1_sge1E
               $dTypeable2_sge1F
               $dTypeable3_sge1G
               $dTypeable4_sge1H] \u []
                  Data.Functor.Compose.$w$cp1Data
                      $dTypeable_sge1D
                      $dTypeable1_sge1E
                      $dTypeable2_sge1F
                      $dTypeable3_sge1G
                      $dTypeable4_sge1H;
        } in 
          Data.Data.C:Data [sat_sge1J
                            sat_sge1O
                            sat_sge1T
                            lvl4_rgdQh
                            lvl5_rgdQi
                            lvl6_rgdQj
                            lvl7_rgdQk
                            sat_sge1W
                            sat_sge22
                            sat_sge28
                            sat_sge2c
                            sat_sge2j
                            sat_sge2n
                            sat_sge2r
                            sat_sge2v];


==================== Pre unarise: ====================
2018-03-16 16:12:11.392116155 UTC

$fEq1Compose1_rgdPP
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dEq1_sggZ0
                    $dEq2_sggZ1
                    eq_sggZ2
                    ds_sggZ3
                    ds1_sggZ4]
        let {
          sat_sggZ5 [Occ=Once]
            :: g_agdsJ a_agdsP -> g_agdsJ b_agdsQ -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sggZ1 eq_sggZ2] \u [] $dEq2_sggZ1 eq_sggZ2;
        } in  $dEq1_sggZ0 sat_sggZ5 ds_sggZ3 ds1_sggZ4;

Data.Functor.Compose.$fEq1Compose [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        $fEq1Compose1_rgdPP eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Compose.$fOrd1Compose_$cliftCompare
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sggZ6 $dOrd2_sggZ7 comp_sggZ8 ds_sggZ9 ds1_sggZa]
        let {
          sat_sggZb [Occ=Once]
            :: g_agdsk a_agdsu -> g_agdsk b_agdsv -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sggZ7 comp_sggZ8] \u []
                  Data.Functor.Classes.liftCompare $dOrd2_sggZ7 comp_sggZ8;
        } in 
          Data.Functor.Classes.liftCompare
              $dOrd1_sggZ6 sat_sggZb ds_sggZ9 ds1_sggZa;

Data.Functor.Compose.$fOrd1Compose1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(U),A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sggZc $dOrd2_sggZd eta_sggZe eta1_sggZf eta2_sggZg]
        let {
          sat_sggZh [Occ=Once]
            :: g_agdsk a_adwad -> g_agdsk b_adwae -> GHC.Types.Bool
          [LclId] =
              [$dOrd2_sggZd eta_sggZe] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sggZd eta_sggZe;
        } in 
          Data.Functor.Classes.$p1Ord1
              $dOrd1_sggZc sat_sggZh eta1_sggZf eta2_sggZg;

Data.Functor.Compose.$fOrd1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(U),C(U))>m] =
    [] \r [$dOrd1_sggZi $dOrd2_sggZj]
        let {
          sat_sggZl [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Compose.Compose f_Xgdux g_Xgduz a
               -> Data.Functor.Compose.Compose f_Xgdux g_Xgduz b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sggZi $dOrd2_sggZj] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrd1Compose_$cliftCompare
                      $dOrd1_sggZi $dOrd2_sggZj eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sggZk [Occ=Once]
            :: Data.Functor.Classes.Eq1
                 (Data.Functor.Compose.Compose f_Xgdux g_Xgduz)
          [LclId] =
              [$dOrd1_sggZi $dOrd2_sggZj] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrd1Compose1
                      $dOrd1_sggZi $dOrd2_sggZj eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sggZk sat_sggZl];

Data.Functor.Compose.$fDataCompose7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Compose"#;

Data.Functor.Compose.$fDataCompose6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Compose.$fDataCompose7;

Data.Functor.Compose.$fRead1Compose2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Compose.$fDataCompose6];

Data.Functor.Compose.$fRead1Compose1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*C1(C1(U)),1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sggZm $dRead2_sggZn rp_sggZo rl_sggZp]
        let {
          reader_sggZq [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_agdr6 (g_agdr7 a_agdru))
          [LclId] =
              [$dRead1_sggZm $dRead2_sggZn rp_sggZo rl_sggZp] \u []
                  let {
                    sat_sggZs [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [g_agdr7 a_agdru]
                    [LclId] =
                        [$dRead2_sggZn rp_sggZo rl_sggZp] \u []
                            Data.Functor.Classes.liftReadListPrec
                                $dRead2_sggZn rp_sggZo rl_sggZp; } in
                  let {
                    sat_sggZr [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec (g_agdr7 a_agdru)
                    [LclId] =
                        [$dRead2_sggZn rp_sggZo rl_sggZp] \u []
                            Data.Functor.Classes.liftReadPrec $dRead2_sggZn rp_sggZo rl_sggZp;
                  } in 
                    Data.Functor.Classes.liftReadPrec
                        $dRead1_sggZm sat_sggZr sat_sggZs; } in
        let {
          $wlvl_sggZt [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [reader_sggZq] \r [ww_sggZu w_sggZv]
                  case <=# [ww_sggZu 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sggZA [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sgdH3
                          [LclId] =
                              [reader_sggZq w_sggZv] \r [a1_sggZx]
                                  let {
                                    sat_sggZz [Occ=Once]
                                      :: f_agdr6 (g_agdr7 a_agdru)
                                         -> Text.ParserCombinators.ReadP.P b_sgdH3
                                    [LclId] =
                                        [w_sggZv] \r [a2_sggZy] w_sggZv a2_sggZy;
                                  } in  reader_sggZq Data.Functor.Compose.$fRead1Compose1 sat_sggZz;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Functor.Compose.$fRead1Compose2 sat_sggZA
                          of
                          { Unit# ww2_sggZC [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_sggZC];
                          };
                  }; } in
        let {
          lvl8_sggZD [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sggZt] \r [w_sggZE w1_sggZF]
                  case w_sggZE of {
                    GHC.Types.I# ww1_sggZH [Occ=Once] ->
                        $wlvl_sggZt ww1_sggZH w1_sggZF;
                  }; } in
        let {
          sat_sggZK [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl8_sggZD] \r [eta_sggZI eta1_sggZJ]
                  GHC.Read.list3 lvl8_sggZD eta_sggZI eta1_sggZJ;
        } in  sat_sggZK;

Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sggZL $dRead2_sggZM rp_sggZN rl_sggZO]
        let {
          ds_sggZP [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
          [LclId] =
              [$dRead1_sggZL $dRead2_sggZM rp_sggZN rl_sggZO] \u []
                  let {
                    sat_sggZV [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdrd]
                    [LclId] =
                        [rl_sggZO] \r [n_sggZR w1_sggZS]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sggZO w1_sggZS
                            of
                            { Unit# ww1_sggZU [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sggZU];
                            }; } in
                  let {
                    sat_sggZQ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdrd
                    [LclId] =
                        [rp_sggZN] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sggZN eta_B1;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sggZL $dRead2_sggZM sat_sggZQ sat_sggZV; } in
        let {
          sat_sggZY [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
          [LclId] =
              [ds_sggZP] \r [n_sggZW]
                  let {
                    sat_sggZX [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
                    [LclId] =
                        [ds_sggZP n_sggZW] \u []
                            ds_sggZP
                                n_sggZW Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sggZX;
        } in  sat_sggZY;

Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sggZZ $dRead2_sgh00 rp_sgh01 rl_sgh02]
        let {
          sat_sgh03 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdsb)
          [LclId] =
              [$dRead1_sggZZ $dRead2_sgh00 rp_sgh01 rl_sgh02] \s []
                  Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                      $dRead1_sggZZ $dRead2_sgh00 rp_sgh01 rl_sgh02;
        } in  GHC.Read.list sat_sgh03;

Data.Functor.Compose.$fRead1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))>m] =
    [] \r [$dRead1_sgh04 $dRead2_sgh05]
        let {
          sat_sgh09 [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Compose.Compose f_agdr6 g_agdr7 a]
          [LclId] =
              [$dRead1_sgh04 $dRead2_sgh05] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec
                      $dRead1_sgh04 $dRead2_sgh05 eta_B2 eta_B1; } in
        let {
          sat_sgh08 [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a)
          [LclId] =
              [$dRead1_sgh04 $dRead2_sgh05] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                      $dRead1_sgh04 $dRead2_sgh05 eta_B2 eta_B1; } in
        let {
          sat_sgh07 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Compose.Compose f_agdr6 g_agdr7 a]
          [LclId] =
              [$dRead1_sgh04 $dRead2_sgh05] \u []
                  Data.Functor.Compose.$fRead1Compose_$cliftReadList
                      $dRead1_sgh04 $dRead2_sgh05; } in
        let {
          sat_sgh06 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a)
          [LclId] =
              [$dRead1_sgh04 $dRead2_sgh05] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec
                      $dRead1_sgh04 $dRead2_sgh05 eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sgh06
                                        sat_sgh07
                                        sat_sgh08
                                        sat_sgh09];
Data.Functor.Compose.$fRead1Compose_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgh0a $dRead2_sgh0b]
        let {
          sat_sgh0c [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7)
          [LclId] =
              [$dRead1_sgh0a $dRead2_sgh0b] \u []
                  Data.Functor.Compose.$fRead1Compose $dRead1_sgh0a $dRead2_sgh0b;
        } in  Data.Functor.Classes.liftReadListDefault sat_sgh0c;

Data.Functor.Compose.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> Data.Functor.Compose.Compose f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*C1(C1(U)),1*C1(C1(U)))><L,U><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh0d w1_sgh0e w2_sgh0f w3_sgh0g ww_sgh0h w4_sgh0i]
        let {
          sat_sgh0l [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sgdHs (g_sgdHt a_sgdHw) -> GHC.Show.ShowS
          [LclId] =
              [w_sgh0d w1_sgh0e w2_sgh0f w3_sgh0g] \s []
                  let {
                    sat_sgh0k [Occ=Once] :: [g_sgdHt a_sgdHw] -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sgh0e w2_sgh0f w3_sgh0g] \u []
                            Data.Functor.Classes.liftShowList w1_sgh0e w2_sgh0f w3_sgh0g; } in
                  let {
                    sat_sgh0j [Occ=Once]
                      :: GHC.Types.Int -> g_sgdHt a_sgdHw -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sgh0e w2_sgh0f w3_sgh0g] \u []
                            Data.Functor.Classes.liftShowsPrec w1_sgh0e w2_sgh0f w3_sgh0g;
                  } in 
                    Data.Functor.Classes.liftShowsPrec w_sgh0d sat_sgh0j sat_sgh0k;
        } in 
          Data.Functor.Classes.$wshowsUnaryWith
              sat_sgh0l Data.Functor.Compose.$fDataCompose6 ww_sgh0h w4_sgh0i;

Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Compose.Compose f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh0m w1_sgh0n w2_sgh0o w3_sgh0p w4_sgh0q w5_sgh0r]
        case w4_sgh0q of {
          GHC.Types.I# ww1_sgh0t [Occ=Once] ->
              Data.Functor.Compose.$w$cliftShowsPrec
                  w_sgh0m w1_sgh0n w2_sgh0o w3_sgh0p ww1_sgh0t w5_sgh0r;
        };

Data.Functor.Compose.$fDataCompose3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Compose.$fShow1Compose_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Compose.Compose f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgh0u
           $dShow2_sgh0v
           sp_sgh0w
           sl_sgh0x
           eta_sgh0y
           eta1_sgh0z]
        let {
          sat_sgh0B [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdqk g_agdql a_agdqZ
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh0u $dShow2_sgh0v sp_sgh0w sl_sgh0x] \r [w_sgh0A]
                  Data.Functor.Compose.$w$cliftShowsPrec
                      $dShow1_sgh0u $dShow2_sgh0v sp_sgh0w sl_sgh0x 0# w_sgh0A;
        } in  GHC.Show.showList__ sat_sgh0B eta_sgh0y eta1_sgh0z;

Data.Functor.Compose.$fShow1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))>m] =
    [] \r [$dShow1_sgh0C $dShow2_sgh0D]
        let {
          sat_sgh0F [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Compose.Compose f_agdqk g_agdql a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh0C $dShow2_sgh0D] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fShow1Compose_$cliftShowList
                      $dShow1_sgh0C $dShow2_sgh0D eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh0E [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Compose.Compose f_agdqk g_agdql a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh0C $dShow2_sgh0D] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec
                      $dShow1_sgh0C $dShow2_sgh0D eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sgh0E sat_sgh0F];

Data.Functor.Compose.$fEqCompose_$c==
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,1*U(1*U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgh0G $dEq2_sgh0H $dEq_sgh0I eta_sgh0J eta1_sgh0K]
        let {
          sat_sgh0M [Occ=Once]
            :: g_agdq0 a_agdq1 -> g_agdq0 a_agdq1 -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sgh0H $dEq_sgh0I] \u []
                  let {
                    sat_sgh0L [Occ=Once] :: a_agdq1 -> a_agdq1 -> GHC.Types.Bool
                    [LclId] =
                        [$dEq_sgh0I] \u [] GHC.Classes.== $dEq_sgh0I;
                  } in  $dEq2_sgh0H sat_sgh0L;
        } in  $dEq1_sgh0G sat_sgh0M eta_sgh0J eta1_sgh0K;

Data.Functor.Compose.$fEqCompose_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,1*U(1*U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgh0N $dEq2_sgh0O $dEq_sgh0P eta_sgh0Q eta1_sgh0R]
        let {
          sat_sgh0T [Occ=Once]
            :: g_agdq0 a_agdq1 -> g_agdq0 a_agdq1 -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sgh0O $dEq_sgh0P] \u []
                  let {
                    sat_sgh0S [Occ=Once] :: a_agdq1 -> a_agdq1 -> GHC.Types.Bool
                    [LclId] =
                        [$dEq_sgh0P] \u [] GHC.Classes.== $dEq_sgh0P;
                  } in  $dEq2_sgh0O sat_sgh0S;
        } in 
          case $dEq1_sgh0N sat_sgh0T eta_sgh0Q eta1_sgh0R of {
            GHC.Types.False -> GHC.Types.True [];
            GHC.Types.True -> GHC.Types.False [];
          };

Data.Functor.Compose.$fEqCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(U)><L,U(U,A)>m] =
    [] \r [$dEq1_sgh0V $dEq2_sgh0W $dEq_sgh0X]
        let {
          sat_sgh0Z [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgh0V $dEq2_sgh0W $dEq_sgh0X] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fEqCompose_$c/=
                      $dEq1_sgh0V $dEq2_sgh0W $dEq_sgh0X eta_B2 eta_B1; } in
        let {
          sat_sgh0Y [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgh0V $dEq2_sgh0W $dEq_sgh0X] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fEqCompose_$c==
                      $dEq1_sgh0V $dEq2_sgh0W $dEq_sgh0X eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sgh0Y sat_sgh0Z];

Data.Functor.Compose.$fOrdCompose_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh10 $dOrd2_sgh11 $dOrd_sgh12 eta_sgh13 eta1_sgh14]
        let {
          sat_sgh16 [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh11 $dOrd_sgh12] \u []
                  let {
                    sat_sgh15 [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh12] \u [] GHC.Classes.compare $dOrd_sgh12;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh11 sat_sgh15;
        } in 
          Data.Functor.Classes.liftCompare
              $dOrd1_sgh10 sat_sgh16 eta_sgh13 eta1_sgh14;

Data.Functor.Compose.$fOrdCompose_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(U),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh17 $dOrd2_sgh18 $dOrd_sgh19]
        let {
          sat_sgh1c [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_agdpd
          [LclId] =
              [$dOrd_sgh19] \u [] GHC.Classes.$p1Ord $dOrd_sgh19; } in
        let {
          sat_sgh1b [Occ=Once, Dmd=<L,C(U)>]
            :: Data.Functor.Classes.Eq1 g_agdpc
          [LclId] =
              [$dOrd2_sgh18] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sgh18; } in
        let {
          sat_sgh1a [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_agdpb
          [LclId] =
              [$dOrd1_sgh17] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sgh17;
        } in 
          Data.Functor.Compose.$fEqCompose sat_sgh1a sat_sgh1b sat_sgh1c;

Data.Functor.Compose.$fOrdCompose_$c<
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1d $dOrd2_sgh1e $dOrd_sgh1f x_sgh1g y_sgh1h]
        let {
          sat_sgh1j [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1e $dOrd_sgh1f] \u []
                  let {
                    sat_sgh1i [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1f] \u [] GHC.Classes.compare $dOrd_sgh1f;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1e sat_sgh1i;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1d sat_sgh1j x_sgh1g y_sgh1h
          of
          { __DEFAULT -> GHC.Types.False [];
            GHC.Types.LT -> GHC.Types.True [];
          };

Data.Functor.Compose.$fOrdCompose_$c>=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1l $dOrd2_sgh1m $dOrd_sgh1n x_sgh1o y_sgh1p]
        let {
          sat_sgh1r [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1m $dOrd_sgh1n] \u []
                  let {
                    sat_sgh1q [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1n] \u [] GHC.Classes.compare $dOrd_sgh1n;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1m sat_sgh1q;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1l sat_sgh1r x_sgh1o y_sgh1p
          of
          { __DEFAULT -> GHC.Types.True [];
            GHC.Types.LT -> GHC.Types.False [];
          };

Data.Functor.Compose.$fOrdCompose_$c>
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1t $dOrd2_sgh1u $dOrd_sgh1v x_sgh1w y_sgh1x]
        let {
          sat_sgh1z [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1u $dOrd_sgh1v] \u []
                  let {
                    sat_sgh1y [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1v] \u [] GHC.Classes.compare $dOrd_sgh1v;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1u sat_sgh1y;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1t sat_sgh1z x_sgh1w y_sgh1x
          of
          { __DEFAULT -> GHC.Types.False [];
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Compose.$fOrdCompose_$c<=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1B $dOrd2_sgh1C $dOrd_sgh1D x_sgh1E y_sgh1F]
        let {
          sat_sgh1H [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1C $dOrd_sgh1D] \u []
                  let {
                    sat_sgh1G [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1D] \u [] GHC.Classes.compare $dOrd_sgh1D;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1C sat_sgh1G;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1B sat_sgh1H x_sgh1E y_sgh1F
          of
          { __DEFAULT -> GHC.Types.True [];
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Compose.$fOrdCompose_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1J $dOrd2_sgh1K $dOrd_sgh1L x_sgh1M y_sgh1N]
        let {
          sat_sgh1P [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1K $dOrd_sgh1L] \u []
                  let {
                    sat_sgh1O [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1L] \u [] GHC.Classes.compare $dOrd_sgh1L;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1K sat_sgh1O;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1J sat_sgh1P x_sgh1M y_sgh1N
          of
          { __DEFAULT -> y_sgh1N;
            GHC.Types.GT -> x_sgh1M;
          };

Data.Functor.Compose.$fOrdCompose_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1R $dOrd2_sgh1S $dOrd_sgh1T x_sgh1U y_sgh1V]
        let {
          sat_sgh1X [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1S $dOrd_sgh1T] \u []
                  let {
                    sat_sgh1W [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1T] \u [] GHC.Classes.compare $dOrd_sgh1T;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1S sat_sgh1W;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1R sat_sgh1X x_sgh1U y_sgh1V
          of
          { __DEFAULT -> x_sgh1U;
            GHC.Types.GT -> y_sgh1V;
          };

Data.Functor.Compose.$fOrdCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(U),C(U))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21]
        let {
          sat_sgh29 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$cmin
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh28 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$cmax
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh27 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c>=
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh26 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c>
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh25 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c<=
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh24 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c<
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh23 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$ccompare
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh22 [Occ=Once]
            :: GHC.Classes.Eq
                 (Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd)
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \u []
                  Data.Functor.Compose.$fOrdCompose_$cp1Ord
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21;
        } in 
          GHC.Classes.C:Ord [sat_sgh22
                             sat_sgh23
                             sat_sgh24
                             sat_sgh25
                             sat_sgh26
                             sat_sgh27
                             sat_sgh28
                             sat_sgh29];

Data.Functor.Compose.$fReadCompose_$creadPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgh2a $dRead2_sgh2b $dRead_sgh2c]
        let {
          sat_sgh2e [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
          [LclId] =
              [$dRead_sgh2c] \u [] GHC.Read.readListPrec $dRead_sgh2c; } in
        let {
          sat_sgh2d [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
          [LclId] =
              [$dRead_sgh2c] \u [] GHC.Read.readPrec $dRead_sgh2c;
        } in 
          Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
              $dRead1_sgh2a $dRead2_sgh2b sat_sgh2d sat_sgh2e;

Data.Functor.Compose.$fReadCompose_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgh2f $dRead2_sgh2g $dRead_sgh2h]
        let {
          ds_sgh2i [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgh2f $dRead2_sgh2g $dRead_sgh2h] \u []
                  let {
                    sat_sgh2k [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
                    [LclId] =
                        [$dRead_sgh2h] \u [] GHC.Read.readListPrec $dRead_sgh2h; } in
                  let {
                    sat_sgh2j [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
                    [LclId] =
                        [$dRead_sgh2h] \u [] GHC.Read.readPrec $dRead_sgh2h;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sgh2f $dRead2_sgh2g sat_sgh2j sat_sgh2k; } in
        let {
          sat_sgh2n [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [ds_sgh2i] \r [n_sgh2l]
                  let {
                    sat_sgh2m [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
                    [LclId] =
                        [ds_sgh2i n_sgh2l] \u []
                            ds_sgh2i
                                n_sgh2l Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgh2m;
        } in  sat_sgh2n;

Data.Functor.Compose.$fReadCompose_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgh2o $dRead2_sgh2p $dRead_sgh2q]
        let {
          sat_sgh2t [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgh2o $dRead2_sgh2p $dRead_sgh2q] \s []
                  let {
                    sat_sgh2s [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
                    [LclId] =
                        [$dRead_sgh2q] \u [] GHC.Read.readListPrec $dRead_sgh2q; } in
                  let {
                    sat_sgh2r [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
                    [LclId] =
                        [$dRead_sgh2q] \u [] GHC.Read.readPrec $dRead_sgh2q;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sgh2o $dRead2_sgh2p sat_sgh2r sat_sgh2s;
        } in  GHC.Read.list sat_sgh2t;

Data.Functor.Compose.$fReadCompose_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgh2u $dRead2_sgh2v $dRead_sgh2w]
        let {
          sat_sgh2x [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgh2u $dRead2_sgh2v $dRead_sgh2w] \u []
                  Data.Functor.Compose.$fReadCompose_$creadListPrec
                      $dRead1_sgh2u
                      $dRead2_sgh2v
                      $dRead_sgh2w
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgh2x;

Data.Functor.Compose.$fReadCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A]
        let {
          sat_sgh2E [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A] \u []
                  Data.Functor.Compose.$fReadCompose_$creadListPrec
                      $dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A; } in
        let {
          sat_sgh2D [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A] \u []
                  Data.Functor.Compose.$fReadCompose_$creadPrec
                      $dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A; } in
        let {
          sat_sgh2C [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A] \u []
                  Data.Functor.Compose.$fReadCompose_$creadList
                      $dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A; } in
        let {
          sat_sgh2B [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A] \u []
                  Data.Functor.Compose.$fReadCompose_$creadsPrec
                      $dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A;
        } in  GHC.Read.C:Read [sat_sgh2B sat_sgh2C sat_sgh2D sat_sgh2E];

Data.Functor.Compose.$fShowCompose_$cshowsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int
     -> Data.Functor.Compose.Compose f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(1*U,A,1*U)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgh2F
           $dShow2_sgh2G
           $dShow_sgh2H
           eta_sgh2I
           eta1_sgh2J]
        case eta_sgh2I of {
          GHC.Types.I# ww1_sgh2L [Occ=Once] ->
              let {
                sat_sgh2N [Occ=Once] :: [a_agdog] -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sgh2H] \u [] GHC.Show.showList $dShow_sgh2H; } in
              let {
                sat_sgh2M [Occ=Once] :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sgh2H] \u [] GHC.Show.showsPrec $dShow_sgh2H;
              } in 
                Data.Functor.Compose.$w$cliftShowsPrec
                    $dShow1_sgh2F
                    $dShow2_sgh2G
                    sat_sgh2M
                    sat_sgh2N
                    ww1_sgh2L
                    eta1_sgh2J;
        };

Data.Functor.Compose.$fShowCompose_$cshow
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Compose.Compose f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*C1(C1(U)),1*C1(C1(U)))><L,U(1*U,A,1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgh2O $dShow2_sgh2P $dShow_sgh2Q x_sgh2R]
        let {
          sp_sgh2S :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgh2Q] \u [] GHC.Show.showsPrec $dShow_sgh2Q; } in
        let {
          sl_sgh2T :: [a_agdog] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgh2Q] \u [] GHC.Show.showList $dShow_sgh2Q; } in
        let {
          sat_sgh2W [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow1_sgh2O $dShow2_sgh2P x_sgh2R sp_sgh2S sl_sgh2T] \u []
                  let {
                    sat_sgh2V [Occ=Once] :: [g_agdof a_agdog] -> GHC.Show.ShowS
                    [LclId] =
                        [$dShow2_sgh2P sp_sgh2S sl_sgh2T] \u []
                            Data.Functor.Classes.liftShowList
                                $dShow2_sgh2P sp_sgh2S sl_sgh2T; } in
                  let {
                    sat_sgh2U [Occ=Once]
                      :: GHC.Types.Int -> g_agdof a_agdog -> GHC.Show.ShowS
                    [LclId] =
                        [$dShow2_sgh2P sp_sgh2S sl_sgh2T] \u []
                            Data.Functor.Classes.liftShowsPrec $dShow2_sgh2P sp_sgh2S sl_sgh2T;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        $dShow1_sgh2O
                        sat_sgh2U
                        sat_sgh2V
                        Data.Functor.Classes.$fRead1Const1
                        x_sgh2R
                        GHC.Types.[]; } in
        let {
          sat_sgh2X [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sgh2W];
        } in  GHC.Base.++ Data.Functor.Compose.$fDataCompose6 sat_sgh2X;

Data.Functor.Compose.$fShowCompose_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Compose.Compose f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgh2Y $dShow2_sgh2Z $dShow_sgh30 ls_sgh31 s_sgh32]
        let {
          lvl8_sgh33 [Occ=OnceL]
            :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgh30] \u [] GHC.Show.showsPrec $dShow_sgh30; } in
        let {
          lvl9_sgh34 [Occ=OnceL] :: [a_agdog] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgh30] \u [] GHC.Show.showList $dShow_sgh30; } in
        let {
          sat_sgh36 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh2Y $dShow2_sgh2Z lvl8_sgh33 lvl9_sgh34] \r [eta_sgh35]
                  Data.Functor.Compose.$w$cliftShowsPrec
                      $dShow1_sgh2Y $dShow2_sgh2Z lvl8_sgh33 lvl9_sgh34 0# eta_sgh35;
        } in  GHC.Show.showList__ sat_sgh36 ls_sgh31 s_sgh32;

Data.Functor.Compose.$fShowCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(U,A,U)>m] =
    [] \r [$dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39]
        let {
          sat_sgh3c [Occ=Once]
            :: [Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshowList
                      $dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39 eta_B2 eta_B1; } in
        let {
          sat_sgh3b [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Base.String
          [LclId] =
              [$dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39] \r [eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshow
                      $dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39 eta_B1; } in
        let {
          sat_sgh3a [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshowsPrec
                      $dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgh3a sat_sgh3b sat_sgh3c];

Data.Functor.Compose.$fFunctorCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b) -> Data.Functor.Compose.Compose f g a -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgh3d $dFunctor1_sgh3e f1_sgh3f ds_sgh3g]
        let {
          sat_sgh3h [Occ=Once] :: g_agdnF a_agdnL -> g_agdnF b_agdnM
          [LclId] =
              [$dFunctor1_sgh3e f1_sgh3f] \u []
                  GHC.Base.fmap $dFunctor1_sgh3e f1_sgh3f;
        } in  GHC.Base.fmap $dFunctor_sgh3d sat_sgh3h ds_sgh3g;

Data.Functor.Compose.$fFunctorCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b. a -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgh3i $dFunctor1_sgh3j x_sgh3k eta_sgh3l]
        let {
          sat_sgh3o [Occ=Once] :: g_Xgdqn b_agdo6 -> g_Xgdqn a_agdo5
          [LclId] =
              [$dFunctor1_sgh3j x_sgh3k] \u []
                  let {
                    sat_sgh3n [Occ=Once] :: b_agdo6 -> a_agdo5
                    [LclId] =
                        [x_sgh3k] \r [ds_sgh3m] x_sgh3k;
                  } in  GHC.Base.fmap $dFunctor1_sgh3j sat_sgh3n;
        } in  GHC.Base.fmap $dFunctor_sgh3i sat_sgh3o eta_sgh3l;

Data.Functor.Compose.$fFunctorCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgh3p $dFunctor1_sgh3q]
        let {
          sat_sgh3s [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm b
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm a
          [LclId] =
              [$dFunctor_sgh3p $dFunctor1_sgh3q] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFunctorCompose1
                      $dFunctor_sgh3p $dFunctor1_sgh3q eta_B2 eta_B1; } in
        let {
          sat_sgh3r [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm a
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm b
          [LclId] =
              [$dFunctor_sgh3p $dFunctor1_sgh3q] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFunctorCompose2
                      $dFunctor_sgh3p $dFunctor1_sgh3q eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sgh3r sat_sgh3s];

Data.Functor.Compose.$fFoldableCompose_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Compose.Compose f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh3t
           $dFoldable1_sgh3u
           $dMonoid_sgh3v
           f1_sgh3w
           ds_sgh3x]
        let {
          sat_sgh3y [Occ=Once] :: g_agdl1 a_agdli -> m_agdlh
          [LclId] =
              [$dFoldable1_sgh3u $dMonoid_sgh3v f1_sgh3w] \u []
                  Data.Foldable.foldMap $dFoldable1_sgh3u $dMonoid_sgh3v f1_sgh3w;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh3t $dMonoid_sgh3v sat_sgh3y ds_sgh3x;

Data.Functor.Compose.$fFoldableCompose_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Compose.Compose f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh3z $dFoldable1_sgh3A $dMonoid_sgh3B ds_sgh3C]
        let {
          sat_sgh3D [Occ=Once] :: g_agdl1 m_agdl7 -> m_agdl7
          [LclId] =
              [$dFoldable1_sgh3A $dMonoid_sgh3B] \u []
                  Data.Foldable.foldMap $dFoldable1_sgh3A $dMonoid_sgh3B GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh3z $dMonoid_sgh3B sat_sgh3D ds_sgh3C;

Data.Functor.Compose.$fFoldableCompose1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgh3E] v_sgh3E;

Data.Functor.Compose.$fFoldableCompose_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh3F $dFoldable1_sgh3G $dNum_sgh3H]
        let {
          $dMonoid_sgh3I
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_agdnl)
          [LclId] =
              [$dNum_sgh3H] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sgh3H; } in
        let {
          lvl8_sgh3J [Occ=OnceL]
            :: g_agdl1 a_agdnl -> Data.Semigroup.Internal.Sum a_agdnl
          [LclId] =
              [$dFoldable1_sgh3G $dMonoid_sgh3I] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh3G
                      $dMonoid_sgh3I
                      Data.Functor.Compose.$fFoldableCompose1; } in
        let {
          sat_sgh3L [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnl
               -> Data.Semigroup.Internal.Sum a_agdnl
          [LclId] =
              [$dFoldable_sgh3F $dMonoid_sgh3I lvl8_sgh3J] \r [ds_sgh3K]
                  Data.Foldable.foldMap
                      $dFoldable_sgh3F $dMonoid_sgh3I lvl8_sgh3J ds_sgh3K;
        } in  sat_sgh3L;

lvl_rgdPQ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Compose.$fFoldableCompose2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rgdPQ of sat_sgh3M {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgh3M;
        };

Data.Functor.Compose.$fFoldableCompose_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh3N $dFoldable1_sgh3O $dOrd_sgh3P]
        let {
          $dMonoid_sgh3Q :: GHC.Base.Monoid (Data.Functor.Utils.Min a_agdnb)
          [LclId] =
              [$dOrd_sgh3P] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sgh3P; } in
        let {
          lvl8_sgh3R [Occ=OnceL]
            :: g_agdl1 a_agdnb -> Data.Functor.Utils.Min a_agdnb
          [LclId] =
              [$dFoldable1_sgh3O $dMonoid_sgh3Q] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh3O $dMonoid_sgh3Q GHC.Base.Just; } in
        let {
          sat_sgh3V [Occ=OnceT[0]]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnb -> a_agdnb
          [LclId] =
              [$dFoldable_sgh3N $dMonoid_sgh3Q lvl8_sgh3R] \r [x_sgh3S]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_sgh3N $dMonoid_sgh3Q lvl8_sgh3R x_sgh3S
                  of
                  { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose2;
                    GHC.Base.Just v_sgh3U [Occ=Once] -> v_sgh3U;
                  };
        } in  sat_sgh3V;

lvl1_rgdPR :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Compose.$fFoldableCompose3 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rgdPR of sat_sgh3W {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgh3W;
        };

Data.Functor.Compose.$fFoldableCompose_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh3X $dFoldable1_sgh3Y $dOrd_sgh3Z]
        let {
          $dMonoid_sgh40 :: GHC.Base.Monoid (Data.Functor.Utils.Max a_agdn1)
          [LclId] =
              [$dOrd_sgh3Z] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sgh3Z; } in
        let {
          lvl8_sgh41 [Occ=OnceL]
            :: g_agdl1 a_agdn1 -> Data.Functor.Utils.Max a_agdn1
          [LclId] =
              [$dFoldable1_sgh3Y $dMonoid_sgh40] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh3Y $dMonoid_sgh40 GHC.Base.Just; } in
        let {
          sat_sgh45 [Occ=OnceT[0]]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdn1 -> a_agdn1
          [LclId] =
              [$dFoldable_sgh3X $dMonoid_sgh40 lvl8_sgh41] \r [x_sgh42]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_sgh3X $dMonoid_sgh40 lvl8_sgh41 x_sgh42
                  of
                  { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose3;
                    GHC.Base.Just v_sgh44 [Occ=Once] -> v_sgh44;
                  };
        } in  sat_sgh45;

Data.Functor.Compose.$fFoldableCompose_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh46 $dFoldable1_sgh47 $dEq_sgh48 eta_sgh49]
        let {
          lvl8_sgh4a [Occ=OnceL]
            :: g_agdl1 a_agdmR -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable1_sgh47 $dEq_sgh48 eta_sgh49] \u []
                  let {
                    sat_sgh4b [Occ=Once] :: a_agdmR -> Data.Semigroup.Internal.Any
                    [LclId] =
                        [$dEq_sgh48 eta_sgh49] \u [] GHC.Classes.== $dEq_sgh48 eta_sgh49;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh47
                        Data.Semigroup.Internal.$fMonoidAny
                        sat_sgh4b; } in
        let {
          sat_sgh4d [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdmR
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sgh46 lvl8_sgh4a] \r [ds_sgh4c]
                  Data.Foldable.foldMap
                      $dFoldable_sgh46
                      Data.Semigroup.Internal.$fMonoidAny
                      lvl8_sgh4a
                      ds_sgh4c;
        } in  sat_sgh4d;

Data.Functor.Compose.$fFoldableCompose7
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Compose.$fFoldableCompose_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh4e
           $dFoldable1_sgh4f
           f1_sgh4g
           z_sgh4h
           t1_sgh4i]
        let {
          sat_sgh4m [Occ=Once]
            :: g_agdl1 a_agdlU
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_agdlT)
          [LclId] =
              [$dFoldable1_sgh4f f1_sgh4g] \u []
                  let {
                    sat_sgh4l [Occ=Once]
                      :: a_agdlU
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo b_agdlT)
                    [LclId] =
                        [f1_sgh4g] \r [x_sgh4j y_sgh4k] f1_sgh4g y_sgh4k x_sgh4j;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh4f
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgh4l;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh4e
              Data.Functor.Compose.$fFoldableCompose7
              sat_sgh4m
              t1_sgh4i
              z_sgh4h;

lvl2_rgdPS :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Compose.$fFoldableCompose6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rgdPS of sat_sgh4n {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgh4n;
        };

Data.Functor.Compose.$fFoldableCompose_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh4o $dFoldable1_sgh4p f1_sgh4q xs_sgh4r]
        let {
          sat_sgh4y [Occ=Once]
            :: g_agdl1 a_agdml
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdml))
          [LclId] =
              [$dFoldable1_sgh4p f1_sgh4q] \u []
                  let {
                    sat_sgh4x [Occ=Once]
                      :: a_agdml
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdml))
                    [LclId] =
                        [f1_sgh4q] \r [x_sgh4s y_sgh4t]
                            let {
                              sat_sgh4w [Occ=Once] :: a_agdml
                              [LclId] =
                                  [f1_sgh4q x_sgh4s y_sgh4t] \u []
                                      case y_sgh4t of {
                                        GHC.Base.Nothing -> x_sgh4s;
                                        GHC.Base.Just x1_sgh4v [Occ=Once] ->
                                            f1_sgh4q x1_sgh4v x_sgh4s;
                                      };
                            } in  GHC.Base.Just [sat_sgh4w];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh4p
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgh4x;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_sgh4o
                  Data.Functor.Compose.$fFoldableCompose7
                  sat_sgh4y
                  xs_sgh4r
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose6;
            GHC.Base.Just v_sgh4A [Occ=Once] -> v_sgh4A;
          };

Data.Functor.Compose.$fFoldableCompose_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh4B
           $dFoldable1_sgh4C
           f1_sgh4D
           z0_sgh4E
           xs_sgh4F]
        let {
          sat_sgh4L [Occ=Once]
            :: g_agdl1 a_agdlJ
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_agdlK -> b_agdlK))
          [LclId] =
              [$dFoldable1_sgh4C f1_sgh4D] \u []
                  let {
                    sat_sgh4K [Occ=Once]
                      :: a_agdlJ
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (b_agdlK -> b_agdlK))
                    [LclId] =
                        [f1_sgh4D] \r [x_sgh4G y_sgh4H z_sgh4I]
                            case f1_sgh4D x_sgh4G z_sgh4I of vx_sgh4J {
                              __DEFAULT -> y_sgh4H vx_sgh4J;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh4C
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgh4K;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh4B
              Data.Functor.Compose.$fFoldableCompose7
              sat_sgh4L
              xs_sgh4F
              GHC.Base.id
              z0_sgh4E;

Data.Functor.Compose.$fFoldableCompose_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh4M
           $dFoldable1_sgh4N
           f1_sgh4O
           z_sgh4P
           t1_sgh4Q]
        let {
          sat_sgh4R [Occ=Once]
            :: g_agdl1 a_agdlz -> Data.Semigroup.Internal.Endo b_agdlA
          [LclId] =
              [$dFoldable1_sgh4N f1_sgh4O] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh4N Data.Semigroup.Internal.$fMonoidEndo f1_sgh4O;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh4M
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgh4R
              t1_sgh4Q
              z_sgh4P;

Data.Functor.Compose.$fFoldableCompose_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh4S
           $dFoldable1_sgh4T
           f1_sgh4U
           z0_sgh4V
           xs_sgh4W]
        let {
          sat_sgh52 [Occ=Once]
            :: g_agdl1 a_agdm4
               -> Data.Semigroup.Internal.Endo (b_agdm3 -> b_agdm3)
          [LclId] =
              [$dFoldable1_sgh4T f1_sgh4U] \u []
                  let {
                    sat_sgh51 [Occ=Once]
                      :: a_agdm4 -> Data.Semigroup.Internal.Endo (b_agdm3 -> b_agdm3)
                    [LclId] =
                        [f1_sgh4U] \r [x_sgh4X k_sgh4Y z_sgh4Z]
                            case f1_sgh4U z_sgh4Z x_sgh4X of vx_sgh50 {
                              __DEFAULT -> k_sgh4Y vx_sgh50;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh4T Data.Semigroup.Internal.$fMonoidEndo sat_sgh51;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh4S
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgh52
              xs_sgh4W
              GHC.Base.id
              z0_sgh4V;

Data.Functor.Compose.$fFoldableCompose4
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sgh53 k_sgh54 z_sgh55]
        case z_sgh55 of {
          GHC.Types.I# x1_sgh57 [Occ=Once] ->
              case +# [x1_sgh57 1#] of sat_sgh58 {
                __DEFAULT ->
                    let {
                      sat_sgh59 [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sgh58];
                    } in  k_sgh54 sat_sgh59;
              };
        };

Data.Functor.Compose.$fFoldableCompose_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh5a $dFoldable1_sgh5b eta_sgh5c]
        let {
          sat_sgh5d [Occ=Once]
            :: g_agdl1 a_agdmJ
               -> Data.Semigroup.Internal.Endo (GHC.Types.Int -> GHC.Types.Int)
          [LclId] =
              [$dFoldable1_sgh5b] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh5b
                      Data.Semigroup.Internal.$fMonoidEndo
                      Data.Functor.Compose.$fFoldableCompose4;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh5a
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgh5d
              eta_sgh5c
              GHC.Base.id
              Data.Functor.Compose.$fDataCompose3;

lvl3_rgdPT :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Compose.$fFoldableCompose8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rgdPT of sat_sgh5e {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgh5e;
        };

Data.Functor.Compose.$fFoldableCompose_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh5f $dFoldable1_sgh5g f1_sgh5h xs_sgh5i]
        let {
          sat_sgh5p [Occ=Once]
            :: g_agdl1 a_agdmd
               -> Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdmd)
          [LclId] =
              [$dFoldable1_sgh5g f1_sgh5h] \u []
                  let {
                    sat_sgh5o [Occ=Once]
                      :: a_agdmd -> Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdmd)
                    [LclId] =
                        [f1_sgh5h] \r [x_sgh5j m_sgh5k]
                            let {
                              sat_sgh5n [Occ=Once] :: a_agdmd
                              [LclId] =
                                  [f1_sgh5h x_sgh5j m_sgh5k] \u []
                                      case m_sgh5k of {
                                        GHC.Base.Nothing -> x_sgh5j;
                                        GHC.Base.Just y_sgh5m [Occ=Once] ->
                                            f1_sgh5h x_sgh5j y_sgh5m;
                                      };
                            } in  GHC.Base.Just [sat_sgh5n];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh5g Data.Semigroup.Internal.$fMonoidEndo sat_sgh5o;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_sgh5f
                  Data.Semigroup.Internal.$fMonoidEndo
                  sat_sgh5p
                  xs_sgh5i
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose8;
            GHC.Base.Just v_sgh5r [Occ=Once] -> v_sgh5r;
          };

Data.Functor.Compose.$fFoldableCompose5
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgh5s ds1_sgh5t] GHC.Types.False [];

Data.Functor.Compose.$fFoldableCompose_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh5u $dFoldable1_sgh5v eta_sgh5w]
        let {
          sat_sgh5x [Occ=Once]
            :: g_agdl1 a_agdmB -> Data.Semigroup.Internal.Endo GHC.Types.Bool
          [LclId] =
              [$dFoldable1_sgh5v] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh5v
                      Data.Semigroup.Internal.$fMonoidEndo
                      Data.Functor.Compose.$fFoldableCompose5;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh5u
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgh5x
              eta_sgh5w
              GHC.Types.True;

Data.Functor.Compose.$fFoldableCompose_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh5y $dFoldable1_sgh5z $dNum_sgh5A]
        let {
          $dMonoid_sgh5B
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_agdnv)
          [LclId] =
              [$dNum_sgh5A] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sgh5A; } in
        let {
          lvl8_sgh5C [Occ=OnceL]
            :: g_agdl1 a_agdnv -> Data.Semigroup.Internal.Product a_agdnv
          [LclId] =
              [$dFoldable1_sgh5z $dMonoid_sgh5B] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh5z
                      $dMonoid_sgh5B
                      Data.Functor.Compose.$fFoldableCompose1; } in
        let {
          sat_sgh5E [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnv
               -> Data.Semigroup.Internal.Product a_agdnv
          [LclId] =
              [$dFoldable_sgh5y $dMonoid_sgh5B lvl8_sgh5C] \r [ds_sgh5D]
                  Data.Foldable.foldMap
                      $dFoldable_sgh5y $dMonoid_sgh5B lvl8_sgh5C ds_sgh5D;
        } in  sat_sgh5E;

Data.Functor.Compose.$fFoldableCompose_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> [a]
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh5F $dFoldable1_sgh5G eta_sgh5H]
        let {
          sat_sgh5I [Occ=Once]
            :: g_agdl1 a_agdmt -> Data.Semigroup.Internal.Endo [a_agdmt]
          [LclId] =
              [$dFoldable1_sgh5G] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh5G Data.Semigroup.Internal.$fMonoidEndo GHC.Types.:;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh5F
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgh5I
              eta_sgh5H
              GHC.Types.[];

Data.Functor.Compose.$fFoldableCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sgh5J $dFoldable1_sgh5K]
        let {
          sat_sgh60 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cproduct
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5Z [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$csum
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5Y [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cminimum
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5X [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cmaximum
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5W [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$celem
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B2 eta_B1; } in
        let {
          sat_sgh5V [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$clength
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5U [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cnull
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5T [Occ=Once]
            :: forall a. Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> [a]
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$ctoList
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5S [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl1
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B2 eta_B1; } in
        let {
          sat_sgh5R [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr1
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B2 eta_B1; } in
        let {
          sat_sgh5Q [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl'
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh5P [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh5O [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr'
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh5N [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh5M [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> m
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldMap
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh5L [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 m -> m
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfold
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sgh5L
                                    sat_sgh5M
                                    sat_sgh5N
                                    sat_sgh5O
                                    sat_sgh5P
                                    sat_sgh5Q
                                    sat_sgh5R
                                    sat_sgh5S
                                    sat_sgh5T
                                    sat_sgh5U
                                    sat_sgh5V
                                    sat_sgh5W
                                    sat_sgh5X
                                    sat_sgh5Y
                                    sat_sgh5Z
                                    sat_sgh60];

Data.Functor.Compose.$fTraversableCompose1
  :: forall (f :: * -> *) (g :: * -> *) b. f (g b) -> f (g b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgh61] v_sgh61;

Data.Functor.Compose.$fTraversableCompose_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Compose.Compose f g a
     -> f1 (Data.Functor.Compose.Compose f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh62
           $dTraversable1_sgh63
           $dApplicative_sgh64
           eta_sgh65
           eta1_sgh66]
        let {
          sat_sgh69 [Occ=Once] :: f1_agdjV (f_agdjG (g_agdjH b_agdjX))
          [LclId] =
              [$dTraversable_sgh62
               $dTraversable1_sgh63
               $dApplicative_sgh64
               eta_sgh65
               eta1_sgh66] \u []
                  let {
                    sat_sgh68 [Occ=Once]
                      :: g_agdjH a_agdjW -> f1_agdjV (g_agdjH b_agdjX)
                    [LclId] =
                        [$dTraversable1_sgh63 $dApplicative_sgh64 eta_sgh65] \u []
                            Data.Traversable.traverse
                                $dTraversable1_sgh63 $dApplicative_sgh64 eta_sgh65;
                  } in 
                    Data.Traversable.traverse
                        $dTraversable_sgh62 $dApplicative_sgh64 sat_sgh68 eta1_sgh66;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sgh64 of sat_sgh67 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sgh67 Data.Functor.Compose.$fTraversableCompose1 sat_sgh69;
          };

Data.Functor.Compose.$fTraversableCompose_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh6a $dTraversable1_sgh6b]
        let {
          sat_sgh6d [Occ=Once,
                     Dmd=<L,U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_agdjH
          [LclId] =
              [$dTraversable1_sgh6b] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sgh6b; } in
        let {
          sat_sgh6c [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_agdjG
          [LclId] =
              [$dTraversable_sgh6a] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sgh6a;
        } in  Data.Functor.Compose.$fFoldableCompose sat_sgh6c sat_sgh6d;

Data.Functor.Compose.$fTraversableCompose_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh6e $dTraversable1_sgh6f]
        let {
          sat_sgh6h [Occ=Once, Dmd=<L,U(C(U),A)>] :: GHC.Base.Functor g_agdjH
          [LclId] =
              [$dTraversable1_sgh6f] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sgh6f; } in
        let {
          sat_sgh6g [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_agdjG
          [LclId] =
              [$dTraversable_sgh6e] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sgh6e;
        } in  Data.Functor.Compose.$fFunctorCompose sat_sgh6g sat_sgh6h;

Data.Functor.Compose.$fTraversableCompose_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Compose.Compose f g (f1 a)
     -> f1 (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(U)),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh6i
           $dTraversable1_sgh6j
           $dApplicative_sgh6k
           eta_B1]
        Data.Functor.Compose.$fTraversableCompose_$ctraverse
            $dTraversable_sgh6i
            $dTraversable1_sgh6j
            $dApplicative_sgh6k
            GHC.Base.id
            eta_B1;

Data.Functor.Compose.$fTraversableCompose_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh6l
           $dTraversable1_sgh6m
           $dMonad_sgh6n
           eta_sgh6o
           eta1_sgh6p]
        case GHC.Base.$p1Monad $dMonad_sgh6n of sat_sgh6q {
          __DEFAULT ->
              Data.Functor.Compose.$fTraversableCompose_$ctraverse
                  $dTraversable_sgh6l
                  $dTraversable1_sgh6m
                  sat_sgh6q
                  eta_sgh6o
                  eta1_sgh6p;
        };

Data.Functor.Compose.$fTraversableCompose_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Compose.Compose f g (m a)
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh6r
           $dTraversable1_sgh6s
           $dMonad_sgh6t
           eta_sgh6u]
        case GHC.Base.$p1Monad $dMonad_sgh6t of sat_sgh6v {
          __DEFAULT ->
              Data.Functor.Compose.$fTraversableCompose_$ctraverse
                  $dTraversable_sgh6r
                  $dTraversable1_sgh6s
                  sat_sgh6v
                  GHC.Base.id
                  eta_sgh6u;
        };

Data.Functor.Compose.$fTraversableCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(U),A),1*U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dTraversable_sgh6w $dTraversable1_sgh6x]
        let {
          sat_sgh6D [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Compose.Compose f_agdjG g_agdjH (m a)
               -> m (Data.Functor.Compose.Compose f_agdjG g_agdjH a)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$csequence
                      $dTraversable_sgh6w $dTraversable1_sgh6x eta_B2 eta_B1; } in
        let {
          sat_sgh6C [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Compose.Compose f_agdjG g_agdjH a
               -> m (Data.Functor.Compose.Compose f_agdjG g_agdjH b)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$cmapM
                      $dTraversable_sgh6w $dTraversable1_sgh6x eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh6B [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Compose.Compose f_agdjG g_agdjH (f a)
               -> f (Data.Functor.Compose.Compose f_agdjG g_agdjH a)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$csequenceA
                      $dTraversable_sgh6w $dTraversable1_sgh6x eta_B2 eta_B1; } in
        let {
          sat_sgh6A [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Compose.Compose f_agdjG g_agdjH a
               -> f (Data.Functor.Compose.Compose f_agdjG g_agdjH b)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$ctraverse
                      $dTraversable_sgh6w $dTraversable1_sgh6x eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh6z [Occ=Once]
            :: Data.Foldable.Foldable
                 (Data.Functor.Compose.Compose f_agdjG g_agdjH)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \u []
                  Data.Functor.Compose.$fTraversableCompose_$cp2Traversable
                      $dTraversable_sgh6w $dTraversable1_sgh6x; } in
        let {
          sat_sgh6y [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Compose.Compose f_agdjG g_agdjH)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \u []
                  Data.Functor.Compose.$fTraversableCompose_$cp1Traversable
                      $dTraversable_sgh6w $dTraversable1_sgh6x;
        } in 
          Data.Traversable.C:Traversable [sat_sgh6y
                                          sat_sgh6z
                                          sat_sgh6A
                                          sat_sgh6B
                                          sat_sgh6C
                                          sat_sgh6D];

Data.Functor.Compose.$fApplicativeCompose4
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> f (g c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(U),A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh6E
           $dApplicative1_sgh6F
           f1_sgh6G
           ds_sgh6H
           ds1_sgh6I]
        let {
          sat_sgh6J [Occ=Once]
            :: g_agdie a_agdj0 -> g_agdie b_agdj1 -> g_agdie c_agdj2
          [LclId] =
              [$dApplicative1_sgh6F f1_sgh6G] \u []
                  GHC.Base.liftA2 $dApplicative1_sgh6F f1_sgh6G;
        } in 
          GHC.Base.liftA2 $dApplicative_sgh6E sat_sgh6J ds_sgh6H ds1_sgh6I;

Data.Functor.Compose.$fApplicativeCompose5
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g (a -> b)
     -> Data.Functor.Compose.Compose f g a -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,1*U,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh6K $dApplicative1_sgh6L ds_sgh6M ds1_sgh6N]
        let {
          sat_sgh6O [Occ=Once]
            :: g_Xgdlx (a_agdiF -> b_agdiG)
               -> g_Xgdlx a_agdiF -> g_Xgdlx b_agdiG
          [LclId] =
              [$dApplicative1_sgh6L] \u [] GHC.Base.<*> $dApplicative1_sgh6L;
        } in 
          GHC.Base.liftA2 $dApplicative_sgh6K sat_sgh6O ds_sgh6M ds1_sgh6N;

Data.Functor.Compose.$fApplicativeCompose6
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a. a -> f (g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh6P $dApplicative1_sgh6Q x_sgh6R]
        let {
          sat_sgh6S [Occ=Once] :: g_XgdlH a_agdio
          [LclId] =
              [$dApplicative1_sgh6Q x_sgh6R] \u []
                  GHC.Base.pure $dApplicative1_sgh6Q x_sgh6R;
        } in  GHC.Base.pure $dApplicative_sgh6P sat_sgh6S;

Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh6T $dApplicative1_sgh6U]
        let {
          sat_sgh6W [Occ=Once, Dmd=<L,U(C(U),A)>] :: GHC.Base.Functor g_XgdlP
          [LclId] =
              [$dApplicative1_sgh6U] \u []
                  GHC.Base.$p1Applicative $dApplicative1_sgh6U; } in
        let {
          sat_sgh6V [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_XgdlN
          [LclId] =
              [$dApplicative_sgh6T] \u []
                  GHC.Base.$p1Applicative $dApplicative_sgh6T;
        } in  Data.Functor.Compose.$fFunctorCompose sat_sgh6V sat_sgh6W;

Data.Functor.Compose.$fApplicativeCompose3
  :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgh6X eta_sgh6Y] eta_sgh6Y;

Data.Functor.Compose.$fApplicativeCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),U(1*U(1*C1(C1(U)),A),A,A,1*C1(C1(C1(U))),A,A)><L,U(1*U(1*C1(U),A),A,1*U,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh6Z
           $dApplicative1_sgh70
           eta_sgh71
           eta1_sgh72]
        let {
          sat_sgh77 [Occ=Once] :: f_XgdlX (g_XgdlZ (b_agdjo -> b_agdjo))
          [LclId] =
              [$dApplicative_sgh6Z $dApplicative1_sgh70 eta_sgh71] \u []
                  let {
                    sat_sgh76 [Occ=Once]
                      :: g_XgdlZ a_agdjn -> g_XgdlZ (b_agdjo -> b_agdjo)
                    [LclId] =
                        [$dApplicative1_sgh70] \u []
                            case GHC.Base.$p1Applicative $dApplicative1_sgh70 of sat_sgh75 {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sgh75 Data.Functor.Compose.$fApplicativeCompose3;
                            };
                  } in 
                    case GHC.Base.$p1Applicative $dApplicative_sgh6Z of sat_sgh74 {
                      __DEFAULT -> GHC.Base.fmap sat_sgh74 sat_sgh76 eta_sgh71;
                    }; } in
        let {
          sat_sgh73 [Occ=Once]
            :: g_XgdlZ (b_agdjo -> b_agdjo)
               -> g_XgdlZ b_agdjo -> g_XgdlZ b_agdjo
          [LclId] =
              [$dApplicative1_sgh70] \u [] GHC.Base.<*> $dApplicative1_sgh70;
        } in 
          GHC.Base.liftA2 $dApplicative_sgh6Z sat_sgh73 sat_sgh77 eta1_sgh72;

Data.Functor.Compose.$fApplicativeCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh78 $dApplicative1_sgh79 ds_sgh7a ds1_sgh7b]
        let {
          sat_sgh7c [Occ=Once]
            :: g_XgdlR a_agdjx -> g_XgdlR b_agdjy -> g_XgdlR a_agdjx
          [LclId] =
              [$dApplicative1_sgh79] \u []
                  GHC.Base.liftA2 $dApplicative1_sgh79 GHC.Base.const;
        } in 
          GHC.Base.liftA2 $dApplicative_sgh78 sat_sgh7c ds_sgh7a ds1_sgh7b;

Data.Functor.Compose.$fApplicativeCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m] =
    [] \r [$dApplicative_sgh7d $dApplicative1_sgh7e]
        let {
          sat_sgh7k [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose1
                      $dApplicative_sgh7d $dApplicative1_sgh7e eta_B2 eta_B1; } in
        let {
          sat_sgh7j [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose2
                      $dApplicative_sgh7d $dApplicative1_sgh7e eta_B2 eta_B1; } in
        let {
          sat_sgh7i [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ c
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose4
                      $dApplicative_sgh7d $dApplicative1_sgh7e eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh7h [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ (a -> b)
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose5
                      $dApplicative_sgh7d $dApplicative1_sgh7e eta_B2 eta_B1; } in
        let {
          sat_sgh7g [Occ=Once]
            :: forall a. a -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \r [eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose6
                      $dApplicative_sgh7d $dApplicative1_sgh7e eta_B1; } in
        let {
          sat_sgh7f [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Compose.Compose f_XgdlO g_XgdlQ)
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \u []
                  Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative
                      $dApplicative_sgh7d $dApplicative1_sgh7e;
        } in 
          GHC.Base.C:Applicative [sat_sgh7f
                                  sat_sgh7g
                                  sat_sgh7h
                                  sat_sgh7i
                                  sat_sgh7j
                                  sat_sgh7k];

Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgh7l $dApplicative_sgh7m]
        let {
          sat_sgh7n [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_XgdkR
          [LclId] =
              [$dAlternative_sgh7l] \u []
                  GHC.Base.$p1Alternative $dAlternative_sgh7l;
        } in 
          Data.Functor.Compose.$fApplicativeCompose
              sat_sgh7n $dApplicative_sgh7m;

Data.Functor.Compose.$fAlternativeCompose_$csome
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     forall a.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U(A,C(U),A,C(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgh7o $dApplicative_sgh7p eta_sgh7q]
        let {
          some_v_sgh7r [Occ=LoopBreaker] :: f_XgdkU (g_XgdkW [a_agdhY])
          [LclId] =
              [$dAlternative_sgh7o
               $dApplicative_sgh7p
               eta_sgh7q
               some_v_sgh7r] \u []
                  case
                      GHC.Base.$p1Alternative $dAlternative_sgh7o
                  of
                  $dApplicative1_sgh7s [Dmd=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                  { __DEFAULT ->
                        let {
                          sat_sgh7w [Occ=Once] :: f_XgdkU (g_XgdkW [a_agdhY])
                          [LclId] =
                              [$dAlternative_sgh7o
                               $dApplicative_sgh7p
                               some_v_sgh7r
                               $dApplicative1_sgh7s] \u []
                                  let {
                                    sat_sgh7v [Occ=Once] :: f_XgdkU (g_XgdkW [a_agdhY])
                                    [LclId] =
                                        [$dApplicative_sgh7p $dApplicative1_sgh7s] \u []
                                            let {
                                              sat_sgh7u [Occ=Once] :: g_XgdkW [a_agdhY]
                                              [LclId] =
                                                  [$dApplicative_sgh7p] \u []
                                                      GHC.Base.pure
                                                          $dApplicative_sgh7p GHC.Types.[];
                                            } in  GHC.Base.pure $dApplicative1_sgh7s sat_sgh7u;
                                  } in 
                                    GHC.Base.<|> $dAlternative_sgh7o some_v_sgh7r sat_sgh7v; } in
                        let {
                          sat_sgh7t [Occ=Once]
                            :: g_XgdkW a_agdhY -> g_XgdkW [a_agdhY] -> g_XgdkW [a_agdhY]
                          [LclId] =
                              [$dApplicative_sgh7p] \u []
                                  GHC.Base.liftA2 $dApplicative_sgh7p GHC.Types.:;
                        } in 
                          GHC.Base.liftA2 $dApplicative1_sgh7s sat_sgh7t eta_sgh7q sat_sgh7w;
                  };
        } in  some_v_sgh7r;

Data.Functor.Compose.$fAlternativeCompose_$cmany
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     forall a.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U(A,C(U),A,C(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgh7x $dApplicative_sgh7y eta_sgh7z]
        let {
          many_v_sgh7A [Occ=LoopBreaker] :: f_XgdkT (g_XgdkV [a_agdi6])
          [LclId] =
              [$dAlternative_sgh7x
               $dApplicative_sgh7y
               eta_sgh7z
               many_v_sgh7A] \u []
                  let {
                    $dApplicative1_sgh7B [Dmd=<L,U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                      :: GHC.Base.Applicative f_XgdkT
                    [LclId] =
                        [$dAlternative_sgh7x] \u []
                            GHC.Base.$p1Alternative $dAlternative_sgh7x; } in
                  let {
                    sat_sgh7F [Occ=Once] :: f_XgdkT (g_XgdkV [a_agdi6])
                    [LclId] =
                        [$dApplicative_sgh7y $dApplicative1_sgh7B] \u []
                            let {
                              sat_sgh7E [Occ=Once] :: g_XgdkV [a_agdi6]
                              [LclId] =
                                  [$dApplicative_sgh7y] \u []
                                      GHC.Base.pure $dApplicative_sgh7y GHC.Types.[];
                            } in  GHC.Base.pure $dApplicative1_sgh7B sat_sgh7E; } in
                  let {
                    sat_sgh7D [Occ=Once] :: f_XgdkT (g_XgdkV [a_agdi6])
                    [LclId] =
                        [$dApplicative_sgh7y
                         eta_sgh7z
                         many_v_sgh7A
                         $dApplicative1_sgh7B] \u []
                            let {
                              sat_sgh7C [Occ=Once]
                                :: g_XgdkV a_agdi6 -> g_XgdkV [a_agdi6] -> g_XgdkV [a_agdi6]
                              [LclId] =
                                  [$dApplicative_sgh7y] \u []
                                      GHC.Base.liftA2 $dApplicative_sgh7y GHC.Types.:;
                            } in 
                              GHC.Base.liftA2
                                  $dApplicative1_sgh7B sat_sgh7C eta_sgh7z many_v_sgh7A;
                  } in  GHC.Base.<|> $dAlternative_sgh7x sat_sgh7D sat_sgh7F;
        } in  many_v_sgh7A;

Data.Functor.Compose.$fAlternativeCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     GHC.Base.Alternative (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A),1*U,U,A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m] =
    [] \r [$dAlternative_sgh7G $dApplicative_sgh7H]
        let {
          sat_sgh7M [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU [a]
          [LclId] =
              [$dAlternative_sgh7G $dApplicative_sgh7H] \r [eta_B1]
                  Data.Functor.Compose.$fAlternativeCompose_$cmany
                      $dAlternative_sgh7G $dApplicative_sgh7H eta_B1; } in
        let {
          sat_sgh7L [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU [a]
          [LclId] =
              [$dAlternative_sgh7G $dApplicative_sgh7H] \r [eta_B1]
                  Data.Functor.Compose.$fAlternativeCompose_$csome
                      $dAlternative_sgh7G $dApplicative_sgh7H eta_B1; } in
        let {
          sat_sgh7K [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
          [LclId] =
              [$dAlternative_sgh7G] \u [] GHC.Base.<|> $dAlternative_sgh7G; } in
        let {
          sat_sgh7J [Occ=Once]
            :: forall a. Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
          [LclId] =
              [$dAlternative_sgh7G] \u []
                  GHC.Base.empty $dAlternative_sgh7G; } in
        let {
          sat_sgh7I [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Compose.Compose f_XgdkS g_XgdkU)
          [LclId] =
              [$dAlternative_sgh7G $dApplicative_sgh7H] \u []
                  Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative
                      $dAlternative_sgh7G $dApplicative_sgh7H;
        } in 
          GHC.Base.C:Alternative [sat_sgh7I
                                  sat_sgh7J
                                  sat_sgh7K
                                  sat_sgh7L
                                  sat_sgh7M];

Data.Functor.Compose.$fGeneric1Compose1
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     forall (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Compose.Compose f g) a -> f (g a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgh7N ds_sgh7O]
        GHC.Base.fmap $dFunctor_sgh7N GHC.Generics.$fGeneric1:.:2 ds_sgh7O;

Data.Functor.Compose.$fGeneric1Compose3
  :: forall k (g :: k -> *) (a :: k). g a -> g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgh7P] v_sgh7P;

Data.Functor.Compose.$fGeneric1Compose2
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     forall (a :: k).
     Data.Functor.Compose.Compose f g a -> f (GHC.Generics.Rec1 g a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgh7Q x_sgh7R]
        GHC.Base.fmap
            $dFunctor_sgh7Q Data.Functor.Compose.$fGeneric1Compose3 x_sgh7R;

Data.Functor.Compose.$fGeneric1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     GHC.Generics.Generic1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sgh7S]
        let {
          sat_sgh7U [Occ=Once]
            :: forall (a :: k).
               GHC.Generics.Rep1 (Data.Functor.Compose.Compose f_XgdjE g_XgdjI) a
               -> Data.Functor.Compose.Compose f_XgdjE g_XgdjI a
          [LclId] =
              [$dFunctor_sgh7S] \r [eta_B1]
                  Data.Functor.Compose.$fGeneric1Compose1
                      $dFunctor_sgh7S eta_B1; } in
        let {
          sat_sgh7T [Occ=Once]
            :: forall (a :: k).
               Data.Functor.Compose.Compose f_XgdjE g_XgdjI a
               -> GHC.Generics.Rep1
                    (Data.Functor.Compose.Compose f_XgdjE g_XgdjI) a
          [LclId] =
              [$dFunctor_sgh7S] \r [eta_B1]
                  Data.Functor.Compose.$fGeneric1Compose2 $dFunctor_sgh7S eta_B1;
        } in  GHC.Generics.C:Generic1 [sat_sgh7T sat_sgh7U];

Data.Functor.Compose.$fGenericCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) x.
     GHC.Generics.Rep (Data.Functor.Compose.Compose f g a) x
     -> GHC.Generics.Rep (Data.Functor.Compose.Compose f g a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgh7V] ds_sgh7V;

Data.Functor.Compose.$fGenericCompose2
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) x.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sgh7W] x1_sgh7W;

Data.Functor.Compose.$fGenericCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     GHC.Generics.Generic (Data.Functor.Compose.Compose f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Compose.$fGenericCompose2
                                           Data.Functor.Compose.$fGenericCompose1];

Data.Functor.Compose.getCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgh7X] ds_sgh7X;

Data.Functor.Compose.getCompose
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> f (g a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Compose.getCompose1 eta_B1;

$cCompose1_rgdPU :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getCompose"#;

$cCompose2_rgdPV :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $cCompose1_rgdPU;

$cCompose3_rgdPW :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$cCompose2_rgdPV GHC.Types.[]];

go61_rgdPX
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgh7Y _ys_sgh7Z]
        case ds2_sgh7Y of {
          [] -> GHC.List.badHead;
          : ipv_sgh81 [Occ=Once!] ipv1_sgh82 [Occ=Once] ->
              case _ys_sgh7Z of {
                [] -> GHC.List.badHead;
                : ipv2_sgh84 [Occ=Once] ipv3_sgh85 [Occ=Once] ->
                    case ipv_sgh81 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgh88 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sgh88 Data.Functor.Compose.$fDataCompose6
                          of
                          { GHC.Types.False -> go61_rgdPX ipv1_sgh82 ipv3_sgh85;
                            GHC.Types.True -> ipv2_sgh84;
                          };
                    };
              };
        };

$cCompose4_rgdPY :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cCompose5_rgdPZ];
Data.Functor.Compose.$fDataCompose5 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Compose.$cCompose GHC.Types.[]];
Data.Functor.Compose.$fDataCompose4 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Functor.Compose.$fDataCompose5];
Data.Functor.Compose.$tCompose :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Functor.Compose.$fDataCompose6
                                       Data.Functor.Compose.$fDataCompose4];
Data.Functor.Compose.$cCompose [Occ=LoopBreaker]
  :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cCompose4_rgdPY
                                     Data.Functor.Compose.$fDataCompose6
                                     $cCompose3_rgdPW
                                     Data.Data.Prefix
                                     Data.Functor.Compose.$tCompose];
$cCompose5_rgdPZ :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rgdPX Data.Functor.Compose.$fDataCompose5 Data.Data.mkConstr1;

Data.Functor.Compose.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Compose.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$trModule4];

Data.Functor.Compose.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Compose"#;

Data.Functor.Compose.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$trModule2];

Data.Functor.Compose.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Compose.$trModule3
                                     Data.Functor.Compose.$trModule1];

$krep_rgdQ0 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_rgdQ1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgdQ0 GHC.Types.krep$*];

$krep2_rgdQ2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_rgdQ3 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_rgdQ2
                                         GHC.Types.krep$*];

$krep4_rgdQ4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgdQ0 $krep2_rgdQ2];

$krep5_rgdQ5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_rgdQ4 $krep1_rgdQ1];

Data.Functor.Compose.$fDataCompose9 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rgdQ3 $krep5_rgdQ5];

$krep6_rgdQ6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep7_rgdQ7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep8_rgdQ8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [4#];

$krep9_rgdQ9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep6_rgdQ6 $krep8_rgdQ8];

$krep10_rgdQa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep7_rgdQ7 $krep9_rgdQ9];

Data.Functor.Compose.$fDataCompose10 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$fDataCompose7];

Data.Functor.Compose.$tcCompose :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6729400645769595507##
                                    7487202375031942550##
                                    Data.Functor.Compose.$trModule
                                    Data.Functor.Compose.$fDataCompose10
                                    2#
                                    Data.Functor.Compose.$fDataCompose9];

$krep11_rgdQb :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep8_rgdQ8 GHC.Types.[]];

$krep12_rgdQc :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_rgdQ6 $krep11_rgdQb];

$krep13_rgdQd :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep7_rgdQ7 $krep12_rgdQc];

$krep14_rgdQe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgdQ0 $krep13_rgdQd];

$krep15_rgdQf :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgdQ2 $krep14_rgdQe];

$krep16_rgdQg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Compose.$tcCompose
                                              $krep15_rgdQf];

Data.Functor.Compose.$tc'Compose1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_rgdQa $krep16_rgdQg];

Data.Functor.Compose.$tc'Compose3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Compose"#;

Data.Functor.Compose.$tc'Compose2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$tc'Compose3];

Data.Functor.Compose.$tc'Compose :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7236514282653524344##
                                    13791541438620948974##
                                    Data.Functor.Compose.$trModule
                                    Data.Functor.Compose.$tc'Compose2
                                    5#
                                    Data.Functor.Compose.$tc'Compose1];

Data.Functor.Compose.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Compose.Compose f g a)
[GblId, Arity=5, Str=<S,U><S,U><S,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sgh8d w1_sgh8e w2_sgh8f w3_sgh8g w4_sgh8h]
        let {
          sat_sgh8j [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w4_sgh8h]; } in
        let {
          sat_sgh8k [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sgh8j GHC.Types.[]]; } in
        let {
          sat_sgh8i [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sgh8g]; } in
        let {
          sat_sgh8l [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sgh8i sat_sgh8k];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  6729400645769595507##
                  7487202375031942550##
                  Data.Functor.Compose.$trModule
                  Data.Functor.Compose.$fDataCompose10
                  2#
                  Data.Functor.Compose.$fDataCompose9
                  sat_sgh8l
          of
          { (#,,,,#) ww8_sgh8n [Occ=Once]
                     ww9_sgh8o [Occ=Once]
                     ww10_sgh8p [Occ=Once]
                     ww11_sgh8q [Occ=Once]
                     ww12_sgh8r [Occ=Once] ->
                let {
                  sat_sgh8s [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Compose.Compose
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sgh8n
                                                            ww9_sgh8o
                                                            ww10_sgh8p
                                                            ww11_sgh8q
                                                            ww12_sgh8r];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sgh8s w1_sgh8e
                  of
                  sat_sgh8t
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sgh8t w2_sgh8f
                        of
                        sat_sgh8u
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sgh8u w_sgh8d;
                        };
                  };
          };

Data.Functor.Compose.$fDataCompose8 [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,U><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sgh8v w1_sgh8w w2_sgh8x w3_sgh8y w4_sgh8z w5_sgh8A]
        Data.Functor.Compose.$w$cp1Data
            w_sgh8v w1_sgh8w w2_sgh8x w3_sgh8y w4_sgh8z;

Data.Functor.Compose.$fDataCompose2
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     f (g a) -> f (g a)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgh8B] v_sgh8B;

Data.Functor.Compose.$fDataCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (f (g a) -> Data.Functor.Compose.Compose f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Compose.$fDataCompose2
                        GHC.Types.False];

Data.Functor.Compose.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh8C w1_sgh8D w2_sgh8E w3_sgh8F]
        let {
          lvl8_sgh8G [Occ=OnceL]
            :: m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9)
          [LclId] =
              [w1_sgh8D] \u [] GHC.Base.mzero w1_sgh8D;
        } in 
          case
              GHC.Base.$p2MonadPlus w1_sgh8D
          of
          $dMonad_sgh8H [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgh93 [Occ=Once]
                    :: (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                        GHC.Types.Bool)
                       -> m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9)
                  [LclId] =
                      [lvl8_sgh8G $dMonad_sgh8H] \r [ds_sgh8Y]
                          case ds_sgh8Y of {
                            (,) x'_sgh90 [Occ=Once] b_sgh91 [Occ=Once!] ->
                                case b_sgh91 of {
                                  GHC.Types.False -> lvl8_sgh8G;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgh8H x'_sgh90;
                                };
                          }; } in
                let {
                  sat_sgh8X [Occ=Once]
                    :: m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sgh8C w1_sgh8D w2_sgh8E w3_sgh8F $dMonad_sgh8H] \u []
                          let {
                            lvl9_sgh8I [Occ=OnceL] :: m_sgdKg (f_sgdK6 (g_sgdK8 a_sgdK9))
                            [LclId] =
                                [w_sgh8C w2_sgh8E w3_sgh8F] \u [] w2_sgh8E w_sgh8C w3_sgh8F; } in
                          let {
                            sat_sgh8W [Occ=Once]
                              :: (f_sgdK6 (g_sgdK8 a_sgdK9)
                                  -> Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                  GHC.Types.Bool)
                                 -> m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                             GHC.Types.Bool)
                            [LclId] =
                                [w1_sgh8D w3_sgh8F $dMonad_sgh8H lvl9_sgh8I] \r [ds1_sgh8K]
                                    case ds1_sgh8K of {
                                      (,) h_sgh8M b1_sgh8N [Occ=Once] ->
                                          let {
                                            sat_sgh8V [Occ=Once]
                                              :: m_sgdKg (Data.Functor.Compose.Compose
                                                            f_sgdK6 g_sgdK8 a_sgdK9,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [w3_sgh8F $dMonad_sgh8H h_sgh8M b1_sgh8N] \u []
                                                    let {
                                                      sat_sgh8T [Occ=Once]
                                                        :: Data.Functor.Compose.Compose
                                                             f_sgdK6 g_sgdK8 a_sgdK9
                                                      [LclId] =
                                                          [w3_sgh8F h_sgh8M] \u []
                                                              h_sgh8M w3_sgh8F; } in
                                                    let {
                                                      sat_sgh8U [Occ=Once]
                                                        :: (Data.Functor.Compose.Compose
                                                              f_sgdK6 g_sgdK8 a_sgdK9,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sgh8T b1_sgh8N];
                                                    } in 
                                                      GHC.Base.return $dMonad_sgh8H sat_sgh8U; } in
                                          let {
                                            sat_sgh8S [Occ=Once]
                                              :: m_sgdKg (Data.Functor.Compose.Compose
                                                            f_sgdK6 g_sgdK8 a_sgdK9,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sgh8H lvl9_sgh8I h_sgh8M] \u []
                                                    let {
                                                      sat_sgh8R [Occ=Once]
                                                        :: f_sgdK6 (g_sgdK8 a_sgdK9)
                                                           -> m_sgdKg (Data.Functor.Compose.Compose
                                                                         f_sgdK6 g_sgdK8 a_sgdK9,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sgh8H h_sgh8M] \r [y'_sgh8O]
                                                              let {
                                                                sat_sgh8P [Occ=Once]
                                                                  :: Data.Functor.Compose.Compose
                                                                       f_sgdK6 g_sgdK8 a_sgdK9
                                                                [LclId] =
                                                                    [h_sgh8M y'_sgh8O] \u []
                                                                        h_sgh8M y'_sgh8O; } in
                                                              let {
                                                                sat_sgh8Q [Occ=Once]
                                                                  :: (Data.Functor.Compose.Compose
                                                                        f_sgdK6 g_sgdK8 a_sgdK9,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sgh8P
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sgh8H sat_sgh8Q;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sgh8H lvl9_sgh8I sat_sgh8R;
                                          } in  GHC.Base.mplus w1_sgh8D sat_sgh8S sat_sgh8V;
                                    }; } in
                          let {
                            sat_sgh8J [Occ=Once]
                              :: m_sgdKg (f_sgdK6 (g_sgdK8 a_sgdK9)
                                          -> Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgh8H] \u []
                                    GHC.Base.return
                                        $dMonad_sgh8H Data.Functor.Compose.$fDataCompose1;
                          } in  GHC.Base.>>= $dMonad_sgh8H sat_sgh8J sat_sgh8W;
                } in  GHC.Base.>>= $dMonad_sgh8H sat_sgh8X sat_sgh93;
          };

Data.Functor.Compose.$fDataCompose_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh94
           w1_sgh95
           w2_sgh96
           w3_sgh97
           w4_sgh98
           w5_sgh99
           w6_sgh9a
           w7_sgh9b
           w8_sgh9c]
        Data.Functor.Compose.$w$cgmapMp
            w5_sgh99 w6_sgh9a w7_sgh9b w8_sgh9c;

Data.Functor.Compose.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh9d w1_sgh9e w2_sgh9f w3_sgh9g]
        let {
          lvl8_sgh9h [Occ=OnceL] :: m_sgdKw (f_sgdKm (g_sgdKo a_sgdKp))
          [LclId] =
              [w_sgh9d w2_sgh9f w3_sgh9g] \u [] w2_sgh9f w_sgh9d w3_sgh9g; } in
        let {
          sat_sgh9n [Occ=Once]
            :: (f_sgdKm (g_sgdKo a_sgdKp)
                -> Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
               -> m_sgdKw (Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
          [LclId] =
              [w1_sgh9e lvl8_sgh9h] \r [c'_sgh9j]
                  let {
                    sat_sgh9m [Occ=Once]
                      :: f_sgdKm (g_sgdKo a_sgdKp)
                         -> m_sgdKw (Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
                    [LclId] =
                        [w1_sgh9e c'_sgh9j] \r [x'_sgh9k]
                            let {
                              sat_sgh9l [Occ=Once]
                                :: Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp
                              [LclId] =
                                  [c'_sgh9j x'_sgh9k] \u [] c'_sgh9j x'_sgh9k;
                            } in  GHC.Base.return w1_sgh9e sat_sgh9l;
                  } in  GHC.Base.>>= w1_sgh9e lvl8_sgh9h sat_sgh9m; } in
        let {
          sat_sgh9i [Occ=Once]
            :: m_sgdKw (f_sgdKm (g_sgdKo a_sgdKp)
                        -> Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
          [LclId] =
              [w1_sgh9e] \u []
                  GHC.Base.return w1_sgh9e Data.Functor.Compose.$fDataCompose2;
        } in  GHC.Base.>>= w1_sgh9e sat_sgh9i sat_sgh9n;

Data.Functor.Compose.$fDataCompose_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh9o
           w1_sgh9p
           w2_sgh9q
           w3_sgh9r
           w4_sgh9s
           w5_sgh9t
           w6_sgh9u
           w7_sgh9v
           w8_sgh9w]
        Data.Functor.Compose.$w$cgmapM w5_sgh9t w6_sgh9u w7_sgh9v w8_sgh9w;

Data.Functor.Compose.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh9x w1_sgh9y w2_sgh9z w3_sgh9A]
        let {
          lvl8_sgh9B [Occ=OnceL]
            :: m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF)
          [LclId] =
              [w1_sgh9y] \u [] GHC.Base.mzero w1_sgh9y;
        } in 
          case
              GHC.Base.$p2MonadPlus w1_sgh9y
          of
          $dMonad_sgh9C [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgha1 [Occ=Once]
                    :: (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                        GHC.Types.Bool)
                       -> m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF)
                  [LclId] =
                      [lvl8_sgh9B $dMonad_sgh9C] \r [ds_sgh9W]
                          case ds_sgh9W of {
                            (,) x'_sgh9Y [Occ=Once] b_sgh9Z [Occ=Once!] ->
                                case b_sgh9Z of {
                                  GHC.Types.False -> lvl8_sgh9B;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgh9C x'_sgh9Y;
                                };
                          }; } in
                let {
                  sat_sgh9V [Occ=Once]
                    :: m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sgh9x w1_sgh9y w2_sgh9z w3_sgh9A $dMonad_sgh9C] \u []
                          let {
                            lvl9_sgh9D [Occ=OnceL] :: m_sgdKM (f_sgdKC (g_sgdKE a_sgdKF))
                            [LclId] =
                                [w_sgh9x w2_sgh9z w3_sgh9A] \u [] w2_sgh9z w_sgh9x w3_sgh9A; } in
                          let {
                            sat_sgh9U [Occ=Once]
                              :: (f_sgdKC (g_sgdKE a_sgdKF)
                                  -> Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                  GHC.Types.Bool)
                                 -> m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                             GHC.Types.Bool)
                            [LclId] =
                                [w1_sgh9y w3_sgh9A $dMonad_sgh9C lvl9_sgh9D] \r [ds1_sgh9F]
                                    case ds1_sgh9F of {
                                      (,) h_sgh9H b1_sgh9I [Occ=Once!] ->
                                          case b1_sgh9I of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sgh9R [Occ=Once]
                                                    :: m_sgdKM (Data.Functor.Compose.Compose
                                                                  f_sgdKC g_sgdKE a_sgdKF,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [w3_sgh9A $dMonad_sgh9C h_sgh9H] \u []
                                                          let {
                                                            sat_sgh9P [Occ=Once]
                                                              :: Data.Functor.Compose.Compose
                                                                   f_sgdKC g_sgdKE a_sgdKF
                                                            [LclId] =
                                                                [w3_sgh9A h_sgh9H] \u []
                                                                    h_sgh9H w3_sgh9A; } in
                                                          let {
                                                            sat_sgh9Q [Occ=Once]
                                                              :: (Data.Functor.Compose.Compose
                                                                    f_sgdKC g_sgdKE a_sgdKF,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sgh9P
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sgh9C sat_sgh9Q; } in
                                                let {
                                                  sat_sgh9O [Occ=Once]
                                                    :: m_sgdKM (Data.Functor.Compose.Compose
                                                                  f_sgdKC g_sgdKE a_sgdKF,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sgh9C lvl9_sgh9D h_sgh9H] \u []
                                                          let {
                                                            sat_sgh9N [Occ=Once]
                                                              :: f_sgdKC (g_sgdKE a_sgdKF)
                                                                 -> m_sgdKM (Data.Functor.Compose.Compose
                                                                               f_sgdKC
                                                                               g_sgdKE
                                                                               a_sgdKF,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgh9C
                                                                 h_sgh9H] \r [y'_sgh9K]
                                                                    let {
                                                                      sat_sgh9L [Occ=Once]
                                                                        :: Data.Functor.Compose.Compose
                                                                             f_sgdKC g_sgdKE a_sgdKF
                                                                      [LclId] =
                                                                          [h_sgh9H y'_sgh9K] \u []
                                                                              h_sgh9H y'_sgh9K; } in
                                                                    let {
                                                                      sat_sgh9M [Occ=Once]
                                                                        :: (Data.Functor.Compose.Compose
                                                                              f_sgdKC
                                                                              g_sgdKE
                                                                              a_sgdKF,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgh9L
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgh9C sat_sgh9M;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sgh9C lvl9_sgh9D sat_sgh9N;
                                                } in  GHC.Base.mplus w1_sgh9y sat_sgh9O sat_sgh9R;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sgh9S [Occ=Once]
                                                    :: Data.Functor.Compose.Compose
                                                         f_sgdKC g_sgdKE a_sgdKF
                                                  [LclId] =
                                                      [w3_sgh9A h_sgh9H] \u []
                                                          h_sgh9H w3_sgh9A; } in
                                                let {
                                                  sat_sgh9T [Occ=Once]
                                                    :: (Data.Functor.Compose.Compose
                                                          f_sgdKC g_sgdKE a_sgdKF,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sgh9S GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sgh9C sat_sgh9T;
                                          };
                                    }; } in
                          let {
                            sat_sgh9E [Occ=Once]
                              :: m_sgdKM (f_sgdKC (g_sgdKE a_sgdKF)
                                          -> Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgh9C] \u []
                                    GHC.Base.return
                                        $dMonad_sgh9C Data.Functor.Compose.$fDataCompose1;
                          } in  GHC.Base.>>= $dMonad_sgh9C sat_sgh9E sat_sgh9U;
                } in  GHC.Base.>>= $dMonad_sgh9C sat_sgh9V sat_sgha1;
          };

Data.Functor.Compose.$fDataCompose_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgha2
           w1_sgha3
           w2_sgha4
           w3_sgha5
           w4_sgha6
           w5_sgha7
           w6_sgha8
           w7_sgha9
           w8_sghaa]
        Data.Functor.Compose.$w$cgmapMo
            w5_sgha7 w6_sgha8 w7_sgha9 w8_sghaa;

lvl4_rgdQh
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sghab] Data.Functor.Compose.$cCompose;

lvl5_rgdQi
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sghac] Data.Functor.Compose.$tCompose;

lvl6_rgdQj
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) (t :: *
                                                                 -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Compose.Compose f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sghad ds_sghae] GHC.Base.Nothing [];

lvl7_rgdQk
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) (t :: *
                                                                 -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Compose.Compose f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sghaf ds_sghag] GHC.Base.Nothing [];

Data.Functor.Compose.$fDataCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     Data.Data.Data (Data.Functor.Compose.Compose f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sghah
           $dTypeable1_sghai
           $dTypeable2_sghaj
           $dTypeable3_sghak
           $dTypeable4_sghal
           $dData_sgham]
        let {
          sat_sghb9 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sgham] \r [w_sghb6 w1_sghb7 w2_sghb8]
                  Data.Functor.Compose.$w$cgmapMo
                      $dData_sgham w_sghb6 w1_sghb7 w2_sghb8; } in
        let {
          sat_sghb5 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sgham] \r [w_sghb2 w1_sghb3 w2_sghb4]
                  Data.Functor.Compose.$w$cgmapMp
                      $dData_sgham w_sghb2 w1_sghb3 w2_sghb4; } in
        let {
          sat_sghb1 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sgham] \r [w_sghaY w1_sghaZ w2_sghb0]
                  Data.Functor.Compose.$w$cgmapM
                      $dData_sgham w_sghaY w1_sghaZ w2_sghb0; } in
        let {
          sat_sghaX [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> u
          [LclId] =
              [$dData_sgham] \r [ds_sghaR ds1_sghaS x_sghaT]
                  case ds_sghaR of {
                    GHC.Types.I# x1_sghaV [Occ=Once!] ->
                        case x1_sghaV of {
                          __DEFAULT -> Data.Maybe.fromJust1;
                          0# -> ds1_sghaS $dData_sgham x_sghaT;
                        };
                  }; } in
        let {
          sat_sghaQ [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs -> [u]
          [LclId] =
              [$dData_sgham] \r [ds_sghaN x0_sghaO]
                  let {
                    sat_sghaP [Occ=Once] :: u_agdd2
                    [LclId] =
                        [$dData_sgham ds_sghaN x0_sghaO] \u []
                            ds_sghaN $dData_sgham x0_sghaO;
                  } in  : [sat_sghaP GHC.Types.[]]; } in
        let {
          sat_sghaM [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> r
          [LclId] =
              [$dData_sgham] \r [ds_sghaH ds1_sghaI ds2_sghaJ x0_sghaK]
                  let {
                    sat_sghaL [Occ=Once] :: r'_agdcM
                    [LclId] =
                        [$dData_sgham ds2_sghaJ x0_sghaK] \u []
                            ds2_sghaJ $dData_sgham x0_sghaK;
                  } in  ds_sghaH sat_sghaL ds1_sghaI; } in
        let {
          sat_sghaG [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> r
          [LclId] =
              [$dData_sgham] \r [ds_sghaB ds1_sghaC ds2_sghaD eta_sghaE]
                  let {
                    sat_sghaF [Occ=Once] :: r'_agdcv
                    [LclId] =
                        [$dData_sgham ds2_sghaD eta_sghaE] \u []
                            ds2_sghaD $dData_sgham eta_sghaE;
                  } in  ds_sghaB ds1_sghaC sat_sghaF; } in
        let {
          sat_sghaA [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
          [LclId] =
              [$dData_sgham] \r [ds_sghay x0_sghaz]
                  ds_sghay $dData_sgham x0_sghaz; } in
        let {
          sat_sghax [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sgham] \r [k2_sghat z_sghau ds_sghav]
                  let {
                    sat_sghaw [Occ=Once]
                      :: c_agdbg (f_Xgdgm (g_Xgdgq a_Xgdgs)
                                  -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
                    [LclId] =
                        [z_sghau] \u [] z_sghau Data.Functor.Compose.$fDataCompose2;
                  } in  k2_sghat $dData_sgham sat_sghaw; } in
        let {
          sat_sghas [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> c (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sgham] \r [k2_sghao z_sghap ds_sghaq]
                  let {
                    sat_sghar [Occ=Once]
                      :: c_agdb1 (f_Xgdgm (g_Xgdgq a_Xgdgs)
                                  -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
                    [LclId] =
                        [z_sghap] \u [] z_sghap Data.Functor.Compose.$fDataCompose2;
                  } in  k2_sghao $dData_sgham sat_sghar ds_sghaq; } in
        let {
          sat_sghan [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dTypeable_sghah
               $dTypeable1_sghai
               $dTypeable2_sghaj
               $dTypeable3_sghak
               $dTypeable4_sghal] \u []
                  Data.Functor.Compose.$w$cp1Data
                      $dTypeable_sghah
                      $dTypeable1_sghai
                      $dTypeable2_sghaj
                      $dTypeable3_sghak
                      $dTypeable4_sghal;
        } in 
          Data.Data.C:Data [sat_sghan
                            sat_sghas
                            sat_sghax
                            lvl4_rgdQh
                            lvl5_rgdQi
                            lvl6_rgdQj
                            lvl7_rgdQk
                            sat_sghaA
                            sat_sghaG
                            sat_sghaM
                            sat_sghaQ
                            sat_sghaX
                            sat_sghb1
                            sat_sghb5
                            sat_sghb9];


==================== STG syntax: ====================
2018-03-16 16:12:11.457722199 UTC

$fEq1Compose1_rgdPP
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dEq1_sggZ0
                    $dEq2_sggZ1
                    eq_sggZ2
                    ds_sggZ3
                    ds1_sggZ4]
        let {
          sat_sggZ5 [Occ=Once]
            :: g_agdsJ a_agdsP -> g_agdsJ b_agdsQ -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sggZ1 eq_sggZ2] \u [] $dEq2_sggZ1 eq_sggZ2;
        } in  $dEq1_sggZ0 sat_sggZ5 ds_sggZ3 ds1_sggZ4;

Data.Functor.Compose.$fEq1Compose [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) =>
     Data.Functor.Classes.Eq1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        $fEq1Compose1_rgdPP eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Compose.$fOrd1Compose_$cliftCompare
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sggZ6 $dOrd2_sggZ7 comp_sggZ8 ds_sggZ9 ds1_sggZa]
        let {
          sat_sggZb [Occ=Once]
            :: g_agdsk a_agdsu -> g_agdsk b_agdsv -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sggZ7 comp_sggZ8] \u []
                  Data.Functor.Classes.liftCompare $dOrd2_sggZ7 comp_sggZ8;
        } in 
          Data.Functor.Classes.liftCompare
              $dOrd1_sggZ6 sat_sggZb ds_sggZ9 ds1_sggZa;

Data.Functor.Compose.$fOrd1Compose1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))L),1*U(1*C1(C1(C1(U))),A)><L,1*U(1*C1(U),A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sggZc $dOrd2_sggZd eta_sggZe eta1_sggZf eta2_sggZg]
        let {
          sat_sggZh [Occ=Once]
            :: g_agdsk a_adwad -> g_agdsk b_adwae -> GHC.Types.Bool
          [LclId] =
              [$dOrd2_sggZd eta_sggZe] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sggZd eta_sggZe;
        } in 
          Data.Functor.Classes.$p1Ord1
              $dOrd1_sggZc sat_sggZh eta1_sggZf eta2_sggZg;

Data.Functor.Compose.$fOrd1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) =>
     Data.Functor.Classes.Ord1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C1(U))),C(C1(C1(U))))><L,U(C(U),C(U))>m] =
    [] \r [$dOrd1_sggZi $dOrd2_sggZj]
        let {
          sat_sggZl [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Compose.Compose f_Xgdux g_Xgduz a
               -> Data.Functor.Compose.Compose f_Xgdux g_Xgduz b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sggZi $dOrd2_sggZj] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrd1Compose_$cliftCompare
                      $dOrd1_sggZi $dOrd2_sggZj eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sggZk [Occ=Once]
            :: Data.Functor.Classes.Eq1
                 (Data.Functor.Compose.Compose f_Xgdux g_Xgduz)
          [LclId] =
              [$dOrd1_sggZi $dOrd2_sggZj] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrd1Compose1
                      $dOrd1_sggZi $dOrd2_sggZj eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sggZk sat_sggZl];

Data.Functor.Compose.$fDataCompose7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Compose"#;

Data.Functor.Compose.$fDataCompose6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Compose.$fDataCompose7;

Data.Functor.Compose.$fRead1Compose2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Compose.$fDataCompose6];

Data.Functor.Compose.$fRead1Compose1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,1*C1(C1(U)),1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sggZm $dRead2_sggZn rp_sggZo rl_sggZp]
        let {
          reader_sggZq [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_agdr6 (g_agdr7 a_agdru))
          [LclId] =
              [$dRead1_sggZm $dRead2_sggZn rp_sggZo rl_sggZp] \u []
                  let {
                    sat_sggZs [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [g_agdr7 a_agdru]
                    [LclId] =
                        [$dRead2_sggZn rp_sggZo rl_sggZp] \u []
                            Data.Functor.Classes.liftReadListPrec
                                $dRead2_sggZn rp_sggZo rl_sggZp; } in
                  let {
                    sat_sggZr [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec (g_agdr7 a_agdru)
                    [LclId] =
                        [$dRead2_sggZn rp_sggZo rl_sggZp] \u []
                            Data.Functor.Classes.liftReadPrec $dRead2_sggZn rp_sggZo rl_sggZp;
                  } in 
                    Data.Functor.Classes.liftReadPrec
                        $dRead1_sggZm sat_sggZr sat_sggZs; } in
        let {
          $wlvl_sggZt [InlPrag=NOUSERINLINE[0], Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: GHC.Prim.Int#
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
              sat-only [reader_sggZq] \r [ww_sggZu w_sggZv]
                  case <=# [ww_sggZu 10#] of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                    1# ->
                        let {
                          sat_sggZA [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_sgdH3
                          [LclId] =
                              [reader_sggZq w_sggZv] \r [a1_sggZx]
                                  let {
                                    sat_sggZz [Occ=Once]
                                      :: f_agdr6 (g_agdr7 a_agdru)
                                         -> Text.ParserCombinators.ReadP.P b_sgdH3
                                    [LclId] =
                                        [w_sggZv] \r [a2_sggZy] w_sggZv a2_sggZy;
                                  } in  reader_sggZq Data.Functor.Compose.$fRead1Compose1 sat_sggZz;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Functor.Compose.$fRead1Compose2 sat_sggZA
                          of
                          { Unit# ww2_sggZC [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_sggZC];
                          };
                  }; } in
        let {
          lvl8_sggZD [InlPrag=NOUSERINLINE[0], Occ=OnceL, Dmd=<L,C(C(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
              [$wlvl_sggZt] \r [w_sggZE w1_sggZF]
                  case w_sggZE of {
                    GHC.Types.I# ww1_sggZH [Occ=Once] ->
                        $wlvl_sggZt ww1_sggZH w1_sggZF;
                  }; } in
        let {
          sat_sggZK [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdru
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [lvl8_sggZD] \r [eta_sggZI eta1_sggZJ]
                  GHC.Read.list3 lvl8_sggZD eta_sggZI eta1_sggZJ;
        } in  sat_sggZK;

Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sggZL $dRead2_sggZM rp_sggZN rl_sggZO]
        let {
          ds_sggZP [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
          [LclId] =
              [$dRead1_sggZL $dRead2_sggZM rp_sggZN rl_sggZO] \u []
                  let {
                    sat_sggZV [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdrd]
                    [LclId] =
                        [rl_sggZO] \r [n_sggZR w1_sggZS]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sggZO w1_sggZS
                            of
                            { Unit# ww1_sggZU [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sggZU];
                            }; } in
                  let {
                    sat_sggZQ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdrd
                    [LclId] =
                        [rp_sggZN] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sggZN eta_B1;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sggZL $dRead2_sggZM sat_sggZQ sat_sggZV; } in
        let {
          sat_sggZY [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
          [LclId] =
              [ds_sggZP] \r [n_sggZW]
                  let {
                    sat_sggZX [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdrd)
                    [LclId] =
                        [ds_sggZP n_sggZW] \u []
                            ds_sggZP
                                n_sggZW Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sggZX;
        } in  sat_sggZY;

Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sggZZ $dRead2_sgh00 rp_sgh01 rl_sgh02]
        let {
          sat_sgh03 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a_agdsb)
          [LclId] =
              [$dRead1_sggZZ $dRead2_sgh00 rp_sgh01 rl_sgh02] \s []
                  Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                      $dRead1_sggZZ $dRead2_sgh00 rp_sgh01 rl_sgh02;
        } in  GHC.Read.list sat_sgh03;

Data.Functor.Compose.$fRead1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     Data.Functor.Classes.Read1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))>m] =
    [] \r [$dRead1_sgh04 $dRead2_sgh05]
        let {
          sat_sgh09 [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Compose.Compose f_agdr6 g_agdr7 a]
          [LclId] =
              [$dRead1_sgh04 $dRead2_sgh05] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadListPrec
                      $dRead1_sgh04 $dRead2_sgh05 eta_B2 eta_B1; } in
        let {
          sat_sgh08 [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a)
          [LclId] =
              [$dRead1_sgh04 $dRead2_sgh05] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                      $dRead1_sgh04 $dRead2_sgh05 eta_B2 eta_B1; } in
        let {
          sat_sgh07 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Compose.Compose f_agdr6 g_agdr7 a]
          [LclId] =
              [$dRead1_sgh04 $dRead2_sgh05] \u []
                  Data.Functor.Compose.$fRead1Compose_$cliftReadList
                      $dRead1_sgh04 $dRead2_sgh05; } in
        let {
          sat_sgh06 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdr6 g_agdr7 a)
          [LclId] =
              [$dRead1_sgh04 $dRead2_sgh05] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fRead1Compose_$cliftReadsPrec
                      $dRead1_sgh04 $dRead2_sgh05 eta_B2 eta_B1;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sgh06
                                        sat_sgh07
                                        sat_sgh08
                                        sat_sgh09];
Data.Functor.Compose.$fRead1Compose_$cliftReadList [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgh0a $dRead2_sgh0b]
        let {
          sat_sgh0c [Occ=Once]
            :: Data.Functor.Classes.Read1
                 (Data.Functor.Compose.Compose f_agdr6 g_agdr7)
          [LclId] =
              [$dRead1_sgh0a $dRead2_sgh0b] \u []
                  Data.Functor.Compose.$fRead1Compose $dRead1_sgh0a $dRead2_sgh0b;
        } in  Data.Functor.Classes.liftReadListDefault sat_sgh0c;

Data.Functor.Compose.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> Data.Functor.Compose.Compose f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*C1(C1(U)),1*C1(C1(U)))><L,U><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh0d w1_sgh0e w2_sgh0f w3_sgh0g ww_sgh0h w4_sgh0i]
        let {
          sat_sgh0l [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
            :: GHC.Types.Int -> f_sgdHs (g_sgdHt a_sgdHw) -> GHC.Show.ShowS
          [LclId] =
              [w_sgh0d w1_sgh0e w2_sgh0f w3_sgh0g] \s []
                  let {
                    sat_sgh0k [Occ=Once] :: [g_sgdHt a_sgdHw] -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sgh0e w2_sgh0f w3_sgh0g] \u []
                            Data.Functor.Classes.liftShowList w1_sgh0e w2_sgh0f w3_sgh0g; } in
                  let {
                    sat_sgh0j [Occ=Once]
                      :: GHC.Types.Int -> g_sgdHt a_sgdHw -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sgh0e w2_sgh0f w3_sgh0g] \u []
                            Data.Functor.Classes.liftShowsPrec w1_sgh0e w2_sgh0f w3_sgh0g;
                  } in 
                    Data.Functor.Classes.liftShowsPrec w_sgh0d sat_sgh0j sat_sgh0k;
        } in 
          Data.Functor.Classes.$wshowsUnaryWith
              sat_sgh0l Data.Functor.Compose.$fDataCompose6 ww_sgh0h w4_sgh0i;

Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Compose.Compose f g a
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh0m w1_sgh0n w2_sgh0o w3_sgh0p w4_sgh0q w5_sgh0r]
        case w4_sgh0q of {
          GHC.Types.I# ww1_sgh0t [Occ=Once] ->
              Data.Functor.Compose.$w$cliftShowsPrec
                  w_sgh0m w1_sgh0n w2_sgh0o w3_sgh0p ww1_sgh0t w5_sgh0r;
        };

Data.Functor.Compose.$fDataCompose3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Compose.$fShow1Compose_$cliftShowList
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Compose.Compose f g a]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U><L,U><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgh0u
           $dShow2_sgh0v
           sp_sgh0w
           sl_sgh0x
           eta_sgh0y
           eta1_sgh0z]
        let {
          sat_sgh0B [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdqk g_agdql a_agdqZ
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh0u $dShow2_sgh0v sp_sgh0w sl_sgh0x] \r [w_sgh0A]
                  Data.Functor.Compose.$w$cliftShowsPrec
                      $dShow1_sgh0u $dShow2_sgh0v sp_sgh0w sl_sgh0x 0# w_sgh0A;
        } in  GHC.Show.showList__ sat_sgh0B eta_sgh0y eta1_sgh0z;

Data.Functor.Compose.$fShow1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) =>
     Data.Functor.Classes.Show1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))>m] =
    [] \r [$dShow1_sgh0C $dShow2_sgh0D]
        let {
          sat_sgh0F [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Compose.Compose f_agdqk g_agdql a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh0C $dShow2_sgh0D] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fShow1Compose_$cliftShowList
                      $dShow1_sgh0C $dShow2_sgh0D eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh0E [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Compose.Compose f_agdqk g_agdql a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh0C $dShow2_sgh0D] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fShow1Compose_$cliftShowsPrec
                      $dShow1_sgh0C $dShow2_sgh0D eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sgh0E sat_sgh0F];

Data.Functor.Compose.$fEqCompose_$c==
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,1*U(1*U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgh0G $dEq2_sgh0H $dEq_sgh0I eta_sgh0J eta1_sgh0K]
        let {
          sat_sgh0M [Occ=Once]
            :: g_agdq0 a_agdq1 -> g_agdq0 a_agdq1 -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sgh0H $dEq_sgh0I] \u []
                  let {
                    sat_sgh0L [Occ=Once] :: a_agdq1 -> a_agdq1 -> GHC.Types.Bool
                    [LclId] =
                        [$dEq_sgh0I] \u [] GHC.Classes.== $dEq_sgh0I;
                  } in  $dEq2_sgh0H sat_sgh0L;
        } in  $dEq1_sgh0G sat_sgh0M eta_sgh0J eta1_sgh0K;

Data.Functor.Compose.$fEqCompose_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,1*U(1*U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sgh0N $dEq2_sgh0O $dEq_sgh0P eta_sgh0Q eta1_sgh0R]
        let {
          sat_sgh0T [Occ=Once]
            :: g_agdq0 a_agdq1 -> g_agdq0 a_agdq1 -> GHC.Types.Bool
          [LclId] =
              [$dEq2_sgh0O $dEq_sgh0P] \u []
                  let {
                    sat_sgh0S [Occ=Once] :: a_agdq1 -> a_agdq1 -> GHC.Types.Bool
                    [LclId] =
                        [$dEq_sgh0P] \u [] GHC.Classes.== $dEq_sgh0P;
                  } in  $dEq2_sgh0O sat_sgh0S;
        } in 
          case $dEq1_sgh0N sat_sgh0T eta_sgh0Q eta1_sgh0R of {
            GHC.Types.False -> GHC.Types.True [];
            GHC.Types.True -> GHC.Types.False [];
          };

Data.Functor.Compose.$fEqCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g,
      GHC.Classes.Eq a) =>
     GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(U)><L,U(U,A)>m] =
    [] \r [$dEq1_sgh0V $dEq2_sgh0W $dEq_sgh0X]
        let {
          sat_sgh0Z [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgh0V $dEq2_sgh0W $dEq_sgh0X] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fEqCompose_$c/=
                      $dEq1_sgh0V $dEq2_sgh0W $dEq_sgh0X eta_B2 eta_B1; } in
        let {
          sat_sgh0Y [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> Data.Functor.Compose.Compose f_agdpZ g_agdq0 a_agdq1
               -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sgh0V $dEq2_sgh0W $dEq_sgh0X] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fEqCompose_$c==
                      $dEq1_sgh0V $dEq2_sgh0W $dEq_sgh0X eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sgh0Y sat_sgh0Z];

Data.Functor.Compose.$fOrdCompose_$ccompare
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh10 $dOrd2_sgh11 $dOrd_sgh12 eta_sgh13 eta1_sgh14]
        let {
          sat_sgh16 [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh11 $dOrd_sgh12] \u []
                  let {
                    sat_sgh15 [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh12] \u [] GHC.Classes.compare $dOrd_sgh12;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh11 sat_sgh15;
        } in 
          Data.Functor.Classes.liftCompare
              $dOrd1_sgh10 sat_sgh16 eta_sgh13 eta1_sgh14;

Data.Functor.Compose.$fOrdCompose_$cp1Ord
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C1(U))),A)><L,1*U(1*C(U),A)><L,1*U(1*U(U,A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh17 $dOrd2_sgh18 $dOrd_sgh19]
        let {
          sat_sgh1c [Occ=Once, Dmd=<L,U(U,A)>] :: GHC.Classes.Eq a_agdpd
          [LclId] =
              [$dOrd_sgh19] \u [] GHC.Classes.$p1Ord $dOrd_sgh19; } in
        let {
          sat_sgh1b [Occ=Once, Dmd=<L,C(U)>]
            :: Data.Functor.Classes.Eq1 g_agdpc
          [LclId] =
              [$dOrd2_sgh18] \u []
                  Data.Functor.Classes.$p1Ord1 $dOrd2_sgh18; } in
        let {
          sat_sgh1a [Occ=Once, Dmd=<L,C(C1(C1(U)))>]
            :: Data.Functor.Classes.Eq1 f_agdpb
          [LclId] =
              [$dOrd1_sgh17] \u [] Data.Functor.Classes.$p1Ord1 $dOrd1_sgh17;
        } in 
          Data.Functor.Compose.$fEqCompose sat_sgh1a sat_sgh1b sat_sgh1c;

Data.Functor.Compose.$fOrdCompose_$c<
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1d $dOrd2_sgh1e $dOrd_sgh1f x_sgh1g y_sgh1h]
        let {
          sat_sgh1j [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1e $dOrd_sgh1f] \u []
                  let {
                    sat_sgh1i [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1f] \u [] GHC.Classes.compare $dOrd_sgh1f;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1e sat_sgh1i;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1d sat_sgh1j x_sgh1g y_sgh1h
          of
          { __DEFAULT -> GHC.Types.False [];
            GHC.Types.LT -> GHC.Types.True [];
          };

Data.Functor.Compose.$fOrdCompose_$c>=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1l $dOrd2_sgh1m $dOrd_sgh1n x_sgh1o y_sgh1p]
        let {
          sat_sgh1r [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1m $dOrd_sgh1n] \u []
                  let {
                    sat_sgh1q [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1n] \u [] GHC.Classes.compare $dOrd_sgh1n;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1m sat_sgh1q;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1l sat_sgh1r x_sgh1o y_sgh1p
          of
          { __DEFAULT -> GHC.Types.True [];
            GHC.Types.LT -> GHC.Types.False [];
          };

Data.Functor.Compose.$fOrdCompose_$c>
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1t $dOrd2_sgh1u $dOrd_sgh1v x_sgh1w y_sgh1x]
        let {
          sat_sgh1z [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1u $dOrd_sgh1v] \u []
                  let {
                    sat_sgh1y [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1v] \u [] GHC.Classes.compare $dOrd_sgh1v;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1u sat_sgh1y;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1t sat_sgh1z x_sgh1w y_sgh1x
          of
          { __DEFAULT -> GHC.Types.False [];
            GHC.Types.GT -> GHC.Types.True [];
          };

Data.Functor.Compose.$fOrdCompose_$c<=
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1B $dOrd2_sgh1C $dOrd_sgh1D x_sgh1E y_sgh1F]
        let {
          sat_sgh1H [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1C $dOrd_sgh1D] \u []
                  let {
                    sat_sgh1G [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1D] \u [] GHC.Classes.compare $dOrd_sgh1D;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1C sat_sgh1G;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1B sat_sgh1H x_sgh1E y_sgh1F
          of
          { __DEFAULT -> GHC.Types.True [];
            GHC.Types.GT -> GHC.Types.False [];
          };

Data.Functor.Compose.$fOrdCompose_$cmax
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1J $dOrd2_sgh1K $dOrd_sgh1L x_sgh1M y_sgh1N]
        let {
          sat_sgh1P [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1K $dOrd_sgh1L] \u []
                  let {
                    sat_sgh1O [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1L] \u [] GHC.Classes.compare $dOrd_sgh1L;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1K sat_sgh1O;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1J sat_sgh1P x_sgh1M y_sgh1N
          of
          { __DEFAULT -> y_sgh1N;
            GHC.Types.GT -> x_sgh1M;
          };

Data.Functor.Compose.$fOrdCompose_$cmin
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))),1*U(A,1*C1(C1(C1(U))))><L,1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sgh1R $dOrd2_sgh1S $dOrd_sgh1T x_sgh1U y_sgh1V]
        let {
          sat_sgh1X [Occ=Once]
            :: g_agdpc a_agdpd -> g_agdpc a_agdpd -> GHC.Types.Ordering
          [LclId] =
              [$dOrd2_sgh1S $dOrd_sgh1T] \u []
                  let {
                    sat_sgh1W [Occ=Once] :: a_agdpd -> a_agdpd -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sgh1T] \u [] GHC.Classes.compare $dOrd_sgh1T;
                  } in  Data.Functor.Classes.liftCompare $dOrd2_sgh1S sat_sgh1W;
        } in 
          case
              Data.Functor.Classes.liftCompare
                  $dOrd1_sgh1R sat_sgh1X x_sgh1U y_sgh1V
          of
          { __DEFAULT -> x_sgh1U;
            GHC.Types.GT -> y_sgh1V;
          };

Data.Functor.Compose.$fOrdCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g,
      GHC.Classes.Ord a) =>
     GHC.Classes.Ord (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*C(C1(C1(U))),C(C1(C1(U))))><L,U(1*C(U),C(U))><L,U(1*U(U,A),U,A,A,A,A,A,A)>m] =
    [] \r [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21]
        let {
          sat_sgh29 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$cmin
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh28 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$cmax
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh27 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c>=
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh26 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c>
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh25 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c<=
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh24 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Bool
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$c<
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh23 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fOrdCompose_$ccompare
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21 eta_B2 eta_B1; } in
        let {
          sat_sgh22 [Occ=Once]
            :: GHC.Classes.Eq
                 (Data.Functor.Compose.Compose f_agdpb g_agdpc a_agdpd)
          [LclId] =
              [$dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21] \u []
                  Data.Functor.Compose.$fOrdCompose_$cp1Ord
                      $dOrd1_sgh1Z $dOrd2_sgh20 $dOrd_sgh21;
        } in 
          GHC.Classes.C:Ord [sat_sgh22
                             sat_sgh23
                             sat_sgh24
                             sat_sgh25
                             sat_sgh26
                             sat_sgh27
                             sat_sgh28
                             sat_sgh29];

Data.Functor.Compose.$fReadCompose_$creadPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgh2a $dRead2_sgh2b $dRead_sgh2c]
        let {
          sat_sgh2e [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
          [LclId] =
              [$dRead_sgh2c] \u [] GHC.Read.readListPrec $dRead_sgh2c; } in
        let {
          sat_sgh2d [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
          [LclId] =
              [$dRead_sgh2c] \u [] GHC.Read.readPrec $dRead_sgh2c;
        } in 
          Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
              $dRead1_sgh2a $dRead2_sgh2b sat_sgh2d sat_sgh2e;

Data.Functor.Compose.$fReadCompose_$creadsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgh2f $dRead2_sgh2g $dRead_sgh2h]
        let {
          ds_sgh2i [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgh2f $dRead2_sgh2g $dRead_sgh2h] \u []
                  let {
                    sat_sgh2k [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
                    [LclId] =
                        [$dRead_sgh2h] \u [] GHC.Read.readListPrec $dRead_sgh2h; } in
                  let {
                    sat_sgh2j [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
                    [LclId] =
                        [$dRead_sgh2h] \u [] GHC.Read.readPrec $dRead_sgh2h;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sgh2f $dRead2_sgh2g sat_sgh2j sat_sgh2k; } in
        let {
          sat_sgh2n [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [ds_sgh2i] \r [n_sgh2l]
                  let {
                    sat_sgh2m [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
                    [LclId] =
                        [ds_sgh2i n_sgh2l] \u []
                            ds_sgh2i
                                n_sgh2l Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgh2m;
        } in  sat_sgh2n;

Data.Functor.Compose.$fReadCompose_$creadListPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgh2o $dRead2_sgh2p $dRead_sgh2q]
        let {
          sat_sgh2t [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgh2o $dRead2_sgh2p $dRead_sgh2q] \s []
                  let {
                    sat_sgh2s [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_agdoG]
                    [LclId] =
                        [$dRead_sgh2q] \u [] GHC.Read.readListPrec $dRead_sgh2q; } in
                  let {
                    sat_sgh2r [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_agdoG
                    [LclId] =
                        [$dRead_sgh2q] \u [] GHC.Read.readPrec $dRead_sgh2q;
                  } in 
                    Data.Functor.Compose.$fRead1Compose_$cliftReadPrec
                        $dRead1_sgh2o $dRead2_sgh2p sat_sgh2r sat_sgh2s;
        } in  GHC.Read.list sat_sgh2t;

Data.Functor.Compose.$fReadCompose_$creadList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Functor.Compose.Compose f g a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sgh2u $dRead2_sgh2v $dRead_sgh2w]
        let {
          sat_sgh2x [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgh2u $dRead2_sgh2v $dRead_sgh2w] \u []
                  Data.Functor.Compose.$fReadCompose_$creadListPrec
                      $dRead1_sgh2u
                      $dRead2_sgh2v
                      $dRead_sgh2w
                      GHC.Read.$fRead()7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgh2x;

Data.Functor.Compose.$fReadCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Read.Read (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(A,A,C(C1(C(C1(U)))),A)><L,U(A,A,C(C1(U)),C(C1(U)))><L,U(A,A,U,U)>m] =
    [] \r [$dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A]
        let {
          sat_sgh2E [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A] \u []
                  Data.Functor.Compose.$fReadCompose_$creadListPrec
                      $dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A; } in
        let {
          sat_sgh2D [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A] \u []
                  Data.Functor.Compose.$fReadCompose_$creadPrec
                      $dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A; } in
        let {
          sat_sgh2C [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG]
          [LclId] =
              [$dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A] \u []
                  Data.Functor.Compose.$fReadCompose_$creadList
                      $dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A; } in
        let {
          sat_sgh2B [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Compose.Compose f_agdoE g_agdoF a_agdoG)
          [LclId] =
              [$dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A] \u []
                  Data.Functor.Compose.$fReadCompose_$creadsPrec
                      $dRead1_sgh2y $dRead2_sgh2z $dRead_sgh2A;
        } in  GHC.Read.C:Read [sat_sgh2B sat_sgh2C sat_sgh2D sat_sgh2E];

Data.Functor.Compose.$fShowCompose_$cshowsPrec
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Types.Int
     -> Data.Functor.Compose.Compose f g a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(1*U,A,1*U)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgh2F
           $dShow2_sgh2G
           $dShow_sgh2H
           eta_sgh2I
           eta1_sgh2J]
        case eta_sgh2I of {
          GHC.Types.I# ww1_sgh2L [Occ=Once] ->
              let {
                sat_sgh2N [Occ=Once] :: [a_agdog] -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sgh2H] \u [] GHC.Show.showList $dShow_sgh2H; } in
              let {
                sat_sgh2M [Occ=Once] :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sgh2H] \u [] GHC.Show.showsPrec $dShow_sgh2H;
              } in 
                Data.Functor.Compose.$w$cliftShowsPrec
                    $dShow1_sgh2F
                    $dShow2_sgh2G
                    sat_sgh2M
                    sat_sgh2N
                    ww1_sgh2L
                    eta1_sgh2J;
        };

Data.Functor.Compose.$fShowCompose_$cshow
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     Data.Functor.Compose.Compose f g a -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(U))))),A)><L,U(1*C1(C1(U)),1*C1(C1(U)))><L,U(1*U,A,1*U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgh2O $dShow2_sgh2P $dShow_sgh2Q x_sgh2R]
        let {
          sp_sgh2S :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgh2Q] \u [] GHC.Show.showsPrec $dShow_sgh2Q; } in
        let {
          sl_sgh2T :: [a_agdog] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgh2Q] \u [] GHC.Show.showList $dShow_sgh2Q; } in
        let {
          sat_sgh2W [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow1_sgh2O $dShow2_sgh2P x_sgh2R sp_sgh2S sl_sgh2T] \u []
                  let {
                    sat_sgh2V [Occ=Once] :: [g_agdof a_agdog] -> GHC.Show.ShowS
                    [LclId] =
                        [$dShow2_sgh2P sp_sgh2S sl_sgh2T] \u []
                            Data.Functor.Classes.liftShowList
                                $dShow2_sgh2P sp_sgh2S sl_sgh2T; } in
                  let {
                    sat_sgh2U [Occ=Once]
                      :: GHC.Types.Int -> g_agdof a_agdog -> GHC.Show.ShowS
                    [LclId] =
                        [$dShow2_sgh2P sp_sgh2S sl_sgh2T] \u []
                            Data.Functor.Classes.liftShowsPrec $dShow2_sgh2P sp_sgh2S sl_sgh2T;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        $dShow1_sgh2O
                        sat_sgh2U
                        sat_sgh2V
                        Data.Functor.Classes.$fRead1Const1
                        x_sgh2R
                        GHC.Types.[]; } in
        let {
          sat_sgh2X [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sgh2W];
        } in  GHC.Base.++ Data.Functor.Compose.$fDataCompose6 sat_sgh2X;

Data.Functor.Compose.$fShowCompose_$cshowList
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     [Data.Functor.Compose.Compose f g a] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(1*U,A,1*U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sgh2Y $dShow2_sgh2Z $dShow_sgh30 ls_sgh31 s_sgh32]
        let {
          lvl8_sgh33 [Occ=OnceL]
            :: GHC.Types.Int -> a_agdog -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgh30] \u [] GHC.Show.showsPrec $dShow_sgh30; } in
        let {
          lvl9_sgh34 [Occ=OnceL] :: [a_agdog] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgh30] \u [] GHC.Show.showList $dShow_sgh30; } in
        let {
          sat_sgh36 [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh2Y $dShow2_sgh2Z lvl8_sgh33 lvl9_sgh34] \r [eta_sgh35]
                  Data.Functor.Compose.$w$cliftShowsPrec
                      $dShow1_sgh2Y $dShow2_sgh2Z lvl8_sgh33 lvl9_sgh34 0# eta_sgh35;
        } in  GHC.Show.showList__ sat_sgh36 ls_sgh31 s_sgh32;

Data.Functor.Compose.$fShowCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Show.Show (Data.Functor.Compose.Compose f g a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(C(C1(C1(C1(C(U))))),A)><L,U(C(C1(U)),C(C1(U)))><L,U(U,A,U)>m] =
    [] \r [$dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39]
        let {
          sat_sgh3c [Occ=Once]
            :: [Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshowList
                      $dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39 eta_B2 eta_B1; } in
        let {
          sat_sgh3b [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Base.String
          [LclId] =
              [$dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39] \r [eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshow
                      $dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39 eta_B1; } in
        let {
          sat_sgh3a [Occ=Once]
            :: GHC.Types.Int
               -> Data.Functor.Compose.Compose f_agdoe g_agdof a_agdog
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fShowCompose_$cshowsPrec
                      $dShow1_sgh37 $dShow2_sgh38 $dShow_sgh39 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgh3a sat_sgh3b sat_sgh3c];

Data.Functor.Compose.$fFunctorCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b.
     (a -> b) -> Data.Functor.Compose.Compose f g a -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgh3d $dFunctor1_sgh3e f1_sgh3f ds_sgh3g]
        let {
          sat_sgh3h [Occ=Once] :: g_agdnF a_agdnL -> g_agdnF b_agdnM
          [LclId] =
              [$dFunctor1_sgh3e f1_sgh3f] \u []
                  GHC.Base.fmap $dFunctor1_sgh3e f1_sgh3f;
        } in  GHC.Base.fmap $dFunctor_sgh3d sat_sgh3h ds_sgh3g;

Data.Functor.Compose.$fFunctorCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     forall a b. a -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgh3i $dFunctor1_sgh3j x_sgh3k eta_sgh3l]
        let {
          sat_sgh3o [Occ=Once] :: g_Xgdqn b_agdo6 -> g_Xgdqn a_agdo5
          [LclId] =
              [$dFunctor1_sgh3j x_sgh3k] \u []
                  let {
                    sat_sgh3n [Occ=Once] :: b_agdo6 -> a_agdo5
                    [LclId] =
                        [x_sgh3k] \r [ds_sgh3m] x_sgh3k;
                  } in  GHC.Base.fmap $dFunctor1_sgh3j sat_sgh3n;
        } in  GHC.Base.fmap $dFunctor_sgh3i sat_sgh3o eta_sgh3l;

Data.Functor.Compose.$fFunctorCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, GHC.Base.Functor g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgh3p $dFunctor1_sgh3q]
        let {
          sat_sgh3s [Occ=Once]
            :: forall a b.
               a
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm b
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm a
          [LclId] =
              [$dFunctor_sgh3p $dFunctor1_sgh3q] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFunctorCompose1
                      $dFunctor_sgh3p $dFunctor1_sgh3q eta_B2 eta_B1; } in
        let {
          sat_sgh3r [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm a
               -> Data.Functor.Compose.Compose f_Xgdqk g_Xgdqm b
          [LclId] =
              [$dFunctor_sgh3p $dFunctor1_sgh3q] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFunctorCompose2
                      $dFunctor_sgh3p $dFunctor1_sgh3q eta_B2 eta_B1;
        } in  GHC.Base.C:Functor [sat_sgh3r sat_sgh3s];

Data.Functor.Compose.$fFoldableCompose_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Functor.Compose.Compose f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh3t
           $dFoldable1_sgh3u
           $dMonoid_sgh3v
           f1_sgh3w
           ds_sgh3x]
        let {
          sat_sgh3y [Occ=Once] :: g_agdl1 a_agdli -> m_agdlh
          [LclId] =
              [$dFoldable1_sgh3u $dMonoid_sgh3v f1_sgh3w] \u []
                  Data.Foldable.foldMap $dFoldable1_sgh3u $dMonoid_sgh3v f1_sgh3w;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh3t $dMonoid_sgh3v sat_sgh3y ds_sgh3x;

Data.Functor.Compose.$fFoldableCompose_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Compose.Compose f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh3z $dFoldable1_sgh3A $dMonoid_sgh3B ds_sgh3C]
        let {
          sat_sgh3D [Occ=Once] :: g_agdl1 m_agdl7 -> m_agdl7
          [LclId] =
              [$dFoldable1_sgh3A $dMonoid_sgh3B] \u []
                  Data.Foldable.foldMap $dFoldable1_sgh3A $dMonoid_sgh3B GHC.Base.id;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh3z $dMonoid_sgh3B sat_sgh3D ds_sgh3C;

Data.Functor.Compose.$fFoldableCompose1 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgh3E] v_sgh3E;

Data.Functor.Compose.$fFoldableCompose_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh3F $dFoldable1_sgh3G $dNum_sgh3H]
        let {
          $dMonoid_sgh3I
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_agdnl)
          [LclId] =
              [$dNum_sgh3H] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sgh3H; } in
        let {
          lvl8_sgh3J [Occ=OnceL]
            :: g_agdl1 a_agdnl -> Data.Semigroup.Internal.Sum a_agdnl
          [LclId] =
              [$dFoldable1_sgh3G $dMonoid_sgh3I] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh3G
                      $dMonoid_sgh3I
                      Data.Functor.Compose.$fFoldableCompose1; } in
        let {
          sat_sgh3L [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnl
               -> Data.Semigroup.Internal.Sum a_agdnl
          [LclId] =
              [$dFoldable_sgh3F $dMonoid_sgh3I lvl8_sgh3J] \r [ds_sgh3K]
                  Data.Foldable.foldMap
                      $dFoldable_sgh3F $dMonoid_sgh3I lvl8_sgh3J ds_sgh3K;
        } in  sat_sgh3L;

lvl_rgdPQ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Functor.Compose.$fFoldableCompose2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rgdPQ of sat_sgh3M {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgh3M;
        };

Data.Functor.Compose.$fFoldableCompose_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh3N $dFoldable1_sgh3O $dOrd_sgh3P]
        let {
          $dMonoid_sgh3Q :: GHC.Base.Monoid (Data.Functor.Utils.Min a_agdnb)
          [LclId] =
              [$dOrd_sgh3P] \u []
                  Data.Functor.Utils.$fMonoidMin $dOrd_sgh3P; } in
        let {
          lvl8_sgh3R [Occ=OnceL]
            :: g_agdl1 a_agdnb -> Data.Functor.Utils.Min a_agdnb
          [LclId] =
              [$dFoldable1_sgh3O $dMonoid_sgh3Q] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh3O $dMonoid_sgh3Q GHC.Base.Just; } in
        let {
          sat_sgh3V [Occ=OnceT[0]]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnb -> a_agdnb
          [LclId] =
              [$dFoldable_sgh3N $dMonoid_sgh3Q lvl8_sgh3R] \r [x_sgh3S]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_sgh3N $dMonoid_sgh3Q lvl8_sgh3R x_sgh3S
                  of
                  { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose2;
                    GHC.Base.Just v_sgh3U [Occ=Once] -> v_sgh3U;
                  };
        } in  sat_sgh3V;

lvl1_rgdPR :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Functor.Compose.$fFoldableCompose3 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rgdPR of sat_sgh3W {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgh3W;
        };

Data.Functor.Compose.$fFoldableCompose_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh3X $dFoldable1_sgh3Y $dOrd_sgh3Z]
        let {
          $dMonoid_sgh40 :: GHC.Base.Monoid (Data.Functor.Utils.Max a_agdn1)
          [LclId] =
              [$dOrd_sgh3Z] \u []
                  Data.Functor.Utils.$fMonoidMax $dOrd_sgh3Z; } in
        let {
          lvl8_sgh41 [Occ=OnceL]
            :: g_agdl1 a_agdn1 -> Data.Functor.Utils.Max a_agdn1
          [LclId] =
              [$dFoldable1_sgh3Y $dMonoid_sgh40] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh3Y $dMonoid_sgh40 GHC.Base.Just; } in
        let {
          sat_sgh45 [Occ=OnceT[0]]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdn1 -> a_agdn1
          [LclId] =
              [$dFoldable_sgh3X $dMonoid_sgh40 lvl8_sgh41] \r [x_sgh42]
                  case
                      Data.Foldable.foldMap
                          $dFoldable_sgh3X $dMonoid_sgh40 lvl8_sgh41 x_sgh42
                  of
                  { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose3;
                    GHC.Base.Just v_sgh44 [Occ=Once] -> v_sgh44;
                  };
        } in  sat_sgh45;

Data.Functor.Compose.$fFoldableCompose_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a.
     GHC.Classes.Eq a =>
     a -> Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh46 $dFoldable1_sgh47 $dEq_sgh48 eta_sgh49]
        let {
          lvl8_sgh4a [Occ=OnceL]
            :: g_agdl1 a_agdmR -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable1_sgh47 $dEq_sgh48 eta_sgh49] \u []
                  let {
                    sat_sgh4b [Occ=Once] :: a_agdmR -> Data.Semigroup.Internal.Any
                    [LclId] =
                        [$dEq_sgh48 eta_sgh49] \u [] GHC.Classes.== $dEq_sgh48 eta_sgh49;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh47
                        Data.Semigroup.Internal.$fMonoidAny
                        sat_sgh4b; } in
        let {
          sat_sgh4d [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdmR
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dFoldable_sgh46 lvl8_sgh4a] \r [ds_sgh4c]
                  Data.Foldable.foldMap
                      $dFoldable_sgh46
                      Data.Semigroup.Internal.$fMonoidAny
                      lvl8_sgh4a
                      ds_sgh4c;
        } in  sat_sgh4d;

Data.Functor.Compose.$fFoldableCompose7
  :: forall b.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Functor.Compose.$fFoldableCompose_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh4e
           $dFoldable1_sgh4f
           f1_sgh4g
           z_sgh4h
           t1_sgh4i]
        let {
          sat_sgh4m [Occ=Once]
            :: g_agdl1 a_agdlU
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo b_agdlT)
          [LclId] =
              [$dFoldable1_sgh4f f1_sgh4g] \u []
                  let {
                    sat_sgh4l [Occ=Once]
                      :: a_agdlU
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo b_agdlT)
                    [LclId] =
                        [f1_sgh4g] \r [x_sgh4j y_sgh4k] f1_sgh4g y_sgh4k x_sgh4j;
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh4f
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgh4l;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh4e
              Data.Functor.Compose.$fFoldableCompose7
              sat_sgh4m
              t1_sgh4i
              z_sgh4h;

lvl2_rgdPS :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Functor.Compose.$fFoldableCompose6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rgdPS of sat_sgh4n {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgh4n;
        };

Data.Functor.Compose.$fFoldableCompose_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh4o $dFoldable1_sgh4p f1_sgh4q xs_sgh4r]
        let {
          sat_sgh4y [Occ=Once]
            :: g_agdl1 a_agdml
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdml))
          [LclId] =
              [$dFoldable1_sgh4p f1_sgh4q] \u []
                  let {
                    sat_sgh4x [Occ=Once]
                      :: a_agdml
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdml))
                    [LclId] =
                        [f1_sgh4q] \r [x_sgh4s y_sgh4t]
                            let {
                              sat_sgh4w [Occ=Once] :: a_agdml
                              [LclId] =
                                  [f1_sgh4q x_sgh4s y_sgh4t] \u []
                                      case y_sgh4t of {
                                        GHC.Base.Nothing -> x_sgh4s;
                                        GHC.Base.Just x1_sgh4v [Occ=Once] ->
                                            f1_sgh4q x1_sgh4v x_sgh4s;
                                      };
                            } in  GHC.Base.Just [sat_sgh4w];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh4p
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgh4x;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_sgh4o
                  Data.Functor.Compose.$fFoldableCompose7
                  sat_sgh4y
                  xs_sgh4r
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose6;
            GHC.Base.Just v_sgh4A [Occ=Once] -> v_sgh4A;
          };

Data.Functor.Compose.$fFoldableCompose_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh4B
           $dFoldable1_sgh4C
           f1_sgh4D
           z0_sgh4E
           xs_sgh4F]
        let {
          sat_sgh4L [Occ=Once]
            :: g_agdl1 a_agdlJ
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo (b_agdlK -> b_agdlK))
          [LclId] =
              [$dFoldable1_sgh4C f1_sgh4D] \u []
                  let {
                    sat_sgh4K [Occ=Once]
                      :: a_agdlJ
                         -> Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (b_agdlK -> b_agdlK))
                    [LclId] =
                        [f1_sgh4D] \r [x_sgh4G y_sgh4H z_sgh4I]
                            case f1_sgh4D x_sgh4G z_sgh4I of vx_sgh4J {
                              __DEFAULT -> y_sgh4H vx_sgh4J;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh4C
                        Data.Functor.Compose.$fFoldableCompose7
                        sat_sgh4K;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh4B
              Data.Functor.Compose.$fFoldableCompose7
              sat_sgh4L
              xs_sgh4F
              GHC.Base.id
              z0_sgh4E;

Data.Functor.Compose.$fFoldableCompose_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a b.
     (a -> b -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh4M
           $dFoldable1_sgh4N
           f1_sgh4O
           z_sgh4P
           t1_sgh4Q]
        let {
          sat_sgh4R [Occ=Once]
            :: g_agdl1 a_agdlz -> Data.Semigroup.Internal.Endo b_agdlA
          [LclId] =
              [$dFoldable1_sgh4N f1_sgh4O] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh4N Data.Semigroup.Internal.$fMonoidEndo f1_sgh4O;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh4M
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgh4R
              t1_sgh4Q
              z_sgh4P;

Data.Functor.Compose.$fFoldableCompose_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall b a.
     (b -> a -> b) -> b -> Data.Functor.Compose.Compose f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh4S
           $dFoldable1_sgh4T
           f1_sgh4U
           z0_sgh4V
           xs_sgh4W]
        let {
          sat_sgh52 [Occ=Once]
            :: g_agdl1 a_agdm4
               -> Data.Semigroup.Internal.Endo (b_agdm3 -> b_agdm3)
          [LclId] =
              [$dFoldable1_sgh4T f1_sgh4U] \u []
                  let {
                    sat_sgh51 [Occ=Once]
                      :: a_agdm4 -> Data.Semigroup.Internal.Endo (b_agdm3 -> b_agdm3)
                    [LclId] =
                        [f1_sgh4U] \r [x_sgh4X k_sgh4Y z_sgh4Z]
                            case f1_sgh4U z_sgh4Z x_sgh4X of vx_sgh50 {
                              __DEFAULT -> k_sgh4Y vx_sgh50;
                            };
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh4T Data.Semigroup.Internal.$fMonoidEndo sat_sgh51;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh4S
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgh52
              xs_sgh4W
              GHC.Base.id
              z0_sgh4V;

Data.Functor.Compose.$fFoldableCompose4
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sgh53 k_sgh54 z_sgh55]
        case z_sgh55 of {
          GHC.Types.I# x1_sgh57 [Occ=Once] ->
              case +# [x1_sgh57 1#] of sat_sgh58 {
                __DEFAULT ->
                    let {
                      sat_sgh59 [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sgh58];
                    } in  k_sgh54 sat_sgh59;
              };
        };

Data.Functor.Compose.$fFoldableCompose_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh5a $dFoldable1_sgh5b eta_sgh5c]
        let {
          sat_sgh5d [Occ=Once]
            :: g_agdl1 a_agdmJ
               -> Data.Semigroup.Internal.Endo (GHC.Types.Int -> GHC.Types.Int)
          [LclId] =
              [$dFoldable1_sgh5b] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh5b
                      Data.Semigroup.Internal.$fMonoidEndo
                      Data.Functor.Compose.$fFoldableCompose4;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh5a
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgh5d
              eta_sgh5c
              GHC.Base.id
              Data.Functor.Compose.$fDataCompose3;

lvl3_rgdPT :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Functor.Compose.$fFoldableCompose8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_rgdPT of sat_sgh5e {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sgh5e;
        };

Data.Functor.Compose.$fFoldableCompose_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. (a -> a -> a) -> Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh5f $dFoldable1_sgh5g f1_sgh5h xs_sgh5i]
        let {
          sat_sgh5p [Occ=Once]
            :: g_agdl1 a_agdmd
               -> Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdmd)
          [LclId] =
              [$dFoldable1_sgh5g f1_sgh5h] \u []
                  let {
                    sat_sgh5o [Occ=Once]
                      :: a_agdmd -> Data.Semigroup.Internal.Endo (GHC.Base.Maybe a_agdmd)
                    [LclId] =
                        [f1_sgh5h] \r [x_sgh5j m_sgh5k]
                            let {
                              sat_sgh5n [Occ=Once] :: a_agdmd
                              [LclId] =
                                  [f1_sgh5h x_sgh5j m_sgh5k] \u []
                                      case m_sgh5k of {
                                        GHC.Base.Nothing -> x_sgh5j;
                                        GHC.Base.Just y_sgh5m [Occ=Once] ->
                                            f1_sgh5h x_sgh5j y_sgh5m;
                                      };
                            } in  GHC.Base.Just [sat_sgh5n];
                  } in 
                    Data.Foldable.foldMap
                        $dFoldable1_sgh5g Data.Semigroup.Internal.$fMonoidEndo sat_sgh5o;
        } in 
          case
              Data.Foldable.foldMap
                  $dFoldable_sgh5f
                  Data.Semigroup.Internal.$fMonoidEndo
                  sat_sgh5p
                  xs_sgh5i
                  GHC.Base.Nothing
          of
          { GHC.Base.Nothing -> Data.Functor.Compose.$fFoldableCompose8;
            GHC.Base.Just v_sgh5r [Occ=Once] -> v_sgh5r;
          };

Data.Functor.Compose.$fFoldableCompose5
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgh5s ds1_sgh5t] GHC.Types.False [];

Data.Functor.Compose.$fFoldableCompose_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh5u $dFoldable1_sgh5v eta_sgh5w]
        let {
          sat_sgh5x [Occ=Once]
            :: g_agdl1 a_agdmB -> Data.Semigroup.Internal.Endo GHC.Types.Bool
          [LclId] =
              [$dFoldable1_sgh5v] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh5v
                      Data.Semigroup.Internal.$fMonoidEndo
                      Data.Functor.Compose.$fFoldableCompose5;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh5u
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgh5x
              eta_sgh5w
              GHC.Types.True;

Data.Functor.Compose.$fFoldableCompose_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. GHC.Num.Num a => Data.Functor.Compose.Compose f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh5y $dFoldable1_sgh5z $dNum_sgh5A]
        let {
          $dMonoid_sgh5B
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_agdnv)
          [LclId] =
              [$dNum_sgh5A] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sgh5A; } in
        let {
          lvl8_sgh5C [Occ=OnceL]
            :: g_agdl1 a_agdnv -> Data.Semigroup.Internal.Product a_agdnv
          [LclId] =
              [$dFoldable1_sgh5z $dMonoid_sgh5B] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh5z
                      $dMonoid_sgh5B
                      Data.Functor.Compose.$fFoldableCompose1; } in
        let {
          sat_sgh5E [Occ=Once]
            :: Data.Functor.Compose.Compose f_agdl0 g_agdl1 a_agdnv
               -> Data.Semigroup.Internal.Product a_agdnv
          [LclId] =
              [$dFoldable_sgh5y $dMonoid_sgh5B lvl8_sgh5C] \r [ds_sgh5D]
                  Data.Foldable.foldMap
                      $dFoldable_sgh5y $dMonoid_sgh5B lvl8_sgh5C ds_sgh5D;
        } in  sat_sgh5E;

Data.Functor.Compose.$fFoldableCompose_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     forall a. Data.Functor.Compose.Compose f g a -> [a]
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sgh5F $dFoldable1_sgh5G eta_sgh5H]
        let {
          sat_sgh5I [Occ=Once]
            :: g_agdl1 a_agdmt -> Data.Semigroup.Internal.Endo [a_agdmt]
          [LclId] =
              [$dFoldable1_sgh5G] \u []
                  Data.Foldable.foldMap
                      $dFoldable1_sgh5G Data.Semigroup.Internal.$fMonoidEndo GHC.Types.:;
        } in 
          Data.Foldable.foldMap
              $dFoldable_sgh5F
              Data.Semigroup.Internal.$fMonoidEndo
              sat_sgh5I
              eta_sgh5H
              GHC.Types.[];

Data.Functor.Compose.$fFoldableCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Foldable.Foldable f, Data.Foldable.Foldable g) =>
     Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [$dFoldable_sgh5J $dFoldable1_sgh5K]
        let {
          sat_sgh60 [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cproduct
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5Z [Occ=Once]
            :: forall a.
               GHC.Num.Num a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$csum
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5Y [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cminimum
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5X [Occ=Once]
            :: forall a.
               GHC.Classes.Ord a =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cmaximum
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5W [Occ=Once]
            :: forall a.
               GHC.Classes.Eq a =>
               a
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$celem
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B2 eta_B1; } in
        let {
          sat_sgh5V [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Int
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$clength
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5U [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> GHC.Types.Bool
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cnull
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5T [Occ=Once]
            :: forall a. Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> [a]
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$ctoList
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B1; } in
        let {
          sat_sgh5S [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl1
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B2 eta_B1; } in
        let {
          sat_sgh5R [Occ=Once]
            :: forall a.
               (a -> a -> a)
               -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> a
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr1
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B2 eta_B1; } in
        let {
          sat_sgh5Q [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl'
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh5P [Occ=Once]
            :: forall b a.
               (b -> a -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldl
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh5O [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr'
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh5N [Occ=Once]
            :: forall a b.
               (a -> b -> b)
               -> b -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> b
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldr
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh5M [Occ=Once]
            :: forall m a.
               GHC.Base.Monoid m =>
               (a -> m) -> Data.Functor.Compose.Compose f_agdl0 g_agdl1 a -> m
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfoldMap
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh5L [Occ=Once]
            :: forall m.
               GHC.Base.Monoid m =>
               Data.Functor.Compose.Compose f_agdl0 g_agdl1 m -> m
          [LclId] =
              [$dFoldable_sgh5J $dFoldable1_sgh5K] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fFoldableCompose_$cfold
                      $dFoldable_sgh5J $dFoldable1_sgh5K eta_B2 eta_B1;
        } in 
          Data.Foldable.C:Foldable [sat_sgh5L
                                    sat_sgh5M
                                    sat_sgh5N
                                    sat_sgh5O
                                    sat_sgh5P
                                    sat_sgh5Q
                                    sat_sgh5R
                                    sat_sgh5S
                                    sat_sgh5T
                                    sat_sgh5U
                                    sat_sgh5V
                                    sat_sgh5W
                                    sat_sgh5X
                                    sat_sgh5Y
                                    sat_sgh5Z
                                    sat_sgh60];

Data.Functor.Compose.$fTraversableCompose1
  :: forall (f :: * -> *) (g :: * -> *) b. f (g b) -> f (g b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgh61] v_sgh61;

Data.Functor.Compose.$fTraversableCompose_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> Data.Functor.Compose.Compose f g a
     -> f1 (Data.Functor.Compose.Compose f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh62
           $dTraversable1_sgh63
           $dApplicative_sgh64
           eta_sgh65
           eta1_sgh66]
        let {
          sat_sgh69 [Occ=Once] :: f1_agdjV (f_agdjG (g_agdjH b_agdjX))
          [LclId] =
              [$dTraversable_sgh62
               $dTraversable1_sgh63
               $dApplicative_sgh64
               eta_sgh65
               eta1_sgh66] \u []
                  let {
                    sat_sgh68 [Occ=Once]
                      :: g_agdjH a_agdjW -> f1_agdjV (g_agdjH b_agdjX)
                    [LclId] =
                        [$dTraversable1_sgh63 $dApplicative_sgh64 eta_sgh65] \u []
                            Data.Traversable.traverse
                                $dTraversable1_sgh63 $dApplicative_sgh64 eta_sgh65;
                  } in 
                    Data.Traversable.traverse
                        $dTraversable_sgh62 $dApplicative_sgh64 sat_sgh68 eta1_sgh66;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sgh64 of sat_sgh67 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sgh67 Data.Functor.Compose.$fTraversableCompose1 sat_sgh69;
          };

Data.Functor.Compose.$fTraversableCompose_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh6a $dTraversable1_sgh6b]
        let {
          sat_sgh6d [Occ=Once,
                     Dmd=<L,U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_agdjH
          [LclId] =
              [$dTraversable1_sgh6b] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sgh6b; } in
        let {
          sat_sgh6c [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_agdjG
          [LclId] =
              [$dTraversable_sgh6a] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sgh6a;
        } in  Data.Functor.Compose.$fFoldableCompose sat_sgh6c sat_sgh6d;

Data.Functor.Compose.$fTraversableCompose_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh6e $dTraversable1_sgh6f]
        let {
          sat_sgh6h [Occ=Once, Dmd=<L,U(C(U),A)>] :: GHC.Base.Functor g_agdjH
          [LclId] =
              [$dTraversable1_sgh6f] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sgh6f; } in
        let {
          sat_sgh6g [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_agdjG
          [LclId] =
              [$dTraversable_sgh6e] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sgh6e;
        } in  Data.Functor.Compose.$fFunctorCompose sat_sgh6g sat_sgh6h;

Data.Functor.Compose.$fTraversableCompose_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     Data.Functor.Compose.Compose f g (f1 a)
     -> f1 (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(U)),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh6i
           $dTraversable1_sgh6j
           $dApplicative_sgh6k
           eta_B1]
        Data.Functor.Compose.$fTraversableCompose_$ctraverse
            $dTraversable_sgh6i
            $dTraversable1_sgh6j
            $dApplicative_sgh6k
            GHC.Base.id
            eta_B1;

Data.Functor.Compose.$fTraversableCompose_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh6l
           $dTraversable1_sgh6m
           $dMonad_sgh6n
           eta_sgh6o
           eta1_sgh6p]
        case GHC.Base.$p1Monad $dMonad_sgh6n of sat_sgh6q {
          __DEFAULT ->
              Data.Functor.Compose.$fTraversableCompose_$ctraverse
                  $dTraversable_sgh6l
                  $dTraversable1_sgh6m
                  sat_sgh6q
                  eta_sgh6o
                  eta1_sgh6p;
        };

Data.Functor.Compose.$fTraversableCompose_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Compose.Compose f g (m a)
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sgh6r
           $dTraversable1_sgh6s
           $dMonad_sgh6t
           eta_sgh6u]
        case GHC.Base.$p1Monad $dMonad_sgh6t of sat_sgh6v {
          __DEFAULT ->
              Data.Functor.Compose.$fTraversableCompose_$ctraverse
                  $dTraversable_sgh6r
                  $dTraversable1_sgh6s
                  sat_sgh6v
                  GHC.Base.id
                  eta_sgh6u;
        };

Data.Functor.Compose.$fTraversableCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(U),A),1*U(A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dTraversable_sgh6w $dTraversable1_sgh6x]
        let {
          sat_sgh6D [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               Data.Functor.Compose.Compose f_agdjG g_agdjH (m a)
               -> m (Data.Functor.Compose.Compose f_agdjG g_agdjH a)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$csequence
                      $dTraversable_sgh6w $dTraversable1_sgh6x eta_B2 eta_B1; } in
        let {
          sat_sgh6C [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> Data.Functor.Compose.Compose f_agdjG g_agdjH a
               -> m (Data.Functor.Compose.Compose f_agdjG g_agdjH b)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$cmapM
                      $dTraversable_sgh6w $dTraversable1_sgh6x eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh6B [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               Data.Functor.Compose.Compose f_agdjG g_agdjH (f a)
               -> f (Data.Functor.Compose.Compose f_agdjG g_agdjH a)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$csequenceA
                      $dTraversable_sgh6w $dTraversable1_sgh6x eta_B2 eta_B1; } in
        let {
          sat_sgh6A [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> Data.Functor.Compose.Compose f_agdjG g_agdjH a
               -> f (Data.Functor.Compose.Compose f_agdjG g_agdjH b)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fTraversableCompose_$ctraverse
                      $dTraversable_sgh6w $dTraversable1_sgh6x eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh6z [Occ=Once]
            :: Data.Foldable.Foldable
                 (Data.Functor.Compose.Compose f_agdjG g_agdjH)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \u []
                  Data.Functor.Compose.$fTraversableCompose_$cp2Traversable
                      $dTraversable_sgh6w $dTraversable1_sgh6x; } in
        let {
          sat_sgh6y [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Compose.Compose f_agdjG g_agdjH)
          [LclId] =
              [$dTraversable_sgh6w $dTraversable1_sgh6x] \u []
                  Data.Functor.Compose.$fTraversableCompose_$cp1Traversable
                      $dTraversable_sgh6w $dTraversable1_sgh6x;
        } in 
          Data.Traversable.C:Traversable [sat_sgh6y
                                          sat_sgh6z
                                          sat_sgh6A
                                          sat_sgh6B
                                          sat_sgh6C
                                          sat_sgh6D];

Data.Functor.Compose.$fApplicativeCompose4
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b c.
     (a -> b -> c)
     -> Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b
     -> f (g c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(U),A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh6E
           $dApplicative1_sgh6F
           f1_sgh6G
           ds_sgh6H
           ds1_sgh6I]
        let {
          sat_sgh6J [Occ=Once]
            :: g_agdie a_agdj0 -> g_agdie b_agdj1 -> g_agdie c_agdj2
          [LclId] =
              [$dApplicative1_sgh6F f1_sgh6G] \u []
                  GHC.Base.liftA2 $dApplicative1_sgh6F f1_sgh6G;
        } in 
          GHC.Base.liftA2 $dApplicative_sgh6E sat_sgh6J ds_sgh6H ds1_sgh6I;

Data.Functor.Compose.$fApplicativeCompose5
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g (a -> b)
     -> Data.Functor.Compose.Compose f g a -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,1*U,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh6K $dApplicative1_sgh6L ds_sgh6M ds1_sgh6N]
        let {
          sat_sgh6O [Occ=Once]
            :: g_Xgdlx (a_agdiF -> b_agdiG)
               -> g_Xgdlx a_agdiF -> g_Xgdlx b_agdiG
          [LclId] =
              [$dApplicative1_sgh6L] \u [] GHC.Base.<*> $dApplicative1_sgh6L;
        } in 
          GHC.Base.liftA2 $dApplicative_sgh6K sat_sgh6O ds_sgh6M ds1_sgh6N;

Data.Functor.Compose.$fApplicativeCompose6
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a. a -> f (g a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh6P $dApplicative1_sgh6Q x_sgh6R]
        let {
          sat_sgh6S [Occ=Once] :: g_XgdlH a_agdio
          [LclId] =
              [$dApplicative1_sgh6Q x_sgh6R] \u []
                  GHC.Base.pure $dApplicative1_sgh6Q x_sgh6R;
        } in  GHC.Base.pure $dApplicative_sgh6P sat_sgh6S;

Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Functor (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),A),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh6T $dApplicative1_sgh6U]
        let {
          sat_sgh6W [Occ=Once, Dmd=<L,U(C(U),A)>] :: GHC.Base.Functor g_XgdlP
          [LclId] =
              [$dApplicative1_sgh6U] \u []
                  GHC.Base.$p1Applicative $dApplicative1_sgh6U; } in
        let {
          sat_sgh6V [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_XgdlN
          [LclId] =
              [$dApplicative_sgh6T] \u []
                  GHC.Base.$p1Applicative $dApplicative_sgh6T;
        } in  Data.Functor.Compose.$fFunctorCompose sat_sgh6V sat_sgh6W;

Data.Functor.Compose.$fApplicativeCompose3
  :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgh6X eta_sgh6Y] eta_sgh6Y;

Data.Functor.Compose.$fApplicativeCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b -> f (g b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),U(1*U(1*C1(C1(U)),A),A,A,1*C1(C1(C1(U))),A,A)><L,U(1*U(1*C1(U),A),A,1*U,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh6Z
           $dApplicative1_sgh70
           eta_sgh71
           eta1_sgh72]
        let {
          sat_sgh77 [Occ=Once] :: f_XgdlX (g_XgdlZ (b_agdjo -> b_agdjo))
          [LclId] =
              [$dApplicative_sgh6Z $dApplicative1_sgh70 eta_sgh71] \u []
                  let {
                    sat_sgh76 [Occ=Once]
                      :: g_XgdlZ a_agdjn -> g_XgdlZ (b_agdjo -> b_agdjo)
                    [LclId] =
                        [$dApplicative1_sgh70] \u []
                            case GHC.Base.$p1Applicative $dApplicative1_sgh70 of sat_sgh75 {
                              __DEFAULT ->
                                  GHC.Base.fmap
                                      sat_sgh75 Data.Functor.Compose.$fApplicativeCompose3;
                            };
                  } in 
                    case GHC.Base.$p1Applicative $dApplicative_sgh6Z of sat_sgh74 {
                      __DEFAULT -> GHC.Base.fmap sat_sgh74 sat_sgh76 eta_sgh71;
                    }; } in
        let {
          sat_sgh73 [Occ=Once]
            :: g_XgdlZ (b_agdjo -> b_agdjo)
               -> g_XgdlZ b_agdjo -> g_XgdlZ b_agdjo
          [LclId] =
              [$dApplicative1_sgh70] \u [] GHC.Base.<*> $dApplicative1_sgh70;
        } in 
          GHC.Base.liftA2 $dApplicative_sgh6Z sat_sgh73 sat_sgh77 eta1_sgh72;

Data.Functor.Compose.$fApplicativeCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     forall a b.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,1*U(A,A,A,1*C1(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgh78 $dApplicative1_sgh79 ds_sgh7a ds1_sgh7b]
        let {
          sat_sgh7c [Occ=Once]
            :: g_XgdlR a_agdjx -> g_XgdlR b_agdjy -> g_XgdlR a_agdjx
          [LclId] =
              [$dApplicative1_sgh79] \u []
                  GHC.Base.liftA2 $dApplicative1_sgh79 GHC.Base.const;
        } in 
          GHC.Base.liftA2 $dApplicative_sgh78 sat_sgh7c ds_sgh7a ds1_sgh7b;

Data.Functor.Compose.$fApplicativeCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Applicative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m] =
    [] \r [$dApplicative_sgh7d $dApplicative1_sgh7e]
        let {
          sat_sgh7k [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose1
                      $dApplicative_sgh7d $dApplicative1_sgh7e eta_B2 eta_B1; } in
        let {
          sat_sgh7j [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose2
                      $dApplicative_sgh7d $dApplicative1_sgh7e eta_B2 eta_B1; } in
        let {
          sat_sgh7i [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ c
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose4
                      $dApplicative_sgh7d $dApplicative1_sgh7e eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgh7h [Occ=Once]
            :: forall a b.
               Data.Functor.Compose.Compose f_XgdlO g_XgdlQ (a -> b)
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
               -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ b
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \r [eta_B2 eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose5
                      $dApplicative_sgh7d $dApplicative1_sgh7e eta_B2 eta_B1; } in
        let {
          sat_sgh7g [Occ=Once]
            :: forall a. a -> Data.Functor.Compose.Compose f_XgdlO g_XgdlQ a
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \r [eta_B1]
                  Data.Functor.Compose.$fApplicativeCompose6
                      $dApplicative_sgh7d $dApplicative1_sgh7e eta_B1; } in
        let {
          sat_sgh7f [Occ=Once]
            :: GHC.Base.Functor (Data.Functor.Compose.Compose f_XgdlO g_XgdlQ)
          [LclId] =
              [$dApplicative_sgh7d $dApplicative1_sgh7e] \u []
                  Data.Functor.Compose.$fApplicativeCompose_$cp1Applicative
                      $dApplicative_sgh7d $dApplicative1_sgh7e;
        } in 
          GHC.Base.C:Applicative [sat_sgh7f
                                  sat_sgh7g
                                  sat_sgh7h
                                  sat_sgh7i
                                  sat_sgh7j
                                  sat_sgh7k];

Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgh7l $dApplicative_sgh7m]
        let {
          sat_sgh7n [Occ=Once,
                     Dmd=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative f_XgdkR
          [LclId] =
              [$dAlternative_sgh7l] \u []
                  GHC.Base.$p1Alternative $dAlternative_sgh7l;
        } in 
          Data.Functor.Compose.$fApplicativeCompose
              sat_sgh7n $dApplicative_sgh7m;

Data.Functor.Compose.$fAlternativeCompose_$csome
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     forall a.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U(A,C(U),A,C(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgh7o $dApplicative_sgh7p eta_sgh7q]
        let {
          some_v_sgh7r [Occ=LoopBreaker] :: f_XgdkU (g_XgdkW [a_agdhY])
          [LclId] =
              [$dAlternative_sgh7o
               $dApplicative_sgh7p
               eta_sgh7q
               some_v_sgh7r] \u []
                  case
                      GHC.Base.$p1Alternative $dAlternative_sgh7o
                  of
                  $dApplicative1_sgh7s [Dmd=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                  { __DEFAULT ->
                        let {
                          sat_sgh7w [Occ=Once] :: f_XgdkU (g_XgdkW [a_agdhY])
                          [LclId] =
                              [$dAlternative_sgh7o
                               $dApplicative_sgh7p
                               some_v_sgh7r
                               $dApplicative1_sgh7s] \u []
                                  let {
                                    sat_sgh7v [Occ=Once] :: f_XgdkU (g_XgdkW [a_agdhY])
                                    [LclId] =
                                        [$dApplicative_sgh7p $dApplicative1_sgh7s] \u []
                                            let {
                                              sat_sgh7u [Occ=Once] :: g_XgdkW [a_agdhY]
                                              [LclId] =
                                                  [$dApplicative_sgh7p] \u []
                                                      GHC.Base.pure
                                                          $dApplicative_sgh7p GHC.Types.[];
                                            } in  GHC.Base.pure $dApplicative1_sgh7s sat_sgh7u;
                                  } in 
                                    GHC.Base.<|> $dAlternative_sgh7o some_v_sgh7r sat_sgh7v; } in
                        let {
                          sat_sgh7t [Occ=Once]
                            :: g_XgdkW a_agdhY -> g_XgdkW [a_agdhY] -> g_XgdkW [a_agdhY]
                          [LclId] =
                              [$dApplicative_sgh7p] \u []
                                  GHC.Base.liftA2 $dApplicative_sgh7p GHC.Types.:;
                        } in 
                          GHC.Base.liftA2 $dApplicative1_sgh7s sat_sgh7t eta_sgh7q sat_sgh7w;
                  };
        } in  some_v_sgh7r;

Data.Functor.Compose.$fAlternativeCompose_$cmany
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     forall a.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U(A,C(U),A,C(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sgh7x $dApplicative_sgh7y eta_sgh7z]
        let {
          many_v_sgh7A [Occ=LoopBreaker] :: f_XgdkT (g_XgdkV [a_agdi6])
          [LclId] =
              [$dAlternative_sgh7x
               $dApplicative_sgh7y
               eta_sgh7z
               many_v_sgh7A] \u []
                  let {
                    $dApplicative1_sgh7B [Dmd=<L,U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                      :: GHC.Base.Applicative f_XgdkT
                    [LclId] =
                        [$dAlternative_sgh7x] \u []
                            GHC.Base.$p1Alternative $dAlternative_sgh7x; } in
                  let {
                    sat_sgh7F [Occ=Once] :: f_XgdkT (g_XgdkV [a_agdi6])
                    [LclId] =
                        [$dApplicative_sgh7y $dApplicative1_sgh7B] \u []
                            let {
                              sat_sgh7E [Occ=Once] :: g_XgdkV [a_agdi6]
                              [LclId] =
                                  [$dApplicative_sgh7y] \u []
                                      GHC.Base.pure $dApplicative_sgh7y GHC.Types.[];
                            } in  GHC.Base.pure $dApplicative1_sgh7B sat_sgh7E; } in
                  let {
                    sat_sgh7D [Occ=Once] :: f_XgdkT (g_XgdkV [a_agdi6])
                    [LclId] =
                        [$dApplicative_sgh7y
                         eta_sgh7z
                         many_v_sgh7A
                         $dApplicative1_sgh7B] \u []
                            let {
                              sat_sgh7C [Occ=Once]
                                :: g_XgdkV a_agdi6 -> g_XgdkV [a_agdi6] -> g_XgdkV [a_agdi6]
                              [LclId] =
                                  [$dApplicative_sgh7y] \u []
                                      GHC.Base.liftA2 $dApplicative_sgh7y GHC.Types.:;
                            } in 
                              GHC.Base.liftA2
                                  $dApplicative1_sgh7B sat_sgh7C eta_sgh7z many_v_sgh7A;
                  } in  GHC.Base.<|> $dAlternative_sgh7x sat_sgh7D sat_sgh7F;
        } in  many_v_sgh7A;

Data.Functor.Compose.$fAlternativeCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Alternative f, GHC.Base.Applicative g) =>
     GHC.Base.Alternative (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A),1*U,U,A,A)><L,U(U(C(U),A),C(U),U,C(U),A,A)>m] =
    [] \r [$dAlternative_sgh7G $dApplicative_sgh7H]
        let {
          sat_sgh7M [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU [a]
          [LclId] =
              [$dAlternative_sgh7G $dApplicative_sgh7H] \r [eta_B1]
                  Data.Functor.Compose.$fAlternativeCompose_$cmany
                      $dAlternative_sgh7G $dApplicative_sgh7H eta_B1; } in
        let {
          sat_sgh7L [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU [a]
          [LclId] =
              [$dAlternative_sgh7G $dApplicative_sgh7H] \r [eta_B1]
                  Data.Functor.Compose.$fAlternativeCompose_$csome
                      $dAlternative_sgh7G $dApplicative_sgh7H eta_B1; } in
        let {
          sat_sgh7K [Occ=Once]
            :: forall a.
               Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
               -> Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
          [LclId] =
              [$dAlternative_sgh7G] \u [] GHC.Base.<|> $dAlternative_sgh7G; } in
        let {
          sat_sgh7J [Occ=Once]
            :: forall a. Data.Functor.Compose.Compose f_XgdkS g_XgdkU a
          [LclId] =
              [$dAlternative_sgh7G] \u []
                  GHC.Base.empty $dAlternative_sgh7G; } in
        let {
          sat_sgh7I [Occ=Once]
            :: GHC.Base.Applicative
                 (Data.Functor.Compose.Compose f_XgdkS g_XgdkU)
          [LclId] =
              [$dAlternative_sgh7G $dApplicative_sgh7H] \u []
                  Data.Functor.Compose.$fAlternativeCompose_$cp1Alternative
                      $dAlternative_sgh7G $dApplicative_sgh7H;
        } in 
          GHC.Base.C:Alternative [sat_sgh7I
                                  sat_sgh7J
                                  sat_sgh7K
                                  sat_sgh7L
                                  sat_sgh7M];

Data.Functor.Compose.$fGeneric1Compose1
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     forall (a :: k).
     GHC.Generics.Rep1 (Data.Functor.Compose.Compose f g) a -> f (g a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgh7N ds_sgh7O]
        GHC.Base.fmap $dFunctor_sgh7N GHC.Generics.$fGeneric1:.:2 ds_sgh7O;

Data.Functor.Compose.$fGeneric1Compose3
  :: forall k (g :: k -> *) (a :: k). g a -> g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgh7P] v_sgh7P;

Data.Functor.Compose.$fGeneric1Compose2
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     forall (a :: k).
     Data.Functor.Compose.Compose f g a -> f (GHC.Generics.Rec1 g a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgh7Q x_sgh7R]
        GHC.Base.fmap
            $dFunctor_sgh7Q Data.Functor.Compose.$fGeneric1Compose3 x_sgh7R;

Data.Functor.Compose.$fGeneric1Compose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) k (g :: k -> *).
     GHC.Base.Functor f =>
     GHC.Generics.Generic1 (Data.Functor.Compose.Compose f g)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dFunctor_sgh7S]
        let {
          sat_sgh7U [Occ=Once]
            :: forall (a :: k).
               GHC.Generics.Rep1 (Data.Functor.Compose.Compose f_XgdjE g_XgdjI) a
               -> Data.Functor.Compose.Compose f_XgdjE g_XgdjI a
          [LclId] =
              [$dFunctor_sgh7S] \r [eta_B1]
                  Data.Functor.Compose.$fGeneric1Compose1
                      $dFunctor_sgh7S eta_B1; } in
        let {
          sat_sgh7T [Occ=Once]
            :: forall (a :: k).
               Data.Functor.Compose.Compose f_XgdjE g_XgdjI a
               -> GHC.Generics.Rep1
                    (Data.Functor.Compose.Compose f_XgdjE g_XgdjI) a
          [LclId] =
              [$dFunctor_sgh7S] \r [eta_B1]
                  Data.Functor.Compose.$fGeneric1Compose2 $dFunctor_sgh7S eta_B1;
        } in  GHC.Generics.C:Generic1 [sat_sgh7T sat_sgh7U];

Data.Functor.Compose.$fGenericCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) x.
     GHC.Generics.Rep (Data.Functor.Compose.Compose f g a) x
     -> GHC.Generics.Rep (Data.Functor.Compose.Compose f g a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgh7V] ds_sgh7V;

Data.Functor.Compose.$fGenericCompose2
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) x.
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sgh7W] x1_sgh7W;

Data.Functor.Compose.$fGenericCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     GHC.Generics.Generic (Data.Functor.Compose.Compose f g a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Functor.Compose.$fGenericCompose2
                                           Data.Functor.Compose.$fGenericCompose1];

Data.Functor.Compose.getCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a
     -> Data.Functor.Compose.Compose f g a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgh7X] ds_sgh7X;

Data.Functor.Compose.getCompose
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> f (g a)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Compose.getCompose1 eta_B1;

$cCompose1_rgdPU :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getCompose"#;

$cCompose2_rgdPV :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $cCompose1_rgdPU;

$cCompose3_rgdPW :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$cCompose2_rgdPV GHC.Types.[]];

go61_rgdPX
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgh7Y _ys_sgh7Z]
        case ds2_sgh7Y of {
          [] -> GHC.List.badHead;
          : ipv_sgh81 [Occ=Once!] ipv1_sgh82 [Occ=Once] ->
              case _ys_sgh7Z of {
                [] -> GHC.List.badHead;
                : ipv2_sgh84 [Occ=Once] ipv3_sgh85 [Occ=Once] ->
                    case ipv_sgh81 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgh88 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sgh88 Data.Functor.Compose.$fDataCompose6
                          of
                          { GHC.Types.False -> go61_rgdPX ipv1_sgh82 ipv3_sgh85;
                            GHC.Types.True -> ipv2_sgh84;
                          };
                    };
              };
        };

$cCompose4_rgdPY :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cCompose5_rgdPZ];
Data.Functor.Compose.$fDataCompose5 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Functor.Compose.$cCompose GHC.Types.[]];
Data.Functor.Compose.$fDataCompose4 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Functor.Compose.$fDataCompose5];
Data.Functor.Compose.$tCompose :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Functor.Compose.$fDataCompose6
                                       Data.Functor.Compose.$fDataCompose4];
Data.Functor.Compose.$cCompose [Occ=LoopBreaker]
  :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cCompose4_rgdPY
                                     Data.Functor.Compose.$fDataCompose6
                                     $cCompose3_rgdPW
                                     Data.Data.Prefix
                                     Data.Functor.Compose.$tCompose];
$cCompose5_rgdPZ :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rgdPX Data.Functor.Compose.$fDataCompose5 Data.Data.mkConstr1;

Data.Functor.Compose.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Compose.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$trModule4];

Data.Functor.Compose.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Compose"#;

Data.Functor.Compose.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$trModule2];

Data.Functor.Compose.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Compose.$trModule3
                                     Data.Functor.Compose.$trModule1];

$krep_rgdQ0 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_rgdQ1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgdQ0 GHC.Types.krep$*];

$krep2_rgdQ2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep3_rgdQ3 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_rgdQ2
                                         GHC.Types.krep$*];

$krep4_rgdQ4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgdQ0 $krep2_rgdQ2];

$krep5_rgdQ5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_rgdQ4 $krep1_rgdQ1];

Data.Functor.Compose.$fDataCompose9 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rgdQ3 $krep5_rgdQ5];

$krep6_rgdQ6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [3#];

$krep7_rgdQ7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep8_rgdQ8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [4#];

$krep9_rgdQ9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep6_rgdQ6 $krep8_rgdQ8];

$krep10_rgdQa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep7_rgdQ7 $krep9_rgdQ9];

Data.Functor.Compose.$fDataCompose10 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$fDataCompose7];

Data.Functor.Compose.$tcCompose :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6729400645769595507##
                                    7487202375031942550##
                                    Data.Functor.Compose.$trModule
                                    Data.Functor.Compose.$fDataCompose10
                                    2#
                                    Data.Functor.Compose.$fDataCompose9];

$krep11_rgdQb :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep8_rgdQ8 GHC.Types.[]];

$krep12_rgdQc :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_rgdQ6 $krep11_rgdQb];

$krep13_rgdQd :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep7_rgdQ7 $krep12_rgdQc];

$krep14_rgdQe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgdQ0 $krep13_rgdQd];

$krep15_rgdQf :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgdQ2 $krep14_rgdQe];

$krep16_rgdQg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Compose.$tcCompose
                                              $krep15_rgdQf];

Data.Functor.Compose.$tc'Compose1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_rgdQa $krep16_rgdQg];

Data.Functor.Compose.$tc'Compose3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Compose"#;

Data.Functor.Compose.$tc'Compose2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Compose.$tc'Compose3];

Data.Functor.Compose.$tc'Compose :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7236514282653524344##
                                    13791541438620948974##
                                    Data.Functor.Compose.$trModule
                                    Data.Functor.Compose.$tc'Compose2
                                    5#
                                    Data.Functor.Compose.$tc'Compose1];

Data.Functor.Compose.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Compose.Compose f g a)
[GblId, Arity=5, Str=<S,U><S,U><S,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sgh8d w1_sgh8e w2_sgh8f w3_sgh8g w4_sgh8h]
        let {
          sat_sgh8j [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w4_sgh8h]; } in
        let {
          sat_sgh8k [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sgh8j GHC.Types.[]]; } in
        let {
          sat_sgh8i [Occ=Once] :: Data.Typeable.Internal.SomeTypeRep
          [LclId] =
              CCCS Data.Typeable.Internal.SomeTypeRep! [w3_sgh8g]; } in
        let {
          sat_sgh8l [Occ=Once] :: [Data.Typeable.Internal.SomeTypeRep]
          [LclId] =
              CCCS :! [sat_sgh8i sat_sgh8k];
        } in 
          case
              Data.Typeable.Internal.$wmkTrCon
                  6729400645769595507##
                  7487202375031942550##
                  Data.Functor.Compose.$trModule
                  Data.Functor.Compose.$fDataCompose10
                  2#
                  Data.Functor.Compose.$fDataCompose9
                  sat_sgh8l
          of
          { (#,,,,#) ww8_sgh8n [Occ=Once]
                     ww9_sgh8o [Occ=Once]
                     ww10_sgh8p [Occ=Once]
                     ww11_sgh8q [Occ=Once]
                     ww12_sgh8r [Occ=Once] ->
                let {
                  sat_sgh8s [Occ=Once]
                    :: Data.Typeable.Internal.TypeRep Data.Functor.Compose.Compose
                  [LclId] =
                      CCCS Data.Typeable.Internal.TrTyCon! [ww8_sgh8n
                                                            ww9_sgh8o
                                                            ww10_sgh8p
                                                            ww11_sgh8q
                                                            ww12_sgh8r];
                } in 
                  case
                      Data.Typeable.Internal.mkTrApp sat_sgh8s w1_sgh8e
                  of
                  sat_sgh8t
                  { __DEFAULT ->
                        case
                            Data.Typeable.Internal.mkTrApp sat_sgh8t w2_sgh8f
                        of
                        sat_sgh8u
                        { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sgh8u w_sgh8d;
                        };
                  };
          };

Data.Functor.Compose.$fDataCompose8 [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     Data.Typeable.Internal.TypeRep (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=6,
 Str=<S,U><S,U><S,U><L,U><L,U><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sgh8v w1_sgh8w w2_sgh8x w3_sgh8y w4_sgh8z w5_sgh8A]
        Data.Functor.Compose.$w$cp1Data
            w_sgh8v w1_sgh8w w2_sgh8x w3_sgh8y w4_sgh8z;

Data.Functor.Compose.$fDataCompose2
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     f (g a) -> f (g a)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgh8B] v_sgh8B;

Data.Functor.Compose.$fDataCompose1
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (f (g a) -> Data.Functor.Compose.Compose f g a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Functor.Compose.$fDataCompose2
                        GHC.Types.False];

Data.Functor.Compose.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh8C w1_sgh8D w2_sgh8E w3_sgh8F]
        let {
          lvl8_sgh8G [Occ=OnceL]
            :: m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9)
          [LclId] =
              [w1_sgh8D] \u [] GHC.Base.mzero w1_sgh8D;
        } in 
          case
              GHC.Base.$p2MonadPlus w1_sgh8D
          of
          $dMonad_sgh8H [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgh93 [Occ=Once]
                    :: (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                        GHC.Types.Bool)
                       -> m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9)
                  [LclId] =
                      [lvl8_sgh8G $dMonad_sgh8H] \r [ds_sgh8Y]
                          case ds_sgh8Y of {
                            (,) x'_sgh90 [Occ=Once] b_sgh91 [Occ=Once!] ->
                                case b_sgh91 of {
                                  GHC.Types.False -> lvl8_sgh8G;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgh8H x'_sgh90;
                                };
                          }; } in
                let {
                  sat_sgh8X [Occ=Once]
                    :: m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sgh8C w1_sgh8D w2_sgh8E w3_sgh8F $dMonad_sgh8H] \u []
                          let {
                            lvl9_sgh8I [Occ=OnceL] :: m_sgdKg (f_sgdK6 (g_sgdK8 a_sgdK9))
                            [LclId] =
                                [w_sgh8C w2_sgh8E w3_sgh8F] \u [] w2_sgh8E w_sgh8C w3_sgh8F; } in
                          let {
                            sat_sgh8W [Occ=Once]
                              :: (f_sgdK6 (g_sgdK8 a_sgdK9)
                                  -> Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                  GHC.Types.Bool)
                                 -> m_sgdKg (Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                             GHC.Types.Bool)
                            [LclId] =
                                [w1_sgh8D w3_sgh8F $dMonad_sgh8H lvl9_sgh8I] \r [ds1_sgh8K]
                                    case ds1_sgh8K of {
                                      (,) h_sgh8M b1_sgh8N [Occ=Once] ->
                                          let {
                                            sat_sgh8V [Occ=Once]
                                              :: m_sgdKg (Data.Functor.Compose.Compose
                                                            f_sgdK6 g_sgdK8 a_sgdK9,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [w3_sgh8F $dMonad_sgh8H h_sgh8M b1_sgh8N] \u []
                                                    let {
                                                      sat_sgh8T [Occ=Once]
                                                        :: Data.Functor.Compose.Compose
                                                             f_sgdK6 g_sgdK8 a_sgdK9
                                                      [LclId] =
                                                          [w3_sgh8F h_sgh8M] \u []
                                                              h_sgh8M w3_sgh8F; } in
                                                    let {
                                                      sat_sgh8U [Occ=Once]
                                                        :: (Data.Functor.Compose.Compose
                                                              f_sgdK6 g_sgdK8 a_sgdK9,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sgh8T b1_sgh8N];
                                                    } in 
                                                      GHC.Base.return $dMonad_sgh8H sat_sgh8U; } in
                                          let {
                                            sat_sgh8S [Occ=Once]
                                              :: m_sgdKg (Data.Functor.Compose.Compose
                                                            f_sgdK6 g_sgdK8 a_sgdK9,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sgh8H lvl9_sgh8I h_sgh8M] \u []
                                                    let {
                                                      sat_sgh8R [Occ=Once]
                                                        :: f_sgdK6 (g_sgdK8 a_sgdK9)
                                                           -> m_sgdKg (Data.Functor.Compose.Compose
                                                                         f_sgdK6 g_sgdK8 a_sgdK9,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sgh8H h_sgh8M] \r [y'_sgh8O]
                                                              let {
                                                                sat_sgh8P [Occ=Once]
                                                                  :: Data.Functor.Compose.Compose
                                                                       f_sgdK6 g_sgdK8 a_sgdK9
                                                                [LclId] =
                                                                    [h_sgh8M y'_sgh8O] \u []
                                                                        h_sgh8M y'_sgh8O; } in
                                                              let {
                                                                sat_sgh8Q [Occ=Once]
                                                                  :: (Data.Functor.Compose.Compose
                                                                        f_sgdK6 g_sgdK8 a_sgdK9,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sgh8P
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sgh8H sat_sgh8Q;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sgh8H lvl9_sgh8I sat_sgh8R;
                                          } in  GHC.Base.mplus w1_sgh8D sat_sgh8S sat_sgh8V;
                                    }; } in
                          let {
                            sat_sgh8J [Occ=Once]
                              :: m_sgdKg (f_sgdK6 (g_sgdK8 a_sgdK9)
                                          -> Data.Functor.Compose.Compose f_sgdK6 g_sgdK8 a_sgdK9,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgh8H] \u []
                                    GHC.Base.return
                                        $dMonad_sgh8H Data.Functor.Compose.$fDataCompose1;
                          } in  GHC.Base.>>= $dMonad_sgh8H sat_sgh8J sat_sgh8W;
                } in  GHC.Base.>>= $dMonad_sgh8H sat_sgh8X sat_sgh93;
          };

Data.Functor.Compose.$fDataCompose_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh94
           w1_sgh95
           w2_sgh96
           w3_sgh97
           w4_sgh98
           w5_sgh99
           w6_sgh9a
           w7_sgh9b
           w8_sgh9c]
        Data.Functor.Compose.$w$cgmapMp
            w5_sgh99 w6_sgh9a w7_sgh9b w8_sgh9c;

Data.Functor.Compose.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh9d w1_sgh9e w2_sgh9f w3_sgh9g]
        let {
          lvl8_sgh9h [Occ=OnceL] :: m_sgdKw (f_sgdKm (g_sgdKo a_sgdKp))
          [LclId] =
              [w_sgh9d w2_sgh9f w3_sgh9g] \u [] w2_sgh9f w_sgh9d w3_sgh9g; } in
        let {
          sat_sgh9n [Occ=Once]
            :: (f_sgdKm (g_sgdKo a_sgdKp)
                -> Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
               -> m_sgdKw (Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
          [LclId] =
              [w1_sgh9e lvl8_sgh9h] \r [c'_sgh9j]
                  let {
                    sat_sgh9m [Occ=Once]
                      :: f_sgdKm (g_sgdKo a_sgdKp)
                         -> m_sgdKw (Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
                    [LclId] =
                        [w1_sgh9e c'_sgh9j] \r [x'_sgh9k]
                            let {
                              sat_sgh9l [Occ=Once]
                                :: Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp
                              [LclId] =
                                  [c'_sgh9j x'_sgh9k] \u [] c'_sgh9j x'_sgh9k;
                            } in  GHC.Base.return w1_sgh9e sat_sgh9l;
                  } in  GHC.Base.>>= w1_sgh9e lvl8_sgh9h sat_sgh9m; } in
        let {
          sat_sgh9i [Occ=Once]
            :: m_sgdKw (f_sgdKm (g_sgdKo a_sgdKp)
                        -> Data.Functor.Compose.Compose f_sgdKm g_sgdKo a_sgdKp)
          [LclId] =
              [w1_sgh9e] \u []
                  GHC.Base.return w1_sgh9e Data.Functor.Compose.$fDataCompose2;
        } in  GHC.Base.>>= w1_sgh9e sat_sgh9i sat_sgh9n;

Data.Functor.Compose.$fDataCompose_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh9o
           w1_sgh9p
           w2_sgh9q
           w3_sgh9r
           w4_sgh9s
           w5_sgh9t
           w6_sgh9u
           w7_sgh9v
           w8_sgh9w]
        Data.Functor.Compose.$w$cgmapM w5_sgh9t w6_sgh9u w7_sgh9v w8_sgh9w;

Data.Functor.Compose.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Data.Data (f (g a)) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgh9x w1_sgh9y w2_sgh9z w3_sgh9A]
        let {
          lvl8_sgh9B [Occ=OnceL]
            :: m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF)
          [LclId] =
              [w1_sgh9y] \u [] GHC.Base.mzero w1_sgh9y;
        } in 
          case
              GHC.Base.$p2MonadPlus w1_sgh9y
          of
          $dMonad_sgh9C [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgha1 [Occ=Once]
                    :: (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                        GHC.Types.Bool)
                       -> m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF)
                  [LclId] =
                      [lvl8_sgh9B $dMonad_sgh9C] \r [ds_sgh9W]
                          case ds_sgh9W of {
                            (,) x'_sgh9Y [Occ=Once] b_sgh9Z [Occ=Once!] ->
                                case b_sgh9Z of {
                                  GHC.Types.False -> lvl8_sgh9B;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgh9C x'_sgh9Y;
                                };
                          }; } in
                let {
                  sat_sgh9V [Occ=Once]
                    :: m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                GHC.Types.Bool)
                  [LclId] =
                      [w_sgh9x w1_sgh9y w2_sgh9z w3_sgh9A $dMonad_sgh9C] \u []
                          let {
                            lvl9_sgh9D [Occ=OnceL] :: m_sgdKM (f_sgdKC (g_sgdKE a_sgdKF))
                            [LclId] =
                                [w_sgh9x w2_sgh9z w3_sgh9A] \u [] w2_sgh9z w_sgh9x w3_sgh9A; } in
                          let {
                            sat_sgh9U [Occ=Once]
                              :: (f_sgdKC (g_sgdKE a_sgdKF)
                                  -> Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                  GHC.Types.Bool)
                                 -> m_sgdKM (Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                             GHC.Types.Bool)
                            [LclId] =
                                [w1_sgh9y w3_sgh9A $dMonad_sgh9C lvl9_sgh9D] \r [ds1_sgh9F]
                                    case ds1_sgh9F of {
                                      (,) h_sgh9H b1_sgh9I [Occ=Once!] ->
                                          case b1_sgh9I of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sgh9R [Occ=Once]
                                                    :: m_sgdKM (Data.Functor.Compose.Compose
                                                                  f_sgdKC g_sgdKE a_sgdKF,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [w3_sgh9A $dMonad_sgh9C h_sgh9H] \u []
                                                          let {
                                                            sat_sgh9P [Occ=Once]
                                                              :: Data.Functor.Compose.Compose
                                                                   f_sgdKC g_sgdKE a_sgdKF
                                                            [LclId] =
                                                                [w3_sgh9A h_sgh9H] \u []
                                                                    h_sgh9H w3_sgh9A; } in
                                                          let {
                                                            sat_sgh9Q [Occ=Once]
                                                              :: (Data.Functor.Compose.Compose
                                                                    f_sgdKC g_sgdKE a_sgdKF,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sgh9P
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sgh9C sat_sgh9Q; } in
                                                let {
                                                  sat_sgh9O [Occ=Once]
                                                    :: m_sgdKM (Data.Functor.Compose.Compose
                                                                  f_sgdKC g_sgdKE a_sgdKF,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sgh9C lvl9_sgh9D h_sgh9H] \u []
                                                          let {
                                                            sat_sgh9N [Occ=Once]
                                                              :: f_sgdKC (g_sgdKE a_sgdKF)
                                                                 -> m_sgdKM (Data.Functor.Compose.Compose
                                                                               f_sgdKC
                                                                               g_sgdKE
                                                                               a_sgdKF,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgh9C
                                                                 h_sgh9H] \r [y'_sgh9K]
                                                                    let {
                                                                      sat_sgh9L [Occ=Once]
                                                                        :: Data.Functor.Compose.Compose
                                                                             f_sgdKC g_sgdKE a_sgdKF
                                                                      [LclId] =
                                                                          [h_sgh9H y'_sgh9K] \u []
                                                                              h_sgh9H y'_sgh9K; } in
                                                                    let {
                                                                      sat_sgh9M [Occ=Once]
                                                                        :: (Data.Functor.Compose.Compose
                                                                              f_sgdKC
                                                                              g_sgdKE
                                                                              a_sgdKF,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgh9L
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgh9C sat_sgh9M;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sgh9C lvl9_sgh9D sat_sgh9N;
                                                } in  GHC.Base.mplus w1_sgh9y sat_sgh9O sat_sgh9R;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sgh9S [Occ=Once]
                                                    :: Data.Functor.Compose.Compose
                                                         f_sgdKC g_sgdKE a_sgdKF
                                                  [LclId] =
                                                      [w3_sgh9A h_sgh9H] \u []
                                                          h_sgh9H w3_sgh9A; } in
                                                let {
                                                  sat_sgh9T [Occ=Once]
                                                    :: (Data.Functor.Compose.Compose
                                                          f_sgdKC g_sgdKE a_sgdKF,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sgh9S GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sgh9C sat_sgh9T;
                                          };
                                    }; } in
                          let {
                            sat_sgh9E [Occ=Once]
                              :: m_sgdKM (f_sgdKC (g_sgdKE a_sgdKF)
                                          -> Data.Functor.Compose.Compose f_sgdKC g_sgdKE a_sgdKF,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgh9C] \u []
                                    GHC.Base.return
                                        $dMonad_sgh9C Data.Functor.Compose.$fDataCompose1;
                          } in  GHC.Base.>>= $dMonad_sgh9C sat_sgh9E sat_sgh9U;
                } in  GHC.Base.>>= $dMonad_sgh9C sat_sgh9V sat_sgha1;
          };

Data.Functor.Compose.$fDataCompose_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Functor.Compose.Compose f g a
     -> m (Data.Functor.Compose.Compose f g a)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgha2
           w1_sgha3
           w2_sgha4
           w3_sgha5
           w4_sgha6
           w5_sgha7
           w6_sgha8
           w7_sgha9
           w8_sghaa]
        Data.Functor.Compose.$w$cgmapMo
            w5_sgha7 w6_sgha8 w7_sgha9 w8_sghaa;

lvl4_rgdQh
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sghab] Data.Functor.Compose.$cCompose;

lvl5_rgdQi
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     Data.Functor.Compose.Compose f g a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sghac] Data.Functor.Compose.$tCompose;

lvl6_rgdQj
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) (t :: *
                                                                 -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Functor.Compose.Compose f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sghad ds_sghae] GHC.Base.Nothing [];

lvl7_rgdQk
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2) (t :: *
                                                                 -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Functor.Compose.Compose f g a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sghaf ds_sghag] GHC.Base.Nothing [];

Data.Functor.Compose.$fDataCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2).
     (Data.Typeable.Internal.Typeable a,
      Data.Typeable.Internal.Typeable f,
      Data.Typeable.Internal.Typeable g,
      Data.Typeable.Internal.Typeable k1,
      Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) =>
     Data.Data.Data (Data.Functor.Compose.Compose f g a)
[GblId[DFunId], Arity=6, Str=<L,U><L,U><L,U><L,U><L,U><L,U>] =
    [] \r [$dTypeable_sghah
           $dTypeable1_sghai
           $dTypeable2_sghaj
           $dTypeable3_sghak
           $dTypeable4_sghal
           $dData_sgham]
        let {
          sat_sghb9 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sgham] \r [w_sghb6 w1_sghb7 w2_sghb8]
                  Data.Functor.Compose.$w$cgmapMo
                      $dData_sgham w_sghb6 w1_sghb7 w2_sghb8; } in
        let {
          sat_sghb5 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sgham] \r [w_sghb2 w1_sghb3 w2_sghb4]
                  Data.Functor.Compose.$w$cgmapMp
                      $dData_sgham w_sghb2 w1_sghb3 w2_sghb4; } in
        let {
          sat_sghb1 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> m (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sgham] \r [w_sghaY w1_sghaZ w2_sghb0]
                  Data.Functor.Compose.$w$cgmapM
                      $dData_sgham w_sghaY w1_sghaZ w2_sghb0; } in
        let {
          sat_sghaX [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> u
          [LclId] =
              [$dData_sgham] \r [ds_sghaR ds1_sghaS x_sghaT]
                  case ds_sghaR of {
                    GHC.Types.I# x1_sghaV [Occ=Once!] ->
                        case x1_sghaV of {
                          __DEFAULT -> Data.Maybe.fromJust1;
                          0# -> ds1_sghaS $dData_sgham x_sghaT;
                        };
                  }; } in
        let {
          sat_sghaQ [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs -> [u]
          [LclId] =
              [$dData_sgham] \r [ds_sghaN x0_sghaO]
                  let {
                    sat_sghaP [Occ=Once] :: u_agdd2
                    [LclId] =
                        [$dData_sgham ds_sghaN x0_sghaO] \u []
                            ds_sghaN $dData_sgham x0_sghaO;
                  } in  : [sat_sghaP GHC.Types.[]]; } in
        let {
          sat_sghaM [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> r
          [LclId] =
              [$dData_sgham] \r [ds_sghaH ds1_sghaI ds2_sghaJ x0_sghaK]
                  let {
                    sat_sghaL [Occ=Once] :: r'_agdcM
                    [LclId] =
                        [$dData_sgham ds2_sghaJ x0_sghaK] \u []
                            ds2_sghaJ $dData_sgham x0_sghaK;
                  } in  ds_sghaH sat_sghaL ds1_sghaI; } in
        let {
          sat_sghaG [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> r
          [LclId] =
              [$dData_sgham] \r [ds_sghaB ds1_sghaC ds2_sghaD eta_sghaE]
                  let {
                    sat_sghaF [Occ=Once] :: r'_agdcv
                    [LclId] =
                        [$dData_sgham ds2_sghaD eta_sghaE] \u []
                            ds2_sghaD $dData_sgham eta_sghaE;
                  } in  ds_sghaB ds1_sghaC sat_sghaF; } in
        let {
          sat_sghaA [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
          [LclId] =
              [$dData_sgham] \r [ds_sghay x0_sghaz]
                  ds_sghay $dData_sgham x0_sghaz; } in
        let {
          sat_sghax [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sgham] \r [k2_sghat z_sghau ds_sghav]
                  let {
                    sat_sghaw [Occ=Once]
                      :: c_agdbg (f_Xgdgm (g_Xgdgq a_Xgdgs)
                                  -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
                    [LclId] =
                        [z_sghau] \u [] z_sghau Data.Functor.Compose.$fDataCompose2;
                  } in  k2_sghat $dData_sgham sat_sghaw; } in
        let {
          sat_sghas [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs
               -> c (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dData_sgham] \r [k2_sghao z_sghap ds_sghaq]
                  let {
                    sat_sghar [Occ=Once]
                      :: c_agdb1 (f_Xgdgm (g_Xgdgq a_Xgdgs)
                                  -> Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
                    [LclId] =
                        [z_sghap] \u [] z_sghap Data.Functor.Compose.$fDataCompose2;
                  } in  k2_sghao $dData_sgham sat_sghar ds_sghaq; } in
        let {
          sat_sghan [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Functor.Compose.Compose f_Xgdgm g_Xgdgq a_Xgdgs)
          [LclId] =
              [$dTypeable_sghah
               $dTypeable1_sghai
               $dTypeable2_sghaj
               $dTypeable3_sghak
               $dTypeable4_sghal] \u []
                  Data.Functor.Compose.$w$cp1Data
                      $dTypeable_sghah
                      $dTypeable1_sghai
                      $dTypeable2_sghaj
                      $dTypeable3_sghak
                      $dTypeable4_sghal;
        } in 
          Data.Data.C:Data [sat_sghan
                            sat_sghas
                            sat_sghax
                            lvl4_rgdQh
                            lvl5_rgdQi
                            lvl6_rgdQj
                            lvl7_rgdQk
                            sat_sghaA
                            sat_sghaG
                            sat_sghaM
                            sat_sghaQ
                            sat_sghaX
                            sat_sghb1
                            sat_sghb5
                            sat_sghb9];

