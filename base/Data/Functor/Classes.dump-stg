
==================== Pre unarise: ====================
2018-03-16 16:08:43.22783365 UTC

Data.Functor.Classes.liftShowsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> f a b
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdymD]
        case v_sdymD of {
          Data.Functor.Classes.C:Show2 v_sdymF [Occ=Once] _ [Occ=Dead] ->
              v_sdymF;
        };

Data.Functor.Classes.liftShowList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [f a b]
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdymH]
        case v_sdymH of {
          Data.Functor.Classes.C:Show2 _ [Occ=Dead] v_sdymK [Occ=Once] ->
              v_sdymK;
        };

Data.Functor.Classes.liftReadsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdymL]
        case v_sdymL of {
          Data.Functor.Classes.C:Read2 v_sdymN [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdymN;
        };

Data.Functor.Classes.liftReadList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdymR]
        case v_sdymR of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       v_sdymU [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdymU;
        };

Data.Functor.Classes.liftReadPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdymX]
        case v_sdymX of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdyn1 [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdyn1;
        };

Data.Functor.Classes.liftReadListPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdyn3]
        case v_sdyn3 of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdyn8 [Occ=Once] ->
              v_sdyn8;
        };

Data.Functor.Classes.$p1Ord2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Ord2 f =>
     Data.Functor.Classes.Eq2 f
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdyn9]
        case v_sdyn9 of {
          Data.Functor.Classes.C:Ord2 v_sdynb [Occ=Once] _ [Occ=Dead] ->
              v_sdynb;
        };

Data.Functor.Classes.liftCompare2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Ord2 f =>
     forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> f a c
     -> f b d
     -> GHC.Types.Ordering
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdynd]
        case v_sdynd of {
          Data.Functor.Classes.C:Ord2 _ [Occ=Dead] v_sdyng [Occ=Once] ->
              v_sdyng;
        };

Data.Functor.Classes.liftEq2 [InlPrag=INLINE]
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Eq2 f =>
     forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool) -> f a c -> f b d -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sdynh] v_sdynh;

Data.Functor.Classes.liftShowsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> f a
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdyni]
        case v_sdyni of {
          Data.Functor.Classes.C:Show1 v_sdynk [Occ=Once] _ [Occ=Dead] ->
              v_sdynk;
        };

Data.Functor.Classes.liftShowList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdynm]
        case v_sdynm of {
          Data.Functor.Classes.C:Show1 _ [Occ=Dead] v_sdynp [Occ=Once] ->
              v_sdynp;
        };

Data.Functor.Classes.liftReadsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdynq]
        case v_sdynq of {
          Data.Functor.Classes.C:Read1 v_sdyns [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdyns;
        };

Data.Functor.Classes.liftReadList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdynw]
        case v_sdynw of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       v_sdynz [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdynz;
        };

Data.Functor.Classes.liftReadPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdynC]
        case v_sdynC of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdynG [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdynG;
        };

Data.Functor.Classes.liftReadListPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdynI]
        case v_sdynI of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdynN [Occ=Once] ->
              v_sdynN;
        };

Data.Functor.Classes.$p1Ord1
  :: forall (f :: * -> *).
     Data.Functor.Classes.Ord1 f =>
     Data.Functor.Classes.Eq1 f
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdynO]
        case v_sdynO of {
          Data.Functor.Classes.C:Ord1 v_sdynQ [Occ=Once] _ [Occ=Dead] ->
              v_sdynQ;
        };

Data.Functor.Classes.liftCompare
  :: forall (f :: * -> *).
     Data.Functor.Classes.Ord1 f =>
     forall a b.
     (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdynS]
        case v_sdynS of {
          Data.Functor.Classes.C:Ord1 _ [Occ=Dead] v_sdynV [Occ=Once] ->
              v_sdynV;
        };

Data.Functor.Classes.liftEq [InlPrag=INLINE]
  :: forall (f :: * -> *).
     Data.Functor.Classes.Eq1 f =>
     forall a b.
     (a -> b -> GHC.Types.Bool) -> f a -> f b -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sdynW] v_sdynW;

Data.Functor.Classes.$fRead1Const1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Classes.$fRead1Const4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Const"#;

Data.Functor.Classes.$fRead1Const3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Const4;

Data.Functor.Classes.$fRead1Const2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Const3];

Data.Functor.Classes.$w$cliftReadPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Functor.Const.Const a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdynX w1_sdynY w2_sdynZ]
        let {
          sat_sdyob [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_sdxVk b_sdxVl)
          [LclId] =
              [w_sdynX] \r [c_sdyo0 eta_sdyo1]
                  case c_sdyo0 of {
                    GHC.Types.I# x_sdyo3 [Occ=Once] ->
                        case <=# [x_sdyo3 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdyo8 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_X81aZ
                                [LclId] =
                                    [w_sdynX eta_sdyo1] \r [a1_sdyo5]
                                        let {
                                          sat_sdyo7 [Occ=Once]
                                            :: a_sdxVk -> Text.ParserCombinators.ReadP.P b2_X81aZ
                                          [LclId] =
                                              [eta_sdyo1] \r [a2_sdyo6] eta_sdyo1 a2_sdyo6;
                                        } in  w_sdynX Data.Functor.Classes.$fRead1Const1 sat_sdyo7;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Const2 sat_sdyo8
                                of
                                { Unit# ww1_sdyoa [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sdyoa];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdyob w1_sdynY w2_sdynZ;

Data.Functor.Classes.$fRead1Const6 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Functor.Const.Const a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,A><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyoc w1_sdyod w2_sdyoe w3_sdyof w4_sdyog w5_sdyoh]
        Data.Functor.Classes.$w$cliftReadPrec1 w_sdyoc w4_sdyog w5_sdyoh;

Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Const.Const a b]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdyoi rl1_sdyoj rp2_sdyok rl2_sdyol]
        let {
          sat_sdyoo [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_adwSL b_adwSM)
          [LclId] =
              [rp1_sdyoi] \r [w_sdyom w1_sdyon]
                  Data.Functor.Classes.$w$cliftReadPrec1 rp1_sdyoi w_sdyom w1_sdyon;
        } in  GHC.Read.list sat_sdyoo;

Data.Functor.Classes.$w$cliftReadsPrec7 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a b)
[GblId, Arity=2, Str=<L,1*C1(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyop w1_sdyoq]
        let {
          sat_sdyoG [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Const.Const a_sdxVu b_sdxVv)
          [LclId] =
              [w_sdyop w1_sdyoq] \u []
                  let {
                    lvl3_sdyor [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS a_sdxVu
                    [LclId] =
                        [w_sdyop] \u [] w_sdyop Data.Functor.Classes.$fRead1Const1; } in
                  let {
                    sat_sdyoF [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Const.Const a_sdxVu b_sdxVv)
                    [LclId] =
                        [lvl3_sdyor] \r [c_sdyos eta_sdyot]
                            case c_sdyos of {
                              GHC.Types.I# x_sdyov [Occ=Once] ->
                                  case <=# [x_sdyov 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdyoC [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [lvl3_sdyor eta_sdyot] \r [a1_sdyox]
                                                  let {
                                                    sat_sdyoz [Occ=Once]
                                                      :: a_sdxVu
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta_sdyot] \r [a2_sdyoy]
                                                            eta_sdyot a2_sdyoy;
                                                  } in 
                                                    case
                                                        Text.ParserCombinators.ReadP.$wreadS_to_P
                                                            lvl3_sdyor sat_sdyoz
                                                    of
                                                    { Unit# ww1_sdyoB [Occ=Once] ->
                                                          Text.ParserCombinators.ReadP.Look [ww1_sdyoB];
                                                    };
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Const2 sat_sdyoC
                                          of
                                          { Unit# ww1_sdyoE [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdyoE];
                                          };
                                  };
                            };
                  } in 
                    GHC.Read.list3
                        sat_sdyoF
                        w1_sdyoq
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyoG;

Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a b)
[GblId,
 Arity=5,
 Str=<L,1*C1(C(U))><L,A><L,A><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyoH w1_sdyoI w2_sdyoJ w3_sdyoK w4_sdyoL]
        Data.Functor.Classes.$w$cliftReadsPrec7 w_sdyoH w4_sdyoL;

Data.Functor.Classes.$fRead1Either3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right"#;

Data.Functor.Classes.$fRead1Either2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Either3;

Data.Functor.Classes.$fRead1Either1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Either2];

Data.Functor.Classes.$fRead1Either6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left"#;

Data.Functor.Classes.$fRead1Either5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Either6;

Data.Functor.Classes.$fRead1Either4 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Either5];

Data.Functor.Classes.$w$cliftReadPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyoM w1_sdyoN w2_sdyoO w3_sdyoP]
        let {
          sat_sdypb [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_sdxVC b_sdxVD)
          [LclId] =
              [w_sdyoM w1_sdyoN] \r [c_sdyoQ eta_sdyoR]
                  case c_sdyoQ of {
                    GHC.Types.I# x_sdyoT [Occ=Once] ->
                        case <=# [x_sdyoT 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdyoZ [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                [LclId] =
                                    [w_sdyoM eta_sdyoR] \r [a1_sdyoV]
                                        let {
                                          sat_sdyoY [Occ=Once]
                                            :: a_sdxVC -> Text.ParserCombinators.ReadP.P b2_i815E
                                          [LclId] =
                                              [eta_sdyoR] \r [a2_sdyoW]
                                                  let {
                                                    sat_sdyoX [Occ=Once]
                                                      :: Data.Either.Either a_sdxVC b_sdxVD
                                                    [LclId] =
                                                        CCCS Data.Either.Left! [a2_sdyoW];
                                                  } in  eta_sdyoR sat_sdyoX;
                                        } in  w_sdyoM Data.Functor.Classes.$fRead1Const1 sat_sdyoY;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Either4 sat_sdyoZ
                                of
                                { Unit# ww1_sdyp1 [Occ=Once] ->
                                      let {
                                        sat_sdypa [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b2_i815E
                                        [LclId] =
                                            [w1_sdyoN eta_sdyoR] \u []
                                                let {
                                                  sat_sdyp7 [Occ=Once]
                                                    :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                                  [LclId] =
                                                      [w1_sdyoN eta_sdyoR] \r [a1_sdyp3]
                                                          let {
                                                            sat_sdyp6 [Occ=Once]
                                                              :: b_sdxVD
                                                                 -> Text.ParserCombinators.ReadP.P
                                                                      b2_i815E
                                                            [LclId] =
                                                                [eta_sdyoR] \r [a2_sdyp4]
                                                                    let {
                                                                      sat_sdyp5 [Occ=Once]
                                                                        :: Data.Either.Either
                                                                             a_sdxVC b_sdxVD
                                                                      [LclId] =
                                                                          CCCS Data.Either.Right! [a2_sdyp4];
                                                                    } in  eta_sdyoR sat_sdyp5;
                                                          } in 
                                                            w1_sdyoN
                                                                Data.Functor.Classes.$fRead1Const1
                                                                sat_sdyp6;
                                                } in 
                                                  case
                                                      Text.Read.Lex.$wexpect
                                                          Data.Functor.Classes.$fRead1Either1
                                                          sat_sdyp7
                                                  of
                                                  { Unit# ww3_sdyp9 [Occ=Once] ->
                                                        Text.ParserCombinators.ReadP.Look [ww3_sdyp9];
                                                  }; } in
                                      let {
                                        sat_sdyp2 [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b2_i815E
                                        [LclId] =
                                            CCCS Text.ParserCombinators.ReadP.Look! [ww1_sdyp1];
                                      } in 
                                        Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                            sat_sdyp2 sat_sdypa;
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdypb w2_sdyoO w3_sdyoP;

Data.Functor.Classes.$fRead1Either8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdypc w1_sdypd w2_sdype w3_sdypf w4_sdypg w5_sdyph]
        Data.Functor.Classes.$w$cliftReadPrec3
            w_sdypc w2_sdype w4_sdypg w5_sdyph;

Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a b]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdypi rl1_sdypj rp2_sdypk rl2_sdypl]
        let {
          sat_sdypo [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_adwUm b_adwUn)
          [LclId] =
              [rp1_sdypi rp2_sdypk] \r [w_sdypm w1_sdypn]
                  Data.Functor.Classes.$w$cliftReadPrec3
                      rp1_sdypi rp2_sdypk w_sdypm w1_sdypn;
        } in  GHC.Read.list sat_sdypo;

Data.Functor.Classes.$w$cliftReadsPrec8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdypp w1_sdypq w2_sdypr]
        let {
          sat_sdypu [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_sdxVM b_sdxVN)
          [LclId] =
              [w_sdypp w1_sdypq w2_sdypr] \u []
                  let {
                    sat_sdypt [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_sdxVN
                    [LclId] =
                        [w1_sdypq] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdypq eta_B1; } in
                  let {
                    sat_sdyps [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdxVM
                    [LclId] =
                        [w_sdypp] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdypp eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec3
                        sat_sdyps
                        sat_sdypt
                        w2_sdypr
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdypu;

Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=5,
 Str=<L,C(C(U))><L,A><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdypv w1_sdypw w2_sdypx w3_sdypy w4_sdypz]
        Data.Functor.Classes.$w$cliftReadsPrec8 w_sdypv w2_sdypx w4_sdypz;

Data.Functor.Classes.$fEq1Maybe_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdypA ds1_sdypB ds2_sdypC]
        case ds1_sdypB of {
          GHC.Base.Nothing ->
              case ds2_sdypC of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just ds3_sdypG [Occ=Once] ->
              case ds2_sdypC of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just y_sdypI [Occ=Once] -> ds_sdypA ds3_sdypG y_sdypI;
              };
        };

Data.Functor.Classes.$fEq1Maybe [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 GHC.Base.Maybe
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Maybe_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1 [Occ=LoopBreaker]
  :: forall a b.
     (a -> b -> GHC.Types.Bool) -> [a] -> [b] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdypJ ds1_sdypK ds2_sdypL]
        case ds1_sdypK of {
          [] ->
              case ds2_sdypL of {
                [] -> GHC.Types.True [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
              };
          : ds3_sdypQ [Occ=Once] ds4_sdypR [Occ=Once] ->
              case ds2_sdypL of {
                [] -> GHC.Types.False [];
                : y_sdypT [Occ=Once] ys_sdypU [Occ=Once] ->
                    case ds_sdypJ ds3_sdypQ y_sdypT of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True ->
                          Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                              ds_sdypJ ds4_sdypR ys_sdypU;
                    };
              };
        };

Data.Functor.Classes.$fEq1[] [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 []
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$w$cliftEq [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> a -> [a] -> b -> [b] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdypW ww_sdypX ww1_sdypY ww2_sdypZ ww3_sdyq0]
        case w_sdypW ww_sdypX ww2_sdypZ of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                  w_sdypW ww1_sdypY ww3_sdyq0;
        };

Data.Functor.Classes.$fEq1NonEmpty_$cliftEq [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyq2 w1_sdyq3 w2_sdyq4]
        case w1_sdyq3 of {
          GHC.Base.:| ww1_sdyq6 [Occ=Once] ww2_sdyq7 [Occ=Once] ->
              case w2_sdyq4 of {
                GHC.Base.:| ww4_sdyq9 [Occ=Once] ww5_sdyqa [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftEq
                        w_sdyq2 ww1_sdyq6 ww2_sdyq7 ww4_sdyq9 ww5_sdyqa;
              };
        };

Data.Functor.Classes.$fEq1NonEmpty [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 GHC.Base.NonEmpty
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1NonEmpty_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Identity_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eq_sdyqb ds_sdyqc ds1_sdyqd] eq_sdyqb ds_sdyqc ds1_sdyqd;

Data.Functor.Classes.$fEq1Identity [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 Data.Functor.Identity.Identity
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Identity_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Proxy_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdyqe ds1_sdyqf ds2_sdyqg] GHC.Types.True [];

Data.Functor.Classes.$fEq1Proxy [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 Data.Proxy.Proxy
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Proxy_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fOrd1Maybe_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdyqh ds1_sdyqi ds2_sdyqj]
        case ds1_sdyqi of {
          GHC.Base.Nothing ->
              case ds2_sdyqj of {
                GHC.Base.Nothing -> GHC.Types.EQ [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.LT [];
              };
          GHC.Base.Just ds3_sdyqn [Occ=Once] ->
              case ds2_sdyqj of {
                GHC.Base.Nothing -> GHC.Types.GT [];
                GHC.Base.Just y_sdyqp [Occ=Once] -> ds_sdyqh ds3_sdyqn y_sdyqp;
              };
        };

Data.Functor.Classes.$fOrd1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Maybe_$cliftEq
                                                Data.Functor.Classes.$fOrd1Maybe_$cliftCompare];

Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1 [Occ=LoopBreaker]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering) -> [a] -> [b] -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdyqq ds1_sdyqr ds2_sdyqs]
        case ds1_sdyqr of {
          [] ->
              case ds2_sdyqs of {
                [] -> GHC.Types.EQ [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.LT [];
              };
          : ds3_sdyqx [Occ=Once] ds4_sdyqy [Occ=Once] ->
              case ds2_sdyqs of {
                [] -> GHC.Types.GT [];
                : y_sdyqA [Occ=Once] ys_sdyqB [Occ=Once] ->
                    case ds_sdyqq ds3_sdyqx y_sdyqA of {
                      GHC.Types.LT -> GHC.Types.LT [];
                      GHC.Types.EQ ->
                          Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
                              ds_sdyqq ds4_sdyqy ys_sdyqB;
                      GHC.Types.GT -> GHC.Types.GT [];
                    };
              };
        };

Data.Functor.Classes.$fOrd1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                                                Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1];

Data.Functor.Classes.$w$cliftCompare1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> a -> [a] -> b -> [b] -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdyqD ww_sdyqE ww1_sdyqF ww2_sdyqG ww3_sdyqH]
        case w_sdyqD ww_sdyqE ww2_sdyqG of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
                  w_sdyqD ww1_sdyqF ww3_sdyqH;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyqJ w1_sdyqK w2_sdyqL]
        case w1_sdyqK of {
          GHC.Base.:| ww1_sdyqN [Occ=Once] ww2_sdyqO [Occ=Once] ->
              case w2_sdyqL of {
                GHC.Base.:| ww4_sdyqQ [Occ=Once] ww5_sdyqR [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftCompare1
                        w_sdyqJ ww1_sdyqN ww2_sdyqO ww4_sdyqQ ww5_sdyqR;
              };
        };

Data.Functor.Classes.$fOrd1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1NonEmpty_$cliftEq
                                                Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare];

Data.Functor.Classes.$fOrd1Identity_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [comp_sdyqS ds_sdyqT ds1_sdyqU]
        comp_sdyqS ds_sdyqT ds1_sdyqU;

Data.Functor.Classes.$fOrd1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Identity_$cliftEq
                                                Data.Functor.Classes.$fOrd1Identity_$cliftCompare];

Data.Functor.Classes.$fOrd1Proxy_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdyqV ds1_sdyqW ds2_sdyqX] GHC.Types.EQ [];

Data.Functor.Classes.$fOrd1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 Data.Proxy.Proxy
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Proxy_$cliftEq
                                                Data.Functor.Classes.$fOrd1Proxy_$cliftCompare];

Data.Functor.Classes.$fRead1[]_$cliftReadPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdyqY rl_sdyqZ] rl_sdyqZ;

Data.Functor.Classes.$fRead1NonEmpty4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":|"#;

Data.Functor.Classes.$fRead1NonEmpty3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1NonEmpty4;

Data.Functor.Classes.$fRead1NonEmpty2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [6#];

Data.Functor.Classes.$w$cliftReadsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Prim.Int#
     -> GHC.Base.String
     -> [(GHC.Base.NonEmpty a, GHC.Base.String)]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(U)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyr0 w1_sdyr1 ww_sdyr2 w2_sdyr3]
        let {
          go_sdyr4 [Occ=LoopBreaker]
            :: [(a_sdxWD, GHC.Base.String)]
               -> [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w1_sdyr1 go_sdyr4] \r [ds_sdyr5]
                  case ds_sdyr5 of {
                    [] -> [] [];
                    : y_sdyr7 [Occ=Once!] ys_sdyr8 [Occ=Once] ->
                        case y_sdyr7 of {
                          (,) a1_sdyra [Occ=OnceL] s''_sdyrb [Occ=Once] ->
                              let {
                                z_sdyrc [Occ=OnceL]
                                  :: [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
                                [LclId] =
                                    [go_sdyr4 ys_sdyr8] \u [] go_sdyr4 ys_sdyr8; } in
                              let {
                                go1_sdyrd [Occ=LoopBreaker]
                                  :: [(GHC.Base.String, GHC.Base.String)]
                                     -> [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
                                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                    sat-only [w1_sdyr1 a1_sdyra z_sdyrc go1_sdyrd] \r [ds1_sdyre]
                                        case ds1_sdyre of {
                                          [] -> z_sdyrc;
                                          : y1_sdyrg [Occ=Once!] ys1_sdyrh [Occ=Once*] ->
                                              case y1_sdyrg of {
                                                (,) ds2_sdyrj [Occ=Once] s'''_sdyrk [Occ=Once] ->
                                                    case
                                                        GHC.Base.eqString
                                                            ds2_sdyrj
                                                            Data.Functor.Classes.$fRead1NonEmpty3
                                                    of
                                                    { GHC.Types.False -> go1_sdyrd ys1_sdyrh;
                                                      GHC.Types.True ->
                                                          let {
                                                            z1_sdyrm [Occ=OnceL]
                                                              :: [(GHC.Base.NonEmpty a_sdxWD,
                                                                   GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdyrd ys1_sdyrh] \u []
                                                                    go1_sdyrd ys1_sdyrh; } in
                                                          let {
                                                            go2_sdyrn [Occ=LoopBreaker]
                                                              :: [([a_sdxWD], GHC.Base.String)]
                                                                 -> [(GHC.Base.NonEmpty a_sdxWD,
                                                                      GHC.Base.String)]
                                                            [LclId,
                                                             Arity=1,
                                                             Str=<S,1*U>,
                                                             Unf=OtherCon []] =
                                                                sat-only [a1_sdyra
                                                                          z1_sdyrm
                                                                          go2_sdyrn] \r [ds3_sdyro]
                                                                    case ds3_sdyro of {
                                                                      [] -> z1_sdyrm;
                                                                      : y2_sdyrq [Occ=Once!]
                                                                        ys2_sdyrr [Occ=Once] ->
                                                                          case y2_sdyrq of {
                                                                            (,) as_sdyrt [Occ=Once]
                                                                                s''''_sdyru [Occ=Once] ->
                                                                                let {
                                                                                  sat_sdyrx [Occ=Once]
                                                                                    :: [(GHC.Base.NonEmpty
                                                                                           a_sdxWD,
                                                                                         GHC.Base.String)]
                                                                                  [LclId] =
                                                                                      [go2_sdyrn
                                                                                       ys2_sdyrr] \u []
                                                                                          go2_sdyrn
                                                                                              ys2_sdyrr; } in
                                                                                let {
                                                                                  sat_sdyrv [Occ=Once]
                                                                                    :: GHC.Base.NonEmpty
                                                                                         a_sdxWD
                                                                                  [LclId] =
                                                                                      CCCS GHC.Base.:|! [a1_sdyra
                                                                                                         as_sdyrt]; } in
                                                                                let {
                                                                                  sat_sdyrw [Occ=Once]
                                                                                    :: (GHC.Base.NonEmpty
                                                                                          a_sdxWD,
                                                                                        GHC.Base.String)
                                                                                  [LclId] =
                                                                                      CCCS (,)! [sat_sdyrv
                                                                                                 s''''_sdyru];
                                                                                } in 
                                                                                  : [sat_sdyrw
                                                                                     sat_sdyrx];
                                                                          };
                                                                    };
                                                          } in 
                                                            case w1_sdyr1 s'''_sdyrk of sat_sdyry {
                                                              __DEFAULT -> go2_sdyrn sat_sdyry;
                                                            };
                                                    };
                                              };
                                        };
                              } in 
                                case
                                    Text.ParserCombinators.ReadP.run GHC.Read.lex1 s''_sdyrb
                                of
                                sat_sdyrz
                                { __DEFAULT -> go1_sdyrd sat_sdyrz;
                                };
                        };
                  }; } in
        let {
          sat_sdyrE [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_sdxWD)
          [LclId] =
              [w_sdyr0 go_sdyr4] \r [s'_sdyrC]
                  case
                      w_sdyr0 Data.Functor.Classes.$fRead1NonEmpty2 s'_sdyrC
                  of
                  sat_sdyrD
                  { __DEFAULT -> go_sdyr4 sat_sdyrD;
                  };
        } in 
          case ># [ww_sdyr2 5#] of sat_sdyrA {
            __DEFAULT ->
                case tagToEnum# [sat_sdyrA] of sat_sdyrB {
                  __DEFAULT -> GHC.Read.readParen sat_sdyrB sat_sdyrE w2_sdyr3;
                };
          };

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a)
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(U)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyrF w1_sdyrG w2_sdyrH w3_sdyrI]
        case w2_sdyrH of {
          GHC.Types.I# ww1_sdyrK [Occ=Once] ->
              Data.Functor.Classes.$w$cliftReadsPrec5
                  w_sdyrF w1_sdyrG ww1_sdyrK w3_sdyrI;
        };

Data.Functor.Classes.$fRead1Proxy4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Proxy"#;

Data.Functor.Classes.$fRead1Proxy3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Proxy4;

Data.Functor.Classes.$fRead1Proxy_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Proxy3];

Data.Functor.Classes.$fRead1Proxy2
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [eta_sdyrL eta1_sdyrM]
        let {
          sat_sdyrO [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X81cg
          [LclId] =
              [eta1_sdyrM] \r [x_sdyrN] eta1_sdyrM Data.Proxy.Proxy;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Functor.Classes.$fRead1Proxy_lexeme sat_sdyrO
          of
          { Unit# ww1_sdyrQ [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sdyrQ];
          };

Data.Functor.Classes.$fRead1Proxy1
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Functor.Classes.$fRead1Proxy2 eta_B2 eta_B1;

Data.Functor.Classes.$fRead1Proxy5
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=4, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdyrR ds1_sdyrS eta_B2 eta_B1]
        Data.Functor.Classes.$fRead1Proxy1 eta_B2 eta_B1;

Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> [a]
     -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdyrT sl_sdyrU ds1_sdyrV] sl_sdyrU;

Data.Functor.Classes.$fShow1NonEmpty1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " :| "#;

Data.Functor.Classes.$w$cliftShowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> a
     -> [a]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C(U))><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyrW w1_sdyrX ww_sdyrY ww1_sdyrZ ww2_sdys0]
        let {
          f_sdys1 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyrW ww1_sdyrZ] \u []
                  w_sdyrW Data.Functor.Classes.$fRead1NonEmpty2 ww1_sdyrZ; } in
        let {
          g_sdys2 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdyrX ww2_sdys0] \u [] w1_sdyrX ww2_sdys0;
        } in 
          case ># [ww_sdyrY 5#] of {
            __DEFAULT ->
                let {
                  sat_sdys7 [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_sdys1 g_sdys2] \r [x_sdys4]
                          let {
                            sat_sdys6 [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g_sdys2 x_sdys4] \u []
                                    let {
                                      sat_sdys5 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdys2 x_sdys4] \u [] g_sdys2 x_sdys4;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Functor.Classes.$fShow1NonEmpty1 sat_sdys5;
                          } in  f_sdys1 sat_sdys6;
                } in  sat_sdys7;
            1# ->
                let {
                  sat_sdysd [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sdys1 g_sdys2] \r [x_sdys8]
                          let {
                            sat_sdysc [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sdys1 g_sdys2 x_sdys8] \u []
                                    let {
                                      sat_sdysb [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g_sdys2 x_sdys8] \u []
                                              let {
                                                sat_sdysa [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sdys2 x_sdys8] \u []
                                                        let {
                                                          sat_sdys9 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdys8];
                                                        } in  g_sdys2 sat_sdys9;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Functor.Classes.$fShow1NonEmpty1 sat_sdysa;
                                    } in  f_sdys1 sat_sdysb;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdysc];
                } in  sat_sdysd;
          };

Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> GHC.Base.NonEmpty a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C(U))><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyse w1_sdysf w2_sdysg w3_sdysh]
        case w2_sdysg of {
          GHC.Types.I# ww1_sdysj [Occ=Once] ->
              case w3_sdysh of {
                GHC.Base.:| ww3_sdysl [Occ=Once] ww4_sdysm [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftShowsPrec1
                        w_sdyse w1_sdysf ww1_sdysj ww3_sdysl ww4_sdysm;
              };
        };

Data.Functor.Classes.$fShow1Proxy2
  :: [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Base.++ Data.Functor.Classes.$fRead1Proxy3 eta_B1;

Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Proxy.Proxy a
     -> GHC.Show.ShowS
[GblId, Arity=5, Str=<L,A><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdysn ds1_sdyso ds2_sdysp ds3_sdysq eta_B1]
        Data.Functor.Classes.$fShow1Proxy2 eta_B1;

Data.Functor.Classes.$fEq2(,)_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool) -> (a, c) -> (b, d) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [e1_sdysr e2_sdyss ds_sdyst ds1_sdysu]
        case ds_sdyst of {
          (,) x1_sdysw [Occ=Once] y1_sdysx [Occ=Once] ->
              case ds1_sdysu of {
                (,) x2_sdysz [Occ=Once] y2_sdysA [Occ=Once] ->
                    case e1_sdysr x1_sdysw x2_sdysz of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> e2_sdyss y1_sdysx y2_sdysA;
                    };
              };
        };

Data.Functor.Classes.$fEq2(,) [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 (,)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2(,)_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1(,)_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> (a, a1) -> (a, b) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdysC eta_sdysD eta1_sdysE eta2_sdysF]
        case eta1_sdysE of {
          (,) x1_sdysH [Occ=Once] y1_sdysI [Occ=Once] ->
              case eta2_sdysF of {
                (,) x2_sdysK [Occ=Once] y2_sdysL [Occ=Once] ->
                    case GHC.Classes.== $dEq_sdysC x1_sdysH x2_sdysK of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> eta_sdysD y1_sdysI y2_sdysL;
                    };
              };
        };

Data.Functor.Classes.$fEq1(,) [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Classes.Eq a => Data.Functor.Classes.Eq1 ((,) a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1(,)_$cliftEq eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq2Either_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool)
     -> Data.Either.Either a c
     -> Data.Either.Either b d
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [e1_sdysN ds_sdysO ds1_sdysP ds2_sdysQ]
        case ds1_sdysP of {
          Data.Either.Left x_sdysS [Occ=Once] ->
              case ds2_sdysQ of {
                Data.Either.Left y_sdysU [Occ=Once] -> e1_sdysN x_sdysS y_sdysU;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds3_sdysW [Occ=Once] ->
              case ds2_sdysQ of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdysZ [Occ=Once] -> ds_sdysO ds3_sdysW y_sdysZ;
              };
        };

Data.Functor.Classes.$fEq2Either [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 Data.Either.Either
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2Either_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Either_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdyt0 eta_sdyt1 eta1_sdyt2 eta2_sdyt3]
        case eta1_sdyt2 of {
          Data.Either.Left x_sdyt5 [Occ=Once] ->
              case eta2_sdyt3 of {
                Data.Either.Left y_sdyt7 [Occ=Once] ->
                    GHC.Classes.== $dEq_sdyt0 x_sdyt5 y_sdyt7;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds_sdyt9 [Occ=Once] ->
              case eta2_sdyt3 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdytc [Occ=Once] -> eta_sdyt1 ds_sdyt9 y_sdytc;
              };
        };

Data.Functor.Classes.$fEq1Either [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Classes.Eq1 (Data.Either.Either a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Either_$cliftEq
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq2Const_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a c
     -> Data.Functor.Const.Const b d
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eq_sdytd ds_sdyte ds1_sdytf ds2_sdytg]
        eq_sdytd ds1_sdytf ds2_sdytg;

Data.Functor.Classes.$fEq2Const [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 Data.Functor.Const.Const
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2Const_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Const_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a a1
     -> Data.Functor.Const.Const a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdyth eta_sdyti eta1_sdytj eta2_sdytk]
        GHC.Classes.== $dEq_sdyth eta1_sdytj eta2_sdytk;

Data.Functor.Classes.$fEq1Const [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Const_$cliftEq
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fOrd2(,)_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> (a, c)
     -> (b, d)
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [comp1_sdytl comp2_sdytm ds_sdytn ds1_sdyto]
        case ds_sdytn of {
          (,) x1_sdytq [Occ=Once] y1_sdytr [Occ=Once] ->
              case ds1_sdyto of {
                (,) x2_sdytt [Occ=Once] y2_sdytu [Occ=Once] ->
                    case comp1_sdytl x1_sdytq x2_sdytt of {
                      GHC.Types.LT -> GHC.Types.LT [];
                      GHC.Types.EQ -> comp2_sdytm y1_sdytr y2_sdytu;
                      GHC.Types.GT -> GHC.Types.GT [];
                    };
              };
        };

Data.Functor.Classes.$fOrd2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2(,)_$cliftEq2
                                                Data.Functor.Classes.$fOrd2(,)_$cliftCompare2];

Data.Functor.Classes.$w$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> a -> a1 -> a -> b -> GHC.Types.Ordering
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdytw w1_sdytx ww_sdyty ww1_sdytz ww2_sdytA ww3_sdytB]
        case GHC.Classes.compare w_sdytw ww_sdyty ww2_sdytA of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> w1_sdytx ww1_sdytz ww3_sdytB;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Classes.$fOrd1(,)_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> (a, a1) -> (a, b) -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdytD w1_sdytE w2_sdytF w3_sdytG]
        case w2_sdytF of {
          (,) ww1_sdytI [Occ=Once] ww2_sdytJ [Occ=Once] ->
              case w3_sdytG of {
                (,) ww4_sdytL [Occ=Once] ww5_sdytM [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftCompare
                        w_sdytD w1_sdytE ww1_sdytI ww2_sdytJ ww4_sdytL ww5_sdytM;
              };
        };

Data.Functor.Classes.$w$cp1Ord1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> a -> a1 -> a -> b -> GHC.Types.Bool
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdytN w1_sdytO ww_sdytP ww1_sdytQ ww2_sdytR ww3_sdytS]
        case GHC.Classes.$p1Ord w_sdytN of sat_sdytT {
          __DEFAULT ->
              case GHC.Classes.== sat_sdytT ww_sdytP ww2_sdytR of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> w1_sdytO ww1_sdytQ ww3_sdytS;
              };
        };

Data.Functor.Classes.$fOrd1(,)1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> (a, a1) -> (a, b) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdytV w1_sdytW w2_sdytX w3_sdytY]
        case w2_sdytX of {
          (,) ww1_sdyu0 [Occ=Once] ww2_sdyu1 [Occ=Once] ->
              case w3_sdytY of {
                (,) ww4_sdyu3 [Occ=Once] ww5_sdyu4 [Occ=Once] ->
                    Data.Functor.Classes.$w$cp1Ord1
                        w_sdytV w1_sdytW ww1_sdyu0 ww2_sdyu1 ww4_sdyu3 ww5_sdyu4;
              };
        };

Data.Functor.Classes.$fOrd1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Ord a => Data.Functor.Classes.Ord1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdyu5]
        let {
          sat_sdyu7 [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> (a_Xdx1z, a) -> (a_Xdx1z, b) -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdyu5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1(,)_$cliftCompare
                      $dOrd_sdyu5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyu6 [Occ=Once] :: Data.Functor.Classes.Eq1 ((,) a_Xdx1z)
          [LclId] =
              [$dOrd_sdyu5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1(,)1 $dOrd_sdyu5 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdyu6 sat_sdyu7];

Data.Functor.Classes.$fOrd2Either_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> Data.Either.Either a c
     -> Data.Either.Either b d
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [comp1_sdyu8 ds_sdyu9 ds1_sdyua ds2_sdyub]
        case ds1_sdyua of {
          Data.Either.Left x_sdyud [Occ=Once] ->
              case ds2_sdyub of {
                Data.Either.Left y_sdyuf [Occ=Once] -> comp1_sdyu8 x_sdyud y_sdyuf;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right ds3_sdyuh [Occ=Once] ->
              case ds2_sdyub of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right y_sdyuk [Occ=Once] -> ds_sdyu9 ds3_sdyuh y_sdyuk;
              };
        };

Data.Functor.Classes.$fOrd2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2Either_$cliftEq2
                                                Data.Functor.Classes.$fOrd2Either_$cliftCompare2];

Data.Functor.Classes.$fOrd1Either_$cliftCompare
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdyul eta_sdyum eta1_sdyun eta2_sdyuo]
        case eta1_sdyun of {
          Data.Either.Left x_sdyuq [Occ=Once] ->
              case eta2_sdyuo of {
                Data.Either.Left y_sdyus [Occ=Once] ->
                    GHC.Classes.compare $dOrd_sdyul x_sdyuq y_sdyus;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right ds_sdyuu [Occ=Once] ->
              case eta2_sdyuo of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right y_sdyux [Occ=Once] -> eta_sdyum ds_sdyuu y_sdyux;
              };
        };

Data.Functor.Classes.$fOrd1Either1
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdyuy eta_sdyuz eta1_sdyuA eta2_sdyuB]
        case eta1_sdyuA of {
          Data.Either.Left x_sdyuD [Occ=Once] ->
              case eta2_sdyuB of {
                Data.Either.Left y_sdyuF [Occ=Once] ->
                    case GHC.Classes.$p1Ord $dOrd_sdyuy of sat_sdyuG {
                      __DEFAULT -> GHC.Classes.== sat_sdyuG x_sdyuD y_sdyuF;
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds_sdyuI [Occ=Once] ->
              case eta2_sdyuB of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdyuL [Occ=Once] -> eta_sdyuz ds_sdyuI y_sdyuL;
              };
        };

Data.Functor.Classes.$fOrd1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Classes.Ord1 (Data.Either.Either a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdyuM]
        let {
          sat_sdyuO [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Either.Either a_Xdx16 a
               -> Data.Either.Either a_Xdx16 b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdyuM] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Either_$cliftCompare
                      $dOrd_sdyuM eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyuN [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Either.Either a_Xdx16)
          [LclId] =
              [$dOrd_sdyuM] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Either1
                      $dOrd_sdyuM eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdyuN sat_sdyuO];

Data.Functor.Classes.$fOrd2Const_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> Data.Functor.Const.Const a c
     -> Data.Functor.Const.Const b d
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [comp_sdyuP ds_sdyuQ ds1_sdyuR ds2_sdyuS]
        comp_sdyuP ds1_sdyuR ds2_sdyuS;

Data.Functor.Classes.$fOrd2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 Data.Functor.Const.Const
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2Const_$cliftEq2
                                                Data.Functor.Classes.$fOrd2Const_$cliftCompare2];

Data.Functor.Classes.$fOrd1Const1
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a a1
     -> Data.Functor.Const.Const a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdyuT eta_sdyuU eta1_sdyuV eta2_sdyuW]
        case GHC.Classes.$p1Ord $dOrd_sdyuT of sat_sdyuX {
          __DEFAULT -> GHC.Classes.== sat_sdyuX eta1_sdyuV eta2_sdyuW;
        };

Data.Functor.Classes.$fOrd1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Classes.Ord1 (Data.Functor.Const.Const a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdyuY]
        let {
          sat_sdyv3 [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Const.Const a_Xdx0D a
               -> Data.Functor.Const.Const a_Xdx0D b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdyuY] \r [eta_sdyv0 eta1_sdyv1 eta2_sdyv2]
                  GHC.Classes.compare $dOrd_sdyuY eta1_sdyv1 eta2_sdyv2; } in
        let {
          sat_sdyuZ [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a_Xdx0D)
          [LclId] =
              [$dOrd_sdyuY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Const1 $dOrd_sdyuY eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdyuZ sat_sdyv3];

Data.Functor.Classes.$fRead1(,)5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ","#;

Data.Functor.Classes.$fRead1(,)4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1(,)5;

Data.Functor.Classes.$fRead1(,)3 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Functor.Classes.$fRead1(,)4];

Data.Functor.Classes.$w$cliftReadPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a, b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyv4 w1_sdyv5 w2_sdyv6 w3_sdyv7]
        let {
          p_sdyv8 [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b2.
                  ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b2)
                  -> Text.ParserCombinators.ReadP.P b2
          [LclId, Arity=2, Str=<L,U><L,C(U)>, Unf=OtherCon []] =
              [w_sdyv4 w1_sdyv5] \r [n_sdyv9 k1_sdyva]
                  let {
                    sat_sdyvj [Occ=Once]
                      :: a_sdxYe -> Text.ParserCombinators.ReadP.P b2_i88WH
                    [LclId] =
                        [w1_sdyv5 n_sdyv9 k1_sdyva] \r [a1_sdyvb]
                            let {
                              sat_sdyvg [Occ=Once]
                                :: () -> Text.ParserCombinators.ReadP.P b2_i88WH
                              [LclId] =
                                  [w1_sdyv5 n_sdyv9 k1_sdyva a1_sdyvb] \r [a2_sdyvc]
                                      let {
                                        sat_sdyvf [Occ=Once]
                                          :: b_sdxYf -> Text.ParserCombinators.ReadP.P b2_i88WH
                                        [LclId] =
                                            [k1_sdyva a1_sdyvb] \r [a3_sdyvd]
                                                let {
                                                  sat_sdyve [Occ=Once] :: (a_sdxYe, b_sdxYf)
                                                  [LclId] =
                                                      CCCS (,)! [a1_sdyvb a3_sdyvd];
                                                } in  k1_sdyva sat_sdyve;
                                      } in  w1_sdyv5 n_sdyv9 sat_sdyvf;
                            } in 
                              case
                                  Text.Read.Lex.$wexpect Data.Functor.Classes.$fRead1(,)3 sat_sdyvg
                              of
                              { Unit# ww1_sdyvi [Occ=Once] ->
                                    Text.ParserCombinators.ReadP.Look [ww1_sdyvi];
                              };
                  } in  w_sdyv4 n_sdyv9 sat_sdyvj; } in
        let {
          lvl3_sdyvk [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b2.
                  ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b2)
                  -> Text.ParserCombinators.ReadP.P b2
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [p_sdyv8] \r [w4_sdyvl w5_sdyvm]
                  case GHC.Read.$wparen' p_sdyv8 w4_sdyvl w5_sdyvm of {
                    Unit# ww1_sdyvo [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Get [ww1_sdyvo];
                  }; } in
        let {
          sat_sdyvt [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_sdxYe, b_sdxYf)
          [LclId] =
              [lvl3_sdyvk] \r [eta_sdyvp eta1_sdyvq]
                  case
                      GHC.Read.$wskipSpacesThenP lvl3_sdyvk eta_sdyvp eta1_sdyvq
                  of
                  { Unit# ww1_sdyvs [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdyvs];
                  };
        } in  GHC.Read.list3 sat_sdyvt w2_sdyv6 w3_sdyv7;

Data.Functor.Classes.$fRead1(,)2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a, b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyvu w1_sdyvv w2_sdyvw w3_sdyvx w4_sdyvy w5_sdyvz]
        Data.Functor.Classes.$w$cliftReadPrec2
            w_sdyvu w2_sdyvw w4_sdyvy w5_sdyvz;

Data.Functor.Classes.$w$cliftReadsPrec6 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, b)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyvA w1_sdyvB w2_sdyvC]
        let {
          sat_sdyvF [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (a_sdxYo, b_sdxYp)
          [LclId] =
              [w_sdyvA w1_sdyvB w2_sdyvC] \u []
                  let {
                    sat_sdyvE [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_sdxYp
                    [LclId] =
                        [w1_sdyvB] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdyvB eta_B1; } in
                  let {
                    sat_sdyvD [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdxYo
                    [LclId] =
                        [w_sdyvA] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdyvA eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec2
                        sat_sdyvD
                        sat_sdyvE
                        w2_sdyvC
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyvF;

Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, b)
[GblId,
 Arity=5,
 Str=<L,C(C(U))><L,A><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyvG w1_sdyvH w2_sdyvI w3_sdyvJ w4_sdyvK]
        Data.Functor.Classes.$w$cliftReadsPrec6 w_sdyvG w2_sdyvI w4_sdyvK;

Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [(a, b)]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdyvL rl1_sdyvM rp2_sdyvN rl2_sdyvO]
        let {
          sat_sdyvR [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_adwW8, b_adwW9)
          [LclId] =
              [rp1_sdyvL rp2_sdyvN] \r [w_sdyvP w1_sdyvQ]
                  Data.Functor.Classes.$w$cliftReadPrec2
                      rp1_sdyvL rp2_sdyvN w_sdyvP w1_sdyvQ;
        } in  GHC.Read.list sat_sdyvR;

Data.Functor.Classes.$fShow1(,)3 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['('#];

Data.Functor.Classes.$fRead1Identity5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Classes.$fShow1(,)2 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [','#];

Data.Functor.Classes.$fShow1(,)1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [')'#];

Data.Functor.Classes.$w$cliftShowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyvS w1_sdyvT ww_sdyvU ww1_sdyvV]
        let {
          f_sdyvW [Occ=OnceL!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyvS ww_sdyvU] \u []
                  w_sdyvS Data.Functor.Classes.$fRead1Identity5 ww_sdyvU; } in
        let {
          f1_sdyvX [Occ=OnceL!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdyvT ww1_sdyvV] \u []
                  w1_sdyvT Data.Functor.Classes.$fRead1Identity5 ww1_sdyvV; } in
        let {
          sat_sdyw3 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
          [LclId] =
              [f_sdyvW f1_sdyvX] \r [x_sdyvY]
                  let {
                    sat_sdyw2 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [f_sdyvW f1_sdyvX x_sdyvY] \u []
                            let {
                              sat_sdyw0 [Occ=Once] :: [GHC.Types.Char]
                              [LclId] =
                                  [f1_sdyvX x_sdyvY] \u []
                                      let {
                                        sat_sdyvZ [Occ=Once] :: GHC.Base.String
                                        [LclId] =
                                            CCCS :! [Data.Functor.Classes.$fShow1(,)1 x_sdyvY];
                                      } in  f1_sdyvX sat_sdyvZ; } in
                            let {
                              sat_sdyw1 [Occ=Once] :: GHC.Base.String
                              [LclId] =
                                  CCCS :! [Data.Functor.Classes.$fShow1(,)2 sat_sdyw0];
                            } in  f_sdyvW sat_sdyw1;
                  } in  : [Data.Functor.Classes.$fShow1(,)3 sat_sdyw2];
        } in  sat_sdyw3;

Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> (a, b)
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*C1(C1(C(U)))><L,A><L,A><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyw4 w1_sdyw5 w2_sdyw6 w3_sdyw7 w4_sdyw8 w5_sdyw9]
        case w5_sdyw9 of {
          (,) ww1_sdywb [Occ=Once] ww2_sdywc [Occ=Once] ->
              Data.Functor.Classes.$w$cliftShowsPrec2
                  w_sdyw4 w2_sdyw6 ww1_sdywb ww2_sdywc;
        };

Data.Functor.Classes.$dmliftShowList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [f a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(C(C1(U))))))),A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow2_sdywd sp1_sdywe sl1_sdywf sp2_sdywg sl2_sdywh]
        let {
          sat_sdywi [Occ=Once] :: f_adw99 a_adwOU b_adwOV -> GHC.Show.ShowS
          [LclId] =
              [$dShow2_sdywd sp1_sdywe sl1_sdywf sp2_sdywg sl2_sdywh] \u []
                  Data.Functor.Classes.liftShowsPrec2
                      $dShow2_sdywd
                      sp1_sdywe
                      sl1_sdywf
                      sp2_sdywg
                      sl2_sdywh
                      Data.Functor.Classes.$fRead1Identity5;
        } in  GHC.Show.showList__ sat_sdywi;

Data.Functor.Classes.$w$cliftShowList3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> [(a, b)]
     -> GHC.Base.String
     -> GHC.Base.String
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdywj w1_sdywk w2_sdywl w3_sdywm]
        let {
          sat_sdyww [Occ=Once] :: (a_sdxYK, b_sdxYL) -> GHC.Show.ShowS
          [LclId] =
              [w_sdywj w1_sdywk] \r [ds_sdywn eta_sdywo]
                  case ds_sdywn of {
                    (,) x_sdywq [Occ=Once] y_sdywr [Occ=Once] ->
                        let {
                          sat_sdywv [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_sdywj w1_sdywk eta_sdywo x_sdywq y_sdywr] \u []
                                  let {
                                    sat_sdywt [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w1_sdywk eta_sdywo y_sdywr] \u []
                                            let {
                                              sat_sdyws [Occ=Once] :: GHC.Base.String
                                              [LclId] =
                                                  CCCS :! [Data.Functor.Classes.$fShow1(,)1
                                                           eta_sdywo];
                                            } in 
                                              w1_sdywk
                                                  Data.Functor.Classes.$fRead1Identity5
                                                  y_sdywr
                                                  sat_sdyws; } in
                                  let {
                                    sat_sdywu [Occ=Once] :: GHC.Base.String
                                    [LclId] =
                                        CCCS :! [Data.Functor.Classes.$fShow1(,)2 sat_sdywt];
                                  } in 
                                    w_sdywj Data.Functor.Classes.$fRead1Identity5 x_sdywq sat_sdywu;
                        } in  : [Data.Functor.Classes.$fShow1(,)3 sat_sdywv];
                  };
        } in  GHC.Show.showList__ sat_sdyww w2_sdywl w3_sdywm;

Data.Functor.Classes.$fShow2(,)_$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [(a, b)]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,A><L,C(C1(C1(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdywx w1_sdywy w2_sdywz w3_sdywA w4_sdywB w5_sdywC]
        Data.Functor.Classes.$w$cliftShowList3
            w_sdywx w2_sdywz w4_sdywB w5_sdywC;

Data.Functor.Classes.$fShow2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2(,)_$cliftShowList2];

Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> (a, a1)
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><L,A><L,A><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdywD eta_sdywE eta1_sdywF eta2_sdywG eta3_sdywH]
        case eta3_sdywH of {
          (,) ww1_sdywJ [Occ=Once] ww2_sdywK [Occ=Once] ->
              let {
                sat_sdywL [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_adwQx -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sdywD] \s [] GHC.Show.showsPrec $dShow_sdywD;
              } in 
                Data.Functor.Classes.$w$cliftShowsPrec2
                    sat_sdywL eta_sdywE ww1_sdywJ ww2_sdywK;
        };

$w$dmliftReadListPrec2_rdymu
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadP.ReadP [f a b]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdywM w1_sdywN w2_sdywO w3_sdywP w4_sdywQ]
        let {
          w5_sdywR [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [f_sdxYT a_sdxYV b_sdxYW]
          [LclId] =
              [w_sdywM w1_sdywN w2_sdywO w3_sdywP w4_sdywQ] \u []
                  let {
                    sat_sdywW [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [b_sdxYW]
                    [LclId] =
                        [w4_sdywQ] \u []
                            w4_sdywQ
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdywX [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [b_sdxYW]
                    [LclId] =
                        [sat_sdywW] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdywW eta_B1; } in
                  let {
                    sat_sdywV [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_sdxYW
                    [LclId] =
                        [w3_sdywP] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w3_sdywP eta_B1; } in
                  let {
                    sat_sdywT [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxYV]
                    [LclId] =
                        [w2_sdywO] \u []
                            w2_sdywO
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdywU [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxYV]
                    [LclId] =
                        [sat_sdywT] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdywT eta_B1; } in
                  let {
                    sat_sdywS [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxYV
                    [LclId] =
                        [w1_sdywN] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w1_sdywN eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadList2
                        w_sdywM sat_sdywS sat_sdywU sat_sdywV sat_sdywX; } in
        let {
          sat_sdyx1 [Occ=Once]
            :: forall b1.
               ([f_sdxYT a_sdxYV b_sdxYW] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [w5_sdywR] \r [w6_sdywY]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w5_sdywR w6_sdywY
                  of
                  { Unit# ww1_sdyx0 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdyx0];
                  };
        } in  sat_sdyx1;

$dmliftReadListPrec1_rdymv
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [f a b]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdyx2
                    w1_sdyx3
                    w2_sdyx4
                    w3_sdyx5
                    w4_sdyx6
                    w5_sdyx7]
        $w$dmliftReadListPrec2_rdymu
            w_sdyx2 w1_sdyx3 w2_sdyx4 w3_sdyx5 w4_sdyx6;

Data.Functor.Classes.$dmliftReadListPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        $dmliftReadListPrec1_rdymv
            eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$dmliftReadPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(C(U)))))),A,A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyx8 rp1_sdyx9 rl1_sdyxa rp2_sdyxb rl2_sdyxc]
        let {
          f1_sdyxd [Occ=OnceL!, Dmd=<L,C(C(U))>]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdwdU a_adwOl b_adwOm)
          [LclId] =
              [$dRead2_sdyx8 rp1_sdyx9 rl1_sdyxa rp2_sdyxb rl2_sdyxc] \u []
                  let {
                    sat_sdyxi [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [b_adwOm]
                    [LclId] =
                        [rl2_sdyxc] \u []
                            rl2_sdyxc
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdyxj [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [b_adwOm]
                    [LclId] =
                        [sat_sdyxi] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdyxi eta_B1; } in
                  let {
                    sat_sdyxh [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_adwOm
                    [LclId] =
                        [rp2_sdyxb] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S
                                rp2_sdyxb eta_B1; } in
                  let {
                    sat_sdyxf [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adwOl]
                    [LclId] =
                        [rl1_sdyxa] \u []
                            rl1_sdyxa
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdyxg [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adwOl]
                    [LclId] =
                        [sat_sdyxf] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdyxf eta_B1; } in
                  let {
                    sat_sdyxe [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwOl
                    [LclId] =
                        [rp1_sdyx9] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S rp1_sdyx9 eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadsPrec2
                        $dRead2_sdyx8 sat_sdyxe sat_sdyxg sat_sdyxh sat_sdyxj; } in
        let {
          sat_sdyxq [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (f_XdwdU a_adwOl b_adwOm -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [f1_sdyxd] \r [n_sdyxk]
                  let {
                    w_sdyxl [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS (f_XdwdU a_adwOl b_adwOm)
                    [LclId] =
                        [f1_sdyxd n_sdyxk] \u [] f1_sdyxd n_sdyxk; } in
                  let {
                    sat_sdyxp [Occ=OnceT[0]]
                      :: forall b1.
                         (f_XdwdU a_adwOl b_adwOm -> Text.ParserCombinators.ReadP.P b1)
                         -> Text.ParserCombinators.ReadP.P b1
                    [LclId] =
                        [w_sdyxl] \r [w1_sdyxm]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdyxl w1_sdyxm
                            of
                            { Unit# ww1_sdyxo [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyxo];
                            };
                  } in  sat_sdyxp;
        } in  sat_sdyxq;

Data.Functor.Classes.$dmliftReadList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C1(C(U)))))),A)><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyxr rp1_sdyxs rl1_sdyxt rp2_sdyxu rl2_sdyxv]
        let {
          sat_sdyxJ [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_XdwdV a_adwNZ b_adwO0]
          [LclId] =
              [$dRead2_sdyxr rp1_sdyxs rl1_sdyxt rp2_sdyxu rl2_sdyxv] \u []
                  let {
                    sat_sdyxI [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (f_XdwdV a_adwNZ b_adwO0)
                    [LclId] =
                        [$dRead2_sdyxr rp1_sdyxs rl1_sdyxt rp2_sdyxu rl2_sdyxv] \s []
                            let {
                              sat_sdyxH [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwO0]
                              [LclId] =
                                  [rl2_sdyxv] \r [n_sdyxD w1_sdyxE]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl2_sdyxv w1_sdyxE
                                      of
                                      { Unit# ww1_sdyxG [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdyxG];
                                      }; } in
                            let {
                              sat_sdyxC [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwO0
                              [LclId] =
                                  [rp2_sdyxu] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp2_sdyxu eta_B1; } in
                            let {
                              sat_sdyxB [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwNZ]
                              [LclId] =
                                  [rl1_sdyxt] \r [n_sdyxx w1_sdyxy]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl1_sdyxt w1_sdyxy
                                      of
                                      { Unit# ww1_sdyxA [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdyxA];
                                      }; } in
                            let {
                              sat_sdyxw [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwNZ
                              [LclId] =
                                  [rp1_sdyxs] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp1_sdyxs eta_B1;
                            } in 
                              Data.Functor.Classes.liftReadPrec2
                                  $dRead2_sdyxr sat_sdyxw sat_sdyxB sat_sdyxC sat_sdyxH;
                  } in 
                    GHC.Read.list
                        sat_sdyxI
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyxJ;

Data.Functor.Classes.$dmliftReadsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C(C1(U)))))),A)><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyxK rp1_sdyxL rl1_sdyxM rp2_sdyxN rl2_sdyxO]
        let {
          ds_sdyxP [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_XdwdW a_adwNE b_adwNF)
          [LclId] =
              [$dRead2_sdyxK rp1_sdyxL rl1_sdyxM rp2_sdyxN rl2_sdyxO] \u []
                  let {
                    sat_sdyy1 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwNF]
                    [LclId] =
                        [rl2_sdyxO] \r [n_sdyxX w1_sdyxY]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl2_sdyxO w1_sdyxY
                            of
                            { Unit# ww1_sdyy0 [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyy0];
                            }; } in
                  let {
                    sat_sdyxW [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwNF
                    [LclId] =
                        [rp2_sdyxN] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                rp2_sdyxN eta_B1; } in
                  let {
                    sat_sdyxV [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwNE]
                    [LclId] =
                        [rl1_sdyxM] \r [n_sdyxR w1_sdyxS]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl1_sdyxM w1_sdyxS
                            of
                            { Unit# ww1_sdyxU [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyxU];
                            }; } in
                  let {
                    sat_sdyxQ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwNE
                    [LclId] =
                        [rp1_sdyxL] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp1_sdyxL eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadPrec2
                        $dRead2_sdyxK sat_sdyxQ sat_sdyxV sat_sdyxW sat_sdyy1; } in
        let {
          sat_sdyy4 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdwdW a_adwNE b_adwNF)
          [LclId] =
              [ds_sdyxP] \r [n_sdyy2]
                  let {
                    sat_sdyy3 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (f_XdwdW a_adwNE b_adwNF)
                    [LclId] =
                        [ds_sdyxP n_sdyy2] \u []
                            ds_sdyxP
                                n_sdyy2 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sdyy3;
        } in  sat_sdyy4;

Data.Functor.Classes.$dmliftShowList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C(C1(U))))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sdyy5 sp_sdyy6 sl_sdyy7]
        let {
          sat_sdyy8 [Occ=Once] :: f_adw9R a_adwNq -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdyy5 sp_sdyy6 sl_sdyy7] \u []
                  Data.Functor.Classes.liftShowsPrec
                      $dShow1_sdyy5
                      sp_sdyy6
                      sl_sdyy7
                      Data.Functor.Classes.$fRead1Identity5;
        } in  GHC.Show.showList__ sat_sdyy8;

Data.Functor.Classes.$w$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> [(a, a1)] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyy9 w1_sdyya w2_sdyyb w3_sdyyc]
        let {
          lvl3_sdyyd [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_sdxZ3 -> GHC.Show.ShowS
          [LclId] =
              [w_sdyy9] \u [] GHC.Show.showsPrec w_sdyy9; } in
        let {
          sat_sdyyi [Occ=Once] :: (a_sdxZ3, a1_sdxZ5) -> GHC.Show.ShowS
          [LclId] =
              [w1_sdyya lvl3_sdyyd] \r [eta_sdyye]
                  case eta_sdyye of {
                    (,) ww1_sdyyg [Occ=Once] ww2_sdyyh [Occ=Once] ->
                        Data.Functor.Classes.$w$cliftShowsPrec2
                            lvl3_sdyyd w1_sdyya ww1_sdyyg ww2_sdyyh;
                  };
        } in  GHC.Show.showList__ sat_sdyyi w2_sdyyb w3_sdyyc;

Data.Functor.Classes.$fShow1(,)_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS) -> [(a, a1)] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyyj w1_sdyyk w2_sdyyl w3_sdyym w4_sdyyn]
        Data.Functor.Classes.$w$cliftShowList
            w_sdyyj w1_sdyyk w3_sdyym w4_sdyyn;

Data.Functor.Classes.$fShow1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => Data.Functor.Classes.Show1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdyyo]
        let {
          sat_sdyyu [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS) -> [(a_adwQx, a)] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyyo] \r [w_sdyyq w1_sdyyr w2_sdyys w3_sdyyt]
                  Data.Functor.Classes.$w$cliftShowList
                      $dShow_sdyyo w_sdyyq w2_sdyys w3_sdyyt; } in
        let {
          sat_sdyyp [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> (a_adwQx, a)
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyyo] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
                      $dShow_sdyyo eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdyyp sat_sdyyu];

Data.Functor.Classes.$fShow1Proxy1
  :: forall a.
     Data.Proxy.Proxy a -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sdyyv eta_B1] Data.Functor.Classes.$fShow1Proxy2 eta_B1;

Data.Functor.Classes.$fShow1Proxy_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Proxy.Proxy a]
     -> GHC.Show.ShowS
[GblId, Arity=4, Str=<L,A><L,A><S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [sp_sdyyw sl_sdyyx eta_sdyyy eta1_sdyyz]
        GHC.Show.showList__
            Data.Functor.Classes.$fShow1Proxy1 eta_sdyyy eta1_sdyyz;

Data.Functor.Classes.$fShow1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Proxy_$cliftShowList];

Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [GHC.Base.NonEmpty a]
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C(U)))><L,C(C(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdyyA sl_sdyyB eta_sdyyC eta1_sdyyD]
        let {
          sat_sdyyI [Occ=Once] :: GHC.Base.NonEmpty a_adx0n -> GHC.Show.ShowS
          [LclId] =
              [sp_sdyyA sl_sdyyB] \r [w_sdyyE]
                  case w_sdyyE of {
                    GHC.Base.:| ww1_sdyyG [Occ=Once] ww2_sdyyH [Occ=Once] ->
                        Data.Functor.Classes.$w$cliftShowsPrec1
                            sp_sdyyA sl_sdyyB 0# ww1_sdyyG ww2_sdyyH;
                  };
        } in  GHC.Show.showList__ sat_sdyyI eta_sdyyC eta1_sdyyD;

Data.Functor.Classes.$fShow1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList];

Data.Functor.Classes.$fShow1[]_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [[a]] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [sp_sdyyJ sl_sdyyK eta_B2 eta_B1]
        GHC.Show.showList__ sl_sdyyK eta_B2 eta_B1;

Data.Functor.Classes.$fShow1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1[]_$cliftShowList];

$w$dmliftReadListPrec_rdymw
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadP.ReadP [f a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdyyL w1_sdyyM w2_sdyyN]
        let {
          w3_sdyyO [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [f_sdxZb a_sdxZd]
          [LclId] =
              [w_sdyyL w1_sdyyM w2_sdyyN] \u []
                  let {
                    sat_sdyyQ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxZd]
                    [LclId] =
                        [w2_sdyyN] \u []
                            w2_sdyyN
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdyyR [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxZd]
                    [LclId] =
                        [sat_sdyyQ] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdyyQ eta_B1; } in
                  let {
                    sat_sdyyP [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxZd
                    [LclId] =
                        [w1_sdyyM] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w1_sdyyM eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadList w_sdyyL sat_sdyyP sat_sdyyR; } in
        let {
          sat_sdyyV [Occ=Once]
            :: forall b.
               ([f_sdxZb a_sdxZd] -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w3_sdyyO] \r [w4_sdyyS]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w3_sdyyO w4_sdyyS
                  of
                  { Unit# ww1_sdyyU [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdyyU];
                  };
        } in  sat_sdyyV;

$dmliftReadListPrec3_rdymx
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [f a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdyyW w1_sdyyX w2_sdyyY w3_sdyyZ]
        $w$dmliftReadListPrec_rdymw w_sdyyW w1_sdyyX w2_sdyyY;

Data.Functor.Classes.$dmliftReadListPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        $dmliftReadListPrec3_rdymx eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$dmliftReadPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(C(U)))),A,A,A)><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyz0 rp_sdyz1 rl_sdyz2]
        let {
          f1_sdyz3 [Occ=OnceL!, Dmd=<L,C(C(U))>]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdweR a_adwMZ)
          [LclId] =
              [$dRead1_sdyz0 rp_sdyz1 rl_sdyz2] \u []
                  let {
                    sat_sdyz5 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adwMZ]
                    [LclId] =
                        [rl_sdyz2] \u []
                            rl_sdyz2
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdyz6 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adwMZ]
                    [LclId] =
                        [sat_sdyz5] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdyz5 eta_B1; } in
                  let {
                    sat_sdyz4 [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwMZ
                    [LclId] =
                        [rp_sdyz1] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S rp_sdyz1 eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdyz0 sat_sdyz4 sat_sdyz6; } in
        let {
          sat_sdyzd [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [f1_sdyz3] \r [n_sdyz7]
                  let {
                    w_sdyz8 [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS (f_XdweR a_adwMZ)
                    [LclId] =
                        [f1_sdyz3 n_sdyz7] \u [] f1_sdyz3 n_sdyz7; } in
                  let {
                    sat_sdyzc [Occ=OnceT[0]]
                      :: forall b.
                         (f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b)
                         -> Text.ParserCombinators.ReadP.P b
                    [LclId] =
                        [w_sdyz8] \r [w1_sdyz9]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdyz8 w1_sdyz9
                            of
                            { Unit# ww1_sdyzb [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyzb];
                            };
                  } in  sat_sdyzc;
        } in  sat_sdyzd;

Data.Functor.Classes.$dmliftReadList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C1(C(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyze rp_sdyzf rl_sdyzg]
        let {
          sat_sdyzo [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_XdweS a_adwMJ]
          [LclId] =
              [$dRead1_sdyze rp_sdyzf rl_sdyzg] \u []
                  let {
                    sat_sdyzn [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec (f_XdweS a_adwMJ)
                    [LclId] =
                        [$dRead1_sdyze rp_sdyzf rl_sdyzg] \s []
                            let {
                              sat_sdyzm [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwMJ]
                              [LclId] =
                                  [rl_sdyzg] \r [n_sdyzi w1_sdyzj]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl_sdyzg w1_sdyzj
                                      of
                                      { Unit# ww1_sdyzl [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdyzl];
                                      }; } in
                            let {
                              sat_sdyzh [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwMJ
                              [LclId] =
                                  [rp_sdyzf] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp_sdyzf eta_B1;
                            } in 
                              Data.Functor.Classes.liftReadPrec
                                  $dRead1_sdyze sat_sdyzh sat_sdyzm;
                  } in 
                    GHC.Read.list
                        sat_sdyzn
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyzo;

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [rp_sdyzp rl_sdyzq]
        let {
          f_sdyzr [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adx31
          [LclId, Arity=1, Unf=OtherCon []] =
              [rp_sdyzp] \r [eta_B1]
                  Text.ParserCombinators.ReadPrec.readPrec_to_S rp_sdyzp eta_B1; } in
        let {
          f1_sdyzs [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adx31]
          [LclId] =
              [rl_sdyzq] \u []
                  rl_sdyzq
                      Data.Functor.Classes.$fRead1Identity5
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          f2_sdyzt [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [a_adx31]
          [LclId, Arity=1, Unf=OtherCon []] =
              [f1_sdyzs] \r [eta_B1]
                  Text.ParserCombinators.ReadP.run f1_sdyzs eta_B1; } in
        let {
          sat_sdyzC [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (GHC.Base.NonEmpty a_adx31 -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [f_sdyzr f2_sdyzt] \r [n_sdyzu eta_sdyzv]
                  let {
                    sat_sdyzz [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_adx31)
                    [LclId] =
                        [f_sdyzr f2_sdyzt n_sdyzu] \r [w_sdyzw]
                            case n_sdyzu of {
                              GHC.Types.I# ww1_sdyzy [Occ=Once] ->
                                  Data.Functor.Classes.$w$cliftReadsPrec5
                                      f_sdyzr f2_sdyzt ww1_sdyzy w_sdyzw;
                            };
                  } in 
                    case
                        Text.ParserCombinators.ReadP.$wreadS_to_P sat_sdyzz eta_sdyzv
                    of
                    { Unit# ww1_sdyzB [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Look [ww1_sdyzB];
                    };
        } in  sat_sdyzC;

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.NonEmpty a]
[GblId, Arity=2, Str=<L,C(C(U))><L,C(U)>, Unf=OtherCon []] =
    [] \r [rp_sdyzD rl_sdyzE]
        let {
          sat_sdyzY [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [GHC.Base.NonEmpty a_adx2T]
          [LclId] =
              [rp_sdyzD rl_sdyzE] \u []
                  let {
                    f_sdyzF [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adx2T
                    [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                        [rp_sdyzD] \r [n_sdyzG]
                            let {
                              sat_sdyzK [Occ=Once] :: Text.ParserCombinators.ReadP.P a_adx2T
                              [LclId] =
                                  [rp_sdyzD n_sdyzG] \u []
                                      let {
                                        sat_sdyzH [Occ=Once, Dmd=<L,C(U)>]
                                          :: Text.ParserCombinators.ReadP.ReadS a_adx2T
                                        [LclId] =
                                            [rp_sdyzD n_sdyzG] \u [] rp_sdyzD n_sdyzG;
                                      } in 
                                        case
                                            Text.ParserCombinators.ReadP.$wreadS_to_P
                                                sat_sdyzH
                                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                        of
                                        { Unit# ww1_sdyzJ [Occ=Once] ->
                                              Text.ParserCombinators.ReadP.Look [ww1_sdyzJ];
                                        };
                            } in  Text.ParserCombinators.ReadP.run sat_sdyzK; } in
                  let {
                    f1_sdyzL [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adx2T]
                    [LclId] =
                        [rl_sdyzE] \u []
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P
                                    rl_sdyzE Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                            of
                            { Unit# ww1_sdyzN [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyzN];
                            }; } in
                  let {
                    f2_sdyzO [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adx2T]
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [f1_sdyzL] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run f1_sdyzL eta_B1; } in
                  let {
                    sat_sdyzX [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.NonEmpty a_adx2T)
                    [LclId] =
                        [f_sdyzF f2_sdyzO] \r [n_sdyzP eta_sdyzQ]
                            let {
                              sat_sdyzU [Occ=Once]
                                :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_adx2T)
                              [LclId] =
                                  [f_sdyzF f2_sdyzO n_sdyzP] \r [w_sdyzR]
                                      case n_sdyzP of {
                                        GHC.Types.I# ww1_sdyzT [Occ=Once] ->
                                            Data.Functor.Classes.$w$cliftReadsPrec5
                                                f_sdyzF f2_sdyzO ww1_sdyzT w_sdyzR;
                                      };
                            } in 
                              case
                                  Text.ParserCombinators.ReadP.$wreadS_to_P sat_sdyzU eta_sdyzQ
                              of
                              { Unit# ww1_sdyzW [Occ=Once] ->
                                    Text.ParserCombinators.ReadP.Look [ww1_sdyzW];
                              };
                  } in 
                    GHC.Read.list
                        sat_sdyzX
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyzY;

Data.Functor.Classes.$w$cliftReadListPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> forall b.
        ([GHC.Base.NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [w_sdyzZ w1_sdyA0]
        let {
          w2_sdyA1 [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [GHC.Base.NonEmpty a_sdxZp]
          [LclId] =
              [w_sdyzZ w1_sdyA0] \u []
                  let {
                    sat_sdyA3 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxZp]
                    [LclId] =
                        [w1_sdyA0] \u []
                            w1_sdyA0
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdyA4 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxZp]
                    [LclId] =
                        [sat_sdyA3] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdyA3 eta_B1; } in
                  let {
                    sat_sdyA2 [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxZp
                    [LclId] =
                        [w_sdyzZ] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w_sdyzZ eta_B1;
                  } in 
                    Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
                        sat_sdyA2 sat_sdyA4; } in
        let {
          sat_sdyA8 [Occ=OnceT[0]]
            :: forall b.
               ([GHC.Base.NonEmpty a_sdxZp] -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w2_sdyA1] \r [w3_sdyA5]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w2_sdyA1 w3_sdyA5
                  of
                  { Unit# ww1_sdyA7 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdyA7];
                  };
        } in  sat_sdyA8;

Data.Functor.Classes.$fRead1NonEmpty1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([GHC.Base.NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdyA9 w1_sdyAa w2_sdyAb]
        Data.Functor.Classes.$w$cliftReadListPrec2 w_sdyA9 w1_sdyAa;

Data.Functor.Classes.$fRead1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
                                                 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
                                                 Data.Functor.Classes.$fRead1NonEmpty1];

Data.Functor.Classes.$dmliftReadsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyAc rp_sdyAd rl_sdyAe]
        let {
          ds_sdyAf [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_XdweY a_adwMu)
          [LclId] =
              [$dRead1_sdyAc rp_sdyAd rl_sdyAe] \u []
                  let {
                    sat_sdyAl [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwMu]
                    [LclId] =
                        [rl_sdyAe] \r [n_sdyAh w1_sdyAi]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sdyAe w1_sdyAi
                            of
                            { Unit# ww1_sdyAk [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyAk];
                            }; } in
                  let {
                    sat_sdyAg [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwMu
                    [LclId] =
                        [rp_sdyAd] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sdyAd eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadPrec
                        $dRead1_sdyAc sat_sdyAg sat_sdyAl; } in
        let {
          sat_sdyAo [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdweY a_adwMu)
          [LclId] =
              [ds_sdyAf] \r [n_sdyAm]
                  let {
                    sat_sdyAn [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (f_XdweY a_adwMu)
                    [LclId] =
                        [ds_sdyAf n_sdyAm] \u []
                            ds_sdyAf
                                n_sdyAm Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sdyAn;
        } in  sat_sdyAo;

Data.Functor.Classes.eq1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) =>
     f a -> f a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sdyAp $dEq_sdyAq]
        let {
          sat_sdyAr [Occ=Once] :: a_adwMf -> a_adwMf -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdyAq] \u [] GHC.Classes.== $dEq_sdyAq;
        } in  $dEq1_sdyAp sat_sdyAr;

Data.Functor.Classes.compare1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) =>
     f a -> f a -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)),1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sdyAs $dOrd_sdyAt]
        let {
          sat_sdyAu [Occ=Once] :: a_adwM3 -> a_adwM3 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdyAt] \u [] GHC.Classes.compare $dOrd_sdyAt;
        } in  Data.Functor.Classes.liftCompare $dOrd1_sdyAs sat_sdyAu;

Data.Functor.Classes.readsPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLL),1*U(1*C1(C1(U)),A,A,A)><L,U(1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyAv $dRead_sdyAw]
        let {
          sat_sdyAy [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [a_adwLh]
          [LclId] =
              [$dRead_sdyAw] \u [] GHC.Read.readList $dRead_sdyAw; } in
        let {
          sat_sdyAx [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLh
          [LclId] =
              [$dRead_sdyAw] \u [] GHC.Read.readsPrec $dRead_sdyAw;
        } in 
          Data.Functor.Classes.liftReadsPrec
              $dRead1_sdyAv sat_sdyAx sat_sdyAy;

Data.Functor.Classes.readsUnary1
  :: forall (f :: * -> *) a t.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     GHC.Base.String
     -> (f a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyAz
           $dRead_sdyAA
           name_sdyAB
           cons_sdyAC
           kw_sdyAD
           s_sdyAE]
        case GHC.Base.eqString kw_sdyAD name_sdyAB of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdyAG [Occ=LoopBreaker]
                  :: [(f_adwLt a_adwLu, GHC.Base.String)]
                     -> [(t_adwLv, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdyAC go_sdyAG] \r [ds_sdyAH]
                        case ds_sdyAH of {
                          [] -> [] [];
                          : y_sdyAJ [Occ=Once!] ys_sdyAK [Occ=Once] ->
                              case y_sdyAJ of {
                                (,) x_sdyAM [Occ=Once] t1_sdyAN [Occ=Once] ->
                                    let {
                                      sat_sdyAQ [Occ=Once] :: [(t_adwLv, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdyAG ys_sdyAK] \u [] go_sdyAG ys_sdyAK; } in
                                    let {
                                      sat_sdyAO [Occ=Once] :: t_adwLv
                                      [LclId] =
                                          [cons_sdyAC x_sdyAM] \u [] cons_sdyAC x_sdyAM; } in
                                    let {
                                      sat_sdyAP [Occ=Once] :: (t_adwLv, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdyAO t1_sdyAN];
                                    } in  : [sat_sdyAP sat_sdyAQ];
                              };
                        }; } in
              let {
                sat_sdyAS [Occ=Once]
                  :: Text.ParserCombinators.ReadP.ReadS [a_adwLu]
                [LclId] =
                    [$dRead_sdyAA] \u [] GHC.Read.readList $dRead_sdyAA; } in
              let {
                sat_sdyAR [Occ=Once]
                  :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLu
                [LclId] =
                    [$dRead_sdyAA] \u [] GHC.Read.readsPrec $dRead_sdyAA;
              } in 
                case
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdyAz
                        sat_sdyAR
                        sat_sdyAS
                        Data.Functor.Classes.$fRead1Const1
                        s_sdyAE
                of
                sat_sdyAT
                { __DEFAULT -> go_sdyAG sat_sdyAT;
                };
        };

Data.Functor.Classes.readsBinary1
  :: forall (f :: * -> *) (g :: * -> *) a t.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Base.String
     -> (f a -> g a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(C(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><S,1*U><L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyAU
           $dRead2_sdyAV
           $dRead_sdyAW
           name_sdyAX
           cons_sdyAY
           kw_sdyAZ
           s_sdyB0]
        case GHC.Base.eqString kw_sdyAZ name_sdyAX of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                lvl3_sdyB2
                  :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLJ
                [LclId] =
                    [$dRead_sdyAW] \u [] GHC.Read.readsPrec $dRead_sdyAW; } in
              let {
                lvl4_sdyB3 :: Text.ParserCombinators.ReadP.ReadS [a_adwLJ]
                [LclId] =
                    [$dRead_sdyAW] \u [] GHC.Read.readList $dRead_sdyAW; } in
              let {
                go_sdyB4 [Occ=LoopBreaker]
                  :: [(f_adwLH a_adwLJ, GHC.Base.String)]
                     -> [(t_adwLK, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [$dRead2_sdyAV
                              cons_sdyAY
                              lvl3_sdyB2
                              lvl4_sdyB3
                              go_sdyB4] \r [ds_sdyB5]
                        case ds_sdyB5 of {
                          [] -> [] [];
                          : y_sdyB7 [Occ=Once!] ys_sdyB8 [Occ=Once] ->
                              case y_sdyB7 of {
                                (,) x_sdyBa [Occ=OnceL] t1_sdyBb [Occ=Once] ->
                                    let {
                                      z_sdyBc [Occ=OnceL] :: [(t_adwLK, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdyB4 ys_sdyB8] \u [] go_sdyB4 ys_sdyB8; } in
                                    let {
                                      go1_sdyBd [Occ=LoopBreaker]
                                        :: [(g_adwLI a_adwLJ, GHC.Base.String)]
                                           -> [(t_adwLK, GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [cons_sdyAY
                                                    x_sdyBa
                                                    z_sdyBc
                                                    go1_sdyBd] \r [ds1_sdyBe]
                                              case ds1_sdyBe of {
                                                [] -> z_sdyBc;
                                                : y1_sdyBg [Occ=Once!] ys1_sdyBh [Occ=Once] ->
                                                    case y1_sdyBg of {
                                                      (,) y2_sdyBj [Occ=Once] u_sdyBk [Occ=Once] ->
                                                          let {
                                                            sat_sdyBn [Occ=Once]
                                                              :: [(t_adwLK, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdyBd ys1_sdyBh] \u []
                                                                    go1_sdyBd ys1_sdyBh; } in
                                                          let {
                                                            sat_sdyBl [Occ=Once] :: t_adwLK
                                                            [LclId] =
                                                                [cons_sdyAY x_sdyBa y2_sdyBj] \u []
                                                                    cons_sdyAY
                                                                        x_sdyBa y2_sdyBj; } in
                                                          let {
                                                            sat_sdyBm [Occ=Once]
                                                              :: (t_adwLK, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sdyBl u_sdyBk];
                                                          } in  : [sat_sdyBm sat_sdyBn];
                                                    };
                                              };
                                    } in 
                                      case
                                          Data.Functor.Classes.liftReadsPrec
                                              $dRead2_sdyAV
                                              lvl3_sdyB2
                                              lvl4_sdyB3
                                              Data.Functor.Classes.$fRead1Const1
                                              t1_sdyBb
                                      of
                                      sat_sdyBo
                                      { __DEFAULT -> go1_sdyBd sat_sdyBo;
                                      };
                              };
                        };
              } in 
                case
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdyAU
                        lvl3_sdyB2
                        lvl4_sdyB3
                        Data.Functor.Classes.$fRead1Const1
                        s_sdyB0
                of
                sat_sdyBp
                { __DEFAULT -> go_sdyB4 sat_sdyBp;
                };
        };

Data.Functor.Classes.readPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyBq $dRead_sdyBr]
        let {
          sat_sdyBt [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwL4]
          [LclId] =
              [$dRead_sdyBr] \u [] GHC.Read.readListPrec $dRead_sdyBr; } in
        let {
          sat_sdyBs [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwL4
          [LclId] =
              [$dRead_sdyBr] \u [] GHC.Read.readPrec $dRead_sdyBr;
        } in 
          Data.Functor.Classes.liftReadPrec
              $dRead1_sdyBq sat_sdyBs sat_sdyBt;

Data.Functor.Classes.liftReadListDefault
  :: forall (f :: * -> *) a.
     Data.Functor.Classes.Read1 f =>
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyBu rp_sdyBv rl_sdyBw]
        let {
          sat_sdyBD [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_adwKQ a_adwKR]
          [LclId] =
              [$dRead1_sdyBu rp_sdyBv rl_sdyBw] \u []
                  let {
                    sat_sdyBC [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwKR]
                    [LclId] =
                        [rl_sdyBw] \r [n_sdyBy w1_sdyBz]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sdyBw w1_sdyBz
                            of
                            { Unit# ww1_sdyBB [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyBB];
                            }; } in
                  let {
                    sat_sdyBx [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwKR
                    [LclId] =
                        [rp_sdyBv] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sdyBv eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadListPrec
                        $dRead1_sdyBu
                        sat_sdyBx
                        sat_sdyBC
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyBD;

Data.Functor.Classes.liftReadListPrecDefault
  :: forall (f :: * -> *) a.
     Data.Functor.Classes.Read1 f =>
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C1(C(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyBE rp_sdyBF rl_sdyBG]
        let {
          sat_sdyBH [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_adwKH a_adwKI)
          [LclId] =
              [$dRead1_sdyBE rp_sdyBF rl_sdyBG] \s []
                  Data.Functor.Classes.liftReadPrec $dRead1_sdyBE rp_sdyBF rl_sdyBG;
        } in  GHC.Read.list sat_sdyBH;

lvl_rdymy
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Proxy.Proxy a]
[GblId] =
    [] \u [] GHC.Read.list Data.Functor.Classes.$fRead1Proxy1;

Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [Data.Proxy.Proxy a]
[GblId, Arity=2, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdyBI rl_sdyBJ] lvl_rdymy;

Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Proxy.Proxy a)
[GblId, Arity=3, Str=<L,A><L,A><L,U>, Unf=OtherCon []] =
    [] \r [rp_sdyBK rl_sdyBL n_sdyBM]
        let {
          sat_sdyBN [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Proxy.Proxy a_adx12)
          [LclId] =
              [n_sdyBM] \u []
                  GHC.Read.list3
                      Data.Functor.Classes.$fRead1Proxy2
                      n_sdyBM
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyBN;

lvl1_rdymz
  :: forall a. Text.ParserCombinators.ReadP.P [Data.Proxy.Proxy a]
[GblId] =
    [] \u []
        GHC.Read.list
            Data.Functor.Classes.$fRead1Proxy1
            Data.Functor.Classes.$fRead1Identity5
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

lvl2_rdymA
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS [Data.Proxy.Proxy a]
[GblId, Arity=1, Unf=OtherCon []] =
    sat-only [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run lvl1_rdymz eta_B1;

Data.Functor.Classes.$fRead1Proxy_$cliftReadList
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Proxy.Proxy a]
[GblId, Arity=3, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdyBO rl_sdyBP eta_B1] lvl2_rdymA eta_B1;

Data.Functor.Classes.$fRead1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Proxy_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Proxy5
                                                 Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec];

Data.Functor.Classes.$fRead1[]_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [[a]]
[GblId, Arity=2, Str=<L,A><L,1*C1(C(U))>, Unf=OtherCon []] =
    [] \r [rp_sdyBQ rl_sdyBR] GHC.Read.list rl_sdyBR;

Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,C(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [rp_sdyBS rl_sdyBT eta_sdyBU]
        let {
          sat_sdyBX [Occ=Once] :: Text.ParserCombinators.ReadP.P [a_adx3j]
          [LclId] =
              [rl_sdyBT] \u []
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P
                          rl_sdyBT Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                  of
                  { Unit# ww1_sdyBW [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdyBW];
                  };
        } in  Text.ParserCombinators.ReadP.run sat_sdyBX;

Data.Functor.Classes.$w$cliftReadList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [[a]]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [w_sdyBY]
        let {
          sat_sdyC4 [Occ=Once] :: Text.ParserCombinators.ReadP.P [[a_sdxZW]]
          [LclId] =
              [w_sdyBY] \u []
                  let {
                    sat_sdyC3 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_sdxZW]
                    [LclId] =
                        [w_sdyBY] \r [n_sdyBZ w1_sdyC0]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdyBY w1_sdyC0
                            of
                            { Unit# ww1_sdyC2 [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyC2];
                            };
                  } in 
                    GHC.Read.list
                        sat_sdyC3
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyC4;

Data.Functor.Classes.$fRead1[]_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [[a]]
[GblId, Arity=2, Str=<L,A><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_sdyC5 w1_sdyC6]
        Data.Functor.Classes.$w$cliftReadList2 w1_sdyC6;

Data.Functor.Classes.$fRead1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 []
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadList
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadPrec
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadListPrec];

Data.Functor.Classes.showsPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Types.Int -> f a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U(1*U,A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sdyC7 $dShow_sdyC8]
        let {
          sat_sdyCa [Occ=Once] :: [a_adwJB] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyC8] \u [] GHC.Show.showList $dShow_sdyC8; } in
        let {
          sat_sdyC9 [Occ=Once] :: GHC.Types.Int -> a_adwJB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyC8] \u [] GHC.Show.showsPrec $dShow_sdyC8;
        } in 
          Data.Functor.Classes.liftShowsPrec
              $dShow1_sdyC7 sat_sdyC9 sat_sdyCa;

Data.Functor.Classes.showsUnaryWith1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [' '#];

Data.Functor.Classes.$wshowsUnary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Prim.Int# -> f a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyCb w1_sdyCc w2_sdyCd ww_sdyCe w3_sdyCf]
        let {
          g_sdyCg [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyCb w1_sdyCc w3_sdyCf] \u []
                  let {
                    sat_sdyCi [Occ=Once] :: [a_sdy01] -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sdyCc] \u [] GHC.Show.showList w1_sdyCc; } in
                  let {
                    sat_sdyCh [Occ=Once] :: GHC.Types.Int -> a_sdy01 -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sdyCc] \u [] GHC.Show.showsPrec w1_sdyCc;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sdyCb
                        sat_sdyCh
                        sat_sdyCi
                        Data.Functor.Classes.$fRead1Const1
                        w3_sdyCf;
        } in 
          case ># [ww_sdyCe 10#] of {
            __DEFAULT ->
                let {
                  sat_sdyCn [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdyCd g_sdyCg] \r [x_sdyCk]
                          let {
                            sat_sdyCl [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdyCg x_sdyCk] \u [] g_sdyCg x_sdyCk; } in
                          let {
                            sat_sdyCm [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyCl];
                          } in  GHC.Base.++ w2_sdyCd sat_sdyCm;
                } in  sat_sdyCn;
            1# ->
                let {
                  sat_sdyCt [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdyCd g_sdyCg] \r [x_sdyCo]
                          let {
                            sat_sdyCs [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w2_sdyCd g_sdyCg x_sdyCo] \u []
                                    let {
                                      sat_sdyCq [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdyCg x_sdyCo] \u []
                                              let {
                                                sat_sdyCp [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdyCo];
                                              } in  g_sdyCg sat_sdyCp; } in
                                    let {
                                      sat_sdyCr [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyCq];
                                    } in  GHC.Base.++ w2_sdyCd sat_sdyCr;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdyCs];
                } in  sat_sdyCt;
          };

Data.Functor.Classes.showsUnary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Types.Int -> f a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyCu w1_sdyCv w2_sdyCw w3_sdyCx w4_sdyCy]
        case w3_sdyCx of {
          GHC.Types.I# ww1_sdyCA [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnary1
                  w_sdyCu w1_sdyCv w2_sdyCw ww1_sdyCA w4_sdyCy;
        };

Data.Functor.Classes.$wshowsBinary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Prim.Int# -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyCB
           w1_sdyCC
           w2_sdyCD
           w3_sdyCE
           ww_sdyCF
           w4_sdyCG
           w5_sdyCH]
        let {
          f1_sdyCI [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyCB w2_sdyCD w4_sdyCG] \u []
                  let {
                    sat_sdyCK [Occ=Once] :: [a_sdy0e] -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdyCD] \u [] GHC.Show.showList w2_sdyCD; } in
                  let {
                    sat_sdyCJ [Occ=Once] :: GHC.Types.Int -> a_sdy0e -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdyCD] \u [] GHC.Show.showsPrec w2_sdyCD;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sdyCB
                        sat_sdyCJ
                        sat_sdyCK
                        Data.Functor.Classes.$fRead1Const1
                        w4_sdyCG; } in
        let {
          g1_sdyCL [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdyCC w2_sdyCD w5_sdyCH] \u []
                  let {
                    sat_sdyCN [Occ=Once] :: [a_sdy0e] -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdyCD] \u [] GHC.Show.showList w2_sdyCD; } in
                  let {
                    sat_sdyCM [Occ=Once] :: GHC.Types.Int -> a_sdy0e -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdyCD] \u [] GHC.Show.showsPrec w2_sdyCD;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w1_sdyCC
                        sat_sdyCM
                        sat_sdyCN
                        Data.Functor.Classes.$fRead1Const1
                        w5_sdyCH;
        } in 
          case ># [ww_sdyCF 10#] of {
            __DEFAULT ->
                let {
                  sat_sdyCU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w3_sdyCE f1_sdyCI g1_sdyCL] \r [x_sdyCP]
                          let {
                            sat_sdyCS [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_sdyCI g1_sdyCL x_sdyCP] \u []
                                    let {
                                      sat_sdyCQ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g1_sdyCL x_sdyCP] \u [] g1_sdyCL x_sdyCP; } in
                                    let {
                                      sat_sdyCR [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyCQ];
                                    } in  f1_sdyCI sat_sdyCR; } in
                          let {
                            sat_sdyCT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyCS];
                          } in  GHC.Base.++ w3_sdyCE sat_sdyCT;
                } in  sat_sdyCU;
            1# ->
                let {
                  sat_sdyD2 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w3_sdyCE f1_sdyCI g1_sdyCL] \r [x_sdyCV]
                          let {
                            sat_sdyD1 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w3_sdyCE f1_sdyCI g1_sdyCL x_sdyCV] \u []
                                    let {
                                      sat_sdyCZ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_sdyCI g1_sdyCL x_sdyCV] \u []
                                              let {
                                                sat_sdyCX [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_sdyCL x_sdyCV] \u []
                                                        let {
                                                          sat_sdyCW [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdyCV];
                                                        } in  g1_sdyCL sat_sdyCW; } in
                                              let {
                                                sat_sdyCY [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [Data.Functor.Classes.showsUnaryWith1
                                                             sat_sdyCX];
                                              } in  f1_sdyCI sat_sdyCY; } in
                                    let {
                                      sat_sdyD0 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyCZ];
                                    } in  GHC.Base.++ w3_sdyCE sat_sdyD0;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdyD1];
                } in  sat_sdyD2;
          };

Data.Functor.Classes.showsBinary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Types.Int -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S(S),1*U(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyD3
           w1_sdyD4
           w2_sdyD5
           w3_sdyD6
           w4_sdyD7
           w5_sdyD8
           w6_sdyD9]
        case w4_sdyD7 of {
          GHC.Types.I# ww1_sdyDb [Occ=Once] ->
              Data.Functor.Classes.$wshowsBinary1
                  w_sdyD3 w1_sdyD4 w2_sdyD5 w3_sdyD6 ww1_sdyDb w5_sdyD8 w6_sdyD9;
        };

Data.Functor.Classes.eq2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Eq2 f, GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     f a b -> f a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*U(1*U,A)><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq2_sdyDc $dEq_sdyDd $dEq1_sdyDe]
        let {
          sat_sdyDg [Occ=Once] :: b_adwJk -> b_adwJk -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sdyDe] \u [] GHC.Classes.== $dEq1_sdyDe; } in
        let {
          sat_sdyDf [Occ=Once] :: a_adwJj -> a_adwJj -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdyDd] \u [] GHC.Classes.== $dEq_sdyDd;
        } in  $dEq2_sdyDc sat_sdyDf sat_sdyDg;

Data.Functor.Classes.compare2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Ord2 f, GHC.Classes.Ord a,
      GHC.Classes.Ord b) =>
     f a b -> f a b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,1*U(A,1*U,A,A,A,A,A,A)><L,1*U(A,1*U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd2_sdyDh $dOrd_sdyDi $dOrd1_sdyDj]
        let {
          sat_sdyDl [Occ=Once] :: b_adwJ2 -> b_adwJ2 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sdyDj] \u [] GHC.Classes.compare $dOrd1_sdyDj; } in
        let {
          sat_sdyDk [Occ=Once] :: a_adwJ1 -> a_adwJ1 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdyDi] \u [] GHC.Classes.compare $dOrd_sdyDi;
        } in 
          Data.Functor.Classes.liftCompare2 $dOrd2_sdyDh sat_sdyDk sat_sdyDl;

Data.Functor.Classes.readsPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Read2 f, GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(C(S))))LLL),1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><L,U(1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyDm $dRead_sdyDn $dRead1_sdyDo]
        let {
          sat_sdyDs [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [b_adwII]
          [LclId] =
              [$dRead1_sdyDo] \u [] GHC.Read.readList $dRead1_sdyDo; } in
        let {
          sat_sdyDr [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_adwII
          [LclId] =
              [$dRead1_sdyDo] \u [] GHC.Read.readsPrec $dRead1_sdyDo; } in
        let {
          sat_sdyDq [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [a_adwIH]
          [LclId] =
              [$dRead_sdyDn] \u [] GHC.Read.readList $dRead_sdyDn; } in
        let {
          sat_sdyDp [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwIH
          [LclId] =
              [$dRead_sdyDn] \u [] GHC.Read.readsPrec $dRead_sdyDn;
        } in 
          Data.Functor.Classes.liftReadsPrec2
              $dRead2_sdyDm sat_sdyDp sat_sdyDq sat_sdyDr sat_sdyDs;

Data.Functor.Classes.readPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Read2 f, GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U(A,A,1*U,1*U)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyDt $dRead_sdyDu $dRead1_sdyDv]
        let {
          sat_sdyDz [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwIo]
          [LclId] =
              [$dRead1_sdyDv] \u [] GHC.Read.readListPrec $dRead1_sdyDv; } in
        let {
          sat_sdyDy [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwIo
          [LclId] =
              [$dRead1_sdyDv] \u [] GHC.Read.readPrec $dRead1_sdyDv; } in
        let {
          sat_sdyDx [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwIn]
          [LclId] =
              [$dRead_sdyDu] \u [] GHC.Read.readListPrec $dRead_sdyDu; } in
        let {
          sat_sdyDw [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwIn
          [LclId] =
              [$dRead_sdyDu] \u [] GHC.Read.readPrec $dRead_sdyDu;
        } in 
          Data.Functor.Classes.liftReadPrec2
              $dRead2_sdyDt sat_sdyDw sat_sdyDx sat_sdyDy sat_sdyDz;

Data.Functor.Classes.liftReadList2Default
  :: forall (f :: * -> * -> *) a b.
     Data.Functor.Classes.Read2 f =>
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(C1(C1(C1(U)))))))><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyDA rp1_sdyDB rl1_sdyDC rp2_sdyDD rl2_sdyDE]
        let {
          sat_sdyDR [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_adwHZ a_adwI0 b_adwI1]
          [LclId] =
              [$dRead2_sdyDA rp1_sdyDB rl1_sdyDC rp2_sdyDD rl2_sdyDE] \u []
                  let {
                    sat_sdyDQ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwI1]
                    [LclId] =
                        [rl2_sdyDE] \r [n_sdyDM w1_sdyDN]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl2_sdyDE w1_sdyDN
                            of
                            { Unit# ww1_sdyDP [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyDP];
                            }; } in
                  let {
                    sat_sdyDL [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwI1
                    [LclId] =
                        [rp2_sdyDD] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                rp2_sdyDD eta_B1; } in
                  let {
                    sat_sdyDK [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwI0]
                    [LclId] =
                        [rl1_sdyDC] \r [n_sdyDG w1_sdyDH]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl1_sdyDC w1_sdyDH
                            of
                            { Unit# ww1_sdyDJ [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyDJ];
                            }; } in
                  let {
                    sat_sdyDF [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwI0
                    [LclId] =
                        [rp1_sdyDB] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp1_sdyDB eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadListPrec2
                        $dRead2_sdyDA
                        sat_sdyDF
                        sat_sdyDK
                        sat_sdyDL
                        sat_sdyDQ
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyDR;

Data.Functor.Classes.$fRead2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 Data.Either.Either
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2Either_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1Either8
                                                 Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2Either_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a b]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2Either eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2Const_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1Const6
                                                 Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2Const_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Const.Const a b]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2Const eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 (,)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2(,)_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1(,)2
                                                 Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2(,)_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [(a, b)]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2(,) eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.liftReadListPrec2Default
  :: forall (f :: * -> * -> *) a b.
     Data.Functor.Classes.Read2 f =>
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C1(C(U)))))),A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyDS rp1_sdyDT rl1_sdyDU rp2_sdyDV rl2_sdyDW]
        let {
          sat_sdyDX [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_adwHO a_adwHP b_adwHQ)
          [LclId] =
              [$dRead2_sdyDS rp1_sdyDT rl1_sdyDU rp2_sdyDV rl2_sdyDW] \s []
                  Data.Functor.Classes.liftReadPrec2
                      $dRead2_sdyDS rp1_sdyDT rl1_sdyDU rp2_sdyDV rl2_sdyDW;
        } in  GHC.Read.list sat_sdyDX;

Data.Functor.Classes.$fRead1(,)1
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a, a1) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdyDY eta_sdyDZ eta1_sdyE0 eta2_sdyE1 eta3_sdyE2]
        let {
          sat_sdyE3 [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwUw
          [LclId] =
              [$dRead_sdyDY] \u [] GHC.Read.readPrec $dRead_sdyDY;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec2
              sat_sdyE3 eta_sdyDZ eta2_sdyE1 eta3_sdyE2;

Data.Functor.Classes.$w$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (a, a1)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyE4 w1_sdyE5 w2_sdyE6]
        let {
          sat_sdyE9 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (a_sdy0L, a1_sdy0N)
          [LclId] =
              [w_sdyE4 w1_sdyE5 w2_sdyE6] \u []
                  let {
                    sat_sdyE8 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a1_sdy0N
                    [LclId] =
                        [w1_sdyE5] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdyE5 eta_B1; } in
                  let {
                    sat_sdyE7 [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy0L
                    [LclId] =
                        [w_sdyE4] \u [] GHC.Read.readPrec w_sdyE4;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec2
                        sat_sdyE7
                        sat_sdyE8
                        w2_sdyE6
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyE9;

Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyEa w1_sdyEb w2_sdyEc w3_sdyEd]
        Data.Functor.Classes.$w$cliftReadsPrec w_sdyEa w1_sdyEb w3_sdyEd;

Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [(a, a1)]
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdyEe rp_sdyEf rl_sdyEg]
        let {
          sat_sdyEh [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_XdwZz, a1_adwV6)
          [LclId] =
              [$dRead_sdyEe rp_sdyEf rl_sdyEg] \r [eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)1
                      $dRead_sdyEe rp_sdyEf rl_sdyEg eta_B2 eta_B1;
        } in  GHC.Read.list sat_sdyEh;

Data.Functor.Classes.$fRead1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => Data.Functor.Classes.Read1 ((,) a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdyEi]
        let {
          sat_sdyEp [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec [(a_XdwZy, a)]
          [LclId] =
              [$dRead_sdyEi] \r [eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
                      $dRead_sdyEi eta_B2 eta_B1; } in
        let {
          sat_sdyEo [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec (a_XdwZy, a)
          [LclId] =
              [$dRead_sdyEi] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)1
                      $dRead_sdyEi eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyEn [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS [(a_XdwZy, a)]
          [LclId] =
              [$dRead_sdyEi] \u []
                  Data.Functor.Classes.$fRead1(,)_$cliftReadList $dRead_sdyEi; } in
        let {
          sat_sdyEm [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (a_XdwZy, a)
          [LclId] =
              [$dRead_sdyEi] \r [w_sdyEj w1_sdyEk w2_sdyEl]
                  Data.Functor.Classes.$w$cliftReadsPrec
                      $dRead_sdyEi w_sdyEj w2_sdyEl;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdyEm
                                        sat_sdyEn
                                        sat_sdyEo
                                        sat_sdyEp];
Data.Functor.Classes.$fRead1(,)_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS [(a, a1)]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdyEq]
        let {
          sat_sdyEr [Occ=Once] :: Data.Functor.Classes.Read1 ((,) a_XdwZA)
          [LclId] =
              [$dRead_sdyEq] \u [] Data.Functor.Classes.$fRead1(,) $dRead_sdyEq;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdyEr;

Data.Functor.Classes.showsPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Show2 f, GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> f a b -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(C(S))))L),1*U(1*C1(C1(C1(C1(U)))),A)><L,U(1*U,A,1*U)><L,U(1*U,A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dShow2_sdyEs $dShow_sdyEt $dShow1_sdyEu]
        let {
          sat_sdyEy [Occ=Once] :: [b_adwHw] -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdyEu] \u [] GHC.Show.showList $dShow1_sdyEu; } in
        let {
          sat_sdyEx [Occ=Once] :: GHC.Types.Int -> b_adwHw -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdyEu] \u [] GHC.Show.showsPrec $dShow1_sdyEu; } in
        let {
          sat_sdyEw [Occ=Once] :: [a_adwHv] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyEt] \u [] GHC.Show.showList $dShow_sdyEt; } in
        let {
          sat_sdyEv [Occ=Once] :: GHC.Types.Int -> a_adwHv -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyEt] \u [] GHC.Show.showsPrec $dShow_sdyEt;
        } in 
          Data.Functor.Classes.liftShowsPrec2
              $dShow2_sdyEs sat_sdyEv sat_sdyEw sat_sdyEx sat_sdyEy;

Data.Functor.Classes.$wreadsData [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Prim.Int# -> GHC.Base.String -> [(a, GHC.Base.String)]
[GblId, Arity=3, Str=<L,C(C1(U))><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyEz ww_sdyEA w1_sdyEB]
        let {
          go_sdyEC [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_sdy11, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sdyEz go_sdyEC] \r [ds_sdyED]
                  case ds_sdyED of {
                    [] -> [] [];
                    : y_sdyEF [Occ=Once!] ys_sdyEG [Occ=Once] ->
                        case y_sdyEF of {
                          (,) kw_sdyEI [Occ=Once] s_sdyEJ [Occ=Once] ->
                              let {
                                sat_sdyEL [Occ=Once, Dmd=<L,1*U>] :: [(a_sdy11, GHC.Base.String)]
                                [LclId] =
                                    [go_sdyEC ys_sdyEG] \s [] go_sdyEC ys_sdyEG;
                              } in 
                                case w_sdyEz kw_sdyEI s_sdyEJ of sat_sdyEK {
                                  __DEFAULT -> GHC.Base.++ sat_sdyEK sat_sdyEL;
                                };
                        };
                  }; } in
        let {
          sat_sdyEQ [Occ=Once] :: Text.ParserCombinators.ReadP.ReadS a_sdy11
          [LclId] =
              [go_sdyEC] \r [r_sdyEO]
                  case
                      Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_sdyEO
                  of
                  sat_sdyEP
                  { __DEFAULT -> go_sdyEC sat_sdyEP;
                  };
        } in 
          case ># [ww_sdyEA 10#] of sat_sdyEM {
            __DEFAULT ->
                case tagToEnum# [sat_sdyEM] of sat_sdyEN {
                  __DEFAULT -> GHC.Read.readParen sat_sdyEN sat_sdyEQ w1_sdyEB;
                };
          };

Data.Functor.Classes.readsData [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyER w1_sdyES w2_sdyET]
        case w1_sdyES of {
          GHC.Types.I# ww1_sdyEV [Occ=Once] ->
              Data.Functor.Classes.$wreadsData w_sdyER ww1_sdyEV w2_sdyET;
        };

Data.Functor.Classes.readData2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

Data.Functor.Classes.readData1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [reader_sdyEW eta_sdyEX eta1_sdyEY]
        let {
          lvl3_sdyEZ [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_adwHc
          [LclId] =
              [reader_sdyEW] \u []
                  reader_sdyEW Data.Functor.Classes.readData2; } in
        let {
          sat_sdyF4 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwHc
          [LclId] =
              [lvl3_sdyEZ] \r [c_sdyF0]
                  case c_sdyF0 of {
                    GHC.Types.I# x_sdyF2 [Occ=Once] ->
                        case <=# [x_sdyF2 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
                          1# -> lvl3_sdyEZ;
                        };
                  };
        } in  GHC.Read.list3 sat_sdyF4 eta_sdyEX eta1_sdyEY;

Data.Functor.Classes.readData
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readData1 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.readsUnaryWith
  :: forall a t.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Base.String
     -> (a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [rp_sdyF5 name_sdyF6 cons_sdyF7 kw_sdyF8 s_sdyF9]
        case GHC.Base.eqString kw_sdyF8 name_sdyF6 of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdyFb [Occ=LoopBreaker]
                  :: [(a_adwH5, GHC.Base.String)] -> [(t_adwH6, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdyF7 go_sdyFb] \r [ds_sdyFc]
                        case ds_sdyFc of {
                          [] -> [] [];
                          : y_sdyFe [Occ=Once!] ys_sdyFf [Occ=Once] ->
                              case y_sdyFe of {
                                (,) x_sdyFh [Occ=Once] t1_sdyFi [Occ=Once] ->
                                    let {
                                      sat_sdyFl [Occ=Once] :: [(t_adwH6, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdyFb ys_sdyFf] \u [] go_sdyFb ys_sdyFf; } in
                                    let {
                                      sat_sdyFj [Occ=Once] :: t_adwH6
                                      [LclId] =
                                          [cons_sdyF7 x_sdyFh] \u [] cons_sdyF7 x_sdyFh; } in
                                    let {
                                      sat_sdyFk [Occ=Once] :: (t_adwH6, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdyFj t1_sdyFi];
                                    } in  : [sat_sdyFk sat_sdyFl];
                              };
                        };
              } in 
                case
                    rp_sdyF5 Data.Functor.Classes.$fRead1Const1 s_sdyF9
                of
                sat_sdyFm
                { __DEFAULT -> go_sdyFb sat_sdyFm;
                };
        };

Data.Functor.Classes.$wreadUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (t -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyFn w1_sdyFo w2_sdyFp w3_sdyFq w4_sdyFr]
        let {
          sat_sdyFB [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_sdy1t
          [LclId] =
              [w_sdyFn w2_sdyFp w3_sdyFq w4_sdyFr] \r [a1_sdyFt]
                  let {
                    sat_sdyFA [Occ=Once]
                      :: a_sdy1n -> Text.ParserCombinators.ReadP.P b_sdy1t
                    [LclId] =
                        [w2_sdyFp w4_sdyFr] \r [a2_sdyFy]
                            let {
                              sat_sdyFz [Occ=Once] :: t_sdy1o
                              [LclId] =
                                  [w2_sdyFp a2_sdyFy] \u [] w2_sdyFp a2_sdyFy;
                            } in  w4_sdyFr sat_sdyFz; } in
                  let {
                    sat_sdyFx [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec
                    [LclId] =
                        [w3_sdyFq] \u []
                            case w3_sdyFq of {
                              GHC.Types.I# x_sdyFv [Occ=Once] ->
                                  case +# [x_sdyFv 1#] of sat_sdyFw {
                                    __DEFAULT -> GHC.Types.I# [sat_sdyFw];
                                  };
                            };
                  } in  w_sdyFn sat_sdyFx sat_sdyFA; } in
        let {
          sat_sdyFs [Occ=Once] :: Text.Read.Lex.Lexeme
          [LclId] =
              CCCS Text.Read.Lex.Ident! [w1_sdyFo];
        } in  Text.Read.Lex.$wexpect sat_sdyFs sat_sdyFB;

Data.Functor.Classes.readUnaryWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (t -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_sdyFC w1_sdyFD w2_sdyFE w3_sdyFF w4_sdyFG]
        case
            Data.Functor.Classes.$wreadUnaryWith
                w_sdyFC w1_sdyFD w2_sdyFE w3_sdyFF w4_sdyFG
        of
        { Unit# ww1_sdyFI [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_sdyFI];
        };

Data.Functor.Classes.readUnaryWith
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.ReadPrec t
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readUnaryWith1
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead1Const5
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Const.Const a a1 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdyFJ eta_sdyFK eta1_sdyFL eta2_sdyFM eta3_sdyFN]
        let {
          sat_sdyFO [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwRr
          [LclId] =
              [$dRead_sdyFJ] \u [] GHC.Read.readPrec $dRead_sdyFJ;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec1
              sat_sdyFO eta2_sdyFM eta3_sdyFN;

Data.Functor.Classes.$w$cliftReadsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a a1)
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyFP w1_sdyFQ]
        let {
          sat_sdyFS [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Const.Const a_sdy1z a1_sdy1B)
          [LclId] =
              [w_sdyFP w1_sdyFQ] \u []
                  let {
                    sat_sdyFR [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1z
                    [LclId] =
                        [w_sdyFP] \u [] GHC.Read.readPrec w_sdyFP;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec1
                        sat_sdyFR
                        w1_sdyFQ
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyFS;

Data.Functor.Classes.$fRead1Const_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyFT w1_sdyFU w2_sdyFV w3_sdyFW]
        Data.Functor.Classes.$w$cliftReadsPrec1 w_sdyFT w3_sdyFW;

Data.Functor.Classes.$w$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Const.Const a a1]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [w_sdyFX]
        let {
          w1_sdyFY [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1G
          [LclId] =
              [w_sdyFX] \u [] GHC.Read.readPrec w_sdyFX; } in
        let {
          sat_sdyG1 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_sdy1G a1_sdy1I)
          [LclId] =
              [w1_sdyFY] \r [w2_sdyFZ w3_sdyG0]
                  Data.Functor.Classes.$w$cliftReadPrec1 w1_sdyFY w2_sdyFZ w3_sdyG0;
        } in  GHC.Read.list sat_sdyG1;

Data.Functor.Classes.$fRead1Const_$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Const.Const a a1]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdyG2 w1_sdyG3 w2_sdyG4]
        Data.Functor.Classes.$w$cliftReadListPrec w_sdyG2;

Data.Functor.Classes.$fRead1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     Data.Functor.Classes.Read1 (Data.Functor.Const.Const a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdyG5]
        let {
          lvl3_sdyG6 [Occ=OnceL]
            :: forall a1.
               Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Const.Const a_XdwZZ a1]
          [LclId] =
              [$dRead_sdyG5] \u []
                  Data.Functor.Classes.$w$cliftReadListPrec $dRead_sdyG5; } in
        let {
          sat_sdyGf [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Const.Const a_XdwZZ a]
          [LclId] =
              [lvl3_sdyG6] \r [w_sdyGd w1_sdyGe] lvl3_sdyG6; } in
        let {
          sat_sdyGc [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Const.Const a_XdwZZ a)
          [LclId] =
              [$dRead_sdyG5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1Const5
                      $dRead_sdyG5 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyGb [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Const.Const a_XdwZZ a]
          [LclId] =
              [$dRead_sdyG5] \u []
                  Data.Functor.Classes.$fRead1Const_$cliftReadList $dRead_sdyG5; } in
        let {
          sat_sdyGa [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Const.Const a_XdwZZ a)
          [LclId] =
              [$dRead_sdyG5] \r [w_sdyG7 w1_sdyG8 w2_sdyG9]
                  Data.Functor.Classes.$w$cliftReadsPrec1 $dRead_sdyG5 w2_sdyG9;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdyGa
                                        sat_sdyGb
                                        sat_sdyGc
                                        sat_sdyGf];
Data.Functor.Classes.$fRead1Const_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Const.Const a a1]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdyGg]
        let {
          sat_sdyGh [Occ=Once]
            :: Data.Functor.Classes.Read1 (Data.Functor.Const.Const a_Xdx00)
          [LclId] =
              [$dRead_sdyGg] \u []
                  Data.Functor.Classes.$fRead1Const $dRead_sdyGg;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdyGh;

Data.Functor.Classes.$fRead1Either7
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Either.Either a a1 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdyGi eta_sdyGj eta1_sdyGk eta2_sdyGl eta3_sdyGm]
        let {
          sat_sdyGn [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwSV
          [LclId] =
              [$dRead_sdyGi] \u [] GHC.Read.readPrec $dRead_sdyGi;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec3
              sat_sdyGn eta_sdyGj eta2_sdyGl eta3_sdyGm;

Data.Functor.Classes.$w$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a a1)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyGo w1_sdyGp w2_sdyGq]
        let {
          sat_sdyGt [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_sdy1O a1_sdy1Q)
          [LclId] =
              [w_sdyGo w1_sdyGp w2_sdyGq] \u []
                  let {
                    sat_sdyGs [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a1_sdy1Q
                    [LclId] =
                        [w1_sdyGp] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdyGp eta_B1; } in
                  let {
                    sat_sdyGr [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1O
                    [LclId] =
                        [w_sdyGo] \u [] GHC.Read.readPrec w_sdyGo;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec3
                        sat_sdyGr
                        sat_sdyGs
                        w2_sdyGq
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyGt;

Data.Functor.Classes.$fRead1Either_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyGu w1_sdyGv w2_sdyGw w3_sdyGx]
        Data.Functor.Classes.$w$cliftReadsPrec2 w_sdyGu w1_sdyGv w3_sdyGx;

Data.Functor.Classes.$w$cliftReadListPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a a1]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [w_sdyGy w1_sdyGz]
        let {
          w2_sdyGA [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1V
          [LclId] =
              [w_sdyGy] \u [] GHC.Read.readPrec w_sdyGy; } in
        let {
          sat_sdyGD [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_sdy1V a1_sdy1X)
          [LclId] =
              [w1_sdyGz w2_sdyGA] \r [w3_sdyGB w4_sdyGC]
                  Data.Functor.Classes.$w$cliftReadPrec3
                      w2_sdyGA w1_sdyGz w3_sdyGB w4_sdyGC;
        } in  GHC.Read.list sat_sdyGD;

Data.Functor.Classes.$fRead1Either_$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a a1]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdyGE w1_sdyGF w2_sdyGG]
        Data.Functor.Classes.$w$cliftReadListPrec1 w_sdyGE w1_sdyGF;

Data.Functor.Classes.$fRead1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     Data.Functor.Classes.Read1 (Data.Either.Either a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdyGH]
        let {
          sat_sdyGQ [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Either.Either a_XdwYA a]
          [LclId] =
              [$dRead_sdyGH] \r [w_sdyGO w1_sdyGP]
                  Data.Functor.Classes.$w$cliftReadListPrec1
                      $dRead_sdyGH w_sdyGO; } in
        let {
          sat_sdyGN [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Either.Either a_XdwYA a)
          [LclId] =
              [$dRead_sdyGH] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1Either7
                      $dRead_sdyGH eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyGM [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Either.Either a_XdwYA a]
          [LclId] =
              [$dRead_sdyGH] \u []
                  Data.Functor.Classes.$fRead1Either_$cliftReadList
                      $dRead_sdyGH; } in
        let {
          sat_sdyGL [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Either.Either a_XdwYA a)
          [LclId] =
              [$dRead_sdyGH] \r [w_sdyGI w1_sdyGJ w2_sdyGK]
                  Data.Functor.Classes.$w$cliftReadsPrec2
                      $dRead_sdyGH w_sdyGI w2_sdyGK;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdyGL
                                        sat_sdyGM
                                        sat_sdyGN
                                        sat_sdyGQ];
Data.Functor.Classes.$fRead1Either_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a a1]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdyGR]
        let {
          sat_sdyGS [Occ=Once]
            :: Data.Functor.Classes.Read1 (Data.Either.Either a_XdwYC)
          [LclId] =
              [$dRead_sdyGR] \u []
                  Data.Functor.Classes.$fRead1Either $dRead_sdyGR;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdyGS;

Data.Functor.Classes.$fRead1Identity4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity"#;

Data.Functor.Classes.$fRead1Identity3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Identity4;

Data.Functor.Classes.$fRead1Identity2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Identity3];

Data.Functor.Classes.$w$cliftReadPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyGT w1_sdyGU w2_sdyGV]
        let {
          sat_sdyH7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_sdy23)
          [LclId] =
              [w_sdyGT] \r [c_sdyGW eta_sdyGX]
                  case c_sdyGW of {
                    GHC.Types.I# x_sdyGZ [Occ=Once] ->
                        case <=# [x_sdyGZ 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdyH4 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_X81et
                                [LclId] =
                                    [w_sdyGT eta_sdyGX] \r [a1_sdyH1]
                                        let {
                                          sat_sdyH3 [Occ=Once]
                                            :: a_sdy23 -> Text.ParserCombinators.ReadP.P b1_X81et
                                          [LclId] =
                                              [eta_sdyGX] \r [a2_sdyH2] eta_sdyGX a2_sdyH2;
                                        } in  w_sdyGT Data.Functor.Classes.$fRead1Const1 sat_sdyH3;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Identity2 sat_sdyH4
                                of
                                { Unit# ww1_sdyH6 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sdyH6];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdyH7 w1_sdyGU w2_sdyGV;

Data.Functor.Classes.$fRead1Identity1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyH8 w1_sdyH9 w2_sdyHa w3_sdyHb]
        Data.Functor.Classes.$w$cliftReadPrec w_sdyH8 w2_sdyHa w3_sdyHb;

Data.Functor.Classes.$w$cliftReadsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId, Arity=2, Str=<L,1*C1(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyHc w1_sdyHd]
        let {
          sat_sdyHt [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Identity.Identity a_sdy2a)
          [LclId] =
              [w_sdyHc w1_sdyHd] \u []
                  let {
                    lvl3_sdyHe [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS a_sdy2a
                    [LclId] =
                        [w_sdyHc] \u [] w_sdyHc Data.Functor.Classes.$fRead1Const1; } in
                  let {
                    sat_sdyHs [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sdy2a)
                    [LclId] =
                        [lvl3_sdyHe] \r [c_sdyHf eta_sdyHg]
                            case c_sdyHf of {
                              GHC.Types.I# x_sdyHi [Occ=Once] ->
                                  case <=# [x_sdyHi 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdyHp [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_X81et
                                          [LclId] =
                                              [lvl3_sdyHe eta_sdyHg] \r [a1_sdyHk]
                                                  let {
                                                    sat_sdyHm [Occ=Once]
                                                      :: a_sdy2a
                                                         -> Text.ParserCombinators.ReadP.P b_X81et
                                                    [LclId] =
                                                        [eta_sdyHg] \r [a2_sdyHl]
                                                            eta_sdyHg a2_sdyHl;
                                                  } in 
                                                    case
                                                        Text.ParserCombinators.ReadP.$wreadS_to_P
                                                            lvl3_sdyHe sat_sdyHm
                                                    of
                                                    { Unit# ww1_sdyHo [Occ=Once] ->
                                                          Text.ParserCombinators.ReadP.Look [ww1_sdyHo];
                                                    };
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Identity2 sat_sdyHp
                                          of
                                          { Unit# ww1_sdyHr [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdyHr];
                                          };
                                  };
                            };
                  } in 
                    GHC.Read.list3
                        sat_sdyHs
                        w1_sdyHd
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyHt;

Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,A><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyHu w1_sdyHv w2_sdyHw]
        Data.Functor.Classes.$w$cliftReadsPrec3 w_sdyHu w2_sdyHw;

Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Identity.Identity a]
[GblId, Arity=2, Str=<L,C(C1(U))><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdyHx rl_sdyHy]
        let {
          sat_sdyHB [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_adx2c)
          [LclId] =
              [rp_sdyHx] \r [w_sdyHz w1_sdyHA]
                  Data.Functor.Classes.$w$cliftReadPrec rp_sdyHx w_sdyHz w1_sdyHA;
        } in  GHC.Read.list sat_sdyHB;

Data.Functor.Classes.$w$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Identity.Identity a]
[GblId, Arity=1, Str=<L,C(C(U))>, Unf=OtherCon []] =
    [] \r [w_sdyHC]
        let {
          sat_sdyHH [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_sdy2f]
          [LclId] =
              [w_sdyHC] \u []
                  let {
                    w1_sdyHD [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.Prec
                         -> forall b.
                            (a_sdy2f -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [w_sdyHC] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdyHC eta_B1; } in
                  let {
                    sat_sdyHG [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sdy2f)
                    [LclId] =
                        [w1_sdyHD] \r [w2_sdyHE w3_sdyHF]
                            Data.Functor.Classes.$w$cliftReadPrec w1_sdyHD w2_sdyHE w3_sdyHF;
                  } in 
                    GHC.Read.list
                        sat_sdyHG
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyHH;

Data.Functor.Classes.$fRead1Identity_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Identity.Identity a]
[GblId, Arity=2, Str=<L,C(C(U))><L,A>, Unf=OtherCon []] =
    [] \r [w_sdyHI w1_sdyHJ]
        Data.Functor.Classes.$w$cliftReadList w_sdyHI;

Data.Functor.Classes.$fRead1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Identity_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Identity1
                                                 Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec];

Data.Functor.Classes.$fRead1Maybe7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Nothing"#;

Data.Functor.Classes.$fRead1Maybe6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Maybe7;

Data.Functor.Classes.$fRead1Maybe_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Maybe6];

Data.Functor.Classes.$fRead1Maybe5
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [eta_sdyHK eta1_sdyHL]
        let {
          sat_sdyHN [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_i815E
          [LclId] =
              [eta1_sdyHL] \r [x_sdyHM] eta1_sdyHL GHC.Base.Nothing;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Functor.Classes.$fRead1Maybe_lexeme sat_sdyHN
          of
          { Unit# ww1_sdyHP [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sdyHP];
          };

Data.Functor.Classes.$fRead1Maybe4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Just"#;

Data.Functor.Classes.$fRead1Maybe3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Maybe4;

Data.Functor.Classes.$fRead1Maybe2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Maybe3];

Data.Functor.Classes.$w$cliftReadPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyHQ w1_sdyHR w2_sdyHS]
        let {
          sat_sdyI7 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sdy2n
          [LclId] =
              [w_sdyHQ w1_sdyHR w2_sdyHS] \u []
                  let {
                    sat_sdyI6 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.Maybe a_sdy2j)
                    [LclId] =
                        [w_sdyHQ] \r [c_sdyHU eta_sdyHV]
                            case c_sdyHU of {
                              GHC.Types.I# x_sdyHX [Occ=Once] ->
                                  case <=# [x_sdyHX 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdyI3 [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_X81c7
                                          [LclId] =
                                              [w_sdyHQ eta_sdyHV] \r [a1_sdyHZ]
                                                  let {
                                                    sat_sdyI2 [Occ=Once]
                                                      :: a_sdy2j
                                                         -> Text.ParserCombinators.ReadP.P b1_X81c7
                                                    [LclId] =
                                                        [eta_sdyHV] \r [a2_sdyI0]
                                                            let {
                                                              sat_sdyI1 [Occ=Once]
                                                                :: GHC.Base.Maybe a_sdy2j
                                                              [LclId] =
                                                                  CCCS GHC.Base.Just! [a2_sdyI0];
                                                            } in  eta_sdyHV sat_sdyI1;
                                                  } in 
                                                    w_sdyHQ
                                                        Data.Functor.Classes.$fRead1Const1
                                                        sat_sdyI2;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Maybe2 sat_sdyI3
                                          of
                                          { Unit# ww1_sdyI5 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdyI5];
                                          };
                                  };
                            };
                  } in  GHC.Read.list3 sat_sdyI6 w1_sdyHR w2_sdyHS;
        } in 
          case
              GHC.Read.list3 Data.Functor.Classes.$fRead1Maybe5 w1_sdyHR w2_sdyHS
          of
          sat_sdyHT
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_sdyHT sat_sdyI7;
          };

Data.Functor.Classes.$fRead1Maybe1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyI8 w1_sdyI9 w2_sdyIa w3_sdyIb]
        Data.Functor.Classes.$w$cliftReadPrec4 w_sdyI8 w2_sdyIa w3_sdyIb;

Data.Functor.Classes.$w$cliftReadsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.Maybe a)
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyIc w1_sdyId]
        let {
          sat_sdyIf [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (GHC.Base.Maybe a_sdy2q)
          [LclId] =
              [w_sdyIc w1_sdyId] \u []
                  let {
                    sat_sdyIe [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy2q
                    [LclId] =
                        [w_sdyIc] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdyIc eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec4
                        sat_sdyIe
                        w1_sdyId
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyIf;

Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.Maybe a)
[GblId, Arity=3, Str=<L,C(C(U))><L,A><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyIg w1_sdyIh w2_sdyIi]
        Data.Functor.Classes.$w$cliftReadsPrec4 w_sdyIg w2_sdyIi;

Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [GHC.Base.Maybe a]
[GblId, Arity=2, Str=<L,C(C1(U))><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdyIj rl_sdyIk]
        let {
          sat_sdyIn [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (GHC.Base.Maybe a_adx4t)
          [LclId] =
              [rp_sdyIj] \r [w_sdyIl w1_sdyIm]
                  Data.Functor.Classes.$w$cliftReadPrec4 rp_sdyIj w_sdyIl w1_sdyIm;
        } in  GHC.Read.list sat_sdyIn;

Data.Functor.Classes.$w$cliftReadList1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.Maybe a]
[GblId, Arity=1, Str=<L,C(C(U))>, Unf=OtherCon []] =
    [] \r [w_sdyIo]
        let {
          sat_sdyIt [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [GHC.Base.Maybe a_sdy2v]
          [LclId] =
              [w_sdyIo] \u []
                  let {
                    w1_sdyIp [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.Prec
                         -> forall b.
                            (a_sdy2v -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [w_sdyIo] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdyIo eta_B1; } in
                  let {
                    sat_sdyIs [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.Maybe a_sdy2v)
                    [LclId] =
                        [w1_sdyIp] \r [w2_sdyIq w3_sdyIr]
                            Data.Functor.Classes.$w$cliftReadPrec4 w1_sdyIp w2_sdyIq w3_sdyIr;
                  } in 
                    GHC.Read.list
                        sat_sdyIs
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyIt;

Data.Functor.Classes.$fRead1Maybe_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.Maybe a]
[GblId, Arity=2, Str=<L,C(C(U))><L,A>, Unf=OtherCon []] =
    [] \r [w_sdyIu w1_sdyIv]
        Data.Functor.Classes.$w$cliftReadList1 w_sdyIu;

Data.Functor.Classes.$fRead1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Maybe_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Maybe1
                                                 Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec];

Data.Functor.Classes.readsBinaryWith
  :: forall a b t.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Base.String
     -> (a -> b -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><S,1*U><L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [rp1_sdyIw rp2_sdyIx name_sdyIy cons_sdyIz kw_sdyIA s_sdyIB]
        case GHC.Base.eqString kw_sdyIA name_sdyIy of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdyID [Occ=LoopBreaker]
                  :: [(a_adwGC, GHC.Base.String)] -> [(t_adwGE, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [rp2_sdyIx cons_sdyIz go_sdyID] \r [ds_sdyIE]
                        case ds_sdyIE of {
                          [] -> [] [];
                          : y_sdyIG [Occ=Once!] ys_sdyIH [Occ=Once] ->
                              case y_sdyIG of {
                                (,) x_sdyIJ [Occ=OnceL] t1_sdyIK [Occ=Once] ->
                                    let {
                                      z_sdyIL [Occ=OnceL] :: [(t_adwGE, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdyID ys_sdyIH] \u [] go_sdyID ys_sdyIH; } in
                                    let {
                                      go1_sdyIM [Occ=LoopBreaker]
                                        :: [(b_adwGD, GHC.Base.String)]
                                           -> [(t_adwGE, GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [cons_sdyIz
                                                    x_sdyIJ
                                                    z_sdyIL
                                                    go1_sdyIM] \r [ds1_sdyIN]
                                              case ds1_sdyIN of {
                                                [] -> z_sdyIL;
                                                : y1_sdyIP [Occ=Once!] ys1_sdyIQ [Occ=Once] ->
                                                    case y1_sdyIP of {
                                                      (,) y2_sdyIS [Occ=Once] u_sdyIT [Occ=Once] ->
                                                          let {
                                                            sat_sdyIW [Occ=Once]
                                                              :: [(t_adwGE, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdyIM ys1_sdyIQ] \u []
                                                                    go1_sdyIM ys1_sdyIQ; } in
                                                          let {
                                                            sat_sdyIU [Occ=Once] :: t_adwGE
                                                            [LclId] =
                                                                [cons_sdyIz x_sdyIJ y2_sdyIS] \u []
                                                                    cons_sdyIz
                                                                        x_sdyIJ y2_sdyIS; } in
                                                          let {
                                                            sat_sdyIV [Occ=Once]
                                                              :: (t_adwGE, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sdyIU u_sdyIT];
                                                          } in  : [sat_sdyIV sat_sdyIW];
                                                    };
                                              };
                                    } in 
                                      case
                                          rp2_sdyIx Data.Functor.Classes.$fRead1Const1 t1_sdyIK
                                      of
                                      sat_sdyIX
                                      { __DEFAULT -> go1_sdyIM sat_sdyIX;
                                      };
                              };
                        };
              } in 
                case
                    rp1_sdyIw Data.Functor.Classes.$fRead1Const1 s_sdyIB
                of
                sat_sdyIY
                { __DEFAULT -> go_sdyID sat_sdyIY;
                };
        };

Data.Functor.Classes.$wreadBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (t -> Text.ParserCombinators.ReadP.P b1)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b1 #)
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyIZ w1_sdyJ0 w2_sdyJ1 w3_sdyJ2 w4_sdyJ3 w5_sdyJ4]
        let {
          sat_sdyJg [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b1_sdy2S
          [LclId] =
              [w_sdyIZ w1_sdyJ0 w3_sdyJ2 w4_sdyJ3 w5_sdyJ4] \r [a1_sdyJ6]
                  let {
                    lvl3_sdyJ7 :: Text.ParserCombinators.ReadPrec.Prec
                    [LclId] =
                        [w4_sdyJ3] \u []
                            case w4_sdyJ3 of {
                              GHC.Types.I# x_sdyJ9 [Occ=Once] ->
                                  case +# [x_sdyJ9 1#] of sat_sdyJa {
                                    __DEFAULT -> GHC.Types.I# [sat_sdyJa];
                                  };
                            }; } in
                  let {
                    sat_sdyJf [Occ=Once]
                      :: a_sdy2K -> Text.ParserCombinators.ReadP.P b1_sdy2S
                    [LclId] =
                        [w1_sdyJ0 w3_sdyJ2 w5_sdyJ4 lvl3_sdyJ7] \r [a2_sdyJb]
                            let {
                              sat_sdyJe [Occ=Once]
                                :: b_sdy2L -> Text.ParserCombinators.ReadP.P b1_sdy2S
                              [LclId] =
                                  [w3_sdyJ2 w5_sdyJ4 a2_sdyJb] \r [a3_sdyJc]
                                      let {
                                        sat_sdyJd [Occ=Once] :: t_sdy2M
                                        [LclId] =
                                            [w3_sdyJ2 a2_sdyJb a3_sdyJc] \u []
                                                w3_sdyJ2 a2_sdyJb a3_sdyJc;
                                      } in  w5_sdyJ4 sat_sdyJd;
                            } in  w1_sdyJ0 lvl3_sdyJ7 sat_sdyJe;
                  } in  w_sdyIZ lvl3_sdyJ7 sat_sdyJf; } in
        let {
          sat_sdyJ5 [Occ=Once] :: Text.Read.Lex.Lexeme
          [LclId] =
              CCCS Text.Read.Lex.Ident! [w2_sdyJ1];
        } in  Text.Read.Lex.$wexpect sat_sdyJ5 sat_sdyJg;

Data.Functor.Classes.readBinaryWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (t -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_sdyJh w1_sdyJi w2_sdyJj w3_sdyJk w4_sdyJl w5_sdyJm]
        case
            Data.Functor.Classes.$wreadBinaryWith
                w_sdyJh w1_sdyJi w2_sdyJj w3_sdyJk w4_sdyJl w5_sdyJm
        of
        { Unit# ww1_sdyJo [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_sdyJo];
        };

Data.Functor.Classes.readBinaryWith
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.ReadPrec t
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readBinaryWith1
            eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$wshowsUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> GHC.Base.String -> GHC.Prim.Int# -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyJp w1_sdyJq ww_sdyJr w2_sdyJs]
        let {
          g_sdyJt [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyJp w2_sdyJs] \u []
                  w_sdyJp Data.Functor.Classes.$fRead1Const1 w2_sdyJs;
        } in 
          case ># [ww_sdyJr 10#] of {
            __DEFAULT ->
                let {
                  sat_sdyJy [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdyJq g_sdyJt] \r [x_sdyJv]
                          let {
                            sat_sdyJw [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdyJt x_sdyJv] \u [] g_sdyJt x_sdyJv; } in
                          let {
                            sat_sdyJx [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyJw];
                          } in  GHC.Base.++ w1_sdyJq sat_sdyJx;
                } in  sat_sdyJy;
            1# ->
                let {
                  sat_sdyJE [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdyJq g_sdyJt] \r [x_sdyJz]
                          let {
                            sat_sdyJD [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w1_sdyJq g_sdyJt x_sdyJz] \u []
                                    let {
                                      sat_sdyJB [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdyJt x_sdyJz] \u []
                                              let {
                                                sat_sdyJA [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdyJz];
                                              } in  g_sdyJt sat_sdyJA; } in
                                    let {
                                      sat_sdyJC [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyJB];
                                    } in  GHC.Base.++ w1_sdyJq sat_sdyJC;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdyJD];
                } in  sat_sdyJE;
          };

Data.Functor.Classes.showsUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyJF w1_sdyJG w2_sdyJH w3_sdyJI]
        case w2_sdyJH of {
          GHC.Types.I# ww1_sdyJK [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  w_sdyJF w1_sdyJG ww1_sdyJK w3_sdyJI;
        };

Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Const.Const a b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(C(U)))><L,A><L,A><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdyJL ds_sdyJM ds1_sdyJN ds2_sdyJO d_sdyJP ds3_sdyJQ]
        case d_sdyJP of {
          GHC.Types.I# ww1_sdyJS [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  sp_sdyJL Data.Functor.Classes.$fRead1Const3 ww1_sdyJS ds3_sdyJQ;
        };

Data.Functor.Classes.$fShow2Const_$cliftShowList2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [Data.Functor.Const.Const a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,C(C1(C(U)))><L,A><L,A><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp1_sdyJT
           sl1_sdyJU
           sp2_sdyJV
           sl2_sdyJW
           eta_sdyJX
           eta1_sdyJY]
        let {
          sat_sdyK0 [Occ=Once]
            :: Data.Functor.Const.Const a_adwPE b_adwPF -> GHC.Show.ShowS
          [LclId] =
              [sp1_sdyJT] \r [ds_sdyJZ]
                  Data.Functor.Classes.$wshowsUnaryWith
                      sp1_sdyJT Data.Functor.Classes.$fRead1Const3 0# ds_sdyJZ;
        } in  GHC.Show.showList__ sat_sdyK0 eta_sdyJX eta1_sdyJY;

Data.Functor.Classes.$fShow2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2Const_$cliftShowList2];

Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Const.Const a a1
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,A><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdyK1 eta_sdyK2 eta1_sdyK3 eta2_sdyK4 eta3_sdyK5]
        case eta2_sdyK4 of {
          GHC.Types.I# ww1_sdyK7 [Occ=Once] ->
              let {
                sat_sdyK8 [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_adwP4 -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sdyK1] \s [] GHC.Show.showsPrec $dShow_sdyK1;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sdyK8 Data.Functor.Classes.$fRead1Const3 ww1_sdyK7 eta3_sdyK5;
        };

Data.Functor.Classes.$fShow1Const_$cliftShowList
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> [Data.Functor.Const.Const a a1]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,A><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdyK9 sp_sdyKa sl_sdyKb eta_sdyKc eta1_sdyKd]
        let {
          lvl3_sdyKe [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_adwP4 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyK9] \u [] GHC.Show.showsPrec $dShow_sdyK9; } in
        let {
          sat_sdyKg [Occ=Once]
            :: Data.Functor.Const.Const a_adwP4 a1_adwPn -> GHC.Show.ShowS
          [LclId] =
              [lvl3_sdyKe] \r [eta2_sdyKf]
                  Data.Functor.Classes.$wshowsUnaryWith
                      lvl3_sdyKe Data.Functor.Classes.$fRead1Const3 0# eta2_sdyKf;
        } in  GHC.Show.showList__ sat_sdyKg eta_sdyKc eta1_sdyKd;

Data.Functor.Classes.$fShow1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Classes.Show1 (Data.Functor.Const.Const a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdyKh]
        let {
          sat_sdyKj [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Const.Const a_adwP4 a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyKh] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Const_$cliftShowList
                      $dShow_sdyKh eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyKi [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Const.Const a_adwP4 a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyKh] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
                      $dShow_sdyKh eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdyKi sat_sdyKj];

Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Either.Either a b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [sp1_sdyKk ds_sdyKl ds1_sdyKm ds2_sdyKn d_sdyKo ds3_sdyKp]
        case ds3_sdyKp of {
          Data.Either.Left x_sdyKr [Occ=Once] ->
              case d_sdyKo of {
                GHC.Types.I# ww1_sdyKt [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        sp1_sdyKk Data.Functor.Classes.$fRead1Either5 ww1_sdyKt x_sdyKr;
              };
          Data.Either.Right x_sdyKu [Occ=Once] ->
              case d_sdyKo of {
                GHC.Types.I# ww1_sdyKw [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        ds1_sdyKm Data.Functor.Classes.$fRead1Either2 ww1_sdyKw x_sdyKu;
              };
        };

Data.Functor.Classes.$w$cliftShowList4 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> [Data.Either.Either a b]
     -> GHC.Base.String
     -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyKx w1_sdyKy w2_sdyKz w3_sdyKA]
        let {
          sat_sdyKF [Occ=Once]
            :: Data.Either.Either a_sdy38 b_sdy39 -> GHC.Show.ShowS
          [LclId] =
              [w_sdyKx w1_sdyKy] \r [ds_sdyKB]
                  case ds_sdyKB of {
                    Data.Either.Left x_sdyKD [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w_sdyKx Data.Functor.Classes.$fRead1Either5 0# x_sdyKD;
                    Data.Either.Right x_sdyKE [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w1_sdyKy Data.Functor.Classes.$fRead1Either2 0# x_sdyKE;
                  };
        } in  GHC.Show.showList__ sat_sdyKF w2_sdyKz w3_sdyKA;

Data.Functor.Classes.$fShow2Either_$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [Data.Either.Either a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,C(C1(C(U)))><L,A><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyKG w1_sdyKH w2_sdyKI w3_sdyKJ w4_sdyKK w5_sdyKL]
        Data.Functor.Classes.$w$cliftShowList4
            w_sdyKG w2_sdyKI w4_sdyKK w5_sdyKL;

Data.Functor.Classes.$fShow2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 Data.Either.Either
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2Either_$cliftShowList2];

Data.Functor.Classes.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> GHC.Prim.Int# -> Data.Either.Either a a1 -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdyKM w1_sdyKN ww_sdyKO w2_sdyKP]
        case w2_sdyKP of {
          Data.Either.Left x_sdyKR [Occ=Once] ->
              let {
                sat_sdyKS [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_sdy3h -> GHC.Show.ShowS
                [LclId] =
                    [w_sdyKM] \s [] GHC.Show.showsPrec w_sdyKM;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sdyKS Data.Functor.Classes.$fRead1Either5 ww_sdyKO x_sdyKR;
          Data.Either.Right x_sdyKT [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  w1_sdyKN Data.Functor.Classes.$fRead1Either2 ww_sdyKO x_sdyKT;
        };

Data.Functor.Classes.$fShow1Either_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Either.Either a a1
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdyKU w1_sdyKV w2_sdyKW w3_sdyKX w4_sdyKY]
        case w3_sdyKX of {
          GHC.Types.I# ww1_sdyL0 [Occ=Once] ->
              Data.Functor.Classes.$w$cliftShowsPrec
                  w_sdyKU w1_sdyKV ww1_sdyL0 w4_sdyKY;
        };

Data.Functor.Classes.$w$cliftShowList1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> [Data.Either.Either a a1] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyL1 w1_sdyL2 w2_sdyL3 w3_sdyL4]
        let {
          lvl3_sdyL5 [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_sdy3t -> GHC.Show.ShowS
          [LclId] =
              [w_sdyL1] \u [] GHC.Show.showsPrec w_sdyL1; } in
        let {
          sat_sdyLa [Occ=Once]
            :: Data.Either.Either a_sdy3t a1_sdy3v -> GHC.Show.ShowS
          [LclId] =
              [w1_sdyL2 lvl3_sdyL5] \r [eta_sdyL6]
                  case eta_sdyL6 of {
                    Data.Either.Left x_sdyL8 [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            lvl3_sdyL5 Data.Functor.Classes.$fRead1Either5 0# x_sdyL8;
                    Data.Either.Right x_sdyL9 [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w1_sdyL2 Data.Functor.Classes.$fRead1Either2 0# x_sdyL9;
                  };
        } in  GHC.Show.showList__ sat_sdyLa w2_sdyL3 w3_sdyL4;

Data.Functor.Classes.$fShow1Either_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> [Data.Either.Either a a1]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyLb w1_sdyLc w2_sdyLd w3_sdyLe w4_sdyLf]
        Data.Functor.Classes.$w$cliftShowList1
            w_sdyLb w1_sdyLc w3_sdyLe w4_sdyLf;

Data.Functor.Classes.$fShow1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Classes.Show1 (Data.Either.Either a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdyLg]
        let {
          sat_sdyLm [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Either.Either a_adwPN a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyLg] \r [w_sdyLi w1_sdyLj w2_sdyLk w3_sdyLl]
                  Data.Functor.Classes.$w$cliftShowList1
                      $dShow_sdyLg w_sdyLi w2_sdyLk w3_sdyLl; } in
        let {
          sat_sdyLh [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Either.Either a_adwPN a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyLg] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Either_$cliftShowsPrec
                      $dShow_sdyLg eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdyLh sat_sdyLm];

Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Identity.Identity a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdyLn ds_sdyLo d_sdyLp ds1_sdyLq]
        case d_sdyLp of {
          GHC.Types.I# ww1_sdyLs [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  sp_sdyLn Data.Functor.Classes.$fRead1Identity3 ww1_sdyLs ds1_sdyLq;
        };

Data.Functor.Classes.$fShow1Identity_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Identity.Identity a]
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdyLt sl_sdyLu eta_sdyLv eta1_sdyLw]
        let {
          sat_sdyLy [Occ=Once]
            :: Data.Functor.Identity.Identity a_adwZV -> GHC.Show.ShowS
          [LclId] =
              [sp_sdyLt] \r [ds_sdyLx]
                  Data.Functor.Classes.$wshowsUnaryWith
                      sp_sdyLt Data.Functor.Classes.$fRead1Identity3 0# ds_sdyLx;
        } in  GHC.Show.showList__ sat_sdyLy eta_sdyLv eta1_sdyLw;

Data.Functor.Classes.$fShow1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Identity_$cliftShowList];

Data.Functor.Classes.$fShow1Maybe1
  :: [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Base.++ Data.Functor.Classes.$fRead1Maybe6 eta_B1;

Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> GHC.Base.Maybe a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdyLz ds1_sdyLA ds2_sdyLB ds3_sdyLC]
        case ds3_sdyLC of {
          GHC.Base.Nothing -> Data.Functor.Classes.$fShow1Maybe1;
          GHC.Base.Just x_sdyLE [Occ=Once] ->
              case ds2_sdyLB of {
                GHC.Types.I# ww1_sdyLG [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        ds_sdyLz Data.Functor.Classes.$fRead1Maybe3 ww1_sdyLG x_sdyLE;
              };
        };

Data.Functor.Classes.$w$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> [GHC.Base.Maybe a] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=3,
 Str=<L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyLH w1_sdyLI w2_sdyLJ]
        let {
          sat_sdyLN [Occ=Once] :: GHC.Base.Maybe a_sdy3B -> GHC.Show.ShowS
          [LclId] =
              [w_sdyLH] \r [ds_sdyLK]
                  case ds_sdyLK of {
                    GHC.Base.Nothing -> Data.Functor.Classes.$fShow1Maybe1;
                    GHC.Base.Just x_sdyLM [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w_sdyLH Data.Functor.Classes.$fRead1Maybe3 0# x_sdyLM;
                  };
        } in  GHC.Show.showList__ sat_sdyLN w1_sdyLI w2_sdyLJ;

Data.Functor.Classes.$fShow1Maybe_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [GHC.Base.Maybe a] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyLO w1_sdyLP w2_sdyLQ w3_sdyLR]
        Data.Functor.Classes.$w$cliftShowList2 w_sdyLO w2_sdyLQ w3_sdyLR;

Data.Functor.Classes.$fShow1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Maybe_$cliftShowList];

Data.Functor.Classes.$wshowsBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> GHC.Base.String
     -> GHC.Prim.Int#
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyLS w1_sdyLT w2_sdyLU ww_sdyLV w3_sdyLW w4_sdyLX]
        let {
          f_sdyLY [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyLS w3_sdyLW] \u []
                  w_sdyLS Data.Functor.Classes.$fRead1Const1 w3_sdyLW; } in
        let {
          g_sdyLZ [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdyLT w4_sdyLX] \u []
                  w1_sdyLT Data.Functor.Classes.$fRead1Const1 w4_sdyLX;
        } in 
          case ># [ww_sdyLV 10#] of {
            __DEFAULT ->
                let {
                  sat_sdyM6 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdyLU f_sdyLY g_sdyLZ] \r [x_sdyM1]
                          let {
                            sat_sdyM4 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sdyLY g_sdyLZ x_sdyM1] \u []
                                    let {
                                      sat_sdyM2 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdyLZ x_sdyM1] \u [] g_sdyLZ x_sdyM1; } in
                                    let {
                                      sat_sdyM3 [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyM2];
                                    } in  f_sdyLY sat_sdyM3; } in
                          let {
                            sat_sdyM5 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyM4];
                          } in  GHC.Base.++ w2_sdyLU sat_sdyM5;
                } in  sat_sdyM6;
            1# ->
                let {
                  sat_sdyMe [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdyLU f_sdyLY g_sdyLZ] \r [x_sdyM7]
                          let {
                            sat_sdyMd [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w2_sdyLU f_sdyLY g_sdyLZ x_sdyM7] \u []
                                    let {
                                      sat_sdyMb [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sdyLY g_sdyLZ x_sdyM7] \u []
                                              let {
                                                sat_sdyM9 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sdyLZ x_sdyM7] \u []
                                                        let {
                                                          sat_sdyM8 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdyM7];
                                                        } in  g_sdyLZ sat_sdyM8; } in
                                              let {
                                                sat_sdyMa [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [Data.Functor.Classes.showsUnaryWith1
                                                             sat_sdyM9];
                                              } in  f_sdyLY sat_sdyMa; } in
                                    let {
                                      sat_sdyMc [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyMb];
                                    } in  GHC.Base.++ w2_sdyLU sat_sdyMc;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdyMd];
                } in  sat_sdyMe;
          };

Data.Functor.Classes.showsBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> GHC.Base.String
     -> GHC.Types.Int
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><S(S),1*U(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyMf w1_sdyMg w2_sdyMh w3_sdyMi w4_sdyMj w5_sdyMk]
        case w3_sdyMi of {
          GHC.Types.I# ww1_sdyMm [Occ=Once] ->
              Data.Functor.Classes.$wshowsBinaryWith
                  w_sdyMf w1_sdyMg w2_sdyMh ww1_sdyMm w4_sdyMj w5_sdyMk;
        };

Data.Functor.Classes.readsUnary
  :: forall a t.
     GHC.Read.Read a =>
     GHC.Base.String
     -> (a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A,A)><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdyMn name_sdyMo cons_sdyMp kw_sdyMq s_sdyMr]
        case GHC.Base.eqString kw_sdyMq name_sdyMo of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdyMt [Occ=LoopBreaker]
                  :: [(a_adwFr, GHC.Base.String)] -> [(t_adwFs, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdyMp go_sdyMt] \r [ds_sdyMu]
                        case ds_sdyMu of {
                          [] -> [] [];
                          : y_sdyMw [Occ=Once!] ys_sdyMx [Occ=Once] ->
                              case y_sdyMw of {
                                (,) x_sdyMz [Occ=Once] t1_sdyMA [Occ=Once] ->
                                    let {
                                      sat_sdyMD [Occ=Once] :: [(t_adwFs, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdyMt ys_sdyMx] \u [] go_sdyMt ys_sdyMx; } in
                                    let {
                                      sat_sdyMB [Occ=Once] :: t_adwFs
                                      [LclId] =
                                          [cons_sdyMp x_sdyMz] \u [] cons_sdyMp x_sdyMz; } in
                                    let {
                                      sat_sdyMC [Occ=Once] :: (t_adwFs, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdyMB t1_sdyMA];
                                    } in  : [sat_sdyMC sat_sdyMD];
                              };
                        };
              } in 
                case
                    GHC.Read.readsPrec
                        $dRead_sdyMn Data.Functor.Classes.$fRead1Const1 s_sdyMr
                of
                sat_sdyME
                { __DEFAULT -> go_sdyMt sat_sdyME;
                };
        };

Data.Functor.Classes.$wshowsUnary [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Base.String -> GHC.Prim.Int# -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyMF w1_sdyMG ww_sdyMH w2_sdyMI]
        let {
          g_sdyMJ [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyMF w2_sdyMI] \u []
                  GHC.Show.showsPrec
                      w_sdyMF Data.Functor.Classes.$fRead1Const1 w2_sdyMI;
        } in 
          case ># [ww_sdyMH 10#] of {
            __DEFAULT ->
                let {
                  sat_sdyMO [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdyMG g_sdyMJ] \r [x_sdyML]
                          let {
                            sat_sdyMM [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdyMJ x_sdyML] \u [] g_sdyMJ x_sdyML; } in
                          let {
                            sat_sdyMN [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyMM];
                          } in  GHC.Base.++ w1_sdyMG sat_sdyMN;
                } in  sat_sdyMO;
            1# ->
                let {
                  sat_sdyMU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdyMG g_sdyMJ] \r [x_sdyMP]
                          let {
                            sat_sdyMT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w1_sdyMG g_sdyMJ x_sdyMP] \u []
                                    let {
                                      sat_sdyMR [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdyMJ x_sdyMP] \u []
                                              let {
                                                sat_sdyMQ [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdyMP];
                                              } in  g_sdyMJ sat_sdyMQ; } in
                                    let {
                                      sat_sdyMS [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyMR];
                                    } in  GHC.Base.++ w1_sdyMG sat_sdyMS;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdyMT];
                } in  sat_sdyMU;
          };

Data.Functor.Classes.showsUnary [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyMV w1_sdyMW w2_sdyMX w3_sdyMY]
        case w2_sdyMX of {
          GHC.Types.I# ww1_sdyN0 [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnary
                  w_sdyMV w1_sdyMW ww1_sdyN0 w3_sdyMY;
        };

Data.Functor.Classes.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Classes.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$trModule4];

Data.Functor.Classes.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Classes"#;

Data.Functor.Classes.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$trModule2];

Data.Functor.Classes.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Classes.$trModule3
                                     Data.Functor.Classes.$trModule1];

$krep_rdymB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Functor.Classes.$tcEq4 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rdymB];

Data.Functor.Classes.$tcEq7 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdymB];

Data.Functor.Classes.$tcEq6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Eq1"#;

Data.Functor.Classes.$tcEq5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcEq6];

Data.Functor.Classes.$tcEq1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [71749974434880567##
                                    7233443027070644957##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcEq5
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcOrd5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ord1"#;

Data.Functor.Classes.$tcOrd4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcOrd5];

Data.Functor.Classes.$tcOrd1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11825914698899667233##
                                    4554948325937498991##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcOrd4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcRead5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Read1"#;

Data.Functor.Classes.$tcRead4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcRead5];

Data.Functor.Classes.$tcRead1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14547308444716217043##
                                    925634574698086715##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcRead4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcShow5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Show1"#;

Data.Functor.Classes.$tcShow4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcShow5];

Data.Functor.Classes.$tcShow1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4743290066722511112##
                                    6779909240154408836##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcShow4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcEq9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Eq2"#;

Data.Functor.Classes.$tcEq8 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcEq9];

Data.Functor.Classes.$tcEq2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16920549266159426738##
                                    13264288076834164909##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcEq8
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcOrd7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ord2"#;

Data.Functor.Classes.$tcOrd6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcOrd7];

Data.Functor.Classes.$tcOrd2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4167316048525678806##
                                    17649124474771181823##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcOrd6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcRead7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Read2"#;

Data.Functor.Classes.$tcRead6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcRead7];

Data.Functor.Classes.$tcRead2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [615267248700376470##
                                    8978126042197021701##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcRead6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcShow7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Show2"#;

Data.Functor.Classes.$tcShow6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcShow7];

Data.Functor.Classes.$tcShow2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11321900378419812635##
                                    1323607160578303441##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcShow6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.C:Show2
  :: forall (f :: * -> * -> *).
     (forall a b.
      (GHC.Types.Int -> a -> GHC.Show.ShowS)
      -> ([a] -> GHC.Show.ShowS)
      -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
      -> ([b] -> GHC.Show.ShowS)
      -> GHC.Types.Int
      -> f a b
      -> GHC.Show.ShowS)
     -> (forall a b.
         (GHC.Types.Int -> a -> GHC.Show.ShowS)
         -> ([a] -> GHC.Show.ShowS)
         -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
         -> ([b] -> GHC.Show.ShowS)
         -> [f a b]
         -> GHC.Show.ShowS)
     -> Data.Functor.Classes.Show2 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Show2 [eta_B2 eta_B1];

Data.Functor.Classes.C:Read2
  :: forall (f :: * -> * -> *).
     (forall a b.
      (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
      -> Text.ParserCombinators.ReadP.ReadS [a]
      -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
      -> Text.ParserCombinators.ReadP.ReadS [b]
      -> GHC.Types.Int
      -> Text.ParserCombinators.ReadP.ReadS (f a b))
     -> (forall a b.
         (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
         -> Text.ParserCombinators.ReadP.ReadS [a]
         -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
         -> Text.ParserCombinators.ReadP.ReadS [b]
         -> Text.ParserCombinators.ReadP.ReadS [f a b])
     -> (forall a b.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec b
         -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
         -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b))
     -> (forall a b.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec b
         -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
         -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b])
     -> Data.Functor.Classes.Read2 f
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.C:Read2 [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Functor.Classes.C:Ord2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Eq2 f =>
     (forall a b c d.
      (a -> b -> GHC.Types.Ordering)
      -> (c -> d -> GHC.Types.Ordering)
      -> f a c
      -> f b d
      -> GHC.Types.Ordering)
     -> Data.Functor.Classes.Ord2 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Ord2 [eta_B2 eta_B1];

Data.Functor.Classes.C:Show1
  :: forall (f :: * -> *).
     (forall a.
      (GHC.Types.Int -> a -> GHC.Show.ShowS)
      -> ([a] -> GHC.Show.ShowS)
      -> GHC.Types.Int
      -> f a
      -> GHC.Show.ShowS)
     -> (forall a.
         (GHC.Types.Int -> a -> GHC.Show.ShowS)
         -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS)
     -> Data.Functor.Classes.Show1 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Show1 [eta_B2 eta_B1];

Data.Functor.Classes.C:Read1
  :: forall (f :: * -> *).
     (forall a.
      (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
      -> Text.ParserCombinators.ReadP.ReadS [a]
      -> GHC.Types.Int
      -> Text.ParserCombinators.ReadP.ReadS (f a))
     -> (forall a.
         (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
         -> Text.ParserCombinators.ReadP.ReadS [a]
         -> Text.ParserCombinators.ReadP.ReadS [f a])
     -> (forall a.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec (f a))
     -> (forall a.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec [f a])
     -> Data.Functor.Classes.Read1 f
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.C:Read1 [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Functor.Classes.C:Ord1
  :: forall (f :: * -> *).
     Data.Functor.Classes.Eq1 f =>
     (forall a b.
      (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering)
     -> Data.Functor.Classes.Ord1 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Ord1 [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:08:43.342709791 UTC

Data.Functor.Classes.liftShowsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> f a b
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdymD]
        case v_sdymD of {
          Data.Functor.Classes.C:Show2 v_sdymF [Occ=Once] _ [Occ=Dead] ->
              v_sdymF;
        };

Data.Functor.Classes.liftShowList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [f a b]
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdymH]
        case v_sdymH of {
          Data.Functor.Classes.C:Show2 _ [Occ=Dead] v_sdymK [Occ=Once] ->
              v_sdymK;
        };

Data.Functor.Classes.liftReadsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdymL]
        case v_sdymL of {
          Data.Functor.Classes.C:Read2 v_sdymN [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdymN;
        };

Data.Functor.Classes.liftReadList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdymR]
        case v_sdymR of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       v_sdymU [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdymU;
        };

Data.Functor.Classes.liftReadPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdymX]
        case v_sdymX of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdyn1 [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdyn1;
        };

Data.Functor.Classes.liftReadListPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdyn3]
        case v_sdyn3 of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdyn8 [Occ=Once] ->
              v_sdyn8;
        };

Data.Functor.Classes.$p1Ord2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Ord2 f =>
     Data.Functor.Classes.Eq2 f
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdyn9]
        case v_sdyn9 of {
          Data.Functor.Classes.C:Ord2 v_sdynb [Occ=Once] _ [Occ=Dead] ->
              v_sdynb;
        };

Data.Functor.Classes.liftCompare2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Ord2 f =>
     forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> f a c
     -> f b d
     -> GHC.Types.Ordering
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdynd]
        case v_sdynd of {
          Data.Functor.Classes.C:Ord2 _ [Occ=Dead] v_sdyng [Occ=Once] ->
              v_sdyng;
        };

Data.Functor.Classes.liftEq2 [InlPrag=INLINE]
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Eq2 f =>
     forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool) -> f a c -> f b d -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sdynh] v_sdynh;

Data.Functor.Classes.liftShowsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> f a
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdyni]
        case v_sdyni of {
          Data.Functor.Classes.C:Show1 v_sdynk [Occ=Once] _ [Occ=Dead] ->
              v_sdynk;
        };

Data.Functor.Classes.liftShowList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdynm]
        case v_sdynm of {
          Data.Functor.Classes.C:Show1 _ [Occ=Dead] v_sdynp [Occ=Once] ->
              v_sdynp;
        };

Data.Functor.Classes.liftReadsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdynq]
        case v_sdynq of {
          Data.Functor.Classes.C:Read1 v_sdyns [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdyns;
        };

Data.Functor.Classes.liftReadList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdynw]
        case v_sdynw of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       v_sdynz [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdynz;
        };

Data.Functor.Classes.liftReadPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdynC]
        case v_sdynC of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdynG [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdynG;
        };

Data.Functor.Classes.liftReadListPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdynI]
        case v_sdynI of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdynN [Occ=Once] ->
              v_sdynN;
        };

Data.Functor.Classes.$p1Ord1
  :: forall (f :: * -> *).
     Data.Functor.Classes.Ord1 f =>
     Data.Functor.Classes.Eq1 f
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdynO]
        case v_sdynO of {
          Data.Functor.Classes.C:Ord1 v_sdynQ [Occ=Once] _ [Occ=Dead] ->
              v_sdynQ;
        };

Data.Functor.Classes.liftCompare
  :: forall (f :: * -> *).
     Data.Functor.Classes.Ord1 f =>
     forall a b.
     (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdynS]
        case v_sdynS of {
          Data.Functor.Classes.C:Ord1 _ [Occ=Dead] v_sdynV [Occ=Once] ->
              v_sdynV;
        };

Data.Functor.Classes.liftEq [InlPrag=INLINE]
  :: forall (f :: * -> *).
     Data.Functor.Classes.Eq1 f =>
     forall a b.
     (a -> b -> GHC.Types.Bool) -> f a -> f b -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sdynW] v_sdynW;

Data.Functor.Classes.$fRead1Const1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Classes.$fRead1Const4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Const"#;

Data.Functor.Classes.$fRead1Const3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Const4;

Data.Functor.Classes.$fRead1Const2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Const3];

Data.Functor.Classes.$w$cliftReadPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Functor.Const.Const a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdynX w1_sdynY w2_sdynZ]
        let {
          sat_sdyob [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_sdxVk b_sdxVl)
          [LclId] =
              [w_sdynX] \r [c_sdyo0 eta_sdyo1]
                  case c_sdyo0 of {
                    GHC.Types.I# x_sdyo3 [Occ=Once] ->
                        case <=# [x_sdyo3 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdyo8 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_X81aZ
                                [LclId] =
                                    [w_sdynX eta_sdyo1] \r [a1_sdyo5]
                                        let {
                                          sat_sdyo7 [Occ=Once]
                                            :: a_sdxVk -> Text.ParserCombinators.ReadP.P b2_X81aZ
                                          [LclId] =
                                              [eta_sdyo1] \r [a2_sdyo6] eta_sdyo1 a2_sdyo6;
                                        } in  w_sdynX Data.Functor.Classes.$fRead1Const1 sat_sdyo7;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Const2 sat_sdyo8
                                of
                                { Unit# ww1_sdyoa [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sdyoa];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdyob w1_sdynY w2_sdynZ;

Data.Functor.Classes.$fRead1Const6 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Functor.Const.Const a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,A><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyoc w1_sdyod w2_sdyoe w3_sdyof w4_sdyog w5_sdyoh]
        Data.Functor.Classes.$w$cliftReadPrec1 w_sdyoc w4_sdyog w5_sdyoh;

Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Const.Const a b]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdyoi rl1_sdyoj rp2_sdyok rl2_sdyol]
        let {
          sat_sdyoo [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_adwSL b_adwSM)
          [LclId] =
              [rp1_sdyoi] \r [w_sdyom w1_sdyon]
                  Data.Functor.Classes.$w$cliftReadPrec1 rp1_sdyoi w_sdyom w1_sdyon;
        } in  GHC.Read.list sat_sdyoo;

Data.Functor.Classes.$w$cliftReadsPrec7 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a b)
[GblId, Arity=2, Str=<L,1*C1(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyop w1_sdyoq]
        let {
          sat_sdyoG [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Const.Const a_sdxVu b_sdxVv)
          [LclId] =
              [w_sdyop w1_sdyoq] \u []
                  let {
                    lvl3_sdyor [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS a_sdxVu
                    [LclId] =
                        [w_sdyop] \u [] w_sdyop Data.Functor.Classes.$fRead1Const1; } in
                  let {
                    sat_sdyoF [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Const.Const a_sdxVu b_sdxVv)
                    [LclId] =
                        [lvl3_sdyor] \r [c_sdyos eta_sdyot]
                            case c_sdyos of {
                              GHC.Types.I# x_sdyov [Occ=Once] ->
                                  case <=# [x_sdyov 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdyoC [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [lvl3_sdyor eta_sdyot] \r [a1_sdyox]
                                                  let {
                                                    sat_sdyoz [Occ=Once]
                                                      :: a_sdxVu
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta_sdyot] \r [a2_sdyoy]
                                                            eta_sdyot a2_sdyoy;
                                                  } in 
                                                    case
                                                        Text.ParserCombinators.ReadP.$wreadS_to_P
                                                            lvl3_sdyor sat_sdyoz
                                                    of
                                                    { Unit# ww1_sdyoB [Occ=Once] ->
                                                          Text.ParserCombinators.ReadP.Look [ww1_sdyoB];
                                                    };
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Const2 sat_sdyoC
                                          of
                                          { Unit# ww1_sdyoE [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdyoE];
                                          };
                                  };
                            };
                  } in 
                    GHC.Read.list3
                        sat_sdyoF
                        w1_sdyoq
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyoG;

Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a b)
[GblId,
 Arity=5,
 Str=<L,1*C1(C(U))><L,A><L,A><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyoH w1_sdyoI w2_sdyoJ w3_sdyoK w4_sdyoL]
        Data.Functor.Classes.$w$cliftReadsPrec7 w_sdyoH w4_sdyoL;

Data.Functor.Classes.$fRead1Either3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right"#;

Data.Functor.Classes.$fRead1Either2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Either3;

Data.Functor.Classes.$fRead1Either1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Either2];

Data.Functor.Classes.$fRead1Either6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left"#;

Data.Functor.Classes.$fRead1Either5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Either6;

Data.Functor.Classes.$fRead1Either4 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Either5];

Data.Functor.Classes.$w$cliftReadPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyoM w1_sdyoN w2_sdyoO w3_sdyoP]
        let {
          sat_sdypb [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_sdxVC b_sdxVD)
          [LclId] =
              [w_sdyoM w1_sdyoN] \r [c_sdyoQ eta_sdyoR]
                  case c_sdyoQ of {
                    GHC.Types.I# x_sdyoT [Occ=Once] ->
                        case <=# [x_sdyoT 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdyoZ [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                [LclId] =
                                    [w_sdyoM eta_sdyoR] \r [a1_sdyoV]
                                        let {
                                          sat_sdyoY [Occ=Once]
                                            :: a_sdxVC -> Text.ParserCombinators.ReadP.P b2_i815E
                                          [LclId] =
                                              [eta_sdyoR] \r [a2_sdyoW]
                                                  let {
                                                    sat_sdyoX [Occ=Once]
                                                      :: Data.Either.Either a_sdxVC b_sdxVD
                                                    [LclId] =
                                                        CCCS Data.Either.Left! [a2_sdyoW];
                                                  } in  eta_sdyoR sat_sdyoX;
                                        } in  w_sdyoM Data.Functor.Classes.$fRead1Const1 sat_sdyoY;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Either4 sat_sdyoZ
                                of
                                { Unit# ww1_sdyp1 [Occ=Once] ->
                                      let {
                                        sat_sdypa [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b2_i815E
                                        [LclId] =
                                            [w1_sdyoN eta_sdyoR] \u []
                                                let {
                                                  sat_sdyp7 [Occ=Once]
                                                    :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                                  [LclId] =
                                                      [w1_sdyoN eta_sdyoR] \r [a1_sdyp3]
                                                          let {
                                                            sat_sdyp6 [Occ=Once]
                                                              :: b_sdxVD
                                                                 -> Text.ParserCombinators.ReadP.P
                                                                      b2_i815E
                                                            [LclId] =
                                                                [eta_sdyoR] \r [a2_sdyp4]
                                                                    let {
                                                                      sat_sdyp5 [Occ=Once]
                                                                        :: Data.Either.Either
                                                                             a_sdxVC b_sdxVD
                                                                      [LclId] =
                                                                          CCCS Data.Either.Right! [a2_sdyp4];
                                                                    } in  eta_sdyoR sat_sdyp5;
                                                          } in 
                                                            w1_sdyoN
                                                                Data.Functor.Classes.$fRead1Const1
                                                                sat_sdyp6;
                                                } in 
                                                  case
                                                      Text.Read.Lex.$wexpect
                                                          Data.Functor.Classes.$fRead1Either1
                                                          sat_sdyp7
                                                  of
                                                  { Unit# ww3_sdyp9 [Occ=Once] ->
                                                        Text.ParserCombinators.ReadP.Look [ww3_sdyp9];
                                                  }; } in
                                      let {
                                        sat_sdyp2 [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b2_i815E
                                        [LclId] =
                                            CCCS Text.ParserCombinators.ReadP.Look! [ww1_sdyp1];
                                      } in 
                                        Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                            sat_sdyp2 sat_sdypa;
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdypb w2_sdyoO w3_sdyoP;

Data.Functor.Classes.$fRead1Either8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdypc w1_sdypd w2_sdype w3_sdypf w4_sdypg w5_sdyph]
        Data.Functor.Classes.$w$cliftReadPrec3
            w_sdypc w2_sdype w4_sdypg w5_sdyph;

Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a b]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdypi rl1_sdypj rp2_sdypk rl2_sdypl]
        let {
          sat_sdypo [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_adwUm b_adwUn)
          [LclId] =
              [rp1_sdypi rp2_sdypk] \r [w_sdypm w1_sdypn]
                  Data.Functor.Classes.$w$cliftReadPrec3
                      rp1_sdypi rp2_sdypk w_sdypm w1_sdypn;
        } in  GHC.Read.list sat_sdypo;

Data.Functor.Classes.$w$cliftReadsPrec8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdypp w1_sdypq w2_sdypr]
        let {
          sat_sdypu [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_sdxVM b_sdxVN)
          [LclId] =
              [w_sdypp w1_sdypq w2_sdypr] \u []
                  let {
                    sat_sdypt [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_sdxVN
                    [LclId] =
                        [w1_sdypq] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdypq eta_B1; } in
                  let {
                    sat_sdyps [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdxVM
                    [LclId] =
                        [w_sdypp] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdypp eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec3
                        sat_sdyps
                        sat_sdypt
                        w2_sdypr
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdypu;

Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=5,
 Str=<L,C(C(U))><L,A><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdypv w1_sdypw w2_sdypx w3_sdypy w4_sdypz]
        Data.Functor.Classes.$w$cliftReadsPrec8 w_sdypv w2_sdypx w4_sdypz;

Data.Functor.Classes.$fEq1Maybe_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdypA ds1_sdypB ds2_sdypC]
        case ds1_sdypB of {
          GHC.Base.Nothing ->
              case ds2_sdypC of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just ds3_sdypG [Occ=Once] ->
              case ds2_sdypC of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just y_sdypI [Occ=Once] -> ds_sdypA ds3_sdypG y_sdypI;
              };
        };

Data.Functor.Classes.$fEq1Maybe [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 GHC.Base.Maybe
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Maybe_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1 [Occ=LoopBreaker]
  :: forall a b.
     (a -> b -> GHC.Types.Bool) -> [a] -> [b] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdypJ ds1_sdypK ds2_sdypL]
        case ds1_sdypK of {
          [] ->
              case ds2_sdypL of {
                [] -> GHC.Types.True [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
              };
          : ds3_sdypQ [Occ=Once] ds4_sdypR [Occ=Once] ->
              case ds2_sdypL of {
                [] -> GHC.Types.False [];
                : y_sdypT [Occ=Once] ys_sdypU [Occ=Once] ->
                    case ds_sdypJ ds3_sdypQ y_sdypT of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True ->
                          Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                              ds_sdypJ ds4_sdypR ys_sdypU;
                    };
              };
        };

Data.Functor.Classes.$fEq1[] [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 []
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$w$cliftEq [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> a -> [a] -> b -> [b] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdypW ww_sdypX ww1_sdypY ww2_sdypZ ww3_sdyq0]
        case w_sdypW ww_sdypX ww2_sdypZ of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                  w_sdypW ww1_sdypY ww3_sdyq0;
        };

Data.Functor.Classes.$fEq1NonEmpty_$cliftEq [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyq2 w1_sdyq3 w2_sdyq4]
        case w1_sdyq3 of {
          GHC.Base.:| ww1_sdyq6 [Occ=Once] ww2_sdyq7 [Occ=Once] ->
              case w2_sdyq4 of {
                GHC.Base.:| ww4_sdyq9 [Occ=Once] ww5_sdyqa [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftEq
                        w_sdyq2 ww1_sdyq6 ww2_sdyq7 ww4_sdyq9 ww5_sdyqa;
              };
        };

Data.Functor.Classes.$fEq1NonEmpty [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 GHC.Base.NonEmpty
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1NonEmpty_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Identity_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eq_sdyqb ds_sdyqc ds1_sdyqd] eq_sdyqb ds_sdyqc ds1_sdyqd;

Data.Functor.Classes.$fEq1Identity [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 Data.Functor.Identity.Identity
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Identity_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Proxy_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdyqe ds1_sdyqf ds2_sdyqg] GHC.Types.True [];

Data.Functor.Classes.$fEq1Proxy [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 Data.Proxy.Proxy
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Proxy_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fOrd1Maybe_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdyqh ds1_sdyqi ds2_sdyqj]
        case ds1_sdyqi of {
          GHC.Base.Nothing ->
              case ds2_sdyqj of {
                GHC.Base.Nothing -> GHC.Types.EQ [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.LT [];
              };
          GHC.Base.Just ds3_sdyqn [Occ=Once] ->
              case ds2_sdyqj of {
                GHC.Base.Nothing -> GHC.Types.GT [];
                GHC.Base.Just y_sdyqp [Occ=Once] -> ds_sdyqh ds3_sdyqn y_sdyqp;
              };
        };

Data.Functor.Classes.$fOrd1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Maybe_$cliftEq
                                                Data.Functor.Classes.$fOrd1Maybe_$cliftCompare];

Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1 [Occ=LoopBreaker]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering) -> [a] -> [b] -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdyqq ds1_sdyqr ds2_sdyqs]
        case ds1_sdyqr of {
          [] ->
              case ds2_sdyqs of {
                [] -> GHC.Types.EQ [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.LT [];
              };
          : ds3_sdyqx [Occ=Once] ds4_sdyqy [Occ=Once] ->
              case ds2_sdyqs of {
                [] -> GHC.Types.GT [];
                : y_sdyqA [Occ=Once] ys_sdyqB [Occ=Once] ->
                    case ds_sdyqq ds3_sdyqx y_sdyqA of {
                      GHC.Types.LT -> GHC.Types.LT [];
                      GHC.Types.EQ ->
                          Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
                              ds_sdyqq ds4_sdyqy ys_sdyqB;
                      GHC.Types.GT -> GHC.Types.GT [];
                    };
              };
        };

Data.Functor.Classes.$fOrd1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                                                Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1];

Data.Functor.Classes.$w$cliftCompare1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> a -> [a] -> b -> [b] -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdyqD ww_sdyqE ww1_sdyqF ww2_sdyqG ww3_sdyqH]
        case w_sdyqD ww_sdyqE ww2_sdyqG of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
                  w_sdyqD ww1_sdyqF ww3_sdyqH;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyqJ w1_sdyqK w2_sdyqL]
        case w1_sdyqK of {
          GHC.Base.:| ww1_sdyqN [Occ=Once] ww2_sdyqO [Occ=Once] ->
              case w2_sdyqL of {
                GHC.Base.:| ww4_sdyqQ [Occ=Once] ww5_sdyqR [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftCompare1
                        w_sdyqJ ww1_sdyqN ww2_sdyqO ww4_sdyqQ ww5_sdyqR;
              };
        };

Data.Functor.Classes.$fOrd1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1NonEmpty_$cliftEq
                                                Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare];

Data.Functor.Classes.$fOrd1Identity_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [comp_sdyqS ds_sdyqT ds1_sdyqU]
        comp_sdyqS ds_sdyqT ds1_sdyqU;

Data.Functor.Classes.$fOrd1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Identity_$cliftEq
                                                Data.Functor.Classes.$fOrd1Identity_$cliftCompare];

Data.Functor.Classes.$fOrd1Proxy_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdyqV ds1_sdyqW ds2_sdyqX] GHC.Types.EQ [];

Data.Functor.Classes.$fOrd1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 Data.Proxy.Proxy
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Proxy_$cliftEq
                                                Data.Functor.Classes.$fOrd1Proxy_$cliftCompare];

Data.Functor.Classes.$fRead1[]_$cliftReadPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdyqY rl_sdyqZ] rl_sdyqZ;

Data.Functor.Classes.$fRead1NonEmpty4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":|"#;

Data.Functor.Classes.$fRead1NonEmpty3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1NonEmpty4;

Data.Functor.Classes.$fRead1NonEmpty2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [6#];

Data.Functor.Classes.$w$cliftReadsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Prim.Int#
     -> GHC.Base.String
     -> [(GHC.Base.NonEmpty a, GHC.Base.String)]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(U)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyr0 w1_sdyr1 ww_sdyr2 w2_sdyr3]
        let {
          go_sdyr4 [Occ=LoopBreaker]
            :: [(a_sdxWD, GHC.Base.String)]
               -> [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w1_sdyr1 go_sdyr4] \r [ds_sdyr5]
                  case ds_sdyr5 of {
                    [] -> [] [];
                    : y_sdyr7 [Occ=Once!] ys_sdyr8 [Occ=Once] ->
                        case y_sdyr7 of {
                          (,) a1_sdyra [Occ=OnceL] s''_sdyrb [Occ=Once] ->
                              let {
                                z_sdyrc [Occ=OnceL]
                                  :: [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
                                [LclId] =
                                    [go_sdyr4 ys_sdyr8] \u [] go_sdyr4 ys_sdyr8; } in
                              let {
                                go1_sdyrd [Occ=LoopBreaker]
                                  :: [(GHC.Base.String, GHC.Base.String)]
                                     -> [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
                                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                    sat-only [w1_sdyr1 a1_sdyra z_sdyrc go1_sdyrd] \r [ds1_sdyre]
                                        case ds1_sdyre of {
                                          [] -> z_sdyrc;
                                          : y1_sdyrg [Occ=Once!] ys1_sdyrh [Occ=Once*] ->
                                              case y1_sdyrg of {
                                                (,) ds2_sdyrj [Occ=Once] s'''_sdyrk [Occ=Once] ->
                                                    case
                                                        GHC.Base.eqString
                                                            ds2_sdyrj
                                                            Data.Functor.Classes.$fRead1NonEmpty3
                                                    of
                                                    { GHC.Types.False -> go1_sdyrd ys1_sdyrh;
                                                      GHC.Types.True ->
                                                          let {
                                                            z1_sdyrm [Occ=OnceL]
                                                              :: [(GHC.Base.NonEmpty a_sdxWD,
                                                                   GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdyrd ys1_sdyrh] \u []
                                                                    go1_sdyrd ys1_sdyrh; } in
                                                          let {
                                                            go2_sdyrn [Occ=LoopBreaker]
                                                              :: [([a_sdxWD], GHC.Base.String)]
                                                                 -> [(GHC.Base.NonEmpty a_sdxWD,
                                                                      GHC.Base.String)]
                                                            [LclId,
                                                             Arity=1,
                                                             Str=<S,1*U>,
                                                             Unf=OtherCon []] =
                                                                sat-only [a1_sdyra
                                                                          z1_sdyrm
                                                                          go2_sdyrn] \r [ds3_sdyro]
                                                                    case ds3_sdyro of {
                                                                      [] -> z1_sdyrm;
                                                                      : y2_sdyrq [Occ=Once!]
                                                                        ys2_sdyrr [Occ=Once] ->
                                                                          case y2_sdyrq of {
                                                                            (,) as_sdyrt [Occ=Once]
                                                                                s''''_sdyru [Occ=Once] ->
                                                                                let {
                                                                                  sat_sdyrx [Occ=Once]
                                                                                    :: [(GHC.Base.NonEmpty
                                                                                           a_sdxWD,
                                                                                         GHC.Base.String)]
                                                                                  [LclId] =
                                                                                      [go2_sdyrn
                                                                                       ys2_sdyrr] \u []
                                                                                          go2_sdyrn
                                                                                              ys2_sdyrr; } in
                                                                                let {
                                                                                  sat_sdyrv [Occ=Once]
                                                                                    :: GHC.Base.NonEmpty
                                                                                         a_sdxWD
                                                                                  [LclId] =
                                                                                      CCCS GHC.Base.:|! [a1_sdyra
                                                                                                         as_sdyrt]; } in
                                                                                let {
                                                                                  sat_sdyrw [Occ=Once]
                                                                                    :: (GHC.Base.NonEmpty
                                                                                          a_sdxWD,
                                                                                        GHC.Base.String)
                                                                                  [LclId] =
                                                                                      CCCS (,)! [sat_sdyrv
                                                                                                 s''''_sdyru];
                                                                                } in 
                                                                                  : [sat_sdyrw
                                                                                     sat_sdyrx];
                                                                          };
                                                                    };
                                                          } in 
                                                            case w1_sdyr1 s'''_sdyrk of sat_sdyry {
                                                              __DEFAULT -> go2_sdyrn sat_sdyry;
                                                            };
                                                    };
                                              };
                                        };
                              } in 
                                case
                                    Text.ParserCombinators.ReadP.run GHC.Read.lex1 s''_sdyrb
                                of
                                sat_sdyrz
                                { __DEFAULT -> go1_sdyrd sat_sdyrz;
                                };
                        };
                  }; } in
        let {
          sat_sdyrE [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_sdxWD)
          [LclId] =
              [w_sdyr0 go_sdyr4] \r [s'_sdyrC]
                  case
                      w_sdyr0 Data.Functor.Classes.$fRead1NonEmpty2 s'_sdyrC
                  of
                  sat_sdyrD
                  { __DEFAULT -> go_sdyr4 sat_sdyrD;
                  };
        } in 
          case ># [ww_sdyr2 5#] of sat_sdyrA {
            __DEFAULT ->
                case tagToEnum# [sat_sdyrA] of sat_sdyrB {
                  __DEFAULT -> GHC.Read.readParen sat_sdyrB sat_sdyrE w2_sdyr3;
                };
          };

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a)
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(U)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyrF w1_sdyrG w2_sdyrH w3_sdyrI]
        case w2_sdyrH of {
          GHC.Types.I# ww1_sdyrK [Occ=Once] ->
              Data.Functor.Classes.$w$cliftReadsPrec5
                  w_sdyrF w1_sdyrG ww1_sdyrK w3_sdyrI;
        };

Data.Functor.Classes.$fRead1Proxy4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Proxy"#;

Data.Functor.Classes.$fRead1Proxy3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Proxy4;

Data.Functor.Classes.$fRead1Proxy_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Proxy3];

Data.Functor.Classes.$fRead1Proxy2
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [eta_sdyrL eta1_sdyrM]
        let {
          sat_sdyrO [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X81cg
          [LclId] =
              [eta1_sdyrM] \r [x_sdyrN] eta1_sdyrM Data.Proxy.Proxy;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Functor.Classes.$fRead1Proxy_lexeme sat_sdyrO
          of
          { Unit# ww1_sdyrQ [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sdyrQ];
          };

Data.Functor.Classes.$fRead1Proxy1
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Functor.Classes.$fRead1Proxy2 eta_B2 eta_B1;

Data.Functor.Classes.$fRead1Proxy5
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=4, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdyrR ds1_sdyrS eta_B2 eta_B1]
        Data.Functor.Classes.$fRead1Proxy1 eta_B2 eta_B1;

Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> [a]
     -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdyrT sl_sdyrU ds1_sdyrV] sl_sdyrU;

Data.Functor.Classes.$fShow1NonEmpty1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " :| "#;

Data.Functor.Classes.$w$cliftShowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> a
     -> [a]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C(U))><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyrW w1_sdyrX ww_sdyrY ww1_sdyrZ ww2_sdys0]
        let {
          f_sdys1 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyrW ww1_sdyrZ] \u []
                  w_sdyrW Data.Functor.Classes.$fRead1NonEmpty2 ww1_sdyrZ; } in
        let {
          g_sdys2 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdyrX ww2_sdys0] \u [] w1_sdyrX ww2_sdys0;
        } in 
          case ># [ww_sdyrY 5#] of {
            __DEFAULT ->
                let {
                  sat_sdys7 [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_sdys1 g_sdys2] \r [x_sdys4]
                          let {
                            sat_sdys6 [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g_sdys2 x_sdys4] \u []
                                    let {
                                      sat_sdys5 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdys2 x_sdys4] \u [] g_sdys2 x_sdys4;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Functor.Classes.$fShow1NonEmpty1 sat_sdys5;
                          } in  f_sdys1 sat_sdys6;
                } in  sat_sdys7;
            1# ->
                let {
                  sat_sdysd [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sdys1 g_sdys2] \r [x_sdys8]
                          let {
                            sat_sdysc [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sdys1 g_sdys2 x_sdys8] \u []
                                    let {
                                      sat_sdysb [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g_sdys2 x_sdys8] \u []
                                              let {
                                                sat_sdysa [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sdys2 x_sdys8] \u []
                                                        let {
                                                          sat_sdys9 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdys8];
                                                        } in  g_sdys2 sat_sdys9;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Functor.Classes.$fShow1NonEmpty1 sat_sdysa;
                                    } in  f_sdys1 sat_sdysb;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdysc];
                } in  sat_sdysd;
          };

Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> GHC.Base.NonEmpty a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C(U))><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyse w1_sdysf w2_sdysg w3_sdysh]
        case w2_sdysg of {
          GHC.Types.I# ww1_sdysj [Occ=Once] ->
              case w3_sdysh of {
                GHC.Base.:| ww3_sdysl [Occ=Once] ww4_sdysm [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftShowsPrec1
                        w_sdyse w1_sdysf ww1_sdysj ww3_sdysl ww4_sdysm;
              };
        };

Data.Functor.Classes.$fShow1Proxy2
  :: [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Base.++ Data.Functor.Classes.$fRead1Proxy3 eta_B1;

Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Proxy.Proxy a
     -> GHC.Show.ShowS
[GblId, Arity=5, Str=<L,A><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdysn ds1_sdyso ds2_sdysp ds3_sdysq eta_B1]
        Data.Functor.Classes.$fShow1Proxy2 eta_B1;

Data.Functor.Classes.$fEq2(,)_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool) -> (a, c) -> (b, d) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [e1_sdysr e2_sdyss ds_sdyst ds1_sdysu]
        case ds_sdyst of {
          (,) x1_sdysw [Occ=Once] y1_sdysx [Occ=Once] ->
              case ds1_sdysu of {
                (,) x2_sdysz [Occ=Once] y2_sdysA [Occ=Once] ->
                    case e1_sdysr x1_sdysw x2_sdysz of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> e2_sdyss y1_sdysx y2_sdysA;
                    };
              };
        };

Data.Functor.Classes.$fEq2(,) [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 (,)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2(,)_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1(,)_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> (a, a1) -> (a, b) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdysC eta_sdysD eta1_sdysE eta2_sdysF]
        case eta1_sdysE of {
          (,) x1_sdysH [Occ=Once] y1_sdysI [Occ=Once] ->
              case eta2_sdysF of {
                (,) x2_sdysK [Occ=Once] y2_sdysL [Occ=Once] ->
                    case GHC.Classes.== $dEq_sdysC x1_sdysH x2_sdysK of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> eta_sdysD y1_sdysI y2_sdysL;
                    };
              };
        };

Data.Functor.Classes.$fEq1(,) [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Classes.Eq a => Data.Functor.Classes.Eq1 ((,) a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1(,)_$cliftEq eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq2Either_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool)
     -> Data.Either.Either a c
     -> Data.Either.Either b d
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [e1_sdysN ds_sdysO ds1_sdysP ds2_sdysQ]
        case ds1_sdysP of {
          Data.Either.Left x_sdysS [Occ=Once] ->
              case ds2_sdysQ of {
                Data.Either.Left y_sdysU [Occ=Once] -> e1_sdysN x_sdysS y_sdysU;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds3_sdysW [Occ=Once] ->
              case ds2_sdysQ of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdysZ [Occ=Once] -> ds_sdysO ds3_sdysW y_sdysZ;
              };
        };

Data.Functor.Classes.$fEq2Either [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 Data.Either.Either
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2Either_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Either_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdyt0 eta_sdyt1 eta1_sdyt2 eta2_sdyt3]
        case eta1_sdyt2 of {
          Data.Either.Left x_sdyt5 [Occ=Once] ->
              case eta2_sdyt3 of {
                Data.Either.Left y_sdyt7 [Occ=Once] ->
                    GHC.Classes.== $dEq_sdyt0 x_sdyt5 y_sdyt7;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds_sdyt9 [Occ=Once] ->
              case eta2_sdyt3 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdytc [Occ=Once] -> eta_sdyt1 ds_sdyt9 y_sdytc;
              };
        };

Data.Functor.Classes.$fEq1Either [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Classes.Eq1 (Data.Either.Either a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Either_$cliftEq
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq2Const_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a c
     -> Data.Functor.Const.Const b d
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eq_sdytd ds_sdyte ds1_sdytf ds2_sdytg]
        eq_sdytd ds1_sdytf ds2_sdytg;

Data.Functor.Classes.$fEq2Const [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 Data.Functor.Const.Const
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2Const_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Const_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a a1
     -> Data.Functor.Const.Const a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdyth eta_sdyti eta1_sdytj eta2_sdytk]
        GHC.Classes.== $dEq_sdyth eta1_sdytj eta2_sdytk;

Data.Functor.Classes.$fEq1Const [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Const_$cliftEq
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fOrd2(,)_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> (a, c)
     -> (b, d)
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [comp1_sdytl comp2_sdytm ds_sdytn ds1_sdyto]
        case ds_sdytn of {
          (,) x1_sdytq [Occ=Once] y1_sdytr [Occ=Once] ->
              case ds1_sdyto of {
                (,) x2_sdytt [Occ=Once] y2_sdytu [Occ=Once] ->
                    case comp1_sdytl x1_sdytq x2_sdytt of {
                      GHC.Types.LT -> GHC.Types.LT [];
                      GHC.Types.EQ -> comp2_sdytm y1_sdytr y2_sdytu;
                      GHC.Types.GT -> GHC.Types.GT [];
                    };
              };
        };

Data.Functor.Classes.$fOrd2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2(,)_$cliftEq2
                                                Data.Functor.Classes.$fOrd2(,)_$cliftCompare2];

Data.Functor.Classes.$w$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> a -> a1 -> a -> b -> GHC.Types.Ordering
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdytw w1_sdytx ww_sdyty ww1_sdytz ww2_sdytA ww3_sdytB]
        case GHC.Classes.compare w_sdytw ww_sdyty ww2_sdytA of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> w1_sdytx ww1_sdytz ww3_sdytB;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Classes.$fOrd1(,)_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> (a, a1) -> (a, b) -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdytD w1_sdytE w2_sdytF w3_sdytG]
        case w2_sdytF of {
          (,) ww1_sdytI [Occ=Once] ww2_sdytJ [Occ=Once] ->
              case w3_sdytG of {
                (,) ww4_sdytL [Occ=Once] ww5_sdytM [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftCompare
                        w_sdytD w1_sdytE ww1_sdytI ww2_sdytJ ww4_sdytL ww5_sdytM;
              };
        };

Data.Functor.Classes.$w$cp1Ord1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> a -> a1 -> a -> b -> GHC.Types.Bool
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdytN w1_sdytO ww_sdytP ww1_sdytQ ww2_sdytR ww3_sdytS]
        case GHC.Classes.$p1Ord w_sdytN of sat_sdytT {
          __DEFAULT ->
              case GHC.Classes.== sat_sdytT ww_sdytP ww2_sdytR of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> w1_sdytO ww1_sdytQ ww3_sdytS;
              };
        };

Data.Functor.Classes.$fOrd1(,)1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> (a, a1) -> (a, b) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdytV w1_sdytW w2_sdytX w3_sdytY]
        case w2_sdytX of {
          (,) ww1_sdyu0 [Occ=Once] ww2_sdyu1 [Occ=Once] ->
              case w3_sdytY of {
                (,) ww4_sdyu3 [Occ=Once] ww5_sdyu4 [Occ=Once] ->
                    Data.Functor.Classes.$w$cp1Ord1
                        w_sdytV w1_sdytW ww1_sdyu0 ww2_sdyu1 ww4_sdyu3 ww5_sdyu4;
              };
        };

Data.Functor.Classes.$fOrd1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Ord a => Data.Functor.Classes.Ord1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdyu5]
        let {
          sat_sdyu7 [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> (a_Xdx1z, a) -> (a_Xdx1z, b) -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdyu5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1(,)_$cliftCompare
                      $dOrd_sdyu5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyu6 [Occ=Once] :: Data.Functor.Classes.Eq1 ((,) a_Xdx1z)
          [LclId] =
              [$dOrd_sdyu5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1(,)1 $dOrd_sdyu5 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdyu6 sat_sdyu7];

Data.Functor.Classes.$fOrd2Either_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> Data.Either.Either a c
     -> Data.Either.Either b d
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [comp1_sdyu8 ds_sdyu9 ds1_sdyua ds2_sdyub]
        case ds1_sdyua of {
          Data.Either.Left x_sdyud [Occ=Once] ->
              case ds2_sdyub of {
                Data.Either.Left y_sdyuf [Occ=Once] -> comp1_sdyu8 x_sdyud y_sdyuf;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right ds3_sdyuh [Occ=Once] ->
              case ds2_sdyub of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right y_sdyuk [Occ=Once] -> ds_sdyu9 ds3_sdyuh y_sdyuk;
              };
        };

Data.Functor.Classes.$fOrd2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2Either_$cliftEq2
                                                Data.Functor.Classes.$fOrd2Either_$cliftCompare2];

Data.Functor.Classes.$fOrd1Either_$cliftCompare
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdyul eta_sdyum eta1_sdyun eta2_sdyuo]
        case eta1_sdyun of {
          Data.Either.Left x_sdyuq [Occ=Once] ->
              case eta2_sdyuo of {
                Data.Either.Left y_sdyus [Occ=Once] ->
                    GHC.Classes.compare $dOrd_sdyul x_sdyuq y_sdyus;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right ds_sdyuu [Occ=Once] ->
              case eta2_sdyuo of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right y_sdyux [Occ=Once] -> eta_sdyum ds_sdyuu y_sdyux;
              };
        };

Data.Functor.Classes.$fOrd1Either1
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdyuy eta_sdyuz eta1_sdyuA eta2_sdyuB]
        case eta1_sdyuA of {
          Data.Either.Left x_sdyuD [Occ=Once] ->
              case eta2_sdyuB of {
                Data.Either.Left y_sdyuF [Occ=Once] ->
                    case GHC.Classes.$p1Ord $dOrd_sdyuy of sat_sdyuG {
                      __DEFAULT -> GHC.Classes.== sat_sdyuG x_sdyuD y_sdyuF;
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds_sdyuI [Occ=Once] ->
              case eta2_sdyuB of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdyuL [Occ=Once] -> eta_sdyuz ds_sdyuI y_sdyuL;
              };
        };

Data.Functor.Classes.$fOrd1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Classes.Ord1 (Data.Either.Either a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdyuM]
        let {
          sat_sdyuO [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Either.Either a_Xdx16 a
               -> Data.Either.Either a_Xdx16 b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdyuM] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Either_$cliftCompare
                      $dOrd_sdyuM eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyuN [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Either.Either a_Xdx16)
          [LclId] =
              [$dOrd_sdyuM] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Either1
                      $dOrd_sdyuM eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdyuN sat_sdyuO];

Data.Functor.Classes.$fOrd2Const_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> Data.Functor.Const.Const a c
     -> Data.Functor.Const.Const b d
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [comp_sdyuP ds_sdyuQ ds1_sdyuR ds2_sdyuS]
        comp_sdyuP ds1_sdyuR ds2_sdyuS;

Data.Functor.Classes.$fOrd2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 Data.Functor.Const.Const
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2Const_$cliftEq2
                                                Data.Functor.Classes.$fOrd2Const_$cliftCompare2];

Data.Functor.Classes.$fOrd1Const1
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a a1
     -> Data.Functor.Const.Const a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdyuT eta_sdyuU eta1_sdyuV eta2_sdyuW]
        case GHC.Classes.$p1Ord $dOrd_sdyuT of sat_sdyuX {
          __DEFAULT -> GHC.Classes.== sat_sdyuX eta1_sdyuV eta2_sdyuW;
        };

Data.Functor.Classes.$fOrd1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Classes.Ord1 (Data.Functor.Const.Const a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdyuY]
        let {
          sat_sdyv3 [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Const.Const a_Xdx0D a
               -> Data.Functor.Const.Const a_Xdx0D b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdyuY] \r [eta_sdyv0 eta1_sdyv1 eta2_sdyv2]
                  GHC.Classes.compare $dOrd_sdyuY eta1_sdyv1 eta2_sdyv2; } in
        let {
          sat_sdyuZ [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a_Xdx0D)
          [LclId] =
              [$dOrd_sdyuY] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Const1 $dOrd_sdyuY eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdyuZ sat_sdyv3];

Data.Functor.Classes.$fRead1(,)5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ","#;

Data.Functor.Classes.$fRead1(,)4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1(,)5;

Data.Functor.Classes.$fRead1(,)3 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Functor.Classes.$fRead1(,)4];

Data.Functor.Classes.$w$cliftReadPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a, b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyv4 w1_sdyv5 w2_sdyv6 w3_sdyv7]
        let {
          p_sdyv8 [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b2.
                  ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b2)
                  -> Text.ParserCombinators.ReadP.P b2
          [LclId, Arity=2, Str=<L,U><L,C(U)>, Unf=OtherCon []] =
              [w_sdyv4 w1_sdyv5] \r [n_sdyv9 k1_sdyva]
                  let {
                    sat_sdyvj [Occ=Once]
                      :: a_sdxYe -> Text.ParserCombinators.ReadP.P b2_i88WH
                    [LclId] =
                        [w1_sdyv5 n_sdyv9 k1_sdyva] \r [a1_sdyvb]
                            let {
                              sat_sdyvg [Occ=Once]
                                :: () -> Text.ParserCombinators.ReadP.P b2_i88WH
                              [LclId] =
                                  [w1_sdyv5 n_sdyv9 k1_sdyva a1_sdyvb] \r [a2_sdyvc]
                                      let {
                                        sat_sdyvf [Occ=Once]
                                          :: b_sdxYf -> Text.ParserCombinators.ReadP.P b2_i88WH
                                        [LclId] =
                                            [k1_sdyva a1_sdyvb] \r [a3_sdyvd]
                                                let {
                                                  sat_sdyve [Occ=Once] :: (a_sdxYe, b_sdxYf)
                                                  [LclId] =
                                                      CCCS (,)! [a1_sdyvb a3_sdyvd];
                                                } in  k1_sdyva sat_sdyve;
                                      } in  w1_sdyv5 n_sdyv9 sat_sdyvf;
                            } in 
                              case
                                  Text.Read.Lex.$wexpect Data.Functor.Classes.$fRead1(,)3 sat_sdyvg
                              of
                              { Unit# ww1_sdyvi [Occ=Once] ->
                                    Text.ParserCombinators.ReadP.Look [ww1_sdyvi];
                              };
                  } in  w_sdyv4 n_sdyv9 sat_sdyvj; } in
        let {
          lvl3_sdyvk [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b2.
                  ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b2)
                  -> Text.ParserCombinators.ReadP.P b2
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [p_sdyv8] \r [w4_sdyvl w5_sdyvm]
                  case GHC.Read.$wparen' p_sdyv8 w4_sdyvl w5_sdyvm of {
                    Unit# ww1_sdyvo [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Get [ww1_sdyvo];
                  }; } in
        let {
          sat_sdyvt [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_sdxYe, b_sdxYf)
          [LclId] =
              [lvl3_sdyvk] \r [eta_sdyvp eta1_sdyvq]
                  case
                      GHC.Read.$wskipSpacesThenP lvl3_sdyvk eta_sdyvp eta1_sdyvq
                  of
                  { Unit# ww1_sdyvs [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdyvs];
                  };
        } in  GHC.Read.list3 sat_sdyvt w2_sdyv6 w3_sdyv7;

Data.Functor.Classes.$fRead1(,)2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a, b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyvu w1_sdyvv w2_sdyvw w3_sdyvx w4_sdyvy w5_sdyvz]
        Data.Functor.Classes.$w$cliftReadPrec2
            w_sdyvu w2_sdyvw w4_sdyvy w5_sdyvz;

Data.Functor.Classes.$w$cliftReadsPrec6 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, b)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyvA w1_sdyvB w2_sdyvC]
        let {
          sat_sdyvF [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (a_sdxYo, b_sdxYp)
          [LclId] =
              [w_sdyvA w1_sdyvB w2_sdyvC] \u []
                  let {
                    sat_sdyvE [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_sdxYp
                    [LclId] =
                        [w1_sdyvB] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdyvB eta_B1; } in
                  let {
                    sat_sdyvD [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdxYo
                    [LclId] =
                        [w_sdyvA] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdyvA eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec2
                        sat_sdyvD
                        sat_sdyvE
                        w2_sdyvC
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyvF;

Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, b)
[GblId,
 Arity=5,
 Str=<L,C(C(U))><L,A><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyvG w1_sdyvH w2_sdyvI w3_sdyvJ w4_sdyvK]
        Data.Functor.Classes.$w$cliftReadsPrec6 w_sdyvG w2_sdyvI w4_sdyvK;

Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [(a, b)]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdyvL rl1_sdyvM rp2_sdyvN rl2_sdyvO]
        let {
          sat_sdyvR [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_adwW8, b_adwW9)
          [LclId] =
              [rp1_sdyvL rp2_sdyvN] \r [w_sdyvP w1_sdyvQ]
                  Data.Functor.Classes.$w$cliftReadPrec2
                      rp1_sdyvL rp2_sdyvN w_sdyvP w1_sdyvQ;
        } in  GHC.Read.list sat_sdyvR;

Data.Functor.Classes.$fShow1(,)3 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['('#];

Data.Functor.Classes.$fRead1Identity5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Classes.$fShow1(,)2 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [','#];

Data.Functor.Classes.$fShow1(,)1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [')'#];

Data.Functor.Classes.$w$cliftShowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyvS w1_sdyvT ww_sdyvU ww1_sdyvV]
        let {
          f_sdyvW [Occ=OnceL!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyvS ww_sdyvU] \u []
                  w_sdyvS Data.Functor.Classes.$fRead1Identity5 ww_sdyvU; } in
        let {
          f1_sdyvX [Occ=OnceL!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdyvT ww1_sdyvV] \u []
                  w1_sdyvT Data.Functor.Classes.$fRead1Identity5 ww1_sdyvV; } in
        let {
          sat_sdyw3 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
          [LclId] =
              [f_sdyvW f1_sdyvX] \r [x_sdyvY]
                  let {
                    sat_sdyw2 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [f_sdyvW f1_sdyvX x_sdyvY] \u []
                            let {
                              sat_sdyw0 [Occ=Once] :: [GHC.Types.Char]
                              [LclId] =
                                  [f1_sdyvX x_sdyvY] \u []
                                      let {
                                        sat_sdyvZ [Occ=Once] :: GHC.Base.String
                                        [LclId] =
                                            CCCS :! [Data.Functor.Classes.$fShow1(,)1 x_sdyvY];
                                      } in  f1_sdyvX sat_sdyvZ; } in
                            let {
                              sat_sdyw1 [Occ=Once] :: GHC.Base.String
                              [LclId] =
                                  CCCS :! [Data.Functor.Classes.$fShow1(,)2 sat_sdyw0];
                            } in  f_sdyvW sat_sdyw1;
                  } in  : [Data.Functor.Classes.$fShow1(,)3 sat_sdyw2];
        } in  sat_sdyw3;

Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> (a, b)
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*C1(C1(C(U)))><L,A><L,A><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyw4 w1_sdyw5 w2_sdyw6 w3_sdyw7 w4_sdyw8 w5_sdyw9]
        case w5_sdyw9 of {
          (,) ww1_sdywb [Occ=Once] ww2_sdywc [Occ=Once] ->
              Data.Functor.Classes.$w$cliftShowsPrec2
                  w_sdyw4 w2_sdyw6 ww1_sdywb ww2_sdywc;
        };

Data.Functor.Classes.$dmliftShowList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [f a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(C(C1(U))))))),A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow2_sdywd sp1_sdywe sl1_sdywf sp2_sdywg sl2_sdywh]
        let {
          sat_sdywi [Occ=Once] :: f_adw99 a_adwOU b_adwOV -> GHC.Show.ShowS
          [LclId] =
              [$dShow2_sdywd sp1_sdywe sl1_sdywf sp2_sdywg sl2_sdywh] \u []
                  Data.Functor.Classes.liftShowsPrec2
                      $dShow2_sdywd
                      sp1_sdywe
                      sl1_sdywf
                      sp2_sdywg
                      sl2_sdywh
                      Data.Functor.Classes.$fRead1Identity5;
        } in  GHC.Show.showList__ sat_sdywi;

Data.Functor.Classes.$w$cliftShowList3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> [(a, b)]
     -> GHC.Base.String
     -> GHC.Base.String
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdywj w1_sdywk w2_sdywl w3_sdywm]
        let {
          sat_sdyww [Occ=Once] :: (a_sdxYK, b_sdxYL) -> GHC.Show.ShowS
          [LclId] =
              [w_sdywj w1_sdywk] \r [ds_sdywn eta_sdywo]
                  case ds_sdywn of {
                    (,) x_sdywq [Occ=Once] y_sdywr [Occ=Once] ->
                        let {
                          sat_sdywv [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_sdywj w1_sdywk eta_sdywo x_sdywq y_sdywr] \u []
                                  let {
                                    sat_sdywt [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w1_sdywk eta_sdywo y_sdywr] \u []
                                            let {
                                              sat_sdyws [Occ=Once] :: GHC.Base.String
                                              [LclId] =
                                                  CCCS :! [Data.Functor.Classes.$fShow1(,)1
                                                           eta_sdywo];
                                            } in 
                                              w1_sdywk
                                                  Data.Functor.Classes.$fRead1Identity5
                                                  y_sdywr
                                                  sat_sdyws; } in
                                  let {
                                    sat_sdywu [Occ=Once] :: GHC.Base.String
                                    [LclId] =
                                        CCCS :! [Data.Functor.Classes.$fShow1(,)2 sat_sdywt];
                                  } in 
                                    w_sdywj Data.Functor.Classes.$fRead1Identity5 x_sdywq sat_sdywu;
                        } in  : [Data.Functor.Classes.$fShow1(,)3 sat_sdywv];
                  };
        } in  GHC.Show.showList__ sat_sdyww w2_sdywl w3_sdywm;

Data.Functor.Classes.$fShow2(,)_$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [(a, b)]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,A><L,C(C1(C1(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdywx w1_sdywy w2_sdywz w3_sdywA w4_sdywB w5_sdywC]
        Data.Functor.Classes.$w$cliftShowList3
            w_sdywx w2_sdywz w4_sdywB w5_sdywC;

Data.Functor.Classes.$fShow2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2(,)_$cliftShowList2];

Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> (a, a1)
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><L,A><L,A><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdywD eta_sdywE eta1_sdywF eta2_sdywG eta3_sdywH]
        case eta3_sdywH of {
          (,) ww1_sdywJ [Occ=Once] ww2_sdywK [Occ=Once] ->
              let {
                sat_sdywL [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_adwQx -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sdywD] \s [] GHC.Show.showsPrec $dShow_sdywD;
              } in 
                Data.Functor.Classes.$w$cliftShowsPrec2
                    sat_sdywL eta_sdywE ww1_sdywJ ww2_sdywK;
        };

$w$dmliftReadListPrec2_rdymu
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadP.ReadP [f a b]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdywM w1_sdywN w2_sdywO w3_sdywP w4_sdywQ]
        let {
          w5_sdywR [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [f_sdxYT a_sdxYV b_sdxYW]
          [LclId] =
              [w_sdywM w1_sdywN w2_sdywO w3_sdywP w4_sdywQ] \u []
                  let {
                    sat_sdywW [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [b_sdxYW]
                    [LclId] =
                        [w4_sdywQ] \u []
                            w4_sdywQ
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdywX [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [b_sdxYW]
                    [LclId] =
                        [sat_sdywW] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdywW eta_B1; } in
                  let {
                    sat_sdywV [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_sdxYW
                    [LclId] =
                        [w3_sdywP] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w3_sdywP eta_B1; } in
                  let {
                    sat_sdywT [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxYV]
                    [LclId] =
                        [w2_sdywO] \u []
                            w2_sdywO
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdywU [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxYV]
                    [LclId] =
                        [sat_sdywT] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdywT eta_B1; } in
                  let {
                    sat_sdywS [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxYV
                    [LclId] =
                        [w1_sdywN] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w1_sdywN eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadList2
                        w_sdywM sat_sdywS sat_sdywU sat_sdywV sat_sdywX; } in
        let {
          sat_sdyx1 [Occ=Once]
            :: forall b1.
               ([f_sdxYT a_sdxYV b_sdxYW] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [w5_sdywR] \r [w6_sdywY]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w5_sdywR w6_sdywY
                  of
                  { Unit# ww1_sdyx0 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdyx0];
                  };
        } in  sat_sdyx1;

$dmliftReadListPrec1_rdymv
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [f a b]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdyx2
                    w1_sdyx3
                    w2_sdyx4
                    w3_sdyx5
                    w4_sdyx6
                    w5_sdyx7]
        $w$dmliftReadListPrec2_rdymu
            w_sdyx2 w1_sdyx3 w2_sdyx4 w3_sdyx5 w4_sdyx6;

Data.Functor.Classes.$dmliftReadListPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        $dmliftReadListPrec1_rdymv
            eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$dmliftReadPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(C(U)))))),A,A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyx8 rp1_sdyx9 rl1_sdyxa rp2_sdyxb rl2_sdyxc]
        let {
          f1_sdyxd [Occ=OnceL!, Dmd=<L,C(C(U))>]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdwdU a_adwOl b_adwOm)
          [LclId] =
              [$dRead2_sdyx8 rp1_sdyx9 rl1_sdyxa rp2_sdyxb rl2_sdyxc] \u []
                  let {
                    sat_sdyxi [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [b_adwOm]
                    [LclId] =
                        [rl2_sdyxc] \u []
                            rl2_sdyxc
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdyxj [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [b_adwOm]
                    [LclId] =
                        [sat_sdyxi] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdyxi eta_B1; } in
                  let {
                    sat_sdyxh [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_adwOm
                    [LclId] =
                        [rp2_sdyxb] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S
                                rp2_sdyxb eta_B1; } in
                  let {
                    sat_sdyxf [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adwOl]
                    [LclId] =
                        [rl1_sdyxa] \u []
                            rl1_sdyxa
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdyxg [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adwOl]
                    [LclId] =
                        [sat_sdyxf] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdyxf eta_B1; } in
                  let {
                    sat_sdyxe [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwOl
                    [LclId] =
                        [rp1_sdyx9] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S rp1_sdyx9 eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadsPrec2
                        $dRead2_sdyx8 sat_sdyxe sat_sdyxg sat_sdyxh sat_sdyxj; } in
        let {
          sat_sdyxq [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (f_XdwdU a_adwOl b_adwOm -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [f1_sdyxd] \r [n_sdyxk]
                  let {
                    w_sdyxl [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS (f_XdwdU a_adwOl b_adwOm)
                    [LclId] =
                        [f1_sdyxd n_sdyxk] \u [] f1_sdyxd n_sdyxk; } in
                  let {
                    sat_sdyxp [Occ=OnceT[0]]
                      :: forall b1.
                         (f_XdwdU a_adwOl b_adwOm -> Text.ParserCombinators.ReadP.P b1)
                         -> Text.ParserCombinators.ReadP.P b1
                    [LclId] =
                        [w_sdyxl] \r [w1_sdyxm]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdyxl w1_sdyxm
                            of
                            { Unit# ww1_sdyxo [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyxo];
                            };
                  } in  sat_sdyxp;
        } in  sat_sdyxq;

Data.Functor.Classes.$dmliftReadList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C1(C(U)))))),A)><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyxr rp1_sdyxs rl1_sdyxt rp2_sdyxu rl2_sdyxv]
        let {
          sat_sdyxJ [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_XdwdV a_adwNZ b_adwO0]
          [LclId] =
              [$dRead2_sdyxr rp1_sdyxs rl1_sdyxt rp2_sdyxu rl2_sdyxv] \u []
                  let {
                    sat_sdyxI [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (f_XdwdV a_adwNZ b_adwO0)
                    [LclId] =
                        [$dRead2_sdyxr rp1_sdyxs rl1_sdyxt rp2_sdyxu rl2_sdyxv] \s []
                            let {
                              sat_sdyxH [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwO0]
                              [LclId] =
                                  [rl2_sdyxv] \r [n_sdyxD w1_sdyxE]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl2_sdyxv w1_sdyxE
                                      of
                                      { Unit# ww1_sdyxG [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdyxG];
                                      }; } in
                            let {
                              sat_sdyxC [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwO0
                              [LclId] =
                                  [rp2_sdyxu] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp2_sdyxu eta_B1; } in
                            let {
                              sat_sdyxB [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwNZ]
                              [LclId] =
                                  [rl1_sdyxt] \r [n_sdyxx w1_sdyxy]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl1_sdyxt w1_sdyxy
                                      of
                                      { Unit# ww1_sdyxA [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdyxA];
                                      }; } in
                            let {
                              sat_sdyxw [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwNZ
                              [LclId] =
                                  [rp1_sdyxs] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp1_sdyxs eta_B1;
                            } in 
                              Data.Functor.Classes.liftReadPrec2
                                  $dRead2_sdyxr sat_sdyxw sat_sdyxB sat_sdyxC sat_sdyxH;
                  } in 
                    GHC.Read.list
                        sat_sdyxI
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyxJ;

Data.Functor.Classes.$dmliftReadsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C(C1(U)))))),A)><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyxK rp1_sdyxL rl1_sdyxM rp2_sdyxN rl2_sdyxO]
        let {
          ds_sdyxP [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_XdwdW a_adwNE b_adwNF)
          [LclId] =
              [$dRead2_sdyxK rp1_sdyxL rl1_sdyxM rp2_sdyxN rl2_sdyxO] \u []
                  let {
                    sat_sdyy1 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwNF]
                    [LclId] =
                        [rl2_sdyxO] \r [n_sdyxX w1_sdyxY]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl2_sdyxO w1_sdyxY
                            of
                            { Unit# ww1_sdyy0 [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyy0];
                            }; } in
                  let {
                    sat_sdyxW [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwNF
                    [LclId] =
                        [rp2_sdyxN] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                rp2_sdyxN eta_B1; } in
                  let {
                    sat_sdyxV [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwNE]
                    [LclId] =
                        [rl1_sdyxM] \r [n_sdyxR w1_sdyxS]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl1_sdyxM w1_sdyxS
                            of
                            { Unit# ww1_sdyxU [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyxU];
                            }; } in
                  let {
                    sat_sdyxQ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwNE
                    [LclId] =
                        [rp1_sdyxL] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp1_sdyxL eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadPrec2
                        $dRead2_sdyxK sat_sdyxQ sat_sdyxV sat_sdyxW sat_sdyy1; } in
        let {
          sat_sdyy4 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdwdW a_adwNE b_adwNF)
          [LclId] =
              [ds_sdyxP] \r [n_sdyy2]
                  let {
                    sat_sdyy3 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (f_XdwdW a_adwNE b_adwNF)
                    [LclId] =
                        [ds_sdyxP n_sdyy2] \u []
                            ds_sdyxP
                                n_sdyy2 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sdyy3;
        } in  sat_sdyy4;

Data.Functor.Classes.$dmliftShowList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C(C1(U))))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sdyy5 sp_sdyy6 sl_sdyy7]
        let {
          sat_sdyy8 [Occ=Once] :: f_adw9R a_adwNq -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdyy5 sp_sdyy6 sl_sdyy7] \u []
                  Data.Functor.Classes.liftShowsPrec
                      $dShow1_sdyy5
                      sp_sdyy6
                      sl_sdyy7
                      Data.Functor.Classes.$fRead1Identity5;
        } in  GHC.Show.showList__ sat_sdyy8;

Data.Functor.Classes.$w$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> [(a, a1)] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyy9 w1_sdyya w2_sdyyb w3_sdyyc]
        let {
          lvl3_sdyyd [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_sdxZ3 -> GHC.Show.ShowS
          [LclId] =
              [w_sdyy9] \u [] GHC.Show.showsPrec w_sdyy9; } in
        let {
          sat_sdyyi [Occ=Once] :: (a_sdxZ3, a1_sdxZ5) -> GHC.Show.ShowS
          [LclId] =
              [w1_sdyya lvl3_sdyyd] \r [eta_sdyye]
                  case eta_sdyye of {
                    (,) ww1_sdyyg [Occ=Once] ww2_sdyyh [Occ=Once] ->
                        Data.Functor.Classes.$w$cliftShowsPrec2
                            lvl3_sdyyd w1_sdyya ww1_sdyyg ww2_sdyyh;
                  };
        } in  GHC.Show.showList__ sat_sdyyi w2_sdyyb w3_sdyyc;

Data.Functor.Classes.$fShow1(,)_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS) -> [(a, a1)] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyyj w1_sdyyk w2_sdyyl w3_sdyym w4_sdyyn]
        Data.Functor.Classes.$w$cliftShowList
            w_sdyyj w1_sdyyk w3_sdyym w4_sdyyn;

Data.Functor.Classes.$fShow1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => Data.Functor.Classes.Show1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdyyo]
        let {
          sat_sdyyu [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS) -> [(a_adwQx, a)] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyyo] \r [w_sdyyq w1_sdyyr w2_sdyys w3_sdyyt]
                  Data.Functor.Classes.$w$cliftShowList
                      $dShow_sdyyo w_sdyyq w2_sdyys w3_sdyyt; } in
        let {
          sat_sdyyp [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> (a_adwQx, a)
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyyo] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
                      $dShow_sdyyo eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdyyp sat_sdyyu];

Data.Functor.Classes.$fShow1Proxy1
  :: forall a.
     Data.Proxy.Proxy a -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sdyyv eta_B1] Data.Functor.Classes.$fShow1Proxy2 eta_B1;

Data.Functor.Classes.$fShow1Proxy_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Proxy.Proxy a]
     -> GHC.Show.ShowS
[GblId, Arity=4, Str=<L,A><L,A><S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [sp_sdyyw sl_sdyyx eta_sdyyy eta1_sdyyz]
        GHC.Show.showList__
            Data.Functor.Classes.$fShow1Proxy1 eta_sdyyy eta1_sdyyz;

Data.Functor.Classes.$fShow1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Proxy_$cliftShowList];

Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [GHC.Base.NonEmpty a]
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C(U)))><L,C(C(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdyyA sl_sdyyB eta_sdyyC eta1_sdyyD]
        let {
          sat_sdyyI [Occ=Once] :: GHC.Base.NonEmpty a_adx0n -> GHC.Show.ShowS
          [LclId] =
              [sp_sdyyA sl_sdyyB] \r [w_sdyyE]
                  case w_sdyyE of {
                    GHC.Base.:| ww1_sdyyG [Occ=Once] ww2_sdyyH [Occ=Once] ->
                        Data.Functor.Classes.$w$cliftShowsPrec1
                            sp_sdyyA sl_sdyyB 0# ww1_sdyyG ww2_sdyyH;
                  };
        } in  GHC.Show.showList__ sat_sdyyI eta_sdyyC eta1_sdyyD;

Data.Functor.Classes.$fShow1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList];

Data.Functor.Classes.$fShow1[]_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [[a]] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [sp_sdyyJ sl_sdyyK eta_B2 eta_B1]
        GHC.Show.showList__ sl_sdyyK eta_B2 eta_B1;

Data.Functor.Classes.$fShow1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1[]_$cliftShowList];

$w$dmliftReadListPrec_rdymw
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadP.ReadP [f a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdyyL w1_sdyyM w2_sdyyN]
        let {
          w3_sdyyO [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [f_sdxZb a_sdxZd]
          [LclId] =
              [w_sdyyL w1_sdyyM w2_sdyyN] \u []
                  let {
                    sat_sdyyQ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxZd]
                    [LclId] =
                        [w2_sdyyN] \u []
                            w2_sdyyN
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdyyR [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxZd]
                    [LclId] =
                        [sat_sdyyQ] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdyyQ eta_B1; } in
                  let {
                    sat_sdyyP [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxZd
                    [LclId] =
                        [w1_sdyyM] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w1_sdyyM eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadList w_sdyyL sat_sdyyP sat_sdyyR; } in
        let {
          sat_sdyyV [Occ=Once]
            :: forall b.
               ([f_sdxZb a_sdxZd] -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w3_sdyyO] \r [w4_sdyyS]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w3_sdyyO w4_sdyyS
                  of
                  { Unit# ww1_sdyyU [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdyyU];
                  };
        } in  sat_sdyyV;

$dmliftReadListPrec3_rdymx
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [f a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdyyW w1_sdyyX w2_sdyyY w3_sdyyZ]
        $w$dmliftReadListPrec_rdymw w_sdyyW w1_sdyyX w2_sdyyY;

Data.Functor.Classes.$dmliftReadListPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        $dmliftReadListPrec3_rdymx eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$dmliftReadPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(C(U)))),A,A,A)><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyz0 rp_sdyz1 rl_sdyz2]
        let {
          f1_sdyz3 [Occ=OnceL!, Dmd=<L,C(C(U))>]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdweR a_adwMZ)
          [LclId] =
              [$dRead1_sdyz0 rp_sdyz1 rl_sdyz2] \u []
                  let {
                    sat_sdyz5 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adwMZ]
                    [LclId] =
                        [rl_sdyz2] \u []
                            rl_sdyz2
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdyz6 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adwMZ]
                    [LclId] =
                        [sat_sdyz5] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdyz5 eta_B1; } in
                  let {
                    sat_sdyz4 [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwMZ
                    [LclId] =
                        [rp_sdyz1] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S rp_sdyz1 eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdyz0 sat_sdyz4 sat_sdyz6; } in
        let {
          sat_sdyzd [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [f1_sdyz3] \r [n_sdyz7]
                  let {
                    w_sdyz8 [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS (f_XdweR a_adwMZ)
                    [LclId] =
                        [f1_sdyz3 n_sdyz7] \u [] f1_sdyz3 n_sdyz7; } in
                  let {
                    sat_sdyzc [Occ=OnceT[0]]
                      :: forall b.
                         (f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b)
                         -> Text.ParserCombinators.ReadP.P b
                    [LclId] =
                        [w_sdyz8] \r [w1_sdyz9]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdyz8 w1_sdyz9
                            of
                            { Unit# ww1_sdyzb [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyzb];
                            };
                  } in  sat_sdyzc;
        } in  sat_sdyzd;

Data.Functor.Classes.$dmliftReadList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C1(C(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyze rp_sdyzf rl_sdyzg]
        let {
          sat_sdyzo [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_XdweS a_adwMJ]
          [LclId] =
              [$dRead1_sdyze rp_sdyzf rl_sdyzg] \u []
                  let {
                    sat_sdyzn [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec (f_XdweS a_adwMJ)
                    [LclId] =
                        [$dRead1_sdyze rp_sdyzf rl_sdyzg] \s []
                            let {
                              sat_sdyzm [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwMJ]
                              [LclId] =
                                  [rl_sdyzg] \r [n_sdyzi w1_sdyzj]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl_sdyzg w1_sdyzj
                                      of
                                      { Unit# ww1_sdyzl [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdyzl];
                                      }; } in
                            let {
                              sat_sdyzh [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwMJ
                              [LclId] =
                                  [rp_sdyzf] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp_sdyzf eta_B1;
                            } in 
                              Data.Functor.Classes.liftReadPrec
                                  $dRead1_sdyze sat_sdyzh sat_sdyzm;
                  } in 
                    GHC.Read.list
                        sat_sdyzn
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyzo;

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [rp_sdyzp rl_sdyzq]
        let {
          f_sdyzr [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adx31
          [LclId, Arity=1, Unf=OtherCon []] =
              [rp_sdyzp] \r [eta_B1]
                  Text.ParserCombinators.ReadPrec.readPrec_to_S rp_sdyzp eta_B1; } in
        let {
          f1_sdyzs [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adx31]
          [LclId] =
              [rl_sdyzq] \u []
                  rl_sdyzq
                      Data.Functor.Classes.$fRead1Identity5
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          f2_sdyzt [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [a_adx31]
          [LclId, Arity=1, Unf=OtherCon []] =
              [f1_sdyzs] \r [eta_B1]
                  Text.ParserCombinators.ReadP.run f1_sdyzs eta_B1; } in
        let {
          sat_sdyzC [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (GHC.Base.NonEmpty a_adx31 -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [f_sdyzr f2_sdyzt] \r [n_sdyzu eta_sdyzv]
                  let {
                    sat_sdyzz [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_adx31)
                    [LclId] =
                        [f_sdyzr f2_sdyzt n_sdyzu] \r [w_sdyzw]
                            case n_sdyzu of {
                              GHC.Types.I# ww1_sdyzy [Occ=Once] ->
                                  Data.Functor.Classes.$w$cliftReadsPrec5
                                      f_sdyzr f2_sdyzt ww1_sdyzy w_sdyzw;
                            };
                  } in 
                    case
                        Text.ParserCombinators.ReadP.$wreadS_to_P sat_sdyzz eta_sdyzv
                    of
                    { Unit# ww1_sdyzB [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Look [ww1_sdyzB];
                    };
        } in  sat_sdyzC;

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.NonEmpty a]
[GblId, Arity=2, Str=<L,C(C(U))><L,C(U)>, Unf=OtherCon []] =
    [] \r [rp_sdyzD rl_sdyzE]
        let {
          sat_sdyzY [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [GHC.Base.NonEmpty a_adx2T]
          [LclId] =
              [rp_sdyzD rl_sdyzE] \u []
                  let {
                    f_sdyzF [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adx2T
                    [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                        [rp_sdyzD] \r [n_sdyzG]
                            let {
                              sat_sdyzK [Occ=Once] :: Text.ParserCombinators.ReadP.P a_adx2T
                              [LclId] =
                                  [rp_sdyzD n_sdyzG] \u []
                                      let {
                                        sat_sdyzH [Occ=Once, Dmd=<L,C(U)>]
                                          :: Text.ParserCombinators.ReadP.ReadS a_adx2T
                                        [LclId] =
                                            [rp_sdyzD n_sdyzG] \u [] rp_sdyzD n_sdyzG;
                                      } in 
                                        case
                                            Text.ParserCombinators.ReadP.$wreadS_to_P
                                                sat_sdyzH
                                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                        of
                                        { Unit# ww1_sdyzJ [Occ=Once] ->
                                              Text.ParserCombinators.ReadP.Look [ww1_sdyzJ];
                                        };
                            } in  Text.ParserCombinators.ReadP.run sat_sdyzK; } in
                  let {
                    f1_sdyzL [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adx2T]
                    [LclId] =
                        [rl_sdyzE] \u []
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P
                                    rl_sdyzE Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                            of
                            { Unit# ww1_sdyzN [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyzN];
                            }; } in
                  let {
                    f2_sdyzO [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adx2T]
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [f1_sdyzL] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run f1_sdyzL eta_B1; } in
                  let {
                    sat_sdyzX [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.NonEmpty a_adx2T)
                    [LclId] =
                        [f_sdyzF f2_sdyzO] \r [n_sdyzP eta_sdyzQ]
                            let {
                              sat_sdyzU [Occ=Once]
                                :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_adx2T)
                              [LclId] =
                                  [f_sdyzF f2_sdyzO n_sdyzP] \r [w_sdyzR]
                                      case n_sdyzP of {
                                        GHC.Types.I# ww1_sdyzT [Occ=Once] ->
                                            Data.Functor.Classes.$w$cliftReadsPrec5
                                                f_sdyzF f2_sdyzO ww1_sdyzT w_sdyzR;
                                      };
                            } in 
                              case
                                  Text.ParserCombinators.ReadP.$wreadS_to_P sat_sdyzU eta_sdyzQ
                              of
                              { Unit# ww1_sdyzW [Occ=Once] ->
                                    Text.ParserCombinators.ReadP.Look [ww1_sdyzW];
                              };
                  } in 
                    GHC.Read.list
                        sat_sdyzX
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyzY;

Data.Functor.Classes.$w$cliftReadListPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> forall b.
        ([GHC.Base.NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [w_sdyzZ w1_sdyA0]
        let {
          w2_sdyA1 [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [GHC.Base.NonEmpty a_sdxZp]
          [LclId] =
              [w_sdyzZ w1_sdyA0] \u []
                  let {
                    sat_sdyA3 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxZp]
                    [LclId] =
                        [w1_sdyA0] \u []
                            w1_sdyA0
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdyA4 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxZp]
                    [LclId] =
                        [sat_sdyA3] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdyA3 eta_B1; } in
                  let {
                    sat_sdyA2 [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxZp
                    [LclId] =
                        [w_sdyzZ] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w_sdyzZ eta_B1;
                  } in 
                    Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
                        sat_sdyA2 sat_sdyA4; } in
        let {
          sat_sdyA8 [Occ=OnceT[0]]
            :: forall b.
               ([GHC.Base.NonEmpty a_sdxZp] -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w2_sdyA1] \r [w3_sdyA5]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w2_sdyA1 w3_sdyA5
                  of
                  { Unit# ww1_sdyA7 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdyA7];
                  };
        } in  sat_sdyA8;

Data.Functor.Classes.$fRead1NonEmpty1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([GHC.Base.NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdyA9 w1_sdyAa w2_sdyAb]
        Data.Functor.Classes.$w$cliftReadListPrec2 w_sdyA9 w1_sdyAa;

Data.Functor.Classes.$fRead1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
                                                 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
                                                 Data.Functor.Classes.$fRead1NonEmpty1];

Data.Functor.Classes.$dmliftReadsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyAc rp_sdyAd rl_sdyAe]
        let {
          ds_sdyAf [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_XdweY a_adwMu)
          [LclId] =
              [$dRead1_sdyAc rp_sdyAd rl_sdyAe] \u []
                  let {
                    sat_sdyAl [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwMu]
                    [LclId] =
                        [rl_sdyAe] \r [n_sdyAh w1_sdyAi]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sdyAe w1_sdyAi
                            of
                            { Unit# ww1_sdyAk [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyAk];
                            }; } in
                  let {
                    sat_sdyAg [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwMu
                    [LclId] =
                        [rp_sdyAd] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sdyAd eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadPrec
                        $dRead1_sdyAc sat_sdyAg sat_sdyAl; } in
        let {
          sat_sdyAo [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdweY a_adwMu)
          [LclId] =
              [ds_sdyAf] \r [n_sdyAm]
                  let {
                    sat_sdyAn [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (f_XdweY a_adwMu)
                    [LclId] =
                        [ds_sdyAf n_sdyAm] \u []
                            ds_sdyAf
                                n_sdyAm Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sdyAn;
        } in  sat_sdyAo;

Data.Functor.Classes.eq1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) =>
     f a -> f a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sdyAp $dEq_sdyAq]
        let {
          sat_sdyAr [Occ=Once] :: a_adwMf -> a_adwMf -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdyAq] \u [] GHC.Classes.== $dEq_sdyAq;
        } in  $dEq1_sdyAp sat_sdyAr;

Data.Functor.Classes.compare1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) =>
     f a -> f a -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)),1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sdyAs $dOrd_sdyAt]
        let {
          sat_sdyAu [Occ=Once] :: a_adwM3 -> a_adwM3 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdyAt] \u [] GHC.Classes.compare $dOrd_sdyAt;
        } in  Data.Functor.Classes.liftCompare $dOrd1_sdyAs sat_sdyAu;

Data.Functor.Classes.readsPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLL),1*U(1*C1(C1(U)),A,A,A)><L,U(1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyAv $dRead_sdyAw]
        let {
          sat_sdyAy [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [a_adwLh]
          [LclId] =
              [$dRead_sdyAw] \u [] GHC.Read.readList $dRead_sdyAw; } in
        let {
          sat_sdyAx [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLh
          [LclId] =
              [$dRead_sdyAw] \u [] GHC.Read.readsPrec $dRead_sdyAw;
        } in 
          Data.Functor.Classes.liftReadsPrec
              $dRead1_sdyAv sat_sdyAx sat_sdyAy;

Data.Functor.Classes.readsUnary1
  :: forall (f :: * -> *) a t.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     GHC.Base.String
     -> (f a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyAz
           $dRead_sdyAA
           name_sdyAB
           cons_sdyAC
           kw_sdyAD
           s_sdyAE]
        case GHC.Base.eqString kw_sdyAD name_sdyAB of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdyAG [Occ=LoopBreaker]
                  :: [(f_adwLt a_adwLu, GHC.Base.String)]
                     -> [(t_adwLv, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdyAC go_sdyAG] \r [ds_sdyAH]
                        case ds_sdyAH of {
                          [] -> [] [];
                          : y_sdyAJ [Occ=Once!] ys_sdyAK [Occ=Once] ->
                              case y_sdyAJ of {
                                (,) x_sdyAM [Occ=Once] t1_sdyAN [Occ=Once] ->
                                    let {
                                      sat_sdyAQ [Occ=Once] :: [(t_adwLv, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdyAG ys_sdyAK] \u [] go_sdyAG ys_sdyAK; } in
                                    let {
                                      sat_sdyAO [Occ=Once] :: t_adwLv
                                      [LclId] =
                                          [cons_sdyAC x_sdyAM] \u [] cons_sdyAC x_sdyAM; } in
                                    let {
                                      sat_sdyAP [Occ=Once] :: (t_adwLv, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdyAO t1_sdyAN];
                                    } in  : [sat_sdyAP sat_sdyAQ];
                              };
                        }; } in
              let {
                sat_sdyAS [Occ=Once]
                  :: Text.ParserCombinators.ReadP.ReadS [a_adwLu]
                [LclId] =
                    [$dRead_sdyAA] \u [] GHC.Read.readList $dRead_sdyAA; } in
              let {
                sat_sdyAR [Occ=Once]
                  :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLu
                [LclId] =
                    [$dRead_sdyAA] \u [] GHC.Read.readsPrec $dRead_sdyAA;
              } in 
                case
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdyAz
                        sat_sdyAR
                        sat_sdyAS
                        Data.Functor.Classes.$fRead1Const1
                        s_sdyAE
                of
                sat_sdyAT
                { __DEFAULT -> go_sdyAG sat_sdyAT;
                };
        };

Data.Functor.Classes.readsBinary1
  :: forall (f :: * -> *) (g :: * -> *) a t.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Base.String
     -> (f a -> g a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(C(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><S,1*U><L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyAU
           $dRead2_sdyAV
           $dRead_sdyAW
           name_sdyAX
           cons_sdyAY
           kw_sdyAZ
           s_sdyB0]
        case GHC.Base.eqString kw_sdyAZ name_sdyAX of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                lvl3_sdyB2
                  :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLJ
                [LclId] =
                    [$dRead_sdyAW] \u [] GHC.Read.readsPrec $dRead_sdyAW; } in
              let {
                lvl4_sdyB3 :: Text.ParserCombinators.ReadP.ReadS [a_adwLJ]
                [LclId] =
                    [$dRead_sdyAW] \u [] GHC.Read.readList $dRead_sdyAW; } in
              let {
                go_sdyB4 [Occ=LoopBreaker]
                  :: [(f_adwLH a_adwLJ, GHC.Base.String)]
                     -> [(t_adwLK, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [$dRead2_sdyAV
                              cons_sdyAY
                              lvl3_sdyB2
                              lvl4_sdyB3
                              go_sdyB4] \r [ds_sdyB5]
                        case ds_sdyB5 of {
                          [] -> [] [];
                          : y_sdyB7 [Occ=Once!] ys_sdyB8 [Occ=Once] ->
                              case y_sdyB7 of {
                                (,) x_sdyBa [Occ=OnceL] t1_sdyBb [Occ=Once] ->
                                    let {
                                      z_sdyBc [Occ=OnceL] :: [(t_adwLK, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdyB4 ys_sdyB8] \u [] go_sdyB4 ys_sdyB8; } in
                                    let {
                                      go1_sdyBd [Occ=LoopBreaker]
                                        :: [(g_adwLI a_adwLJ, GHC.Base.String)]
                                           -> [(t_adwLK, GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [cons_sdyAY
                                                    x_sdyBa
                                                    z_sdyBc
                                                    go1_sdyBd] \r [ds1_sdyBe]
                                              case ds1_sdyBe of {
                                                [] -> z_sdyBc;
                                                : y1_sdyBg [Occ=Once!] ys1_sdyBh [Occ=Once] ->
                                                    case y1_sdyBg of {
                                                      (,) y2_sdyBj [Occ=Once] u_sdyBk [Occ=Once] ->
                                                          let {
                                                            sat_sdyBn [Occ=Once]
                                                              :: [(t_adwLK, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdyBd ys1_sdyBh] \u []
                                                                    go1_sdyBd ys1_sdyBh; } in
                                                          let {
                                                            sat_sdyBl [Occ=Once] :: t_adwLK
                                                            [LclId] =
                                                                [cons_sdyAY x_sdyBa y2_sdyBj] \u []
                                                                    cons_sdyAY
                                                                        x_sdyBa y2_sdyBj; } in
                                                          let {
                                                            sat_sdyBm [Occ=Once]
                                                              :: (t_adwLK, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sdyBl u_sdyBk];
                                                          } in  : [sat_sdyBm sat_sdyBn];
                                                    };
                                              };
                                    } in 
                                      case
                                          Data.Functor.Classes.liftReadsPrec
                                              $dRead2_sdyAV
                                              lvl3_sdyB2
                                              lvl4_sdyB3
                                              Data.Functor.Classes.$fRead1Const1
                                              t1_sdyBb
                                      of
                                      sat_sdyBo
                                      { __DEFAULT -> go1_sdyBd sat_sdyBo;
                                      };
                              };
                        };
              } in 
                case
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdyAU
                        lvl3_sdyB2
                        lvl4_sdyB3
                        Data.Functor.Classes.$fRead1Const1
                        s_sdyB0
                of
                sat_sdyBp
                { __DEFAULT -> go_sdyB4 sat_sdyBp;
                };
        };

Data.Functor.Classes.readPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyBq $dRead_sdyBr]
        let {
          sat_sdyBt [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwL4]
          [LclId] =
              [$dRead_sdyBr] \u [] GHC.Read.readListPrec $dRead_sdyBr; } in
        let {
          sat_sdyBs [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwL4
          [LclId] =
              [$dRead_sdyBr] \u [] GHC.Read.readPrec $dRead_sdyBr;
        } in 
          Data.Functor.Classes.liftReadPrec
              $dRead1_sdyBq sat_sdyBs sat_sdyBt;

Data.Functor.Classes.liftReadListDefault
  :: forall (f :: * -> *) a.
     Data.Functor.Classes.Read1 f =>
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyBu rp_sdyBv rl_sdyBw]
        let {
          sat_sdyBD [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_adwKQ a_adwKR]
          [LclId] =
              [$dRead1_sdyBu rp_sdyBv rl_sdyBw] \u []
                  let {
                    sat_sdyBC [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwKR]
                    [LclId] =
                        [rl_sdyBw] \r [n_sdyBy w1_sdyBz]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sdyBw w1_sdyBz
                            of
                            { Unit# ww1_sdyBB [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyBB];
                            }; } in
                  let {
                    sat_sdyBx [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwKR
                    [LclId] =
                        [rp_sdyBv] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sdyBv eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadListPrec
                        $dRead1_sdyBu
                        sat_sdyBx
                        sat_sdyBC
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyBD;

Data.Functor.Classes.liftReadListPrecDefault
  :: forall (f :: * -> *) a.
     Data.Functor.Classes.Read1 f =>
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C1(C(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdyBE rp_sdyBF rl_sdyBG]
        let {
          sat_sdyBH [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_adwKH a_adwKI)
          [LclId] =
              [$dRead1_sdyBE rp_sdyBF rl_sdyBG] \s []
                  Data.Functor.Classes.liftReadPrec $dRead1_sdyBE rp_sdyBF rl_sdyBG;
        } in  GHC.Read.list sat_sdyBH;

lvl_rdymy
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Proxy.Proxy a]
[GblId] =
    [] \u [] GHC.Read.list Data.Functor.Classes.$fRead1Proxy1;

Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [Data.Proxy.Proxy a]
[GblId, Arity=2, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdyBI rl_sdyBJ] lvl_rdymy;

Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Proxy.Proxy a)
[GblId, Arity=3, Str=<L,A><L,A><L,U>, Unf=OtherCon []] =
    [] \r [rp_sdyBK rl_sdyBL n_sdyBM]
        let {
          sat_sdyBN [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Proxy.Proxy a_adx12)
          [LclId] =
              [n_sdyBM] \u []
                  GHC.Read.list3
                      Data.Functor.Classes.$fRead1Proxy2
                      n_sdyBM
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyBN;

lvl1_rdymz
  :: forall a. Text.ParserCombinators.ReadP.P [Data.Proxy.Proxy a]
[GblId] =
    [] \u []
        GHC.Read.list
            Data.Functor.Classes.$fRead1Proxy1
            Data.Functor.Classes.$fRead1Identity5
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

lvl2_rdymA
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS [Data.Proxy.Proxy a]
[GblId, Arity=1, Unf=OtherCon []] =
    sat-only [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run lvl1_rdymz eta_B1;

Data.Functor.Classes.$fRead1Proxy_$cliftReadList
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Proxy.Proxy a]
[GblId, Arity=3, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdyBO rl_sdyBP eta_B1] lvl2_rdymA eta_B1;

Data.Functor.Classes.$fRead1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Proxy_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Proxy5
                                                 Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec];

Data.Functor.Classes.$fRead1[]_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [[a]]
[GblId, Arity=2, Str=<L,A><L,1*C1(C(U))>, Unf=OtherCon []] =
    [] \r [rp_sdyBQ rl_sdyBR] GHC.Read.list rl_sdyBR;

Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,C(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [rp_sdyBS rl_sdyBT eta_sdyBU]
        let {
          sat_sdyBX [Occ=Once] :: Text.ParserCombinators.ReadP.P [a_adx3j]
          [LclId] =
              [rl_sdyBT] \u []
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P
                          rl_sdyBT Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                  of
                  { Unit# ww1_sdyBW [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdyBW];
                  };
        } in  Text.ParserCombinators.ReadP.run sat_sdyBX;

Data.Functor.Classes.$w$cliftReadList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [[a]]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [w_sdyBY]
        let {
          sat_sdyC4 [Occ=Once] :: Text.ParserCombinators.ReadP.P [[a_sdxZW]]
          [LclId] =
              [w_sdyBY] \u []
                  let {
                    sat_sdyC3 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_sdxZW]
                    [LclId] =
                        [w_sdyBY] \r [n_sdyBZ w1_sdyC0]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdyBY w1_sdyC0
                            of
                            { Unit# ww1_sdyC2 [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyC2];
                            };
                  } in 
                    GHC.Read.list
                        sat_sdyC3
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyC4;

Data.Functor.Classes.$fRead1[]_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [[a]]
[GblId, Arity=2, Str=<L,A><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_sdyC5 w1_sdyC6]
        Data.Functor.Classes.$w$cliftReadList2 w1_sdyC6;

Data.Functor.Classes.$fRead1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 []
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadList
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadPrec
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadListPrec];

Data.Functor.Classes.showsPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Types.Int -> f a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U(1*U,A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sdyC7 $dShow_sdyC8]
        let {
          sat_sdyCa [Occ=Once] :: [a_adwJB] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyC8] \u [] GHC.Show.showList $dShow_sdyC8; } in
        let {
          sat_sdyC9 [Occ=Once] :: GHC.Types.Int -> a_adwJB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyC8] \u [] GHC.Show.showsPrec $dShow_sdyC8;
        } in 
          Data.Functor.Classes.liftShowsPrec
              $dShow1_sdyC7 sat_sdyC9 sat_sdyCa;

Data.Functor.Classes.showsUnaryWith1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [' '#];

Data.Functor.Classes.$wshowsUnary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Prim.Int# -> f a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyCb w1_sdyCc w2_sdyCd ww_sdyCe w3_sdyCf]
        let {
          g_sdyCg [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyCb w1_sdyCc w3_sdyCf] \u []
                  let {
                    sat_sdyCi [Occ=Once] :: [a_sdy01] -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sdyCc] \u [] GHC.Show.showList w1_sdyCc; } in
                  let {
                    sat_sdyCh [Occ=Once] :: GHC.Types.Int -> a_sdy01 -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sdyCc] \u [] GHC.Show.showsPrec w1_sdyCc;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sdyCb
                        sat_sdyCh
                        sat_sdyCi
                        Data.Functor.Classes.$fRead1Const1
                        w3_sdyCf;
        } in 
          case ># [ww_sdyCe 10#] of {
            __DEFAULT ->
                let {
                  sat_sdyCn [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdyCd g_sdyCg] \r [x_sdyCk]
                          let {
                            sat_sdyCl [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdyCg x_sdyCk] \u [] g_sdyCg x_sdyCk; } in
                          let {
                            sat_sdyCm [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyCl];
                          } in  GHC.Base.++ w2_sdyCd sat_sdyCm;
                } in  sat_sdyCn;
            1# ->
                let {
                  sat_sdyCt [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdyCd g_sdyCg] \r [x_sdyCo]
                          let {
                            sat_sdyCs [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w2_sdyCd g_sdyCg x_sdyCo] \u []
                                    let {
                                      sat_sdyCq [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdyCg x_sdyCo] \u []
                                              let {
                                                sat_sdyCp [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdyCo];
                                              } in  g_sdyCg sat_sdyCp; } in
                                    let {
                                      sat_sdyCr [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyCq];
                                    } in  GHC.Base.++ w2_sdyCd sat_sdyCr;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdyCs];
                } in  sat_sdyCt;
          };

Data.Functor.Classes.showsUnary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Types.Int -> f a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyCu w1_sdyCv w2_sdyCw w3_sdyCx w4_sdyCy]
        case w3_sdyCx of {
          GHC.Types.I# ww1_sdyCA [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnary1
                  w_sdyCu w1_sdyCv w2_sdyCw ww1_sdyCA w4_sdyCy;
        };

Data.Functor.Classes.$wshowsBinary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Prim.Int# -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyCB
           w1_sdyCC
           w2_sdyCD
           w3_sdyCE
           ww_sdyCF
           w4_sdyCG
           w5_sdyCH]
        let {
          f1_sdyCI [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyCB w2_sdyCD w4_sdyCG] \u []
                  let {
                    sat_sdyCK [Occ=Once] :: [a_sdy0e] -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdyCD] \u [] GHC.Show.showList w2_sdyCD; } in
                  let {
                    sat_sdyCJ [Occ=Once] :: GHC.Types.Int -> a_sdy0e -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdyCD] \u [] GHC.Show.showsPrec w2_sdyCD;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sdyCB
                        sat_sdyCJ
                        sat_sdyCK
                        Data.Functor.Classes.$fRead1Const1
                        w4_sdyCG; } in
        let {
          g1_sdyCL [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdyCC w2_sdyCD w5_sdyCH] \u []
                  let {
                    sat_sdyCN [Occ=Once] :: [a_sdy0e] -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdyCD] \u [] GHC.Show.showList w2_sdyCD; } in
                  let {
                    sat_sdyCM [Occ=Once] :: GHC.Types.Int -> a_sdy0e -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdyCD] \u [] GHC.Show.showsPrec w2_sdyCD;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w1_sdyCC
                        sat_sdyCM
                        sat_sdyCN
                        Data.Functor.Classes.$fRead1Const1
                        w5_sdyCH;
        } in 
          case ># [ww_sdyCF 10#] of {
            __DEFAULT ->
                let {
                  sat_sdyCU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w3_sdyCE f1_sdyCI g1_sdyCL] \r [x_sdyCP]
                          let {
                            sat_sdyCS [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_sdyCI g1_sdyCL x_sdyCP] \u []
                                    let {
                                      sat_sdyCQ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g1_sdyCL x_sdyCP] \u [] g1_sdyCL x_sdyCP; } in
                                    let {
                                      sat_sdyCR [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyCQ];
                                    } in  f1_sdyCI sat_sdyCR; } in
                          let {
                            sat_sdyCT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyCS];
                          } in  GHC.Base.++ w3_sdyCE sat_sdyCT;
                } in  sat_sdyCU;
            1# ->
                let {
                  sat_sdyD2 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w3_sdyCE f1_sdyCI g1_sdyCL] \r [x_sdyCV]
                          let {
                            sat_sdyD1 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w3_sdyCE f1_sdyCI g1_sdyCL x_sdyCV] \u []
                                    let {
                                      sat_sdyCZ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_sdyCI g1_sdyCL x_sdyCV] \u []
                                              let {
                                                sat_sdyCX [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_sdyCL x_sdyCV] \u []
                                                        let {
                                                          sat_sdyCW [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdyCV];
                                                        } in  g1_sdyCL sat_sdyCW; } in
                                              let {
                                                sat_sdyCY [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [Data.Functor.Classes.showsUnaryWith1
                                                             sat_sdyCX];
                                              } in  f1_sdyCI sat_sdyCY; } in
                                    let {
                                      sat_sdyD0 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyCZ];
                                    } in  GHC.Base.++ w3_sdyCE sat_sdyD0;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdyD1];
                } in  sat_sdyD2;
          };

Data.Functor.Classes.showsBinary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Types.Int -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S(S),1*U(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyD3
           w1_sdyD4
           w2_sdyD5
           w3_sdyD6
           w4_sdyD7
           w5_sdyD8
           w6_sdyD9]
        case w4_sdyD7 of {
          GHC.Types.I# ww1_sdyDb [Occ=Once] ->
              Data.Functor.Classes.$wshowsBinary1
                  w_sdyD3 w1_sdyD4 w2_sdyD5 w3_sdyD6 ww1_sdyDb w5_sdyD8 w6_sdyD9;
        };

Data.Functor.Classes.eq2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Eq2 f, GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     f a b -> f a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*U(1*U,A)><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq2_sdyDc $dEq_sdyDd $dEq1_sdyDe]
        let {
          sat_sdyDg [Occ=Once] :: b_adwJk -> b_adwJk -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sdyDe] \u [] GHC.Classes.== $dEq1_sdyDe; } in
        let {
          sat_sdyDf [Occ=Once] :: a_adwJj -> a_adwJj -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdyDd] \u [] GHC.Classes.== $dEq_sdyDd;
        } in  $dEq2_sdyDc sat_sdyDf sat_sdyDg;

Data.Functor.Classes.compare2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Ord2 f, GHC.Classes.Ord a,
      GHC.Classes.Ord b) =>
     f a b -> f a b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,1*U(A,1*U,A,A,A,A,A,A)><L,1*U(A,1*U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd2_sdyDh $dOrd_sdyDi $dOrd1_sdyDj]
        let {
          sat_sdyDl [Occ=Once] :: b_adwJ2 -> b_adwJ2 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sdyDj] \u [] GHC.Classes.compare $dOrd1_sdyDj; } in
        let {
          sat_sdyDk [Occ=Once] :: a_adwJ1 -> a_adwJ1 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdyDi] \u [] GHC.Classes.compare $dOrd_sdyDi;
        } in 
          Data.Functor.Classes.liftCompare2 $dOrd2_sdyDh sat_sdyDk sat_sdyDl;

Data.Functor.Classes.readsPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Read2 f, GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(C(S))))LLL),1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><L,U(1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyDm $dRead_sdyDn $dRead1_sdyDo]
        let {
          sat_sdyDs [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [b_adwII]
          [LclId] =
              [$dRead1_sdyDo] \u [] GHC.Read.readList $dRead1_sdyDo; } in
        let {
          sat_sdyDr [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_adwII
          [LclId] =
              [$dRead1_sdyDo] \u [] GHC.Read.readsPrec $dRead1_sdyDo; } in
        let {
          sat_sdyDq [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [a_adwIH]
          [LclId] =
              [$dRead_sdyDn] \u [] GHC.Read.readList $dRead_sdyDn; } in
        let {
          sat_sdyDp [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwIH
          [LclId] =
              [$dRead_sdyDn] \u [] GHC.Read.readsPrec $dRead_sdyDn;
        } in 
          Data.Functor.Classes.liftReadsPrec2
              $dRead2_sdyDm sat_sdyDp sat_sdyDq sat_sdyDr sat_sdyDs;

Data.Functor.Classes.readPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Read2 f, GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U(A,A,1*U,1*U)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyDt $dRead_sdyDu $dRead1_sdyDv]
        let {
          sat_sdyDz [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwIo]
          [LclId] =
              [$dRead1_sdyDv] \u [] GHC.Read.readListPrec $dRead1_sdyDv; } in
        let {
          sat_sdyDy [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwIo
          [LclId] =
              [$dRead1_sdyDv] \u [] GHC.Read.readPrec $dRead1_sdyDv; } in
        let {
          sat_sdyDx [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwIn]
          [LclId] =
              [$dRead_sdyDu] \u [] GHC.Read.readListPrec $dRead_sdyDu; } in
        let {
          sat_sdyDw [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwIn
          [LclId] =
              [$dRead_sdyDu] \u [] GHC.Read.readPrec $dRead_sdyDu;
        } in 
          Data.Functor.Classes.liftReadPrec2
              $dRead2_sdyDt sat_sdyDw sat_sdyDx sat_sdyDy sat_sdyDz;

Data.Functor.Classes.liftReadList2Default
  :: forall (f :: * -> * -> *) a b.
     Data.Functor.Classes.Read2 f =>
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(C1(C1(C1(U)))))))><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyDA rp1_sdyDB rl1_sdyDC rp2_sdyDD rl2_sdyDE]
        let {
          sat_sdyDR [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_adwHZ a_adwI0 b_adwI1]
          [LclId] =
              [$dRead2_sdyDA rp1_sdyDB rl1_sdyDC rp2_sdyDD rl2_sdyDE] \u []
                  let {
                    sat_sdyDQ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwI1]
                    [LclId] =
                        [rl2_sdyDE] \r [n_sdyDM w1_sdyDN]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl2_sdyDE w1_sdyDN
                            of
                            { Unit# ww1_sdyDP [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyDP];
                            }; } in
                  let {
                    sat_sdyDL [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwI1
                    [LclId] =
                        [rp2_sdyDD] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                rp2_sdyDD eta_B1; } in
                  let {
                    sat_sdyDK [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwI0]
                    [LclId] =
                        [rl1_sdyDC] \r [n_sdyDG w1_sdyDH]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl1_sdyDC w1_sdyDH
                            of
                            { Unit# ww1_sdyDJ [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdyDJ];
                            }; } in
                  let {
                    sat_sdyDF [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwI0
                    [LclId] =
                        [rp1_sdyDB] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp1_sdyDB eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadListPrec2
                        $dRead2_sdyDA
                        sat_sdyDF
                        sat_sdyDK
                        sat_sdyDL
                        sat_sdyDQ
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyDR;

Data.Functor.Classes.$fRead2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 Data.Either.Either
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2Either_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1Either8
                                                 Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2Either_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a b]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2Either eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2Const_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1Const6
                                                 Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2Const_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Const.Const a b]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2Const eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 (,)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2(,)_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1(,)2
                                                 Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2(,)_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [(a, b)]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2(,) eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.liftReadListPrec2Default
  :: forall (f :: * -> * -> *) a b.
     Data.Functor.Classes.Read2 f =>
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C1(C(U)))))),A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdyDS rp1_sdyDT rl1_sdyDU rp2_sdyDV rl2_sdyDW]
        let {
          sat_sdyDX [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_adwHO a_adwHP b_adwHQ)
          [LclId] =
              [$dRead2_sdyDS rp1_sdyDT rl1_sdyDU rp2_sdyDV rl2_sdyDW] \s []
                  Data.Functor.Classes.liftReadPrec2
                      $dRead2_sdyDS rp1_sdyDT rl1_sdyDU rp2_sdyDV rl2_sdyDW;
        } in  GHC.Read.list sat_sdyDX;

Data.Functor.Classes.$fRead1(,)1
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a, a1) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdyDY eta_sdyDZ eta1_sdyE0 eta2_sdyE1 eta3_sdyE2]
        let {
          sat_sdyE3 [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwUw
          [LclId] =
              [$dRead_sdyDY] \u [] GHC.Read.readPrec $dRead_sdyDY;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec2
              sat_sdyE3 eta_sdyDZ eta2_sdyE1 eta3_sdyE2;

Data.Functor.Classes.$w$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (a, a1)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyE4 w1_sdyE5 w2_sdyE6]
        let {
          sat_sdyE9 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (a_sdy0L, a1_sdy0N)
          [LclId] =
              [w_sdyE4 w1_sdyE5 w2_sdyE6] \u []
                  let {
                    sat_sdyE8 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a1_sdy0N
                    [LclId] =
                        [w1_sdyE5] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdyE5 eta_B1; } in
                  let {
                    sat_sdyE7 [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy0L
                    [LclId] =
                        [w_sdyE4] \u [] GHC.Read.readPrec w_sdyE4;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec2
                        sat_sdyE7
                        sat_sdyE8
                        w2_sdyE6
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyE9;

Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyEa w1_sdyEb w2_sdyEc w3_sdyEd]
        Data.Functor.Classes.$w$cliftReadsPrec w_sdyEa w1_sdyEb w3_sdyEd;

Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [(a, a1)]
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdyEe rp_sdyEf rl_sdyEg]
        let {
          sat_sdyEh [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_XdwZz, a1_adwV6)
          [LclId] =
              [$dRead_sdyEe rp_sdyEf rl_sdyEg] \r [eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)1
                      $dRead_sdyEe rp_sdyEf rl_sdyEg eta_B2 eta_B1;
        } in  GHC.Read.list sat_sdyEh;

Data.Functor.Classes.$fRead1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => Data.Functor.Classes.Read1 ((,) a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdyEi]
        let {
          sat_sdyEp [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec [(a_XdwZy, a)]
          [LclId] =
              [$dRead_sdyEi] \r [eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
                      $dRead_sdyEi eta_B2 eta_B1; } in
        let {
          sat_sdyEo [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec (a_XdwZy, a)
          [LclId] =
              [$dRead_sdyEi] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)1
                      $dRead_sdyEi eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyEn [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS [(a_XdwZy, a)]
          [LclId] =
              [$dRead_sdyEi] \u []
                  Data.Functor.Classes.$fRead1(,)_$cliftReadList $dRead_sdyEi; } in
        let {
          sat_sdyEm [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (a_XdwZy, a)
          [LclId] =
              [$dRead_sdyEi] \r [w_sdyEj w1_sdyEk w2_sdyEl]
                  Data.Functor.Classes.$w$cliftReadsPrec
                      $dRead_sdyEi w_sdyEj w2_sdyEl;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdyEm
                                        sat_sdyEn
                                        sat_sdyEo
                                        sat_sdyEp];
Data.Functor.Classes.$fRead1(,)_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS [(a, a1)]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdyEq]
        let {
          sat_sdyEr [Occ=Once] :: Data.Functor.Classes.Read1 ((,) a_XdwZA)
          [LclId] =
              [$dRead_sdyEq] \u [] Data.Functor.Classes.$fRead1(,) $dRead_sdyEq;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdyEr;

Data.Functor.Classes.showsPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Show2 f, GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> f a b -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(C(S))))L),1*U(1*C1(C1(C1(C1(U)))),A)><L,U(1*U,A,1*U)><L,U(1*U,A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dShow2_sdyEs $dShow_sdyEt $dShow1_sdyEu]
        let {
          sat_sdyEy [Occ=Once] :: [b_adwHw] -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdyEu] \u [] GHC.Show.showList $dShow1_sdyEu; } in
        let {
          sat_sdyEx [Occ=Once] :: GHC.Types.Int -> b_adwHw -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdyEu] \u [] GHC.Show.showsPrec $dShow1_sdyEu; } in
        let {
          sat_sdyEw [Occ=Once] :: [a_adwHv] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyEt] \u [] GHC.Show.showList $dShow_sdyEt; } in
        let {
          sat_sdyEv [Occ=Once] :: GHC.Types.Int -> a_adwHv -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyEt] \u [] GHC.Show.showsPrec $dShow_sdyEt;
        } in 
          Data.Functor.Classes.liftShowsPrec2
              $dShow2_sdyEs sat_sdyEv sat_sdyEw sat_sdyEx sat_sdyEy;

Data.Functor.Classes.$wreadsData [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Prim.Int# -> GHC.Base.String -> [(a, GHC.Base.String)]
[GblId, Arity=3, Str=<L,C(C1(U))><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyEz ww_sdyEA w1_sdyEB]
        let {
          go_sdyEC [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_sdy11, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sdyEz go_sdyEC] \r [ds_sdyED]
                  case ds_sdyED of {
                    [] -> [] [];
                    : y_sdyEF [Occ=Once!] ys_sdyEG [Occ=Once] ->
                        case y_sdyEF of {
                          (,) kw_sdyEI [Occ=Once] s_sdyEJ [Occ=Once] ->
                              let {
                                sat_sdyEL [Occ=Once, Dmd=<L,1*U>] :: [(a_sdy11, GHC.Base.String)]
                                [LclId] =
                                    [go_sdyEC ys_sdyEG] \s [] go_sdyEC ys_sdyEG;
                              } in 
                                case w_sdyEz kw_sdyEI s_sdyEJ of sat_sdyEK {
                                  __DEFAULT -> GHC.Base.++ sat_sdyEK sat_sdyEL;
                                };
                        };
                  }; } in
        let {
          sat_sdyEQ [Occ=Once] :: Text.ParserCombinators.ReadP.ReadS a_sdy11
          [LclId] =
              [go_sdyEC] \r [r_sdyEO]
                  case
                      Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_sdyEO
                  of
                  sat_sdyEP
                  { __DEFAULT -> go_sdyEC sat_sdyEP;
                  };
        } in 
          case ># [ww_sdyEA 10#] of sat_sdyEM {
            __DEFAULT ->
                case tagToEnum# [sat_sdyEM] of sat_sdyEN {
                  __DEFAULT -> GHC.Read.readParen sat_sdyEN sat_sdyEQ w1_sdyEB;
                };
          };

Data.Functor.Classes.readsData [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyER w1_sdyES w2_sdyET]
        case w1_sdyES of {
          GHC.Types.I# ww1_sdyEV [Occ=Once] ->
              Data.Functor.Classes.$wreadsData w_sdyER ww1_sdyEV w2_sdyET;
        };

Data.Functor.Classes.readData2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

Data.Functor.Classes.readData1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [reader_sdyEW eta_sdyEX eta1_sdyEY]
        let {
          lvl3_sdyEZ [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_adwHc
          [LclId] =
              [reader_sdyEW] \u []
                  reader_sdyEW Data.Functor.Classes.readData2; } in
        let {
          sat_sdyF4 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwHc
          [LclId] =
              [lvl3_sdyEZ] \r [c_sdyF0]
                  case c_sdyF0 of {
                    GHC.Types.I# x_sdyF2 [Occ=Once] ->
                        case <=# [x_sdyF2 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
                          1# -> lvl3_sdyEZ;
                        };
                  };
        } in  GHC.Read.list3 sat_sdyF4 eta_sdyEX eta1_sdyEY;

Data.Functor.Classes.readData
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readData1 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.readsUnaryWith
  :: forall a t.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Base.String
     -> (a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [rp_sdyF5 name_sdyF6 cons_sdyF7 kw_sdyF8 s_sdyF9]
        case GHC.Base.eqString kw_sdyF8 name_sdyF6 of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdyFb [Occ=LoopBreaker]
                  :: [(a_adwH5, GHC.Base.String)] -> [(t_adwH6, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdyF7 go_sdyFb] \r [ds_sdyFc]
                        case ds_sdyFc of {
                          [] -> [] [];
                          : y_sdyFe [Occ=Once!] ys_sdyFf [Occ=Once] ->
                              case y_sdyFe of {
                                (,) x_sdyFh [Occ=Once] t1_sdyFi [Occ=Once] ->
                                    let {
                                      sat_sdyFl [Occ=Once] :: [(t_adwH6, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdyFb ys_sdyFf] \u [] go_sdyFb ys_sdyFf; } in
                                    let {
                                      sat_sdyFj [Occ=Once] :: t_adwH6
                                      [LclId] =
                                          [cons_sdyF7 x_sdyFh] \u [] cons_sdyF7 x_sdyFh; } in
                                    let {
                                      sat_sdyFk [Occ=Once] :: (t_adwH6, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdyFj t1_sdyFi];
                                    } in  : [sat_sdyFk sat_sdyFl];
                              };
                        };
              } in 
                case
                    rp_sdyF5 Data.Functor.Classes.$fRead1Const1 s_sdyF9
                of
                sat_sdyFm
                { __DEFAULT -> go_sdyFb sat_sdyFm;
                };
        };

Data.Functor.Classes.$wreadUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (t -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyFn w1_sdyFo w2_sdyFp w3_sdyFq w4_sdyFr]
        let {
          sat_sdyFB [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_sdy1t
          [LclId] =
              [w_sdyFn w2_sdyFp w3_sdyFq w4_sdyFr] \r [a1_sdyFt]
                  let {
                    sat_sdyFA [Occ=Once]
                      :: a_sdy1n -> Text.ParserCombinators.ReadP.P b_sdy1t
                    [LclId] =
                        [w2_sdyFp w4_sdyFr] \r [a2_sdyFy]
                            let {
                              sat_sdyFz [Occ=Once] :: t_sdy1o
                              [LclId] =
                                  [w2_sdyFp a2_sdyFy] \u [] w2_sdyFp a2_sdyFy;
                            } in  w4_sdyFr sat_sdyFz; } in
                  let {
                    sat_sdyFx [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec
                    [LclId] =
                        [w3_sdyFq] \u []
                            case w3_sdyFq of {
                              GHC.Types.I# x_sdyFv [Occ=Once] ->
                                  case +# [x_sdyFv 1#] of sat_sdyFw {
                                    __DEFAULT -> GHC.Types.I# [sat_sdyFw];
                                  };
                            };
                  } in  w_sdyFn sat_sdyFx sat_sdyFA; } in
        let {
          sat_sdyFs [Occ=Once] :: Text.Read.Lex.Lexeme
          [LclId] =
              CCCS Text.Read.Lex.Ident! [w1_sdyFo];
        } in  Text.Read.Lex.$wexpect sat_sdyFs sat_sdyFB;

Data.Functor.Classes.readUnaryWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (t -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_sdyFC w1_sdyFD w2_sdyFE w3_sdyFF w4_sdyFG]
        case
            Data.Functor.Classes.$wreadUnaryWith
                w_sdyFC w1_sdyFD w2_sdyFE w3_sdyFF w4_sdyFG
        of
        { Unit# ww1_sdyFI [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_sdyFI];
        };

Data.Functor.Classes.readUnaryWith
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.ReadPrec t
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readUnaryWith1
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead1Const5
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Const.Const a a1 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdyFJ eta_sdyFK eta1_sdyFL eta2_sdyFM eta3_sdyFN]
        let {
          sat_sdyFO [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwRr
          [LclId] =
              [$dRead_sdyFJ] \u [] GHC.Read.readPrec $dRead_sdyFJ;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec1
              sat_sdyFO eta2_sdyFM eta3_sdyFN;

Data.Functor.Classes.$w$cliftReadsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a a1)
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyFP w1_sdyFQ]
        let {
          sat_sdyFS [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Const.Const a_sdy1z a1_sdy1B)
          [LclId] =
              [w_sdyFP w1_sdyFQ] \u []
                  let {
                    sat_sdyFR [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1z
                    [LclId] =
                        [w_sdyFP] \u [] GHC.Read.readPrec w_sdyFP;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec1
                        sat_sdyFR
                        w1_sdyFQ
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyFS;

Data.Functor.Classes.$fRead1Const_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyFT w1_sdyFU w2_sdyFV w3_sdyFW]
        Data.Functor.Classes.$w$cliftReadsPrec1 w_sdyFT w3_sdyFW;

Data.Functor.Classes.$w$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Const.Const a a1]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [w_sdyFX]
        let {
          w1_sdyFY [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1G
          [LclId] =
              [w_sdyFX] \u [] GHC.Read.readPrec w_sdyFX; } in
        let {
          sat_sdyG1 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_sdy1G a1_sdy1I)
          [LclId] =
              [w1_sdyFY] \r [w2_sdyFZ w3_sdyG0]
                  Data.Functor.Classes.$w$cliftReadPrec1 w1_sdyFY w2_sdyFZ w3_sdyG0;
        } in  GHC.Read.list sat_sdyG1;

Data.Functor.Classes.$fRead1Const_$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Const.Const a a1]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdyG2 w1_sdyG3 w2_sdyG4]
        Data.Functor.Classes.$w$cliftReadListPrec w_sdyG2;

Data.Functor.Classes.$fRead1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     Data.Functor.Classes.Read1 (Data.Functor.Const.Const a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdyG5]
        let {
          lvl3_sdyG6 [Occ=OnceL]
            :: forall a1.
               Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Const.Const a_XdwZZ a1]
          [LclId] =
              [$dRead_sdyG5] \u []
                  Data.Functor.Classes.$w$cliftReadListPrec $dRead_sdyG5; } in
        let {
          sat_sdyGf [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Const.Const a_XdwZZ a]
          [LclId] =
              [lvl3_sdyG6] \r [w_sdyGd w1_sdyGe] lvl3_sdyG6; } in
        let {
          sat_sdyGc [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Const.Const a_XdwZZ a)
          [LclId] =
              [$dRead_sdyG5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1Const5
                      $dRead_sdyG5 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyGb [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Const.Const a_XdwZZ a]
          [LclId] =
              [$dRead_sdyG5] \u []
                  Data.Functor.Classes.$fRead1Const_$cliftReadList $dRead_sdyG5; } in
        let {
          sat_sdyGa [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Const.Const a_XdwZZ a)
          [LclId] =
              [$dRead_sdyG5] \r [w_sdyG7 w1_sdyG8 w2_sdyG9]
                  Data.Functor.Classes.$w$cliftReadsPrec1 $dRead_sdyG5 w2_sdyG9;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdyGa
                                        sat_sdyGb
                                        sat_sdyGc
                                        sat_sdyGf];
Data.Functor.Classes.$fRead1Const_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Const.Const a a1]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdyGg]
        let {
          sat_sdyGh [Occ=Once]
            :: Data.Functor.Classes.Read1 (Data.Functor.Const.Const a_Xdx00)
          [LclId] =
              [$dRead_sdyGg] \u []
                  Data.Functor.Classes.$fRead1Const $dRead_sdyGg;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdyGh;

Data.Functor.Classes.$fRead1Either7
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Either.Either a a1 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdyGi eta_sdyGj eta1_sdyGk eta2_sdyGl eta3_sdyGm]
        let {
          sat_sdyGn [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwSV
          [LclId] =
              [$dRead_sdyGi] \u [] GHC.Read.readPrec $dRead_sdyGi;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec3
              sat_sdyGn eta_sdyGj eta2_sdyGl eta3_sdyGm;

Data.Functor.Classes.$w$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a a1)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyGo w1_sdyGp w2_sdyGq]
        let {
          sat_sdyGt [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_sdy1O a1_sdy1Q)
          [LclId] =
              [w_sdyGo w1_sdyGp w2_sdyGq] \u []
                  let {
                    sat_sdyGs [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a1_sdy1Q
                    [LclId] =
                        [w1_sdyGp] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdyGp eta_B1; } in
                  let {
                    sat_sdyGr [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1O
                    [LclId] =
                        [w_sdyGo] \u [] GHC.Read.readPrec w_sdyGo;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec3
                        sat_sdyGr
                        sat_sdyGs
                        w2_sdyGq
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyGt;

Data.Functor.Classes.$fRead1Either_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyGu w1_sdyGv w2_sdyGw w3_sdyGx]
        Data.Functor.Classes.$w$cliftReadsPrec2 w_sdyGu w1_sdyGv w3_sdyGx;

Data.Functor.Classes.$w$cliftReadListPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a a1]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [w_sdyGy w1_sdyGz]
        let {
          w2_sdyGA [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1V
          [LclId] =
              [w_sdyGy] \u [] GHC.Read.readPrec w_sdyGy; } in
        let {
          sat_sdyGD [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_sdy1V a1_sdy1X)
          [LclId] =
              [w1_sdyGz w2_sdyGA] \r [w3_sdyGB w4_sdyGC]
                  Data.Functor.Classes.$w$cliftReadPrec3
                      w2_sdyGA w1_sdyGz w3_sdyGB w4_sdyGC;
        } in  GHC.Read.list sat_sdyGD;

Data.Functor.Classes.$fRead1Either_$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a a1]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdyGE w1_sdyGF w2_sdyGG]
        Data.Functor.Classes.$w$cliftReadListPrec1 w_sdyGE w1_sdyGF;

Data.Functor.Classes.$fRead1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     Data.Functor.Classes.Read1 (Data.Either.Either a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdyGH]
        let {
          sat_sdyGQ [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Either.Either a_XdwYA a]
          [LclId] =
              [$dRead_sdyGH] \r [w_sdyGO w1_sdyGP]
                  Data.Functor.Classes.$w$cliftReadListPrec1
                      $dRead_sdyGH w_sdyGO; } in
        let {
          sat_sdyGN [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Either.Either a_XdwYA a)
          [LclId] =
              [$dRead_sdyGH] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1Either7
                      $dRead_sdyGH eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyGM [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Either.Either a_XdwYA a]
          [LclId] =
              [$dRead_sdyGH] \u []
                  Data.Functor.Classes.$fRead1Either_$cliftReadList
                      $dRead_sdyGH; } in
        let {
          sat_sdyGL [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Either.Either a_XdwYA a)
          [LclId] =
              [$dRead_sdyGH] \r [w_sdyGI w1_sdyGJ w2_sdyGK]
                  Data.Functor.Classes.$w$cliftReadsPrec2
                      $dRead_sdyGH w_sdyGI w2_sdyGK;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdyGL
                                        sat_sdyGM
                                        sat_sdyGN
                                        sat_sdyGQ];
Data.Functor.Classes.$fRead1Either_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a a1]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdyGR]
        let {
          sat_sdyGS [Occ=Once]
            :: Data.Functor.Classes.Read1 (Data.Either.Either a_XdwYC)
          [LclId] =
              [$dRead_sdyGR] \u []
                  Data.Functor.Classes.$fRead1Either $dRead_sdyGR;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdyGS;

Data.Functor.Classes.$fRead1Identity4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity"#;

Data.Functor.Classes.$fRead1Identity3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Identity4;

Data.Functor.Classes.$fRead1Identity2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Identity3];

Data.Functor.Classes.$w$cliftReadPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyGT w1_sdyGU w2_sdyGV]
        let {
          sat_sdyH7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_sdy23)
          [LclId] =
              [w_sdyGT] \r [c_sdyGW eta_sdyGX]
                  case c_sdyGW of {
                    GHC.Types.I# x_sdyGZ [Occ=Once] ->
                        case <=# [x_sdyGZ 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdyH4 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_X81et
                                [LclId] =
                                    [w_sdyGT eta_sdyGX] \r [a1_sdyH1]
                                        let {
                                          sat_sdyH3 [Occ=Once]
                                            :: a_sdy23 -> Text.ParserCombinators.ReadP.P b1_X81et
                                          [LclId] =
                                              [eta_sdyGX] \r [a2_sdyH2] eta_sdyGX a2_sdyH2;
                                        } in  w_sdyGT Data.Functor.Classes.$fRead1Const1 sat_sdyH3;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Identity2 sat_sdyH4
                                of
                                { Unit# ww1_sdyH6 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sdyH6];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdyH7 w1_sdyGU w2_sdyGV;

Data.Functor.Classes.$fRead1Identity1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyH8 w1_sdyH9 w2_sdyHa w3_sdyHb]
        Data.Functor.Classes.$w$cliftReadPrec w_sdyH8 w2_sdyHa w3_sdyHb;

Data.Functor.Classes.$w$cliftReadsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId, Arity=2, Str=<L,1*C1(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyHc w1_sdyHd]
        let {
          sat_sdyHt [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Identity.Identity a_sdy2a)
          [LclId] =
              [w_sdyHc w1_sdyHd] \u []
                  let {
                    lvl3_sdyHe [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS a_sdy2a
                    [LclId] =
                        [w_sdyHc] \u [] w_sdyHc Data.Functor.Classes.$fRead1Const1; } in
                  let {
                    sat_sdyHs [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sdy2a)
                    [LclId] =
                        [lvl3_sdyHe] \r [c_sdyHf eta_sdyHg]
                            case c_sdyHf of {
                              GHC.Types.I# x_sdyHi [Occ=Once] ->
                                  case <=# [x_sdyHi 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdyHp [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_X81et
                                          [LclId] =
                                              [lvl3_sdyHe eta_sdyHg] \r [a1_sdyHk]
                                                  let {
                                                    sat_sdyHm [Occ=Once]
                                                      :: a_sdy2a
                                                         -> Text.ParserCombinators.ReadP.P b_X81et
                                                    [LclId] =
                                                        [eta_sdyHg] \r [a2_sdyHl]
                                                            eta_sdyHg a2_sdyHl;
                                                  } in 
                                                    case
                                                        Text.ParserCombinators.ReadP.$wreadS_to_P
                                                            lvl3_sdyHe sat_sdyHm
                                                    of
                                                    { Unit# ww1_sdyHo [Occ=Once] ->
                                                          Text.ParserCombinators.ReadP.Look [ww1_sdyHo];
                                                    };
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Identity2 sat_sdyHp
                                          of
                                          { Unit# ww1_sdyHr [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdyHr];
                                          };
                                  };
                            };
                  } in 
                    GHC.Read.list3
                        sat_sdyHs
                        w1_sdyHd
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyHt;

Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,A><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyHu w1_sdyHv w2_sdyHw]
        Data.Functor.Classes.$w$cliftReadsPrec3 w_sdyHu w2_sdyHw;

Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Identity.Identity a]
[GblId, Arity=2, Str=<L,C(C1(U))><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdyHx rl_sdyHy]
        let {
          sat_sdyHB [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_adx2c)
          [LclId] =
              [rp_sdyHx] \r [w_sdyHz w1_sdyHA]
                  Data.Functor.Classes.$w$cliftReadPrec rp_sdyHx w_sdyHz w1_sdyHA;
        } in  GHC.Read.list sat_sdyHB;

Data.Functor.Classes.$w$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Identity.Identity a]
[GblId, Arity=1, Str=<L,C(C(U))>, Unf=OtherCon []] =
    [] \r [w_sdyHC]
        let {
          sat_sdyHH [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_sdy2f]
          [LclId] =
              [w_sdyHC] \u []
                  let {
                    w1_sdyHD [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.Prec
                         -> forall b.
                            (a_sdy2f -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [w_sdyHC] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdyHC eta_B1; } in
                  let {
                    sat_sdyHG [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sdy2f)
                    [LclId] =
                        [w1_sdyHD] \r [w2_sdyHE w3_sdyHF]
                            Data.Functor.Classes.$w$cliftReadPrec w1_sdyHD w2_sdyHE w3_sdyHF;
                  } in 
                    GHC.Read.list
                        sat_sdyHG
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyHH;

Data.Functor.Classes.$fRead1Identity_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Identity.Identity a]
[GblId, Arity=2, Str=<L,C(C(U))><L,A>, Unf=OtherCon []] =
    [] \r [w_sdyHI w1_sdyHJ]
        Data.Functor.Classes.$w$cliftReadList w_sdyHI;

Data.Functor.Classes.$fRead1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Identity_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Identity1
                                                 Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec];

Data.Functor.Classes.$fRead1Maybe7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Nothing"#;

Data.Functor.Classes.$fRead1Maybe6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Maybe7;

Data.Functor.Classes.$fRead1Maybe_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Maybe6];

Data.Functor.Classes.$fRead1Maybe5
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [eta_sdyHK eta1_sdyHL]
        let {
          sat_sdyHN [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_i815E
          [LclId] =
              [eta1_sdyHL] \r [x_sdyHM] eta1_sdyHL GHC.Base.Nothing;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Functor.Classes.$fRead1Maybe_lexeme sat_sdyHN
          of
          { Unit# ww1_sdyHP [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sdyHP];
          };

Data.Functor.Classes.$fRead1Maybe4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Just"#;

Data.Functor.Classes.$fRead1Maybe3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Maybe4;

Data.Functor.Classes.$fRead1Maybe2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Maybe3];

Data.Functor.Classes.$w$cliftReadPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyHQ w1_sdyHR w2_sdyHS]
        let {
          sat_sdyI7 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sdy2n
          [LclId] =
              [w_sdyHQ w1_sdyHR w2_sdyHS] \u []
                  let {
                    sat_sdyI6 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.Maybe a_sdy2j)
                    [LclId] =
                        [w_sdyHQ] \r [c_sdyHU eta_sdyHV]
                            case c_sdyHU of {
                              GHC.Types.I# x_sdyHX [Occ=Once] ->
                                  case <=# [x_sdyHX 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdyI3 [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_X81c7
                                          [LclId] =
                                              [w_sdyHQ eta_sdyHV] \r [a1_sdyHZ]
                                                  let {
                                                    sat_sdyI2 [Occ=Once]
                                                      :: a_sdy2j
                                                         -> Text.ParserCombinators.ReadP.P b1_X81c7
                                                    [LclId] =
                                                        [eta_sdyHV] \r [a2_sdyI0]
                                                            let {
                                                              sat_sdyI1 [Occ=Once]
                                                                :: GHC.Base.Maybe a_sdy2j
                                                              [LclId] =
                                                                  CCCS GHC.Base.Just! [a2_sdyI0];
                                                            } in  eta_sdyHV sat_sdyI1;
                                                  } in 
                                                    w_sdyHQ
                                                        Data.Functor.Classes.$fRead1Const1
                                                        sat_sdyI2;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Maybe2 sat_sdyI3
                                          of
                                          { Unit# ww1_sdyI5 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdyI5];
                                          };
                                  };
                            };
                  } in  GHC.Read.list3 sat_sdyI6 w1_sdyHR w2_sdyHS;
        } in 
          case
              GHC.Read.list3 Data.Functor.Classes.$fRead1Maybe5 w1_sdyHR w2_sdyHS
          of
          sat_sdyHT
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_sdyHT sat_sdyI7;
          };

Data.Functor.Classes.$fRead1Maybe1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyI8 w1_sdyI9 w2_sdyIa w3_sdyIb]
        Data.Functor.Classes.$w$cliftReadPrec4 w_sdyI8 w2_sdyIa w3_sdyIb;

Data.Functor.Classes.$w$cliftReadsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.Maybe a)
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyIc w1_sdyId]
        let {
          sat_sdyIf [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (GHC.Base.Maybe a_sdy2q)
          [LclId] =
              [w_sdyIc w1_sdyId] \u []
                  let {
                    sat_sdyIe [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy2q
                    [LclId] =
                        [w_sdyIc] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdyIc eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec4
                        sat_sdyIe
                        w1_sdyId
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyIf;

Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.Maybe a)
[GblId, Arity=3, Str=<L,C(C(U))><L,A><L,U>, Unf=OtherCon []] =
    [] \r [w_sdyIg w1_sdyIh w2_sdyIi]
        Data.Functor.Classes.$w$cliftReadsPrec4 w_sdyIg w2_sdyIi;

Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [GHC.Base.Maybe a]
[GblId, Arity=2, Str=<L,C(C1(U))><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdyIj rl_sdyIk]
        let {
          sat_sdyIn [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (GHC.Base.Maybe a_adx4t)
          [LclId] =
              [rp_sdyIj] \r [w_sdyIl w1_sdyIm]
                  Data.Functor.Classes.$w$cliftReadPrec4 rp_sdyIj w_sdyIl w1_sdyIm;
        } in  GHC.Read.list sat_sdyIn;

Data.Functor.Classes.$w$cliftReadList1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.Maybe a]
[GblId, Arity=1, Str=<L,C(C(U))>, Unf=OtherCon []] =
    [] \r [w_sdyIo]
        let {
          sat_sdyIt [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [GHC.Base.Maybe a_sdy2v]
          [LclId] =
              [w_sdyIo] \u []
                  let {
                    w1_sdyIp [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.Prec
                         -> forall b.
                            (a_sdy2v -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [w_sdyIo] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdyIo eta_B1; } in
                  let {
                    sat_sdyIs [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.Maybe a_sdy2v)
                    [LclId] =
                        [w1_sdyIp] \r [w2_sdyIq w3_sdyIr]
                            Data.Functor.Classes.$w$cliftReadPrec4 w1_sdyIp w2_sdyIq w3_sdyIr;
                  } in 
                    GHC.Read.list
                        sat_sdyIs
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdyIt;

Data.Functor.Classes.$fRead1Maybe_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.Maybe a]
[GblId, Arity=2, Str=<L,C(C(U))><L,A>, Unf=OtherCon []] =
    [] \r [w_sdyIu w1_sdyIv]
        Data.Functor.Classes.$w$cliftReadList1 w_sdyIu;

Data.Functor.Classes.$fRead1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Maybe_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Maybe1
                                                 Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec];

Data.Functor.Classes.readsBinaryWith
  :: forall a b t.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Base.String
     -> (a -> b -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><S,1*U><L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [rp1_sdyIw rp2_sdyIx name_sdyIy cons_sdyIz kw_sdyIA s_sdyIB]
        case GHC.Base.eqString kw_sdyIA name_sdyIy of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdyID [Occ=LoopBreaker]
                  :: [(a_adwGC, GHC.Base.String)] -> [(t_adwGE, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [rp2_sdyIx cons_sdyIz go_sdyID] \r [ds_sdyIE]
                        case ds_sdyIE of {
                          [] -> [] [];
                          : y_sdyIG [Occ=Once!] ys_sdyIH [Occ=Once] ->
                              case y_sdyIG of {
                                (,) x_sdyIJ [Occ=OnceL] t1_sdyIK [Occ=Once] ->
                                    let {
                                      z_sdyIL [Occ=OnceL] :: [(t_adwGE, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdyID ys_sdyIH] \u [] go_sdyID ys_sdyIH; } in
                                    let {
                                      go1_sdyIM [Occ=LoopBreaker]
                                        :: [(b_adwGD, GHC.Base.String)]
                                           -> [(t_adwGE, GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [cons_sdyIz
                                                    x_sdyIJ
                                                    z_sdyIL
                                                    go1_sdyIM] \r [ds1_sdyIN]
                                              case ds1_sdyIN of {
                                                [] -> z_sdyIL;
                                                : y1_sdyIP [Occ=Once!] ys1_sdyIQ [Occ=Once] ->
                                                    case y1_sdyIP of {
                                                      (,) y2_sdyIS [Occ=Once] u_sdyIT [Occ=Once] ->
                                                          let {
                                                            sat_sdyIW [Occ=Once]
                                                              :: [(t_adwGE, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdyIM ys1_sdyIQ] \u []
                                                                    go1_sdyIM ys1_sdyIQ; } in
                                                          let {
                                                            sat_sdyIU [Occ=Once] :: t_adwGE
                                                            [LclId] =
                                                                [cons_sdyIz x_sdyIJ y2_sdyIS] \u []
                                                                    cons_sdyIz
                                                                        x_sdyIJ y2_sdyIS; } in
                                                          let {
                                                            sat_sdyIV [Occ=Once]
                                                              :: (t_adwGE, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sdyIU u_sdyIT];
                                                          } in  : [sat_sdyIV sat_sdyIW];
                                                    };
                                              };
                                    } in 
                                      case
                                          rp2_sdyIx Data.Functor.Classes.$fRead1Const1 t1_sdyIK
                                      of
                                      sat_sdyIX
                                      { __DEFAULT -> go1_sdyIM sat_sdyIX;
                                      };
                              };
                        };
              } in 
                case
                    rp1_sdyIw Data.Functor.Classes.$fRead1Const1 s_sdyIB
                of
                sat_sdyIY
                { __DEFAULT -> go_sdyID sat_sdyIY;
                };
        };

Data.Functor.Classes.$wreadBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (t -> Text.ParserCombinators.ReadP.P b1)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b1 #)
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_sdyIZ w1_sdyJ0 w2_sdyJ1 w3_sdyJ2 w4_sdyJ3 w5_sdyJ4]
        let {
          sat_sdyJg [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b1_sdy2S
          [LclId] =
              [w_sdyIZ w1_sdyJ0 w3_sdyJ2 w4_sdyJ3 w5_sdyJ4] \r [a1_sdyJ6]
                  let {
                    lvl3_sdyJ7 :: Text.ParserCombinators.ReadPrec.Prec
                    [LclId] =
                        [w4_sdyJ3] \u []
                            case w4_sdyJ3 of {
                              GHC.Types.I# x_sdyJ9 [Occ=Once] ->
                                  case +# [x_sdyJ9 1#] of sat_sdyJa {
                                    __DEFAULT -> GHC.Types.I# [sat_sdyJa];
                                  };
                            }; } in
                  let {
                    sat_sdyJf [Occ=Once]
                      :: a_sdy2K -> Text.ParserCombinators.ReadP.P b1_sdy2S
                    [LclId] =
                        [w1_sdyJ0 w3_sdyJ2 w5_sdyJ4 lvl3_sdyJ7] \r [a2_sdyJb]
                            let {
                              sat_sdyJe [Occ=Once]
                                :: b_sdy2L -> Text.ParserCombinators.ReadP.P b1_sdy2S
                              [LclId] =
                                  [w3_sdyJ2 w5_sdyJ4 a2_sdyJb] \r [a3_sdyJc]
                                      let {
                                        sat_sdyJd [Occ=Once] :: t_sdy2M
                                        [LclId] =
                                            [w3_sdyJ2 a2_sdyJb a3_sdyJc] \u []
                                                w3_sdyJ2 a2_sdyJb a3_sdyJc;
                                      } in  w5_sdyJ4 sat_sdyJd;
                            } in  w1_sdyJ0 lvl3_sdyJ7 sat_sdyJe;
                  } in  w_sdyIZ lvl3_sdyJ7 sat_sdyJf; } in
        let {
          sat_sdyJ5 [Occ=Once] :: Text.Read.Lex.Lexeme
          [LclId] =
              CCCS Text.Read.Lex.Ident! [w2_sdyJ1];
        } in  Text.Read.Lex.$wexpect sat_sdyJ5 sat_sdyJg;

Data.Functor.Classes.readBinaryWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (t -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_sdyJh w1_sdyJi w2_sdyJj w3_sdyJk w4_sdyJl w5_sdyJm]
        case
            Data.Functor.Classes.$wreadBinaryWith
                w_sdyJh w1_sdyJi w2_sdyJj w3_sdyJk w4_sdyJl w5_sdyJm
        of
        { Unit# ww1_sdyJo [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_sdyJo];
        };

Data.Functor.Classes.readBinaryWith
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.ReadPrec t
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readBinaryWith1
            eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$wshowsUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> GHC.Base.String -> GHC.Prim.Int# -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyJp w1_sdyJq ww_sdyJr w2_sdyJs]
        let {
          g_sdyJt [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyJp w2_sdyJs] \u []
                  w_sdyJp Data.Functor.Classes.$fRead1Const1 w2_sdyJs;
        } in 
          case ># [ww_sdyJr 10#] of {
            __DEFAULT ->
                let {
                  sat_sdyJy [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdyJq g_sdyJt] \r [x_sdyJv]
                          let {
                            sat_sdyJw [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdyJt x_sdyJv] \u [] g_sdyJt x_sdyJv; } in
                          let {
                            sat_sdyJx [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyJw];
                          } in  GHC.Base.++ w1_sdyJq sat_sdyJx;
                } in  sat_sdyJy;
            1# ->
                let {
                  sat_sdyJE [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdyJq g_sdyJt] \r [x_sdyJz]
                          let {
                            sat_sdyJD [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w1_sdyJq g_sdyJt x_sdyJz] \u []
                                    let {
                                      sat_sdyJB [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdyJt x_sdyJz] \u []
                                              let {
                                                sat_sdyJA [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdyJz];
                                              } in  g_sdyJt sat_sdyJA; } in
                                    let {
                                      sat_sdyJC [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyJB];
                                    } in  GHC.Base.++ w1_sdyJq sat_sdyJC;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdyJD];
                } in  sat_sdyJE;
          };

Data.Functor.Classes.showsUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyJF w1_sdyJG w2_sdyJH w3_sdyJI]
        case w2_sdyJH of {
          GHC.Types.I# ww1_sdyJK [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  w_sdyJF w1_sdyJG ww1_sdyJK w3_sdyJI;
        };

Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Const.Const a b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(C(U)))><L,A><L,A><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdyJL ds_sdyJM ds1_sdyJN ds2_sdyJO d_sdyJP ds3_sdyJQ]
        case d_sdyJP of {
          GHC.Types.I# ww1_sdyJS [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  sp_sdyJL Data.Functor.Classes.$fRead1Const3 ww1_sdyJS ds3_sdyJQ;
        };

Data.Functor.Classes.$fShow2Const_$cliftShowList2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [Data.Functor.Const.Const a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,C(C1(C(U)))><L,A><L,A><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp1_sdyJT
           sl1_sdyJU
           sp2_sdyJV
           sl2_sdyJW
           eta_sdyJX
           eta1_sdyJY]
        let {
          sat_sdyK0 [Occ=Once]
            :: Data.Functor.Const.Const a_adwPE b_adwPF -> GHC.Show.ShowS
          [LclId] =
              [sp1_sdyJT] \r [ds_sdyJZ]
                  Data.Functor.Classes.$wshowsUnaryWith
                      sp1_sdyJT Data.Functor.Classes.$fRead1Const3 0# ds_sdyJZ;
        } in  GHC.Show.showList__ sat_sdyK0 eta_sdyJX eta1_sdyJY;

Data.Functor.Classes.$fShow2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2Const_$cliftShowList2];

Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Const.Const a a1
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,A><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdyK1 eta_sdyK2 eta1_sdyK3 eta2_sdyK4 eta3_sdyK5]
        case eta2_sdyK4 of {
          GHC.Types.I# ww1_sdyK7 [Occ=Once] ->
              let {
                sat_sdyK8 [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_adwP4 -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sdyK1] \s [] GHC.Show.showsPrec $dShow_sdyK1;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sdyK8 Data.Functor.Classes.$fRead1Const3 ww1_sdyK7 eta3_sdyK5;
        };

Data.Functor.Classes.$fShow1Const_$cliftShowList
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> [Data.Functor.Const.Const a a1]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,A><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdyK9 sp_sdyKa sl_sdyKb eta_sdyKc eta1_sdyKd]
        let {
          lvl3_sdyKe [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_adwP4 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyK9] \u [] GHC.Show.showsPrec $dShow_sdyK9; } in
        let {
          sat_sdyKg [Occ=Once]
            :: Data.Functor.Const.Const a_adwP4 a1_adwPn -> GHC.Show.ShowS
          [LclId] =
              [lvl3_sdyKe] \r [eta2_sdyKf]
                  Data.Functor.Classes.$wshowsUnaryWith
                      lvl3_sdyKe Data.Functor.Classes.$fRead1Const3 0# eta2_sdyKf;
        } in  GHC.Show.showList__ sat_sdyKg eta_sdyKc eta1_sdyKd;

Data.Functor.Classes.$fShow1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Classes.Show1 (Data.Functor.Const.Const a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdyKh]
        let {
          sat_sdyKj [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Const.Const a_adwP4 a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyKh] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Const_$cliftShowList
                      $dShow_sdyKh eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdyKi [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Const.Const a_adwP4 a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyKh] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
                      $dShow_sdyKh eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdyKi sat_sdyKj];

Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Either.Either a b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [sp1_sdyKk ds_sdyKl ds1_sdyKm ds2_sdyKn d_sdyKo ds3_sdyKp]
        case ds3_sdyKp of {
          Data.Either.Left x_sdyKr [Occ=Once] ->
              case d_sdyKo of {
                GHC.Types.I# ww1_sdyKt [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        sp1_sdyKk Data.Functor.Classes.$fRead1Either5 ww1_sdyKt x_sdyKr;
              };
          Data.Either.Right x_sdyKu [Occ=Once] ->
              case d_sdyKo of {
                GHC.Types.I# ww1_sdyKw [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        ds1_sdyKm Data.Functor.Classes.$fRead1Either2 ww1_sdyKw x_sdyKu;
              };
        };

Data.Functor.Classes.$w$cliftShowList4 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> [Data.Either.Either a b]
     -> GHC.Base.String
     -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyKx w1_sdyKy w2_sdyKz w3_sdyKA]
        let {
          sat_sdyKF [Occ=Once]
            :: Data.Either.Either a_sdy38 b_sdy39 -> GHC.Show.ShowS
          [LclId] =
              [w_sdyKx w1_sdyKy] \r [ds_sdyKB]
                  case ds_sdyKB of {
                    Data.Either.Left x_sdyKD [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w_sdyKx Data.Functor.Classes.$fRead1Either5 0# x_sdyKD;
                    Data.Either.Right x_sdyKE [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w1_sdyKy Data.Functor.Classes.$fRead1Either2 0# x_sdyKE;
                  };
        } in  GHC.Show.showList__ sat_sdyKF w2_sdyKz w3_sdyKA;

Data.Functor.Classes.$fShow2Either_$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [Data.Either.Either a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,C(C1(C(U)))><L,A><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyKG w1_sdyKH w2_sdyKI w3_sdyKJ w4_sdyKK w5_sdyKL]
        Data.Functor.Classes.$w$cliftShowList4
            w_sdyKG w2_sdyKI w4_sdyKK w5_sdyKL;

Data.Functor.Classes.$fShow2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 Data.Either.Either
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2Either_$cliftShowList2];

Data.Functor.Classes.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> GHC.Prim.Int# -> Data.Either.Either a a1 -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdyKM w1_sdyKN ww_sdyKO w2_sdyKP]
        case w2_sdyKP of {
          Data.Either.Left x_sdyKR [Occ=Once] ->
              let {
                sat_sdyKS [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_sdy3h -> GHC.Show.ShowS
                [LclId] =
                    [w_sdyKM] \s [] GHC.Show.showsPrec w_sdyKM;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sdyKS Data.Functor.Classes.$fRead1Either5 ww_sdyKO x_sdyKR;
          Data.Either.Right x_sdyKT [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  w1_sdyKN Data.Functor.Classes.$fRead1Either2 ww_sdyKO x_sdyKT;
        };

Data.Functor.Classes.$fShow1Either_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Either.Either a a1
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdyKU w1_sdyKV w2_sdyKW w3_sdyKX w4_sdyKY]
        case w3_sdyKX of {
          GHC.Types.I# ww1_sdyL0 [Occ=Once] ->
              Data.Functor.Classes.$w$cliftShowsPrec
                  w_sdyKU w1_sdyKV ww1_sdyL0 w4_sdyKY;
        };

Data.Functor.Classes.$w$cliftShowList1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> [Data.Either.Either a a1] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyL1 w1_sdyL2 w2_sdyL3 w3_sdyL4]
        let {
          lvl3_sdyL5 [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_sdy3t -> GHC.Show.ShowS
          [LclId] =
              [w_sdyL1] \u [] GHC.Show.showsPrec w_sdyL1; } in
        let {
          sat_sdyLa [Occ=Once]
            :: Data.Either.Either a_sdy3t a1_sdy3v -> GHC.Show.ShowS
          [LclId] =
              [w1_sdyL2 lvl3_sdyL5] \r [eta_sdyL6]
                  case eta_sdyL6 of {
                    Data.Either.Left x_sdyL8 [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            lvl3_sdyL5 Data.Functor.Classes.$fRead1Either5 0# x_sdyL8;
                    Data.Either.Right x_sdyL9 [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w1_sdyL2 Data.Functor.Classes.$fRead1Either2 0# x_sdyL9;
                  };
        } in  GHC.Show.showList__ sat_sdyLa w2_sdyL3 w3_sdyL4;

Data.Functor.Classes.$fShow1Either_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> [Data.Either.Either a a1]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyLb w1_sdyLc w2_sdyLd w3_sdyLe w4_sdyLf]
        Data.Functor.Classes.$w$cliftShowList1
            w_sdyLb w1_sdyLc w3_sdyLe w4_sdyLf;

Data.Functor.Classes.$fShow1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Classes.Show1 (Data.Either.Either a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdyLg]
        let {
          sat_sdyLm [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Either.Either a_adwPN a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyLg] \r [w_sdyLi w1_sdyLj w2_sdyLk w3_sdyLl]
                  Data.Functor.Classes.$w$cliftShowList1
                      $dShow_sdyLg w_sdyLi w2_sdyLk w3_sdyLl; } in
        let {
          sat_sdyLh [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Either.Either a_adwPN a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdyLg] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Either_$cliftShowsPrec
                      $dShow_sdyLg eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdyLh sat_sdyLm];

Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Identity.Identity a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdyLn ds_sdyLo d_sdyLp ds1_sdyLq]
        case d_sdyLp of {
          GHC.Types.I# ww1_sdyLs [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  sp_sdyLn Data.Functor.Classes.$fRead1Identity3 ww1_sdyLs ds1_sdyLq;
        };

Data.Functor.Classes.$fShow1Identity_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Identity.Identity a]
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdyLt sl_sdyLu eta_sdyLv eta1_sdyLw]
        let {
          sat_sdyLy [Occ=Once]
            :: Data.Functor.Identity.Identity a_adwZV -> GHC.Show.ShowS
          [LclId] =
              [sp_sdyLt] \r [ds_sdyLx]
                  Data.Functor.Classes.$wshowsUnaryWith
                      sp_sdyLt Data.Functor.Classes.$fRead1Identity3 0# ds_sdyLx;
        } in  GHC.Show.showList__ sat_sdyLy eta_sdyLv eta1_sdyLw;

Data.Functor.Classes.$fShow1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Identity_$cliftShowList];

Data.Functor.Classes.$fShow1Maybe1
  :: [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Base.++ Data.Functor.Classes.$fRead1Maybe6 eta_B1;

Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> GHC.Base.Maybe a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdyLz ds1_sdyLA ds2_sdyLB ds3_sdyLC]
        case ds3_sdyLC of {
          GHC.Base.Nothing -> Data.Functor.Classes.$fShow1Maybe1;
          GHC.Base.Just x_sdyLE [Occ=Once] ->
              case ds2_sdyLB of {
                GHC.Types.I# ww1_sdyLG [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        ds_sdyLz Data.Functor.Classes.$fRead1Maybe3 ww1_sdyLG x_sdyLE;
              };
        };

Data.Functor.Classes.$w$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> [GHC.Base.Maybe a] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=3,
 Str=<L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyLH w1_sdyLI w2_sdyLJ]
        let {
          sat_sdyLN [Occ=Once] :: GHC.Base.Maybe a_sdy3B -> GHC.Show.ShowS
          [LclId] =
              [w_sdyLH] \r [ds_sdyLK]
                  case ds_sdyLK of {
                    GHC.Base.Nothing -> Data.Functor.Classes.$fShow1Maybe1;
                    GHC.Base.Just x_sdyLM [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w_sdyLH Data.Functor.Classes.$fRead1Maybe3 0# x_sdyLM;
                  };
        } in  GHC.Show.showList__ sat_sdyLN w1_sdyLI w2_sdyLJ;

Data.Functor.Classes.$fShow1Maybe_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [GHC.Base.Maybe a] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyLO w1_sdyLP w2_sdyLQ w3_sdyLR]
        Data.Functor.Classes.$w$cliftShowList2 w_sdyLO w2_sdyLQ w3_sdyLR;

Data.Functor.Classes.$fShow1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Maybe_$cliftShowList];

Data.Functor.Classes.$wshowsBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> GHC.Base.String
     -> GHC.Prim.Int#
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyLS w1_sdyLT w2_sdyLU ww_sdyLV w3_sdyLW w4_sdyLX]
        let {
          f_sdyLY [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyLS w3_sdyLW] \u []
                  w_sdyLS Data.Functor.Classes.$fRead1Const1 w3_sdyLW; } in
        let {
          g_sdyLZ [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdyLT w4_sdyLX] \u []
                  w1_sdyLT Data.Functor.Classes.$fRead1Const1 w4_sdyLX;
        } in 
          case ># [ww_sdyLV 10#] of {
            __DEFAULT ->
                let {
                  sat_sdyM6 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdyLU f_sdyLY g_sdyLZ] \r [x_sdyM1]
                          let {
                            sat_sdyM4 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sdyLY g_sdyLZ x_sdyM1] \u []
                                    let {
                                      sat_sdyM2 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdyLZ x_sdyM1] \u [] g_sdyLZ x_sdyM1; } in
                                    let {
                                      sat_sdyM3 [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyM2];
                                    } in  f_sdyLY sat_sdyM3; } in
                          let {
                            sat_sdyM5 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyM4];
                          } in  GHC.Base.++ w2_sdyLU sat_sdyM5;
                } in  sat_sdyM6;
            1# ->
                let {
                  sat_sdyMe [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdyLU f_sdyLY g_sdyLZ] \r [x_sdyM7]
                          let {
                            sat_sdyMd [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w2_sdyLU f_sdyLY g_sdyLZ x_sdyM7] \u []
                                    let {
                                      sat_sdyMb [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sdyLY g_sdyLZ x_sdyM7] \u []
                                              let {
                                                sat_sdyM9 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sdyLZ x_sdyM7] \u []
                                                        let {
                                                          sat_sdyM8 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdyM7];
                                                        } in  g_sdyLZ sat_sdyM8; } in
                                              let {
                                                sat_sdyMa [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [Data.Functor.Classes.showsUnaryWith1
                                                             sat_sdyM9];
                                              } in  f_sdyLY sat_sdyMa; } in
                                    let {
                                      sat_sdyMc [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyMb];
                                    } in  GHC.Base.++ w2_sdyLU sat_sdyMc;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdyMd];
                } in  sat_sdyMe;
          };

Data.Functor.Classes.showsBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> GHC.Base.String
     -> GHC.Types.Int
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><S(S),1*U(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyMf w1_sdyMg w2_sdyMh w3_sdyMi w4_sdyMj w5_sdyMk]
        case w3_sdyMi of {
          GHC.Types.I# ww1_sdyMm [Occ=Once] ->
              Data.Functor.Classes.$wshowsBinaryWith
                  w_sdyMf w1_sdyMg w2_sdyMh ww1_sdyMm w4_sdyMj w5_sdyMk;
        };

Data.Functor.Classes.readsUnary
  :: forall a t.
     GHC.Read.Read a =>
     GHC.Base.String
     -> (a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A,A)><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdyMn name_sdyMo cons_sdyMp kw_sdyMq s_sdyMr]
        case GHC.Base.eqString kw_sdyMq name_sdyMo of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdyMt [Occ=LoopBreaker]
                  :: [(a_adwFr, GHC.Base.String)] -> [(t_adwFs, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdyMp go_sdyMt] \r [ds_sdyMu]
                        case ds_sdyMu of {
                          [] -> [] [];
                          : y_sdyMw [Occ=Once!] ys_sdyMx [Occ=Once] ->
                              case y_sdyMw of {
                                (,) x_sdyMz [Occ=Once] t1_sdyMA [Occ=Once] ->
                                    let {
                                      sat_sdyMD [Occ=Once] :: [(t_adwFs, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdyMt ys_sdyMx] \u [] go_sdyMt ys_sdyMx; } in
                                    let {
                                      sat_sdyMB [Occ=Once] :: t_adwFs
                                      [LclId] =
                                          [cons_sdyMp x_sdyMz] \u [] cons_sdyMp x_sdyMz; } in
                                    let {
                                      sat_sdyMC [Occ=Once] :: (t_adwFs, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdyMB t1_sdyMA];
                                    } in  : [sat_sdyMC sat_sdyMD];
                              };
                        };
              } in 
                case
                    GHC.Read.readsPrec
                        $dRead_sdyMn Data.Functor.Classes.$fRead1Const1 s_sdyMr
                of
                sat_sdyME
                { __DEFAULT -> go_sdyMt sat_sdyME;
                };
        };

Data.Functor.Classes.$wshowsUnary [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Base.String -> GHC.Prim.Int# -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyMF w1_sdyMG ww_sdyMH w2_sdyMI]
        let {
          g_sdyMJ [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdyMF w2_sdyMI] \u []
                  GHC.Show.showsPrec
                      w_sdyMF Data.Functor.Classes.$fRead1Const1 w2_sdyMI;
        } in 
          case ># [ww_sdyMH 10#] of {
            __DEFAULT ->
                let {
                  sat_sdyMO [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdyMG g_sdyMJ] \r [x_sdyML]
                          let {
                            sat_sdyMM [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdyMJ x_sdyML] \u [] g_sdyMJ x_sdyML; } in
                          let {
                            sat_sdyMN [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyMM];
                          } in  GHC.Base.++ w1_sdyMG sat_sdyMN;
                } in  sat_sdyMO;
            1# ->
                let {
                  sat_sdyMU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdyMG g_sdyMJ] \r [x_sdyMP]
                          let {
                            sat_sdyMT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w1_sdyMG g_sdyMJ x_sdyMP] \u []
                                    let {
                                      sat_sdyMR [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdyMJ x_sdyMP] \u []
                                              let {
                                                sat_sdyMQ [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdyMP];
                                              } in  g_sdyMJ sat_sdyMQ; } in
                                    let {
                                      sat_sdyMS [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdyMR];
                                    } in  GHC.Base.++ w1_sdyMG sat_sdyMS;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdyMT];
                } in  sat_sdyMU;
          };

Data.Functor.Classes.showsUnary [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdyMV w1_sdyMW w2_sdyMX w3_sdyMY]
        case w2_sdyMX of {
          GHC.Types.I# ww1_sdyN0 [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnary
                  w_sdyMV w1_sdyMW ww1_sdyN0 w3_sdyMY;
        };

Data.Functor.Classes.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Classes.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$trModule4];

Data.Functor.Classes.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Classes"#;

Data.Functor.Classes.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$trModule2];

Data.Functor.Classes.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Classes.$trModule3
                                     Data.Functor.Classes.$trModule1];

$krep_rdymB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Functor.Classes.$tcEq4 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rdymB];

Data.Functor.Classes.$tcEq7 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdymB];

Data.Functor.Classes.$tcEq6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Eq1"#;

Data.Functor.Classes.$tcEq5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcEq6];

Data.Functor.Classes.$tcEq1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [71749974434880567##
                                    7233443027070644957##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcEq5
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcOrd5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ord1"#;

Data.Functor.Classes.$tcOrd4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcOrd5];

Data.Functor.Classes.$tcOrd1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11825914698899667233##
                                    4554948325937498991##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcOrd4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcRead5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Read1"#;

Data.Functor.Classes.$tcRead4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcRead5];

Data.Functor.Classes.$tcRead1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14547308444716217043##
                                    925634574698086715##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcRead4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcShow5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Show1"#;

Data.Functor.Classes.$tcShow4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcShow5];

Data.Functor.Classes.$tcShow1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4743290066722511112##
                                    6779909240154408836##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcShow4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcEq9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Eq2"#;

Data.Functor.Classes.$tcEq8 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcEq9];

Data.Functor.Classes.$tcEq2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16920549266159426738##
                                    13264288076834164909##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcEq8
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcOrd7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ord2"#;

Data.Functor.Classes.$tcOrd6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcOrd7];

Data.Functor.Classes.$tcOrd2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4167316048525678806##
                                    17649124474771181823##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcOrd6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcRead7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Read2"#;

Data.Functor.Classes.$tcRead6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcRead7];

Data.Functor.Classes.$tcRead2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [615267248700376470##
                                    8978126042197021701##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcRead6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcShow7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Show2"#;

Data.Functor.Classes.$tcShow6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcShow7];

Data.Functor.Classes.$tcShow2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11321900378419812635##
                                    1323607160578303441##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcShow6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.C:Show2
  :: forall (f :: * -> * -> *).
     (forall a b.
      (GHC.Types.Int -> a -> GHC.Show.ShowS)
      -> ([a] -> GHC.Show.ShowS)
      -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
      -> ([b] -> GHC.Show.ShowS)
      -> GHC.Types.Int
      -> f a b
      -> GHC.Show.ShowS)
     -> (forall a b.
         (GHC.Types.Int -> a -> GHC.Show.ShowS)
         -> ([a] -> GHC.Show.ShowS)
         -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
         -> ([b] -> GHC.Show.ShowS)
         -> [f a b]
         -> GHC.Show.ShowS)
     -> Data.Functor.Classes.Show2 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Show2 [eta_B2 eta_B1];

Data.Functor.Classes.C:Read2
  :: forall (f :: * -> * -> *).
     (forall a b.
      (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
      -> Text.ParserCombinators.ReadP.ReadS [a]
      -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
      -> Text.ParserCombinators.ReadP.ReadS [b]
      -> GHC.Types.Int
      -> Text.ParserCombinators.ReadP.ReadS (f a b))
     -> (forall a b.
         (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
         -> Text.ParserCombinators.ReadP.ReadS [a]
         -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
         -> Text.ParserCombinators.ReadP.ReadS [b]
         -> Text.ParserCombinators.ReadP.ReadS [f a b])
     -> (forall a b.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec b
         -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
         -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b))
     -> (forall a b.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec b
         -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
         -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b])
     -> Data.Functor.Classes.Read2 f
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.C:Read2 [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Functor.Classes.C:Ord2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Eq2 f =>
     (forall a b c d.
      (a -> b -> GHC.Types.Ordering)
      -> (c -> d -> GHC.Types.Ordering)
      -> f a c
      -> f b d
      -> GHC.Types.Ordering)
     -> Data.Functor.Classes.Ord2 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Ord2 [eta_B2 eta_B1];

Data.Functor.Classes.C:Show1
  :: forall (f :: * -> *).
     (forall a.
      (GHC.Types.Int -> a -> GHC.Show.ShowS)
      -> ([a] -> GHC.Show.ShowS)
      -> GHC.Types.Int
      -> f a
      -> GHC.Show.ShowS)
     -> (forall a.
         (GHC.Types.Int -> a -> GHC.Show.ShowS)
         -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS)
     -> Data.Functor.Classes.Show1 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Show1 [eta_B2 eta_B1];

Data.Functor.Classes.C:Read1
  :: forall (f :: * -> *).
     (forall a.
      (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
      -> Text.ParserCombinators.ReadP.ReadS [a]
      -> GHC.Types.Int
      -> Text.ParserCombinators.ReadP.ReadS (f a))
     -> (forall a.
         (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
         -> Text.ParserCombinators.ReadP.ReadS [a]
         -> Text.ParserCombinators.ReadP.ReadS [f a])
     -> (forall a.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec (f a))
     -> (forall a.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec [f a])
     -> Data.Functor.Classes.Read1 f
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.C:Read1 [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Functor.Classes.C:Ord1
  :: forall (f :: * -> *).
     Data.Functor.Classes.Eq1 f =>
     (forall a b.
      (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering)
     -> Data.Functor.Classes.Ord1 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Ord1 [eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:08:53.655719255 UTC

Data.Functor.Classes.liftShowsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> f a b
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdEzz]
        case v_sdEzz of {
          Data.Functor.Classes.C:Show2 v_sdEzB [Occ=Once] _ [Occ=Dead] ->
              v_sdEzB;
        };

Data.Functor.Classes.liftShowList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [f a b]
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdEzD]
        case v_sdEzD of {
          Data.Functor.Classes.C:Show2 _ [Occ=Dead] v_sdEzG [Occ=Once] ->
              v_sdEzG;
        };

Data.Functor.Classes.liftReadsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdEzH]
        case v_sdEzH of {
          Data.Functor.Classes.C:Read2 v_sdEzJ [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdEzJ;
        };

Data.Functor.Classes.liftReadList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdEzN]
        case v_sdEzN of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       v_sdEzQ [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdEzQ;
        };

Data.Functor.Classes.liftReadPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdEzT]
        case v_sdEzT of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdEzX [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdEzX;
        };

Data.Functor.Classes.liftReadListPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdEzZ]
        case v_sdEzZ of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdEA4 [Occ=Once] ->
              v_sdEA4;
        };

Data.Functor.Classes.$p1Ord2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Ord2 f =>
     Data.Functor.Classes.Eq2 f
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdEA5]
        case v_sdEA5 of {
          Data.Functor.Classes.C:Ord2 v_sdEA7 [Occ=Once] _ [Occ=Dead] ->
              v_sdEA7;
        };

Data.Functor.Classes.liftCompare2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Ord2 f =>
     forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> f a c
     -> f b d
     -> GHC.Types.Ordering
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdEA9]
        case v_sdEA9 of {
          Data.Functor.Classes.C:Ord2 _ [Occ=Dead] v_sdEAc [Occ=Once] ->
              v_sdEAc;
        };

Data.Functor.Classes.liftEq2 [InlPrag=INLINE]
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Eq2 f =>
     forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool) -> f a c -> f b d -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sdEAd] v_sdEAd;

Data.Functor.Classes.liftShowsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> f a
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdEAe]
        case v_sdEAe of {
          Data.Functor.Classes.C:Show1 v_sdEAg [Occ=Once] _ [Occ=Dead] ->
              v_sdEAg;
        };

Data.Functor.Classes.liftShowList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdEAi]
        case v_sdEAi of {
          Data.Functor.Classes.C:Show1 _ [Occ=Dead] v_sdEAl [Occ=Once] ->
              v_sdEAl;
        };

Data.Functor.Classes.liftReadsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdEAm]
        case v_sdEAm of {
          Data.Functor.Classes.C:Read1 v_sdEAo [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdEAo;
        };

Data.Functor.Classes.liftReadList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdEAs]
        case v_sdEAs of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       v_sdEAv [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdEAv;
        };

Data.Functor.Classes.liftReadPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdEAy]
        case v_sdEAy of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdEAC [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdEAC;
        };

Data.Functor.Classes.liftReadListPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdEAE]
        case v_sdEAE of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdEAJ [Occ=Once] ->
              v_sdEAJ;
        };

Data.Functor.Classes.$p1Ord1
  :: forall (f :: * -> *).
     Data.Functor.Classes.Ord1 f =>
     Data.Functor.Classes.Eq1 f
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdEAK]
        case v_sdEAK of {
          Data.Functor.Classes.C:Ord1 v_sdEAM [Occ=Once] _ [Occ=Dead] ->
              v_sdEAM;
        };

Data.Functor.Classes.liftCompare
  :: forall (f :: * -> *).
     Data.Functor.Classes.Ord1 f =>
     forall a b.
     (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdEAO]
        case v_sdEAO of {
          Data.Functor.Classes.C:Ord1 _ [Occ=Dead] v_sdEAR [Occ=Once] ->
              v_sdEAR;
        };

Data.Functor.Classes.liftEq [InlPrag=INLINE]
  :: forall (f :: * -> *).
     Data.Functor.Classes.Eq1 f =>
     forall a b.
     (a -> b -> GHC.Types.Bool) -> f a -> f b -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sdEAS] v_sdEAS;

Data.Functor.Classes.$fRead1Const1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Classes.$fRead1Const4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Const"#;

Data.Functor.Classes.$fRead1Const3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Const4;

Data.Functor.Classes.$fRead1Const2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Const3];

Data.Functor.Classes.$w$cliftReadPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Functor.Const.Const a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEAT w1_sdEAU w2_sdEAV]
        let {
          sat_sdEB7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_sdxVk b_sdxVl)
          [LclId] =
              [w_sdEAT] \r [c_sdEAW eta_sdEAX]
                  case c_sdEAW of {
                    GHC.Types.I# x_sdEAZ [Occ=Once] ->
                        case <=# [x_sdEAZ 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdEB4 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_X81aZ
                                [LclId] =
                                    [w_sdEAT eta_sdEAX] \r [a1_sdEB1]
                                        let {
                                          sat_sdEB3 [Occ=Once]
                                            :: a_sdxVk -> Text.ParserCombinators.ReadP.P b2_X81aZ
                                          [LclId] =
                                              [eta_sdEAX] \r [a2_sdEB2] eta_sdEAX a2_sdEB2;
                                        } in  w_sdEAT Data.Functor.Classes.$fRead1Const1 sat_sdEB3;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Const2 sat_sdEB4
                                of
                                { Unit# ww1_sdEB6 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sdEB6];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdEB7 w1_sdEAU w2_sdEAV;

Data.Functor.Classes.$fRead1Const6 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Functor.Const.Const a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,A><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEB8 w1_sdEB9 w2_sdEBa w3_sdEBb w4_sdEBc w5_sdEBd]
        Data.Functor.Classes.$w$cliftReadPrec1 w_sdEB8 w4_sdEBc w5_sdEBd;

Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Const.Const a b]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdEBe rl1_sdEBf rp2_sdEBg rl2_sdEBh]
        let {
          sat_sdEBk [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_adwSL b_adwSM)
          [LclId] =
              [rp1_sdEBe] \r [w_sdEBi w1_sdEBj]
                  Data.Functor.Classes.$w$cliftReadPrec1 rp1_sdEBe w_sdEBi w1_sdEBj;
        } in  GHC.Read.list sat_sdEBk;

Data.Functor.Classes.$w$cliftReadsPrec7 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a b)
[GblId, Arity=2, Str=<L,1*C1(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEBl w1_sdEBm]
        let {
          sat_sdEBC [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Const.Const a_sdxVu b_sdxVv)
          [LclId] =
              [w_sdEBl w1_sdEBm] \u []
                  let {
                    lvl3_sdEBn [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS a_sdxVu
                    [LclId] =
                        [w_sdEBl] \u [] w_sdEBl Data.Functor.Classes.$fRead1Const1; } in
                  let {
                    sat_sdEBB [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Const.Const a_sdxVu b_sdxVv)
                    [LclId] =
                        [lvl3_sdEBn] \r [c_sdEBo eta_sdEBp]
                            case c_sdEBo of {
                              GHC.Types.I# x_sdEBr [Occ=Once] ->
                                  case <=# [x_sdEBr 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdEBy [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [lvl3_sdEBn eta_sdEBp] \r [a1_sdEBt]
                                                  let {
                                                    sat_sdEBv [Occ=Once]
                                                      :: a_sdxVu
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta_sdEBp] \r [a2_sdEBu]
                                                            eta_sdEBp a2_sdEBu;
                                                  } in 
                                                    case
                                                        Text.ParserCombinators.ReadP.$wreadS_to_P
                                                            lvl3_sdEBn sat_sdEBv
                                                    of
                                                    { Unit# ww1_sdEBx [Occ=Once] ->
                                                          Text.ParserCombinators.ReadP.Look [ww1_sdEBx];
                                                    };
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Const2 sat_sdEBy
                                          of
                                          { Unit# ww1_sdEBA [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdEBA];
                                          };
                                  };
                            };
                  } in 
                    GHC.Read.list3
                        sat_sdEBB
                        w1_sdEBm
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEBC;

Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a b)
[GblId,
 Arity=5,
 Str=<L,1*C1(C(U))><L,A><L,A><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEBD w1_sdEBE w2_sdEBF w3_sdEBG w4_sdEBH]
        Data.Functor.Classes.$w$cliftReadsPrec7 w_sdEBD w4_sdEBH;

Data.Functor.Classes.$fRead1Either3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right"#;

Data.Functor.Classes.$fRead1Either2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Either3;

Data.Functor.Classes.$fRead1Either1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Either2];

Data.Functor.Classes.$fRead1Either6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left"#;

Data.Functor.Classes.$fRead1Either5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Either6;

Data.Functor.Classes.$fRead1Either4 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Either5];

Data.Functor.Classes.$w$cliftReadPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEBI w1_sdEBJ w2_sdEBK w3_sdEBL]
        let {
          sat_sdEC7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_sdxVC b_sdxVD)
          [LclId] =
              [w_sdEBI w1_sdEBJ] \r [c_sdEBM eta_sdEBN]
                  case c_sdEBM of {
                    GHC.Types.I# x_sdEBP [Occ=Once] ->
                        case <=# [x_sdEBP 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdEBV [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                [LclId] =
                                    [w_sdEBI eta_sdEBN] \r [a1_sdEBR]
                                        let {
                                          sat_sdEBU [Occ=Once]
                                            :: a_sdxVC -> Text.ParserCombinators.ReadP.P b2_i815E
                                          [LclId] =
                                              [eta_sdEBN] \r [a2_sdEBS]
                                                  let {
                                                    sat_sdEBT [Occ=Once]
                                                      :: Data.Either.Either a_sdxVC b_sdxVD
                                                    [LclId] =
                                                        CCCS Data.Either.Left! [a2_sdEBS];
                                                  } in  eta_sdEBN sat_sdEBT;
                                        } in  w_sdEBI Data.Functor.Classes.$fRead1Const1 sat_sdEBU;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Either4 sat_sdEBV
                                of
                                { Unit# ww1_sdEBX [Occ=Once] ->
                                      let {
                                        sat_sdEC6 [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b2_i815E
                                        [LclId] =
                                            [w1_sdEBJ eta_sdEBN] \u []
                                                let {
                                                  sat_sdEC3 [Occ=Once]
                                                    :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                                  [LclId] =
                                                      [w1_sdEBJ eta_sdEBN] \r [a1_sdEBZ]
                                                          let {
                                                            sat_sdEC2 [Occ=Once]
                                                              :: b_sdxVD
                                                                 -> Text.ParserCombinators.ReadP.P
                                                                      b2_i815E
                                                            [LclId] =
                                                                [eta_sdEBN] \r [a2_sdEC0]
                                                                    let {
                                                                      sat_sdEC1 [Occ=Once]
                                                                        :: Data.Either.Either
                                                                             a_sdxVC b_sdxVD
                                                                      [LclId] =
                                                                          CCCS Data.Either.Right! [a2_sdEC0];
                                                                    } in  eta_sdEBN sat_sdEC1;
                                                          } in 
                                                            w1_sdEBJ
                                                                Data.Functor.Classes.$fRead1Const1
                                                                sat_sdEC2;
                                                } in 
                                                  case
                                                      Text.Read.Lex.$wexpect
                                                          Data.Functor.Classes.$fRead1Either1
                                                          sat_sdEC3
                                                  of
                                                  { Unit# ww3_sdEC5 [Occ=Once] ->
                                                        Text.ParserCombinators.ReadP.Look [ww3_sdEC5];
                                                  }; } in
                                      let {
                                        sat_sdEBY [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b2_i815E
                                        [LclId] =
                                            CCCS Text.ParserCombinators.ReadP.Look! [ww1_sdEBX];
                                      } in 
                                        Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                            sat_sdEBY sat_sdEC6;
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdEC7 w2_sdEBK w3_sdEBL;

Data.Functor.Classes.$fRead1Either8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEC8 w1_sdEC9 w2_sdECa w3_sdECb w4_sdECc w5_sdECd]
        Data.Functor.Classes.$w$cliftReadPrec3
            w_sdEC8 w2_sdECa w4_sdECc w5_sdECd;

Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a b]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdECe rl1_sdECf rp2_sdECg rl2_sdECh]
        let {
          sat_sdECk [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_adwUm b_adwUn)
          [LclId] =
              [rp1_sdECe rp2_sdECg] \r [w_sdECi w1_sdECj]
                  Data.Functor.Classes.$w$cliftReadPrec3
                      rp1_sdECe rp2_sdECg w_sdECi w1_sdECj;
        } in  GHC.Read.list sat_sdECk;

Data.Functor.Classes.$w$cliftReadsPrec8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdECl w1_sdECm w2_sdECn]
        let {
          sat_sdECq [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_sdxVM b_sdxVN)
          [LclId] =
              [w_sdECl w1_sdECm w2_sdECn] \u []
                  let {
                    sat_sdECp [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_sdxVN
                    [LclId] =
                        [w1_sdECm] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdECm eta_B1; } in
                  let {
                    sat_sdECo [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdxVM
                    [LclId] =
                        [w_sdECl] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdECl eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec3
                        sat_sdECo
                        sat_sdECp
                        w2_sdECn
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdECq;

Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=5,
 Str=<L,C(C(U))><L,A><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdECr w1_sdECs w2_sdECt w3_sdECu w4_sdECv]
        Data.Functor.Classes.$w$cliftReadsPrec8 w_sdECr w2_sdECt w4_sdECv;

Data.Functor.Classes.$fEq1Maybe_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdECw ds1_sdECx ds2_sdECy]
        case ds1_sdECx of {
          GHC.Base.Nothing ->
              case ds2_sdECy of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just ds3_sdECC [Occ=Once] ->
              case ds2_sdECy of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just y_sdECE [Occ=Once] -> ds_sdECw ds3_sdECC y_sdECE;
              };
        };

Data.Functor.Classes.$fEq1Maybe [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 GHC.Base.Maybe
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Maybe_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1 [Occ=LoopBreaker]
  :: forall a b.
     (a -> b -> GHC.Types.Bool) -> [a] -> [b] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdECF ds1_sdECG ds2_sdECH]
        case ds1_sdECG of {
          [] ->
              case ds2_sdECH of {
                [] -> GHC.Types.True [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
              };
          : ds3_sdECM [Occ=Once] ds4_sdECN [Occ=Once] ->
              case ds2_sdECH of {
                [] -> GHC.Types.False [];
                : y_sdECP [Occ=Once] ys_sdECQ [Occ=Once] ->
                    case ds_sdECF ds3_sdECM y_sdECP of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True ->
                          Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                              ds_sdECF ds4_sdECN ys_sdECQ;
                    };
              };
        };

Data.Functor.Classes.$fEq1[] [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 []
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$w$cliftEq [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> a -> [a] -> b -> [b] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdECS ww_sdECT ww1_sdECU ww2_sdECV ww3_sdECW]
        case w_sdECS ww_sdECT ww2_sdECV of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                  w_sdECS ww1_sdECU ww3_sdECW;
        };

Data.Functor.Classes.$fEq1NonEmpty_$cliftEq [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdECY w1_sdECZ w2_sdED0]
        case w1_sdECZ of {
          GHC.Base.:| ww1_sdED2 [Occ=Once] ww2_sdED3 [Occ=Once] ->
              case w2_sdED0 of {
                GHC.Base.:| ww4_sdED5 [Occ=Once] ww5_sdED6 [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftEq
                        w_sdECY ww1_sdED2 ww2_sdED3 ww4_sdED5 ww5_sdED6;
              };
        };

Data.Functor.Classes.$fEq1NonEmpty [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 GHC.Base.NonEmpty
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1NonEmpty_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Identity_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eq_sdED7 ds_sdED8 ds1_sdED9] eq_sdED7 ds_sdED8 ds1_sdED9;

Data.Functor.Classes.$fEq1Identity [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 Data.Functor.Identity.Identity
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Identity_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Proxy_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdEDa ds1_sdEDb ds2_sdEDc] GHC.Types.True [];

Data.Functor.Classes.$fEq1Proxy [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 Data.Proxy.Proxy
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Proxy_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fOrd1Maybe_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdEDd ds1_sdEDe ds2_sdEDf]
        case ds1_sdEDe of {
          GHC.Base.Nothing ->
              case ds2_sdEDf of {
                GHC.Base.Nothing -> GHC.Types.EQ [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.LT [];
              };
          GHC.Base.Just ds3_sdEDj [Occ=Once] ->
              case ds2_sdEDf of {
                GHC.Base.Nothing -> GHC.Types.GT [];
                GHC.Base.Just y_sdEDl [Occ=Once] -> ds_sdEDd ds3_sdEDj y_sdEDl;
              };
        };

Data.Functor.Classes.$fOrd1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Maybe_$cliftEq
                                                Data.Functor.Classes.$fOrd1Maybe_$cliftCompare];

Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1 [Occ=LoopBreaker]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering) -> [a] -> [b] -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdEDm ds1_sdEDn ds2_sdEDo]
        case ds1_sdEDn of {
          [] ->
              case ds2_sdEDo of {
                [] -> GHC.Types.EQ [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.LT [];
              };
          : ds3_sdEDt [Occ=Once] ds4_sdEDu [Occ=Once] ->
              case ds2_sdEDo of {
                [] -> GHC.Types.GT [];
                : y_sdEDw [Occ=Once] ys_sdEDx [Occ=Once] ->
                    case ds_sdEDm ds3_sdEDt y_sdEDw of {
                      GHC.Types.LT -> GHC.Types.LT [];
                      GHC.Types.EQ ->
                          Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
                              ds_sdEDm ds4_sdEDu ys_sdEDx;
                      GHC.Types.GT -> GHC.Types.GT [];
                    };
              };
        };

Data.Functor.Classes.$fOrd1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                                                Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1];

Data.Functor.Classes.$w$cliftCompare1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> a -> [a] -> b -> [b] -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdEDz ww_sdEDA ww1_sdEDB ww2_sdEDC ww3_sdEDD]
        case w_sdEDz ww_sdEDA ww2_sdEDC of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
                  w_sdEDz ww1_sdEDB ww3_sdEDD;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEDF w1_sdEDG w2_sdEDH]
        case w1_sdEDG of {
          GHC.Base.:| ww1_sdEDJ [Occ=Once] ww2_sdEDK [Occ=Once] ->
              case w2_sdEDH of {
                GHC.Base.:| ww4_sdEDM [Occ=Once] ww5_sdEDN [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftCompare1
                        w_sdEDF ww1_sdEDJ ww2_sdEDK ww4_sdEDM ww5_sdEDN;
              };
        };

Data.Functor.Classes.$fOrd1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1NonEmpty_$cliftEq
                                                Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare];

Data.Functor.Classes.$fOrd1Identity_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [comp_sdEDO ds_sdEDP ds1_sdEDQ]
        comp_sdEDO ds_sdEDP ds1_sdEDQ;

Data.Functor.Classes.$fOrd1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Identity_$cliftEq
                                                Data.Functor.Classes.$fOrd1Identity_$cliftCompare];

Data.Functor.Classes.$fOrd1Proxy_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdEDR ds1_sdEDS ds2_sdEDT] GHC.Types.EQ [];

Data.Functor.Classes.$fOrd1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 Data.Proxy.Proxy
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Proxy_$cliftEq
                                                Data.Functor.Classes.$fOrd1Proxy_$cliftCompare];

Data.Functor.Classes.$fRead1[]_$cliftReadPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdEDU rl_sdEDV] rl_sdEDV;

Data.Functor.Classes.$fRead1NonEmpty4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":|"#;

Data.Functor.Classes.$fRead1NonEmpty3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1NonEmpty4;

Data.Functor.Classes.$fRead1NonEmpty2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [6#];

Data.Functor.Classes.$w$cliftReadsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Prim.Int#
     -> GHC.Base.String
     -> [(GHC.Base.NonEmpty a, GHC.Base.String)]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(U)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEDW w1_sdEDX ww_sdEDY w2_sdEDZ]
        let {
          go_sdEE0 [Occ=LoopBreaker]
            :: [(a_sdxWD, GHC.Base.String)]
               -> [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w1_sdEDX go_sdEE0] \r [ds_sdEE1]
                  case ds_sdEE1 of {
                    [] -> [] [];
                    : y_sdEE3 [Occ=Once!] ys_sdEE4 [Occ=Once] ->
                        case y_sdEE3 of {
                          (,) a1_sdEE6 [Occ=OnceL] s''_sdEE7 [Occ=Once] ->
                              let {
                                z_sdEE8 [Occ=OnceL]
                                  :: [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
                                [LclId] =
                                    [go_sdEE0 ys_sdEE4] \u [] go_sdEE0 ys_sdEE4; } in
                              let {
                                go1_sdEE9 [Occ=LoopBreaker]
                                  :: [(GHC.Base.String, GHC.Base.String)]
                                     -> [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
                                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                    sat-only [w1_sdEDX a1_sdEE6 z_sdEE8 go1_sdEE9] \r [ds1_sdEEa]
                                        case ds1_sdEEa of {
                                          [] -> z_sdEE8;
                                          : y1_sdEEc [Occ=Once!] ys1_sdEEd [Occ=Once*] ->
                                              case y1_sdEEc of {
                                                (,) ds2_sdEEf [Occ=Once] s'''_sdEEg [Occ=Once] ->
                                                    case
                                                        GHC.Base.eqString
                                                            ds2_sdEEf
                                                            Data.Functor.Classes.$fRead1NonEmpty3
                                                    of
                                                    { GHC.Types.False -> go1_sdEE9 ys1_sdEEd;
                                                      GHC.Types.True ->
                                                          let {
                                                            z1_sdEEi [Occ=OnceL]
                                                              :: [(GHC.Base.NonEmpty a_sdxWD,
                                                                   GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdEE9 ys1_sdEEd] \u []
                                                                    go1_sdEE9 ys1_sdEEd; } in
                                                          let {
                                                            go2_sdEEj [Occ=LoopBreaker]
                                                              :: [([a_sdxWD], GHC.Base.String)]
                                                                 -> [(GHC.Base.NonEmpty a_sdxWD,
                                                                      GHC.Base.String)]
                                                            [LclId,
                                                             Arity=1,
                                                             Str=<S,1*U>,
                                                             Unf=OtherCon []] =
                                                                sat-only [a1_sdEE6
                                                                          z1_sdEEi
                                                                          go2_sdEEj] \r [ds3_sdEEk]
                                                                    case ds3_sdEEk of {
                                                                      [] -> z1_sdEEi;
                                                                      : y2_sdEEm [Occ=Once!]
                                                                        ys2_sdEEn [Occ=Once] ->
                                                                          case y2_sdEEm of {
                                                                            (,) as_sdEEp [Occ=Once]
                                                                                s''''_sdEEq [Occ=Once] ->
                                                                                let {
                                                                                  sat_sdEEt [Occ=Once]
                                                                                    :: [(GHC.Base.NonEmpty
                                                                                           a_sdxWD,
                                                                                         GHC.Base.String)]
                                                                                  [LclId] =
                                                                                      [go2_sdEEj
                                                                                       ys2_sdEEn] \u []
                                                                                          go2_sdEEj
                                                                                              ys2_sdEEn; } in
                                                                                let {
                                                                                  sat_sdEEr [Occ=Once]
                                                                                    :: GHC.Base.NonEmpty
                                                                                         a_sdxWD
                                                                                  [LclId] =
                                                                                      CCCS GHC.Base.:|! [a1_sdEE6
                                                                                                         as_sdEEp]; } in
                                                                                let {
                                                                                  sat_sdEEs [Occ=Once]
                                                                                    :: (GHC.Base.NonEmpty
                                                                                          a_sdxWD,
                                                                                        GHC.Base.String)
                                                                                  [LclId] =
                                                                                      CCCS (,)! [sat_sdEEr
                                                                                                 s''''_sdEEq];
                                                                                } in 
                                                                                  : [sat_sdEEs
                                                                                     sat_sdEEt];
                                                                          };
                                                                    };
                                                          } in 
                                                            case w1_sdEDX s'''_sdEEg of sat_sdEEu {
                                                              __DEFAULT -> go2_sdEEj sat_sdEEu;
                                                            };
                                                    };
                                              };
                                        };
                              } in 
                                case
                                    Text.ParserCombinators.ReadP.run GHC.Read.lex1 s''_sdEE7
                                of
                                sat_sdEEv
                                { __DEFAULT -> go1_sdEE9 sat_sdEEv;
                                };
                        };
                  }; } in
        let {
          sat_sdEEA [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_sdxWD)
          [LclId] =
              [w_sdEDW go_sdEE0] \r [s'_sdEEy]
                  case
                      w_sdEDW Data.Functor.Classes.$fRead1NonEmpty2 s'_sdEEy
                  of
                  sat_sdEEz
                  { __DEFAULT -> go_sdEE0 sat_sdEEz;
                  };
        } in 
          case ># [ww_sdEDY 5#] of sat_sdEEw {
            __DEFAULT ->
                case tagToEnum# [sat_sdEEw] of sat_sdEEx {
                  __DEFAULT -> GHC.Read.readParen sat_sdEEx sat_sdEEA w2_sdEDZ;
                };
          };

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a)
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(U)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEEB w1_sdEEC w2_sdEED w3_sdEEE]
        case w2_sdEED of {
          GHC.Types.I# ww1_sdEEG [Occ=Once] ->
              Data.Functor.Classes.$w$cliftReadsPrec5
                  w_sdEEB w1_sdEEC ww1_sdEEG w3_sdEEE;
        };

Data.Functor.Classes.$fRead1Proxy4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Proxy"#;

Data.Functor.Classes.$fRead1Proxy3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Proxy4;

Data.Functor.Classes.$fRead1Proxy_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Proxy3];

Data.Functor.Classes.$fRead1Proxy2
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [eta_sdEEH eta1_sdEEI]
        let {
          sat_sdEEK [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X81cg
          [LclId] =
              [eta1_sdEEI] \r [x_sdEEJ] eta1_sdEEI Data.Proxy.Proxy;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Functor.Classes.$fRead1Proxy_lexeme sat_sdEEK
          of
          { Unit# ww1_sdEEM [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sdEEM];
          };

Data.Functor.Classes.$fRead1Proxy1
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Functor.Classes.$fRead1Proxy2 eta_B2 eta_B1;

Data.Functor.Classes.$fRead1Proxy5
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=4, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdEEN ds1_sdEEO eta_B2 eta_B1]
        Data.Functor.Classes.$fRead1Proxy1 eta_B2 eta_B1;

Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> [a]
     -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdEEP sl_sdEEQ ds1_sdEER] sl_sdEEQ;

Data.Functor.Classes.$fShow1NonEmpty1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " :| "#;

Data.Functor.Classes.$w$cliftShowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> a
     -> [a]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C(U))><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEES w1_sdEET ww_sdEEU ww1_sdEEV ww2_sdEEW]
        let {
          f_sdEEX [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEES ww1_sdEEV] \u []
                  w_sdEES Data.Functor.Classes.$fRead1NonEmpty2 ww1_sdEEV; } in
        let {
          g_sdEEY [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdEET ww2_sdEEW] \u [] w1_sdEET ww2_sdEEW;
        } in 
          case ># [ww_sdEEU 5#] of {
            __DEFAULT ->
                let {
                  sat_sdEF3 [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_sdEEX g_sdEEY] \r [x_sdEF0]
                          let {
                            sat_sdEF2 [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g_sdEEY x_sdEF0] \u []
                                    let {
                                      sat_sdEF1 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdEEY x_sdEF0] \u [] g_sdEEY x_sdEF0;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Functor.Classes.$fShow1NonEmpty1 sat_sdEF1;
                          } in  f_sdEEX sat_sdEF2;
                } in  sat_sdEF3;
            1# ->
                let {
                  sat_sdEF9 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sdEEX g_sdEEY] \r [x_sdEF4]
                          let {
                            sat_sdEF8 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sdEEX g_sdEEY x_sdEF4] \u []
                                    let {
                                      sat_sdEF7 [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g_sdEEY x_sdEF4] \u []
                                              let {
                                                sat_sdEF6 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sdEEY x_sdEF4] \u []
                                                        let {
                                                          sat_sdEF5 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdEF4];
                                                        } in  g_sdEEY sat_sdEF5;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Functor.Classes.$fShow1NonEmpty1 sat_sdEF6;
                                    } in  f_sdEEX sat_sdEF7;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEF8];
                } in  sat_sdEF9;
          };

Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> GHC.Base.NonEmpty a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C(U))><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEFa w1_sdEFb w2_sdEFc w3_sdEFd]
        case w2_sdEFc of {
          GHC.Types.I# ww1_sdEFf [Occ=Once] ->
              case w3_sdEFd of {
                GHC.Base.:| ww3_sdEFh [Occ=Once] ww4_sdEFi [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftShowsPrec1
                        w_sdEFa w1_sdEFb ww1_sdEFf ww3_sdEFh ww4_sdEFi;
              };
        };

Data.Functor.Classes.$fShow1Proxy2
  :: [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Base.++ Data.Functor.Classes.$fRead1Proxy3 eta_B1;

Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Proxy.Proxy a
     -> GHC.Show.ShowS
[GblId, Arity=5, Str=<L,A><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdEFj ds1_sdEFk ds2_sdEFl ds3_sdEFm eta_B1]
        Data.Functor.Classes.$fShow1Proxy2 eta_B1;

Data.Functor.Classes.$fEq2(,)_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool) -> (a, c) -> (b, d) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [e1_sdEFn e2_sdEFo ds_sdEFp ds1_sdEFq]
        case ds_sdEFp of {
          (,) x1_sdEFs [Occ=Once] y1_sdEFt [Occ=Once] ->
              case ds1_sdEFq of {
                (,) x2_sdEFv [Occ=Once] y2_sdEFw [Occ=Once] ->
                    case e1_sdEFn x1_sdEFs x2_sdEFv of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> e2_sdEFo y1_sdEFt y2_sdEFw;
                    };
              };
        };

Data.Functor.Classes.$fEq2(,) [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 (,)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2(,)_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1(,)_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> (a, a1) -> (a, b) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdEFy eta_sdEFz eta1_sdEFA eta2_sdEFB]
        case eta1_sdEFA of {
          (,) x1_sdEFD [Occ=Once] y1_sdEFE [Occ=Once] ->
              case eta2_sdEFB of {
                (,) x2_sdEFG [Occ=Once] y2_sdEFH [Occ=Once] ->
                    case GHC.Classes.== $dEq_sdEFy x1_sdEFD x2_sdEFG of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> eta_sdEFz y1_sdEFE y2_sdEFH;
                    };
              };
        };

Data.Functor.Classes.$fEq1(,) [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Classes.Eq a => Data.Functor.Classes.Eq1 ((,) a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1(,)_$cliftEq eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq2Either_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool)
     -> Data.Either.Either a c
     -> Data.Either.Either b d
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [e1_sdEFJ ds_sdEFK ds1_sdEFL ds2_sdEFM]
        case ds1_sdEFL of {
          Data.Either.Left x_sdEFO [Occ=Once] ->
              case ds2_sdEFM of {
                Data.Either.Left y_sdEFQ [Occ=Once] -> e1_sdEFJ x_sdEFO y_sdEFQ;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds3_sdEFS [Occ=Once] ->
              case ds2_sdEFM of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdEFV [Occ=Once] -> ds_sdEFK ds3_sdEFS y_sdEFV;
              };
        };

Data.Functor.Classes.$fEq2Either [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 Data.Either.Either
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2Either_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Either_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdEFW eta_sdEFX eta1_sdEFY eta2_sdEFZ]
        case eta1_sdEFY of {
          Data.Either.Left x_sdEG1 [Occ=Once] ->
              case eta2_sdEFZ of {
                Data.Either.Left y_sdEG3 [Occ=Once] ->
                    GHC.Classes.== $dEq_sdEFW x_sdEG1 y_sdEG3;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds_sdEG5 [Occ=Once] ->
              case eta2_sdEFZ of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdEG8 [Occ=Once] -> eta_sdEFX ds_sdEG5 y_sdEG8;
              };
        };

Data.Functor.Classes.$fEq1Either [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Classes.Eq1 (Data.Either.Either a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Either_$cliftEq
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq2Const_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a c
     -> Data.Functor.Const.Const b d
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eq_sdEG9 ds_sdEGa ds1_sdEGb ds2_sdEGc]
        eq_sdEG9 ds1_sdEGb ds2_sdEGc;

Data.Functor.Classes.$fEq2Const [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 Data.Functor.Const.Const
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2Const_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Const_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a a1
     -> Data.Functor.Const.Const a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdEGd eta_sdEGe eta1_sdEGf eta2_sdEGg]
        GHC.Classes.== $dEq_sdEGd eta1_sdEGf eta2_sdEGg;

Data.Functor.Classes.$fEq1Const [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Const_$cliftEq
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fOrd2(,)_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> (a, c)
     -> (b, d)
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [comp1_sdEGh comp2_sdEGi ds_sdEGj ds1_sdEGk]
        case ds_sdEGj of {
          (,) x1_sdEGm [Occ=Once] y1_sdEGn [Occ=Once] ->
              case ds1_sdEGk of {
                (,) x2_sdEGp [Occ=Once] y2_sdEGq [Occ=Once] ->
                    case comp1_sdEGh x1_sdEGm x2_sdEGp of {
                      GHC.Types.LT -> GHC.Types.LT [];
                      GHC.Types.EQ -> comp2_sdEGi y1_sdEGn y2_sdEGq;
                      GHC.Types.GT -> GHC.Types.GT [];
                    };
              };
        };

Data.Functor.Classes.$fOrd2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2(,)_$cliftEq2
                                                Data.Functor.Classes.$fOrd2(,)_$cliftCompare2];

Data.Functor.Classes.$w$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> a -> a1 -> a -> b -> GHC.Types.Ordering
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEGs w1_sdEGt ww_sdEGu ww1_sdEGv ww2_sdEGw ww3_sdEGx]
        case GHC.Classes.compare w_sdEGs ww_sdEGu ww2_sdEGw of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> w1_sdEGt ww1_sdEGv ww3_sdEGx;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Classes.$fOrd1(,)_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> (a, a1) -> (a, b) -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEGz w1_sdEGA w2_sdEGB w3_sdEGC]
        case w2_sdEGB of {
          (,) ww1_sdEGE [Occ=Once] ww2_sdEGF [Occ=Once] ->
              case w3_sdEGC of {
                (,) ww4_sdEGH [Occ=Once] ww5_sdEGI [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftCompare
                        w_sdEGz w1_sdEGA ww1_sdEGE ww2_sdEGF ww4_sdEGH ww5_sdEGI;
              };
        };

Data.Functor.Classes.$w$cp1Ord1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> a -> a1 -> a -> b -> GHC.Types.Bool
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEGJ w1_sdEGK ww_sdEGL ww1_sdEGM ww2_sdEGN ww3_sdEGO]
        case GHC.Classes.$p1Ord w_sdEGJ of sat_sdEGP {
          __DEFAULT ->
              case GHC.Classes.== sat_sdEGP ww_sdEGL ww2_sdEGN of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> w1_sdEGK ww1_sdEGM ww3_sdEGO;
              };
        };

Data.Functor.Classes.$fOrd1(,)1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> (a, a1) -> (a, b) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEGR w1_sdEGS w2_sdEGT w3_sdEGU]
        case w2_sdEGT of {
          (,) ww1_sdEGW [Occ=Once] ww2_sdEGX [Occ=Once] ->
              case w3_sdEGU of {
                (,) ww4_sdEGZ [Occ=Once] ww5_sdEH0 [Occ=Once] ->
                    Data.Functor.Classes.$w$cp1Ord1
                        w_sdEGR w1_sdEGS ww1_sdEGW ww2_sdEGX ww4_sdEGZ ww5_sdEH0;
              };
        };

Data.Functor.Classes.$fOrd1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Ord a => Data.Functor.Classes.Ord1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdEH1]
        let {
          sat_sdEH3 [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> (a_Xdx1z, a) -> (a_Xdx1z, b) -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdEH1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1(,)_$cliftCompare
                      $dOrd_sdEH1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdEH2 [Occ=Once] :: Data.Functor.Classes.Eq1 ((,) a_Xdx1z)
          [LclId] =
              [$dOrd_sdEH1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1(,)1 $dOrd_sdEH1 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdEH2 sat_sdEH3];

Data.Functor.Classes.$fOrd2Either_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> Data.Either.Either a c
     -> Data.Either.Either b d
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [comp1_sdEH4 ds_sdEH5 ds1_sdEH6 ds2_sdEH7]
        case ds1_sdEH6 of {
          Data.Either.Left x_sdEH9 [Occ=Once] ->
              case ds2_sdEH7 of {
                Data.Either.Left y_sdEHb [Occ=Once] -> comp1_sdEH4 x_sdEH9 y_sdEHb;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right ds3_sdEHd [Occ=Once] ->
              case ds2_sdEH7 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right y_sdEHg [Occ=Once] -> ds_sdEH5 ds3_sdEHd y_sdEHg;
              };
        };

Data.Functor.Classes.$fOrd2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2Either_$cliftEq2
                                                Data.Functor.Classes.$fOrd2Either_$cliftCompare2];

Data.Functor.Classes.$fOrd1Either_$cliftCompare
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdEHh eta_sdEHi eta1_sdEHj eta2_sdEHk]
        case eta1_sdEHj of {
          Data.Either.Left x_sdEHm [Occ=Once] ->
              case eta2_sdEHk of {
                Data.Either.Left y_sdEHo [Occ=Once] ->
                    GHC.Classes.compare $dOrd_sdEHh x_sdEHm y_sdEHo;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right ds_sdEHq [Occ=Once] ->
              case eta2_sdEHk of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right y_sdEHt [Occ=Once] -> eta_sdEHi ds_sdEHq y_sdEHt;
              };
        };

Data.Functor.Classes.$fOrd1Either1
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdEHu eta_sdEHv eta1_sdEHw eta2_sdEHx]
        case eta1_sdEHw of {
          Data.Either.Left x_sdEHz [Occ=Once] ->
              case eta2_sdEHx of {
                Data.Either.Left y_sdEHB [Occ=Once] ->
                    case GHC.Classes.$p1Ord $dOrd_sdEHu of sat_sdEHC {
                      __DEFAULT -> GHC.Classes.== sat_sdEHC x_sdEHz y_sdEHB;
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds_sdEHE [Occ=Once] ->
              case eta2_sdEHx of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdEHH [Occ=Once] -> eta_sdEHv ds_sdEHE y_sdEHH;
              };
        };

Data.Functor.Classes.$fOrd1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Classes.Ord1 (Data.Either.Either a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdEHI]
        let {
          sat_sdEHK [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Either.Either a_Xdx16 a
               -> Data.Either.Either a_Xdx16 b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdEHI] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Either_$cliftCompare
                      $dOrd_sdEHI eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdEHJ [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Either.Either a_Xdx16)
          [LclId] =
              [$dOrd_sdEHI] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Either1
                      $dOrd_sdEHI eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdEHJ sat_sdEHK];

Data.Functor.Classes.$fOrd2Const_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> Data.Functor.Const.Const a c
     -> Data.Functor.Const.Const b d
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [comp_sdEHL ds_sdEHM ds1_sdEHN ds2_sdEHO]
        comp_sdEHL ds1_sdEHN ds2_sdEHO;

Data.Functor.Classes.$fOrd2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 Data.Functor.Const.Const
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2Const_$cliftEq2
                                                Data.Functor.Classes.$fOrd2Const_$cliftCompare2];

Data.Functor.Classes.$fOrd1Const1
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a a1
     -> Data.Functor.Const.Const a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdEHP eta_sdEHQ eta1_sdEHR eta2_sdEHS]
        case GHC.Classes.$p1Ord $dOrd_sdEHP of sat_sdEHT {
          __DEFAULT -> GHC.Classes.== sat_sdEHT eta1_sdEHR eta2_sdEHS;
        };

Data.Functor.Classes.$fOrd1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Classes.Ord1 (Data.Functor.Const.Const a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdEHU]
        let {
          sat_sdEHZ [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Const.Const a_Xdx0D a
               -> Data.Functor.Const.Const a_Xdx0D b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdEHU] \r [eta_sdEHW eta1_sdEHX eta2_sdEHY]
                  GHC.Classes.compare $dOrd_sdEHU eta1_sdEHX eta2_sdEHY; } in
        let {
          sat_sdEHV [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a_Xdx0D)
          [LclId] =
              [$dOrd_sdEHU] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Const1 $dOrd_sdEHU eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdEHV sat_sdEHZ];

Data.Functor.Classes.$fRead1(,)5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ","#;

Data.Functor.Classes.$fRead1(,)4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1(,)5;

Data.Functor.Classes.$fRead1(,)3 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Functor.Classes.$fRead1(,)4];

Data.Functor.Classes.$w$cliftReadPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a, b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEI0 w1_sdEI1 w2_sdEI2 w3_sdEI3]
        let {
          p_sdEI4 [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b2.
                  ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b2)
                  -> Text.ParserCombinators.ReadP.P b2
          [LclId, Arity=2, Str=<L,U><L,C(U)>, Unf=OtherCon []] =
              [w_sdEI0 w1_sdEI1] \r [n_sdEI5 k1_sdEI6]
                  let {
                    sat_sdEIf [Occ=Once]
                      :: a_sdxYe -> Text.ParserCombinators.ReadP.P b2_i88WH
                    [LclId] =
                        [w1_sdEI1 n_sdEI5 k1_sdEI6] \r [a1_sdEI7]
                            let {
                              sat_sdEIc [Occ=Once]
                                :: () -> Text.ParserCombinators.ReadP.P b2_i88WH
                              [LclId] =
                                  [w1_sdEI1 n_sdEI5 k1_sdEI6 a1_sdEI7] \r [a2_sdEI8]
                                      let {
                                        sat_sdEIb [Occ=Once]
                                          :: b_sdxYf -> Text.ParserCombinators.ReadP.P b2_i88WH
                                        [LclId] =
                                            [k1_sdEI6 a1_sdEI7] \r [a3_sdEI9]
                                                let {
                                                  sat_sdEIa [Occ=Once] :: (a_sdxYe, b_sdxYf)
                                                  [LclId] =
                                                      CCCS (,)! [a1_sdEI7 a3_sdEI9];
                                                } in  k1_sdEI6 sat_sdEIa;
                                      } in  w1_sdEI1 n_sdEI5 sat_sdEIb;
                            } in 
                              case
                                  Text.Read.Lex.$wexpect Data.Functor.Classes.$fRead1(,)3 sat_sdEIc
                              of
                              { Unit# ww1_sdEIe [Occ=Once] ->
                                    Text.ParserCombinators.ReadP.Look [ww1_sdEIe];
                              };
                  } in  w_sdEI0 n_sdEI5 sat_sdEIf; } in
        let {
          lvl3_sdEIg [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b2.
                  ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b2)
                  -> Text.ParserCombinators.ReadP.P b2
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [p_sdEI4] \r [w4_sdEIh w5_sdEIi]
                  case GHC.Read.$wparen' p_sdEI4 w4_sdEIh w5_sdEIi of {
                    Unit# ww1_sdEIk [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Get [ww1_sdEIk];
                  }; } in
        let {
          sat_sdEIp [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_sdxYe, b_sdxYf)
          [LclId] =
              [lvl3_sdEIg] \r [eta_sdEIl eta1_sdEIm]
                  case
                      GHC.Read.$wskipSpacesThenP lvl3_sdEIg eta_sdEIl eta1_sdEIm
                  of
                  { Unit# ww1_sdEIo [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdEIo];
                  };
        } in  GHC.Read.list3 sat_sdEIp w2_sdEI2 w3_sdEI3;

Data.Functor.Classes.$fRead1(,)2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a, b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEIq w1_sdEIr w2_sdEIs w3_sdEIt w4_sdEIu w5_sdEIv]
        Data.Functor.Classes.$w$cliftReadPrec2
            w_sdEIq w2_sdEIs w4_sdEIu w5_sdEIv;

Data.Functor.Classes.$w$cliftReadsPrec6 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, b)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEIw w1_sdEIx w2_sdEIy]
        let {
          sat_sdEIB [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (a_sdxYo, b_sdxYp)
          [LclId] =
              [w_sdEIw w1_sdEIx w2_sdEIy] \u []
                  let {
                    sat_sdEIA [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_sdxYp
                    [LclId] =
                        [w1_sdEIx] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdEIx eta_B1; } in
                  let {
                    sat_sdEIz [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdxYo
                    [LclId] =
                        [w_sdEIw] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdEIw eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec2
                        sat_sdEIz
                        sat_sdEIA
                        w2_sdEIy
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEIB;

Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, b)
[GblId,
 Arity=5,
 Str=<L,C(C(U))><L,A><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEIC w1_sdEID w2_sdEIE w3_sdEIF w4_sdEIG]
        Data.Functor.Classes.$w$cliftReadsPrec6 w_sdEIC w2_sdEIE w4_sdEIG;

Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [(a, b)]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdEIH rl1_sdEII rp2_sdEIJ rl2_sdEIK]
        let {
          sat_sdEIN [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_adwW8, b_adwW9)
          [LclId] =
              [rp1_sdEIH rp2_sdEIJ] \r [w_sdEIL w1_sdEIM]
                  Data.Functor.Classes.$w$cliftReadPrec2
                      rp1_sdEIH rp2_sdEIJ w_sdEIL w1_sdEIM;
        } in  GHC.Read.list sat_sdEIN;

Data.Functor.Classes.$fShow1(,)3 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['('#];

Data.Functor.Classes.$fRead1Identity5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Classes.$fShow1(,)2 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [','#];

Data.Functor.Classes.$fShow1(,)1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [')'#];

Data.Functor.Classes.$w$cliftShowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEIO w1_sdEIP ww_sdEIQ ww1_sdEIR]
        let {
          f_sdEIS [Occ=OnceL!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEIO ww_sdEIQ] \u []
                  w_sdEIO Data.Functor.Classes.$fRead1Identity5 ww_sdEIQ; } in
        let {
          f1_sdEIT [Occ=OnceL!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdEIP ww1_sdEIR] \u []
                  w1_sdEIP Data.Functor.Classes.$fRead1Identity5 ww1_sdEIR; } in
        let {
          sat_sdEIZ [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
          [LclId] =
              [f_sdEIS f1_sdEIT] \r [x_sdEIU]
                  let {
                    sat_sdEIY [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [f_sdEIS f1_sdEIT x_sdEIU] \u []
                            let {
                              sat_sdEIW [Occ=Once] :: [GHC.Types.Char]
                              [LclId] =
                                  [f1_sdEIT x_sdEIU] \u []
                                      let {
                                        sat_sdEIV [Occ=Once] :: GHC.Base.String
                                        [LclId] =
                                            CCCS :! [Data.Functor.Classes.$fShow1(,)1 x_sdEIU];
                                      } in  f1_sdEIT sat_sdEIV; } in
                            let {
                              sat_sdEIX [Occ=Once] :: GHC.Base.String
                              [LclId] =
                                  CCCS :! [Data.Functor.Classes.$fShow1(,)2 sat_sdEIW];
                            } in  f_sdEIS sat_sdEIX;
                  } in  : [Data.Functor.Classes.$fShow1(,)3 sat_sdEIY];
        } in  sat_sdEIZ;

Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> (a, b)
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*C1(C1(C(U)))><L,A><L,A><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEJ0 w1_sdEJ1 w2_sdEJ2 w3_sdEJ3 w4_sdEJ4 w5_sdEJ5]
        case w5_sdEJ5 of {
          (,) ww1_sdEJ7 [Occ=Once] ww2_sdEJ8 [Occ=Once] ->
              Data.Functor.Classes.$w$cliftShowsPrec2
                  w_sdEJ0 w2_sdEJ2 ww1_sdEJ7 ww2_sdEJ8;
        };

Data.Functor.Classes.$dmliftShowList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [f a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(C(C1(U))))))),A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow2_sdEJ9 sp1_sdEJa sl1_sdEJb sp2_sdEJc sl2_sdEJd]
        let {
          sat_sdEJe [Occ=Once] :: f_adw99 a_adwOU b_adwOV -> GHC.Show.ShowS
          [LclId] =
              [$dShow2_sdEJ9 sp1_sdEJa sl1_sdEJb sp2_sdEJc sl2_sdEJd] \u []
                  Data.Functor.Classes.liftShowsPrec2
                      $dShow2_sdEJ9
                      sp1_sdEJa
                      sl1_sdEJb
                      sp2_sdEJc
                      sl2_sdEJd
                      Data.Functor.Classes.$fRead1Identity5;
        } in  GHC.Show.showList__ sat_sdEJe;

Data.Functor.Classes.$w$cliftShowList3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> [(a, b)]
     -> GHC.Base.String
     -> GHC.Base.String
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEJf w1_sdEJg w2_sdEJh w3_sdEJi]
        let {
          sat_sdEJs [Occ=Once] :: (a_sdxYK, b_sdxYL) -> GHC.Show.ShowS
          [LclId] =
              [w_sdEJf w1_sdEJg] \r [ds_sdEJj eta_sdEJk]
                  case ds_sdEJj of {
                    (,) x_sdEJm [Occ=Once] y_sdEJn [Occ=Once] ->
                        let {
                          sat_sdEJr [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_sdEJf w1_sdEJg eta_sdEJk x_sdEJm y_sdEJn] \u []
                                  let {
                                    sat_sdEJp [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w1_sdEJg eta_sdEJk y_sdEJn] \u []
                                            let {
                                              sat_sdEJo [Occ=Once] :: GHC.Base.String
                                              [LclId] =
                                                  CCCS :! [Data.Functor.Classes.$fShow1(,)1
                                                           eta_sdEJk];
                                            } in 
                                              w1_sdEJg
                                                  Data.Functor.Classes.$fRead1Identity5
                                                  y_sdEJn
                                                  sat_sdEJo; } in
                                  let {
                                    sat_sdEJq [Occ=Once] :: GHC.Base.String
                                    [LclId] =
                                        CCCS :! [Data.Functor.Classes.$fShow1(,)2 sat_sdEJp];
                                  } in 
                                    w_sdEJf Data.Functor.Classes.$fRead1Identity5 x_sdEJm sat_sdEJq;
                        } in  : [Data.Functor.Classes.$fShow1(,)3 sat_sdEJr];
                  };
        } in  GHC.Show.showList__ sat_sdEJs w2_sdEJh w3_sdEJi;

Data.Functor.Classes.$fShow2(,)_$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [(a, b)]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,A><L,C(C1(C1(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEJt w1_sdEJu w2_sdEJv w3_sdEJw w4_sdEJx w5_sdEJy]
        Data.Functor.Classes.$w$cliftShowList3
            w_sdEJt w2_sdEJv w4_sdEJx w5_sdEJy;

Data.Functor.Classes.$fShow2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2(,)_$cliftShowList2];

Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> (a, a1)
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><L,A><L,A><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdEJz eta_sdEJA eta1_sdEJB eta2_sdEJC eta3_sdEJD]
        case eta3_sdEJD of {
          (,) ww1_sdEJF [Occ=Once] ww2_sdEJG [Occ=Once] ->
              let {
                sat_sdEJH [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_adwQx -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sdEJz] \s [] GHC.Show.showsPrec $dShow_sdEJz;
              } in 
                Data.Functor.Classes.$w$cliftShowsPrec2
                    sat_sdEJH eta_sdEJA ww1_sdEJF ww2_sdEJG;
        };

$w$dmliftReadListPrec2_rdymu
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadP.ReadP [f a b]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdEJI w1_sdEJJ w2_sdEJK w3_sdEJL w4_sdEJM]
        let {
          w5_sdEJN [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [f_sdxYT a_sdxYV b_sdxYW]
          [LclId] =
              [w_sdEJI w1_sdEJJ w2_sdEJK w3_sdEJL w4_sdEJM] \u []
                  let {
                    sat_sdEJS [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [b_sdxYW]
                    [LclId] =
                        [w4_sdEJM] \u []
                            w4_sdEJM
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEJT [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [b_sdxYW]
                    [LclId] =
                        [sat_sdEJS] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEJS eta_B1; } in
                  let {
                    sat_sdEJR [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_sdxYW
                    [LclId] =
                        [w3_sdEJL] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w3_sdEJL eta_B1; } in
                  let {
                    sat_sdEJP [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxYV]
                    [LclId] =
                        [w2_sdEJK] \u []
                            w2_sdEJK
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEJQ [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxYV]
                    [LclId] =
                        [sat_sdEJP] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEJP eta_B1; } in
                  let {
                    sat_sdEJO [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxYV
                    [LclId] =
                        [w1_sdEJJ] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w1_sdEJJ eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadList2
                        w_sdEJI sat_sdEJO sat_sdEJQ sat_sdEJR sat_sdEJT; } in
        let {
          sat_sdEJX [Occ=Once]
            :: forall b1.
               ([f_sdxYT a_sdxYV b_sdxYW] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [w5_sdEJN] \r [w6_sdEJU]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w5_sdEJN w6_sdEJU
                  of
                  { Unit# ww1_sdEJW [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdEJW];
                  };
        } in  sat_sdEJX;

$dmliftReadListPrec1_rdymv
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [f a b]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdEJY
                    w1_sdEJZ
                    w2_sdEK0
                    w3_sdEK1
                    w4_sdEK2
                    w5_sdEK3]
        $w$dmliftReadListPrec2_rdymu
            w_sdEJY w1_sdEJZ w2_sdEK0 w3_sdEK1 w4_sdEK2;

Data.Functor.Classes.$dmliftReadListPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        $dmliftReadListPrec1_rdymv
            eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$dmliftReadPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(C(U)))))),A,A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEK4 rp1_sdEK5 rl1_sdEK6 rp2_sdEK7 rl2_sdEK8]
        let {
          f1_sdEK9 [Occ=OnceL!, Dmd=<L,C(C(U))>]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdwdU a_adwOl b_adwOm)
          [LclId] =
              [$dRead2_sdEK4 rp1_sdEK5 rl1_sdEK6 rp2_sdEK7 rl2_sdEK8] \u []
                  let {
                    sat_sdEKe [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [b_adwOm]
                    [LclId] =
                        [rl2_sdEK8] \u []
                            rl2_sdEK8
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEKf [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [b_adwOm]
                    [LclId] =
                        [sat_sdEKe] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEKe eta_B1; } in
                  let {
                    sat_sdEKd [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_adwOm
                    [LclId] =
                        [rp2_sdEK7] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S
                                rp2_sdEK7 eta_B1; } in
                  let {
                    sat_sdEKb [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adwOl]
                    [LclId] =
                        [rl1_sdEK6] \u []
                            rl1_sdEK6
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEKc [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adwOl]
                    [LclId] =
                        [sat_sdEKb] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEKb eta_B1; } in
                  let {
                    sat_sdEKa [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwOl
                    [LclId] =
                        [rp1_sdEK5] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S rp1_sdEK5 eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadsPrec2
                        $dRead2_sdEK4 sat_sdEKa sat_sdEKc sat_sdEKd sat_sdEKf; } in
        let {
          sat_sdEKm [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (f_XdwdU a_adwOl b_adwOm -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [f1_sdEK9] \r [n_sdEKg]
                  let {
                    w_sdEKh [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS (f_XdwdU a_adwOl b_adwOm)
                    [LclId] =
                        [f1_sdEK9 n_sdEKg] \u [] f1_sdEK9 n_sdEKg; } in
                  let {
                    sat_sdEKl [Occ=OnceT[0]]
                      :: forall b1.
                         (f_XdwdU a_adwOl b_adwOm -> Text.ParserCombinators.ReadP.P b1)
                         -> Text.ParserCombinators.ReadP.P b1
                    [LclId] =
                        [w_sdEKh] \r [w1_sdEKi]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdEKh w1_sdEKi
                            of
                            { Unit# ww1_sdEKk [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEKk];
                            };
                  } in  sat_sdEKl;
        } in  sat_sdEKm;

Data.Functor.Classes.$dmliftReadList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C1(C(U)))))),A)><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEKn rp1_sdEKo rl1_sdEKp rp2_sdEKq rl2_sdEKr]
        let {
          sat_sdEKF [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_XdwdV a_adwNZ b_adwO0]
          [LclId] =
              [$dRead2_sdEKn rp1_sdEKo rl1_sdEKp rp2_sdEKq rl2_sdEKr] \u []
                  let {
                    sat_sdEKE [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (f_XdwdV a_adwNZ b_adwO0)
                    [LclId] =
                        [$dRead2_sdEKn rp1_sdEKo rl1_sdEKp rp2_sdEKq rl2_sdEKr] \s []
                            let {
                              sat_sdEKD [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwO0]
                              [LclId] =
                                  [rl2_sdEKr] \r [n_sdEKz w1_sdEKA]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl2_sdEKr w1_sdEKA
                                      of
                                      { Unit# ww1_sdEKC [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdEKC];
                                      }; } in
                            let {
                              sat_sdEKy [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwO0
                              [LclId] =
                                  [rp2_sdEKq] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp2_sdEKq eta_B1; } in
                            let {
                              sat_sdEKx [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwNZ]
                              [LclId] =
                                  [rl1_sdEKp] \r [n_sdEKt w1_sdEKu]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl1_sdEKp w1_sdEKu
                                      of
                                      { Unit# ww1_sdEKw [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdEKw];
                                      }; } in
                            let {
                              sat_sdEKs [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwNZ
                              [LclId] =
                                  [rp1_sdEKo] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp1_sdEKo eta_B1;
                            } in 
                              Data.Functor.Classes.liftReadPrec2
                                  $dRead2_sdEKn sat_sdEKs sat_sdEKx sat_sdEKy sat_sdEKD;
                  } in 
                    GHC.Read.list
                        sat_sdEKE
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEKF;

Data.Functor.Classes.$dmliftReadsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C(C1(U)))))),A)><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEKG rp1_sdEKH rl1_sdEKI rp2_sdEKJ rl2_sdEKK]
        let {
          ds_sdEKL [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_XdwdW a_adwNE b_adwNF)
          [LclId] =
              [$dRead2_sdEKG rp1_sdEKH rl1_sdEKI rp2_sdEKJ rl2_sdEKK] \u []
                  let {
                    sat_sdEKX [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwNF]
                    [LclId] =
                        [rl2_sdEKK] \r [n_sdEKT w1_sdEKU]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl2_sdEKK w1_sdEKU
                            of
                            { Unit# ww1_sdEKW [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEKW];
                            }; } in
                  let {
                    sat_sdEKS [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwNF
                    [LclId] =
                        [rp2_sdEKJ] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                rp2_sdEKJ eta_B1; } in
                  let {
                    sat_sdEKR [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwNE]
                    [LclId] =
                        [rl1_sdEKI] \r [n_sdEKN w1_sdEKO]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl1_sdEKI w1_sdEKO
                            of
                            { Unit# ww1_sdEKQ [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEKQ];
                            }; } in
                  let {
                    sat_sdEKM [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwNE
                    [LclId] =
                        [rp1_sdEKH] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp1_sdEKH eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadPrec2
                        $dRead2_sdEKG sat_sdEKM sat_sdEKR sat_sdEKS sat_sdEKX; } in
        let {
          sat_sdEL0 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdwdW a_adwNE b_adwNF)
          [LclId] =
              [ds_sdEKL] \r [n_sdEKY]
                  let {
                    sat_sdEKZ [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (f_XdwdW a_adwNE b_adwNF)
                    [LclId] =
                        [ds_sdEKL n_sdEKY] \u []
                            ds_sdEKL
                                n_sdEKY Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sdEKZ;
        } in  sat_sdEL0;

Data.Functor.Classes.$dmliftShowList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C(C1(U))))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sdEL1 sp_sdEL2 sl_sdEL3]
        let {
          sat_sdEL4 [Occ=Once] :: f_adw9R a_adwNq -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdEL1 sp_sdEL2 sl_sdEL3] \u []
                  Data.Functor.Classes.liftShowsPrec
                      $dShow1_sdEL1
                      sp_sdEL2
                      sl_sdEL3
                      Data.Functor.Classes.$fRead1Identity5;
        } in  GHC.Show.showList__ sat_sdEL4;

Data.Functor.Classes.$w$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> [(a, a1)] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEL5 w1_sdEL6 w2_sdEL7 w3_sdEL8]
        let {
          lvl3_sdEL9 [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_sdxZ3 -> GHC.Show.ShowS
          [LclId] =
              [w_sdEL5] \u [] GHC.Show.showsPrec w_sdEL5; } in
        let {
          sat_sdELe [Occ=Once] :: (a_sdxZ3, a1_sdxZ5) -> GHC.Show.ShowS
          [LclId] =
              [w1_sdEL6 lvl3_sdEL9] \r [eta_sdELa]
                  case eta_sdELa of {
                    (,) ww1_sdELc [Occ=Once] ww2_sdELd [Occ=Once] ->
                        Data.Functor.Classes.$w$cliftShowsPrec2
                            lvl3_sdEL9 w1_sdEL6 ww1_sdELc ww2_sdELd;
                  };
        } in  GHC.Show.showList__ sat_sdELe w2_sdEL7 w3_sdEL8;

Data.Functor.Classes.$fShow1(,)_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS) -> [(a, a1)] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdELf w1_sdELg w2_sdELh w3_sdELi w4_sdELj]
        Data.Functor.Classes.$w$cliftShowList
            w_sdELf w1_sdELg w3_sdELi w4_sdELj;

Data.Functor.Classes.$fShow1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => Data.Functor.Classes.Show1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdELk]
        let {
          sat_sdELq [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS) -> [(a_adwQx, a)] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdELk] \r [w_sdELm w1_sdELn w2_sdELo w3_sdELp]
                  Data.Functor.Classes.$w$cliftShowList
                      $dShow_sdELk w_sdELm w2_sdELo w3_sdELp; } in
        let {
          sat_sdELl [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> (a_adwQx, a)
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdELk] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
                      $dShow_sdELk eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdELl sat_sdELq];

Data.Functor.Classes.$fShow1Proxy1
  :: forall a.
     Data.Proxy.Proxy a -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sdELr eta_B1] Data.Functor.Classes.$fShow1Proxy2 eta_B1;

Data.Functor.Classes.$fShow1Proxy_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Proxy.Proxy a]
     -> GHC.Show.ShowS
[GblId, Arity=4, Str=<L,A><L,A><S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [sp_sdELs sl_sdELt eta_sdELu eta1_sdELv]
        GHC.Show.showList__
            Data.Functor.Classes.$fShow1Proxy1 eta_sdELu eta1_sdELv;

Data.Functor.Classes.$fShow1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Proxy_$cliftShowList];

Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [GHC.Base.NonEmpty a]
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C(U)))><L,C(C(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdELw sl_sdELx eta_sdELy eta1_sdELz]
        let {
          sat_sdELE [Occ=Once] :: GHC.Base.NonEmpty a_adx0n -> GHC.Show.ShowS
          [LclId] =
              [sp_sdELw sl_sdELx] \r [w_sdELA]
                  case w_sdELA of {
                    GHC.Base.:| ww1_sdELC [Occ=Once] ww2_sdELD [Occ=Once] ->
                        Data.Functor.Classes.$w$cliftShowsPrec1
                            sp_sdELw sl_sdELx 0# ww1_sdELC ww2_sdELD;
                  };
        } in  GHC.Show.showList__ sat_sdELE eta_sdELy eta1_sdELz;

Data.Functor.Classes.$fShow1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList];

Data.Functor.Classes.$fShow1[]_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [[a]] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [sp_sdELF sl_sdELG eta_B2 eta_B1]
        GHC.Show.showList__ sl_sdELG eta_B2 eta_B1;

Data.Functor.Classes.$fShow1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1[]_$cliftShowList];

$w$dmliftReadListPrec_rdymw
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadP.ReadP [f a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdELH w1_sdELI w2_sdELJ]
        let {
          w3_sdELK [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [f_sdxZb a_sdxZd]
          [LclId] =
              [w_sdELH w1_sdELI w2_sdELJ] \u []
                  let {
                    sat_sdELM [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxZd]
                    [LclId] =
                        [w2_sdELJ] \u []
                            w2_sdELJ
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdELN [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxZd]
                    [LclId] =
                        [sat_sdELM] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdELM eta_B1; } in
                  let {
                    sat_sdELL [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxZd
                    [LclId] =
                        [w1_sdELI] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w1_sdELI eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadList w_sdELH sat_sdELL sat_sdELN; } in
        let {
          sat_sdELR [Occ=Once]
            :: forall b.
               ([f_sdxZb a_sdxZd] -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w3_sdELK] \r [w4_sdELO]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w3_sdELK w4_sdELO
                  of
                  { Unit# ww1_sdELQ [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdELQ];
                  };
        } in  sat_sdELR;

$dmliftReadListPrec3_rdymx
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [f a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdELS w1_sdELT w2_sdELU w3_sdELV]
        $w$dmliftReadListPrec_rdymw w_sdELS w1_sdELT w2_sdELU;

Data.Functor.Classes.$dmliftReadListPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        $dmliftReadListPrec3_rdymx eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$dmliftReadPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(C(U)))),A,A,A)><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdELW rp_sdELX rl_sdELY]
        let {
          f1_sdELZ [Occ=OnceL!, Dmd=<L,C(C(U))>]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdweR a_adwMZ)
          [LclId] =
              [$dRead1_sdELW rp_sdELX rl_sdELY] \u []
                  let {
                    sat_sdEM1 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adwMZ]
                    [LclId] =
                        [rl_sdELY] \u []
                            rl_sdELY
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEM2 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adwMZ]
                    [LclId] =
                        [sat_sdEM1] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEM1 eta_B1; } in
                  let {
                    sat_sdEM0 [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwMZ
                    [LclId] =
                        [rp_sdELX] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S rp_sdELX eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdELW sat_sdEM0 sat_sdEM2; } in
        let {
          sat_sdEM9 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [f1_sdELZ] \r [n_sdEM3]
                  let {
                    w_sdEM4 [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS (f_XdweR a_adwMZ)
                    [LclId] =
                        [f1_sdELZ n_sdEM3] \u [] f1_sdELZ n_sdEM3; } in
                  let {
                    sat_sdEM8 [Occ=OnceT[0]]
                      :: forall b.
                         (f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b)
                         -> Text.ParserCombinators.ReadP.P b
                    [LclId] =
                        [w_sdEM4] \r [w1_sdEM5]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdEM4 w1_sdEM5
                            of
                            { Unit# ww1_sdEM7 [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEM7];
                            };
                  } in  sat_sdEM8;
        } in  sat_sdEM9;

Data.Functor.Classes.$dmliftReadList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C1(C(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdEMa rp_sdEMb rl_sdEMc]
        let {
          sat_sdEMk [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_XdweS a_adwMJ]
          [LclId] =
              [$dRead1_sdEMa rp_sdEMb rl_sdEMc] \u []
                  let {
                    sat_sdEMj [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec (f_XdweS a_adwMJ)
                    [LclId] =
                        [$dRead1_sdEMa rp_sdEMb rl_sdEMc] \s []
                            let {
                              sat_sdEMi [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwMJ]
                              [LclId] =
                                  [rl_sdEMc] \r [n_sdEMe w1_sdEMf]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl_sdEMc w1_sdEMf
                                      of
                                      { Unit# ww1_sdEMh [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdEMh];
                                      }; } in
                            let {
                              sat_sdEMd [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwMJ
                              [LclId] =
                                  [rp_sdEMb] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp_sdEMb eta_B1;
                            } in 
                              Data.Functor.Classes.liftReadPrec
                                  $dRead1_sdEMa sat_sdEMd sat_sdEMi;
                  } in 
                    GHC.Read.list
                        sat_sdEMj
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEMk;

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [rp_sdEMl rl_sdEMm]
        let {
          f_sdEMn [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adx31
          [LclId, Arity=1, Unf=OtherCon []] =
              [rp_sdEMl] \r [eta_B1]
                  Text.ParserCombinators.ReadPrec.readPrec_to_S rp_sdEMl eta_B1; } in
        let {
          f1_sdEMo [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adx31]
          [LclId] =
              [rl_sdEMm] \u []
                  rl_sdEMm
                      Data.Functor.Classes.$fRead1Identity5
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          f2_sdEMp [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [a_adx31]
          [LclId, Arity=1, Unf=OtherCon []] =
              [f1_sdEMo] \r [eta_B1]
                  Text.ParserCombinators.ReadP.run f1_sdEMo eta_B1; } in
        let {
          sat_sdEMy [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (GHC.Base.NonEmpty a_adx31 -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [f_sdEMn f2_sdEMp] \r [n_sdEMq eta_sdEMr]
                  let {
                    sat_sdEMv [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_adx31)
                    [LclId] =
                        [f_sdEMn f2_sdEMp n_sdEMq] \r [w_sdEMs]
                            case n_sdEMq of {
                              GHC.Types.I# ww1_sdEMu [Occ=Once] ->
                                  Data.Functor.Classes.$w$cliftReadsPrec5
                                      f_sdEMn f2_sdEMp ww1_sdEMu w_sdEMs;
                            };
                  } in 
                    case
                        Text.ParserCombinators.ReadP.$wreadS_to_P sat_sdEMv eta_sdEMr
                    of
                    { Unit# ww1_sdEMx [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Look [ww1_sdEMx];
                    };
        } in  sat_sdEMy;

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.NonEmpty a]
[GblId, Arity=2, Str=<L,C(C(U))><L,C(U)>, Unf=OtherCon []] =
    [] \r [rp_sdEMz rl_sdEMA]
        let {
          sat_sdEMU [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [GHC.Base.NonEmpty a_adx2T]
          [LclId] =
              [rp_sdEMz rl_sdEMA] \u []
                  let {
                    f_sdEMB [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adx2T
                    [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                        [rp_sdEMz] \r [n_sdEMC]
                            let {
                              sat_sdEMG [Occ=Once] :: Text.ParserCombinators.ReadP.P a_adx2T
                              [LclId] =
                                  [rp_sdEMz n_sdEMC] \u []
                                      let {
                                        sat_sdEMD [Occ=Once, Dmd=<L,C(U)>]
                                          :: Text.ParserCombinators.ReadP.ReadS a_adx2T
                                        [LclId] =
                                            [rp_sdEMz n_sdEMC] \u [] rp_sdEMz n_sdEMC;
                                      } in 
                                        case
                                            Text.ParserCombinators.ReadP.$wreadS_to_P
                                                sat_sdEMD
                                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                        of
                                        { Unit# ww1_sdEMF [Occ=Once] ->
                                              Text.ParserCombinators.ReadP.Look [ww1_sdEMF];
                                        };
                            } in  Text.ParserCombinators.ReadP.run sat_sdEMG; } in
                  let {
                    f1_sdEMH [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adx2T]
                    [LclId] =
                        [rl_sdEMA] \u []
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P
                                    rl_sdEMA Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                            of
                            { Unit# ww1_sdEMJ [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEMJ];
                            }; } in
                  let {
                    f2_sdEMK [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adx2T]
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [f1_sdEMH] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run f1_sdEMH eta_B1; } in
                  let {
                    sat_sdEMT [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.NonEmpty a_adx2T)
                    [LclId] =
                        [f_sdEMB f2_sdEMK] \r [n_sdEML eta_sdEMM]
                            let {
                              sat_sdEMQ [Occ=Once]
                                :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_adx2T)
                              [LclId] =
                                  [f_sdEMB f2_sdEMK n_sdEML] \r [w_sdEMN]
                                      case n_sdEML of {
                                        GHC.Types.I# ww1_sdEMP [Occ=Once] ->
                                            Data.Functor.Classes.$w$cliftReadsPrec5
                                                f_sdEMB f2_sdEMK ww1_sdEMP w_sdEMN;
                                      };
                            } in 
                              case
                                  Text.ParserCombinators.ReadP.$wreadS_to_P sat_sdEMQ eta_sdEMM
                              of
                              { Unit# ww1_sdEMS [Occ=Once] ->
                                    Text.ParserCombinators.ReadP.Look [ww1_sdEMS];
                              };
                  } in 
                    GHC.Read.list
                        sat_sdEMT
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEMU;

Data.Functor.Classes.$w$cliftReadListPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> forall b.
        ([GHC.Base.NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [w_sdEMV w1_sdEMW]
        let {
          w2_sdEMX [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [GHC.Base.NonEmpty a_sdxZp]
          [LclId] =
              [w_sdEMV w1_sdEMW] \u []
                  let {
                    sat_sdEMZ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxZp]
                    [LclId] =
                        [w1_sdEMW] \u []
                            w1_sdEMW
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEN0 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxZp]
                    [LclId] =
                        [sat_sdEMZ] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEMZ eta_B1; } in
                  let {
                    sat_sdEMY [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxZp
                    [LclId] =
                        [w_sdEMV] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w_sdEMV eta_B1;
                  } in 
                    Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
                        sat_sdEMY sat_sdEN0; } in
        let {
          sat_sdEN4 [Occ=OnceT[0]]
            :: forall b.
               ([GHC.Base.NonEmpty a_sdxZp] -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w2_sdEMX] \r [w3_sdEN1]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w2_sdEMX w3_sdEN1
                  of
                  { Unit# ww1_sdEN3 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdEN3];
                  };
        } in  sat_sdEN4;

Data.Functor.Classes.$fRead1NonEmpty1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([GHC.Base.NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdEN5 w1_sdEN6 w2_sdEN7]
        Data.Functor.Classes.$w$cliftReadListPrec2 w_sdEN5 w1_sdEN6;

Data.Functor.Classes.$fRead1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
                                                 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
                                                 Data.Functor.Classes.$fRead1NonEmpty1];

Data.Functor.Classes.$dmliftReadsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdEN8 rp_sdEN9 rl_sdENa]
        let {
          ds_sdENb [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_XdweY a_adwMu)
          [LclId] =
              [$dRead1_sdEN8 rp_sdEN9 rl_sdENa] \u []
                  let {
                    sat_sdENh [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwMu]
                    [LclId] =
                        [rl_sdENa] \r [n_sdENd w1_sdENe]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sdENa w1_sdENe
                            of
                            { Unit# ww1_sdENg [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdENg];
                            }; } in
                  let {
                    sat_sdENc [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwMu
                    [LclId] =
                        [rp_sdEN9] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sdEN9 eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadPrec
                        $dRead1_sdEN8 sat_sdENc sat_sdENh; } in
        let {
          sat_sdENk [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdweY a_adwMu)
          [LclId] =
              [ds_sdENb] \r [n_sdENi]
                  let {
                    sat_sdENj [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (f_XdweY a_adwMu)
                    [LclId] =
                        [ds_sdENb n_sdENi] \u []
                            ds_sdENb
                                n_sdENi Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sdENj;
        } in  sat_sdENk;

Data.Functor.Classes.eq1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) =>
     f a -> f a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sdENl $dEq_sdENm]
        let {
          sat_sdENn [Occ=Once] :: a_adwMf -> a_adwMf -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdENm] \u [] GHC.Classes.== $dEq_sdENm;
        } in  $dEq1_sdENl sat_sdENn;

Data.Functor.Classes.compare1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) =>
     f a -> f a -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)),1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sdENo $dOrd_sdENp]
        let {
          sat_sdENq [Occ=Once] :: a_adwM3 -> a_adwM3 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdENp] \u [] GHC.Classes.compare $dOrd_sdENp;
        } in  Data.Functor.Classes.liftCompare $dOrd1_sdENo sat_sdENq;

Data.Functor.Classes.readsPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLL),1*U(1*C1(C1(U)),A,A,A)><L,U(1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdENr $dRead_sdENs]
        let {
          sat_sdENu [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [a_adwLh]
          [LclId] =
              [$dRead_sdENs] \u [] GHC.Read.readList $dRead_sdENs; } in
        let {
          sat_sdENt [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLh
          [LclId] =
              [$dRead_sdENs] \u [] GHC.Read.readsPrec $dRead_sdENs;
        } in 
          Data.Functor.Classes.liftReadsPrec
              $dRead1_sdENr sat_sdENt sat_sdENu;

Data.Functor.Classes.readsUnary1
  :: forall (f :: * -> *) a t.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     GHC.Base.String
     -> (f a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdENv
           $dRead_sdENw
           name_sdENx
           cons_sdENy
           kw_sdENz
           s_sdENA]
        case GHC.Base.eqString kw_sdENz name_sdENx of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdENC [Occ=LoopBreaker]
                  :: [(f_adwLt a_adwLu, GHC.Base.String)]
                     -> [(t_adwLv, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdENy go_sdENC] \r [ds_sdEND]
                        case ds_sdEND of {
                          [] -> [] [];
                          : y_sdENF [Occ=Once!] ys_sdENG [Occ=Once] ->
                              case y_sdENF of {
                                (,) x_sdENI [Occ=Once] t1_sdENJ [Occ=Once] ->
                                    let {
                                      sat_sdENM [Occ=Once] :: [(t_adwLv, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdENC ys_sdENG] \u [] go_sdENC ys_sdENG; } in
                                    let {
                                      sat_sdENK [Occ=Once] :: t_adwLv
                                      [LclId] =
                                          [cons_sdENy x_sdENI] \u [] cons_sdENy x_sdENI; } in
                                    let {
                                      sat_sdENL [Occ=Once] :: (t_adwLv, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdENK t1_sdENJ];
                                    } in  : [sat_sdENL sat_sdENM];
                              };
                        }; } in
              let {
                sat_sdENO [Occ=Once]
                  :: Text.ParserCombinators.ReadP.ReadS [a_adwLu]
                [LclId] =
                    [$dRead_sdENw] \u [] GHC.Read.readList $dRead_sdENw; } in
              let {
                sat_sdENN [Occ=Once]
                  :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLu
                [LclId] =
                    [$dRead_sdENw] \u [] GHC.Read.readsPrec $dRead_sdENw;
              } in 
                case
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdENv
                        sat_sdENN
                        sat_sdENO
                        Data.Functor.Classes.$fRead1Const1
                        s_sdENA
                of
                sat_sdENP
                { __DEFAULT -> go_sdENC sat_sdENP;
                };
        };

Data.Functor.Classes.readsBinary1
  :: forall (f :: * -> *) (g :: * -> *) a t.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Base.String
     -> (f a -> g a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(C(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><S,1*U><L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdENQ
           $dRead2_sdENR
           $dRead_sdENS
           name_sdENT
           cons_sdENU
           kw_sdENV
           s_sdENW]
        case GHC.Base.eqString kw_sdENV name_sdENT of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                lvl3_sdENY
                  :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLJ
                [LclId] =
                    [$dRead_sdENS] \u [] GHC.Read.readsPrec $dRead_sdENS; } in
              let {
                lvl4_sdENZ :: Text.ParserCombinators.ReadP.ReadS [a_adwLJ]
                [LclId] =
                    [$dRead_sdENS] \u [] GHC.Read.readList $dRead_sdENS; } in
              let {
                go_sdEO0 [Occ=LoopBreaker]
                  :: [(f_adwLH a_adwLJ, GHC.Base.String)]
                     -> [(t_adwLK, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [$dRead2_sdENR
                              cons_sdENU
                              lvl3_sdENY
                              lvl4_sdENZ
                              go_sdEO0] \r [ds_sdEO1]
                        case ds_sdEO1 of {
                          [] -> [] [];
                          : y_sdEO3 [Occ=Once!] ys_sdEO4 [Occ=Once] ->
                              case y_sdEO3 of {
                                (,) x_sdEO6 [Occ=OnceL] t1_sdEO7 [Occ=Once] ->
                                    let {
                                      z_sdEO8 [Occ=OnceL] :: [(t_adwLK, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdEO0 ys_sdEO4] \u [] go_sdEO0 ys_sdEO4; } in
                                    let {
                                      go1_sdEO9 [Occ=LoopBreaker]
                                        :: [(g_adwLI a_adwLJ, GHC.Base.String)]
                                           -> [(t_adwLK, GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [cons_sdENU
                                                    x_sdEO6
                                                    z_sdEO8
                                                    go1_sdEO9] \r [ds1_sdEOa]
                                              case ds1_sdEOa of {
                                                [] -> z_sdEO8;
                                                : y1_sdEOc [Occ=Once!] ys1_sdEOd [Occ=Once] ->
                                                    case y1_sdEOc of {
                                                      (,) y2_sdEOf [Occ=Once] u_sdEOg [Occ=Once] ->
                                                          let {
                                                            sat_sdEOj [Occ=Once]
                                                              :: [(t_adwLK, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdEO9 ys1_sdEOd] \u []
                                                                    go1_sdEO9 ys1_sdEOd; } in
                                                          let {
                                                            sat_sdEOh [Occ=Once] :: t_adwLK
                                                            [LclId] =
                                                                [cons_sdENU x_sdEO6 y2_sdEOf] \u []
                                                                    cons_sdENU
                                                                        x_sdEO6 y2_sdEOf; } in
                                                          let {
                                                            sat_sdEOi [Occ=Once]
                                                              :: (t_adwLK, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sdEOh u_sdEOg];
                                                          } in  : [sat_sdEOi sat_sdEOj];
                                                    };
                                              };
                                    } in 
                                      case
                                          Data.Functor.Classes.liftReadsPrec
                                              $dRead2_sdENR
                                              lvl3_sdENY
                                              lvl4_sdENZ
                                              Data.Functor.Classes.$fRead1Const1
                                              t1_sdEO7
                                      of
                                      sat_sdEOk
                                      { __DEFAULT -> go1_sdEO9 sat_sdEOk;
                                      };
                              };
                        };
              } in 
                case
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdENQ
                        lvl3_sdENY
                        lvl4_sdENZ
                        Data.Functor.Classes.$fRead1Const1
                        s_sdENW
                of
                sat_sdEOl
                { __DEFAULT -> go_sdEO0 sat_sdEOl;
                };
        };

Data.Functor.Classes.readPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdEOm $dRead_sdEOn]
        let {
          sat_sdEOp [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwL4]
          [LclId] =
              [$dRead_sdEOn] \u [] GHC.Read.readListPrec $dRead_sdEOn; } in
        let {
          sat_sdEOo [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwL4
          [LclId] =
              [$dRead_sdEOn] \u [] GHC.Read.readPrec $dRead_sdEOn;
        } in 
          Data.Functor.Classes.liftReadPrec
              $dRead1_sdEOm sat_sdEOo sat_sdEOp;

Data.Functor.Classes.liftReadListDefault
  :: forall (f :: * -> *) a.
     Data.Functor.Classes.Read1 f =>
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdEOq rp_sdEOr rl_sdEOs]
        let {
          sat_sdEOz [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_adwKQ a_adwKR]
          [LclId] =
              [$dRead1_sdEOq rp_sdEOr rl_sdEOs] \u []
                  let {
                    sat_sdEOy [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwKR]
                    [LclId] =
                        [rl_sdEOs] \r [n_sdEOu w1_sdEOv]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sdEOs w1_sdEOv
                            of
                            { Unit# ww1_sdEOx [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEOx];
                            }; } in
                  let {
                    sat_sdEOt [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwKR
                    [LclId] =
                        [rp_sdEOr] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sdEOr eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadListPrec
                        $dRead1_sdEOq
                        sat_sdEOt
                        sat_sdEOy
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEOz;

Data.Functor.Classes.liftReadListPrecDefault
  :: forall (f :: * -> *) a.
     Data.Functor.Classes.Read1 f =>
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C1(C(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdEOA rp_sdEOB rl_sdEOC]
        let {
          sat_sdEOD [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_adwKH a_adwKI)
          [LclId] =
              [$dRead1_sdEOA rp_sdEOB rl_sdEOC] \s []
                  Data.Functor.Classes.liftReadPrec $dRead1_sdEOA rp_sdEOB rl_sdEOC;
        } in  GHC.Read.list sat_sdEOD;

lvl_rdymy
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Proxy.Proxy a]
[GblId] =
    [] \u [] GHC.Read.list Data.Functor.Classes.$fRead1Proxy1;

Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [Data.Proxy.Proxy a]
[GblId, Arity=2, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdEOE rl_sdEOF] lvl_rdymy;

Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Proxy.Proxy a)
[GblId, Arity=3, Str=<L,A><L,A><L,U>, Unf=OtherCon []] =
    [] \r [rp_sdEOG rl_sdEOH n_sdEOI]
        let {
          sat_sdEOJ [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Proxy.Proxy a_adx12)
          [LclId] =
              [n_sdEOI] \u []
                  GHC.Read.list3
                      Data.Functor.Classes.$fRead1Proxy2
                      n_sdEOI
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEOJ;

lvl1_rdymz
  :: forall a. Text.ParserCombinators.ReadP.P [Data.Proxy.Proxy a]
[GblId] =
    [] \u []
        GHC.Read.list
            Data.Functor.Classes.$fRead1Proxy1
            Data.Functor.Classes.$fRead1Identity5
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

lvl2_rdymA
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS [Data.Proxy.Proxy a]
[GblId, Arity=1, Unf=OtherCon []] =
    sat-only [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run lvl1_rdymz eta_B1;

Data.Functor.Classes.$fRead1Proxy_$cliftReadList
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Proxy.Proxy a]
[GblId, Arity=3, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdEOK rl_sdEOL eta_B1] lvl2_rdymA eta_B1;

Data.Functor.Classes.$fRead1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Proxy_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Proxy5
                                                 Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec];

Data.Functor.Classes.$fRead1[]_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [[a]]
[GblId, Arity=2, Str=<L,A><L,1*C1(C(U))>, Unf=OtherCon []] =
    [] \r [rp_sdEOM rl_sdEON] GHC.Read.list rl_sdEON;

Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,C(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [rp_sdEOO rl_sdEOP eta_sdEOQ]
        let {
          sat_sdEOT [Occ=Once] :: Text.ParserCombinators.ReadP.P [a_adx3j]
          [LclId] =
              [rl_sdEOP] \u []
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P
                          rl_sdEOP Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                  of
                  { Unit# ww1_sdEOS [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdEOS];
                  };
        } in  Text.ParserCombinators.ReadP.run sat_sdEOT;

Data.Functor.Classes.$w$cliftReadList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [[a]]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [w_sdEOU]
        let {
          sat_sdEP0 [Occ=Once] :: Text.ParserCombinators.ReadP.P [[a_sdxZW]]
          [LclId] =
              [w_sdEOU] \u []
                  let {
                    sat_sdEOZ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_sdxZW]
                    [LclId] =
                        [w_sdEOU] \r [n_sdEOV w1_sdEOW]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdEOU w1_sdEOW
                            of
                            { Unit# ww1_sdEOY [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEOY];
                            };
                  } in 
                    GHC.Read.list
                        sat_sdEOZ
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEP0;

Data.Functor.Classes.$fRead1[]_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [[a]]
[GblId, Arity=2, Str=<L,A><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_sdEP1 w1_sdEP2]
        Data.Functor.Classes.$w$cliftReadList2 w1_sdEP2;

Data.Functor.Classes.$fRead1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 []
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadList
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadPrec
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadListPrec];

Data.Functor.Classes.showsPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Types.Int -> f a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U(1*U,A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sdEP3 $dShow_sdEP4]
        let {
          sat_sdEP6 [Occ=Once] :: [a_adwJB] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEP4] \u [] GHC.Show.showList $dShow_sdEP4; } in
        let {
          sat_sdEP5 [Occ=Once] :: GHC.Types.Int -> a_adwJB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEP4] \u [] GHC.Show.showsPrec $dShow_sdEP4;
        } in 
          Data.Functor.Classes.liftShowsPrec
              $dShow1_sdEP3 sat_sdEP5 sat_sdEP6;

Data.Functor.Classes.showsUnaryWith1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [' '#];

Data.Functor.Classes.$wshowsUnary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Prim.Int# -> f a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEP7 w1_sdEP8 w2_sdEP9 ww_sdEPa w3_sdEPb]
        let {
          g_sdEPc [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEP7 w1_sdEP8 w3_sdEPb] \u []
                  let {
                    sat_sdEPe [Occ=Once] :: [a_sdy01] -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sdEP8] \u [] GHC.Show.showList w1_sdEP8; } in
                  let {
                    sat_sdEPd [Occ=Once] :: GHC.Types.Int -> a_sdy01 -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sdEP8] \u [] GHC.Show.showsPrec w1_sdEP8;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sdEP7
                        sat_sdEPd
                        sat_sdEPe
                        Data.Functor.Classes.$fRead1Const1
                        w3_sdEPb;
        } in 
          case ># [ww_sdEPa 10#] of {
            __DEFAULT ->
                let {
                  sat_sdEPj [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdEP9 g_sdEPc] \r [x_sdEPg]
                          let {
                            sat_sdEPh [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdEPc x_sdEPg] \u [] g_sdEPc x_sdEPg; } in
                          let {
                            sat_sdEPi [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEPh];
                          } in  GHC.Base.++ w2_sdEP9 sat_sdEPi;
                } in  sat_sdEPj;
            1# ->
                let {
                  sat_sdEPp [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdEP9 g_sdEPc] \r [x_sdEPk]
                          let {
                            sat_sdEPo [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w2_sdEP9 g_sdEPc x_sdEPk] \u []
                                    let {
                                      sat_sdEPm [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdEPc x_sdEPk] \u []
                                              let {
                                                sat_sdEPl [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdEPk];
                                              } in  g_sdEPc sat_sdEPl; } in
                                    let {
                                      sat_sdEPn [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEPm];
                                    } in  GHC.Base.++ w2_sdEP9 sat_sdEPn;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEPo];
                } in  sat_sdEPp;
          };

Data.Functor.Classes.showsUnary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Types.Int -> f a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEPq w1_sdEPr w2_sdEPs w3_sdEPt w4_sdEPu]
        case w3_sdEPt of {
          GHC.Types.I# ww1_sdEPw [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnary1
                  w_sdEPq w1_sdEPr w2_sdEPs ww1_sdEPw w4_sdEPu;
        };

Data.Functor.Classes.$wshowsBinary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Prim.Int# -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEPx
           w1_sdEPy
           w2_sdEPz
           w3_sdEPA
           ww_sdEPB
           w4_sdEPC
           w5_sdEPD]
        let {
          f1_sdEPE [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEPx w2_sdEPz w4_sdEPC] \u []
                  let {
                    sat_sdEPG [Occ=Once] :: [a_sdy0e] -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdEPz] \u [] GHC.Show.showList w2_sdEPz; } in
                  let {
                    sat_sdEPF [Occ=Once] :: GHC.Types.Int -> a_sdy0e -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdEPz] \u [] GHC.Show.showsPrec w2_sdEPz;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sdEPx
                        sat_sdEPF
                        sat_sdEPG
                        Data.Functor.Classes.$fRead1Const1
                        w4_sdEPC; } in
        let {
          g1_sdEPH [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdEPy w2_sdEPz w5_sdEPD] \u []
                  let {
                    sat_sdEPJ [Occ=Once] :: [a_sdy0e] -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdEPz] \u [] GHC.Show.showList w2_sdEPz; } in
                  let {
                    sat_sdEPI [Occ=Once] :: GHC.Types.Int -> a_sdy0e -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdEPz] \u [] GHC.Show.showsPrec w2_sdEPz;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w1_sdEPy
                        sat_sdEPI
                        sat_sdEPJ
                        Data.Functor.Classes.$fRead1Const1
                        w5_sdEPD;
        } in 
          case ># [ww_sdEPB 10#] of {
            __DEFAULT ->
                let {
                  sat_sdEPQ [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w3_sdEPA f1_sdEPE g1_sdEPH] \r [x_sdEPL]
                          let {
                            sat_sdEPO [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_sdEPE g1_sdEPH x_sdEPL] \u []
                                    let {
                                      sat_sdEPM [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g1_sdEPH x_sdEPL] \u [] g1_sdEPH x_sdEPL; } in
                                    let {
                                      sat_sdEPN [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEPM];
                                    } in  f1_sdEPE sat_sdEPN; } in
                          let {
                            sat_sdEPP [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEPO];
                          } in  GHC.Base.++ w3_sdEPA sat_sdEPP;
                } in  sat_sdEPQ;
            1# ->
                let {
                  sat_sdEPY [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w3_sdEPA f1_sdEPE g1_sdEPH] \r [x_sdEPR]
                          let {
                            sat_sdEPX [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w3_sdEPA f1_sdEPE g1_sdEPH x_sdEPR] \u []
                                    let {
                                      sat_sdEPV [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_sdEPE g1_sdEPH x_sdEPR] \u []
                                              let {
                                                sat_sdEPT [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_sdEPH x_sdEPR] \u []
                                                        let {
                                                          sat_sdEPS [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdEPR];
                                                        } in  g1_sdEPH sat_sdEPS; } in
                                              let {
                                                sat_sdEPU [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [Data.Functor.Classes.showsUnaryWith1
                                                             sat_sdEPT];
                                              } in  f1_sdEPE sat_sdEPU; } in
                                    let {
                                      sat_sdEPW [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEPV];
                                    } in  GHC.Base.++ w3_sdEPA sat_sdEPW;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEPX];
                } in  sat_sdEPY;
          };

Data.Functor.Classes.showsBinary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Types.Int -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S(S),1*U(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEPZ
           w1_sdEQ0
           w2_sdEQ1
           w3_sdEQ2
           w4_sdEQ3
           w5_sdEQ4
           w6_sdEQ5]
        case w4_sdEQ3 of {
          GHC.Types.I# ww1_sdEQ7 [Occ=Once] ->
              Data.Functor.Classes.$wshowsBinary1
                  w_sdEPZ w1_sdEQ0 w2_sdEQ1 w3_sdEQ2 ww1_sdEQ7 w5_sdEQ4 w6_sdEQ5;
        };

Data.Functor.Classes.eq2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Eq2 f, GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     f a b -> f a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*U(1*U,A)><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq2_sdEQ8 $dEq_sdEQ9 $dEq1_sdEQa]
        let {
          sat_sdEQc [Occ=Once] :: b_adwJk -> b_adwJk -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sdEQa] \u [] GHC.Classes.== $dEq1_sdEQa; } in
        let {
          sat_sdEQb [Occ=Once] :: a_adwJj -> a_adwJj -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdEQ9] \u [] GHC.Classes.== $dEq_sdEQ9;
        } in  $dEq2_sdEQ8 sat_sdEQb sat_sdEQc;

Data.Functor.Classes.compare2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Ord2 f, GHC.Classes.Ord a,
      GHC.Classes.Ord b) =>
     f a b -> f a b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,1*U(A,1*U,A,A,A,A,A,A)><L,1*U(A,1*U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd2_sdEQd $dOrd_sdEQe $dOrd1_sdEQf]
        let {
          sat_sdEQh [Occ=Once] :: b_adwJ2 -> b_adwJ2 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sdEQf] \u [] GHC.Classes.compare $dOrd1_sdEQf; } in
        let {
          sat_sdEQg [Occ=Once] :: a_adwJ1 -> a_adwJ1 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdEQe] \u [] GHC.Classes.compare $dOrd_sdEQe;
        } in 
          Data.Functor.Classes.liftCompare2 $dOrd2_sdEQd sat_sdEQg sat_sdEQh;

Data.Functor.Classes.readsPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Read2 f, GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(C(S))))LLL),1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><L,U(1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEQi $dRead_sdEQj $dRead1_sdEQk]
        let {
          sat_sdEQo [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [b_adwII]
          [LclId] =
              [$dRead1_sdEQk] \u [] GHC.Read.readList $dRead1_sdEQk; } in
        let {
          sat_sdEQn [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_adwII
          [LclId] =
              [$dRead1_sdEQk] \u [] GHC.Read.readsPrec $dRead1_sdEQk; } in
        let {
          sat_sdEQm [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [a_adwIH]
          [LclId] =
              [$dRead_sdEQj] \u [] GHC.Read.readList $dRead_sdEQj; } in
        let {
          sat_sdEQl [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwIH
          [LclId] =
              [$dRead_sdEQj] \u [] GHC.Read.readsPrec $dRead_sdEQj;
        } in 
          Data.Functor.Classes.liftReadsPrec2
              $dRead2_sdEQi sat_sdEQl sat_sdEQm sat_sdEQn sat_sdEQo;

Data.Functor.Classes.readPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Read2 f, GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U(A,A,1*U,1*U)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEQp $dRead_sdEQq $dRead1_sdEQr]
        let {
          sat_sdEQv [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwIo]
          [LclId] =
              [$dRead1_sdEQr] \u [] GHC.Read.readListPrec $dRead1_sdEQr; } in
        let {
          sat_sdEQu [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwIo
          [LclId] =
              [$dRead1_sdEQr] \u [] GHC.Read.readPrec $dRead1_sdEQr; } in
        let {
          sat_sdEQt [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwIn]
          [LclId] =
              [$dRead_sdEQq] \u [] GHC.Read.readListPrec $dRead_sdEQq; } in
        let {
          sat_sdEQs [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwIn
          [LclId] =
              [$dRead_sdEQq] \u [] GHC.Read.readPrec $dRead_sdEQq;
        } in 
          Data.Functor.Classes.liftReadPrec2
              $dRead2_sdEQp sat_sdEQs sat_sdEQt sat_sdEQu sat_sdEQv;

Data.Functor.Classes.liftReadList2Default
  :: forall (f :: * -> * -> *) a b.
     Data.Functor.Classes.Read2 f =>
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(C1(C1(C1(U)))))))><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEQw rp1_sdEQx rl1_sdEQy rp2_sdEQz rl2_sdEQA]
        let {
          sat_sdEQN [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_adwHZ a_adwI0 b_adwI1]
          [LclId] =
              [$dRead2_sdEQw rp1_sdEQx rl1_sdEQy rp2_sdEQz rl2_sdEQA] \u []
                  let {
                    sat_sdEQM [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwI1]
                    [LclId] =
                        [rl2_sdEQA] \r [n_sdEQI w1_sdEQJ]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl2_sdEQA w1_sdEQJ
                            of
                            { Unit# ww1_sdEQL [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEQL];
                            }; } in
                  let {
                    sat_sdEQH [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwI1
                    [LclId] =
                        [rp2_sdEQz] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                rp2_sdEQz eta_B1; } in
                  let {
                    sat_sdEQG [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwI0]
                    [LclId] =
                        [rl1_sdEQy] \r [n_sdEQC w1_sdEQD]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl1_sdEQy w1_sdEQD
                            of
                            { Unit# ww1_sdEQF [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEQF];
                            }; } in
                  let {
                    sat_sdEQB [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwI0
                    [LclId] =
                        [rp1_sdEQx] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp1_sdEQx eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadListPrec2
                        $dRead2_sdEQw
                        sat_sdEQB
                        sat_sdEQG
                        sat_sdEQH
                        sat_sdEQM
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEQN;

Data.Functor.Classes.$fRead2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 Data.Either.Either
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2Either_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1Either8
                                                 Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2Either_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a b]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2Either eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2Const_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1Const6
                                                 Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2Const_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Const.Const a b]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2Const eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 (,)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2(,)_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1(,)2
                                                 Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2(,)_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [(a, b)]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2(,) eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.liftReadListPrec2Default
  :: forall (f :: * -> * -> *) a b.
     Data.Functor.Classes.Read2 f =>
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C1(C(U)))))),A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEQO rp1_sdEQP rl1_sdEQQ rp2_sdEQR rl2_sdEQS]
        let {
          sat_sdEQT [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_adwHO a_adwHP b_adwHQ)
          [LclId] =
              [$dRead2_sdEQO rp1_sdEQP rl1_sdEQQ rp2_sdEQR rl2_sdEQS] \s []
                  Data.Functor.Classes.liftReadPrec2
                      $dRead2_sdEQO rp1_sdEQP rl1_sdEQQ rp2_sdEQR rl2_sdEQS;
        } in  GHC.Read.list sat_sdEQT;

Data.Functor.Classes.$fRead1(,)1
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a, a1) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdEQU eta_sdEQV eta1_sdEQW eta2_sdEQX eta3_sdEQY]
        let {
          sat_sdEQZ [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwUw
          [LclId] =
              [$dRead_sdEQU] \u [] GHC.Read.readPrec $dRead_sdEQU;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec2
              sat_sdEQZ eta_sdEQV eta2_sdEQX eta3_sdEQY;

Data.Functor.Classes.$w$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (a, a1)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdER0 w1_sdER1 w2_sdER2]
        let {
          sat_sdER5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (a_sdy0L, a1_sdy0N)
          [LclId] =
              [w_sdER0 w1_sdER1 w2_sdER2] \u []
                  let {
                    sat_sdER4 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a1_sdy0N
                    [LclId] =
                        [w1_sdER1] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdER1 eta_B1; } in
                  let {
                    sat_sdER3 [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy0L
                    [LclId] =
                        [w_sdER0] \u [] GHC.Read.readPrec w_sdER0;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec2
                        sat_sdER3
                        sat_sdER4
                        w2_sdER2
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdER5;

Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdER6 w1_sdER7 w2_sdER8 w3_sdER9]
        Data.Functor.Classes.$w$cliftReadsPrec w_sdER6 w1_sdER7 w3_sdER9;

Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [(a, a1)]
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdERa rp_sdERb rl_sdERc]
        let {
          sat_sdERd [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_XdwZz, a1_adwV6)
          [LclId] =
              [$dRead_sdERa rp_sdERb rl_sdERc] \r [eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)1
                      $dRead_sdERa rp_sdERb rl_sdERc eta_B2 eta_B1;
        } in  GHC.Read.list sat_sdERd;

Data.Functor.Classes.$fRead1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => Data.Functor.Classes.Read1 ((,) a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdERe]
        let {
          sat_sdERl [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec [(a_XdwZy, a)]
          [LclId] =
              [$dRead_sdERe] \r [eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
                      $dRead_sdERe eta_B2 eta_B1; } in
        let {
          sat_sdERk [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec (a_XdwZy, a)
          [LclId] =
              [$dRead_sdERe] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)1
                      $dRead_sdERe eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdERj [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS [(a_XdwZy, a)]
          [LclId] =
              [$dRead_sdERe] \u []
                  Data.Functor.Classes.$fRead1(,)_$cliftReadList $dRead_sdERe; } in
        let {
          sat_sdERi [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (a_XdwZy, a)
          [LclId] =
              [$dRead_sdERe] \r [w_sdERf w1_sdERg w2_sdERh]
                  Data.Functor.Classes.$w$cliftReadsPrec
                      $dRead_sdERe w_sdERf w2_sdERh;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdERi
                                        sat_sdERj
                                        sat_sdERk
                                        sat_sdERl];
Data.Functor.Classes.$fRead1(,)_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS [(a, a1)]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdERm]
        let {
          sat_sdERn [Occ=Once] :: Data.Functor.Classes.Read1 ((,) a_XdwZA)
          [LclId] =
              [$dRead_sdERm] \u [] Data.Functor.Classes.$fRead1(,) $dRead_sdERm;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdERn;

Data.Functor.Classes.showsPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Show2 f, GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> f a b -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(C(S))))L),1*U(1*C1(C1(C1(C1(U)))),A)><L,U(1*U,A,1*U)><L,U(1*U,A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dShow2_sdERo $dShow_sdERp $dShow1_sdERq]
        let {
          sat_sdERu [Occ=Once] :: [b_adwHw] -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdERq] \u [] GHC.Show.showList $dShow1_sdERq; } in
        let {
          sat_sdERt [Occ=Once] :: GHC.Types.Int -> b_adwHw -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdERq] \u [] GHC.Show.showsPrec $dShow1_sdERq; } in
        let {
          sat_sdERs [Occ=Once] :: [a_adwHv] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdERp] \u [] GHC.Show.showList $dShow_sdERp; } in
        let {
          sat_sdERr [Occ=Once] :: GHC.Types.Int -> a_adwHv -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdERp] \u [] GHC.Show.showsPrec $dShow_sdERp;
        } in 
          Data.Functor.Classes.liftShowsPrec2
              $dShow2_sdERo sat_sdERr sat_sdERs sat_sdERt sat_sdERu;

Data.Functor.Classes.$wreadsData [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Prim.Int# -> GHC.Base.String -> [(a, GHC.Base.String)]
[GblId, Arity=3, Str=<L,C(C1(U))><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdERv ww_sdERw w1_sdERx]
        let {
          go_sdERy [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_sdy11, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sdERv go_sdERy] \r [ds_sdERz]
                  case ds_sdERz of {
                    [] -> [] [];
                    : y_sdERB [Occ=Once!] ys_sdERC [Occ=Once] ->
                        case y_sdERB of {
                          (,) kw_sdERE [Occ=Once] s_sdERF [Occ=Once] ->
                              let {
                                sat_sdERH [Occ=Once, Dmd=<L,1*U>] :: [(a_sdy11, GHC.Base.String)]
                                [LclId] =
                                    [go_sdERy ys_sdERC] \s [] go_sdERy ys_sdERC;
                              } in 
                                case w_sdERv kw_sdERE s_sdERF of sat_sdERG {
                                  __DEFAULT -> GHC.Base.++ sat_sdERG sat_sdERH;
                                };
                        };
                  }; } in
        let {
          sat_sdERM [Occ=Once] :: Text.ParserCombinators.ReadP.ReadS a_sdy11
          [LclId] =
              [go_sdERy] \r [r_sdERK]
                  case
                      Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_sdERK
                  of
                  sat_sdERL
                  { __DEFAULT -> go_sdERy sat_sdERL;
                  };
        } in 
          case ># [ww_sdERw 10#] of sat_sdERI {
            __DEFAULT ->
                case tagToEnum# [sat_sdERI] of sat_sdERJ {
                  __DEFAULT -> GHC.Read.readParen sat_sdERJ sat_sdERM w1_sdERx;
                };
          };

Data.Functor.Classes.readsData [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdERN w1_sdERO w2_sdERP]
        case w1_sdERO of {
          GHC.Types.I# ww1_sdERR [Occ=Once] ->
              Data.Functor.Classes.$wreadsData w_sdERN ww1_sdERR w2_sdERP;
        };

Data.Functor.Classes.readData2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

Data.Functor.Classes.readData1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [reader_sdERS eta_sdERT eta1_sdERU]
        let {
          lvl3_sdERV [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_adwHc
          [LclId] =
              [reader_sdERS] \u []
                  reader_sdERS Data.Functor.Classes.readData2; } in
        let {
          sat_sdES0 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwHc
          [LclId] =
              [lvl3_sdERV] \r [c_sdERW]
                  case c_sdERW of {
                    GHC.Types.I# x_sdERY [Occ=Once] ->
                        case <=# [x_sdERY 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
                          1# -> lvl3_sdERV;
                        };
                  };
        } in  GHC.Read.list3 sat_sdES0 eta_sdERT eta1_sdERU;

Data.Functor.Classes.readData
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readData1 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.readsUnaryWith
  :: forall a t.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Base.String
     -> (a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [rp_sdES1 name_sdES2 cons_sdES3 kw_sdES4 s_sdES5]
        case GHC.Base.eqString kw_sdES4 name_sdES2 of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdES7 [Occ=LoopBreaker]
                  :: [(a_adwH5, GHC.Base.String)] -> [(t_adwH6, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdES3 go_sdES7] \r [ds_sdES8]
                        case ds_sdES8 of {
                          [] -> [] [];
                          : y_sdESa [Occ=Once!] ys_sdESb [Occ=Once] ->
                              case y_sdESa of {
                                (,) x_sdESd [Occ=Once] t1_sdESe [Occ=Once] ->
                                    let {
                                      sat_sdESh [Occ=Once] :: [(t_adwH6, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdES7 ys_sdESb] \u [] go_sdES7 ys_sdESb; } in
                                    let {
                                      sat_sdESf [Occ=Once] :: t_adwH6
                                      [LclId] =
                                          [cons_sdES3 x_sdESd] \u [] cons_sdES3 x_sdESd; } in
                                    let {
                                      sat_sdESg [Occ=Once] :: (t_adwH6, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdESf t1_sdESe];
                                    } in  : [sat_sdESg sat_sdESh];
                              };
                        };
              } in 
                case
                    rp_sdES1 Data.Functor.Classes.$fRead1Const1 s_sdES5
                of
                sat_sdESi
                { __DEFAULT -> go_sdES7 sat_sdESi;
                };
        };

Data.Functor.Classes.$wreadUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (t -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_sdESj w1_sdESk w2_sdESl w3_sdESm w4_sdESn]
        let {
          sat_sdESx [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_sdy1t
          [LclId] =
              [w_sdESj w2_sdESl w3_sdESm w4_sdESn] \r [a1_sdESp]
                  let {
                    sat_sdESw [Occ=Once]
                      :: a_sdy1n -> Text.ParserCombinators.ReadP.P b_sdy1t
                    [LclId] =
                        [w2_sdESl w4_sdESn] \r [a2_sdESu]
                            let {
                              sat_sdESv [Occ=Once] :: t_sdy1o
                              [LclId] =
                                  [w2_sdESl a2_sdESu] \u [] w2_sdESl a2_sdESu;
                            } in  w4_sdESn sat_sdESv; } in
                  let {
                    sat_sdESt [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec
                    [LclId] =
                        [w3_sdESm] \u []
                            case w3_sdESm of {
                              GHC.Types.I# x_sdESr [Occ=Once] ->
                                  case +# [x_sdESr 1#] of sat_sdESs {
                                    __DEFAULT -> GHC.Types.I# [sat_sdESs];
                                  };
                            };
                  } in  w_sdESj sat_sdESt sat_sdESw; } in
        let {
          sat_sdESo [Occ=Once] :: Text.Read.Lex.Lexeme
          [LclId] =
              CCCS Text.Read.Lex.Ident! [w1_sdESk];
        } in  Text.Read.Lex.$wexpect sat_sdESo sat_sdESx;

Data.Functor.Classes.readUnaryWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (t -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_sdESy w1_sdESz w2_sdESA w3_sdESB w4_sdESC]
        case
            Data.Functor.Classes.$wreadUnaryWith
                w_sdESy w1_sdESz w2_sdESA w3_sdESB w4_sdESC
        of
        { Unit# ww1_sdESE [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_sdESE];
        };

Data.Functor.Classes.readUnaryWith
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.ReadPrec t
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readUnaryWith1
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead1Const5
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Const.Const a a1 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdESF eta_sdESG eta1_sdESH eta2_sdESI eta3_sdESJ]
        let {
          sat_sdESK [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwRr
          [LclId] =
              [$dRead_sdESF] \u [] GHC.Read.readPrec $dRead_sdESF;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec1
              sat_sdESK eta2_sdESI eta3_sdESJ;

Data.Functor.Classes.$w$cliftReadsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a a1)
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdESL w1_sdESM]
        let {
          sat_sdESO [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Const.Const a_sdy1z a1_sdy1B)
          [LclId] =
              [w_sdESL w1_sdESM] \u []
                  let {
                    sat_sdESN [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1z
                    [LclId] =
                        [w_sdESL] \u [] GHC.Read.readPrec w_sdESL;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec1
                        sat_sdESN
                        w1_sdESM
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdESO;

Data.Functor.Classes.$fRead1Const_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdESP w1_sdESQ w2_sdESR w3_sdESS]
        Data.Functor.Classes.$w$cliftReadsPrec1 w_sdESP w3_sdESS;

Data.Functor.Classes.$w$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Const.Const a a1]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [w_sdEST]
        let {
          w1_sdESU [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1G
          [LclId] =
              [w_sdEST] \u [] GHC.Read.readPrec w_sdEST; } in
        let {
          sat_sdESX [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_sdy1G a1_sdy1I)
          [LclId] =
              [w1_sdESU] \r [w2_sdESV w3_sdESW]
                  Data.Functor.Classes.$w$cliftReadPrec1 w1_sdESU w2_sdESV w3_sdESW;
        } in  GHC.Read.list sat_sdESX;

Data.Functor.Classes.$fRead1Const_$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Const.Const a a1]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdESY w1_sdESZ w2_sdET0]
        Data.Functor.Classes.$w$cliftReadListPrec w_sdESY;

Data.Functor.Classes.$fRead1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     Data.Functor.Classes.Read1 (Data.Functor.Const.Const a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdET1]
        let {
          lvl3_sdET2 [Occ=OnceL]
            :: forall a1.
               Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Const.Const a_XdwZZ a1]
          [LclId] =
              [$dRead_sdET1] \u []
                  Data.Functor.Classes.$w$cliftReadListPrec $dRead_sdET1; } in
        let {
          sat_sdETb [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Const.Const a_XdwZZ a]
          [LclId] =
              [lvl3_sdET2] \r [w_sdET9 w1_sdETa] lvl3_sdET2; } in
        let {
          sat_sdET8 [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Const.Const a_XdwZZ a)
          [LclId] =
              [$dRead_sdET1] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1Const5
                      $dRead_sdET1 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdET7 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Const.Const a_XdwZZ a]
          [LclId] =
              [$dRead_sdET1] \u []
                  Data.Functor.Classes.$fRead1Const_$cliftReadList $dRead_sdET1; } in
        let {
          sat_sdET6 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Const.Const a_XdwZZ a)
          [LclId] =
              [$dRead_sdET1] \r [w_sdET3 w1_sdET4 w2_sdET5]
                  Data.Functor.Classes.$w$cliftReadsPrec1 $dRead_sdET1 w2_sdET5;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdET6
                                        sat_sdET7
                                        sat_sdET8
                                        sat_sdETb];
Data.Functor.Classes.$fRead1Const_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Const.Const a a1]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdETc]
        let {
          sat_sdETd [Occ=Once]
            :: Data.Functor.Classes.Read1 (Data.Functor.Const.Const a_Xdx00)
          [LclId] =
              [$dRead_sdETc] \u []
                  Data.Functor.Classes.$fRead1Const $dRead_sdETc;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdETd;

Data.Functor.Classes.$fRead1Either7
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Either.Either a a1 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdETe eta_sdETf eta1_sdETg eta2_sdETh eta3_sdETi]
        let {
          sat_sdETj [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwSV
          [LclId] =
              [$dRead_sdETe] \u [] GHC.Read.readPrec $dRead_sdETe;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec3
              sat_sdETj eta_sdETf eta2_sdETh eta3_sdETi;

Data.Functor.Classes.$w$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a a1)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdETk w1_sdETl w2_sdETm]
        let {
          sat_sdETp [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_sdy1O a1_sdy1Q)
          [LclId] =
              [w_sdETk w1_sdETl w2_sdETm] \u []
                  let {
                    sat_sdETo [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a1_sdy1Q
                    [LclId] =
                        [w1_sdETl] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdETl eta_B1; } in
                  let {
                    sat_sdETn [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1O
                    [LclId] =
                        [w_sdETk] \u [] GHC.Read.readPrec w_sdETk;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec3
                        sat_sdETn
                        sat_sdETo
                        w2_sdETm
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdETp;

Data.Functor.Classes.$fRead1Either_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdETq w1_sdETr w2_sdETs w3_sdETt]
        Data.Functor.Classes.$w$cliftReadsPrec2 w_sdETq w1_sdETr w3_sdETt;

Data.Functor.Classes.$w$cliftReadListPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a a1]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [w_sdETu w1_sdETv]
        let {
          w2_sdETw [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1V
          [LclId] =
              [w_sdETu] \u [] GHC.Read.readPrec w_sdETu; } in
        let {
          sat_sdETz [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_sdy1V a1_sdy1X)
          [LclId] =
              [w1_sdETv w2_sdETw] \r [w3_sdETx w4_sdETy]
                  Data.Functor.Classes.$w$cliftReadPrec3
                      w2_sdETw w1_sdETv w3_sdETx w4_sdETy;
        } in  GHC.Read.list sat_sdETz;

Data.Functor.Classes.$fRead1Either_$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a a1]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdETA w1_sdETB w2_sdETC]
        Data.Functor.Classes.$w$cliftReadListPrec1 w_sdETA w1_sdETB;

Data.Functor.Classes.$fRead1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     Data.Functor.Classes.Read1 (Data.Either.Either a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdETD]
        let {
          sat_sdETM [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Either.Either a_XdwYA a]
          [LclId] =
              [$dRead_sdETD] \r [w_sdETK w1_sdETL]
                  Data.Functor.Classes.$w$cliftReadListPrec1
                      $dRead_sdETD w_sdETK; } in
        let {
          sat_sdETJ [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Either.Either a_XdwYA a)
          [LclId] =
              [$dRead_sdETD] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1Either7
                      $dRead_sdETD eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdETI [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Either.Either a_XdwYA a]
          [LclId] =
              [$dRead_sdETD] \u []
                  Data.Functor.Classes.$fRead1Either_$cliftReadList
                      $dRead_sdETD; } in
        let {
          sat_sdETH [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Either.Either a_XdwYA a)
          [LclId] =
              [$dRead_sdETD] \r [w_sdETE w1_sdETF w2_sdETG]
                  Data.Functor.Classes.$w$cliftReadsPrec2
                      $dRead_sdETD w_sdETE w2_sdETG;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdETH
                                        sat_sdETI
                                        sat_sdETJ
                                        sat_sdETM];
Data.Functor.Classes.$fRead1Either_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a a1]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdETN]
        let {
          sat_sdETO [Occ=Once]
            :: Data.Functor.Classes.Read1 (Data.Either.Either a_XdwYC)
          [LclId] =
              [$dRead_sdETN] \u []
                  Data.Functor.Classes.$fRead1Either $dRead_sdETN;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdETO;

Data.Functor.Classes.$fRead1Identity4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity"#;

Data.Functor.Classes.$fRead1Identity3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Identity4;

Data.Functor.Classes.$fRead1Identity2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Identity3];

Data.Functor.Classes.$w$cliftReadPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdETP w1_sdETQ w2_sdETR]
        let {
          sat_sdEU3 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_sdy23)
          [LclId] =
              [w_sdETP] \r [c_sdETS eta_sdETT]
                  case c_sdETS of {
                    GHC.Types.I# x_sdETV [Occ=Once] ->
                        case <=# [x_sdETV 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdEU0 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_X81et
                                [LclId] =
                                    [w_sdETP eta_sdETT] \r [a1_sdETX]
                                        let {
                                          sat_sdETZ [Occ=Once]
                                            :: a_sdy23 -> Text.ParserCombinators.ReadP.P b1_X81et
                                          [LclId] =
                                              [eta_sdETT] \r [a2_sdETY] eta_sdETT a2_sdETY;
                                        } in  w_sdETP Data.Functor.Classes.$fRead1Const1 sat_sdETZ;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Identity2 sat_sdEU0
                                of
                                { Unit# ww1_sdEU2 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sdEU2];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdEU3 w1_sdETQ w2_sdETR;

Data.Functor.Classes.$fRead1Identity1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEU4 w1_sdEU5 w2_sdEU6 w3_sdEU7]
        Data.Functor.Classes.$w$cliftReadPrec w_sdEU4 w2_sdEU6 w3_sdEU7;

Data.Functor.Classes.$w$cliftReadsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId, Arity=2, Str=<L,1*C1(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEU8 w1_sdEU9]
        let {
          sat_sdEUp [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Identity.Identity a_sdy2a)
          [LclId] =
              [w_sdEU8 w1_sdEU9] \u []
                  let {
                    lvl3_sdEUa [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS a_sdy2a
                    [LclId] =
                        [w_sdEU8] \u [] w_sdEU8 Data.Functor.Classes.$fRead1Const1; } in
                  let {
                    sat_sdEUo [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sdy2a)
                    [LclId] =
                        [lvl3_sdEUa] \r [c_sdEUb eta_sdEUc]
                            case c_sdEUb of {
                              GHC.Types.I# x_sdEUe [Occ=Once] ->
                                  case <=# [x_sdEUe 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdEUl [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_X81et
                                          [LclId] =
                                              [lvl3_sdEUa eta_sdEUc] \r [a1_sdEUg]
                                                  let {
                                                    sat_sdEUi [Occ=Once]
                                                      :: a_sdy2a
                                                         -> Text.ParserCombinators.ReadP.P b_X81et
                                                    [LclId] =
                                                        [eta_sdEUc] \r [a2_sdEUh]
                                                            eta_sdEUc a2_sdEUh;
                                                  } in 
                                                    case
                                                        Text.ParserCombinators.ReadP.$wreadS_to_P
                                                            lvl3_sdEUa sat_sdEUi
                                                    of
                                                    { Unit# ww1_sdEUk [Occ=Once] ->
                                                          Text.ParserCombinators.ReadP.Look [ww1_sdEUk];
                                                    };
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Identity2 sat_sdEUl
                                          of
                                          { Unit# ww1_sdEUn [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdEUn];
                                          };
                                  };
                            };
                  } in 
                    GHC.Read.list3
                        sat_sdEUo
                        w1_sdEU9
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEUp;

Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,A><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEUq w1_sdEUr w2_sdEUs]
        Data.Functor.Classes.$w$cliftReadsPrec3 w_sdEUq w2_sdEUs;

Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Identity.Identity a]
[GblId, Arity=2, Str=<L,C(C1(U))><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdEUt rl_sdEUu]
        let {
          sat_sdEUx [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_adx2c)
          [LclId] =
              [rp_sdEUt] \r [w_sdEUv w1_sdEUw]
                  Data.Functor.Classes.$w$cliftReadPrec rp_sdEUt w_sdEUv w1_sdEUw;
        } in  GHC.Read.list sat_sdEUx;

Data.Functor.Classes.$w$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Identity.Identity a]
[GblId, Arity=1, Str=<L,C(C(U))>, Unf=OtherCon []] =
    [] \r [w_sdEUy]
        let {
          sat_sdEUD [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_sdy2f]
          [LclId] =
              [w_sdEUy] \u []
                  let {
                    w1_sdEUz [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.Prec
                         -> forall b.
                            (a_sdy2f -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [w_sdEUy] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdEUy eta_B1; } in
                  let {
                    sat_sdEUC [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sdy2f)
                    [LclId] =
                        [w1_sdEUz] \r [w2_sdEUA w3_sdEUB]
                            Data.Functor.Classes.$w$cliftReadPrec w1_sdEUz w2_sdEUA w3_sdEUB;
                  } in 
                    GHC.Read.list
                        sat_sdEUC
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEUD;

Data.Functor.Classes.$fRead1Identity_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Identity.Identity a]
[GblId, Arity=2, Str=<L,C(C(U))><L,A>, Unf=OtherCon []] =
    [] \r [w_sdEUE w1_sdEUF]
        Data.Functor.Classes.$w$cliftReadList w_sdEUE;

Data.Functor.Classes.$fRead1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Identity_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Identity1
                                                 Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec];

Data.Functor.Classes.$fRead1Maybe7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Nothing"#;

Data.Functor.Classes.$fRead1Maybe6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Maybe7;

Data.Functor.Classes.$fRead1Maybe_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Maybe6];

Data.Functor.Classes.$fRead1Maybe5
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [eta_sdEUG eta1_sdEUH]
        let {
          sat_sdEUJ [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_i815E
          [LclId] =
              [eta1_sdEUH] \r [x_sdEUI] eta1_sdEUH GHC.Base.Nothing;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Functor.Classes.$fRead1Maybe_lexeme sat_sdEUJ
          of
          { Unit# ww1_sdEUL [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sdEUL];
          };

Data.Functor.Classes.$fRead1Maybe4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Just"#;

Data.Functor.Classes.$fRead1Maybe3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Maybe4;

Data.Functor.Classes.$fRead1Maybe2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Maybe3];

Data.Functor.Classes.$w$cliftReadPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEUM w1_sdEUN w2_sdEUO]
        let {
          sat_sdEV3 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sdy2n
          [LclId] =
              [w_sdEUM w1_sdEUN w2_sdEUO] \u []
                  let {
                    sat_sdEV2 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.Maybe a_sdy2j)
                    [LclId] =
                        [w_sdEUM] \r [c_sdEUQ eta_sdEUR]
                            case c_sdEUQ of {
                              GHC.Types.I# x_sdEUT [Occ=Once] ->
                                  case <=# [x_sdEUT 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdEUZ [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_X81c7
                                          [LclId] =
                                              [w_sdEUM eta_sdEUR] \r [a1_sdEUV]
                                                  let {
                                                    sat_sdEUY [Occ=Once]
                                                      :: a_sdy2j
                                                         -> Text.ParserCombinators.ReadP.P b1_X81c7
                                                    [LclId] =
                                                        [eta_sdEUR] \r [a2_sdEUW]
                                                            let {
                                                              sat_sdEUX [Occ=Once]
                                                                :: GHC.Base.Maybe a_sdy2j
                                                              [LclId] =
                                                                  CCCS GHC.Base.Just! [a2_sdEUW];
                                                            } in  eta_sdEUR sat_sdEUX;
                                                  } in 
                                                    w_sdEUM
                                                        Data.Functor.Classes.$fRead1Const1
                                                        sat_sdEUY;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Maybe2 sat_sdEUZ
                                          of
                                          { Unit# ww1_sdEV1 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdEV1];
                                          };
                                  };
                            };
                  } in  GHC.Read.list3 sat_sdEV2 w1_sdEUN w2_sdEUO;
        } in 
          case
              GHC.Read.list3 Data.Functor.Classes.$fRead1Maybe5 w1_sdEUN w2_sdEUO
          of
          sat_sdEUP
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_sdEUP sat_sdEV3;
          };

Data.Functor.Classes.$fRead1Maybe1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEV4 w1_sdEV5 w2_sdEV6 w3_sdEV7]
        Data.Functor.Classes.$w$cliftReadPrec4 w_sdEV4 w2_sdEV6 w3_sdEV7;

Data.Functor.Classes.$w$cliftReadsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.Maybe a)
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEV8 w1_sdEV9]
        let {
          sat_sdEVb [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (GHC.Base.Maybe a_sdy2q)
          [LclId] =
              [w_sdEV8 w1_sdEV9] \u []
                  let {
                    sat_sdEVa [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy2q
                    [LclId] =
                        [w_sdEV8] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdEV8 eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec4
                        sat_sdEVa
                        w1_sdEV9
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEVb;

Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.Maybe a)
[GblId, Arity=3, Str=<L,C(C(U))><L,A><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEVc w1_sdEVd w2_sdEVe]
        Data.Functor.Classes.$w$cliftReadsPrec4 w_sdEVc w2_sdEVe;

Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [GHC.Base.Maybe a]
[GblId, Arity=2, Str=<L,C(C1(U))><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdEVf rl_sdEVg]
        let {
          sat_sdEVj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (GHC.Base.Maybe a_adx4t)
          [LclId] =
              [rp_sdEVf] \r [w_sdEVh w1_sdEVi]
                  Data.Functor.Classes.$w$cliftReadPrec4 rp_sdEVf w_sdEVh w1_sdEVi;
        } in  GHC.Read.list sat_sdEVj;

Data.Functor.Classes.$w$cliftReadList1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.Maybe a]
[GblId, Arity=1, Str=<L,C(C(U))>, Unf=OtherCon []] =
    [] \r [w_sdEVk]
        let {
          sat_sdEVp [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [GHC.Base.Maybe a_sdy2v]
          [LclId] =
              [w_sdEVk] \u []
                  let {
                    w1_sdEVl [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.Prec
                         -> forall b.
                            (a_sdy2v -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [w_sdEVk] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdEVk eta_B1; } in
                  let {
                    sat_sdEVo [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.Maybe a_sdy2v)
                    [LclId] =
                        [w1_sdEVl] \r [w2_sdEVm w3_sdEVn]
                            Data.Functor.Classes.$w$cliftReadPrec4 w1_sdEVl w2_sdEVm w3_sdEVn;
                  } in 
                    GHC.Read.list
                        sat_sdEVo
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEVp;

Data.Functor.Classes.$fRead1Maybe_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.Maybe a]
[GblId, Arity=2, Str=<L,C(C(U))><L,A>, Unf=OtherCon []] =
    [] \r [w_sdEVq w1_sdEVr]
        Data.Functor.Classes.$w$cliftReadList1 w_sdEVq;

Data.Functor.Classes.$fRead1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Maybe_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Maybe1
                                                 Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec];

Data.Functor.Classes.readsBinaryWith
  :: forall a b t.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Base.String
     -> (a -> b -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><S,1*U><L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [rp1_sdEVs rp2_sdEVt name_sdEVu cons_sdEVv kw_sdEVw s_sdEVx]
        case GHC.Base.eqString kw_sdEVw name_sdEVu of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdEVz [Occ=LoopBreaker]
                  :: [(a_adwGC, GHC.Base.String)] -> [(t_adwGE, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [rp2_sdEVt cons_sdEVv go_sdEVz] \r [ds_sdEVA]
                        case ds_sdEVA of {
                          [] -> [] [];
                          : y_sdEVC [Occ=Once!] ys_sdEVD [Occ=Once] ->
                              case y_sdEVC of {
                                (,) x_sdEVF [Occ=OnceL] t1_sdEVG [Occ=Once] ->
                                    let {
                                      z_sdEVH [Occ=OnceL] :: [(t_adwGE, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdEVz ys_sdEVD] \u [] go_sdEVz ys_sdEVD; } in
                                    let {
                                      go1_sdEVI [Occ=LoopBreaker]
                                        :: [(b_adwGD, GHC.Base.String)]
                                           -> [(t_adwGE, GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [cons_sdEVv
                                                    x_sdEVF
                                                    z_sdEVH
                                                    go1_sdEVI] \r [ds1_sdEVJ]
                                              case ds1_sdEVJ of {
                                                [] -> z_sdEVH;
                                                : y1_sdEVL [Occ=Once!] ys1_sdEVM [Occ=Once] ->
                                                    case y1_sdEVL of {
                                                      (,) y2_sdEVO [Occ=Once] u_sdEVP [Occ=Once] ->
                                                          let {
                                                            sat_sdEVS [Occ=Once]
                                                              :: [(t_adwGE, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdEVI ys1_sdEVM] \u []
                                                                    go1_sdEVI ys1_sdEVM; } in
                                                          let {
                                                            sat_sdEVQ [Occ=Once] :: t_adwGE
                                                            [LclId] =
                                                                [cons_sdEVv x_sdEVF y2_sdEVO] \u []
                                                                    cons_sdEVv
                                                                        x_sdEVF y2_sdEVO; } in
                                                          let {
                                                            sat_sdEVR [Occ=Once]
                                                              :: (t_adwGE, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sdEVQ u_sdEVP];
                                                          } in  : [sat_sdEVR sat_sdEVS];
                                                    };
                                              };
                                    } in 
                                      case
                                          rp2_sdEVt Data.Functor.Classes.$fRead1Const1 t1_sdEVG
                                      of
                                      sat_sdEVT
                                      { __DEFAULT -> go1_sdEVI sat_sdEVT;
                                      };
                              };
                        };
              } in 
                case
                    rp1_sdEVs Data.Functor.Classes.$fRead1Const1 s_sdEVx
                of
                sat_sdEVU
                { __DEFAULT -> go_sdEVz sat_sdEVU;
                };
        };

Data.Functor.Classes.$wreadBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (t -> Text.ParserCombinators.ReadP.P b1)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b1 #)
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEVV w1_sdEVW w2_sdEVX w3_sdEVY w4_sdEVZ w5_sdEW0]
        let {
          sat_sdEWc [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b1_sdy2S
          [LclId] =
              [w_sdEVV w1_sdEVW w3_sdEVY w4_sdEVZ w5_sdEW0] \r [a1_sdEW2]
                  let {
                    lvl3_sdEW3 :: Text.ParserCombinators.ReadPrec.Prec
                    [LclId] =
                        [w4_sdEVZ] \u []
                            case w4_sdEVZ of {
                              GHC.Types.I# x_sdEW5 [Occ=Once] ->
                                  case +# [x_sdEW5 1#] of sat_sdEW6 {
                                    __DEFAULT -> GHC.Types.I# [sat_sdEW6];
                                  };
                            }; } in
                  let {
                    sat_sdEWb [Occ=Once]
                      :: a_sdy2K -> Text.ParserCombinators.ReadP.P b1_sdy2S
                    [LclId] =
                        [w1_sdEVW w3_sdEVY w5_sdEW0 lvl3_sdEW3] \r [a2_sdEW7]
                            let {
                              sat_sdEWa [Occ=Once]
                                :: b_sdy2L -> Text.ParserCombinators.ReadP.P b1_sdy2S
                              [LclId] =
                                  [w3_sdEVY w5_sdEW0 a2_sdEW7] \r [a3_sdEW8]
                                      let {
                                        sat_sdEW9 [Occ=Once] :: t_sdy2M
                                        [LclId] =
                                            [w3_sdEVY a2_sdEW7 a3_sdEW8] \u []
                                                w3_sdEVY a2_sdEW7 a3_sdEW8;
                                      } in  w5_sdEW0 sat_sdEW9;
                            } in  w1_sdEVW lvl3_sdEW3 sat_sdEWa;
                  } in  w_sdEVV lvl3_sdEW3 sat_sdEWb; } in
        let {
          sat_sdEW1 [Occ=Once] :: Text.Read.Lex.Lexeme
          [LclId] =
              CCCS Text.Read.Lex.Ident! [w2_sdEVX];
        } in  Text.Read.Lex.$wexpect sat_sdEW1 sat_sdEWc;

Data.Functor.Classes.readBinaryWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (t -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_sdEWd w1_sdEWe w2_sdEWf w3_sdEWg w4_sdEWh w5_sdEWi]
        case
            Data.Functor.Classes.$wreadBinaryWith
                w_sdEWd w1_sdEWe w2_sdEWf w3_sdEWg w4_sdEWh w5_sdEWi
        of
        { Unit# ww1_sdEWk [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_sdEWk];
        };

Data.Functor.Classes.readBinaryWith
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.ReadPrec t
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readBinaryWith1
            eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$wshowsUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> GHC.Base.String -> GHC.Prim.Int# -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEWl w1_sdEWm ww_sdEWn w2_sdEWo]
        let {
          g_sdEWp [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEWl w2_sdEWo] \u []
                  w_sdEWl Data.Functor.Classes.$fRead1Const1 w2_sdEWo;
        } in 
          case ># [ww_sdEWn 10#] of {
            __DEFAULT ->
                let {
                  sat_sdEWu [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdEWm g_sdEWp] \r [x_sdEWr]
                          let {
                            sat_sdEWs [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdEWp x_sdEWr] \u [] g_sdEWp x_sdEWr; } in
                          let {
                            sat_sdEWt [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEWs];
                          } in  GHC.Base.++ w1_sdEWm sat_sdEWt;
                } in  sat_sdEWu;
            1# ->
                let {
                  sat_sdEWA [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdEWm g_sdEWp] \r [x_sdEWv]
                          let {
                            sat_sdEWz [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w1_sdEWm g_sdEWp x_sdEWv] \u []
                                    let {
                                      sat_sdEWx [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdEWp x_sdEWv] \u []
                                              let {
                                                sat_sdEWw [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdEWv];
                                              } in  g_sdEWp sat_sdEWw; } in
                                    let {
                                      sat_sdEWy [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEWx];
                                    } in  GHC.Base.++ w1_sdEWm sat_sdEWy;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEWz];
                } in  sat_sdEWA;
          };

Data.Functor.Classes.showsUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEWB w1_sdEWC w2_sdEWD w3_sdEWE]
        case w2_sdEWD of {
          GHC.Types.I# ww1_sdEWG [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  w_sdEWB w1_sdEWC ww1_sdEWG w3_sdEWE;
        };

Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Const.Const a b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(C(U)))><L,A><L,A><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdEWH ds_sdEWI ds1_sdEWJ ds2_sdEWK d_sdEWL ds3_sdEWM]
        case d_sdEWL of {
          GHC.Types.I# ww1_sdEWO [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  sp_sdEWH Data.Functor.Classes.$fRead1Const3 ww1_sdEWO ds3_sdEWM;
        };

Data.Functor.Classes.$fShow2Const_$cliftShowList2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [Data.Functor.Const.Const a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,C(C1(C(U)))><L,A><L,A><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp1_sdEWP
           sl1_sdEWQ
           sp2_sdEWR
           sl2_sdEWS
           eta_sdEWT
           eta1_sdEWU]
        let {
          sat_sdEWW [Occ=Once]
            :: Data.Functor.Const.Const a_adwPE b_adwPF -> GHC.Show.ShowS
          [LclId] =
              [sp1_sdEWP] \r [ds_sdEWV]
                  Data.Functor.Classes.$wshowsUnaryWith
                      sp1_sdEWP Data.Functor.Classes.$fRead1Const3 0# ds_sdEWV;
        } in  GHC.Show.showList__ sat_sdEWW eta_sdEWT eta1_sdEWU;

Data.Functor.Classes.$fShow2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2Const_$cliftShowList2];

Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Const.Const a a1
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,A><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdEWX eta_sdEWY eta1_sdEWZ eta2_sdEX0 eta3_sdEX1]
        case eta2_sdEX0 of {
          GHC.Types.I# ww1_sdEX3 [Occ=Once] ->
              let {
                sat_sdEX4 [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_adwP4 -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sdEWX] \s [] GHC.Show.showsPrec $dShow_sdEWX;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sdEX4 Data.Functor.Classes.$fRead1Const3 ww1_sdEX3 eta3_sdEX1;
        };

Data.Functor.Classes.$fShow1Const_$cliftShowList
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> [Data.Functor.Const.Const a a1]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,A><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdEX5 sp_sdEX6 sl_sdEX7 eta_sdEX8 eta1_sdEX9]
        let {
          lvl3_sdEXa [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_adwP4 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEX5] \u [] GHC.Show.showsPrec $dShow_sdEX5; } in
        let {
          sat_sdEXc [Occ=Once]
            :: Data.Functor.Const.Const a_adwP4 a1_adwPn -> GHC.Show.ShowS
          [LclId] =
              [lvl3_sdEXa] \r [eta2_sdEXb]
                  Data.Functor.Classes.$wshowsUnaryWith
                      lvl3_sdEXa Data.Functor.Classes.$fRead1Const3 0# eta2_sdEXb;
        } in  GHC.Show.showList__ sat_sdEXc eta_sdEX8 eta1_sdEX9;

Data.Functor.Classes.$fShow1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Classes.Show1 (Data.Functor.Const.Const a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdEXd]
        let {
          sat_sdEXf [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Const.Const a_adwP4 a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEXd] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Const_$cliftShowList
                      $dShow_sdEXd eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdEXe [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Const.Const a_adwP4 a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEXd] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
                      $dShow_sdEXd eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdEXe sat_sdEXf];

Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Either.Either a b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [sp1_sdEXg ds_sdEXh ds1_sdEXi ds2_sdEXj d_sdEXk ds3_sdEXl]
        case ds3_sdEXl of {
          Data.Either.Left x_sdEXn [Occ=Once] ->
              case d_sdEXk of {
                GHC.Types.I# ww1_sdEXp [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        sp1_sdEXg Data.Functor.Classes.$fRead1Either5 ww1_sdEXp x_sdEXn;
              };
          Data.Either.Right x_sdEXq [Occ=Once] ->
              case d_sdEXk of {
                GHC.Types.I# ww1_sdEXs [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        ds1_sdEXi Data.Functor.Classes.$fRead1Either2 ww1_sdEXs x_sdEXq;
              };
        };

Data.Functor.Classes.$w$cliftShowList4 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> [Data.Either.Either a b]
     -> GHC.Base.String
     -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEXt w1_sdEXu w2_sdEXv w3_sdEXw]
        let {
          sat_sdEXB [Occ=Once]
            :: Data.Either.Either a_sdy38 b_sdy39 -> GHC.Show.ShowS
          [LclId] =
              [w_sdEXt w1_sdEXu] \r [ds_sdEXx]
                  case ds_sdEXx of {
                    Data.Either.Left x_sdEXz [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w_sdEXt Data.Functor.Classes.$fRead1Either5 0# x_sdEXz;
                    Data.Either.Right x_sdEXA [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w1_sdEXu Data.Functor.Classes.$fRead1Either2 0# x_sdEXA;
                  };
        } in  GHC.Show.showList__ sat_sdEXB w2_sdEXv w3_sdEXw;

Data.Functor.Classes.$fShow2Either_$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [Data.Either.Either a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,C(C1(C(U)))><L,A><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEXC w1_sdEXD w2_sdEXE w3_sdEXF w4_sdEXG w5_sdEXH]
        Data.Functor.Classes.$w$cliftShowList4
            w_sdEXC w2_sdEXE w4_sdEXG w5_sdEXH;

Data.Functor.Classes.$fShow2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 Data.Either.Either
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2Either_$cliftShowList2];

Data.Functor.Classes.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> GHC.Prim.Int# -> Data.Either.Either a a1 -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdEXI w1_sdEXJ ww_sdEXK w2_sdEXL]
        case w2_sdEXL of {
          Data.Either.Left x_sdEXN [Occ=Once] ->
              let {
                sat_sdEXO [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_sdy3h -> GHC.Show.ShowS
                [LclId] =
                    [w_sdEXI] \s [] GHC.Show.showsPrec w_sdEXI;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sdEXO Data.Functor.Classes.$fRead1Either5 ww_sdEXK x_sdEXN;
          Data.Either.Right x_sdEXP [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  w1_sdEXJ Data.Functor.Classes.$fRead1Either2 ww_sdEXK x_sdEXP;
        };

Data.Functor.Classes.$fShow1Either_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Either.Either a a1
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdEXQ w1_sdEXR w2_sdEXS w3_sdEXT w4_sdEXU]
        case w3_sdEXT of {
          GHC.Types.I# ww1_sdEXW [Occ=Once] ->
              Data.Functor.Classes.$w$cliftShowsPrec
                  w_sdEXQ w1_sdEXR ww1_sdEXW w4_sdEXU;
        };

Data.Functor.Classes.$w$cliftShowList1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> [Data.Either.Either a a1] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEXX w1_sdEXY w2_sdEXZ w3_sdEY0]
        let {
          lvl3_sdEY1 [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_sdy3t -> GHC.Show.ShowS
          [LclId] =
              [w_sdEXX] \u [] GHC.Show.showsPrec w_sdEXX; } in
        let {
          sat_sdEY6 [Occ=Once]
            :: Data.Either.Either a_sdy3t a1_sdy3v -> GHC.Show.ShowS
          [LclId] =
              [w1_sdEXY lvl3_sdEY1] \r [eta_sdEY2]
                  case eta_sdEY2 of {
                    Data.Either.Left x_sdEY4 [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            lvl3_sdEY1 Data.Functor.Classes.$fRead1Either5 0# x_sdEY4;
                    Data.Either.Right x_sdEY5 [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w1_sdEXY Data.Functor.Classes.$fRead1Either2 0# x_sdEY5;
                  };
        } in  GHC.Show.showList__ sat_sdEY6 w2_sdEXZ w3_sdEY0;

Data.Functor.Classes.$fShow1Either_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> [Data.Either.Either a a1]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEY7 w1_sdEY8 w2_sdEY9 w3_sdEYa w4_sdEYb]
        Data.Functor.Classes.$w$cliftShowList1
            w_sdEY7 w1_sdEY8 w3_sdEYa w4_sdEYb;

Data.Functor.Classes.$fShow1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Classes.Show1 (Data.Either.Either a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdEYc]
        let {
          sat_sdEYi [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Either.Either a_adwPN a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEYc] \r [w_sdEYe w1_sdEYf w2_sdEYg w3_sdEYh]
                  Data.Functor.Classes.$w$cliftShowList1
                      $dShow_sdEYc w_sdEYe w2_sdEYg w3_sdEYh; } in
        let {
          sat_sdEYd [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Either.Either a_adwPN a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEYc] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Either_$cliftShowsPrec
                      $dShow_sdEYc eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdEYd sat_sdEYi];

Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Identity.Identity a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdEYj ds_sdEYk d_sdEYl ds1_sdEYm]
        case d_sdEYl of {
          GHC.Types.I# ww1_sdEYo [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  sp_sdEYj Data.Functor.Classes.$fRead1Identity3 ww1_sdEYo ds1_sdEYm;
        };

Data.Functor.Classes.$fShow1Identity_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Identity.Identity a]
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdEYp sl_sdEYq eta_sdEYr eta1_sdEYs]
        let {
          sat_sdEYu [Occ=Once]
            :: Data.Functor.Identity.Identity a_adwZV -> GHC.Show.ShowS
          [LclId] =
              [sp_sdEYp] \r [ds_sdEYt]
                  Data.Functor.Classes.$wshowsUnaryWith
                      sp_sdEYp Data.Functor.Classes.$fRead1Identity3 0# ds_sdEYt;
        } in  GHC.Show.showList__ sat_sdEYu eta_sdEYr eta1_sdEYs;

Data.Functor.Classes.$fShow1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Identity_$cliftShowList];

Data.Functor.Classes.$fShow1Maybe1
  :: [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Base.++ Data.Functor.Classes.$fRead1Maybe6 eta_B1;

Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> GHC.Base.Maybe a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdEYv ds1_sdEYw ds2_sdEYx ds3_sdEYy]
        case ds3_sdEYy of {
          GHC.Base.Nothing -> Data.Functor.Classes.$fShow1Maybe1;
          GHC.Base.Just x_sdEYA [Occ=Once] ->
              case ds2_sdEYx of {
                GHC.Types.I# ww1_sdEYC [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        ds_sdEYv Data.Functor.Classes.$fRead1Maybe3 ww1_sdEYC x_sdEYA;
              };
        };

Data.Functor.Classes.$w$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> [GHC.Base.Maybe a] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=3,
 Str=<L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEYD w1_sdEYE w2_sdEYF]
        let {
          sat_sdEYJ [Occ=Once] :: GHC.Base.Maybe a_sdy3B -> GHC.Show.ShowS
          [LclId] =
              [w_sdEYD] \r [ds_sdEYG]
                  case ds_sdEYG of {
                    GHC.Base.Nothing -> Data.Functor.Classes.$fShow1Maybe1;
                    GHC.Base.Just x_sdEYI [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w_sdEYD Data.Functor.Classes.$fRead1Maybe3 0# x_sdEYI;
                  };
        } in  GHC.Show.showList__ sat_sdEYJ w1_sdEYE w2_sdEYF;

Data.Functor.Classes.$fShow1Maybe_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [GHC.Base.Maybe a] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEYK w1_sdEYL w2_sdEYM w3_sdEYN]
        Data.Functor.Classes.$w$cliftShowList2 w_sdEYK w2_sdEYM w3_sdEYN;

Data.Functor.Classes.$fShow1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Maybe_$cliftShowList];

Data.Functor.Classes.$wshowsBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> GHC.Base.String
     -> GHC.Prim.Int#
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEYO w1_sdEYP w2_sdEYQ ww_sdEYR w3_sdEYS w4_sdEYT]
        let {
          f_sdEYU [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEYO w3_sdEYS] \u []
                  w_sdEYO Data.Functor.Classes.$fRead1Const1 w3_sdEYS; } in
        let {
          g_sdEYV [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdEYP w4_sdEYT] \u []
                  w1_sdEYP Data.Functor.Classes.$fRead1Const1 w4_sdEYT;
        } in 
          case ># [ww_sdEYR 10#] of {
            __DEFAULT ->
                let {
                  sat_sdEZ2 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdEYQ f_sdEYU g_sdEYV] \r [x_sdEYX]
                          let {
                            sat_sdEZ0 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sdEYU g_sdEYV x_sdEYX] \u []
                                    let {
                                      sat_sdEYY [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdEYV x_sdEYX] \u [] g_sdEYV x_sdEYX; } in
                                    let {
                                      sat_sdEYZ [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEYY];
                                    } in  f_sdEYU sat_sdEYZ; } in
                          let {
                            sat_sdEZ1 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEZ0];
                          } in  GHC.Base.++ w2_sdEYQ sat_sdEZ1;
                } in  sat_sdEZ2;
            1# ->
                let {
                  sat_sdEZa [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdEYQ f_sdEYU g_sdEYV] \r [x_sdEZ3]
                          let {
                            sat_sdEZ9 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w2_sdEYQ f_sdEYU g_sdEYV x_sdEZ3] \u []
                                    let {
                                      sat_sdEZ7 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sdEYU g_sdEYV x_sdEZ3] \u []
                                              let {
                                                sat_sdEZ5 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sdEYV x_sdEZ3] \u []
                                                        let {
                                                          sat_sdEZ4 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdEZ3];
                                                        } in  g_sdEYV sat_sdEZ4; } in
                                              let {
                                                sat_sdEZ6 [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [Data.Functor.Classes.showsUnaryWith1
                                                             sat_sdEZ5];
                                              } in  f_sdEYU sat_sdEZ6; } in
                                    let {
                                      sat_sdEZ8 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEZ7];
                                    } in  GHC.Base.++ w2_sdEYQ sat_sdEZ8;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEZ9];
                } in  sat_sdEZa;
          };

Data.Functor.Classes.showsBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> GHC.Base.String
     -> GHC.Types.Int
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><S(S),1*U(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEZb w1_sdEZc w2_sdEZd w3_sdEZe w4_sdEZf w5_sdEZg]
        case w3_sdEZe of {
          GHC.Types.I# ww1_sdEZi [Occ=Once] ->
              Data.Functor.Classes.$wshowsBinaryWith
                  w_sdEZb w1_sdEZc w2_sdEZd ww1_sdEZi w4_sdEZf w5_sdEZg;
        };

Data.Functor.Classes.readsUnary
  :: forall a t.
     GHC.Read.Read a =>
     GHC.Base.String
     -> (a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A,A)><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdEZj name_sdEZk cons_sdEZl kw_sdEZm s_sdEZn]
        case GHC.Base.eqString kw_sdEZm name_sdEZk of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdEZp [Occ=LoopBreaker]
                  :: [(a_adwFr, GHC.Base.String)] -> [(t_adwFs, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdEZl go_sdEZp] \r [ds_sdEZq]
                        case ds_sdEZq of {
                          [] -> [] [];
                          : y_sdEZs [Occ=Once!] ys_sdEZt [Occ=Once] ->
                              case y_sdEZs of {
                                (,) x_sdEZv [Occ=Once] t1_sdEZw [Occ=Once] ->
                                    let {
                                      sat_sdEZz [Occ=Once] :: [(t_adwFs, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdEZp ys_sdEZt] \u [] go_sdEZp ys_sdEZt; } in
                                    let {
                                      sat_sdEZx [Occ=Once] :: t_adwFs
                                      [LclId] =
                                          [cons_sdEZl x_sdEZv] \u [] cons_sdEZl x_sdEZv; } in
                                    let {
                                      sat_sdEZy [Occ=Once] :: (t_adwFs, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdEZx t1_sdEZw];
                                    } in  : [sat_sdEZy sat_sdEZz];
                              };
                        };
              } in 
                case
                    GHC.Read.readsPrec
                        $dRead_sdEZj Data.Functor.Classes.$fRead1Const1 s_sdEZn
                of
                sat_sdEZA
                { __DEFAULT -> go_sdEZp sat_sdEZA;
                };
        };

Data.Functor.Classes.$wshowsUnary [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Base.String -> GHC.Prim.Int# -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEZB w1_sdEZC ww_sdEZD w2_sdEZE]
        let {
          g_sdEZF [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEZB w2_sdEZE] \u []
                  GHC.Show.showsPrec
                      w_sdEZB Data.Functor.Classes.$fRead1Const1 w2_sdEZE;
        } in 
          case ># [ww_sdEZD 10#] of {
            __DEFAULT ->
                let {
                  sat_sdEZK [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdEZC g_sdEZF] \r [x_sdEZH]
                          let {
                            sat_sdEZI [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdEZF x_sdEZH] \u [] g_sdEZF x_sdEZH; } in
                          let {
                            sat_sdEZJ [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEZI];
                          } in  GHC.Base.++ w1_sdEZC sat_sdEZJ;
                } in  sat_sdEZK;
            1# ->
                let {
                  sat_sdEZQ [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdEZC g_sdEZF] \r [x_sdEZL]
                          let {
                            sat_sdEZP [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w1_sdEZC g_sdEZF x_sdEZL] \u []
                                    let {
                                      sat_sdEZN [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdEZF x_sdEZL] \u []
                                              let {
                                                sat_sdEZM [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdEZL];
                                              } in  g_sdEZF sat_sdEZM; } in
                                    let {
                                      sat_sdEZO [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEZN];
                                    } in  GHC.Base.++ w1_sdEZC sat_sdEZO;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEZP];
                } in  sat_sdEZQ;
          };

Data.Functor.Classes.showsUnary [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEZR w1_sdEZS w2_sdEZT w3_sdEZU]
        case w2_sdEZT of {
          GHC.Types.I# ww1_sdEZW [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnary
                  w_sdEZR w1_sdEZS ww1_sdEZW w3_sdEZU;
        };

Data.Functor.Classes.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Classes.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$trModule4];

Data.Functor.Classes.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Classes"#;

Data.Functor.Classes.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$trModule2];

Data.Functor.Classes.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Classes.$trModule3
                                     Data.Functor.Classes.$trModule1];

$krep_rdymB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Functor.Classes.$tcEq4 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rdymB];

Data.Functor.Classes.$tcEq7 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdymB];

Data.Functor.Classes.$tcEq6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Eq1"#;

Data.Functor.Classes.$tcEq5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcEq6];

Data.Functor.Classes.$tcEq1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [71749974434880567##
                                    7233443027070644957##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcEq5
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcOrd5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ord1"#;

Data.Functor.Classes.$tcOrd4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcOrd5];

Data.Functor.Classes.$tcOrd1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11825914698899667233##
                                    4554948325937498991##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcOrd4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcRead5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Read1"#;

Data.Functor.Classes.$tcRead4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcRead5];

Data.Functor.Classes.$tcRead1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14547308444716217043##
                                    925634574698086715##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcRead4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcShow5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Show1"#;

Data.Functor.Classes.$tcShow4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcShow5];

Data.Functor.Classes.$tcShow1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4743290066722511112##
                                    6779909240154408836##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcShow4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcEq9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Eq2"#;

Data.Functor.Classes.$tcEq8 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcEq9];

Data.Functor.Classes.$tcEq2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16920549266159426738##
                                    13264288076834164909##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcEq8
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcOrd7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ord2"#;

Data.Functor.Classes.$tcOrd6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcOrd7];

Data.Functor.Classes.$tcOrd2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4167316048525678806##
                                    17649124474771181823##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcOrd6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcRead7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Read2"#;

Data.Functor.Classes.$tcRead6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcRead7];

Data.Functor.Classes.$tcRead2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [615267248700376470##
                                    8978126042197021701##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcRead6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcShow7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Show2"#;

Data.Functor.Classes.$tcShow6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcShow7];

Data.Functor.Classes.$tcShow2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11321900378419812635##
                                    1323607160578303441##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcShow6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.C:Show2
  :: forall (f :: * -> * -> *).
     (forall a b.
      (GHC.Types.Int -> a -> GHC.Show.ShowS)
      -> ([a] -> GHC.Show.ShowS)
      -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
      -> ([b] -> GHC.Show.ShowS)
      -> GHC.Types.Int
      -> f a b
      -> GHC.Show.ShowS)
     -> (forall a b.
         (GHC.Types.Int -> a -> GHC.Show.ShowS)
         -> ([a] -> GHC.Show.ShowS)
         -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
         -> ([b] -> GHC.Show.ShowS)
         -> [f a b]
         -> GHC.Show.ShowS)
     -> Data.Functor.Classes.Show2 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Show2 [eta_B2 eta_B1];

Data.Functor.Classes.C:Read2
  :: forall (f :: * -> * -> *).
     (forall a b.
      (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
      -> Text.ParserCombinators.ReadP.ReadS [a]
      -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
      -> Text.ParserCombinators.ReadP.ReadS [b]
      -> GHC.Types.Int
      -> Text.ParserCombinators.ReadP.ReadS (f a b))
     -> (forall a b.
         (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
         -> Text.ParserCombinators.ReadP.ReadS [a]
         -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
         -> Text.ParserCombinators.ReadP.ReadS [b]
         -> Text.ParserCombinators.ReadP.ReadS [f a b])
     -> (forall a b.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec b
         -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
         -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b))
     -> (forall a b.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec b
         -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
         -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b])
     -> Data.Functor.Classes.Read2 f
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.C:Read2 [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Functor.Classes.C:Ord2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Eq2 f =>
     (forall a b c d.
      (a -> b -> GHC.Types.Ordering)
      -> (c -> d -> GHC.Types.Ordering)
      -> f a c
      -> f b d
      -> GHC.Types.Ordering)
     -> Data.Functor.Classes.Ord2 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Ord2 [eta_B2 eta_B1];

Data.Functor.Classes.C:Show1
  :: forall (f :: * -> *).
     (forall a.
      (GHC.Types.Int -> a -> GHC.Show.ShowS)
      -> ([a] -> GHC.Show.ShowS)
      -> GHC.Types.Int
      -> f a
      -> GHC.Show.ShowS)
     -> (forall a.
         (GHC.Types.Int -> a -> GHC.Show.ShowS)
         -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS)
     -> Data.Functor.Classes.Show1 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Show1 [eta_B2 eta_B1];

Data.Functor.Classes.C:Read1
  :: forall (f :: * -> *).
     (forall a.
      (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
      -> Text.ParserCombinators.ReadP.ReadS [a]
      -> GHC.Types.Int
      -> Text.ParserCombinators.ReadP.ReadS (f a))
     -> (forall a.
         (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
         -> Text.ParserCombinators.ReadP.ReadS [a]
         -> Text.ParserCombinators.ReadP.ReadS [f a])
     -> (forall a.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec (f a))
     -> (forall a.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec [f a])
     -> Data.Functor.Classes.Read1 f
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.C:Read1 [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Functor.Classes.C:Ord1
  :: forall (f :: * -> *).
     Data.Functor.Classes.Eq1 f =>
     (forall a b.
      (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering)
     -> Data.Functor.Classes.Ord1 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Ord1 [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:08:53.78546009 UTC

Data.Functor.Classes.liftShowsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> f a b
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdEzz]
        case v_sdEzz of {
          Data.Functor.Classes.C:Show2 v_sdEzB [Occ=Once] _ [Occ=Dead] ->
              v_sdEzB;
        };

Data.Functor.Classes.liftShowList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [f a b]
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdEzD]
        case v_sdEzD of {
          Data.Functor.Classes.C:Show2 _ [Occ=Dead] v_sdEzG [Occ=Once] ->
              v_sdEzG;
        };

Data.Functor.Classes.liftReadsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdEzH]
        case v_sdEzH of {
          Data.Functor.Classes.C:Read2 v_sdEzJ [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdEzJ;
        };

Data.Functor.Classes.liftReadList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdEzN]
        case v_sdEzN of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       v_sdEzQ [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdEzQ;
        };

Data.Functor.Classes.liftReadPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdEzT]
        case v_sdEzT of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdEzX [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdEzX;
        };

Data.Functor.Classes.liftReadListPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdEzZ]
        case v_sdEzZ of {
          Data.Functor.Classes.C:Read2 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdEA4 [Occ=Once] ->
              v_sdEA4;
        };

Data.Functor.Classes.$p1Ord2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Ord2 f =>
     Data.Functor.Classes.Eq2 f
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdEA5]
        case v_sdEA5 of {
          Data.Functor.Classes.C:Ord2 v_sdEA7 [Occ=Once] _ [Occ=Dead] ->
              v_sdEA7;
        };

Data.Functor.Classes.liftCompare2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Ord2 f =>
     forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> f a c
     -> f b d
     -> GHC.Types.Ordering
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdEA9]
        case v_sdEA9 of {
          Data.Functor.Classes.C:Ord2 _ [Occ=Dead] v_sdEAc [Occ=Once] ->
              v_sdEAc;
        };

Data.Functor.Classes.liftEq2 [InlPrag=INLINE]
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Eq2 f =>
     forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool) -> f a c -> f b d -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sdEAd] v_sdEAd;

Data.Functor.Classes.liftShowsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> f a
     -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdEAe]
        case v_sdEAe of {
          Data.Functor.Classes.C:Show1 v_sdEAg [Occ=Once] _ [Occ=Dead] ->
              v_sdEAg;
        };

Data.Functor.Classes.liftShowList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdEAi]
        case v_sdEAi of {
          Data.Functor.Classes.C:Show1 _ [Occ=Dead] v_sdEAl [Occ=Once] ->
              v_sdEAl;
        };

Data.Functor.Classes.liftReadsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdEAm]
        case v_sdEAm of {
          Data.Functor.Classes.C:Read1 v_sdEAo [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdEAo;
        };

Data.Functor.Classes.liftReadList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdEAs]
        case v_sdEAs of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       v_sdEAv [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdEAv;
        };

Data.Functor.Classes.liftReadPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdEAy]
        case v_sdEAy of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdEAC [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdEAC;
        };

Data.Functor.Classes.liftReadListPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdEAE]
        case v_sdEAE of {
          Data.Functor.Classes.C:Read1 _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdEAJ [Occ=Once] ->
              v_sdEAJ;
        };

Data.Functor.Classes.$p1Ord1
  :: forall (f :: * -> *).
     Data.Functor.Classes.Ord1 f =>
     Data.Functor.Classes.Eq1 f
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sdEAK]
        case v_sdEAK of {
          Data.Functor.Classes.C:Ord1 v_sdEAM [Occ=Once] _ [Occ=Dead] ->
              v_sdEAM;
        };

Data.Functor.Classes.liftCompare
  :: forall (f :: * -> *).
     Data.Functor.Classes.Ord1 f =>
     forall a b.
     (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sdEAO]
        case v_sdEAO of {
          Data.Functor.Classes.C:Ord1 _ [Occ=Dead] v_sdEAR [Occ=Once] ->
              v_sdEAR;
        };

Data.Functor.Classes.liftEq [InlPrag=INLINE]
  :: forall (f :: * -> *).
     Data.Functor.Classes.Eq1 f =>
     forall a b.
     (a -> b -> GHC.Types.Bool) -> f a -> f b -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sdEAS] v_sdEAS;

Data.Functor.Classes.$fRead1Const1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Functor.Classes.$fRead1Const4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Const"#;

Data.Functor.Classes.$fRead1Const3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Const4;

Data.Functor.Classes.$fRead1Const2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Const3];

Data.Functor.Classes.$w$cliftReadPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Functor.Const.Const a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEAT w1_sdEAU w2_sdEAV]
        let {
          sat_sdEB7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_sdxVk b_sdxVl)
          [LclId] =
              [w_sdEAT] \r [c_sdEAW eta_sdEAX]
                  case c_sdEAW of {
                    GHC.Types.I# x_sdEAZ [Occ=Once] ->
                        case <=# [x_sdEAZ 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdEB4 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_X81aZ
                                [LclId] =
                                    [w_sdEAT eta_sdEAX] \r [a1_sdEB1]
                                        let {
                                          sat_sdEB3 [Occ=Once]
                                            :: a_sdxVk -> Text.ParserCombinators.ReadP.P b2_X81aZ
                                          [LclId] =
                                              [eta_sdEAX] \r [a2_sdEB2] eta_sdEAX a2_sdEB2;
                                        } in  w_sdEAT Data.Functor.Classes.$fRead1Const1 sat_sdEB3;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Const2 sat_sdEB4
                                of
                                { Unit# ww1_sdEB6 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sdEB6];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdEB7 w1_sdEAU w2_sdEAV;

Data.Functor.Classes.$fRead1Const6 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Functor.Const.Const a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,A><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEB8 w1_sdEB9 w2_sdEBa w3_sdEBb w4_sdEBc w5_sdEBd]
        Data.Functor.Classes.$w$cliftReadPrec1 w_sdEB8 w4_sdEBc w5_sdEBd;

Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Const.Const a b]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdEBe rl1_sdEBf rp2_sdEBg rl2_sdEBh]
        let {
          sat_sdEBk [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_adwSL b_adwSM)
          [LclId] =
              [rp1_sdEBe] \r [w_sdEBi w1_sdEBj]
                  Data.Functor.Classes.$w$cliftReadPrec1 rp1_sdEBe w_sdEBi w1_sdEBj;
        } in  GHC.Read.list sat_sdEBk;

Data.Functor.Classes.$w$cliftReadsPrec7 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a b)
[GblId, Arity=2, Str=<L,1*C1(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEBl w1_sdEBm]
        let {
          sat_sdEBC [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Const.Const a_sdxVu b_sdxVv)
          [LclId] =
              [w_sdEBl w1_sdEBm] \u []
                  let {
                    lvl3_sdEBn [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS a_sdxVu
                    [LclId] =
                        [w_sdEBl] \u [] w_sdEBl Data.Functor.Classes.$fRead1Const1; } in
                  let {
                    sat_sdEBB [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Const.Const a_sdxVu b_sdxVv)
                    [LclId] =
                        [lvl3_sdEBn] \r [c_sdEBo eta_sdEBp]
                            case c_sdEBo of {
                              GHC.Types.I# x_sdEBr [Occ=Once] ->
                                  case <=# [x_sdEBr 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdEBy [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [lvl3_sdEBn eta_sdEBp] \r [a1_sdEBt]
                                                  let {
                                                    sat_sdEBv [Occ=Once]
                                                      :: a_sdxVu
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta_sdEBp] \r [a2_sdEBu]
                                                            eta_sdEBp a2_sdEBu;
                                                  } in 
                                                    case
                                                        Text.ParserCombinators.ReadP.$wreadS_to_P
                                                            lvl3_sdEBn sat_sdEBv
                                                    of
                                                    { Unit# ww1_sdEBx [Occ=Once] ->
                                                          Text.ParserCombinators.ReadP.Look [ww1_sdEBx];
                                                    };
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Const2 sat_sdEBy
                                          of
                                          { Unit# ww1_sdEBA [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdEBA];
                                          };
                                  };
                            };
                  } in 
                    GHC.Read.list3
                        sat_sdEBB
                        w1_sdEBm
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEBC;

Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a b)
[GblId,
 Arity=5,
 Str=<L,1*C1(C(U))><L,A><L,A><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEBD w1_sdEBE w2_sdEBF w3_sdEBG w4_sdEBH]
        Data.Functor.Classes.$w$cliftReadsPrec7 w_sdEBD w4_sdEBH;

Data.Functor.Classes.$fRead1Either3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right"#;

Data.Functor.Classes.$fRead1Either2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Either3;

Data.Functor.Classes.$fRead1Either1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Either2];

Data.Functor.Classes.$fRead1Either6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left"#;

Data.Functor.Classes.$fRead1Either5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Either6;

Data.Functor.Classes.$fRead1Either4 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Either5];

Data.Functor.Classes.$w$cliftReadPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEBI w1_sdEBJ w2_sdEBK w3_sdEBL]
        let {
          sat_sdEC7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_sdxVC b_sdxVD)
          [LclId] =
              [w_sdEBI w1_sdEBJ] \r [c_sdEBM eta_sdEBN]
                  case c_sdEBM of {
                    GHC.Types.I# x_sdEBP [Occ=Once] ->
                        case <=# [x_sdEBP 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdEBV [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                [LclId] =
                                    [w_sdEBI eta_sdEBN] \r [a1_sdEBR]
                                        let {
                                          sat_sdEBU [Occ=Once]
                                            :: a_sdxVC -> Text.ParserCombinators.ReadP.P b2_i815E
                                          [LclId] =
                                              [eta_sdEBN] \r [a2_sdEBS]
                                                  let {
                                                    sat_sdEBT [Occ=Once]
                                                      :: Data.Either.Either a_sdxVC b_sdxVD
                                                    [LclId] =
                                                        CCCS Data.Either.Left! [a2_sdEBS];
                                                  } in  eta_sdEBN sat_sdEBT;
                                        } in  w_sdEBI Data.Functor.Classes.$fRead1Const1 sat_sdEBU;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Either4 sat_sdEBV
                                of
                                { Unit# ww1_sdEBX [Occ=Once] ->
                                      let {
                                        sat_sdEC6 [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b2_i815E
                                        [LclId] =
                                            [w1_sdEBJ eta_sdEBN] \u []
                                                let {
                                                  sat_sdEC3 [Occ=Once]
                                                    :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                                  [LclId] =
                                                      [w1_sdEBJ eta_sdEBN] \r [a1_sdEBZ]
                                                          let {
                                                            sat_sdEC2 [Occ=Once]
                                                              :: b_sdxVD
                                                                 -> Text.ParserCombinators.ReadP.P
                                                                      b2_i815E
                                                            [LclId] =
                                                                [eta_sdEBN] \r [a2_sdEC0]
                                                                    let {
                                                                      sat_sdEC1 [Occ=Once]
                                                                        :: Data.Either.Either
                                                                             a_sdxVC b_sdxVD
                                                                      [LclId] =
                                                                          CCCS Data.Either.Right! [a2_sdEC0];
                                                                    } in  eta_sdEBN sat_sdEC1;
                                                          } in 
                                                            w1_sdEBJ
                                                                Data.Functor.Classes.$fRead1Const1
                                                                sat_sdEC2;
                                                } in 
                                                  case
                                                      Text.Read.Lex.$wexpect
                                                          Data.Functor.Classes.$fRead1Either1
                                                          sat_sdEC3
                                                  of
                                                  { Unit# ww3_sdEC5 [Occ=Once] ->
                                                        Text.ParserCombinators.ReadP.Look [ww3_sdEC5];
                                                  }; } in
                                      let {
                                        sat_sdEBY [Occ=Once]
                                          :: Text.ParserCombinators.ReadP.P b2_i815E
                                        [LclId] =
                                            CCCS Text.ParserCombinators.ReadP.Look! [ww1_sdEBX];
                                      } in 
                                        Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                            sat_sdEBY sat_sdEC6;
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdEC7 w2_sdEBK w3_sdEBL;

Data.Functor.Classes.$fRead1Either8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEC8 w1_sdEC9 w2_sdECa w3_sdECb w4_sdECc w5_sdECd]
        Data.Functor.Classes.$w$cliftReadPrec3
            w_sdEC8 w2_sdECa w4_sdECc w5_sdECd;

Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a b]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdECe rl1_sdECf rp2_sdECg rl2_sdECh]
        let {
          sat_sdECk [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_adwUm b_adwUn)
          [LclId] =
              [rp1_sdECe rp2_sdECg] \r [w_sdECi w1_sdECj]
                  Data.Functor.Classes.$w$cliftReadPrec3
                      rp1_sdECe rp2_sdECg w_sdECi w1_sdECj;
        } in  GHC.Read.list sat_sdECk;

Data.Functor.Classes.$w$cliftReadsPrec8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdECl w1_sdECm w2_sdECn]
        let {
          sat_sdECq [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_sdxVM b_sdxVN)
          [LclId] =
              [w_sdECl w1_sdECm w2_sdECn] \u []
                  let {
                    sat_sdECp [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_sdxVN
                    [LclId] =
                        [w1_sdECm] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdECm eta_B1; } in
                  let {
                    sat_sdECo [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdxVM
                    [LclId] =
                        [w_sdECl] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdECl eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec3
                        sat_sdECo
                        sat_sdECp
                        w2_sdECn
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdECq;

Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=5,
 Str=<L,C(C(U))><L,A><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdECr w1_sdECs w2_sdECt w3_sdECu w4_sdECv]
        Data.Functor.Classes.$w$cliftReadsPrec8 w_sdECr w2_sdECt w4_sdECv;

Data.Functor.Classes.$fEq1Maybe_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdECw ds1_sdECx ds2_sdECy]
        case ds1_sdECx of {
          GHC.Base.Nothing ->
              case ds2_sdECy of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just ds3_sdECC [Occ=Once] ->
              case ds2_sdECy of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just y_sdECE [Occ=Once] -> ds_sdECw ds3_sdECC y_sdECE;
              };
        };

Data.Functor.Classes.$fEq1Maybe [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 GHC.Base.Maybe
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Maybe_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1 [Occ=LoopBreaker]
  :: forall a b.
     (a -> b -> GHC.Types.Bool) -> [a] -> [b] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdECF ds1_sdECG ds2_sdECH]
        case ds1_sdECG of {
          [] ->
              case ds2_sdECH of {
                [] -> GHC.Types.True [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
              };
          : ds3_sdECM [Occ=Once] ds4_sdECN [Occ=Once] ->
              case ds2_sdECH of {
                [] -> GHC.Types.False [];
                : y_sdECP [Occ=Once] ys_sdECQ [Occ=Once] ->
                    case ds_sdECF ds3_sdECM y_sdECP of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True ->
                          Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                              ds_sdECF ds4_sdECN ys_sdECQ;
                    };
              };
        };

Data.Functor.Classes.$fEq1[] [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 []
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$w$cliftEq [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> a -> [a] -> b -> [b] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdECS ww_sdECT ww1_sdECU ww2_sdECV ww3_sdECW]
        case w_sdECS ww_sdECT ww2_sdECV of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                  w_sdECS ww1_sdECU ww3_sdECW;
        };

Data.Functor.Classes.$fEq1NonEmpty_$cliftEq [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdECY w1_sdECZ w2_sdED0]
        case w1_sdECZ of {
          GHC.Base.:| ww1_sdED2 [Occ=Once] ww2_sdED3 [Occ=Once] ->
              case w2_sdED0 of {
                GHC.Base.:| ww4_sdED5 [Occ=Once] ww5_sdED6 [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftEq
                        w_sdECY ww1_sdED2 ww2_sdED3 ww4_sdED5 ww5_sdED6;
              };
        };

Data.Functor.Classes.$fEq1NonEmpty [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 GHC.Base.NonEmpty
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1NonEmpty_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Identity_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eq_sdED7 ds_sdED8 ds1_sdED9] eq_sdED7 ds_sdED8 ds1_sdED9;

Data.Functor.Classes.$fEq1Identity [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 Data.Functor.Identity.Identity
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Identity_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Proxy_$cliftEq
  :: forall a b.
     (a -> b -> GHC.Types.Bool)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdEDa ds1_sdEDb ds2_sdEDc] GHC.Types.True [];

Data.Functor.Classes.$fEq1Proxy [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq1 Data.Proxy.Proxy
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Proxy_$cliftEq eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fOrd1Maybe_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdEDd ds1_sdEDe ds2_sdEDf]
        case ds1_sdEDe of {
          GHC.Base.Nothing ->
              case ds2_sdEDf of {
                GHC.Base.Nothing -> GHC.Types.EQ [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.LT [];
              };
          GHC.Base.Just ds3_sdEDj [Occ=Once] ->
              case ds2_sdEDf of {
                GHC.Base.Nothing -> GHC.Types.GT [];
                GHC.Base.Just y_sdEDl [Occ=Once] -> ds_sdEDd ds3_sdEDj y_sdEDl;
              };
        };

Data.Functor.Classes.$fOrd1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Maybe_$cliftEq
                                                Data.Functor.Classes.$fOrd1Maybe_$cliftCompare];

Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1 [Occ=LoopBreaker]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering) -> [a] -> [b] -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdEDm ds1_sdEDn ds2_sdEDo]
        case ds1_sdEDn of {
          [] ->
              case ds2_sdEDo of {
                [] -> GHC.Types.EQ [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.LT [];
              };
          : ds3_sdEDt [Occ=Once] ds4_sdEDu [Occ=Once] ->
              case ds2_sdEDo of {
                [] -> GHC.Types.GT [];
                : y_sdEDw [Occ=Once] ys_sdEDx [Occ=Once] ->
                    case ds_sdEDm ds3_sdEDt y_sdEDw of {
                      GHC.Types.LT -> GHC.Types.LT [];
                      GHC.Types.EQ ->
                          Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
                              ds_sdEDm ds4_sdEDu ys_sdEDx;
                      GHC.Types.GT -> GHC.Types.GT [];
                    };
              };
        };

Data.Functor.Classes.$fOrd1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1NonEmpty_$cliftEq1
                                                Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1];

Data.Functor.Classes.$w$cliftCompare1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> a -> [a] -> b -> [b] -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdEDz ww_sdEDA ww1_sdEDB ww2_sdEDC ww3_sdEDD]
        case w_sdEDz ww_sdEDA ww2_sdEDC of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare1
                  w_sdEDz ww1_sdEDB ww3_sdEDD;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEDF w1_sdEDG w2_sdEDH]
        case w1_sdEDG of {
          GHC.Base.:| ww1_sdEDJ [Occ=Once] ww2_sdEDK [Occ=Once] ->
              case w2_sdEDH of {
                GHC.Base.:| ww4_sdEDM [Occ=Once] ww5_sdEDN [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftCompare1
                        w_sdEDF ww1_sdEDJ ww2_sdEDK ww4_sdEDM ww5_sdEDN;
              };
        };

Data.Functor.Classes.$fOrd1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1NonEmpty_$cliftEq
                                                Data.Functor.Classes.$fOrd1NonEmpty_$cliftCompare];

Data.Functor.Classes.$fOrd1Identity_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Functor.Identity.Identity a
     -> Data.Functor.Identity.Identity b
     -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [comp_sdEDO ds_sdEDP ds1_sdEDQ]
        comp_sdEDO ds_sdEDP ds1_sdEDQ;

Data.Functor.Classes.$fOrd1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 Data.Functor.Identity.Identity
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Identity_$cliftEq
                                                Data.Functor.Classes.$fOrd1Identity_$cliftCompare];

Data.Functor.Classes.$fOrd1Proxy_$cliftCompare
  :: forall a b.
     (a -> b -> GHC.Types.Ordering)
     -> Data.Proxy.Proxy a -> Data.Proxy.Proxy b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdEDR ds1_sdEDS ds2_sdEDT] GHC.Types.EQ [];

Data.Functor.Classes.$fOrd1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord1 Data.Proxy.Proxy
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord1! [Data.Functor.Classes.$fEq1Proxy_$cliftEq
                                                Data.Functor.Classes.$fOrd1Proxy_$cliftCompare];

Data.Functor.Classes.$fRead1[]_$cliftReadPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdEDU rl_sdEDV] rl_sdEDV;

Data.Functor.Classes.$fRead1NonEmpty4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":|"#;

Data.Functor.Classes.$fRead1NonEmpty3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1NonEmpty4;

Data.Functor.Classes.$fRead1NonEmpty2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [6#];

Data.Functor.Classes.$w$cliftReadsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Prim.Int#
     -> GHC.Base.String
     -> [(GHC.Base.NonEmpty a, GHC.Base.String)]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(U)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEDW w1_sdEDX ww_sdEDY w2_sdEDZ]
        let {
          go_sdEE0 [Occ=LoopBreaker]
            :: [(a_sdxWD, GHC.Base.String)]
               -> [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w1_sdEDX go_sdEE0] \r [ds_sdEE1]
                  case ds_sdEE1 of {
                    [] -> [] [];
                    : y_sdEE3 [Occ=Once!] ys_sdEE4 [Occ=Once] ->
                        case y_sdEE3 of {
                          (,) a1_sdEE6 [Occ=OnceL] s''_sdEE7 [Occ=Once] ->
                              let {
                                z_sdEE8 [Occ=OnceL]
                                  :: [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
                                [LclId] =
                                    [go_sdEE0 ys_sdEE4] \u [] go_sdEE0 ys_sdEE4; } in
                              let {
                                go1_sdEE9 [Occ=LoopBreaker]
                                  :: [(GHC.Base.String, GHC.Base.String)]
                                     -> [(GHC.Base.NonEmpty a_sdxWD, GHC.Base.String)]
                                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                    sat-only [w1_sdEDX a1_sdEE6 z_sdEE8 go1_sdEE9] \r [ds1_sdEEa]
                                        case ds1_sdEEa of {
                                          [] -> z_sdEE8;
                                          : y1_sdEEc [Occ=Once!] ys1_sdEEd [Occ=Once*] ->
                                              case y1_sdEEc of {
                                                (,) ds2_sdEEf [Occ=Once] s'''_sdEEg [Occ=Once] ->
                                                    case
                                                        GHC.Base.eqString
                                                            ds2_sdEEf
                                                            Data.Functor.Classes.$fRead1NonEmpty3
                                                    of
                                                    { GHC.Types.False -> go1_sdEE9 ys1_sdEEd;
                                                      GHC.Types.True ->
                                                          let {
                                                            z1_sdEEi [Occ=OnceL]
                                                              :: [(GHC.Base.NonEmpty a_sdxWD,
                                                                   GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdEE9 ys1_sdEEd] \u []
                                                                    go1_sdEE9 ys1_sdEEd; } in
                                                          let {
                                                            go2_sdEEj [Occ=LoopBreaker]
                                                              :: [([a_sdxWD], GHC.Base.String)]
                                                                 -> [(GHC.Base.NonEmpty a_sdxWD,
                                                                      GHC.Base.String)]
                                                            [LclId,
                                                             Arity=1,
                                                             Str=<S,1*U>,
                                                             Unf=OtherCon []] =
                                                                sat-only [a1_sdEE6
                                                                          z1_sdEEi
                                                                          go2_sdEEj] \r [ds3_sdEEk]
                                                                    case ds3_sdEEk of {
                                                                      [] -> z1_sdEEi;
                                                                      : y2_sdEEm [Occ=Once!]
                                                                        ys2_sdEEn [Occ=Once] ->
                                                                          case y2_sdEEm of {
                                                                            (,) as_sdEEp [Occ=Once]
                                                                                s''''_sdEEq [Occ=Once] ->
                                                                                let {
                                                                                  sat_sdEEt [Occ=Once]
                                                                                    :: [(GHC.Base.NonEmpty
                                                                                           a_sdxWD,
                                                                                         GHC.Base.String)]
                                                                                  [LclId] =
                                                                                      [go2_sdEEj
                                                                                       ys2_sdEEn] \u []
                                                                                          go2_sdEEj
                                                                                              ys2_sdEEn; } in
                                                                                let {
                                                                                  sat_sdEEr [Occ=Once]
                                                                                    :: GHC.Base.NonEmpty
                                                                                         a_sdxWD
                                                                                  [LclId] =
                                                                                      CCCS GHC.Base.:|! [a1_sdEE6
                                                                                                         as_sdEEp]; } in
                                                                                let {
                                                                                  sat_sdEEs [Occ=Once]
                                                                                    :: (GHC.Base.NonEmpty
                                                                                          a_sdxWD,
                                                                                        GHC.Base.String)
                                                                                  [LclId] =
                                                                                      CCCS (,)! [sat_sdEEr
                                                                                                 s''''_sdEEq];
                                                                                } in 
                                                                                  : [sat_sdEEs
                                                                                     sat_sdEEt];
                                                                          };
                                                                    };
                                                          } in 
                                                            case w1_sdEDX s'''_sdEEg of sat_sdEEu {
                                                              __DEFAULT -> go2_sdEEj sat_sdEEu;
                                                            };
                                                    };
                                              };
                                        };
                              } in 
                                case
                                    Text.ParserCombinators.ReadP.run GHC.Read.lex1 s''_sdEE7
                                of
                                sat_sdEEv
                                { __DEFAULT -> go1_sdEE9 sat_sdEEv;
                                };
                        };
                  }; } in
        let {
          sat_sdEEA [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_sdxWD)
          [LclId] =
              [w_sdEDW go_sdEE0] \r [s'_sdEEy]
                  case
                      w_sdEDW Data.Functor.Classes.$fRead1NonEmpty2 s'_sdEEy
                  of
                  sat_sdEEz
                  { __DEFAULT -> go_sdEE0 sat_sdEEz;
                  };
        } in 
          case ># [ww_sdEDY 5#] of sat_sdEEw {
            __DEFAULT ->
                case tagToEnum# [sat_sdEEw] of sat_sdEEx {
                  __DEFAULT -> GHC.Read.readParen sat_sdEEx sat_sdEEA w2_sdEDZ;
                };
          };

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a)
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(U)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEEB w1_sdEEC w2_sdEED w3_sdEEE]
        case w2_sdEED of {
          GHC.Types.I# ww1_sdEEG [Occ=Once] ->
              Data.Functor.Classes.$w$cliftReadsPrec5
                  w_sdEEB w1_sdEEC ww1_sdEEG w3_sdEEE;
        };

Data.Functor.Classes.$fRead1Proxy4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Proxy"#;

Data.Functor.Classes.$fRead1Proxy3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Proxy4;

Data.Functor.Classes.$fRead1Proxy_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Proxy3];

Data.Functor.Classes.$fRead1Proxy2
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [eta_sdEEH eta1_sdEEI]
        let {
          sat_sdEEK [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X81cg
          [LclId] =
              [eta1_sdEEI] \r [x_sdEEJ] eta1_sdEEI Data.Proxy.Proxy;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Functor.Classes.$fRead1Proxy_lexeme sat_sdEEK
          of
          { Unit# ww1_sdEEM [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sdEEM];
          };

Data.Functor.Classes.$fRead1Proxy1
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Functor.Classes.$fRead1Proxy2 eta_B2 eta_B1;

Data.Functor.Classes.$fRead1Proxy5
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Proxy.Proxy a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=4, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdEEN ds1_sdEEO eta_B2 eta_B1]
        Data.Functor.Classes.$fRead1Proxy1 eta_B2 eta_B1;

Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> [a]
     -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [ds_sdEEP sl_sdEEQ ds1_sdEER] sl_sdEEQ;

Data.Functor.Classes.$fShow1NonEmpty1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " :| "#;

Data.Functor.Classes.$w$cliftShowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Prim.Int#
     -> a
     -> [a]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C(U))><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEES w1_sdEET ww_sdEEU ww1_sdEEV ww2_sdEEW]
        let {
          f_sdEEX [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEES ww1_sdEEV] \u []
                  w_sdEES Data.Functor.Classes.$fRead1NonEmpty2 ww1_sdEEV; } in
        let {
          g_sdEEY [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdEET ww2_sdEEW] \u [] w1_sdEET ww2_sdEEW;
        } in 
          case ># [ww_sdEEU 5#] of {
            __DEFAULT ->
                let {
                  sat_sdEF3 [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_sdEEX g_sdEEY] \r [x_sdEF0]
                          let {
                            sat_sdEF2 [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g_sdEEY x_sdEF0] \u []
                                    let {
                                      sat_sdEF1 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdEEY x_sdEF0] \u [] g_sdEEY x_sdEF0;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Functor.Classes.$fShow1NonEmpty1 sat_sdEF1;
                          } in  f_sdEEX sat_sdEF2;
                } in  sat_sdEF3;
            1# ->
                let {
                  sat_sdEF9 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sdEEX g_sdEEY] \r [x_sdEF4]
                          let {
                            sat_sdEF8 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sdEEX g_sdEEY x_sdEF4] \u []
                                    let {
                                      sat_sdEF7 [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g_sdEEY x_sdEF4] \u []
                                              let {
                                                sat_sdEF6 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sdEEY x_sdEF4] \u []
                                                        let {
                                                          sat_sdEF5 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdEF4];
                                                        } in  g_sdEEY sat_sdEF5;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Functor.Classes.$fShow1NonEmpty1 sat_sdEF6;
                                    } in  f_sdEEX sat_sdEF7;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEF8];
                } in  sat_sdEF9;
          };

Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> GHC.Base.NonEmpty a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C(U))><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEFa w1_sdEFb w2_sdEFc w3_sdEFd]
        case w2_sdEFc of {
          GHC.Types.I# ww1_sdEFf [Occ=Once] ->
              case w3_sdEFd of {
                GHC.Base.:| ww3_sdEFh [Occ=Once] ww4_sdEFi [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftShowsPrec1
                        w_sdEFa w1_sdEFb ww1_sdEFf ww3_sdEFh ww4_sdEFi;
              };
        };

Data.Functor.Classes.$fShow1Proxy2
  :: [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Base.++ Data.Functor.Classes.$fRead1Proxy3 eta_B1;

Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Proxy.Proxy a
     -> GHC.Show.ShowS
[GblId, Arity=5, Str=<L,A><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdEFj ds1_sdEFk ds2_sdEFl ds3_sdEFm eta_B1]
        Data.Functor.Classes.$fShow1Proxy2 eta_B1;

Data.Functor.Classes.$fEq2(,)_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool) -> (a, c) -> (b, d) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [e1_sdEFn e2_sdEFo ds_sdEFp ds1_sdEFq]
        case ds_sdEFp of {
          (,) x1_sdEFs [Occ=Once] y1_sdEFt [Occ=Once] ->
              case ds1_sdEFq of {
                (,) x2_sdEFv [Occ=Once] y2_sdEFw [Occ=Once] ->
                    case e1_sdEFn x1_sdEFs x2_sdEFv of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> e2_sdEFo y1_sdEFt y2_sdEFw;
                    };
              };
        };

Data.Functor.Classes.$fEq2(,) [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 (,)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2(,)_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1(,)_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> (a, a1) -> (a, b) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdEFy eta_sdEFz eta1_sdEFA eta2_sdEFB]
        case eta1_sdEFA of {
          (,) x1_sdEFD [Occ=Once] y1_sdEFE [Occ=Once] ->
              case eta2_sdEFB of {
                (,) x2_sdEFG [Occ=Once] y2_sdEFH [Occ=Once] ->
                    case GHC.Classes.== $dEq_sdEFy x1_sdEFD x2_sdEFG of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> eta_sdEFz y1_sdEFE y2_sdEFH;
                    };
              };
        };

Data.Functor.Classes.$fEq1(,) [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Classes.Eq a => Data.Functor.Classes.Eq1 ((,) a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1(,)_$cliftEq eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq2Either_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool)
     -> Data.Either.Either a c
     -> Data.Either.Either b d
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [e1_sdEFJ ds_sdEFK ds1_sdEFL ds2_sdEFM]
        case ds1_sdEFL of {
          Data.Either.Left x_sdEFO [Occ=Once] ->
              case ds2_sdEFM of {
                Data.Either.Left y_sdEFQ [Occ=Once] -> e1_sdEFJ x_sdEFO y_sdEFQ;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds3_sdEFS [Occ=Once] ->
              case ds2_sdEFM of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdEFV [Occ=Once] -> ds_sdEFK ds3_sdEFS y_sdEFV;
              };
        };

Data.Functor.Classes.$fEq2Either [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 Data.Either.Either
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2Either_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Either_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdEFW eta_sdEFX eta1_sdEFY eta2_sdEFZ]
        case eta1_sdEFY of {
          Data.Either.Left x_sdEG1 [Occ=Once] ->
              case eta2_sdEFZ of {
                Data.Either.Left y_sdEG3 [Occ=Once] ->
                    GHC.Classes.== $dEq_sdEFW x_sdEG1 y_sdEG3;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds_sdEG5 [Occ=Once] ->
              case eta2_sdEFZ of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdEG8 [Occ=Once] -> eta_sdEFX ds_sdEG5 y_sdEG8;
              };
        };

Data.Functor.Classes.$fEq1Either [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Classes.Eq1 (Data.Either.Either a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Either_$cliftEq
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq2Const_$cliftEq2
  :: forall a b c d.
     (a -> b -> GHC.Types.Bool)
     -> (c -> d -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a c
     -> Data.Functor.Const.Const b d
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eq_sdEG9 ds_sdEGa ds1_sdEGb ds2_sdEGc]
        eq_sdEG9 ds1_sdEGb ds2_sdEGc;

Data.Functor.Classes.$fEq2Const [InlPrag=INLINE (sat-args=0)]
  :: Data.Functor.Classes.Eq2 Data.Functor.Const.Const
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq2Const_$cliftEq2
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fEq1Const_$cliftEq
  :: forall a.
     GHC.Classes.Eq a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a a1
     -> Data.Functor.Const.Const a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdEGd eta_sdEGe eta1_sdEGf eta2_sdEGg]
        GHC.Classes.== $dEq_sdEGd eta1_sdEGf eta2_sdEGg;

Data.Functor.Classes.$fEq1Const [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.$fEq1Const_$cliftEq
            eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fOrd2(,)_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> (a, c)
     -> (b, d)
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [comp1_sdEGh comp2_sdEGi ds_sdEGj ds1_sdEGk]
        case ds_sdEGj of {
          (,) x1_sdEGm [Occ=Once] y1_sdEGn [Occ=Once] ->
              case ds1_sdEGk of {
                (,) x2_sdEGp [Occ=Once] y2_sdEGq [Occ=Once] ->
                    case comp1_sdEGh x1_sdEGm x2_sdEGp of {
                      GHC.Types.LT -> GHC.Types.LT [];
                      GHC.Types.EQ -> comp2_sdEGi y1_sdEGn y2_sdEGq;
                      GHC.Types.GT -> GHC.Types.GT [];
                    };
              };
        };

Data.Functor.Classes.$fOrd2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2(,)_$cliftEq2
                                                Data.Functor.Classes.$fOrd2(,)_$cliftCompare2];

Data.Functor.Classes.$w$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> a -> a1 -> a -> b -> GHC.Types.Ordering
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEGs w1_sdEGt ww_sdEGu ww1_sdEGv ww2_sdEGw ww3_sdEGx]
        case GHC.Classes.compare w_sdEGs ww_sdEGu ww2_sdEGw of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> w1_sdEGt ww1_sdEGv ww3_sdEGx;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Classes.$fOrd1(,)_$cliftCompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> (a, a1) -> (a, b) -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEGz w1_sdEGA w2_sdEGB w3_sdEGC]
        case w2_sdEGB of {
          (,) ww1_sdEGE [Occ=Once] ww2_sdEGF [Occ=Once] ->
              case w3_sdEGC of {
                (,) ww4_sdEGH [Occ=Once] ww5_sdEGI [Occ=Once] ->
                    Data.Functor.Classes.$w$cliftCompare
                        w_sdEGz w1_sdEGA ww1_sdEGE ww2_sdEGF ww4_sdEGH ww5_sdEGI;
              };
        };

Data.Functor.Classes.$w$cp1Ord1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> a -> a1 -> a -> b -> GHC.Types.Bool
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEGJ w1_sdEGK ww_sdEGL ww1_sdEGM ww2_sdEGN ww3_sdEGO]
        case GHC.Classes.$p1Ord w_sdEGJ of sat_sdEGP {
          __DEFAULT ->
              case GHC.Classes.== sat_sdEGP ww_sdEGL ww2_sdEGN of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> w1_sdEGK ww1_sdEGM ww3_sdEGO;
              };
        };

Data.Functor.Classes.$fOrd1(,)1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool) -> (a, a1) -> (a, b) -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEGR w1_sdEGS w2_sdEGT w3_sdEGU]
        case w2_sdEGT of {
          (,) ww1_sdEGW [Occ=Once] ww2_sdEGX [Occ=Once] ->
              case w3_sdEGU of {
                (,) ww4_sdEGZ [Occ=Once] ww5_sdEH0 [Occ=Once] ->
                    Data.Functor.Classes.$w$cp1Ord1
                        w_sdEGR w1_sdEGS ww1_sdEGW ww2_sdEGX ww4_sdEGZ ww5_sdEH0;
              };
        };

Data.Functor.Classes.$fOrd1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Ord a => Data.Functor.Classes.Ord1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdEH1]
        let {
          sat_sdEH3 [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> (a_Xdx1z, a) -> (a_Xdx1z, b) -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdEH1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1(,)_$cliftCompare
                      $dOrd_sdEH1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdEH2 [Occ=Once] :: Data.Functor.Classes.Eq1 ((,) a_Xdx1z)
          [LclId] =
              [$dOrd_sdEH1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1(,)1 $dOrd_sdEH1 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdEH2 sat_sdEH3];

Data.Functor.Classes.$fOrd2Either_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> Data.Either.Either a c
     -> Data.Either.Either b d
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [comp1_sdEH4 ds_sdEH5 ds1_sdEH6 ds2_sdEH7]
        case ds1_sdEH6 of {
          Data.Either.Left x_sdEH9 [Occ=Once] ->
              case ds2_sdEH7 of {
                Data.Either.Left y_sdEHb [Occ=Once] -> comp1_sdEH4 x_sdEH9 y_sdEHb;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right ds3_sdEHd [Occ=Once] ->
              case ds2_sdEH7 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right y_sdEHg [Occ=Once] -> ds_sdEH5 ds3_sdEHd y_sdEHg;
              };
        };

Data.Functor.Classes.$fOrd2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2Either_$cliftEq2
                                                Data.Functor.Classes.$fOrd2Either_$cliftCompare2];

Data.Functor.Classes.$fOrd1Either_$cliftCompare
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Ordering)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdEHh eta_sdEHi eta1_sdEHj eta2_sdEHk]
        case eta1_sdEHj of {
          Data.Either.Left x_sdEHm [Occ=Once] ->
              case eta2_sdEHk of {
                Data.Either.Left y_sdEHo [Occ=Once] ->
                    GHC.Classes.compare $dOrd_sdEHh x_sdEHm y_sdEHo;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right ds_sdEHq [Occ=Once] ->
              case eta2_sdEHk of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right y_sdEHt [Occ=Once] -> eta_sdEHi ds_sdEHq y_sdEHt;
              };
        };

Data.Functor.Classes.$fOrd1Either1
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Either.Either a a1
     -> Data.Either.Either a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,1*C1(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdEHu eta_sdEHv eta1_sdEHw eta2_sdEHx]
        case eta1_sdEHw of {
          Data.Either.Left x_sdEHz [Occ=Once] ->
              case eta2_sdEHx of {
                Data.Either.Left y_sdEHB [Occ=Once] ->
                    case GHC.Classes.$p1Ord $dOrd_sdEHu of sat_sdEHC {
                      __DEFAULT -> GHC.Classes.== sat_sdEHC x_sdEHz y_sdEHB;
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right ds_sdEHE [Occ=Once] ->
              case eta2_sdEHx of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right y_sdEHH [Occ=Once] -> eta_sdEHv ds_sdEHE y_sdEHH;
              };
        };

Data.Functor.Classes.$fOrd1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Classes.Ord1 (Data.Either.Either a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdEHI]
        let {
          sat_sdEHK [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Either.Either a_Xdx16 a
               -> Data.Either.Either a_Xdx16 b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdEHI] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Either_$cliftCompare
                      $dOrd_sdEHI eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdEHJ [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Either.Either a_Xdx16)
          [LclId] =
              [$dOrd_sdEHI] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Either1
                      $dOrd_sdEHI eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdEHJ sat_sdEHK];

Data.Functor.Classes.$fOrd2Const_$cliftCompare2
  :: forall a b c d.
     (a -> b -> GHC.Types.Ordering)
     -> (c -> d -> GHC.Types.Ordering)
     -> Data.Functor.Const.Const a c
     -> Data.Functor.Const.Const b d
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [comp_sdEHL ds_sdEHM ds1_sdEHN ds2_sdEHO]
        comp_sdEHL ds1_sdEHN ds2_sdEHO;

Data.Functor.Classes.$fOrd2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Ord2 Data.Functor.Const.Const
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Ord2! [Data.Functor.Classes.$fEq2Const_$cliftEq2
                                                Data.Functor.Classes.$fOrd2Const_$cliftCompare2];

Data.Functor.Classes.$fOrd1Const1
  :: forall a.
     GHC.Classes.Ord a =>
     forall a1 b.
     (a1 -> b -> GHC.Types.Bool)
     -> Data.Functor.Const.Const a a1
     -> Data.Functor.Const.Const a b
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdEHP eta_sdEHQ eta1_sdEHR eta2_sdEHS]
        case GHC.Classes.$p1Ord $dOrd_sdEHP of sat_sdEHT {
          __DEFAULT -> GHC.Classes.== sat_sdEHT eta1_sdEHR eta2_sdEHS;
        };

Data.Functor.Classes.$fOrd1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Classes.Ord1 (Data.Functor.Const.Const a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sdEHU]
        let {
          sat_sdEHZ [Occ=Once]
            :: forall a b.
               (a -> b -> GHC.Types.Ordering)
               -> Data.Functor.Const.Const a_Xdx0D a
               -> Data.Functor.Const.Const a_Xdx0D b
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdEHU] \r [eta_sdEHW eta1_sdEHX eta2_sdEHY]
                  GHC.Classes.compare $dOrd_sdEHU eta1_sdEHX eta2_sdEHY; } in
        let {
          sat_sdEHV [Occ=Once]
            :: Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a_Xdx0D)
          [LclId] =
              [$dOrd_sdEHU] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fOrd1Const1 $dOrd_sdEHU eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Ord1 [sat_sdEHV sat_sdEHZ];

Data.Functor.Classes.$fRead1(,)5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ","#;

Data.Functor.Classes.$fRead1(,)4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1(,)5;

Data.Functor.Classes.$fRead1(,)3 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Functor.Classes.$fRead1(,)4];

Data.Functor.Classes.$w$cliftReadPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a, b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEI0 w1_sdEI1 w2_sdEI2 w3_sdEI3]
        let {
          p_sdEI4 [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b2.
                  ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b2)
                  -> Text.ParserCombinators.ReadP.P b2
          [LclId, Arity=2, Str=<L,U><L,C(U)>, Unf=OtherCon []] =
              [w_sdEI0 w1_sdEI1] \r [n_sdEI5 k1_sdEI6]
                  let {
                    sat_sdEIf [Occ=Once]
                      :: a_sdxYe -> Text.ParserCombinators.ReadP.P b2_i88WH
                    [LclId] =
                        [w1_sdEI1 n_sdEI5 k1_sdEI6] \r [a1_sdEI7]
                            let {
                              sat_sdEIc [Occ=Once]
                                :: () -> Text.ParserCombinators.ReadP.P b2_i88WH
                              [LclId] =
                                  [w1_sdEI1 n_sdEI5 k1_sdEI6 a1_sdEI7] \r [a2_sdEI8]
                                      let {
                                        sat_sdEIb [Occ=Once]
                                          :: b_sdxYf -> Text.ParserCombinators.ReadP.P b2_i88WH
                                        [LclId] =
                                            [k1_sdEI6 a1_sdEI7] \r [a3_sdEI9]
                                                let {
                                                  sat_sdEIa [Occ=Once] :: (a_sdxYe, b_sdxYf)
                                                  [LclId] =
                                                      CCCS (,)! [a1_sdEI7 a3_sdEI9];
                                                } in  k1_sdEI6 sat_sdEIa;
                                      } in  w1_sdEI1 n_sdEI5 sat_sdEIb;
                            } in 
                              case
                                  Text.Read.Lex.$wexpect Data.Functor.Classes.$fRead1(,)3 sat_sdEIc
                              of
                              { Unit# ww1_sdEIe [Occ=Once] ->
                                    Text.ParserCombinators.ReadP.Look [ww1_sdEIe];
                              };
                  } in  w_sdEI0 n_sdEI5 sat_sdEIf; } in
        let {
          lvl3_sdEIg [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b2.
                  ((a_sdxYe, b_sdxYf) -> Text.ParserCombinators.ReadP.P b2)
                  -> Text.ParserCombinators.ReadP.P b2
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [p_sdEI4] \r [w4_sdEIh w5_sdEIi]
                  case GHC.Read.$wparen' p_sdEI4 w4_sdEIh w5_sdEIi of {
                    Unit# ww1_sdEIk [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Get [ww1_sdEIk];
                  }; } in
        let {
          sat_sdEIp [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_sdxYe, b_sdxYf)
          [LclId] =
              [lvl3_sdEIg] \r [eta_sdEIl eta1_sdEIm]
                  case
                      GHC.Read.$wskipSpacesThenP lvl3_sdEIg eta_sdEIl eta1_sdEIm
                  of
                  { Unit# ww1_sdEIo [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdEIo];
                  };
        } in  GHC.Read.list3 sat_sdEIp w2_sdEI2 w3_sdEI3;

Data.Functor.Classes.$fRead1(,)2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a, b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEIq w1_sdEIr w2_sdEIs w3_sdEIt w4_sdEIu w5_sdEIv]
        Data.Functor.Classes.$w$cliftReadPrec2
            w_sdEIq w2_sdEIs w4_sdEIu w5_sdEIv;

Data.Functor.Classes.$w$cliftReadsPrec6 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, b)
[GblId,
 Arity=3,
 Str=<L,C(C(U))><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEIw w1_sdEIx w2_sdEIy]
        let {
          sat_sdEIB [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (a_sdxYo, b_sdxYp)
          [LclId] =
              [w_sdEIw w1_sdEIx w2_sdEIy] \u []
                  let {
                    sat_sdEIA [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_sdxYp
                    [LclId] =
                        [w1_sdEIx] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdEIx eta_B1; } in
                  let {
                    sat_sdEIz [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdxYo
                    [LclId] =
                        [w_sdEIw] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdEIw eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec2
                        sat_sdEIz
                        sat_sdEIA
                        w2_sdEIy
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEIB;

Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, b)
[GblId,
 Arity=5,
 Str=<L,C(C(U))><L,A><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEIC w1_sdEID w2_sdEIE w3_sdEIF w4_sdEIG]
        Data.Functor.Classes.$w$cliftReadsPrec6 w_sdEIC w2_sdEIE w4_sdEIG;

Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2
  :: forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [(a, b)]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [rp1_sdEIH rl1_sdEII rp2_sdEIJ rl2_sdEIK]
        let {
          sat_sdEIN [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_adwW8, b_adwW9)
          [LclId] =
              [rp1_sdEIH rp2_sdEIJ] \r [w_sdEIL w1_sdEIM]
                  Data.Functor.Classes.$w$cliftReadPrec2
                      rp1_sdEIH rp2_sdEIJ w_sdEIL w1_sdEIM;
        } in  GHC.Read.list sat_sdEIN;

Data.Functor.Classes.$fShow1(,)3 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['('#];

Data.Functor.Classes.$fRead1Identity5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Functor.Classes.$fShow1(,)2 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [','#];

Data.Functor.Classes.$fShow1(,)1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [')'#];

Data.Functor.Classes.$w$cliftShowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEIO w1_sdEIP ww_sdEIQ ww1_sdEIR]
        let {
          f_sdEIS [Occ=OnceL!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEIO ww_sdEIQ] \u []
                  w_sdEIO Data.Functor.Classes.$fRead1Identity5 ww_sdEIQ; } in
        let {
          f1_sdEIT [Occ=OnceL!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdEIP ww1_sdEIR] \u []
                  w1_sdEIP Data.Functor.Classes.$fRead1Identity5 ww1_sdEIR; } in
        let {
          sat_sdEIZ [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
          [LclId] =
              [f_sdEIS f1_sdEIT] \r [x_sdEIU]
                  let {
                    sat_sdEIY [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [f_sdEIS f1_sdEIT x_sdEIU] \u []
                            let {
                              sat_sdEIW [Occ=Once] :: [GHC.Types.Char]
                              [LclId] =
                                  [f1_sdEIT x_sdEIU] \u []
                                      let {
                                        sat_sdEIV [Occ=Once] :: GHC.Base.String
                                        [LclId] =
                                            CCCS :! [Data.Functor.Classes.$fShow1(,)1 x_sdEIU];
                                      } in  f1_sdEIT sat_sdEIV; } in
                            let {
                              sat_sdEIX [Occ=Once] :: GHC.Base.String
                              [LclId] =
                                  CCCS :! [Data.Functor.Classes.$fShow1(,)2 sat_sdEIW];
                            } in  f_sdEIS sat_sdEIX;
                  } in  : [Data.Functor.Classes.$fShow1(,)3 sat_sdEIY];
        } in  sat_sdEIZ;

Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> (a, b)
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*C1(C1(C(U)))><L,A><L,A><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEJ0 w1_sdEJ1 w2_sdEJ2 w3_sdEJ3 w4_sdEJ4 w5_sdEJ5]
        case w5_sdEJ5 of {
          (,) ww1_sdEJ7 [Occ=Once] ww2_sdEJ8 [Occ=Once] ->
              Data.Functor.Classes.$w$cliftShowsPrec2
                  w_sdEJ0 w2_sdEJ2 ww1_sdEJ7 ww2_sdEJ8;
        };

Data.Functor.Classes.$dmliftShowList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Show2 f =>
     forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [f a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C1(C(C1(U))))))),A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow2_sdEJ9 sp1_sdEJa sl1_sdEJb sp2_sdEJc sl2_sdEJd]
        let {
          sat_sdEJe [Occ=Once] :: f_adw99 a_adwOU b_adwOV -> GHC.Show.ShowS
          [LclId] =
              [$dShow2_sdEJ9 sp1_sdEJa sl1_sdEJb sp2_sdEJc sl2_sdEJd] \u []
                  Data.Functor.Classes.liftShowsPrec2
                      $dShow2_sdEJ9
                      sp1_sdEJa
                      sl1_sdEJb
                      sp2_sdEJc
                      sl2_sdEJd
                      Data.Functor.Classes.$fRead1Identity5;
        } in  GHC.Show.showList__ sat_sdEJe;

Data.Functor.Classes.$w$cliftShowList3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> [(a, b)]
     -> GHC.Base.String
     -> GHC.Base.String
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,C(C1(C1(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEJf w1_sdEJg w2_sdEJh w3_sdEJi]
        let {
          sat_sdEJs [Occ=Once] :: (a_sdxYK, b_sdxYL) -> GHC.Show.ShowS
          [LclId] =
              [w_sdEJf w1_sdEJg] \r [ds_sdEJj eta_sdEJk]
                  case ds_sdEJj of {
                    (,) x_sdEJm [Occ=Once] y_sdEJn [Occ=Once] ->
                        let {
                          sat_sdEJr [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_sdEJf w1_sdEJg eta_sdEJk x_sdEJm y_sdEJn] \u []
                                  let {
                                    sat_sdEJp [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w1_sdEJg eta_sdEJk y_sdEJn] \u []
                                            let {
                                              sat_sdEJo [Occ=Once] :: GHC.Base.String
                                              [LclId] =
                                                  CCCS :! [Data.Functor.Classes.$fShow1(,)1
                                                           eta_sdEJk];
                                            } in 
                                              w1_sdEJg
                                                  Data.Functor.Classes.$fRead1Identity5
                                                  y_sdEJn
                                                  sat_sdEJo; } in
                                  let {
                                    sat_sdEJq [Occ=Once] :: GHC.Base.String
                                    [LclId] =
                                        CCCS :! [Data.Functor.Classes.$fShow1(,)2 sat_sdEJp];
                                  } in 
                                    w_sdEJf Data.Functor.Classes.$fRead1Identity5 x_sdEJm sat_sdEJq;
                        } in  : [Data.Functor.Classes.$fShow1(,)3 sat_sdEJr];
                  };
        } in  GHC.Show.showList__ sat_sdEJs w2_sdEJh w3_sdEJi;

Data.Functor.Classes.$fShow2(,)_$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [(a, b)]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,A><L,C(C1(C1(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEJt w1_sdEJu w2_sdEJv w3_sdEJw w4_sdEJx w5_sdEJy]
        Data.Functor.Classes.$w$cliftShowList3
            w_sdEJt w2_sdEJv w4_sdEJx w5_sdEJy;

Data.Functor.Classes.$fShow2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2(,)_$cliftShowList2];

Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> (a, a1)
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><L,A><L,A><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdEJz eta_sdEJA eta1_sdEJB eta2_sdEJC eta3_sdEJD]
        case eta3_sdEJD of {
          (,) ww1_sdEJF [Occ=Once] ww2_sdEJG [Occ=Once] ->
              let {
                sat_sdEJH [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_adwQx -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sdEJz] \s [] GHC.Show.showsPrec $dShow_sdEJz;
              } in 
                Data.Functor.Classes.$w$cliftShowsPrec2
                    sat_sdEJH eta_sdEJA ww1_sdEJF ww2_sdEJG;
        };

$w$dmliftReadListPrec2_rdymu
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadP.ReadP [f a b]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdEJI w1_sdEJJ w2_sdEJK w3_sdEJL w4_sdEJM]
        let {
          w5_sdEJN [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [f_sdxYT a_sdxYV b_sdxYW]
          [LclId] =
              [w_sdEJI w1_sdEJJ w2_sdEJK w3_sdEJL w4_sdEJM] \u []
                  let {
                    sat_sdEJS [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [b_sdxYW]
                    [LclId] =
                        [w4_sdEJM] \u []
                            w4_sdEJM
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEJT [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [b_sdxYW]
                    [LclId] =
                        [sat_sdEJS] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEJS eta_B1; } in
                  let {
                    sat_sdEJR [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_sdxYW
                    [LclId] =
                        [w3_sdEJL] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w3_sdEJL eta_B1; } in
                  let {
                    sat_sdEJP [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxYV]
                    [LclId] =
                        [w2_sdEJK] \u []
                            w2_sdEJK
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEJQ [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxYV]
                    [LclId] =
                        [sat_sdEJP] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEJP eta_B1; } in
                  let {
                    sat_sdEJO [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxYV
                    [LclId] =
                        [w1_sdEJJ] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w1_sdEJJ eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadList2
                        w_sdEJI sat_sdEJO sat_sdEJQ sat_sdEJR sat_sdEJT; } in
        let {
          sat_sdEJX [Occ=Once]
            :: forall b1.
               ([f_sdxYT a_sdxYV b_sdxYW] -> Text.ParserCombinators.ReadP.P b1)
               -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [w5_sdEJN] \r [w6_sdEJU]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w5_sdEJN w6_sdEJU
                  of
                  { Unit# ww1_sdEJW [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdEJW];
                  };
        } in  sat_sdEJX;

$dmliftReadListPrec1_rdymv
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [f a b]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdEJY
                    w1_sdEJZ
                    w2_sdEK0
                    w3_sdEK1
                    w4_sdEK2
                    w5_sdEK3]
        $w$dmliftReadListPrec2_rdymu
            w_sdEJY w1_sdEJZ w2_sdEK0 w3_sdEK1 w4_sdEK2;

Data.Functor.Classes.$dmliftReadListPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(C1(C(U))))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        $dmliftReadListPrec1_rdymv
            eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$dmliftReadPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(C(U)))))),A,A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEK4 rp1_sdEK5 rl1_sdEK6 rp2_sdEK7 rl2_sdEK8]
        let {
          f1_sdEK9 [Occ=OnceL!, Dmd=<L,C(C(U))>]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdwdU a_adwOl b_adwOm)
          [LclId] =
              [$dRead2_sdEK4 rp1_sdEK5 rl1_sdEK6 rp2_sdEK7 rl2_sdEK8] \u []
                  let {
                    sat_sdEKe [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [b_adwOm]
                    [LclId] =
                        [rl2_sdEK8] \u []
                            rl2_sdEK8
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEKf [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [b_adwOm]
                    [LclId] =
                        [sat_sdEKe] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEKe eta_B1; } in
                  let {
                    sat_sdEKd [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_adwOm
                    [LclId] =
                        [rp2_sdEK7] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S
                                rp2_sdEK7 eta_B1; } in
                  let {
                    sat_sdEKb [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adwOl]
                    [LclId] =
                        [rl1_sdEK6] \u []
                            rl1_sdEK6
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEKc [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adwOl]
                    [LclId] =
                        [sat_sdEKb] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEKb eta_B1; } in
                  let {
                    sat_sdEKa [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwOl
                    [LclId] =
                        [rp1_sdEK5] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S rp1_sdEK5 eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadsPrec2
                        $dRead2_sdEK4 sat_sdEKa sat_sdEKc sat_sdEKd sat_sdEKf; } in
        let {
          sat_sdEKm [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (f_XdwdU a_adwOl b_adwOm -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId] =
              [f1_sdEK9] \r [n_sdEKg]
                  let {
                    w_sdEKh [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS (f_XdwdU a_adwOl b_adwOm)
                    [LclId] =
                        [f1_sdEK9 n_sdEKg] \u [] f1_sdEK9 n_sdEKg; } in
                  let {
                    sat_sdEKl [Occ=OnceT[0]]
                      :: forall b1.
                         (f_XdwdU a_adwOl b_adwOm -> Text.ParserCombinators.ReadP.P b1)
                         -> Text.ParserCombinators.ReadP.P b1
                    [LclId] =
                        [w_sdEKh] \r [w1_sdEKi]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdEKh w1_sdEKi
                            of
                            { Unit# ww1_sdEKk [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEKk];
                            };
                  } in  sat_sdEKl;
        } in  sat_sdEKm;

Data.Functor.Classes.$dmliftReadList2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C1(C(U)))))),A)><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEKn rp1_sdEKo rl1_sdEKp rp2_sdEKq rl2_sdEKr]
        let {
          sat_sdEKF [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_XdwdV a_adwNZ b_adwO0]
          [LclId] =
              [$dRead2_sdEKn rp1_sdEKo rl1_sdEKp rp2_sdEKq rl2_sdEKr] \u []
                  let {
                    sat_sdEKE [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (f_XdwdV a_adwNZ b_adwO0)
                    [LclId] =
                        [$dRead2_sdEKn rp1_sdEKo rl1_sdEKp rp2_sdEKq rl2_sdEKr] \s []
                            let {
                              sat_sdEKD [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwO0]
                              [LclId] =
                                  [rl2_sdEKr] \r [n_sdEKz w1_sdEKA]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl2_sdEKr w1_sdEKA
                                      of
                                      { Unit# ww1_sdEKC [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdEKC];
                                      }; } in
                            let {
                              sat_sdEKy [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwO0
                              [LclId] =
                                  [rp2_sdEKq] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp2_sdEKq eta_B1; } in
                            let {
                              sat_sdEKx [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwNZ]
                              [LclId] =
                                  [rl1_sdEKp] \r [n_sdEKt w1_sdEKu]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl1_sdEKp w1_sdEKu
                                      of
                                      { Unit# ww1_sdEKw [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdEKw];
                                      }; } in
                            let {
                              sat_sdEKs [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwNZ
                              [LclId] =
                                  [rp1_sdEKo] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp1_sdEKo eta_B1;
                            } in 
                              Data.Functor.Classes.liftReadPrec2
                                  $dRead2_sdEKn sat_sdEKs sat_sdEKx sat_sdEKy sat_sdEKD;
                  } in 
                    GHC.Read.list
                        sat_sdEKE
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEKF;

Data.Functor.Classes.$dmliftReadsPrec2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Read2 f =>
     forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C(C1(U)))))),A)><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEKG rp1_sdEKH rl1_sdEKI rp2_sdEKJ rl2_sdEKK]
        let {
          ds_sdEKL [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_XdwdW a_adwNE b_adwNF)
          [LclId] =
              [$dRead2_sdEKG rp1_sdEKH rl1_sdEKI rp2_sdEKJ rl2_sdEKK] \u []
                  let {
                    sat_sdEKX [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwNF]
                    [LclId] =
                        [rl2_sdEKK] \r [n_sdEKT w1_sdEKU]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl2_sdEKK w1_sdEKU
                            of
                            { Unit# ww1_sdEKW [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEKW];
                            }; } in
                  let {
                    sat_sdEKS [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwNF
                    [LclId] =
                        [rp2_sdEKJ] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                rp2_sdEKJ eta_B1; } in
                  let {
                    sat_sdEKR [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwNE]
                    [LclId] =
                        [rl1_sdEKI] \r [n_sdEKN w1_sdEKO]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl1_sdEKI w1_sdEKO
                            of
                            { Unit# ww1_sdEKQ [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEKQ];
                            }; } in
                  let {
                    sat_sdEKM [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwNE
                    [LclId] =
                        [rp1_sdEKH] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp1_sdEKH eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadPrec2
                        $dRead2_sdEKG sat_sdEKM sat_sdEKR sat_sdEKS sat_sdEKX; } in
        let {
          sat_sdEL0 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdwdW a_adwNE b_adwNF)
          [LclId] =
              [ds_sdEKL] \r [n_sdEKY]
                  let {
                    sat_sdEKZ [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (f_XdwdW a_adwNE b_adwNF)
                    [LclId] =
                        [ds_sdEKL n_sdEKY] \u []
                            ds_sdEKL
                                n_sdEKY Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sdEKZ;
        } in  sat_sdEL0;

Data.Functor.Classes.$dmliftShowList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Show1 f =>
     forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C(C1(U))))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sdEL1 sp_sdEL2 sl_sdEL3]
        let {
          sat_sdEL4 [Occ=Once] :: f_adw9R a_adwNq -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdEL1 sp_sdEL2 sl_sdEL3] \u []
                  Data.Functor.Classes.liftShowsPrec
                      $dShow1_sdEL1
                      sp_sdEL2
                      sl_sdEL3
                      Data.Functor.Classes.$fRead1Identity5;
        } in  GHC.Show.showList__ sat_sdEL4;

Data.Functor.Classes.$w$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> [(a, a1)] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEL5 w1_sdEL6 w2_sdEL7 w3_sdEL8]
        let {
          lvl3_sdEL9 [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_sdxZ3 -> GHC.Show.ShowS
          [LclId] =
              [w_sdEL5] \u [] GHC.Show.showsPrec w_sdEL5; } in
        let {
          sat_sdELe [Occ=Once] :: (a_sdxZ3, a1_sdxZ5) -> GHC.Show.ShowS
          [LclId] =
              [w1_sdEL6 lvl3_sdEL9] \r [eta_sdELa]
                  case eta_sdELa of {
                    (,) ww1_sdELc [Occ=Once] ww2_sdELd [Occ=Once] ->
                        Data.Functor.Classes.$w$cliftShowsPrec2
                            lvl3_sdEL9 w1_sdEL6 ww1_sdELc ww2_sdELd;
                  };
        } in  GHC.Show.showList__ sat_sdELe w2_sdEL7 w3_sdEL8;

Data.Functor.Classes.$fShow1(,)_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS) -> [(a, a1)] -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdELf w1_sdELg w2_sdELh w3_sdELi w4_sdELj]
        Data.Functor.Classes.$w$cliftShowList
            w_sdELf w1_sdELg w3_sdELi w4_sdELj;

Data.Functor.Classes.$fShow1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => Data.Functor.Classes.Show1 ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdELk]
        let {
          sat_sdELq [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS) -> [(a_adwQx, a)] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdELk] \r [w_sdELm w1_sdELn w2_sdELo w3_sdELp]
                  Data.Functor.Classes.$w$cliftShowList
                      $dShow_sdELk w_sdELm w2_sdELo w3_sdELp; } in
        let {
          sat_sdELl [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> (a_adwQx, a)
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdELk] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1(,)_$cliftShowsPrec
                      $dShow_sdELk eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdELl sat_sdELq];

Data.Functor.Classes.$fShow1Proxy1
  :: forall a.
     Data.Proxy.Proxy a -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sdELr eta_B1] Data.Functor.Classes.$fShow1Proxy2 eta_B1;

Data.Functor.Classes.$fShow1Proxy_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Proxy.Proxy a]
     -> GHC.Show.ShowS
[GblId, Arity=4, Str=<L,A><L,A><S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [sp_sdELs sl_sdELt eta_sdELu eta1_sdELv]
        GHC.Show.showList__
            Data.Functor.Classes.$fShow1Proxy1 eta_sdELu eta1_sdELv;

Data.Functor.Classes.$fShow1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Proxy_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Proxy_$cliftShowList];

Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [GHC.Base.NonEmpty a]
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C(U)))><L,C(C(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdELw sl_sdELx eta_sdELy eta1_sdELz]
        let {
          sat_sdELE [Occ=Once] :: GHC.Base.NonEmpty a_adx0n -> GHC.Show.ShowS
          [LclId] =
              [sp_sdELw sl_sdELx] \r [w_sdELA]
                  case w_sdELA of {
                    GHC.Base.:| ww1_sdELC [Occ=Once] ww2_sdELD [Occ=Once] ->
                        Data.Functor.Classes.$w$cliftShowsPrec1
                            sp_sdELw sl_sdELx 0# ww1_sdELC ww2_sdELD;
                  };
        } in  GHC.Show.showList__ sat_sdELE eta_sdELy eta1_sdELz;

Data.Functor.Classes.$fShow1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1NonEmpty_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1NonEmpty_$cliftShowList];

Data.Functor.Classes.$fShow1[]_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [[a]] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [sp_sdELF sl_sdELG eta_B2 eta_B1]
        GHC.Show.showList__ sl_sdELG eta_B2 eta_B1;

Data.Functor.Classes.$fShow1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1[]_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1[]_$cliftShowList];

$w$dmliftReadListPrec_rdymw
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadP.ReadP [f a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdELH w1_sdELI w2_sdELJ]
        let {
          w3_sdELK [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [f_sdxZb a_sdxZd]
          [LclId] =
              [w_sdELH w1_sdELI w2_sdELJ] \u []
                  let {
                    sat_sdELM [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxZd]
                    [LclId] =
                        [w2_sdELJ] \u []
                            w2_sdELJ
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdELN [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxZd]
                    [LclId] =
                        [sat_sdELM] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdELM eta_B1; } in
                  let {
                    sat_sdELL [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxZd
                    [LclId] =
                        [w1_sdELI] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w1_sdELI eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadList w_sdELH sat_sdELL sat_sdELN; } in
        let {
          sat_sdELR [Occ=Once]
            :: forall b.
               ([f_sdxZb a_sdxZd] -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w3_sdELK] \r [w4_sdELO]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w3_sdELK w4_sdELO
                  of
                  { Unit# ww1_sdELQ [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdELQ];
                  };
        } in  sat_sdELR;

$dmliftReadListPrec3_rdymx
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP [f a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    sat-only [] \r [w_sdELS w1_sdELT w2_sdELU w3_sdELV]
        $w$dmliftReadListPrec_rdymw w_sdELS w1_sdELT w2_sdELU;

Data.Functor.Classes.$dmliftReadListPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A)><L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        $dmliftReadListPrec3_rdymx eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$dmliftReadPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(C(U)))),A,A,A)><L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdELW rp_sdELX rl_sdELY]
        let {
          f1_sdELZ [Occ=OnceL!, Dmd=<L,C(C(U))>]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdweR a_adwMZ)
          [LclId] =
              [$dRead1_sdELW rp_sdELX rl_sdELY] \u []
                  let {
                    sat_sdEM1 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adwMZ]
                    [LclId] =
                        [rl_sdELY] \u []
                            rl_sdELY
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEM2 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adwMZ]
                    [LclId] =
                        [sat_sdEM1] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEM1 eta_B1; } in
                  let {
                    sat_sdEM0 [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwMZ
                    [LclId] =
                        [rp_sdELX] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S rp_sdELX eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdELW sat_sdEM0 sat_sdEM2; } in
        let {
          sat_sdEM9 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [f1_sdELZ] \r [n_sdEM3]
                  let {
                    w_sdEM4 [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS (f_XdweR a_adwMZ)
                    [LclId] =
                        [f1_sdELZ n_sdEM3] \u [] f1_sdELZ n_sdEM3; } in
                  let {
                    sat_sdEM8 [Occ=OnceT[0]]
                      :: forall b.
                         (f_XdweR a_adwMZ -> Text.ParserCombinators.ReadP.P b)
                         -> Text.ParserCombinators.ReadP.P b
                    [LclId] =
                        [w_sdEM4] \r [w1_sdEM5]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdEM4 w1_sdEM5
                            of
                            { Unit# ww1_sdEM7 [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEM7];
                            };
                  } in  sat_sdEM8;
        } in  sat_sdEM9;

Data.Functor.Classes.$dmliftReadList
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C1(C(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdEMa rp_sdEMb rl_sdEMc]
        let {
          sat_sdEMk [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_XdweS a_adwMJ]
          [LclId] =
              [$dRead1_sdEMa rp_sdEMb rl_sdEMc] \u []
                  let {
                    sat_sdEMj [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec (f_XdweS a_adwMJ)
                    [LclId] =
                        [$dRead1_sdEMa rp_sdEMb rl_sdEMc] \s []
                            let {
                              sat_sdEMi [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwMJ]
                              [LclId] =
                                  [rl_sdEMc] \r [n_sdEMe w1_sdEMf]
                                      case
                                          Text.ParserCombinators.ReadP.$wreadS_to_P
                                              rl_sdEMc w1_sdEMf
                                      of
                                      { Unit# ww1_sdEMh [Occ=Once] ->
                                            Text.ParserCombinators.ReadP.Look [ww1_sdEMh];
                                      }; } in
                            let {
                              sat_sdEMd [Occ=Once]
                                :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwMJ
                              [LclId] =
                                  [rp_sdEMb] \r [eta_B1]
                                      Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                          rp_sdEMb eta_B1;
                            } in 
                              Data.Functor.Classes.liftReadPrec
                                  $dRead1_sdEMa sat_sdEMd sat_sdEMi;
                  } in 
                    GHC.Read.list
                        sat_sdEMj
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEMk;

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [rp_sdEMl rl_sdEMm]
        let {
          f_sdEMn [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adx31
          [LclId, Arity=1, Unf=OtherCon []] =
              [rp_sdEMl] \r [eta_B1]
                  Text.ParserCombinators.ReadPrec.readPrec_to_S rp_sdEMl eta_B1; } in
        let {
          f1_sdEMo [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adx31]
          [LclId] =
              [rl_sdEMm] \u []
                  rl_sdEMm
                      Data.Functor.Classes.$fRead1Identity5
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
        let {
          f2_sdEMp [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [a_adx31]
          [LclId, Arity=1, Unf=OtherCon []] =
              [f1_sdEMo] \r [eta_B1]
                  Text.ParserCombinators.ReadP.run f1_sdEMo eta_B1; } in
        let {
          sat_sdEMy [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (GHC.Base.NonEmpty a_adx31 -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [f_sdEMn f2_sdEMp] \r [n_sdEMq eta_sdEMr]
                  let {
                    sat_sdEMv [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_adx31)
                    [LclId] =
                        [f_sdEMn f2_sdEMp n_sdEMq] \r [w_sdEMs]
                            case n_sdEMq of {
                              GHC.Types.I# ww1_sdEMu [Occ=Once] ->
                                  Data.Functor.Classes.$w$cliftReadsPrec5
                                      f_sdEMn f2_sdEMp ww1_sdEMu w_sdEMs;
                            };
                  } in 
                    case
                        Text.ParserCombinators.ReadP.$wreadS_to_P sat_sdEMv eta_sdEMr
                    of
                    { Unit# ww1_sdEMx [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Look [ww1_sdEMx];
                    };
        } in  sat_sdEMy;

Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.NonEmpty a]
[GblId, Arity=2, Str=<L,C(C(U))><L,C(U)>, Unf=OtherCon []] =
    [] \r [rp_sdEMz rl_sdEMA]
        let {
          sat_sdEMU [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [GHC.Base.NonEmpty a_adx2T]
          [LclId] =
              [rp_sdEMz rl_sdEMA] \u []
                  let {
                    f_sdEMB [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adx2T
                    [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                        [rp_sdEMz] \r [n_sdEMC]
                            let {
                              sat_sdEMG [Occ=Once] :: Text.ParserCombinators.ReadP.P a_adx2T
                              [LclId] =
                                  [rp_sdEMz n_sdEMC] \u []
                                      let {
                                        sat_sdEMD [Occ=Once, Dmd=<L,C(U)>]
                                          :: Text.ParserCombinators.ReadP.ReadS a_adx2T
                                        [LclId] =
                                            [rp_sdEMz n_sdEMC] \u [] rp_sdEMz n_sdEMC;
                                      } in 
                                        case
                                            Text.ParserCombinators.ReadP.$wreadS_to_P
                                                sat_sdEMD
                                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                                        of
                                        { Unit# ww1_sdEMF [Occ=Once] ->
                                              Text.ParserCombinators.ReadP.Look [ww1_sdEMF];
                                        };
                            } in  Text.ParserCombinators.ReadP.run sat_sdEMG; } in
                  let {
                    f1_sdEMH [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_adx2T]
                    [LclId] =
                        [rl_sdEMA] \u []
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P
                                    rl_sdEMA Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                            of
                            { Unit# ww1_sdEMJ [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEMJ];
                            }; } in
                  let {
                    f2_sdEMK [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS [a_adx2T]
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [f1_sdEMH] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run f1_sdEMH eta_B1; } in
                  let {
                    sat_sdEMT [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.NonEmpty a_adx2T)
                    [LclId] =
                        [f_sdEMB f2_sdEMK] \r [n_sdEML eta_sdEMM]
                            let {
                              sat_sdEMQ [Occ=Once]
                                :: Text.ParserCombinators.ReadP.ReadS (GHC.Base.NonEmpty a_adx2T)
                              [LclId] =
                                  [f_sdEMB f2_sdEMK n_sdEML] \r [w_sdEMN]
                                      case n_sdEML of {
                                        GHC.Types.I# ww1_sdEMP [Occ=Once] ->
                                            Data.Functor.Classes.$w$cliftReadsPrec5
                                                f_sdEMB f2_sdEMK ww1_sdEMP w_sdEMN;
                                      };
                            } in 
                              case
                                  Text.ParserCombinators.ReadP.$wreadS_to_P sat_sdEMQ eta_sdEMM
                              of
                              { Unit# ww1_sdEMS [Occ=Once] ->
                                    Text.ParserCombinators.ReadP.Look [ww1_sdEMS];
                              };
                  } in 
                    GHC.Read.list
                        sat_sdEMT
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEMU;

Data.Functor.Classes.$w$cliftReadListPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> forall b.
        ([GHC.Base.NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [w_sdEMV w1_sdEMW]
        let {
          w2_sdEMX [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadS [GHC.Base.NonEmpty a_sdxZp]
          [LclId] =
              [w_sdEMV w1_sdEMW] \u []
                  let {
                    sat_sdEMZ [Occ=OnceL] :: Text.ParserCombinators.ReadP.P [a_sdxZp]
                    [LclId] =
                        [w1_sdEMW] \u []
                            w1_sdEMW
                                Data.Functor.Classes.$fRead1Identity5
                                Text.ParserCombinators.ReadP.$fApplicativeP_$cpure; } in
                  let {
                    sat_sdEN0 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.ReadS [a_sdxZp]
                    [LclId] =
                        [sat_sdEMZ] \r [eta_B1]
                            Text.ParserCombinators.ReadP.run sat_sdEMZ eta_B1; } in
                  let {
                    sat_sdEMY [Occ=Once]
                      :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_sdxZp
                    [LclId] =
                        [w_sdEMV] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readPrec_to_S w_sdEMV eta_B1;
                  } in 
                    Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
                        sat_sdEMY sat_sdEN0; } in
        let {
          sat_sdEN4 [Occ=OnceT[0]]
            :: forall b.
               ([GHC.Base.NonEmpty a_sdxZp] -> Text.ParserCombinators.ReadP.P b)
               -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [w2_sdEMX] \r [w3_sdEN1]
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P w2_sdEMX w3_sdEN1
                  of
                  { Unit# ww1_sdEN3 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdEN3];
                  };
        } in  sat_sdEN4;

Data.Functor.Classes.$fRead1NonEmpty1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([GHC.Base.NonEmpty a] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,1*C1(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdEN5 w1_sdEN6 w2_sdEN7]
        Data.Functor.Classes.$w$cliftReadListPrec2 w_sdEN5 w1_sdEN6;

Data.Functor.Classes.$fRead1NonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1NonEmpty_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadList
                                                 Data.Functor.Classes.$fRead1NonEmpty_$cliftReadPrec
                                                 Data.Functor.Classes.$fRead1NonEmpty1];

Data.Functor.Classes.$dmliftReadsPrec
  :: forall (f :: * -> *).
     Data.Functor.Classes.Read1 f =>
     forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C(C1(U)))),A)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdEN8 rp_sdEN9 rl_sdENa]
        let {
          ds_sdENb [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_XdweY a_adwMu)
          [LclId] =
              [$dRead1_sdEN8 rp_sdEN9 rl_sdENa] \u []
                  let {
                    sat_sdENh [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwMu]
                    [LclId] =
                        [rl_sdENa] \r [n_sdENd w1_sdENe]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sdENa w1_sdENe
                            of
                            { Unit# ww1_sdENg [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdENg];
                            }; } in
                  let {
                    sat_sdENc [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwMu
                    [LclId] =
                        [rp_sdEN9] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sdEN9 eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadPrec
                        $dRead1_sdEN8 sat_sdENc sat_sdENh; } in
        let {
          sat_sdENk [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (f_XdweY a_adwMu)
          [LclId] =
              [ds_sdENb] \r [n_sdENi]
                  let {
                    sat_sdENj [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (f_XdweY a_adwMu)
                    [LclId] =
                        [ds_sdENb n_sdENi] \u []
                            ds_sdENb
                                n_sdENi Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sdENj;
        } in  sat_sdENk;

Data.Functor.Classes.eq1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) =>
     f a -> f a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq1_sdENl $dEq_sdENm]
        let {
          sat_sdENn [Occ=Once] :: a_adwMf -> a_adwMf -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdENm] \u [] GHC.Classes.== $dEq_sdENm;
        } in  $dEq1_sdENl sat_sdENn;

Data.Functor.Classes.compare1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) =>
     f a -> f a -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)),1*U(A,1*C1(U))><L,1*U(A,1*U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd1_sdENo $dOrd_sdENp]
        let {
          sat_sdENq [Occ=Once] :: a_adwM3 -> a_adwM3 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdENp] \u [] GHC.Classes.compare $dOrd_sdENp;
        } in  Data.Functor.Classes.liftCompare $dOrd1_sdENo sat_sdENq;

Data.Functor.Classes.readsPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLL),1*U(1*C1(C1(U)),A,A,A)><L,U(1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdENr $dRead_sdENs]
        let {
          sat_sdENu [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [a_adwLh]
          [LclId] =
              [$dRead_sdENs] \u [] GHC.Read.readList $dRead_sdENs; } in
        let {
          sat_sdENt [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLh
          [LclId] =
              [$dRead_sdENs] \u [] GHC.Read.readsPrec $dRead_sdENs;
        } in 
          Data.Functor.Classes.liftReadsPrec
              $dRead1_sdENr sat_sdENt sat_sdENu;

Data.Functor.Classes.readsUnary1
  :: forall (f :: * -> *) a t.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     GHC.Base.String
     -> (f a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdENv
           $dRead_sdENw
           name_sdENx
           cons_sdENy
           kw_sdENz
           s_sdENA]
        case GHC.Base.eqString kw_sdENz name_sdENx of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdENC [Occ=LoopBreaker]
                  :: [(f_adwLt a_adwLu, GHC.Base.String)]
                     -> [(t_adwLv, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdENy go_sdENC] \r [ds_sdEND]
                        case ds_sdEND of {
                          [] -> [] [];
                          : y_sdENF [Occ=Once!] ys_sdENG [Occ=Once] ->
                              case y_sdENF of {
                                (,) x_sdENI [Occ=Once] t1_sdENJ [Occ=Once] ->
                                    let {
                                      sat_sdENM [Occ=Once] :: [(t_adwLv, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdENC ys_sdENG] \u [] go_sdENC ys_sdENG; } in
                                    let {
                                      sat_sdENK [Occ=Once] :: t_adwLv
                                      [LclId] =
                                          [cons_sdENy x_sdENI] \u [] cons_sdENy x_sdENI; } in
                                    let {
                                      sat_sdENL [Occ=Once] :: (t_adwLv, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdENK t1_sdENJ];
                                    } in  : [sat_sdENL sat_sdENM];
                              };
                        }; } in
              let {
                sat_sdENO [Occ=Once]
                  :: Text.ParserCombinators.ReadP.ReadS [a_adwLu]
                [LclId] =
                    [$dRead_sdENw] \u [] GHC.Read.readList $dRead_sdENw; } in
              let {
                sat_sdENN [Occ=Once]
                  :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLu
                [LclId] =
                    [$dRead_sdENw] \u [] GHC.Read.readsPrec $dRead_sdENw;
              } in 
                case
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdENv
                        sat_sdENN
                        sat_sdENO
                        Data.Functor.Classes.$fRead1Const1
                        s_sdENA
                of
                sat_sdENP
                { __DEFAULT -> go_sdENC sat_sdENP;
                };
        };

Data.Functor.Classes.readsBinary1
  :: forall (f :: * -> *) (g :: * -> *) a t.
     (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g,
      GHC.Read.Read a) =>
     GHC.Base.String
     -> (f a -> g a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(C(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><S,1*U><L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdENQ
           $dRead2_sdENR
           $dRead_sdENS
           name_sdENT
           cons_sdENU
           kw_sdENV
           s_sdENW]
        case GHC.Base.eqString kw_sdENV name_sdENT of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                lvl3_sdENY
                  :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwLJ
                [LclId] =
                    [$dRead_sdENS] \u [] GHC.Read.readsPrec $dRead_sdENS; } in
              let {
                lvl4_sdENZ :: Text.ParserCombinators.ReadP.ReadS [a_adwLJ]
                [LclId] =
                    [$dRead_sdENS] \u [] GHC.Read.readList $dRead_sdENS; } in
              let {
                go_sdEO0 [Occ=LoopBreaker]
                  :: [(f_adwLH a_adwLJ, GHC.Base.String)]
                     -> [(t_adwLK, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [$dRead2_sdENR
                              cons_sdENU
                              lvl3_sdENY
                              lvl4_sdENZ
                              go_sdEO0] \r [ds_sdEO1]
                        case ds_sdEO1 of {
                          [] -> [] [];
                          : y_sdEO3 [Occ=Once!] ys_sdEO4 [Occ=Once] ->
                              case y_sdEO3 of {
                                (,) x_sdEO6 [Occ=OnceL] t1_sdEO7 [Occ=Once] ->
                                    let {
                                      z_sdEO8 [Occ=OnceL] :: [(t_adwLK, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdEO0 ys_sdEO4] \u [] go_sdEO0 ys_sdEO4; } in
                                    let {
                                      go1_sdEO9 [Occ=LoopBreaker]
                                        :: [(g_adwLI a_adwLJ, GHC.Base.String)]
                                           -> [(t_adwLK, GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [cons_sdENU
                                                    x_sdEO6
                                                    z_sdEO8
                                                    go1_sdEO9] \r [ds1_sdEOa]
                                              case ds1_sdEOa of {
                                                [] -> z_sdEO8;
                                                : y1_sdEOc [Occ=Once!] ys1_sdEOd [Occ=Once] ->
                                                    case y1_sdEOc of {
                                                      (,) y2_sdEOf [Occ=Once] u_sdEOg [Occ=Once] ->
                                                          let {
                                                            sat_sdEOj [Occ=Once]
                                                              :: [(t_adwLK, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdEO9 ys1_sdEOd] \u []
                                                                    go1_sdEO9 ys1_sdEOd; } in
                                                          let {
                                                            sat_sdEOh [Occ=Once] :: t_adwLK
                                                            [LclId] =
                                                                [cons_sdENU x_sdEO6 y2_sdEOf] \u []
                                                                    cons_sdENU
                                                                        x_sdEO6 y2_sdEOf; } in
                                                          let {
                                                            sat_sdEOi [Occ=Once]
                                                              :: (t_adwLK, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sdEOh u_sdEOg];
                                                          } in  : [sat_sdEOi sat_sdEOj];
                                                    };
                                              };
                                    } in 
                                      case
                                          Data.Functor.Classes.liftReadsPrec
                                              $dRead2_sdENR
                                              lvl3_sdENY
                                              lvl4_sdENZ
                                              Data.Functor.Classes.$fRead1Const1
                                              t1_sdEO7
                                      of
                                      sat_sdEOk
                                      { __DEFAULT -> go1_sdEO9 sat_sdEOk;
                                      };
                              };
                        };
              } in 
                case
                    Data.Functor.Classes.liftReadsPrec
                        $dRead1_sdENQ
                        lvl3_sdENY
                        lvl4_sdENZ
                        Data.Functor.Classes.$fRead1Const1
                        s_sdENW
                of
                sat_sdEOl
                { __DEFAULT -> go_sdEO0 sat_sdEOl;
                };
        };

Data.Functor.Classes.readPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Read1 f, GHC.Read.Read a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec (f a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdEOm $dRead_sdEOn]
        let {
          sat_sdEOp [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwL4]
          [LclId] =
              [$dRead_sdEOn] \u [] GHC.Read.readListPrec $dRead_sdEOn; } in
        let {
          sat_sdEOo [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwL4
          [LclId] =
              [$dRead_sdEOn] \u [] GHC.Read.readPrec $dRead_sdEOn;
        } in 
          Data.Functor.Classes.liftReadPrec
              $dRead1_sdEOm sat_sdEOo sat_sdEOp;

Data.Functor.Classes.liftReadListDefault
  :: forall (f :: * -> *) a.
     Data.Functor.Classes.Read1 f =>
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [f a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdEOq rp_sdEOr rl_sdEOs]
        let {
          sat_sdEOz [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_adwKQ a_adwKR]
          [LclId] =
              [$dRead1_sdEOq rp_sdEOr rl_sdEOs] \u []
                  let {
                    sat_sdEOy [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwKR]
                    [LclId] =
                        [rl_sdEOs] \r [n_sdEOu w1_sdEOv]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl_sdEOs w1_sdEOv
                            of
                            { Unit# ww1_sdEOx [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEOx];
                            }; } in
                  let {
                    sat_sdEOt [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwKR
                    [LclId] =
                        [rp_sdEOr] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp_sdEOr eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadListPrec
                        $dRead1_sdEOq
                        sat_sdEOt
                        sat_sdEOy
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEOz;

Data.Functor.Classes.liftReadListPrecDefault
  :: forall (f :: * -> *) a.
     Data.Functor.Classes.Read1 f =>
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C1(C1(C(U)))),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead1_sdEOA rp_sdEOB rl_sdEOC]
        let {
          sat_sdEOD [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (f_adwKH a_adwKI)
          [LclId] =
              [$dRead1_sdEOA rp_sdEOB rl_sdEOC] \s []
                  Data.Functor.Classes.liftReadPrec $dRead1_sdEOA rp_sdEOB rl_sdEOC;
        } in  GHC.Read.list sat_sdEOD;

lvl_rdymy
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Proxy.Proxy a]
[GblId] =
    [] \u [] GHC.Read.list Data.Functor.Classes.$fRead1Proxy1;

Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [Data.Proxy.Proxy a]
[GblId, Arity=2, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdEOE rl_sdEOF] lvl_rdymy;

Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Proxy.Proxy a)
[GblId, Arity=3, Str=<L,A><L,A><L,U>, Unf=OtherCon []] =
    [] \r [rp_sdEOG rl_sdEOH n_sdEOI]
        let {
          sat_sdEOJ [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Proxy.Proxy a_adx12)
          [LclId] =
              [n_sdEOI] \u []
                  GHC.Read.list3
                      Data.Functor.Classes.$fRead1Proxy2
                      n_sdEOI
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEOJ;

lvl1_rdymz
  :: forall a. Text.ParserCombinators.ReadP.P [Data.Proxy.Proxy a]
[GblId] =
    [] \u []
        GHC.Read.list
            Data.Functor.Classes.$fRead1Proxy1
            Data.Functor.Classes.$fRead1Identity5
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

lvl2_rdymA
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS [Data.Proxy.Proxy a]
[GblId, Arity=1, Unf=OtherCon []] =
    sat-only [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run lvl1_rdymz eta_B1;

Data.Functor.Classes.$fRead1Proxy_$cliftReadList
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Proxy.Proxy a]
[GblId, Arity=3, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdEOK rl_sdEOL eta_B1] lvl2_rdymA eta_B1;

Data.Functor.Classes.$fRead1Proxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Proxy_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Proxy_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Proxy5
                                                 Data.Functor.Classes.$fRead1Proxy_$cliftReadListPrec];

Data.Functor.Classes.$fRead1[]_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [[a]]
[GblId, Arity=2, Str=<L,A><L,1*C1(C(U))>, Unf=OtherCon []] =
    [] \r [rp_sdEOM rl_sdEON] GHC.Read.list rl_sdEON;

Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,C(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [rp_sdEOO rl_sdEOP eta_sdEOQ]
        let {
          sat_sdEOT [Occ=Once] :: Text.ParserCombinators.ReadP.P [a_adx3j]
          [LclId] =
              [rl_sdEOP] \u []
                  case
                      Text.ParserCombinators.ReadP.$wreadS_to_P
                          rl_sdEOP Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                  of
                  { Unit# ww1_sdEOS [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Look [ww1_sdEOS];
                  };
        } in  Text.ParserCombinators.ReadP.run sat_sdEOT;

Data.Functor.Classes.$w$cliftReadList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [[a]]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [w_sdEOU]
        let {
          sat_sdEP0 [Occ=Once] :: Text.ParserCombinators.ReadP.P [[a_sdxZW]]
          [LclId] =
              [w_sdEOU] \u []
                  let {
                    sat_sdEOZ [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_sdxZW]
                    [LclId] =
                        [w_sdEOU] \r [n_sdEOV w1_sdEOW]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P w_sdEOU w1_sdEOW
                            of
                            { Unit# ww1_sdEOY [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEOY];
                            };
                  } in 
                    GHC.Read.list
                        sat_sdEOZ
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEP0;

Data.Functor.Classes.$fRead1[]_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [[a]]
[GblId, Arity=2, Str=<L,A><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_sdEP1 w1_sdEP2]
        Data.Functor.Classes.$w$cliftReadList2 w1_sdEP2;

Data.Functor.Classes.$fRead1[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 []
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1[]_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadList
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadPrec
                                                 Data.Functor.Classes.$fRead1[]_$cliftReadListPrec];

Data.Functor.Classes.showsPrec1
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Types.Int -> f a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U(1*U,A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dShow1_sdEP3 $dShow_sdEP4]
        let {
          sat_sdEP6 [Occ=Once] :: [a_adwJB] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEP4] \u [] GHC.Show.showList $dShow_sdEP4; } in
        let {
          sat_sdEP5 [Occ=Once] :: GHC.Types.Int -> a_adwJB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEP4] \u [] GHC.Show.showsPrec $dShow_sdEP4;
        } in 
          Data.Functor.Classes.liftShowsPrec
              $dShow1_sdEP3 sat_sdEP5 sat_sdEP6;

Data.Functor.Classes.showsUnaryWith1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! [' '#];

Data.Functor.Classes.$wshowsUnary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Prim.Int# -> f a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(1*U,A,1*U)><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEP7 w1_sdEP8 w2_sdEP9 ww_sdEPa w3_sdEPb]
        let {
          g_sdEPc [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEP7 w1_sdEP8 w3_sdEPb] \u []
                  let {
                    sat_sdEPe [Occ=Once] :: [a_sdy01] -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sdEP8] \u [] GHC.Show.showList w1_sdEP8; } in
                  let {
                    sat_sdEPd [Occ=Once] :: GHC.Types.Int -> a_sdy01 -> GHC.Show.ShowS
                    [LclId] =
                        [w1_sdEP8] \u [] GHC.Show.showsPrec w1_sdEP8;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sdEP7
                        sat_sdEPd
                        sat_sdEPe
                        Data.Functor.Classes.$fRead1Const1
                        w3_sdEPb;
        } in 
          case ># [ww_sdEPa 10#] of {
            __DEFAULT ->
                let {
                  sat_sdEPj [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdEP9 g_sdEPc] \r [x_sdEPg]
                          let {
                            sat_sdEPh [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdEPc x_sdEPg] \u [] g_sdEPc x_sdEPg; } in
                          let {
                            sat_sdEPi [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEPh];
                          } in  GHC.Base.++ w2_sdEP9 sat_sdEPi;
                } in  sat_sdEPj;
            1# ->
                let {
                  sat_sdEPp [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdEP9 g_sdEPc] \r [x_sdEPk]
                          let {
                            sat_sdEPo [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w2_sdEP9 g_sdEPc x_sdEPk] \u []
                                    let {
                                      sat_sdEPm [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdEPc x_sdEPk] \u []
                                              let {
                                                sat_sdEPl [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdEPk];
                                              } in  g_sdEPc sat_sdEPl; } in
                                    let {
                                      sat_sdEPn [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEPm];
                                    } in  GHC.Base.++ w2_sdEP9 sat_sdEPn;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEPo];
                } in  sat_sdEPp;
          };

Data.Functor.Classes.showsUnary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data.Functor.Classes.Show1 f, GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Types.Int -> f a -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEPq w1_sdEPr w2_sdEPs w3_sdEPt w4_sdEPu]
        case w3_sdEPt of {
          GHC.Types.I# ww1_sdEPw [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnary1
                  w_sdEPq w1_sdEPr w2_sdEPs ww1_sdEPw w4_sdEPu;
        };

Data.Functor.Classes.$wshowsBinary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Prim.Int# -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEPx
           w1_sdEPy
           w2_sdEPz
           w3_sdEPA
           ww_sdEPB
           w4_sdEPC
           w5_sdEPD]
        let {
          f1_sdEPE [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEPx w2_sdEPz w4_sdEPC] \u []
                  let {
                    sat_sdEPG [Occ=Once] :: [a_sdy0e] -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdEPz] \u [] GHC.Show.showList w2_sdEPz; } in
                  let {
                    sat_sdEPF [Occ=Once] :: GHC.Types.Int -> a_sdy0e -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdEPz] \u [] GHC.Show.showsPrec w2_sdEPz;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w_sdEPx
                        sat_sdEPF
                        sat_sdEPG
                        Data.Functor.Classes.$fRead1Const1
                        w4_sdEPC; } in
        let {
          g1_sdEPH [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdEPy w2_sdEPz w5_sdEPD] \u []
                  let {
                    sat_sdEPJ [Occ=Once] :: [a_sdy0e] -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdEPz] \u [] GHC.Show.showList w2_sdEPz; } in
                  let {
                    sat_sdEPI [Occ=Once] :: GHC.Types.Int -> a_sdy0e -> GHC.Show.ShowS
                    [LclId] =
                        [w2_sdEPz] \u [] GHC.Show.showsPrec w2_sdEPz;
                  } in 
                    Data.Functor.Classes.liftShowsPrec
                        w1_sdEPy
                        sat_sdEPI
                        sat_sdEPJ
                        Data.Functor.Classes.$fRead1Const1
                        w5_sdEPD;
        } in 
          case ># [ww_sdEPB 10#] of {
            __DEFAULT ->
                let {
                  sat_sdEPQ [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w3_sdEPA f1_sdEPE g1_sdEPH] \r [x_sdEPL]
                          let {
                            sat_sdEPO [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_sdEPE g1_sdEPH x_sdEPL] \u []
                                    let {
                                      sat_sdEPM [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g1_sdEPH x_sdEPL] \u [] g1_sdEPH x_sdEPL; } in
                                    let {
                                      sat_sdEPN [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEPM];
                                    } in  f1_sdEPE sat_sdEPN; } in
                          let {
                            sat_sdEPP [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEPO];
                          } in  GHC.Base.++ w3_sdEPA sat_sdEPP;
                } in  sat_sdEPQ;
            1# ->
                let {
                  sat_sdEPY [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w3_sdEPA f1_sdEPE g1_sdEPH] \r [x_sdEPR]
                          let {
                            sat_sdEPX [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w3_sdEPA f1_sdEPE g1_sdEPH x_sdEPR] \u []
                                    let {
                                      sat_sdEPV [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_sdEPE g1_sdEPH x_sdEPR] \u []
                                              let {
                                                sat_sdEPT [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g1_sdEPH x_sdEPR] \u []
                                                        let {
                                                          sat_sdEPS [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdEPR];
                                                        } in  g1_sdEPH sat_sdEPS; } in
                                              let {
                                                sat_sdEPU [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [Data.Functor.Classes.showsUnaryWith1
                                                             sat_sdEPT];
                                              } in  f1_sdEPE sat_sdEPU; } in
                                    let {
                                      sat_sdEPW [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEPV];
                                    } in  GHC.Base.++ w3_sdEPA sat_sdEPW;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEPX];
                } in  sat_sdEPY;
          };

Data.Functor.Classes.showsBinary1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g,
      GHC.Show.Show a) =>
     GHC.Base.String -> GHC.Types.Int -> f a -> g a -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,1*U(1*C1(C1(C1(C1(C(U))))),A)><L,U(U,A,U)><L,U><S(S),1*U(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEPZ
           w1_sdEQ0
           w2_sdEQ1
           w3_sdEQ2
           w4_sdEQ3
           w5_sdEQ4
           w6_sdEQ5]
        case w4_sdEQ3 of {
          GHC.Types.I# ww1_sdEQ7 [Occ=Once] ->
              Data.Functor.Classes.$wshowsBinary1
                  w_sdEPZ w1_sdEQ0 w2_sdEQ1 w3_sdEQ2 ww1_sdEQ7 w5_sdEQ4 w6_sdEQ5;
        };

Data.Functor.Classes.eq2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Eq2 f, GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     f a b -> f a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*U(1*U,A)><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq2_sdEQ8 $dEq_sdEQ9 $dEq1_sdEQa]
        let {
          sat_sdEQc [Occ=Once] :: b_adwJk -> b_adwJk -> GHC.Types.Bool
          [LclId] =
              [$dEq1_sdEQa] \u [] GHC.Classes.== $dEq1_sdEQa; } in
        let {
          sat_sdEQb [Occ=Once] :: a_adwJj -> a_adwJj -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdEQ9] \u [] GHC.Classes.== $dEq_sdEQ9;
        } in  $dEq2_sdEQ8 sat_sdEQb sat_sdEQc;

Data.Functor.Classes.compare2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Ord2 f, GHC.Classes.Ord a,
      GHC.Classes.Ord b) =>
     f a b -> f a b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,1*U(A,1*U,A,A,A,A,A,A)><L,1*U(A,1*U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd2_sdEQd $dOrd_sdEQe $dOrd1_sdEQf]
        let {
          sat_sdEQh [Occ=Once] :: b_adwJ2 -> b_adwJ2 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd1_sdEQf] \u [] GHC.Classes.compare $dOrd1_sdEQf; } in
        let {
          sat_sdEQg [Occ=Once] :: a_adwJ1 -> a_adwJ1 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sdEQe] \u [] GHC.Classes.compare $dOrd_sdEQe;
        } in 
          Data.Functor.Classes.liftCompare2 $dOrd2_sdEQd sat_sdEQg sat_sdEQh;

Data.Functor.Classes.readsPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Read2 f, GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(C(S))))LLL),1*U(1*C1(C1(C1(C1(U)))),A,A,A)><L,U(1*U,1*U,A,A)><L,U(1*U,1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEQi $dRead_sdEQj $dRead1_sdEQk]
        let {
          sat_sdEQo [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [b_adwII]
          [LclId] =
              [$dRead1_sdEQk] \u [] GHC.Read.readList $dRead1_sdEQk; } in
        let {
          sat_sdEQn [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b_adwII
          [LclId] =
              [$dRead1_sdEQk] \u [] GHC.Read.readsPrec $dRead1_sdEQk; } in
        let {
          sat_sdEQm [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [a_adwIH]
          [LclId] =
              [$dRead_sdEQj] \u [] GHC.Read.readList $dRead_sdEQj; } in
        let {
          sat_sdEQl [Occ=Once]
            :: GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a_adwIH
          [LclId] =
              [$dRead_sdEQj] \u [] GHC.Read.readsPrec $dRead_sdEQj;
        } in 
          Data.Functor.Classes.liftReadsPrec2
              $dRead2_sdEQi sat_sdEQl sat_sdEQm sat_sdEQn sat_sdEQo;

Data.Functor.Classes.readPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Read2 f, GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U(A,A,1*U,1*U)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEQp $dRead_sdEQq $dRead1_sdEQr]
        let {
          sat_sdEQv [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwIo]
          [LclId] =
              [$dRead1_sdEQr] \u [] GHC.Read.readListPrec $dRead1_sdEQr; } in
        let {
          sat_sdEQu [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwIo
          [LclId] =
              [$dRead1_sdEQr] \u [] GHC.Read.readPrec $dRead1_sdEQr; } in
        let {
          sat_sdEQt [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwIn]
          [LclId] =
              [$dRead_sdEQq] \u [] GHC.Read.readListPrec $dRead_sdEQq; } in
        let {
          sat_sdEQs [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwIn
          [LclId] =
              [$dRead_sdEQq] \u [] GHC.Read.readPrec $dRead_sdEQq;
        } in 
          Data.Functor.Classes.liftReadPrec2
              $dRead2_sdEQp sat_sdEQs sat_sdEQt sat_sdEQu sat_sdEQv;

Data.Functor.Classes.liftReadList2Default
  :: forall (f :: * -> * -> *) a b.
     Data.Functor.Classes.Read2 f =>
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [f a b]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(C1(C1(C1(C1(C1(U)))))))><L,C(C(U))><L,C(U)><L,C(C(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEQw rp1_sdEQx rl1_sdEQy rp2_sdEQz rl2_sdEQA]
        let {
          sat_sdEQN [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [f_adwHZ a_adwI0 b_adwI1]
          [LclId] =
              [$dRead2_sdEQw rp1_sdEQx rl1_sdEQy rp2_sdEQz rl2_sdEQA] \u []
                  let {
                    sat_sdEQM [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [b_adwI1]
                    [LclId] =
                        [rl2_sdEQA] \r [n_sdEQI w1_sdEQJ]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl2_sdEQA w1_sdEQJ
                            of
                            { Unit# ww1_sdEQL [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEQL];
                            }; } in
                  let {
                    sat_sdEQH [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec b_adwI1
                    [LclId] =
                        [rp2_sdEQz] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                rp2_sdEQz eta_B1; } in
                  let {
                    sat_sdEQG [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec [a_adwI0]
                    [LclId] =
                        [rl1_sdEQy] \r [n_sdEQC w1_sdEQD]
                            case
                                Text.ParserCombinators.ReadP.$wreadS_to_P rl1_sdEQy w1_sdEQD
                            of
                            { Unit# ww1_sdEQF [Occ=Once] ->
                                  Text.ParserCombinators.ReadP.Look [ww1_sdEQF];
                            }; } in
                  let {
                    sat_sdEQB [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwI0
                    [LclId] =
                        [rp1_sdEQx] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 rp1_sdEQx eta_B1;
                  } in 
                    Data.Functor.Classes.liftReadListPrec2
                        $dRead2_sdEQw
                        sat_sdEQB
                        sat_sdEQG
                        sat_sdEQH
                        sat_sdEQM
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEQN;

Data.Functor.Classes.$fRead2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 Data.Either.Either
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2Either_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2Either_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1Either8
                                                 Data.Functor.Classes.$fRead2Either_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2Either_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a b]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2Either eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2Const_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2Const_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1Const6
                                                 Data.Functor.Classes.$fRead2Const_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2Const_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Const.Const a b]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2Const eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead2(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read2 (,)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read2! [Data.Functor.Classes.$fRead2(,)_$cliftReadsPrec2
                                                 Data.Functor.Classes.$fRead2(,)_$cliftReadList2
                                                 Data.Functor.Classes.$fRead1(,)2
                                                 Data.Functor.Classes.$fRead2(,)_$cliftReadListPrec2];
Data.Functor.Classes.$fRead2(,)_$cliftReadList2 [Occ=LoopBreaker]
  :: forall a b.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> Text.ParserCombinators.ReadP.ReadS [b]
     -> Text.ParserCombinators.ReadP.ReadS [(a, b)]
[GblId, Arity=4, Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.liftReadList2Default
            Data.Functor.Classes.$fRead2(,) eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.liftReadListPrec2Default
  :: forall (f :: * -> * -> *) a b.
     Data.Functor.Classes.Read2 f =>
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C1(C1(C1(C1(C1(C(U)))))),A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead2_sdEQO rp1_sdEQP rl1_sdEQQ rp2_sdEQR rl2_sdEQS]
        let {
          sat_sdEQT [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (f_adwHO a_adwHP b_adwHQ)
          [LclId] =
              [$dRead2_sdEQO rp1_sdEQP rl1_sdEQQ rp2_sdEQR rl2_sdEQS] \s []
                  Data.Functor.Classes.liftReadPrec2
                      $dRead2_sdEQO rp1_sdEQP rl1_sdEQQ rp2_sdEQR rl2_sdEQS;
        } in  GHC.Read.list sat_sdEQT;

Data.Functor.Classes.$fRead1(,)1
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a, a1) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdEQU eta_sdEQV eta1_sdEQW eta2_sdEQX eta3_sdEQY]
        let {
          sat_sdEQZ [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwUw
          [LclId] =
              [$dRead_sdEQU] \u [] GHC.Read.readPrec $dRead_sdEQU;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec2
              sat_sdEQZ eta_sdEQV eta2_sdEQX eta3_sdEQY;

Data.Functor.Classes.$w$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (a, a1)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdER0 w1_sdER1 w2_sdER2]
        let {
          sat_sdER5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (a_sdy0L, a1_sdy0N)
          [LclId] =
              [w_sdER0 w1_sdER1 w2_sdER2] \u []
                  let {
                    sat_sdER4 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a1_sdy0N
                    [LclId] =
                        [w1_sdER1] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdER1 eta_B1; } in
                  let {
                    sat_sdER3 [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy0L
                    [LclId] =
                        [w_sdER0] \u [] GHC.Read.readPrec w_sdER0;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec2
                        sat_sdER3
                        sat_sdER4
                        w2_sdER2
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdER5;

Data.Functor.Classes.$fRead1(,)_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a, a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdER6 w1_sdER7 w2_sdER8 w3_sdER9]
        Data.Functor.Classes.$w$cliftReadsPrec w_sdER6 w1_sdER7 w3_sdER9;

Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [(a, a1)]
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdERa rp_sdERb rl_sdERc]
        let {
          sat_sdERd [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec (a_XdwZz, a1_adwV6)
          [LclId] =
              [$dRead_sdERa rp_sdERb rl_sdERc] \r [eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)1
                      $dRead_sdERa rp_sdERb rl_sdERc eta_B2 eta_B1;
        } in  GHC.Read.list sat_sdERd;

Data.Functor.Classes.$fRead1(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => Data.Functor.Classes.Read1 ((,) a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdERe]
        let {
          sat_sdERl [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec [(a_XdwZy, a)]
          [LclId] =
              [$dRead_sdERe] \r [eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)_$cliftReadListPrec
                      $dRead_sdERe eta_B2 eta_B1; } in
        let {
          sat_sdERk [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec (a_XdwZy, a)
          [LclId] =
              [$dRead_sdERe] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1(,)1
                      $dRead_sdERe eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdERj [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS [(a_XdwZy, a)]
          [LclId] =
              [$dRead_sdERe] \u []
                  Data.Functor.Classes.$fRead1(,)_$cliftReadList $dRead_sdERe; } in
        let {
          sat_sdERi [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (a_XdwZy, a)
          [LclId] =
              [$dRead_sdERe] \r [w_sdERf w1_sdERg w2_sdERh]
                  Data.Functor.Classes.$w$cliftReadsPrec
                      $dRead_sdERe w_sdERf w2_sdERh;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdERi
                                        sat_sdERj
                                        sat_sdERk
                                        sat_sdERl];
Data.Functor.Classes.$fRead1(,)_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS [(a, a1)]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdERm]
        let {
          sat_sdERn [Occ=Once] :: Data.Functor.Classes.Read1 ((,) a_XdwZA)
          [LclId] =
              [$dRead_sdERm] \u [] Data.Functor.Classes.$fRead1(,) $dRead_sdERm;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdERn;

Data.Functor.Classes.showsPrec2
  :: forall (f :: * -> * -> *) a b.
     (Data.Functor.Classes.Show2 f, GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> f a b -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(C(S))))L),1*U(1*C1(C1(C1(C1(U)))),A)><L,U(1*U,A,1*U)><L,U(1*U,A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dShow2_sdERo $dShow_sdERp $dShow1_sdERq]
        let {
          sat_sdERu [Occ=Once] :: [b_adwHw] -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdERq] \u [] GHC.Show.showList $dShow1_sdERq; } in
        let {
          sat_sdERt [Occ=Once] :: GHC.Types.Int -> b_adwHw -> GHC.Show.ShowS
          [LclId] =
              [$dShow1_sdERq] \u [] GHC.Show.showsPrec $dShow1_sdERq; } in
        let {
          sat_sdERs [Occ=Once] :: [a_adwHv] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdERp] \u [] GHC.Show.showList $dShow_sdERp; } in
        let {
          sat_sdERr [Occ=Once] :: GHC.Types.Int -> a_adwHv -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdERp] \u [] GHC.Show.showsPrec $dShow_sdERp;
        } in 
          Data.Functor.Classes.liftShowsPrec2
              $dShow2_sdERo sat_sdERr sat_sdERs sat_sdERt sat_sdERu;

Data.Functor.Classes.$wreadsData [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Prim.Int# -> GHC.Base.String -> [(a, GHC.Base.String)]
[GblId, Arity=3, Str=<L,C(C1(U))><S,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdERv ww_sdERw w1_sdERx]
        let {
          go_sdERy [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_sdy11, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sdERv go_sdERy] \r [ds_sdERz]
                  case ds_sdERz of {
                    [] -> [] [];
                    : y_sdERB [Occ=Once!] ys_sdERC [Occ=Once] ->
                        case y_sdERB of {
                          (,) kw_sdERE [Occ=Once] s_sdERF [Occ=Once] ->
                              let {
                                sat_sdERH [Occ=Once, Dmd=<L,1*U>] :: [(a_sdy11, GHC.Base.String)]
                                [LclId] =
                                    [go_sdERy ys_sdERC] \s [] go_sdERy ys_sdERC;
                              } in 
                                case w_sdERv kw_sdERE s_sdERF of sat_sdERG {
                                  __DEFAULT -> GHC.Base.++ sat_sdERG sat_sdERH;
                                };
                        };
                  }; } in
        let {
          sat_sdERM [Occ=Once] :: Text.ParserCombinators.ReadP.ReadS a_sdy11
          [LclId] =
              [go_sdERy] \r [r_sdERK]
                  case
                      Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_sdERK
                  of
                  sat_sdERL
                  { __DEFAULT -> go_sdERy sat_sdERL;
                  };
        } in 
          case ># [ww_sdERw 10#] of sat_sdERI {
            __DEFAULT ->
                case tagToEnum# [sat_sdERI] of sat_sdERJ {
                  __DEFAULT -> GHC.Read.readParen sat_sdERJ sat_sdERM w1_sdERx;
                };
          };

Data.Functor.Classes.readsData [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdERN w1_sdERO w2_sdERP]
        case w1_sdERO of {
          GHC.Types.I# ww1_sdERR [Occ=Once] ->
              Data.Functor.Classes.$wreadsData w_sdERN ww1_sdERR w2_sdERP;
        };

Data.Functor.Classes.readData2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

Data.Functor.Classes.readData1
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [reader_sdERS eta_sdERT eta1_sdERU]
        let {
          lvl3_sdERV [Occ=OnceL, Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_adwHc
          [LclId] =
              [reader_sdERS] \u []
                  reader_sdERS Data.Functor.Classes.readData2; } in
        let {
          sat_sdES0 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwHc
          [LclId] =
              [lvl3_sdERV] \r [c_sdERW]
                  case c_sdERW of {
                    GHC.Types.I# x_sdERY [Occ=Once] ->
                        case <=# [x_sdERY 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.$fAlternativeReadP4;
                          1# -> lvl3_sdERV;
                        };
                  };
        } in  GHC.Read.list3 sat_sdES0 eta_sdERT eta1_sdERU;

Data.Functor.Classes.readData
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec a
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readData1 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.readsUnaryWith
  :: forall a t.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Base.String
     -> (a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [rp_sdES1 name_sdES2 cons_sdES3 kw_sdES4 s_sdES5]
        case GHC.Base.eqString kw_sdES4 name_sdES2 of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdES7 [Occ=LoopBreaker]
                  :: [(a_adwH5, GHC.Base.String)] -> [(t_adwH6, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdES3 go_sdES7] \r [ds_sdES8]
                        case ds_sdES8 of {
                          [] -> [] [];
                          : y_sdESa [Occ=Once!] ys_sdESb [Occ=Once] ->
                              case y_sdESa of {
                                (,) x_sdESd [Occ=Once] t1_sdESe [Occ=Once] ->
                                    let {
                                      sat_sdESh [Occ=Once] :: [(t_adwH6, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdES7 ys_sdESb] \u [] go_sdES7 ys_sdESb; } in
                                    let {
                                      sat_sdESf [Occ=Once] :: t_adwH6
                                      [LclId] =
                                          [cons_sdES3 x_sdESd] \u [] cons_sdES3 x_sdESd; } in
                                    let {
                                      sat_sdESg [Occ=Once] :: (t_adwH6, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdESf t1_sdESe];
                                    } in  : [sat_sdESg sat_sdESh];
                              };
                        };
              } in 
                case
                    rp_sdES1 Data.Functor.Classes.$fRead1Const1 s_sdES5
                of
                sat_sdESi
                { __DEFAULT -> go_sdES7 sat_sdESi;
                };
        };

Data.Functor.Classes.$wreadUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (t -> Text.ParserCombinators.ReadP.P b)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b #)
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_sdESj w1_sdESk w2_sdESl w3_sdESm w4_sdESn]
        let {
          sat_sdESx [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_sdy1t
          [LclId] =
              [w_sdESj w2_sdESl w3_sdESm w4_sdESn] \r [a1_sdESp]
                  let {
                    sat_sdESw [Occ=Once]
                      :: a_sdy1n -> Text.ParserCombinators.ReadP.P b_sdy1t
                    [LclId] =
                        [w2_sdESl w4_sdESn] \r [a2_sdESu]
                            let {
                              sat_sdESv [Occ=Once] :: t_sdy1o
                              [LclId] =
                                  [w2_sdESl a2_sdESu] \u [] w2_sdESl a2_sdESu;
                            } in  w4_sdESn sat_sdESv; } in
                  let {
                    sat_sdESt [Occ=Once] :: Text.ParserCombinators.ReadPrec.Prec
                    [LclId] =
                        [w3_sdESm] \u []
                            case w3_sdESm of {
                              GHC.Types.I# x_sdESr [Occ=Once] ->
                                  case +# [x_sdESr 1#] of sat_sdESs {
                                    __DEFAULT -> GHC.Types.I# [sat_sdESs];
                                  };
                            };
                  } in  w_sdESj sat_sdESt sat_sdESw; } in
        let {
          sat_sdESo [Occ=Once] :: Text.Read.Lex.Lexeme
          [LclId] =
              CCCS Text.Read.Lex.Ident! [w1_sdESk];
        } in  Text.Read.Lex.$wexpect sat_sdESo sat_sdESx;

Data.Functor.Classes.readUnaryWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (t -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_sdESy w1_sdESz w2_sdESA w3_sdESB w4_sdESC]
        case
            Data.Functor.Classes.$wreadUnaryWith
                w_sdESy w1_sdESz w2_sdESA w3_sdESB w4_sdESC
        of
        { Unit# ww1_sdESE [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_sdESE];
        };

Data.Functor.Classes.readUnaryWith
  :: forall a t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> GHC.Base.String
     -> (a -> t)
     -> Text.ParserCombinators.ReadPrec.ReadPrec t
[GblId,
 Arity=5,
 Str=<L,1*C1(C1(U))><L,U><L,C(U)><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readUnaryWith1
            eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$fRead1Const5
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Const.Const a a1 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdESF eta_sdESG eta1_sdESH eta2_sdESI eta3_sdESJ]
        let {
          sat_sdESK [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwRr
          [LclId] =
              [$dRead_sdESF] \u [] GHC.Read.readPrec $dRead_sdESF;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec1
              sat_sdESK eta2_sdESI eta3_sdESJ;

Data.Functor.Classes.$w$cliftReadsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a a1)
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdESL w1_sdESM]
        let {
          sat_sdESO [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Const.Const a_sdy1z a1_sdy1B)
          [LclId] =
              [w_sdESL w1_sdESM] \u []
                  let {
                    sat_sdESN [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1z
                    [LclId] =
                        [w_sdESL] \u [] GHC.Read.readPrec w_sdESL;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec1
                        sat_sdESN
                        w1_sdESM
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdESO;

Data.Functor.Classes.$fRead1Const_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Const.Const a a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdESP w1_sdESQ w2_sdESR w3_sdESS]
        Data.Functor.Classes.$w$cliftReadsPrec1 w_sdESP w3_sdESS;

Data.Functor.Classes.$w$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Functor.Const.Const a a1]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [w_sdEST]
        let {
          w1_sdESU [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1G
          [LclId] =
              [w_sdEST] \u [] GHC.Read.readPrec w_sdEST; } in
        let {
          sat_sdESX [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Const.Const a_sdy1G a1_sdy1I)
          [LclId] =
              [w1_sdESU] \r [w2_sdESV w3_sdESW]
                  Data.Functor.Classes.$w$cliftReadPrec1 w1_sdESU w2_sdESV w3_sdESW;
        } in  GHC.Read.list sat_sdESX;

Data.Functor.Classes.$fRead1Const_$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Const.Const a a1]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdESY w1_sdESZ w2_sdET0]
        Data.Functor.Classes.$w$cliftReadListPrec w_sdESY;

Data.Functor.Classes.$fRead1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     Data.Functor.Classes.Read1 (Data.Functor.Const.Const a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdET1]
        let {
          lvl3_sdET2 [Occ=OnceL]
            :: forall a1.
               Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Functor.Const.Const a_XdwZZ a1]
          [LclId] =
              [$dRead_sdET1] \u []
                  Data.Functor.Classes.$w$cliftReadListPrec $dRead_sdET1; } in
        let {
          sat_sdETb [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Functor.Const.Const a_XdwZZ a]
          [LclId] =
              [lvl3_sdET2] \r [w_sdET9 w1_sdETa] lvl3_sdET2; } in
        let {
          sat_sdET8 [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Functor.Const.Const a_XdwZZ a)
          [LclId] =
              [$dRead_sdET1] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1Const5
                      $dRead_sdET1 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdET7 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Functor.Const.Const a_XdwZZ a]
          [LclId] =
              [$dRead_sdET1] \u []
                  Data.Functor.Classes.$fRead1Const_$cliftReadList $dRead_sdET1; } in
        let {
          sat_sdET6 [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Functor.Const.Const a_XdwZZ a)
          [LclId] =
              [$dRead_sdET1] \r [w_sdET3 w1_sdET4 w2_sdET5]
                  Data.Functor.Classes.$w$cliftReadsPrec1 $dRead_sdET1 w2_sdET5;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdET6
                                        sat_sdET7
                                        sat_sdET8
                                        sat_sdETb];
Data.Functor.Classes.$fRead1Const_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Const.Const a a1]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdETc]
        let {
          sat_sdETd [Occ=Once]
            :: Data.Functor.Classes.Read1 (Data.Functor.Const.Const a_Xdx00)
          [LclId] =
              [$dRead_sdETc] \u []
                  Data.Functor.Classes.$fRead1Const $dRead_sdETc;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdETd;

Data.Functor.Classes.$fRead1Either7
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Either.Either a a1 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=5,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdETe eta_sdETf eta1_sdETg eta2_sdETh eta3_sdETi]
        let {
          sat_sdETj [Occ=Once, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_adwSV
          [LclId] =
              [$dRead_sdETe] \u [] GHC.Read.readPrec $dRead_sdETe;
        } in 
          Data.Functor.Classes.$w$cliftReadPrec3
              sat_sdETj eta_sdETf eta2_sdETh eta3_sdETi;

Data.Functor.Classes.$w$cliftReadsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a a1)
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdETk w1_sdETl w2_sdETm]
        let {
          sat_sdETp [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_sdy1O a1_sdy1Q)
          [LclId] =
              [w_sdETk w1_sdETl w2_sdETm] \u []
                  let {
                    sat_sdETo [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a1_sdy1Q
                    [LclId] =
                        [w1_sdETl] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1
                                w1_sdETl eta_B1; } in
                  let {
                    sat_sdETn [Occ=Once, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1O
                    [LclId] =
                        [w_sdETk] \u [] GHC.Read.readPrec w_sdETk;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec3
                        sat_sdETn
                        sat_sdETo
                        w2_sdETm
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdETp;

Data.Functor.Classes.$fRead1Either_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a a1)
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C(U))><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdETq w1_sdETr w2_sdETs w3_sdETt]
        Data.Functor.Classes.$w$cliftReadsPrec2 w_sdETq w1_sdETr w3_sdETt;

Data.Functor.Classes.$w$cliftReadListPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a a1]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [w_sdETu w1_sdETv]
        let {
          w2_sdETw [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy1V
          [LclId] =
              [w_sdETu] \u [] GHC.Read.readPrec w_sdETu; } in
        let {
          sat_sdETz [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_sdy1V a1_sdy1X)
          [LclId] =
              [w1_sdETv w2_sdETw] \r [w3_sdETx w4_sdETy]
                  Data.Functor.Classes.$w$cliftReadPrec3
                      w2_sdETw w1_sdETv w3_sdETx w4_sdETy;
        } in  GHC.Read.list sat_sdETz;

Data.Functor.Classes.$fRead1Either_$cliftReadListPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     Text.ParserCombinators.ReadPrec.ReadPrec a1
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a1]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Either.Either a a1]
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C(C1(U)),A)><L,C(C1(U))><L,A>,
 Unf=OtherCon []] =
    [] \r [w_sdETA w1_sdETB w2_sdETC]
        Data.Functor.Classes.$w$cliftReadListPrec1 w_sdETA w1_sdETB;

Data.Functor.Classes.$fRead1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     Data.Functor.Classes.Read1 (Data.Either.Either a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sdETD]
        let {
          sat_sdETM [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    [Data.Either.Either a_XdwYA a]
          [LclId] =
              [$dRead_sdETD] \r [w_sdETK w1_sdETL]
                  Data.Functor.Classes.$w$cliftReadListPrec1
                      $dRead_sdETD w_sdETK; } in
        let {
          sat_sdETJ [Occ=Once]
            :: forall a.
               Text.ParserCombinators.ReadPrec.ReadPrec a
               -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Either.Either a_XdwYA a)
          [LclId] =
              [$dRead_sdETD] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fRead1Either7
                      $dRead_sdETD eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdETI [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> Text.ParserCombinators.ReadP.ReadS
                    [Data.Either.Either a_XdwYA a]
          [LclId] =
              [$dRead_sdETD] \u []
                  Data.Functor.Classes.$fRead1Either_$cliftReadList
                      $dRead_sdETD; } in
        let {
          sat_sdETH [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
               -> Text.ParserCombinators.ReadP.ReadS [a]
               -> GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Either.Either a_XdwYA a)
          [LclId] =
              [$dRead_sdETD] \r [w_sdETE w1_sdETF w2_sdETG]
                  Data.Functor.Classes.$w$cliftReadsPrec2
                      $dRead_sdETD w_sdETE w2_sdETG;
        } in 
          Data.Functor.Classes.C:Read1 [sat_sdETH
                                        sat_sdETI
                                        sat_sdETJ
                                        sat_sdETM];
Data.Functor.Classes.$fRead1Either_$cliftReadList [Occ=LoopBreaker]
  :: forall a.
     GHC.Read.Read a =>
     forall a1.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a1)
     -> Text.ParserCombinators.ReadP.ReadS [a1]
     -> Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a a1]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sdETN]
        let {
          sat_sdETO [Occ=Once]
            :: Data.Functor.Classes.Read1 (Data.Either.Either a_XdwYC)
          [LclId] =
              [$dRead_sdETN] \u []
                  Data.Functor.Classes.$fRead1Either $dRead_sdETN;
        } in  Data.Functor.Classes.liftReadListDefault sat_sdETO;

Data.Functor.Classes.$fRead1Identity4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Identity"#;

Data.Functor.Classes.$fRead1Identity3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Identity4;

Data.Functor.Classes.$fRead1Identity2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Identity3];

Data.Functor.Classes.$w$cliftReadPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdETP w1_sdETQ w2_sdETR]
        let {
          sat_sdEU3 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_sdy23)
          [LclId] =
              [w_sdETP] \r [c_sdETS eta_sdETT]
                  case c_sdETS of {
                    GHC.Types.I# x_sdETV [Occ=Once] ->
                        case <=# [x_sdETV 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sdEU0 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_X81et
                                [LclId] =
                                    [w_sdETP eta_sdETT] \r [a1_sdETX]
                                        let {
                                          sat_sdETZ [Occ=Once]
                                            :: a_sdy23 -> Text.ParserCombinators.ReadP.P b1_X81et
                                          [LclId] =
                                              [eta_sdETT] \r [a2_sdETY] eta_sdETT a2_sdETY;
                                        } in  w_sdETP Data.Functor.Classes.$fRead1Const1 sat_sdETZ;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Functor.Classes.$fRead1Identity2 sat_sdEU0
                                of
                                { Unit# ww1_sdEU2 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sdEU2];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sdEU3 w1_sdETQ w2_sdETR;

Data.Functor.Classes.$fRead1Identity1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Functor.Identity.Identity a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEU4 w1_sdEU5 w2_sdEU6 w3_sdEU7]
        Data.Functor.Classes.$w$cliftReadPrec w_sdEU4 w2_sdEU6 w3_sdEU7;

Data.Functor.Classes.$w$cliftReadsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId, Arity=2, Str=<L,1*C1(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEU8 w1_sdEU9]
        let {
          sat_sdEUp [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Functor.Identity.Identity a_sdy2a)
          [LclId] =
              [w_sdEU8 w1_sdEU9] \u []
                  let {
                    lvl3_sdEUa [Occ=OnceL, Dmd=<L,C(U)>]
                      :: Text.ParserCombinators.ReadP.ReadS a_sdy2a
                    [LclId] =
                        [w_sdEU8] \u [] w_sdEU8 Data.Functor.Classes.$fRead1Const1; } in
                  let {
                    sat_sdEUo [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sdy2a)
                    [LclId] =
                        [lvl3_sdEUa] \r [c_sdEUb eta_sdEUc]
                            case c_sdEUb of {
                              GHC.Types.I# x_sdEUe [Occ=Once] ->
                                  case <=# [x_sdEUe 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdEUl [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_X81et
                                          [LclId] =
                                              [lvl3_sdEUa eta_sdEUc] \r [a1_sdEUg]
                                                  let {
                                                    sat_sdEUi [Occ=Once]
                                                      :: a_sdy2a
                                                         -> Text.ParserCombinators.ReadP.P b_X81et
                                                    [LclId] =
                                                        [eta_sdEUc] \r [a2_sdEUh]
                                                            eta_sdEUc a2_sdEUh;
                                                  } in 
                                                    case
                                                        Text.ParserCombinators.ReadP.$wreadS_to_P
                                                            lvl3_sdEUa sat_sdEUi
                                                    of
                                                    { Unit# ww1_sdEUk [Occ=Once] ->
                                                          Text.ParserCombinators.ReadP.Look [ww1_sdEUk];
                                                    };
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Identity2 sat_sdEUl
                                          of
                                          { Unit# ww1_sdEUn [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdEUn];
                                          };
                                  };
                            };
                  } in 
                    GHC.Read.list3
                        sat_sdEUo
                        w1_sdEU9
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEUp;

Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Functor.Identity.Identity a)
[GblId, Arity=3, Str=<L,1*C1(C(U))><L,A><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEUq w1_sdEUr w2_sdEUs]
        Data.Functor.Classes.$w$cliftReadsPrec3 w_sdEUq w2_sdEUs;

Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec
          [Data.Functor.Identity.Identity a]
[GblId, Arity=2, Str=<L,C(C1(U))><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdEUt rl_sdEUu]
        let {
          sat_sdEUx [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Functor.Identity.Identity a_adx2c)
          [LclId] =
              [rp_sdEUt] \r [w_sdEUv w1_sdEUw]
                  Data.Functor.Classes.$w$cliftReadPrec rp_sdEUt w_sdEUv w1_sdEUw;
        } in  GHC.Read.list sat_sdEUx;

Data.Functor.Classes.$w$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Identity.Identity a]
[GblId, Arity=1, Str=<L,C(C(U))>, Unf=OtherCon []] =
    [] \r [w_sdEUy]
        let {
          sat_sdEUD [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Functor.Identity.Identity a_sdy2f]
          [LclId] =
              [w_sdEUy] \u []
                  let {
                    w1_sdEUz [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.Prec
                         -> forall b.
                            (a_sdy2f -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [w_sdEUy] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdEUy eta_B1; } in
                  let {
                    sat_sdEUC [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Functor.Identity.Identity a_sdy2f)
                    [LclId] =
                        [w1_sdEUz] \r [w2_sdEUA w3_sdEUB]
                            Data.Functor.Classes.$w$cliftReadPrec w1_sdEUz w2_sdEUA w3_sdEUB;
                  } in 
                    GHC.Read.list
                        sat_sdEUC
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEUD;

Data.Functor.Classes.$fRead1Identity_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS
          [Data.Functor.Identity.Identity a]
[GblId, Arity=2, Str=<L,C(C(U))><L,A>, Unf=OtherCon []] =
    [] \r [w_sdEUE w1_sdEUF]
        Data.Functor.Classes.$w$cliftReadList w_sdEUE;

Data.Functor.Classes.$fRead1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Identity_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Identity_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Identity1
                                                 Data.Functor.Classes.$fRead1Identity_$cliftReadListPrec];

Data.Functor.Classes.$fRead1Maybe7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Nothing"#;

Data.Functor.Classes.$fRead1Maybe6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Maybe7;

Data.Functor.Classes.$fRead1Maybe_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Maybe6];

Data.Functor.Classes.$fRead1Maybe5
  :: forall a.
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [eta_sdEUG eta1_sdEUH]
        let {
          sat_sdEUJ [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_i815E
          [LclId] =
              [eta1_sdEUH] \r [x_sdEUI] eta1_sdEUH GHC.Base.Nothing;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Functor.Classes.$fRead1Maybe_lexeme sat_sdEUJ
          of
          { Unit# ww1_sdEUL [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_sdEUL];
          };

Data.Functor.Classes.$fRead1Maybe4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Just"#;

Data.Functor.Classes.$fRead1Maybe3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Functor.Classes.$fRead1Maybe4;

Data.Functor.Classes.$fRead1Maybe2 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Functor.Classes.$fRead1Maybe3];

Data.Functor.Classes.$w$cliftReadPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=3, Str=<L,C(C1(U))><L,U><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEUM w1_sdEUN w2_sdEUO]
        let {
          sat_sdEV3 [Occ=Once] :: Text.ParserCombinators.ReadP.P b_sdy2n
          [LclId] =
              [w_sdEUM w1_sdEUN w2_sdEUO] \u []
                  let {
                    sat_sdEV2 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.Maybe a_sdy2j)
                    [LclId] =
                        [w_sdEUM] \r [c_sdEUQ eta_sdEUR]
                            case c_sdEUQ of {
                              GHC.Types.I# x_sdEUT [Occ=Once] ->
                                  case <=# [x_sdEUT 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_sdEUZ [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_X81c7
                                          [LclId] =
                                              [w_sdEUM eta_sdEUR] \r [a1_sdEUV]
                                                  let {
                                                    sat_sdEUY [Occ=Once]
                                                      :: a_sdy2j
                                                         -> Text.ParserCombinators.ReadP.P b1_X81c7
                                                    [LclId] =
                                                        [eta_sdEUR] \r [a2_sdEUW]
                                                            let {
                                                              sat_sdEUX [Occ=Once]
                                                                :: GHC.Base.Maybe a_sdy2j
                                                              [LclId] =
                                                                  CCCS GHC.Base.Just! [a2_sdEUW];
                                                            } in  eta_sdEUR sat_sdEUX;
                                                  } in 
                                                    w_sdEUM
                                                        Data.Functor.Classes.$fRead1Const1
                                                        sat_sdEUY;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Functor.Classes.$fRead1Maybe2 sat_sdEUZ
                                          of
                                          { Unit# ww1_sdEV1 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sdEV1];
                                          };
                                  };
                            };
                  } in  GHC.Read.list3 sat_sdEV2 w1_sdEUN w2_sdEUO;
        } in 
          case
              GHC.Read.list3 Data.Functor.Classes.$fRead1Maybe5 w1_sdEUN w2_sdEUO
          of
          sat_sdEUP
          { __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    sat_sdEUP sat_sdEV3;
          };

Data.Functor.Classes.$fRead1Maybe1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Base.Maybe a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEV4 w1_sdEV5 w2_sdEV6 w3_sdEV7]
        Data.Functor.Classes.$w$cliftReadPrec4 w_sdEV4 w2_sdEV6 w3_sdEV7;

Data.Functor.Classes.$w$cliftReadsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.Maybe a)
[GblId, Arity=2, Str=<L,C(C(U))><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEV8 w1_sdEV9]
        let {
          sat_sdEVb [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (GHC.Base.Maybe a_sdy2q)
          [LclId] =
              [w_sdEV8 w1_sdEV9] \u []
                  let {
                    sat_sdEVa [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec a_sdy2q
                    [LclId] =
                        [w_sdEV8] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdEV8 eta_B1;
                  } in 
                    Data.Functor.Classes.$w$cliftReadPrec4
                        sat_sdEVa
                        w1_sdEV9
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEVb;

Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (GHC.Base.Maybe a)
[GblId, Arity=3, Str=<L,C(C(U))><L,A><L,U>, Unf=OtherCon []] =
    [] \r [w_sdEVc w1_sdEVd w2_sdEVe]
        Data.Functor.Classes.$w$cliftReadsPrec4 w_sdEVc w2_sdEVe;

Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec
  :: forall a.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
     -> Text.ParserCombinators.ReadPrec.ReadPrec [GHC.Base.Maybe a]
[GblId, Arity=2, Str=<L,C(C1(U))><L,A>, Unf=OtherCon []] =
    [] \r [rp_sdEVf rl_sdEVg]
        let {
          sat_sdEVj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (GHC.Base.Maybe a_adx4t)
          [LclId] =
              [rp_sdEVf] \r [w_sdEVh w1_sdEVi]
                  Data.Functor.Classes.$w$cliftReadPrec4 rp_sdEVf w_sdEVh w1_sdEVi;
        } in  GHC.Read.list sat_sdEVj;

Data.Functor.Classes.$w$cliftReadList1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.Maybe a]
[GblId, Arity=1, Str=<L,C(C(U))>, Unf=OtherCon []] =
    [] \r [w_sdEVk]
        let {
          sat_sdEVp [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [GHC.Base.Maybe a_sdy2v]
          [LclId] =
              [w_sdEVk] \u []
                  let {
                    w1_sdEVl [Occ=OnceL, Dmd=<L,C(C1(U))>]
                      :: Text.ParserCombinators.ReadPrec.Prec
                         -> forall b.
                            (a_sdy2v -> Text.ParserCombinators.ReadP.P b)
                            -> Text.ParserCombinators.ReadP.P b
                    [LclId, Arity=1, Unf=OtherCon []] =
                        [w_sdEVk] \r [eta_B1]
                            Text.ParserCombinators.ReadPrec.readS_to_Prec1 w_sdEVk eta_B1; } in
                  let {
                    sat_sdEVo [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (GHC.Base.Maybe a_sdy2v)
                    [LclId] =
                        [w1_sdEVl] \r [w2_sdEVm w3_sdEVn]
                            Data.Functor.Classes.$w$cliftReadPrec4 w1_sdEVl w2_sdEVm w3_sdEVn;
                  } in 
                    GHC.Read.list
                        sat_sdEVo
                        Data.Functor.Classes.$fRead1Identity5
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sdEVp;

Data.Functor.Classes.$fRead1Maybe_$cliftReadList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> Text.ParserCombinators.ReadP.ReadS [a]
     -> Text.ParserCombinators.ReadP.ReadS [GHC.Base.Maybe a]
[GblId, Arity=2, Str=<L,C(C(U))><L,A>, Unf=OtherCon []] =
    [] \r [w_sdEVq w1_sdEVr]
        Data.Functor.Classes.$w$cliftReadList1 w_sdEVq;

Data.Functor.Classes.$fRead1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Read1 GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Read1! [Data.Functor.Classes.$fRead1Maybe_$cliftReadsPrec
                                                 Data.Functor.Classes.$fRead1Maybe_$cliftReadList
                                                 Data.Functor.Classes.$fRead1Maybe1
                                                 Data.Functor.Classes.$fRead1Maybe_$cliftReadListPrec];

Data.Functor.Classes.readsBinaryWith
  :: forall a b t.
     (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
     -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
     -> GHC.Base.String
     -> (a -> b -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><S,1*U><L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [rp1_sdEVs rp2_sdEVt name_sdEVu cons_sdEVv kw_sdEVw s_sdEVx]
        case GHC.Base.eqString kw_sdEVw name_sdEVu of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdEVz [Occ=LoopBreaker]
                  :: [(a_adwGC, GHC.Base.String)] -> [(t_adwGE, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [rp2_sdEVt cons_sdEVv go_sdEVz] \r [ds_sdEVA]
                        case ds_sdEVA of {
                          [] -> [] [];
                          : y_sdEVC [Occ=Once!] ys_sdEVD [Occ=Once] ->
                              case y_sdEVC of {
                                (,) x_sdEVF [Occ=OnceL] t1_sdEVG [Occ=Once] ->
                                    let {
                                      z_sdEVH [Occ=OnceL] :: [(t_adwGE, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdEVz ys_sdEVD] \u [] go_sdEVz ys_sdEVD; } in
                                    let {
                                      go1_sdEVI [Occ=LoopBreaker]
                                        :: [(b_adwGD, GHC.Base.String)]
                                           -> [(t_adwGE, GHC.Base.String)]
                                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                          sat-only [cons_sdEVv
                                                    x_sdEVF
                                                    z_sdEVH
                                                    go1_sdEVI] \r [ds1_sdEVJ]
                                              case ds1_sdEVJ of {
                                                [] -> z_sdEVH;
                                                : y1_sdEVL [Occ=Once!] ys1_sdEVM [Occ=Once] ->
                                                    case y1_sdEVL of {
                                                      (,) y2_sdEVO [Occ=Once] u_sdEVP [Occ=Once] ->
                                                          let {
                                                            sat_sdEVS [Occ=Once]
                                                              :: [(t_adwGE, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_sdEVI ys1_sdEVM] \u []
                                                                    go1_sdEVI ys1_sdEVM; } in
                                                          let {
                                                            sat_sdEVQ [Occ=Once] :: t_adwGE
                                                            [LclId] =
                                                                [cons_sdEVv x_sdEVF y2_sdEVO] \u []
                                                                    cons_sdEVv
                                                                        x_sdEVF y2_sdEVO; } in
                                                          let {
                                                            sat_sdEVR [Occ=Once]
                                                              :: (t_adwGE, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sdEVQ u_sdEVP];
                                                          } in  : [sat_sdEVR sat_sdEVS];
                                                    };
                                              };
                                    } in 
                                      case
                                          rp2_sdEVt Data.Functor.Classes.$fRead1Const1 t1_sdEVG
                                      of
                                      sat_sdEVT
                                      { __DEFAULT -> go1_sdEVI sat_sdEVT;
                                      };
                              };
                        };
              } in 
                case
                    rp1_sdEVs Data.Functor.Classes.$fRead1Const1 s_sdEVx
                of
                sat_sdEVU
                { __DEFAULT -> go_sdEVz sat_sdEVU;
                };
        };

Data.Functor.Classes.$wreadBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (t -> Text.ParserCombinators.ReadP.P b1)
        -> (# GHC.Base.String -> Text.ParserCombinators.ReadP.P b1 #)
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [w_sdEVV w1_sdEVW w2_sdEVX w3_sdEVY w4_sdEVZ w5_sdEW0]
        let {
          sat_sdEWc [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b1_sdy2S
          [LclId] =
              [w_sdEVV w1_sdEVW w3_sdEVY w4_sdEVZ w5_sdEW0] \r [a1_sdEW2]
                  let {
                    lvl3_sdEW3 :: Text.ParserCombinators.ReadPrec.Prec
                    [LclId] =
                        [w4_sdEVZ] \u []
                            case w4_sdEVZ of {
                              GHC.Types.I# x_sdEW5 [Occ=Once] ->
                                  case +# [x_sdEW5 1#] of sat_sdEW6 {
                                    __DEFAULT -> GHC.Types.I# [sat_sdEW6];
                                  };
                            }; } in
                  let {
                    sat_sdEWb [Occ=Once]
                      :: a_sdy2K -> Text.ParserCombinators.ReadP.P b1_sdy2S
                    [LclId] =
                        [w1_sdEVW w3_sdEVY w5_sdEW0 lvl3_sdEW3] \r [a2_sdEW7]
                            let {
                              sat_sdEWa [Occ=Once]
                                :: b_sdy2L -> Text.ParserCombinators.ReadP.P b1_sdy2S
                              [LclId] =
                                  [w3_sdEVY w5_sdEW0 a2_sdEW7] \r [a3_sdEW8]
                                      let {
                                        sat_sdEW9 [Occ=Once] :: t_sdy2M
                                        [LclId] =
                                            [w3_sdEVY a2_sdEW7 a3_sdEW8] \u []
                                                w3_sdEVY a2_sdEW7 a3_sdEW8;
                                      } in  w5_sdEW0 sat_sdEW9;
                            } in  w1_sdEVW lvl3_sdEW3 sat_sdEWa;
                  } in  w_sdEVV lvl3_sdEW3 sat_sdEWb; } in
        let {
          sat_sdEW1 [Occ=Once] :: Text.Read.Lex.Lexeme
          [LclId] =
              CCCS Text.Read.Lex.Ident! [w2_sdEVX];
        } in  Text.Read.Lex.$wexpect sat_sdEW1 sat_sdEWc;

Data.Functor.Classes.readBinaryWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (t -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [w_sdEWd w1_sdEWe w2_sdEWf w3_sdEWg w4_sdEWh w5_sdEWi]
        case
            Data.Functor.Classes.$wreadBinaryWith
                w_sdEWd w1_sdEWe w2_sdEWf w3_sdEWg w4_sdEWh w5_sdEWi
        of
        { Unit# ww1_sdEWk [Occ=Once] ->
              Text.ParserCombinators.ReadP.Look [ww1_sdEWk];
        };

Data.Functor.Classes.readBinaryWith
  :: forall a b t.
     Text.ParserCombinators.ReadPrec.ReadPrec a
     -> Text.ParserCombinators.ReadPrec.ReadPrec b
     -> GHC.Base.String
     -> (a -> b -> t)
     -> Text.ParserCombinators.ReadPrec.ReadPrec t
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(U))><L,C(C1(U))><L,U><L,C(C1(U))><L,1*U(U)><L,C(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.readBinaryWith1
            eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Functor.Classes.$wshowsUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> GHC.Base.String -> GHC.Prim.Int# -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEWl w1_sdEWm ww_sdEWn w2_sdEWo]
        let {
          g_sdEWp [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEWl w2_sdEWo] \u []
                  w_sdEWl Data.Functor.Classes.$fRead1Const1 w2_sdEWo;
        } in 
          case ># [ww_sdEWn 10#] of {
            __DEFAULT ->
                let {
                  sat_sdEWu [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdEWm g_sdEWp] \r [x_sdEWr]
                          let {
                            sat_sdEWs [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdEWp x_sdEWr] \u [] g_sdEWp x_sdEWr; } in
                          let {
                            sat_sdEWt [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEWs];
                          } in  GHC.Base.++ w1_sdEWm sat_sdEWt;
                } in  sat_sdEWu;
            1# ->
                let {
                  sat_sdEWA [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdEWm g_sdEWp] \r [x_sdEWv]
                          let {
                            sat_sdEWz [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w1_sdEWm g_sdEWp x_sdEWv] \u []
                                    let {
                                      sat_sdEWx [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdEWp x_sdEWv] \u []
                                              let {
                                                sat_sdEWw [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdEWv];
                                              } in  g_sdEWp sat_sdEWw; } in
                                    let {
                                      sat_sdEWy [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEWx];
                                    } in  GHC.Base.++ w1_sdEWm sat_sdEWy;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEWz];
                } in  sat_sdEWA;
          };

Data.Functor.Classes.showsUnaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEWB w1_sdEWC w2_sdEWD w3_sdEWE]
        case w2_sdEWD of {
          GHC.Types.I# ww1_sdEWG [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  w_sdEWB w1_sdEWC ww1_sdEWG w3_sdEWE;
        };

Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Const.Const a b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(C(U)))><L,A><L,A><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdEWH ds_sdEWI ds1_sdEWJ ds2_sdEWK d_sdEWL ds3_sdEWM]
        case d_sdEWL of {
          GHC.Types.I# ww1_sdEWO [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  sp_sdEWH Data.Functor.Classes.$fRead1Const3 ww1_sdEWO ds3_sdEWM;
        };

Data.Functor.Classes.$fShow2Const_$cliftShowList2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [Data.Functor.Const.Const a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,C(C1(C(U)))><L,A><L,A><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp1_sdEWP
           sl1_sdEWQ
           sp2_sdEWR
           sl2_sdEWS
           eta_sdEWT
           eta1_sdEWU]
        let {
          sat_sdEWW [Occ=Once]
            :: Data.Functor.Const.Const a_adwPE b_adwPF -> GHC.Show.ShowS
          [LclId] =
              [sp1_sdEWP] \r [ds_sdEWV]
                  Data.Functor.Classes.$wshowsUnaryWith
                      sp1_sdEWP Data.Functor.Classes.$fRead1Const3 0# ds_sdEWV;
        } in  GHC.Show.showList__ sat_sdEWW eta_sdEWT eta1_sdEWU;

Data.Functor.Classes.$fShow2Const [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 Data.Functor.Const.Const
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow2Const_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2Const_$cliftShowList2];

Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Const.Const a a1
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,A><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdEWX eta_sdEWY eta1_sdEWZ eta2_sdEX0 eta3_sdEX1]
        case eta2_sdEX0 of {
          GHC.Types.I# ww1_sdEX3 [Occ=Once] ->
              let {
                sat_sdEX4 [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_adwP4 -> GHC.Show.ShowS
                [LclId] =
                    [$dShow_sdEWX] \s [] GHC.Show.showsPrec $dShow_sdEWX;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sdEX4 Data.Functor.Classes.$fRead1Const3 ww1_sdEX3 eta3_sdEX1;
        };

Data.Functor.Classes.$fShow1Const_$cliftShowList
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> [Data.Functor.Const.Const a a1]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,A><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sdEX5 sp_sdEX6 sl_sdEX7 eta_sdEX8 eta1_sdEX9]
        let {
          lvl3_sdEXa [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_adwP4 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEX5] \u [] GHC.Show.showsPrec $dShow_sdEX5; } in
        let {
          sat_sdEXc [Occ=Once]
            :: Data.Functor.Const.Const a_adwP4 a1_adwPn -> GHC.Show.ShowS
          [LclId] =
              [lvl3_sdEXa] \r [eta2_sdEXb]
                  Data.Functor.Classes.$wshowsUnaryWith
                      lvl3_sdEXa Data.Functor.Classes.$fRead1Const3 0# eta2_sdEXb;
        } in  GHC.Show.showList__ sat_sdEXc eta_sdEX8 eta1_sdEX9;

Data.Functor.Classes.$fShow1Const [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Classes.Show1 (Data.Functor.Const.Const a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdEXd]
        let {
          sat_sdEXf [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Functor.Const.Const a_adwP4 a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEXd] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Const_$cliftShowList
                      $dShow_sdEXd eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sdEXe [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Functor.Const.Const a_adwP4 a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEXd] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Const_$cliftShowsPrec
                      $dShow_sdEXd eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdEXe sat_sdEXf];

Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Either.Either a b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [sp1_sdEXg ds_sdEXh ds1_sdEXi ds2_sdEXj d_sdEXk ds3_sdEXl]
        case ds3_sdEXl of {
          Data.Either.Left x_sdEXn [Occ=Once] ->
              case d_sdEXk of {
                GHC.Types.I# ww1_sdEXp [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        sp1_sdEXg Data.Functor.Classes.$fRead1Either5 ww1_sdEXp x_sdEXn;
              };
          Data.Either.Right x_sdEXq [Occ=Once] ->
              case d_sdEXk of {
                GHC.Types.I# ww1_sdEXs [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        ds1_sdEXi Data.Functor.Classes.$fRead1Either2 ww1_sdEXs x_sdEXq;
              };
        };

Data.Functor.Classes.$w$cliftShowList4 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> [Data.Either.Either a b]
     -> GHC.Base.String
     -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEXt w1_sdEXu w2_sdEXv w3_sdEXw]
        let {
          sat_sdEXB [Occ=Once]
            :: Data.Either.Either a_sdy38 b_sdy39 -> GHC.Show.ShowS
          [LclId] =
              [w_sdEXt w1_sdEXu] \r [ds_sdEXx]
                  case ds_sdEXx of {
                    Data.Either.Left x_sdEXz [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w_sdEXt Data.Functor.Classes.$fRead1Either5 0# x_sdEXz;
                    Data.Either.Right x_sdEXA [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w1_sdEXu Data.Functor.Classes.$fRead1Either2 0# x_sdEXA;
                  };
        } in  GHC.Show.showList__ sat_sdEXB w2_sdEXv w3_sdEXw;

Data.Functor.Classes.$fShow2Either_$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> ([b] -> GHC.Show.ShowS)
     -> [Data.Either.Either a b]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<L,C(C1(C(U)))><L,A><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEXC w1_sdEXD w2_sdEXE w3_sdEXF w4_sdEXG w5_sdEXH]
        Data.Functor.Classes.$w$cliftShowList4
            w_sdEXC w2_sdEXE w4_sdEXG w5_sdEXH;

Data.Functor.Classes.$fShow2Either [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show2 Data.Either.Either
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show2! [Data.Functor.Classes.$fShow2Either_$cliftShowsPrec2
                                                 Data.Functor.Classes.$fShow2Either_$cliftShowList2];

Data.Functor.Classes.$w$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> GHC.Prim.Int# -> Data.Either.Either a a1 -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdEXI w1_sdEXJ ww_sdEXK w2_sdEXL]
        case w2_sdEXL of {
          Data.Either.Left x_sdEXN [Occ=Once] ->
              let {
                sat_sdEXO [Occ=Once, Dmd=<L,1*C1(C1(C(U)))>]
                  :: GHC.Types.Int -> a_sdy3h -> GHC.Show.ShowS
                [LclId] =
                    [w_sdEXI] \s [] GHC.Show.showsPrec w_sdEXI;
              } in 
                Data.Functor.Classes.$wshowsUnaryWith
                    sat_sdEXO Data.Functor.Classes.$fRead1Either5 ww_sdEXK x_sdEXN;
          Data.Either.Right x_sdEXP [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  w1_sdEXJ Data.Functor.Classes.$fRead1Either2 ww_sdEXK x_sdEXP;
        };

Data.Functor.Classes.$fShow1Either_$cliftShowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Either.Either a a1
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdEXQ w1_sdEXR w2_sdEXS w3_sdEXT w4_sdEXU]
        case w3_sdEXT of {
          GHC.Types.I# ww1_sdEXW [Occ=Once] ->
              Data.Functor.Classes.$w$cliftShowsPrec
                  w_sdEXQ w1_sdEXR ww1_sdEXW w4_sdEXU;
        };

Data.Functor.Classes.$w$cliftShowList1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> [Data.Either.Either a a1] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=4,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEXX w1_sdEXY w2_sdEXZ w3_sdEY0]
        let {
          lvl3_sdEY1 [Occ=OnceL, Dmd=<L,C(C1(C(U)))>]
            :: GHC.Types.Int -> a_sdy3t -> GHC.Show.ShowS
          [LclId] =
              [w_sdEXX] \u [] GHC.Show.showsPrec w_sdEXX; } in
        let {
          sat_sdEY6 [Occ=Once]
            :: Data.Either.Either a_sdy3t a1_sdy3v -> GHC.Show.ShowS
          [LclId] =
              [w1_sdEXY lvl3_sdEY1] \r [eta_sdEY2]
                  case eta_sdEY2 of {
                    Data.Either.Left x_sdEY4 [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            lvl3_sdEY1 Data.Functor.Classes.$fRead1Either5 0# x_sdEY4;
                    Data.Either.Right x_sdEY5 [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w1_sdEXY Data.Functor.Classes.$fRead1Either2 0# x_sdEY5;
                  };
        } in  GHC.Show.showList__ sat_sdEY6 w2_sdEXZ w3_sdEY0;

Data.Functor.Classes.$fShow1Either_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     forall a1.
     (GHC.Types.Int -> a1 -> GHC.Show.ShowS)
     -> ([a1] -> GHC.Show.ShowS)
     -> [Data.Either.Either a a1]
     -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Str=<L,1*U(1*C(C1(C(U))),A,A)><L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEY7 w1_sdEY8 w2_sdEY9 w3_sdEYa w4_sdEYb]
        Data.Functor.Classes.$w$cliftShowList1
            w_sdEY7 w1_sdEY8 w3_sdEYa w4_sdEYb;

Data.Functor.Classes.$fShow1Either [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     Data.Functor.Classes.Show1 (Data.Either.Either a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sdEYc]
        let {
          sat_sdEYi [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> [Data.Either.Either a_adwPN a]
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEYc] \r [w_sdEYe w1_sdEYf w2_sdEYg w3_sdEYh]
                  Data.Functor.Classes.$w$cliftShowList1
                      $dShow_sdEYc w_sdEYe w2_sdEYg w3_sdEYh; } in
        let {
          sat_sdEYd [Occ=Once]
            :: forall a.
               (GHC.Types.Int -> a -> GHC.Show.ShowS)
               -> ([a] -> GHC.Show.ShowS)
               -> GHC.Types.Int
               -> Data.Either.Either a_adwPN a
               -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sdEYc] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Functor.Classes.$fShow1Either_$cliftShowsPrec
                      $dShow_sdEYc eta_B4 eta_B3 eta_B2 eta_B1;
        } in  Data.Functor.Classes.C:Show1 [sat_sdEYd sat_sdEYi];

Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> Data.Functor.Identity.Identity a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(C1(C(U)))><L,A><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdEYj ds_sdEYk d_sdEYl ds1_sdEYm]
        case d_sdEYl of {
          GHC.Types.I# ww1_sdEYo [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnaryWith
                  sp_sdEYj Data.Functor.Classes.$fRead1Identity3 ww1_sdEYo ds1_sdEYm;
        };

Data.Functor.Classes.$fShow1Identity_$cliftShowList
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> [Data.Functor.Identity.Identity a]
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [sp_sdEYp sl_sdEYq eta_sdEYr eta1_sdEYs]
        let {
          sat_sdEYu [Occ=Once]
            :: Data.Functor.Identity.Identity a_adwZV -> GHC.Show.ShowS
          [LclId] =
              [sp_sdEYp] \r [ds_sdEYt]
                  Data.Functor.Classes.$wshowsUnaryWith
                      sp_sdEYp Data.Functor.Classes.$fRead1Identity3 0# ds_sdEYt;
        } in  GHC.Show.showList__ sat_sdEYu eta_sdEYr eta1_sdEYs;

Data.Functor.Classes.$fShow1Identity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Identity_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Identity_$cliftShowList];

Data.Functor.Classes.$fShow1Maybe1
  :: [GHC.Types.Char] -> [GHC.Types.Char]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Base.++ Data.Functor.Classes.$fRead1Maybe6 eta_B1;

Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS)
     -> GHC.Types.Int
     -> GHC.Base.Maybe a
     -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(C1(C(U)))><L,A><L,1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sdEYv ds1_sdEYw ds2_sdEYx ds3_sdEYy]
        case ds3_sdEYy of {
          GHC.Base.Nothing -> Data.Functor.Classes.$fShow1Maybe1;
          GHC.Base.Just x_sdEYA [Occ=Once] ->
              case ds2_sdEYx of {
                GHC.Types.I# ww1_sdEYC [Occ=Once] ->
                    Data.Functor.Classes.$wshowsUnaryWith
                        ds_sdEYv Data.Functor.Classes.$fRead1Maybe3 ww1_sdEYC x_sdEYA;
              };
        };

Data.Functor.Classes.$w$cliftShowList2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> [GHC.Base.Maybe a] -> GHC.Base.String -> GHC.Base.String
[GblId,
 Arity=3,
 Str=<L,C(C1(C(U)))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEYD w1_sdEYE w2_sdEYF]
        let {
          sat_sdEYJ [Occ=Once] :: GHC.Base.Maybe a_sdy3B -> GHC.Show.ShowS
          [LclId] =
              [w_sdEYD] \r [ds_sdEYG]
                  case ds_sdEYG of {
                    GHC.Base.Nothing -> Data.Functor.Classes.$fShow1Maybe1;
                    GHC.Base.Just x_sdEYI [Occ=Once] ->
                        Data.Functor.Classes.$wshowsUnaryWith
                            w_sdEYD Data.Functor.Classes.$fRead1Maybe3 0# x_sdEYI;
                  };
        } in  GHC.Show.showList__ sat_sdEYJ w1_sdEYE w2_sdEYF;

Data.Functor.Classes.$fShow1Maybe_$cliftShowList [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> ([a] -> GHC.Show.ShowS) -> [GHC.Base.Maybe a] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,C(C1(C(U)))><L,A><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEYK w1_sdEYL w2_sdEYM w3_sdEYN]
        Data.Functor.Classes.$w$cliftShowList2 w_sdEYK w2_sdEYM w3_sdEYN;

Data.Functor.Classes.$fShow1Maybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Classes.Show1 GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Classes.C:Show1! [Data.Functor.Classes.$fShow1Maybe_$cliftShowsPrec
                                                 Data.Functor.Classes.$fShow1Maybe_$cliftShowList];

Data.Functor.Classes.$wshowsBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> GHC.Base.String
     -> GHC.Prim.Int#
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEYO w1_sdEYP w2_sdEYQ ww_sdEYR w3_sdEYS w4_sdEYT]
        let {
          f_sdEYU [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEYO w3_sdEYS] \u []
                  w_sdEYO Data.Functor.Classes.$fRead1Const1 w3_sdEYS; } in
        let {
          g_sdEYV [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sdEYP w4_sdEYT] \u []
                  w1_sdEYP Data.Functor.Classes.$fRead1Const1 w4_sdEYT;
        } in 
          case ># [ww_sdEYR 10#] of {
            __DEFAULT ->
                let {
                  sat_sdEZ2 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdEYQ f_sdEYU g_sdEYV] \r [x_sdEYX]
                          let {
                            sat_sdEZ0 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sdEYU g_sdEYV x_sdEYX] \u []
                                    let {
                                      sat_sdEYY [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdEYV x_sdEYX] \u [] g_sdEYV x_sdEYX; } in
                                    let {
                                      sat_sdEYZ [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEYY];
                                    } in  f_sdEYU sat_sdEYZ; } in
                          let {
                            sat_sdEZ1 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEZ0];
                          } in  GHC.Base.++ w2_sdEYQ sat_sdEZ1;
                } in  sat_sdEZ2;
            1# ->
                let {
                  sat_sdEZa [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w2_sdEYQ f_sdEYU g_sdEYV] \r [x_sdEZ3]
                          let {
                            sat_sdEZ9 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w2_sdEYQ f_sdEYU g_sdEYV x_sdEZ3] \u []
                                    let {
                                      sat_sdEZ7 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sdEYU g_sdEYV x_sdEZ3] \u []
                                              let {
                                                sat_sdEZ5 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sdEYV x_sdEZ3] \u []
                                                        let {
                                                          sat_sdEZ4 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sdEZ3];
                                                        } in  g_sdEYV sat_sdEZ4; } in
                                              let {
                                                sat_sdEZ6 [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [Data.Functor.Classes.showsUnaryWith1
                                                             sat_sdEZ5];
                                              } in  f_sdEYU sat_sdEZ6; } in
                                    let {
                                      sat_sdEZ8 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEZ7];
                                    } in  GHC.Base.++ w2_sdEYQ sat_sdEZ8;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEZ9];
                } in  sat_sdEZa;
          };

Data.Functor.Classes.showsBinaryWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Types.Int -> a -> GHC.Show.ShowS)
     -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
     -> GHC.Base.String
     -> GHC.Types.Int
     -> a
     -> b
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C(U)))><L,1*C1(C1(C(U)))><L,U><S(S),1*U(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEZb w1_sdEZc w2_sdEZd w3_sdEZe w4_sdEZf w5_sdEZg]
        case w3_sdEZe of {
          GHC.Types.I# ww1_sdEZi [Occ=Once] ->
              Data.Functor.Classes.$wshowsBinaryWith
                  w_sdEZb w1_sdEZc w2_sdEZd ww1_sdEZi w4_sdEZf w5_sdEZg;
        };

Data.Functor.Classes.readsUnary
  :: forall a t.
     GHC.Read.Read a =>
     GHC.Base.String
     -> (a -> t)
     -> GHC.Base.String
     -> Text.ParserCombinators.ReadP.ReadS t
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A,A)><S,1*U><L,C(U)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sdEZj name_sdEZk cons_sdEZl kw_sdEZm s_sdEZn]
        case GHC.Base.eqString kw_sdEZm name_sdEZk of {
          GHC.Types.False -> [] [];
          GHC.Types.True ->
              let {
                go_sdEZp [Occ=LoopBreaker]
                  :: [(a_adwFr, GHC.Base.String)] -> [(t_adwFs, GHC.Base.String)]
                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                    sat-only [cons_sdEZl go_sdEZp] \r [ds_sdEZq]
                        case ds_sdEZq of {
                          [] -> [] [];
                          : y_sdEZs [Occ=Once!] ys_sdEZt [Occ=Once] ->
                              case y_sdEZs of {
                                (,) x_sdEZv [Occ=Once] t1_sdEZw [Occ=Once] ->
                                    let {
                                      sat_sdEZz [Occ=Once] :: [(t_adwFs, GHC.Base.String)]
                                      [LclId] =
                                          [go_sdEZp ys_sdEZt] \u [] go_sdEZp ys_sdEZt; } in
                                    let {
                                      sat_sdEZx [Occ=Once] :: t_adwFs
                                      [LclId] =
                                          [cons_sdEZl x_sdEZv] \u [] cons_sdEZl x_sdEZv; } in
                                    let {
                                      sat_sdEZy [Occ=Once] :: (t_adwFs, GHC.Base.String)
                                      [LclId] =
                                          CCCS (,)! [sat_sdEZx t1_sdEZw];
                                    } in  : [sat_sdEZy sat_sdEZz];
                              };
                        };
              } in 
                case
                    GHC.Read.readsPrec
                        $dRead_sdEZj Data.Functor.Classes.$fRead1Const1 s_sdEZn
                of
                sat_sdEZA
                { __DEFAULT -> go_sdEZp sat_sdEZA;
                };
        };

Data.Functor.Classes.$wshowsUnary [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Base.String -> GHC.Prim.Int# -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,U><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEZB w1_sdEZC ww_sdEZD w2_sdEZE]
        let {
          g_sdEZF [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sdEZB w2_sdEZE] \u []
                  GHC.Show.showsPrec
                      w_sdEZB Data.Functor.Classes.$fRead1Const1 w2_sdEZE;
        } in 
          case ># [ww_sdEZD 10#] of {
            __DEFAULT ->
                let {
                  sat_sdEZK [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdEZC g_sdEZF] \r [x_sdEZH]
                          let {
                            sat_sdEZI [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [g_sdEZF x_sdEZH] \u [] g_sdEZF x_sdEZH; } in
                          let {
                            sat_sdEZJ [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEZI];
                          } in  GHC.Base.++ w1_sdEZC sat_sdEZJ;
                } in  sat_sdEZK;
            1# ->
                let {
                  sat_sdEZQ [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [w1_sdEZC g_sdEZF] \r [x_sdEZL]
                          let {
                            sat_sdEZP [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [w1_sdEZC g_sdEZF x_sdEZL] \u []
                                    let {
                                      sat_sdEZN [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sdEZF x_sdEZL] \u []
                                              let {
                                                sat_sdEZM [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.$fShow(,)2 x_sdEZL];
                                              } in  g_sdEZF sat_sdEZM; } in
                                    let {
                                      sat_sdEZO [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          CCCS :! [Data.Functor.Classes.showsUnaryWith1 sat_sdEZN];
                                    } in  GHC.Base.++ w1_sdEZC sat_sdEZO;
                          } in  : [GHC.Show.$fShow(,)4 sat_sdEZP];
                } in  sat_sdEZQ;
          };

Data.Functor.Classes.showsUnary [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,U><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdEZR w1_sdEZS w2_sdEZT w3_sdEZU]
        case w2_sdEZT of {
          GHC.Types.I# ww1_sdEZW [Occ=Once] ->
              Data.Functor.Classes.$wshowsUnary
                  w_sdEZR w1_sdEZS ww1_sdEZW w3_sdEZU;
        };

Data.Functor.Classes.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Classes.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$trModule4];

Data.Functor.Classes.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Classes"#;

Data.Functor.Classes.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$trModule2];

Data.Functor.Classes.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Classes.$trModule3
                                     Data.Functor.Classes.$trModule1];

$krep_rdymB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Functor.Classes.$tcEq4 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rdymB];

Data.Functor.Classes.$tcEq7 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdymB];

Data.Functor.Classes.$tcEq6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Eq1"#;

Data.Functor.Classes.$tcEq5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcEq6];

Data.Functor.Classes.$tcEq1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [71749974434880567##
                                    7233443027070644957##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcEq5
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcOrd5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ord1"#;

Data.Functor.Classes.$tcOrd4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcOrd5];

Data.Functor.Classes.$tcOrd1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11825914698899667233##
                                    4554948325937498991##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcOrd4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcRead5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Read1"#;

Data.Functor.Classes.$tcRead4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcRead5];

Data.Functor.Classes.$tcRead1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14547308444716217043##
                                    925634574698086715##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcRead4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcShow5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Show1"#;

Data.Functor.Classes.$tcShow4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcShow5];

Data.Functor.Classes.$tcShow1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4743290066722511112##
                                    6779909240154408836##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcShow4
                                    0#
                                    Data.Functor.Classes.$tcEq4];

Data.Functor.Classes.$tcEq9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Eq2"#;

Data.Functor.Classes.$tcEq8 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcEq9];

Data.Functor.Classes.$tcEq2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16920549266159426738##
                                    13264288076834164909##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcEq8
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcOrd7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Ord2"#;

Data.Functor.Classes.$tcOrd6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcOrd7];

Data.Functor.Classes.$tcOrd2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4167316048525678806##
                                    17649124474771181823##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcOrd6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcRead7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Read2"#;

Data.Functor.Classes.$tcRead6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcRead7];

Data.Functor.Classes.$tcRead2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [615267248700376470##
                                    8978126042197021701##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcRead6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.$tcShow7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Show2"#;

Data.Functor.Classes.$tcShow6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Classes.$tcShow7];

Data.Functor.Classes.$tcShow2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11321900378419812635##
                                    1323607160578303441##
                                    Data.Functor.Classes.$trModule
                                    Data.Functor.Classes.$tcShow6
                                    0#
                                    Data.Functor.Classes.$tcEq7];

Data.Functor.Classes.C:Show2
  :: forall (f :: * -> * -> *).
     (forall a b.
      (GHC.Types.Int -> a -> GHC.Show.ShowS)
      -> ([a] -> GHC.Show.ShowS)
      -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
      -> ([b] -> GHC.Show.ShowS)
      -> GHC.Types.Int
      -> f a b
      -> GHC.Show.ShowS)
     -> (forall a b.
         (GHC.Types.Int -> a -> GHC.Show.ShowS)
         -> ([a] -> GHC.Show.ShowS)
         -> (GHC.Types.Int -> b -> GHC.Show.ShowS)
         -> ([b] -> GHC.Show.ShowS)
         -> [f a b]
         -> GHC.Show.ShowS)
     -> Data.Functor.Classes.Show2 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Show2 [eta_B2 eta_B1];

Data.Functor.Classes.C:Read2
  :: forall (f :: * -> * -> *).
     (forall a b.
      (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
      -> Text.ParserCombinators.ReadP.ReadS [a]
      -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
      -> Text.ParserCombinators.ReadP.ReadS [b]
      -> GHC.Types.Int
      -> Text.ParserCombinators.ReadP.ReadS (f a b))
     -> (forall a b.
         (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
         -> Text.ParserCombinators.ReadP.ReadS [a]
         -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b)
         -> Text.ParserCombinators.ReadP.ReadS [b]
         -> Text.ParserCombinators.ReadP.ReadS [f a b])
     -> (forall a b.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec b
         -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
         -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b))
     -> (forall a b.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec b
         -> Text.ParserCombinators.ReadPrec.ReadPrec [b]
         -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b])
     -> Data.Functor.Classes.Read2 f
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.C:Read2 [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Functor.Classes.C:Ord2
  :: forall (f :: * -> * -> *).
     Data.Functor.Classes.Eq2 f =>
     (forall a b c d.
      (a -> b -> GHC.Types.Ordering)
      -> (c -> d -> GHC.Types.Ordering)
      -> f a c
      -> f b d
      -> GHC.Types.Ordering)
     -> Data.Functor.Classes.Ord2 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Ord2 [eta_B2 eta_B1];

Data.Functor.Classes.C:Show1
  :: forall (f :: * -> *).
     (forall a.
      (GHC.Types.Int -> a -> GHC.Show.ShowS)
      -> ([a] -> GHC.Show.ShowS)
      -> GHC.Types.Int
      -> f a
      -> GHC.Show.ShowS)
     -> (forall a.
         (GHC.Types.Int -> a -> GHC.Show.ShowS)
         -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS)
     -> Data.Functor.Classes.Show1 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Show1 [eta_B2 eta_B1];

Data.Functor.Classes.C:Read1
  :: forall (f :: * -> *).
     (forall a.
      (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
      -> Text.ParserCombinators.ReadP.ReadS [a]
      -> GHC.Types.Int
      -> Text.ParserCombinators.ReadP.ReadS (f a))
     -> (forall a.
         (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a)
         -> Text.ParserCombinators.ReadP.ReadS [a]
         -> Text.ParserCombinators.ReadP.ReadS [f a])
     -> (forall a.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec (f a))
     -> (forall a.
         Text.ParserCombinators.ReadPrec.ReadPrec a
         -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
         -> Text.ParserCombinators.ReadPrec.ReadPrec [f a])
     -> Data.Functor.Classes.Read1 f
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Functor.Classes.C:Read1 [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Functor.Classes.C:Ord1
  :: forall (f :: * -> *).
     Data.Functor.Classes.Eq1 f =>
     (forall a b.
      (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering)
     -> Data.Functor.Classes.Ord1 f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Functor.Classes.C:Ord1 [eta_B2 eta_B1];

