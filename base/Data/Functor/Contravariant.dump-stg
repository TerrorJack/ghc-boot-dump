
==================== Pre unarise: ====================
2018-03-16 16:12:13.186967491 UTC

Data.Functor.Contravariant.contramap
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall a b. (a -> b) -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sgjLz]
        case v_sgjLz of {
          Data.Functor.Contravariant.C:Contravariant v_sgjLB [Occ=Once]
                                                     _ [Occ=Dead] ->
              v_sgjLB;
        };

Data.Functor.Contravariant.>$
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall b a. b -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sgjLD]
        case v_sgjLD of {
          Data.Functor.Contravariant.C:Contravariant _ [Occ=Dead]
                                                     v_sgjLG [Occ=Once] ->
              v_sgjLG;
        };

Data.Functor.Contravariant.$tc'Op3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Op"#;

Data.Functor.Contravariant.$tc'Op2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Op3];

Data.Functor.Contravariant.$tcOp2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Op"#;

Data.Functor.Contravariant.$tcOp1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcOp2];

Data.Functor.Contravariant.$tc'Equivalence3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Equivalence"#;

Data.Functor.Contravariant.$tc'Equivalence2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Equivalence3];

Data.Functor.Contravariant.$tcEquivalence2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Equivalence"#;

Data.Functor.Contravariant.$tcEquivalence1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcEquivalence2];

Data.Functor.Contravariant.$tc'Comparison3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Comparison"#;

Data.Functor.Contravariant.$tc'Comparison2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Comparison3];

Data.Functor.Contravariant.$tcComparison2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Comparison"#;

Data.Functor.Contravariant.$tcComparison1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcComparison2];

Data.Functor.Contravariant.$tc'Predicate3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Predicate"#;

Data.Functor.Contravariant.$tc'Predicate2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Predicate3];

Data.Functor.Contravariant.$tcPredicate2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Predicate"#;

Data.Functor.Contravariant.$tcPredicate1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcPredicate2];

Data.Functor.Contravariant.$tcContravariant3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Contravariant"#;

Data.Functor.Contravariant.$tcContravariant2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcContravariant3];

$krep_rgjLa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rgjLb :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgjLa GHC.Types.[]];

$krep2_rgjLc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep3_rgjLd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_rgjLc $krep_rgjLa];

$krep4_rgjLe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgjLc GHC.Types.[]];

$krep5_rgjLf :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgjLa $krep4_rgjLe];

$krep6_rgjLg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep7_rgjLh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep6_rgjLg];

$krep8_rgjLi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep7_rgjLh];

$krep9_rgjLj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcOrdering
                                              GHC.Types.[]];

$krep10_rgjLk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep9_rgjLj];

$krep11_rgjLl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep10_rgjLk];

$krep12_rgjLm :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Functor.Contravariant.$tcContravariant1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep12_rgjLm];

Data.Functor.Contravariant.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Contravariant"#;

Data.Functor.Contravariant.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$trModule2];

Data.Functor.Contravariant.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Contravariant.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$trModule4];

Data.Functor.Contravariant.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Contravariant.$trModule3
                                     Data.Functor.Contravariant.$trModule1];

Data.Functor.Contravariant.$tcContravariant :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1944710495430526909##
                                    15571985404928937498##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcContravariant2
                                    0#
                                    Data.Functor.Contravariant.$tcContravariant1];

Data.Functor.Contravariant.$tcPredicate :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9927645946720114643##
                                    17478425232619398566##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcPredicate1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_rgjLn :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcPredicate
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Predicate1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rgjLh $krep13_rgjLn];

Data.Functor.Contravariant.$tc'Predicate :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10560326927625189840##
                                    8988710799443424590##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Predicate2
                                    1#
                                    Data.Functor.Contravariant.$tc'Predicate1];

Data.Functor.Contravariant.$tcComparison :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8128667979445988110##
                                    9034904213662261762##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcComparison1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_rgjLo :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcComparison
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Comparison1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_rgjLl $krep14_rgjLo];

Data.Functor.Contravariant.$tc'Comparison :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11047345948274903716##
                                    12707949450550295743##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Comparison2
                                    1#
                                    Data.Functor.Contravariant.$tc'Comparison1];

Data.Functor.Contravariant.$tcEquivalence :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9646573079009549553##
                                    12303965936368510845##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcEquivalence1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep15_rgjLp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcEquivalence
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Equivalence1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_rgjLi $krep15_rgjLp];

Data.Functor.Contravariant.$tc'Equivalence :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5667737350508967909##
                                    15093804341312440267##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Equivalence2
                                    1#
                                    Data.Functor.Contravariant.$tc'Equivalence1];

Data.Functor.Contravariant.$tcOp :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13209106975460307324##
                                    7546944290236364550##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcOp1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep16_rgjLq :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcOp
                                              $krep5_rgjLf];

Data.Functor.Contravariant.$tc'Op1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rgjLd $krep16_rgjLq];

Data.Functor.Contravariant.$tc'Op :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12479862397628491530##
                                    1381176546464080972##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Op2
                                    2#
                                    Data.Functor.Contravariant.$tc'Op1];

Data.Functor.Contravariant.comparisonEquivalence1
  :: forall a.
     Data.Functor.Contravariant.Comparison a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjLH a1_sgjLI b_sgjLJ]
        case ds_sgjLH a1_sgjLI b_sgjLJ of {
          __DEFAULT -> GHC.Types.False [];
          GHC.Types.EQ -> GHC.Types.True [];
        };

Data.Functor.Contravariant.comparisonEquivalence
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Contravariant.comparisonEquivalence1
            eta_B3 eta_B2 eta_B1;

Data.Functor.Contravariant.defaultEquivalence
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Classes.== eta_B1;

Data.Functor.Contravariant.defaultComparison
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Contravariant.Comparison a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Classes.compare eta_B1;

Data.Functor.Contravariant.>$$<
  :: forall (f :: * -> *) b a.
     Data.Functor.Contravariant.Contravariant f =>
     f b -> (a -> b) -> f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjLL eta_sgjLM eta1_sgjLN]
        Data.Functor.Contravariant.contramap
            $dContravariant_sgjLL eta1_sgjLN eta_sgjLM;

Data.Functor.Contravariant.>$<
  :: forall (f :: * -> *) a b.
     Data.Functor.Contravariant.Contravariant f =>
     (a -> b) -> f b -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjLO]
        Data.Functor.Contravariant.contramap $dContravariant_sgjLO;

Data.Functor.Contravariant.phantom
  :: forall (f :: * -> *) a b.
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant f) =>
     f a -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)))><S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgjLP $dContravariant_sgjLQ x_sgjLR]
        let {
          sat_sgjLS [Occ=Once] :: f_agiQT ()
          [LclId] =
              [$dFunctor_sgjLP x_sgjLR] \u []
                  GHC.Base.<$ $dFunctor_sgjLP GHC.Tuple.() x_sgjLR;
        } in 
          Data.Functor.Contravariant.>$
              $dContravariant_sgjLQ GHC.Tuple.() sat_sgjLS;

Data.Functor.Contravariant.$<
  :: forall (f :: * -> *) b a.
     Data.Functor.Contravariant.Contravariant f =>
     f b -> b -> f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjLT eta_sgjLU eta1_sgjLV]
        Data.Functor.Contravariant.>$
            $dContravariant_sgjLT eta1_sgjLV eta_sgjLU;

Data.Functor.Contravariant.$fContravariantOp1
  :: forall a1 b a2.
     b -> Data.Functor.Contravariant.Op a1 b -> a2 -> a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgjLW eta_sgjLX eta1_sgjLY] eta_sgjLX x_sgjLW;

Data.Functor.Contravariant.$fContravariantOp2
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Functor.Contravariant.Op a1 b -> a2 -> a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f_sgjLZ g_sgjM0 eta_B1] GHC.Base.. g_sgjM0 f_sgjLZ eta_B1;

Data.Functor.Contravariant.$fContravariantOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Contravariant.Op a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantOp2
                                                               Data.Functor.Contravariant.$fContravariantOp1];

Data.Functor.Contravariant.getOp1
  :: forall a b.
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgjM1] ds_sgjM1;

Data.Functor.Contravariant.getOp
  :: forall a b. Data.Functor.Contravariant.Op a b -> b -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getOp1 eta_B1;

Data.Functor.Contravariant.$fContravariantEquivalence1
  :: forall b a.
     b
     -> Data.Functor.Contravariant.Equivalence b
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),1*C1(C1(U))><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgjM2 eta_sgjM3 eta1_sgjM4 eta2_sgjM5]
        eta_sgjM3 x_sgjM2 x_sgjM2;

Data.Functor.Contravariant.$fContravariantEquivalence2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Equivalence b
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgjM6 g_sgjM7 x_sgjM8 y_sgjM9]
        let {
          sat_sgjMb [Occ=Once] :: b_agj9q
          [LclId] =
              [f_sgjM6 y_sgjM9] \u [] f_sgjM6 y_sgjM9; } in
        let {
          sat_sgjMa [Occ=Once] :: b_agj9q
          [LclId] =
              [f_sgjM6 x_sgjM8] \u [] f_sgjM6 x_sgjM8;
        } in  g_sgjM7 sat_sgjMa sat_sgjMb;

Data.Functor.Contravariant.$fContravariantEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Equivalence
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantEquivalence2
                                                               Data.Functor.Contravariant.$fContravariantEquivalence1];

Data.Functor.Contravariant.getEquivalence1
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgjMc] ds_sgjMc;

Data.Functor.Contravariant.getEquivalence
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> a -> a -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getEquivalence1 eta_B1;

Data.Functor.Contravariant.$fContravariantComparison1
  :: forall b a.
     b
     -> Data.Functor.Contravariant.Comparison b
     -> a
     -> a
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),1*C1(C1(U))><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgjMd eta_sgjMe eta1_sgjMf eta2_sgjMg]
        eta_sgjMe x_sgjMd x_sgjMd;

Data.Functor.Contravariant.$fContravariantComparison2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Comparison b
     -> a
     -> a
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgjMh g_sgjMi x_sgjMj y_sgjMk]
        let {
          sat_sgjMm [Occ=Once] :: b_agj9P
          [LclId] =
              [f_sgjMh y_sgjMk] \u [] f_sgjMh y_sgjMk; } in
        let {
          sat_sgjMl [Occ=Once] :: b_agj9P
          [LclId] =
              [f_sgjMh x_sgjMj] \u [] f_sgjMh x_sgjMj;
        } in  g_sgjMi sat_sgjMl sat_sgjMm;

Data.Functor.Contravariant.$fContravariantComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Comparison
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantComparison2
                                                               Data.Functor.Contravariant.$fContravariantComparison1];

Data.Functor.Contravariant.getComparison1
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> Data.Functor.Contravariant.Comparison a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgjMn] ds_sgjMn;

Data.Functor.Contravariant.getComparison
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> a -> a -> GHC.Types.Ordering
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getComparison1 eta_B1;

Data.Functor.Contravariant.$fContravariantPredicate1
  :: forall b a.
     b -> Data.Functor.Contravariant.Predicate b -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgjMo eta_sgjMp eta1_sgjMq] eta_sgjMp x_sgjMo;

Data.Functor.Contravariant.$fContravariantPredicate2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Predicate b -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f_sgjMr g_sgjMs eta_B1] GHC.Base.. g_sgjMs f_sgjMr eta_B1;

Data.Functor.Contravariant.$fContravariantPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Predicate
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantPredicate2
                                                               Data.Functor.Contravariant.$fContravariantPredicate1];

Data.Functor.Contravariant.getPredicate1
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgjMt] ds_sgjMt;

Data.Functor.Contravariant.getPredicate
  :: forall a.
     Data.Functor.Contravariant.Predicate a -> a -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getPredicate1 eta_B1;

Data.Functor.Contravariant.$fContravariantV1_$c>$
  :: forall b a. b -> GHC.Generics.V1 b -> GHC.Generics.V1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [x_sgjMu x1_sgjMv] x1_sgjMv;

Data.Functor.Contravariant.$fContravariantU1_$c>$
  :: forall b a. b -> GHC.Generics.U1 b -> GHC.Generics.U1 a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sgjMx ds_sgjMy] GHC.Generics.U1 [];

Data.Functor.Contravariant.$fContravariantK2
  :: forall b c i.
     b -> GHC.Generics.K1 i c b -> GHC.Generics.K1 i c b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgjMz ds_sgjMA] ds_sgjMA;

Data.Functor.Contravariant.$fContravariant:*:_$c>$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgjMB w1_sgjMC w2_sgjMD w3_sgjME]
        case w3_sgjME of {
          GHC.Generics.:*: ww1_sgjMG [Occ=Once] ww2_sgjMH [Occ=Once] ->
              let {
                f1_sgjMI :: a_sgjEw -> b_sgjEv
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sgjMD] \r [ds_sgjMJ] w2_sgjMD; } in
              let {
                sat_sgjML [Occ=Once] :: g_sgjEs a_sgjEw
                [LclId] =
                    [w1_sgjMC ww2_sgjMH f1_sgjMI] \u []
                        Data.Functor.Contravariant.contramap
                            w1_sgjMC f1_sgjMI ww2_sgjMH; } in
              let {
                sat_sgjMK [Occ=Once] :: f_sgjEr a_sgjEw
                [LclId] =
                    [w_sgjMB ww1_sgjMG f1_sgjMI] \u []
                        Data.Functor.Contravariant.contramap w_sgjMB f1_sgjMI ww1_sgjMG;
              } in  GHC.Generics.:*: [sat_sgjMK sat_sgjML];
        };

Data.Functor.Contravariant.$fContravariant:.:1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall b a. b -> (GHC.Generics.:.:) f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgjMM $dContravariant_sgjMN x_sgjMO eta_sgjMP]
        let {
          sat_sgjMS [Occ=Once] :: g_XgjkT b_agjf1 -> g_XgjkT a_agjf2
          [LclId] =
              [$dContravariant_sgjMN x_sgjMO] \u []
                  let {
                    sat_sgjMR [Occ=Once] :: a_agjf2 -> b_agjf1
                    [LclId] =
                        [x_sgjMO] \r [ds_sgjMQ] x_sgjMO;
                  } in 
                    Data.Functor.Contravariant.contramap
                        $dContravariant_sgjMN sat_sgjMR;
        } in  GHC.Base.fmap $dFunctor_sgjMM sat_sgjMS eta_sgjMP;

Data.Functor.Contravariant.$fContravariantProduct_$c>$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgjMT w1_sgjMU w2_sgjMV w3_sgjMW]
        case w3_sgjMW of {
          Data.Functor.Product.Pair ww1_sgjMY [Occ=Once]
                                    ww2_sgjMZ [Occ=Once] ->
              let {
                f1_sgjN0 :: a_sgjEN -> b_sgjEM
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sgjMV] \r [ds_sgjN1] w2_sgjMV; } in
              let {
                sat_sgjN3 [Occ=Once] :: g_sgjEJ a_sgjEN
                [LclId] =
                    [w1_sgjMU ww2_sgjMZ f1_sgjN0] \u []
                        Data.Functor.Contravariant.contramap
                            w1_sgjMU f1_sgjN0 ww2_sgjMZ; } in
              let {
                sat_sgjN2 [Occ=Once] :: f_sgjEI a_sgjEN
                [LclId] =
                    [w_sgjMT ww1_sgjMY f1_sgjN0] \u []
                        Data.Functor.Contravariant.contramap w_sgjMT f1_sgjN0 ww1_sgjMY;
              } in  Data.Functor.Product.Pair [sat_sgjN2 sat_sgjN3];
        };

Data.Functor.Contravariant.$fContravariantConst1
  :: forall b a.
     b -> Data.Functor.Const.Const a b -> Data.Functor.Const.Const a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgjN4 ds_sgjN5] ds_sgjN5;

Data.Functor.Contravariant.$fContravariantCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall b a. b -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgjN6 $dContravariant_sgjN7 x_sgjN8 eta_sgjN9]
        let {
          sat_sgjNc [Occ=Once] :: g_XgjhX b_agjcg -> g_XgjhX a_agjch
          [LclId] =
              [$dContravariant_sgjN7 x_sgjN8] \u []
                  let {
                    sat_sgjNb [Occ=Once] :: a_agjch -> b_agjcg
                    [LclId] =
                        [x_sgjN8] \r [ds_sgjNa] x_sgjN8;
                  } in 
                    Data.Functor.Contravariant.contramap
                        $dContravariant_sgjN7 sat_sgjNb;
        } in  GHC.Base.fmap $dFunctor_sgjN6 sat_sgjNc eta_sgjN9;

Data.Functor.Contravariant.$fContravariantProxy_$c>$
  :: forall b a. b -> Data.Proxy.Proxy b -> Data.Proxy.Proxy a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sgjNd ds_sgjNe] Data.Proxy.Proxy [];

Data.Functor.Contravariant.$dm>$
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall b a. b -> f b -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjNf eta_sgjNg]
        let {
          sat_sgjNi [Occ=Once] :: a_agiRb -> b_agiRa
          [LclId] =
              [eta_sgjNg] \r [ds_sgjNh] eta_sgjNg;
        } in 
          Data.Functor.Contravariant.contramap
              $dContravariant_sgjNf sat_sgjNi;

Data.Functor.Contravariant.$fSemigroupOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sgjNj]
        let {
          sat_sgjNm [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgjNj] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$cstimes
                      $dSemigroup_sgjNj eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjNl [Occ=Once]
            :: GHC.Base.NonEmpty
                 (Data.Functor.Contravariant.Op a_agiSm b_agiSn)
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgjNj] \r [eta_B1]
                  GHC.Base.$fSemigroup(->)_$csconcat $dSemigroup_sgjNj eta_B1; } in
        let {
          sat_sgjNk [Occ=Once]
            :: Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgjNj] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$c<>
                      $dSemigroup_sgjNj eta_B3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sgjNk sat_sgjNl sat_sgjNm];

Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid
  :: forall a b.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgjNn]
        let {
          sat_sgjNo [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_XgiXu
          [LclId] =
              [$dMonoid_sgjNn] \u [] GHC.Base.$p1Monoid $dMonoid_sgjNn;
        } in  Data.Functor.Contravariant.$fSemigroupOp sat_sgjNo;

Data.Functor.Contravariant.$fMonoidOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_sgjNp]
        let {
          lvl7_sgjNq [Occ=OnceL] :: a_XgiXv
          [LclId] =
              [$dMonoid_sgjNp] \u [] GHC.Base.mempty $dMonoid_sgjNp; } in
        let {
          sat_sgjNv [Occ=Once]
            :: [Data.Functor.Contravariant.Op a_XgiXv b_XgiXx]
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [$dMonoid_sgjNp] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmconcat $dMonoid_sgjNp eta_B2 eta_B1; } in
        let {
          sat_sgjNu [Occ=Once]
            :: Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [$dMonoid_sgjNp] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmappend
                      $dMonoid_sgjNp eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjNt [Occ=Once]
            :: Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [lvl7_sgjNq] \r [ds_sgjNs] lvl7_sgjNq; } in
        let {
          sat_sgjNr [Occ=Once]
            :: GHC.Base.Semigroup
                 (Data.Functor.Contravariant.Op a_XgiXv b_XgiXx)
          [LclId] =
              [$dMonoid_sgjNp] \u []
                  Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid $dMonoid_sgjNp;
        } in  GHC.Base.C:Monoid [sat_sgjNr sat_sgjNt sat_sgjNu sat_sgjNv];

Data.Functor.Contravariant.$fMonoidComparison3
  :: forall a. a -> a -> GHC.Types.Ordering
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjNw ds1_sgjNx] GHC.Types.EQ [];

Data.Functor.Contravariant.$fMonoidComparison2
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgjNy g_sgjNz x_sgjNA]
        let {
          f1_sgjNB [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [f_sgjNy x_sgjNA] \u [] f_sgjNy x_sgjNA; } in
        let {
          g1_sgjNC [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [g_sgjNz x_sgjNA] \u [] g_sgjNz x_sgjNA; } in
        let {
          sat_sgjNF [Occ=OnceT[0]] :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [f1_sgjNB g1_sgjNC] \r [x1_sgjND]
                  case f1_sgjNB x1_sgjND of {
                    GHC.Types.LT -> GHC.Types.LT [];
                    GHC.Types.EQ -> g1_sgjNC x1_sgjND;
                    GHC.Types.GT -> GHC.Types.GT [];
                  };
        } in  sat_sgjNF;

Data.Functor.Contravariant.$fSemigroupComparison3
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgjNG g_sgjNH x_sgjNI]
        let {
          f1_sgjNJ [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [f_sgjNG x_sgjNI] \u [] f_sgjNG x_sgjNI; } in
        let {
          g1_sgjNK [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [g_sgjNH x_sgjNI] \u [] g_sgjNH x_sgjNI; } in
        let {
          sat_sgjNN [Occ=OnceT[0]] :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [f1_sgjNJ g1_sgjNK] \r [x1_sgjNL]
                  case f1_sgjNJ x1_sgjNL of {
                    GHC.Types.LT -> GHC.Types.LT [];
                    GHC.Types.EQ -> g1_sgjNK x1_sgjNL;
                    GHC.Types.GT -> GHC.Types.GT [];
                  };
        } in  sat_sgjNN;

Data.Functor.Contravariant.$fSemigroupComparison1
  :: forall a b.
     GHC.Real.Integral b =>
     b -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Str=<L,U><L,U><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sgjNO n_sgjNP f_sgjNQ e_sgjNR]
        let {
          f1_sgjNS [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiUz -> GHC.Types.Ordering
          [LclId] =
              [f_sgjNQ e_sgjNR] \u [] f_sgjNQ e_sgjNR; } in
        let {
          lvl7_sgjNT [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: b_agiVn -> GHC.Types.Ordering -> GHC.Types.Ordering
          [LclId] =
              [$dIntegral_sgjNO] \u []
                  GHC.Base.$fSemigroupOrdering_$cstimes $dIntegral_sgjNO; } in
        let {
          sat_sgjNW [Occ=OnceT[0]] :: a_agiUz -> GHC.Types.Ordering
          [LclId] =
              [n_sgjNP f1_sgjNS lvl7_sgjNT] \r [e1_sgjNU]
                  let {
                    sat_sgjNV [Occ=Once] :: GHC.Types.Ordering
                    [LclId] =
                        [f1_sgjNS e1_sgjNU] \u [] f1_sgjNS e1_sgjNU;
                  } in  lvl7_sgjNT n_sgjNP sat_sgjNV;
        } in  sat_sgjNW;

Data.Functor.Contravariant.$fContravariantM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant (GHC.Generics.M1 i c f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgjNX]
        let {
          sat_sgjNZ [Occ=Once]
            :: forall b a.
               b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r a
          [LclId] =
              [$dContravariant_sgjNX] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgjNX; } in
        let {
          sat_sgjNY [Occ=Once]
            :: forall a b.
               (a -> b)
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r a
          [LclId] =
              [$dContravariant_sgjNX] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgjNX;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjNY sat_sgjNZ];

Data.Functor.Contravariant.$fContravariantRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant (GHC.Generics.Rec1 f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgjO0]
        let {
          sat_sgjO2 [Occ=Once]
            :: forall b a.
               b -> GHC.Generics.Rec1 f_agiX0 b -> GHC.Generics.Rec1 f_agiX0 a
          [LclId] =
              [$dContravariant_sgjO0] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgjO0; } in
        let {
          sat_sgjO1 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> GHC.Generics.Rec1 f_agiX0 b -> GHC.Generics.Rec1 f_agiX0 a
          [LclId] =
              [$dContravariant_sgjO0] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgjO0;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjO1 sat_sgjO2];

Data.Functor.Contravariant.$fContravariantAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant
       (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgjO3]
        let {
          sat_sgjO5 [Occ=Once]
            :: forall b a.
               b
               -> Data.Semigroup.Internal.Alt f_agiY2 b
               -> Data.Semigroup.Internal.Alt f_agiY2 a
          [LclId] =
              [$dContravariant_sgjO3] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgjO3; } in
        let {
          sat_sgjO4 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Semigroup.Internal.Alt f_agiY2 b
               -> Data.Semigroup.Internal.Alt f_agiY2 a
          [LclId] =
              [$dContravariant_sgjO3] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgjO3;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjO4 sat_sgjO5];

sat_sgjO6 :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgjO7 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgjO6 GHC.Types.[]];

lvl_rgjLr :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgjO7;

lvl1_rgjLs :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Functor.Contravariant.$fFloatingOp_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjO8 eta_sgjO9]
        let {
          $dFractional_sgjOa [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgjO8] \s []
                  GHC.Float.$p1Floating $dFloating_sgjO8; } in
        let {
          $dNum_sgjOb [Dmd=<L,U(C(C1(U)),C(C1(U)),A,A,A,A,C(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgjOa] \u []
                  GHC.Real.$p1Fractional $dFractional_sgjOa; } in
        let {
          x_sgjOc [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgjOb] \u []
                  GHC.Num.fromInteger $dNum_sgjOb lvl1_rgjLs; } in
        let {
          x1_sgjOd [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgjOb] \u [] GHC.Num.fromInteger $dNum_sgjOb lvl_rgjLr; } in
        let {
          sat_sgjOj [Occ=Once] :: b_Xgj9Q -> a_Xgj9N
          [LclId] =
              [$dFloating_sgjO8
               eta_sgjO9
               $dNum_sgjOb
               x_sgjOc
               x1_sgjOd] \r [eta1_sgjOe]
                  let {
                    sat_sgjOi [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgjO8
                         eta_sgjO9
                         $dNum_sgjOb
                         x_sgjOc
                         x1_sgjOd
                         eta1_sgjOe] \u []
                            let {
                              sat_sgjOh [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [$dFloating_sgjO8 eta_sgjO9 $dNum_sgjOb x_sgjOc eta1_sgjOe] \u []
                                      let {
                                        sat_sgjOg [Occ=Once] :: a_Xgj9N
                                        [LclId] =
                                            [$dFloating_sgjO8 eta_sgjO9 eta1_sgjOe] \u []
                                                let {
                                                  sat_sgjOf [Occ=Once] :: a_Xgj9N
                                                  [LclId] =
                                                      [eta_sgjO9 eta1_sgjOe] \u []
                                                          eta_sgjO9 eta1_sgjOe;
                                                } in  GHC.Float.exp $dFloating_sgjO8 sat_sgjOf;
                                      } in  GHC.Num.- $dNum_sgjOb x_sgjOc sat_sgjOg;
                            } in  GHC.Num.+ $dNum_sgjOb x1_sgjOd sat_sgjOh;
                  } in  GHC.Float.log $dFloating_sgjO8 sat_sgjOi;
        } in  sat_sgjOj;

Data.Functor.Contravariant.$fFloatingOp_$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(A,C(C1(U)),A,A,A,A,1*C1(U)),A,A,A),A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOk eta_sgjOl]
        let {
          $dFractional_sgjOm [Occ=OnceL,
                              Dmd=<L,1*U(1*U(A,C(C1(U)),A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgjOk] \s []
                  GHC.Float.$p1Floating $dFloating_sgjOk; } in
        let {
          $dNum_sgjOn [Dmd=<L,U(A,C(C1(U)),A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgjOm] \u []
                  GHC.Real.$p1Fractional $dFractional_sgjOm; } in
        let {
          x_sgjOo [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgjOn] \u [] GHC.Num.fromInteger $dNum_sgjOn lvl_rgjLr; } in
        let {
          sat_sgjOs [Occ=Once] :: b_Xgj4c -> a_Xgj9N
          [LclId] =
              [$dFloating_sgjOk eta_sgjOl $dNum_sgjOn x_sgjOo] \r [a1_sgjOp]
                  let {
                    sat_sgjOr [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgjOk eta_sgjOl a1_sgjOp] \u []
                            let {
                              sat_sgjOq [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [eta_sgjOl a1_sgjOp] \u [] eta_sgjOl a1_sgjOp;
                            } in  GHC.Float.exp $dFloating_sgjOk sat_sgjOq;
                  } in  GHC.Num.- $dNum_sgjOn sat_sgjOr x_sgjOo;
        } in  sat_sgjOs;

Data.Functor.Contravariant.$fFloatingOp_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOt eta_sgjOu]
        let {
          $dFractional_sgjOv [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgjOt] \s []
                  GHC.Float.$p1Floating $dFloating_sgjOt; } in
        let {
          $dNum_sgjOw [Dmd=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgjOv] \u []
                  GHC.Real.$p1Fractional $dFractional_sgjOv; } in
        let {
          x_sgjOx [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgjOw] \u [] GHC.Num.fromInteger $dNum_sgjOw lvl_rgjLr; } in
        let {
          sat_sgjOC [Occ=Once] :: b_Xgj9Q -> a_Xgj9N
          [LclId] =
              [$dFloating_sgjOt eta_sgjOu $dNum_sgjOw x_sgjOx] \r [eta1_sgjOy]
                  let {
                    sat_sgjOB [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgjOt eta_sgjOu $dNum_sgjOw x_sgjOx eta1_sgjOy] \u []
                            let {
                              sat_sgjOA [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [$dFloating_sgjOt eta_sgjOu eta1_sgjOy] \u []
                                      let {
                                        sat_sgjOz [Occ=Once] :: a_Xgj9N
                                        [LclId] =
                                            [eta_sgjOu eta1_sgjOy] \u [] eta_sgjOu eta1_sgjOy;
                                      } in  GHC.Float.exp $dFloating_sgjOt sat_sgjOz;
                            } in  GHC.Num.+ $dNum_sgjOw x_sgjOx sat_sgjOA;
                  } in  GHC.Float.log $dFloating_sgjOt sat_sgjOB;
        } in  sat_sgjOC;

Data.Functor.Contravariant.$fFloatingOp_$clog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOD eta_sgjOE]
        let {
          $dFractional_sgjOF [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj4c
          [LclId] =
              [$dFloating_sgjOD] \s []
                  GHC.Float.$p1Floating $dFloating_sgjOD; } in
        let {
          $dNum_sgjOG [Dmd=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj4c
          [LclId] =
              [$dFractional_sgjOF] \u []
                  GHC.Real.$p1Fractional $dFractional_sgjOF; } in
        let {
          x_sgjOH [Occ=OnceL] :: a_Xgj4c
          [LclId] =
              [$dNum_sgjOG] \u [] GHC.Num.fromInteger $dNum_sgjOG lvl_rgjLr; } in
        let {
          sat_sgjOL [Occ=Once] :: b_Xgj4e -> a_Xgj4c
          [LclId] =
              [$dFloating_sgjOD eta_sgjOE $dNum_sgjOG x_sgjOH] \r [eta1_sgjOI]
                  let {
                    sat_sgjOK [Occ=Once] :: a_Xgj4c
                    [LclId] =
                        [eta_sgjOE $dNum_sgjOG x_sgjOH eta1_sgjOI] \u []
                            let {
                              sat_sgjOJ [Occ=Once] :: a_Xgj4c
                              [LclId] =
                                  [eta_sgjOE eta1_sgjOI] \u [] eta_sgjOE eta1_sgjOI;
                            } in  GHC.Num.+ $dNum_sgjOG x_sgjOH sat_sgjOJ;
                  } in  GHC.Float.log $dFloating_sgjOD sat_sgjOK;
        } in  sat_sgjOL;

Data.Functor.Contravariant.$fFloatingOp17
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLLLLLLLLLLLLLLLLLLL),1*U(A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOM ds_sgjON eta_sgjOO]
        let {
          sat_sgjOP [Occ=Once] :: a_XgjeT
          [LclId] =
              [ds_sgjON eta_sgjOO] \u [] ds_sgjON eta_sgjOO;
        } in  GHC.Float.exp $dFloating_sgjOM sat_sgjOP;

Data.Functor.Contravariant.$fFloatingOp16
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LLLLLLLLLLLLLLLLLLL),1*U(A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOQ ds_sgjOR eta_sgjOS]
        let {
          sat_sgjOT [Occ=Once] :: a_Xgj44
          [LclId] =
              [ds_sgjOR eta_sgjOS] \u [] ds_sgjOR eta_sgjOS;
        } in  GHC.Float.log $dFloating_sgjOQ sat_sgjOT;

Data.Functor.Contravariant.$fFloatingOp15
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)LLLLLLLLLLLLLLLLLL),1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOU ds_sgjOV eta_sgjOW]
        let {
          sat_sgjOX [Occ=Once] :: a_Xgj9g
          [LclId] =
              [ds_sgjOV eta_sgjOW] \u [] ds_sgjOV eta_sgjOW;
        } in  GHC.Float.sqrt $dFloating_sgjOU sat_sgjOX;

Data.Functor.Contravariant.$fFloatingOp14
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOY ds_sgjOZ ds1_sgjP0 a1_sgjP1]
        let {
          sat_sgjP3 [Occ=Once] :: a_Xgj3W
          [LclId] =
              [ds1_sgjP0 a1_sgjP1] \u [] ds1_sgjP0 a1_sgjP1; } in
        let {
          sat_sgjP2 [Occ=Once] :: a_Xgj3W
          [LclId] =
              [ds_sgjOZ a1_sgjP1] \u [] ds_sgjOZ a1_sgjP1;
        } in  GHC.Float.** $dFloating_sgjOY sat_sgjP2 sat_sgjP3;

Data.Functor.Contravariant.$fFloatingOp13
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjP4 ds_sgjP5 ds1_sgjP6 a1_sgjP7]
        let {
          sat_sgjP9 [Occ=Once] :: a_Xgj4f
          [LclId] =
              [ds1_sgjP6 a1_sgjP7] \u [] ds1_sgjP6 a1_sgjP7; } in
        let {
          sat_sgjP8 [Occ=Once] :: a_Xgj4f
          [LclId] =
              [ds_sgjP5 a1_sgjP7] \u [] ds_sgjP5 a1_sgjP7;
        } in  GHC.Float.logBase $dFloating_sgjP4 sat_sgjP8 sat_sgjP9;

Data.Functor.Contravariant.$fFloatingOp12
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPa ds_sgjPb eta_sgjPc]
        let {
          sat_sgjPd [Occ=Once] :: a_Xgj49
          [LclId] =
              [ds_sgjPb eta_sgjPc] \u [] ds_sgjPb eta_sgjPc;
        } in  GHC.Float.sin $dFloating_sgjPa sat_sgjPd;

Data.Functor.Contravariant.$fFloatingOp11
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPe ds_sgjPf eta_sgjPg]
        let {
          sat_sgjPh [Occ=Once] :: a_Xgj43
          [LclId] =
              [ds_sgjPf eta_sgjPg] \u [] ds_sgjPf eta_sgjPg;
        } in  GHC.Float.cos $dFloating_sgjPe sat_sgjPh;

Data.Functor.Contravariant.$fFloatingOp10
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(S)LLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPi ds_sgjPj eta_sgjPk]
        let {
          sat_sgjPl [Occ=Once] :: a_Xgj3X
          [LclId] =
              [ds_sgjPj eta_sgjPk] \u [] ds_sgjPj eta_sgjPk;
        } in  GHC.Float.tan $dFloating_sgjPi sat_sgjPl;

Data.Functor.Contravariant.$fFloatingOp9
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLC(S)LLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPm ds_sgjPn eta_sgjPo]
        let {
          sat_sgjPp [Occ=Once] :: a_Xgj3R
          [LclId] =
              [ds_sgjPn eta_sgjPo] \u [] ds_sgjPn eta_sgjPo;
        } in  GHC.Float.asin $dFloating_sgjPm sat_sgjPp;

Data.Functor.Contravariant.$fFloatingOp8
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLC(S)LLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPq ds_sgjPr eta_sgjPs]
        let {
          sat_sgjPt [Occ=Once] :: a_Xgj3L
          [LclId] =
              [ds_sgjPr eta_sgjPs] \u [] ds_sgjPr eta_sgjPs;
        } in  GHC.Float.acos $dFloating_sgjPq sat_sgjPt;

Data.Functor.Contravariant.$fFloatingOp7
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLC(S)LLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPu ds_sgjPv eta_sgjPw]
        let {
          sat_sgjPx [Occ=Once] :: a_Xgj3F
          [LclId] =
              [ds_sgjPv eta_sgjPw] \u [] ds_sgjPv eta_sgjPw;
        } in  GHC.Float.atan $dFloating_sgjPu sat_sgjPx;

Data.Functor.Contravariant.$fFloatingOp6
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLC(S)LLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPy ds_sgjPz eta_sgjPA]
        let {
          sat_sgjPB [Occ=Once] :: a_Xgj3z
          [LclId] =
              [ds_sgjPz eta_sgjPA] \u [] ds_sgjPz eta_sgjPA;
        } in  GHC.Float.sinh $dFloating_sgjPy sat_sgjPB;

Data.Functor.Contravariant.$fFloatingOp5
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPC ds_sgjPD eta_sgjPE]
        let {
          sat_sgjPF [Occ=Once] :: a_Xgj3t
          [LclId] =
              [ds_sgjPD eta_sgjPE] \u [] ds_sgjPD eta_sgjPE;
        } in  GHC.Float.cosh $dFloating_sgjPC sat_sgjPF;

Data.Functor.Contravariant.$fFloatingOp4
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPG ds_sgjPH eta_sgjPI]
        let {
          sat_sgjPJ [Occ=Once] :: a_Xgj3n
          [LclId] =
              [ds_sgjPH eta_sgjPI] \u [] ds_sgjPH eta_sgjPI;
        } in  GHC.Float.tanh $dFloating_sgjPG sat_sgjPJ;

Data.Functor.Contravariant.$fFloatingOp3
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLC(S)LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPK ds_sgjPL eta_sgjPM]
        let {
          sat_sgjPN [Occ=Once] :: a_Xgj3h
          [LclId] =
              [ds_sgjPL eta_sgjPM] \u [] ds_sgjPL eta_sgjPM;
        } in  GHC.Float.asinh $dFloating_sgjPK sat_sgjPN;

Data.Functor.Contravariant.$fFloatingOp2
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLC(S)LLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPO ds_sgjPP eta_sgjPQ]
        let {
          sat_sgjPR [Occ=Once] :: a_Xgj3b
          [LclId] =
              [ds_sgjPP eta_sgjPQ] \u [] ds_sgjPP eta_sgjPQ;
        } in  GHC.Float.acosh $dFloating_sgjPO sat_sgjPR;

Data.Functor.Contravariant.$fFloatingOp1
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLC(S)LLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPS ds_sgjPT eta_sgjPU]
        let {
          sat_sgjPV [Occ=Once] :: a_agiZ4
          [LclId] =
              [ds_sgjPT eta_sgjPU] \u [] ds_sgjPT eta_sgjPU;
        } in  GHC.Float.atanh $dFloating_sgjPS sat_sgjPV;

Data.Functor.Contravariant.$fFractionalOp2
  :: forall a b.
     GHC.Real.Fractional a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LL),1*U(A,1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgjPW ds_sgjPX ds1_sgjPY a1_sgjPZ]
        let {
          sat_sgjQ1 [Occ=Once] :: a_Xgj8K
          [LclId] =
              [ds1_sgjPY a1_sgjPZ] \u [] ds1_sgjPY a1_sgjPZ; } in
        let {
          sat_sgjQ0 [Occ=Once] :: a_Xgj8K
          [LclId] =
              [ds_sgjPX a1_sgjPZ] \u [] ds_sgjPX a1_sgjPZ;
        } in  GHC.Real./ $dFractional_sgjPW sat_sgjQ0 sat_sgjQ1;

Data.Functor.Contravariant.$fFractionalOp1
  :: forall a b.
     GHC.Real.Fractional a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)L),1*U(A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgjQ2 ds_sgjQ3 eta_sgjQ4]
        let {
          sat_sgjQ5 [Occ=Once] :: a_agj4M
          [LclId] =
              [ds_sgjQ3 eta_sgjQ4] \u [] ds_sgjQ3 eta_sgjQ4;
        } in  GHC.Real.recip $dFractional_sgjQ2 sat_sgjQ5;

Data.Functor.Contravariant.$fFractionalOp_$cfromRational
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Real.Rational -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgjQ6 eta_sgjQ7]
        let {
          x_sgjQ8 [Occ=OnceL] :: a_agj4M
          [LclId] =
              [$dFractional_sgjQ6 eta_sgjQ7] \u []
                  GHC.Real.fromRational $dFractional_sgjQ6 eta_sgjQ7; } in
        let {
          sat_sgjQa [Occ=Once] :: b_agj4N -> a_agj4M
          [LclId] =
              [x_sgjQ8] \r [ds_sgjQ9] x_sgjQ8;
        } in  sat_sgjQa;

Data.Functor.Contravariant.$fNumOp_$cnegate [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(U)),A,A,A,A,1*C1(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQb eta_sgjQc]
        let {
          x_sgjQd [Occ=OnceL] :: a_Xgjab
          [LclId] =
              [$dNum_sgjQb] \u []
                  GHC.Num.fromInteger $dNum_sgjQb lvl1_rgjLs; } in
        let {
          sat_sgjQg [Occ=Once] :: b_Xgjad -> a_Xgjab
          [LclId] =
              [$dNum_sgjQb eta_sgjQc x_sgjQd] \r [a1_sgjQe]
                  let {
                    sat_sgjQf [Occ=Once] :: a_Xgjab
                    [LclId] =
                        [eta_sgjQc a1_sgjQe] \u [] eta_sgjQc a1_sgjQe;
                  } in  GHC.Num.- $dNum_sgjQb x_sgjQd sat_sgjQf;
        } in  sat_sgjQg;

Data.Functor.Contravariant.$fNumOp5
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQh ds_sgjQi ds1_sgjQj a1_sgjQk]
        let {
          sat_sgjQm [Occ=Once] :: a_Xgja3
          [LclId] =
              [ds1_sgjQj a1_sgjQk] \u [] ds1_sgjQj a1_sgjQk; } in
        let {
          sat_sgjQl [Occ=Once] :: a_Xgja3
          [LclId] =
              [ds_sgjQi a1_sgjQk] \u [] ds_sgjQi a1_sgjQk;
        } in  GHC.Num.+ $dNum_sgjQh sat_sgjQl sat_sgjQm;

Data.Functor.Contravariant.$fNumOp4
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQn ds_sgjQo ds1_sgjQp a1_sgjQq]
        let {
          sat_sgjQs [Occ=Once] :: a_Xgj9W
          [LclId] =
              [ds1_sgjQp a1_sgjQq] \u [] ds1_sgjQp a1_sgjQq; } in
        let {
          sat_sgjQr [Occ=Once] :: a_Xgj9W
          [LclId] =
              [ds_sgjQo a1_sgjQq] \u [] ds_sgjQo a1_sgjQq;
        } in  GHC.Num.- $dNum_sgjQn sat_sgjQr sat_sgjQs;

Data.Functor.Contravariant.$fNumOp3
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQt ds_sgjQu ds1_sgjQv a1_sgjQw]
        let {
          sat_sgjQy [Occ=Once] :: a_Xgj9A
          [LclId] =
              [ds1_sgjQv a1_sgjQw] \u [] ds1_sgjQv a1_sgjQw; } in
        let {
          sat_sgjQx [Occ=Once] :: a_Xgj9A
          [LclId] =
              [ds_sgjQu a1_sgjQw] \u [] ds_sgjQu a1_sgjQw;
        } in  GHC.Num.* $dNum_sgjQt sat_sgjQx sat_sgjQy;

Data.Functor.Contravariant.$fNumOp2
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)LL),1*U(A,A,A,A,1*C1(U),A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQz ds_sgjQA eta_sgjQB]
        let {
          sat_sgjQC [Occ=Once] :: a_Xgj9u
          [LclId] =
              [ds_sgjQA eta_sgjQB] \u [] ds_sgjQA eta_sgjQB;
        } in  GHC.Num.abs $dNum_sgjQz sat_sgjQC;

Data.Functor.Contravariant.$fNumOp1
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(S)L),1*U(A,A,A,A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQD ds_sgjQE eta_sgjQF]
        let {
          sat_sgjQG [Occ=Once] :: a_agj5O
          [LclId] =
              [ds_sgjQE eta_sgjQF] \u [] ds_sgjQE eta_sgjQF;
        } in  GHC.Num.signum $dNum_sgjQD sat_sgjQG;

Data.Functor.Contravariant.$fNumOp_$cfromInteger
  :: forall a b.
     GHC.Num.Num a =>
     GHC.Integer.Type.Integer -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQH eta_sgjQI]
        let {
          x_sgjQJ [Occ=OnceL] :: a_agj5O
          [LclId] =
              [$dNum_sgjQH eta_sgjQI] \u []
                  GHC.Num.fromInteger $dNum_sgjQH eta_sgjQI; } in
        let {
          sat_sgjQL [Occ=Once] :: b_agj5P -> a_agj5O
          [LclId] =
              [x_sgjQJ] \r [ds_sgjQK] x_sgjQJ;
        } in  sat_sgjQL;

Data.Functor.Contravariant.$fNumOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>m] =
    [] \r [$dNum_sgjQM]
        let {
          sat_sgjQT [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B1]
                  Data.Functor.Contravariant.$fNumOp_$cfromInteger
                      $dNum_sgjQM eta_B1; } in
        let {
          sat_sgjQS [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp1 $dNum_sgjQM eta_B2 eta_B1; } in
        let {
          sat_sgjQR [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp2 $dNum_sgjQM eta_B2 eta_B1; } in
        let {
          sat_sgjQQ [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B1]
                  Data.Functor.Contravariant.$fNumOp_$cnegate
                      $dNum_sgjQM eta_B1; } in
        let {
          sat_sgjQP [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp3
                      $dNum_sgjQM eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjQO [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp4
                      $dNum_sgjQM eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjQN [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp5
                      $dNum_sgjQM eta_B3 eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_sgjQN
                         sat_sgjQO
                         sat_sgjQP
                         sat_sgjQQ
                         sat_sgjQR
                         sat_sgjQS
                         sat_sgjQT];

Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Num.Num (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgjQU]
        let {
          sat_sgjQV [Occ=Once,
                     Dmd=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>]
            :: GHC.Num.Num a_Xgj9j
          [LclId] =
              [$dFractional_sgjQU] \u []
                  GHC.Real.$p1Fractional $dFractional_sgjQU;
        } in  Data.Functor.Contravariant.$fNumOp sat_sgjQV;

Data.Functor.Contravariant.$fFractionalOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U))>m] =
    [] \r [$dFractional_sgjQW]
        let {
          sat_sgjR0 [Occ=Once]
            :: GHC.Real.Rational
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgjQW] \r [eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp_$cfromRational
                      $dFractional_sgjQW eta_B1; } in
        let {
          sat_sgjQZ [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgjQW] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp1
                      $dFractional_sgjQW eta_B2 eta_B1; } in
        let {
          sat_sgjQY [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgjQW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp2
                      $dFractional_sgjQW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjQX [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m)
          [LclId] =
              [$dFractional_sgjQW] \u []
                  Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
                      $dFractional_sgjQW;
        } in 
          GHC.Real.C:Fractional [sat_sgjQX sat_sgjQY sat_sgjQZ sat_sgjR0];

Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
  :: forall a b.
     GHC.Float.Floating a =>
     GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjR1]
        let {
          sat_sgjR2 [Occ=Once,
                     Dmd=<L,U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U))>]
            :: GHC.Real.Fractional a_Xgj9H
          [LclId] =
              [$dFloating_sgjR1] \u [] GHC.Float.$p1Floating $dFloating_sgjR1;
        } in  Data.Functor.Contravariant.$fFractionalOp sat_sgjR2;

Data.Functor.Contravariant.$fFloatingOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Float.Floating a =>
     GHC.Float.Floating (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U)),1*U,C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),A,A,A,A)>] =
    [] \r [$dFloating_sgjR3]
        let {
          lvl7_sgjR4 [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dFloating_sgjR3] \u [] GHC.Float.pi $dFloating_sgjR3; } in
        let {
          sat_sgjRs [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1mexp
                      $dFloating_sgjR3 eta_B1; } in
        let {
          sat_sgjRr [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1pexp
                      $dFloating_sgjR3 eta_B1; } in
        let {
          sat_sgjRq [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$cexpm1
                      $dFloating_sgjR3 eta_B1; } in
        let {
          sat_sgjRp [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1p
                      $dFloating_sgjR3 eta_B1; } in
        let {
          sat_sgjRo [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp1
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRn [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp2
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRm [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp3
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRl [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp4
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRk [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp5
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRj [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp6
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRi [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp7
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRh [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp8
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRg [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp9
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRf [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp10
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRe [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp11
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRd [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp12
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRc [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp13
                      $dFloating_sgjR3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjRb [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp14
                      $dFloating_sgjR3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjRa [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp15
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjR9 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp16
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjR8 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp17
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjR7 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [lvl7_sgjR4] \r [eta_sgjR6] lvl7_sgjR4; } in
        let {
          sat_sgjR5 [Occ=Once]
            :: GHC.Real.Fractional
                 (Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q)
          [LclId] =
              [$dFloating_sgjR3] \u []
                  Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
                      $dFloating_sgjR3;
        } in 
          GHC.Float.C:Floating [sat_sgjR5
                                sat_sgjR7
                                sat_sgjR8
                                sat_sgjR9
                                sat_sgjRa
                                sat_sgjRb
                                sat_sgjRc
                                sat_sgjRd
                                sat_sgjRe
                                sat_sgjRf
                                sat_sgjRg
                                sat_sgjRh
                                sat_sgjRi
                                sat_sgjRj
                                sat_sgjRk
                                sat_sgjRl
                                sat_sgjRm
                                sat_sgjRn
                                sat_sgjRo
                                sat_sgjRp
                                sat_sgjRq
                                sat_sgjRr
                                sat_sgjRs];

Data.Functor.Contravariant.$fCategoryTYPEOp1
  :: forall b c a.
     Data.Functor.Contravariant.Op b c
     -> Data.Functor.Contravariant.Op a b -> c -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgjRt ds1_sgjRu eta_B1]
        GHC.Base.. ds1_sgjRu ds_sgjRt eta_B1;

Data.Functor.Contravariant.$fCategoryTYPEOp [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Category.Category Data.Functor.Contravariant.Op
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Category.C:Category! [GHC.Base.id
                                                Data.Functor.Contravariant.$fCategoryTYPEOp1];

Data.Functor.Contravariant.$fMonoidEquivalence3
  :: forall a. a -> a -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjRv ds1_sgjRw] GHC.Types.True [];

Data.Functor.Contravariant.$fSemigroupEquivalence1 [Occ=LoopBreaker]
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> [Data.Functor.Contravariant.Equivalence a]
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgjRx ds1_sgjRy]
        case ds1_sgjRy of {
          [] -> b_sgjRx;
          : c_sgjRA [Occ=Once] cs_sgjRB [Occ=Once] ->
              let {
                ds_sgjRC [Occ=OnceL, Dmd=<L,C(C1(U))>]
                  :: Data.Functor.Contravariant.Equivalence a_XgjcG
                [LclId] =
                    [c_sgjRA cs_sgjRB] \u []
                        Data.Functor.Contravariant.$fSemigroupEquivalence1
                            c_sgjRA cs_sgjRB; } in
              let {
                sat_sgjRG [Occ=Once] :: a_XgjcG -> a_XgjcG -> GHC.Types.Bool
                [LclId] =
                    [b_sgjRx ds_sgjRC] \r [a1_sgjRD b1_sgjRE]
                        case b_sgjRx a1_sgjRD b1_sgjRE of {
                          GHC.Types.False -> GHC.Types.False [];
                          GHC.Types.True -> ds_sgjRC a1_sgjRD b1_sgjRE;
                        };
              } in  sat_sgjRG;
        };

Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Functor.Contravariant.Equivalence a)
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgjRH]
        case ds_sgjRH of {
          GHC.Base.:| a1_sgjRJ [Occ=Once] as_sgjRK [Occ=Once] ->
              Data.Functor.Contravariant.$fSemigroupEquivalence1
                  a1_sgjRJ as_sgjRK;
        };

Data.Functor.Contravariant.$fMonoidEquivalence2
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjRL ds1_sgjRM a1_sgjRN b_sgjRO]
        case ds_sgjRL a1_sgjRN b_sgjRO of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> ds1_sgjRM a1_sgjRN b_sgjRO;
        };

Data.Functor.Contravariant.$fSemigroupEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Equivalence a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fMonoidEquivalence2
                                         Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
                                         Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes];
Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgjRQ]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sgjRQ Data.Functor.Contravariant.$fSemigroupEquivalence;

Data.Functor.Contravariant.$fMonoidEquivalence1 [Occ=LoopBreaker]
  :: forall a.
     [Data.Functor.Contravariant.Equivalence a]
     -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjRR eta_sgjRS eta1_sgjRT]
        case ds_sgjRR of {
          [] -> GHC.Types.True [];
          : y_sgjRV [Occ=Once] ys_sgjRW [Occ=Once] ->
              case y_sgjRV eta_sgjRS eta1_sgjRT of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Functor.Contravariant.$fMonoidEquivalence1
                        ys_sgjRW eta_sgjRS eta1_sgjRT;
              };
        };

Data.Functor.Contravariant.$fMonoidEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupEquivalence
                                      Data.Functor.Contravariant.$fMonoidEquivalence3
                                      Data.Functor.Contravariant.$fMonoidEquivalence2
                                      Data.Functor.Contravariant.$fMonoidEquivalence1];

Data.Functor.Contravariant.$fMonoidPredicate3
  :: forall a. a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjRY] GHC.Types.True [];

Data.Functor.Contravariant.$fSemigroupPredicate1 [Occ=LoopBreaker]
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> [Data.Functor.Contravariant.Predicate a]
     -> Data.Functor.Contravariant.Predicate a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgjRZ ds1_sgjS0]
        case ds1_sgjS0 of {
          [] -> b_sgjRZ;
          : c_sgjS2 [Occ=Once] cs_sgjS3 [Occ=Once] ->
              let {
                ds_sgjS4 [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Data.Functor.Contravariant.Predicate a_Xgje6
                [LclId] =
                    [c_sgjS2 cs_sgjS3] \u []
                        Data.Functor.Contravariant.$fSemigroupPredicate1
                            c_sgjS2 cs_sgjS3; } in
              let {
                sat_sgjS7 [Occ=Once] :: a_Xgje6 -> GHC.Types.Bool
                [LclId] =
                    [b_sgjRZ ds_sgjS4] \r [a1_sgjS5]
                        case b_sgjRZ a1_sgjS5 of {
                          GHC.Types.False -> GHC.Types.False [];
                          GHC.Types.True -> ds_sgjS4 a1_sgjS5;
                        };
              } in  sat_sgjS7;
        };

Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Functor.Contravariant.Predicate a)
     -> Data.Functor.Contravariant.Predicate a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgjS8]
        case ds_sgjS8 of {
          GHC.Base.:| a1_sgjSa [Occ=Once] as_sgjSb [Occ=Once] ->
              Data.Functor.Contravariant.$fSemigroupPredicate1 a1_sgjSa as_sgjSb;
        };

Data.Functor.Contravariant.$fMonoidPredicate2
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjSc ds1_sgjSd a1_sgjSe]
        case ds_sgjSc a1_sgjSe of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> ds1_sgjSd a1_sgjSe;
        };

Data.Functor.Contravariant.$fSemigroupPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Predicate a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fMonoidPredicate2
                                         Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
                                         Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes];
Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgjSg]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sgjSg Data.Functor.Contravariant.$fSemigroupPredicate;

Data.Functor.Contravariant.$fMonoidPredicate1 [Occ=LoopBreaker]
  :: forall a.
     [Data.Functor.Contravariant.Predicate a] -> a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjSh eta_sgjSi]
        case ds_sgjSh of {
          [] -> GHC.Types.True [];
          : y_sgjSk [Occ=Once] ys_sgjSl [Occ=Once] ->
              case y_sgjSk eta_sgjSi of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Functor.Contravariant.$fMonoidPredicate1 ys_sgjSl eta_sgjSi;
              };
        };

Data.Functor.Contravariant.$fMonoidPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Predicate a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupPredicate
                                      Data.Functor.Contravariant.$fMonoidPredicate3
                                      Data.Functor.Contravariant.$fMonoidPredicate2
                                      Data.Functor.Contravariant.$fMonoidPredicate1];

Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
  :: forall a b. (a -> b) -> Data.Proxy.Proxy b -> Data.Proxy.Proxy a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjSn ds1_sgjSo] Data.Proxy.Proxy [];

Data.Functor.Contravariant.$fContravariantProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant Data.Proxy.Proxy
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantProxy_$c>$];

Data.Functor.Contravariant.$fContravariantCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgjSp $dContravariant_sgjSq f1_sgjSr ds_sgjSs]
        let {
          sat_sgjSt [Occ=Once] :: g_agjbQ b_agjbX -> g_agjbQ a_agjbW
          [LclId] =
              [$dContravariant_sgjSq f1_sgjSr] \u []
                  Data.Functor.Contravariant.contramap
                      $dContravariant_sgjSq f1_sgjSr;
        } in  GHC.Base.fmap $dFunctor_sgjSp sat_sgjSt ds_sgjSs;

Data.Functor.Contravariant.$fContravariantCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgjSu $dContravariant_sgjSv]
        let {
          sat_sgjSx [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW a
          [LclId] =
              [$dFunctor_sgjSu $dContravariant_sgjSv] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantCompose1
                      $dFunctor_sgjSu $dContravariant_sgjSv eta_B2 eta_B1; } in
        let {
          sat_sgjSw [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW a
          [LclId] =
              [$dFunctor_sgjSu $dContravariant_sgjSv] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantCompose2
                      $dFunctor_sgjSu $dContravariant_sgjSv eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjSw sat_sgjSx];

Data.Functor.Contravariant.$fContravariantConst2
  :: forall a1 a2 b.
     (a2 -> b)
     -> Data.Functor.Const.Const a1 b -> Data.Functor.Const.Const a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjSy ds1_sgjSz] ds1_sgjSz;

Data.Functor.Contravariant.$fContravariantConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Const.Const a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantConst2
                                                               Data.Functor.Contravariant.$fContravariantConst1];

Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjSA
           $dContravariant1_sgjSB
           f1_sgjSC
           ds_sgjSD]
        case ds_sgjSD of {
          Data.Functor.Product.Pair a1_sgjSF [Occ=Once]
                                    b1_sgjSG [Occ=Once] ->
              let {
                sat_sgjSI [Occ=Once] :: g_agjcM a_agjcS
                [LclId] =
                    [$dContravariant1_sgjSB f1_sgjSC b1_sgjSG] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgjSB f1_sgjSC b1_sgjSG; } in
              let {
                sat_sgjSH [Occ=Once] :: f_agjcL a_agjcS
                [LclId] =
                    [$dContravariant_sgjSA f1_sgjSC a1_sgjSF] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgjSA f1_sgjSC a1_sgjSF;
              } in  Data.Functor.Product.Pair [sat_sgjSH sat_sgjSI];
        };

Data.Functor.Contravariant.$fContravariantProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgjSJ $dContravariant1_sgjSK]
        let {
          sat_sgjSM [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Product.Product f_agjcL g_agjcM b
               -> Data.Functor.Product.Product f_agjcL g_agjcM a
          [LclId] =
              [$dContravariant_sgjSJ $dContravariant1_sgjSK] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantProduct_$c>$
                      $dContravariant_sgjSJ $dContravariant1_sgjSK eta_B2 eta_B1; } in
        let {
          sat_sgjSL [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Product.Product f_agjcL g_agjcM b
               -> Data.Functor.Product.Product f_agjcL g_agjcM a
          [LclId] =
              [$dContravariant_sgjSJ $dContravariant1_sgjSK] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
                      $dContravariant_sgjSJ $dContravariant1_sgjSK eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjSL sat_sgjSM];

Data.Functor.Contravariant.$fContravariantSum_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjSN
           $dContravariant1_sgjSO
           f1_sgjSP
           ds_sgjSQ]
        case ds_sgjSQ of {
          Data.Functor.Sum.InL xs_sgjSS [Occ=Once] ->
              let {
                sat_sgjST [Occ=Once] :: f_agjdk a_agjdr
                [LclId] =
                    [$dContravariant_sgjSN f1_sgjSP xs_sgjSS] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgjSN f1_sgjSP xs_sgjSS;
              } in  Data.Functor.Sum.InL [sat_sgjST];
          Data.Functor.Sum.InR ys_sgjSU [Occ=Once] ->
              let {
                sat_sgjSV [Occ=Once] :: g_agjdl a_agjdr
                [LclId] =
                    [$dContravariant1_sgjSO f1_sgjSP ys_sgjSU] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgjSO f1_sgjSP ys_sgjSU;
              } in  Data.Functor.Sum.InR [sat_sgjSV];
        };

Data.Functor.Contravariant.$fContravariantSum_$c>$
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjSW
           $dContravariant1_sgjSX
           x_sgjSY
           eta_sgjSZ]
        let {
          sat_sgjT1 [Occ=Once] :: a_agjdP -> b_agjdO
          [LclId] =
              [x_sgjSY] \r [ds_sgjT0] x_sgjSY;
        } in 
          Data.Functor.Contravariant.$fContravariantSum_$ccontramap
              $dContravariant_sgjSW $dContravariant1_sgjSX sat_sgjT1 eta_sgjSZ;

Data.Functor.Contravariant.$fContravariantSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgjT2 $dContravariant1_sgjT3]
        let {
          sat_sgjT5 [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl a
          [LclId] =
              [$dContravariant_sgjT2 $dContravariant1_sgjT3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantSum_$c>$
                      $dContravariant_sgjT2 $dContravariant1_sgjT3 eta_B2 eta_B1; } in
        let {
          sat_sgjT4 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl a
          [LclId] =
              [$dContravariant_sgjT2 $dContravariant1_sgjT3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantSum_$ccontramap
                      $dContravariant_sgjT2 $dContravariant1_sgjT3 eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjT4 sat_sgjT5];

Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> (GHC.Generics.:+:) f g b -> (GHC.Generics.:+:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjT6
           $dContravariant1_sgjT7
           f1_sgjT8
           ds_sgjT9]
        case ds_sgjT9 of {
          GHC.Generics.L1 xs_sgjTb [Occ=Once] ->
              let {
                sat_sgjTc [Occ=Once] :: f_agjdX a_agje4
                [LclId] =
                    [$dContravariant_sgjT6 f1_sgjT8 xs_sgjTb] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgjT6 f1_sgjT8 xs_sgjTb;
              } in  GHC.Generics.L1 [sat_sgjTc];
          GHC.Generics.R1 ys_sgjTd [Occ=Once] ->
              let {
                sat_sgjTe [Occ=Once] :: g_agjdY a_agje4
                [LclId] =
                    [$dContravariant1_sgjT7 f1_sgjT8 ys_sgjTd] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgjT7 f1_sgjT8 ys_sgjTd;
              } in  GHC.Generics.R1 [sat_sgjTe];
        };

Data.Functor.Contravariant.$fContravariant:+:_$c>$
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> (GHC.Generics.:+:) f g b -> (GHC.Generics.:+:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjTf
           $dContravariant1_sgjTg
           x_sgjTh
           eta_sgjTi]
        let {
          sat_sgjTk [Occ=Once] :: a_agjes -> b_agjer
          [LclId] =
              [x_sgjTh] \r [ds_sgjTj] x_sgjTh;
        } in 
          Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
              $dContravariant_sgjTf $dContravariant1_sgjTg sat_sgjTk eta_sgjTi;

Data.Functor.Contravariant.$fContravariant:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgjTl $dContravariant1_sgjTm]
        let {
          sat_sgjTo [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY a
          [LclId] =
              [$dContravariant_sgjTl $dContravariant1_sgjTm] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:+:_$c>$
                      $dContravariant_sgjTl $dContravariant1_sgjTm eta_B2 eta_B1; } in
        let {
          sat_sgjTn [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:+:) f_agjdX g_agjdY b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY a
          [LclId] =
              [$dContravariant_sgjTl $dContravariant1_sgjTm] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
                      $dContravariant_sgjTl $dContravariant1_sgjTm eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjTn sat_sgjTo];

Data.Functor.Contravariant.$fContravariant:.:2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall a b. (a -> b) -> (GHC.Generics.:.:) f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgjTp $dContravariant_sgjTq f1_sgjTr ds_sgjTs]
        let {
          sat_sgjTt [Occ=Once] :: g_agjeB b_agjeI -> g_agjeB a_agjeH
          [LclId] =
              [$dContravariant_sgjTq f1_sgjTr] \u []
                  Data.Functor.Contravariant.contramap
                      $dContravariant_sgjTq f1_sgjTr;
        } in  GHC.Base.fmap $dFunctor_sgjTp sat_sgjTt ds_sgjTs;

Data.Functor.Contravariant.$fContravariant:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgjTu $dContravariant_sgjTv]
        let {
          sat_sgjTx [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS a
          [LclId] =
              [$dFunctor_sgjTu $dContravariant_sgjTv] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:.:1
                      $dFunctor_sgjTu $dContravariant_sgjTv eta_B2 eta_B1; } in
        let {
          sat_sgjTw [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS a
          [LclId] =
              [$dFunctor_sgjTu $dContravariant_sgjTv] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:.:2
                      $dFunctor_sgjTu $dContravariant_sgjTv eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjTw sat_sgjTx];

Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjTy
           $dContravariant1_sgjTz
           f1_sgjTA
           ds_sgjTB]
        case ds_sgjTB of {
          GHC.Generics.:*: xs_sgjTD [Occ=Once] ys_sgjTE [Occ=Once] ->
              let {
                sat_sgjTG [Occ=Once] :: g_agjfb a_agjfh
                [LclId] =
                    [$dContravariant1_sgjTz f1_sgjTA ys_sgjTE] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgjTz f1_sgjTA ys_sgjTE; } in
              let {
                sat_sgjTF [Occ=Once] :: f_agjfa a_agjfh
                [LclId] =
                    [$dContravariant_sgjTy f1_sgjTA xs_sgjTD] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgjTy f1_sgjTA xs_sgjTD;
              } in  GHC.Generics.:*: [sat_sgjTF sat_sgjTG];
        };

Data.Functor.Contravariant.$fContravariant:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgjTH $dContravariant1_sgjTI]
        let {
          sat_sgjTK [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb a
          [LclId] =
              [$dContravariant_sgjTH $dContravariant1_sgjTI] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:*:_$c>$
                      $dContravariant_sgjTH $dContravariant1_sgjTI eta_B2 eta_B1; } in
        let {
          sat_sgjTJ [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:*:) f_agjfa g_agjfb b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb a
          [LclId] =
              [$dContravariant_sgjTH $dContravariant1_sgjTI] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
                      $dContravariant_sgjTH $dContravariant1_sgjTI eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjTJ sat_sgjTK];

Data.Functor.Contravariant.$fContravariantK3
  :: forall i c a b.
     (a -> b) -> GHC.Generics.K1 i c b -> GHC.Generics.K1 i c b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjTL ds1_sgjTM] ds1_sgjTM;

Data.Functor.Contravariant.$fContravariantK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c.
     Data.Functor.Contravariant.Contravariant (GHC.Generics.K1 i c)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantK3
                                                               Data.Functor.Contravariant.$fContravariantK2];

Data.Functor.Contravariant.$fContravariantU1_$ccontramap
  :: forall a b. (a -> b) -> GHC.Generics.U1 b -> GHC.Generics.U1 a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjTN ds1_sgjTO] GHC.Generics.U1 [];

Data.Functor.Contravariant.$fContravariantU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant GHC.Generics.U1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantU1_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantU1_$c>$];

Data.Functor.Contravariant.$fContravariantV1_$ccontramap
  :: forall a b. (a -> b) -> GHC.Generics.V1 b -> GHC.Generics.V1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sgjTP x_sgjTQ] x_sgjTQ;

Data.Functor.Contravariant.$fContravariantV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant GHC.Generics.V1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantV1_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantV1_$c>$];

lvl2_rgjLt
  :: forall a b1.
     GHC.Real.Integral b1 =>
     b1 -> (a -> GHC.Types.Ordering) -> a -> GHC.Types.Ordering
[GblId, Arity=4, Str=<L,U><L,U><L,1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgjTS n_sgjTT f_sgjTU e_sgjTV]
        let {
          sat_sgjTW [Occ=Once] :: GHC.Types.Ordering
          [LclId] =
              [f_sgjTU e_sgjTV] \u [] f_sgjTU e_sgjTV;
        } in 
          GHC.Base.$fSemigroupOrdering_$cstimes
              $dIntegral_sgjTS n_sgjTT sat_sgjTW;

lvl3_rgjLu
  :: forall a.
     GHC.Base.NonEmpty (a -> GHC.Types.Ordering)
     -> a -> GHC.Types.Ordering
[GblId, Arity=1, Str=<S(LS),1*U(U,1*U)>, Unf=OtherCon []] =
    [] \r [w1_sgjTX]
        case w1_sgjTX of {
          GHC.Base.:| ww1_sgjTZ [Occ=Once] ww2_sgjU0 [Occ=Once] ->
              GHC.Base.$w$csconcat3
                  GHC.Base.$fSemigroupOrdering ww1_sgjTZ ww2_sgjU0;
        };

lvl4_rgjLv
  :: forall a.
     (a -> GHC.Types.Ordering)
     -> (a -> GHC.Types.Ordering) -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgjU1 g_sgjU2 x_sgjU3]
        case f_sgjU1 x_sgjU3 of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> g_sgjU2 x_sgjU3;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (a -> GHC.Types.Ordering)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [lvl4_rgjLv
                                         lvl3_rgjLu
                                         lvl2_rgjLt];

Data.Functor.Contravariant.$fSemigroupComparison2
  :: forall a.
     GHC.Base.NonEmpty (a -> a -> GHC.Types.Ordering)
     -> a -> a -> GHC.Types.Ordering
[GblId, Arity=1, Str=<S(LS),1*U(U,1*U)>, Unf=OtherCon []] =
    [] \r [w1_sgjU5]
        case w1_sgjU5 of {
          GHC.Base.:| ww1_sgjU7 [Occ=Once] ww2_sgjU8 [Occ=Once] ->
              GHC.Base.$w$csconcat3
                  Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
                  ww1_sgjU7
                  ww2_sgjU8;
        };

Data.Functor.Contravariant.$fSemigroupComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Comparison a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fSemigroupComparison3
                                         Data.Functor.Contravariant.$fSemigroupComparison2
                                         Data.Functor.Contravariant.$fSemigroupComparison1];

lvl5_rgjLw :: forall a. a -> GHC.Types.Ordering
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjU9] GHC.Types.EQ [];

lvl6_rgjLx
  :: forall a. [a -> GHC.Types.Ordering] -> a -> GHC.Types.Ordering
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fMonoid(->)_$cmconcat
            GHC.Base.$fMonoidOrdering eta_B2 eta_B1;

Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (a -> GHC.Types.Ordering)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
                                      lvl5_rgjLw
                                      lvl4_rgjLv
                                      lvl6_rgjLx];

Data.Functor.Contravariant.$fMonoidComparison1
  :: forall a.
     [a -> a -> GHC.Types.Ordering] -> a -> a -> GHC.Types.Ordering
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fMonoid(->)_$cmconcat
            Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)
            eta_B2
            eta_B1;

Data.Functor.Contravariant.$fMonoidComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupComparison
                                      Data.Functor.Contravariant.$fMonoidComparison3
                                      Data.Functor.Contravariant.$fMonoidComparison2
                                      Data.Functor.Contravariant.$fMonoidComparison1];

Data.Functor.Contravariant.C:Contravariant
  :: forall (f :: * -> *).
     (forall a b. (a -> b) -> f b -> f a)
     -> (forall b a. b -> f b -> f a)
     -> Data.Functor.Contravariant.Contravariant f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Functor.Contravariant.C:Contravariant [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:12:13.232089382 UTC

Data.Functor.Contravariant.contramap
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall a b. (a -> b) -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sgjLz]
        case v_sgjLz of {
          Data.Functor.Contravariant.C:Contravariant v_sgjLB [Occ=Once]
                                                     _ [Occ=Dead] ->
              v_sgjLB;
        };

Data.Functor.Contravariant.>$
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall b a. b -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sgjLD]
        case v_sgjLD of {
          Data.Functor.Contravariant.C:Contravariant _ [Occ=Dead]
                                                     v_sgjLG [Occ=Once] ->
              v_sgjLG;
        };

Data.Functor.Contravariant.$tc'Op3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Op"#;

Data.Functor.Contravariant.$tc'Op2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Op3];

Data.Functor.Contravariant.$tcOp2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Op"#;

Data.Functor.Contravariant.$tcOp1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcOp2];

Data.Functor.Contravariant.$tc'Equivalence3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Equivalence"#;

Data.Functor.Contravariant.$tc'Equivalence2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Equivalence3];

Data.Functor.Contravariant.$tcEquivalence2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Equivalence"#;

Data.Functor.Contravariant.$tcEquivalence1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcEquivalence2];

Data.Functor.Contravariant.$tc'Comparison3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Comparison"#;

Data.Functor.Contravariant.$tc'Comparison2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Comparison3];

Data.Functor.Contravariant.$tcComparison2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Comparison"#;

Data.Functor.Contravariant.$tcComparison1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcComparison2];

Data.Functor.Contravariant.$tc'Predicate3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Predicate"#;

Data.Functor.Contravariant.$tc'Predicate2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Predicate3];

Data.Functor.Contravariant.$tcPredicate2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Predicate"#;

Data.Functor.Contravariant.$tcPredicate1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcPredicate2];

Data.Functor.Contravariant.$tcContravariant3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Contravariant"#;

Data.Functor.Contravariant.$tcContravariant2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcContravariant3];

$krep_rgjLa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rgjLb :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgjLa GHC.Types.[]];

$krep2_rgjLc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep3_rgjLd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_rgjLc $krep_rgjLa];

$krep4_rgjLe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgjLc GHC.Types.[]];

$krep5_rgjLf :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgjLa $krep4_rgjLe];

$krep6_rgjLg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep7_rgjLh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep6_rgjLg];

$krep8_rgjLi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep7_rgjLh];

$krep9_rgjLj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcOrdering
                                              GHC.Types.[]];

$krep10_rgjLk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep9_rgjLj];

$krep11_rgjLl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep10_rgjLk];

$krep12_rgjLm :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Functor.Contravariant.$tcContravariant1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep12_rgjLm];

Data.Functor.Contravariant.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Contravariant"#;

Data.Functor.Contravariant.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$trModule2];

Data.Functor.Contravariant.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Contravariant.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$trModule4];

Data.Functor.Contravariant.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Contravariant.$trModule3
                                     Data.Functor.Contravariant.$trModule1];

Data.Functor.Contravariant.$tcContravariant :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1944710495430526909##
                                    15571985404928937498##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcContravariant2
                                    0#
                                    Data.Functor.Contravariant.$tcContravariant1];

Data.Functor.Contravariant.$tcPredicate :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9927645946720114643##
                                    17478425232619398566##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcPredicate1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_rgjLn :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcPredicate
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Predicate1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rgjLh $krep13_rgjLn];

Data.Functor.Contravariant.$tc'Predicate :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10560326927625189840##
                                    8988710799443424590##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Predicate2
                                    1#
                                    Data.Functor.Contravariant.$tc'Predicate1];

Data.Functor.Contravariant.$tcComparison :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8128667979445988110##
                                    9034904213662261762##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcComparison1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_rgjLo :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcComparison
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Comparison1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_rgjLl $krep14_rgjLo];

Data.Functor.Contravariant.$tc'Comparison :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11047345948274903716##
                                    12707949450550295743##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Comparison2
                                    1#
                                    Data.Functor.Contravariant.$tc'Comparison1];

Data.Functor.Contravariant.$tcEquivalence :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9646573079009549553##
                                    12303965936368510845##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcEquivalence1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep15_rgjLp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcEquivalence
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Equivalence1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_rgjLi $krep15_rgjLp];

Data.Functor.Contravariant.$tc'Equivalence :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5667737350508967909##
                                    15093804341312440267##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Equivalence2
                                    1#
                                    Data.Functor.Contravariant.$tc'Equivalence1];

Data.Functor.Contravariant.$tcOp :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13209106975460307324##
                                    7546944290236364550##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcOp1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep16_rgjLq :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcOp
                                              $krep5_rgjLf];

Data.Functor.Contravariant.$tc'Op1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rgjLd $krep16_rgjLq];

Data.Functor.Contravariant.$tc'Op :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12479862397628491530##
                                    1381176546464080972##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Op2
                                    2#
                                    Data.Functor.Contravariant.$tc'Op1];

Data.Functor.Contravariant.comparisonEquivalence1
  :: forall a.
     Data.Functor.Contravariant.Comparison a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjLH a1_sgjLI b_sgjLJ]
        case ds_sgjLH a1_sgjLI b_sgjLJ of {
          __DEFAULT -> GHC.Types.False [];
          GHC.Types.EQ -> GHC.Types.True [];
        };

Data.Functor.Contravariant.comparisonEquivalence
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Contravariant.comparisonEquivalence1
            eta_B3 eta_B2 eta_B1;

Data.Functor.Contravariant.defaultEquivalence
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Classes.== eta_B1;

Data.Functor.Contravariant.defaultComparison
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Contravariant.Comparison a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Classes.compare eta_B1;

Data.Functor.Contravariant.>$$<
  :: forall (f :: * -> *) b a.
     Data.Functor.Contravariant.Contravariant f =>
     f b -> (a -> b) -> f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjLL eta_sgjLM eta1_sgjLN]
        Data.Functor.Contravariant.contramap
            $dContravariant_sgjLL eta1_sgjLN eta_sgjLM;

Data.Functor.Contravariant.>$<
  :: forall (f :: * -> *) a b.
     Data.Functor.Contravariant.Contravariant f =>
     (a -> b) -> f b -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjLO]
        Data.Functor.Contravariant.contramap $dContravariant_sgjLO;

Data.Functor.Contravariant.phantom
  :: forall (f :: * -> *) a b.
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant f) =>
     f a -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)))><S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgjLP $dContravariant_sgjLQ x_sgjLR]
        let {
          sat_sgjLS [Occ=Once] :: f_agiQT ()
          [LclId] =
              [$dFunctor_sgjLP x_sgjLR] \u []
                  GHC.Base.<$ $dFunctor_sgjLP GHC.Tuple.() x_sgjLR;
        } in 
          Data.Functor.Contravariant.>$
              $dContravariant_sgjLQ GHC.Tuple.() sat_sgjLS;

Data.Functor.Contravariant.$<
  :: forall (f :: * -> *) b a.
     Data.Functor.Contravariant.Contravariant f =>
     f b -> b -> f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjLT eta_sgjLU eta1_sgjLV]
        Data.Functor.Contravariant.>$
            $dContravariant_sgjLT eta1_sgjLV eta_sgjLU;

Data.Functor.Contravariant.$fContravariantOp1
  :: forall a1 b a2.
     b -> Data.Functor.Contravariant.Op a1 b -> a2 -> a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgjLW eta_sgjLX eta1_sgjLY] eta_sgjLX x_sgjLW;

Data.Functor.Contravariant.$fContravariantOp2
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Functor.Contravariant.Op a1 b -> a2 -> a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f_sgjLZ g_sgjM0 eta_B1] GHC.Base.. g_sgjM0 f_sgjLZ eta_B1;

Data.Functor.Contravariant.$fContravariantOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Contravariant.Op a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantOp2
                                                               Data.Functor.Contravariant.$fContravariantOp1];

Data.Functor.Contravariant.getOp1
  :: forall a b.
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgjM1] ds_sgjM1;

Data.Functor.Contravariant.getOp
  :: forall a b. Data.Functor.Contravariant.Op a b -> b -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getOp1 eta_B1;

Data.Functor.Contravariant.$fContravariantEquivalence1
  :: forall b a.
     b
     -> Data.Functor.Contravariant.Equivalence b
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),1*C1(C1(U))><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgjM2 eta_sgjM3 eta1_sgjM4 eta2_sgjM5]
        eta_sgjM3 x_sgjM2 x_sgjM2;

Data.Functor.Contravariant.$fContravariantEquivalence2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Equivalence b
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgjM6 g_sgjM7 x_sgjM8 y_sgjM9]
        let {
          sat_sgjMb [Occ=Once] :: b_agj9q
          [LclId] =
              [f_sgjM6 y_sgjM9] \u [] f_sgjM6 y_sgjM9; } in
        let {
          sat_sgjMa [Occ=Once] :: b_agj9q
          [LclId] =
              [f_sgjM6 x_sgjM8] \u [] f_sgjM6 x_sgjM8;
        } in  g_sgjM7 sat_sgjMa sat_sgjMb;

Data.Functor.Contravariant.$fContravariantEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Equivalence
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantEquivalence2
                                                               Data.Functor.Contravariant.$fContravariantEquivalence1];

Data.Functor.Contravariant.getEquivalence1
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgjMc] ds_sgjMc;

Data.Functor.Contravariant.getEquivalence
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> a -> a -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getEquivalence1 eta_B1;

Data.Functor.Contravariant.$fContravariantComparison1
  :: forall b a.
     b
     -> Data.Functor.Contravariant.Comparison b
     -> a
     -> a
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),1*C1(C1(U))><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgjMd eta_sgjMe eta1_sgjMf eta2_sgjMg]
        eta_sgjMe x_sgjMd x_sgjMd;

Data.Functor.Contravariant.$fContravariantComparison2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Comparison b
     -> a
     -> a
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgjMh g_sgjMi x_sgjMj y_sgjMk]
        let {
          sat_sgjMm [Occ=Once] :: b_agj9P
          [LclId] =
              [f_sgjMh y_sgjMk] \u [] f_sgjMh y_sgjMk; } in
        let {
          sat_sgjMl [Occ=Once] :: b_agj9P
          [LclId] =
              [f_sgjMh x_sgjMj] \u [] f_sgjMh x_sgjMj;
        } in  g_sgjMi sat_sgjMl sat_sgjMm;

Data.Functor.Contravariant.$fContravariantComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Comparison
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantComparison2
                                                               Data.Functor.Contravariant.$fContravariantComparison1];

Data.Functor.Contravariant.getComparison1
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> Data.Functor.Contravariant.Comparison a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgjMn] ds_sgjMn;

Data.Functor.Contravariant.getComparison
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> a -> a -> GHC.Types.Ordering
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getComparison1 eta_B1;

Data.Functor.Contravariant.$fContravariantPredicate1
  :: forall b a.
     b -> Data.Functor.Contravariant.Predicate b -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgjMo eta_sgjMp eta1_sgjMq] eta_sgjMp x_sgjMo;

Data.Functor.Contravariant.$fContravariantPredicate2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Predicate b -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f_sgjMr g_sgjMs eta_B1] GHC.Base.. g_sgjMs f_sgjMr eta_B1;

Data.Functor.Contravariant.$fContravariantPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Predicate
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantPredicate2
                                                               Data.Functor.Contravariant.$fContravariantPredicate1];

Data.Functor.Contravariant.getPredicate1
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgjMt] ds_sgjMt;

Data.Functor.Contravariant.getPredicate
  :: forall a.
     Data.Functor.Contravariant.Predicate a -> a -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getPredicate1 eta_B1;

Data.Functor.Contravariant.$fContravariantV1_$c>$
  :: forall b a. b -> GHC.Generics.V1 b -> GHC.Generics.V1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [x_sgjMu x1_sgjMv] x1_sgjMv;

Data.Functor.Contravariant.$fContravariantU1_$c>$
  :: forall b a. b -> GHC.Generics.U1 b -> GHC.Generics.U1 a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sgjMx ds_sgjMy] GHC.Generics.U1 [];

Data.Functor.Contravariant.$fContravariantK2
  :: forall b c i.
     b -> GHC.Generics.K1 i c b -> GHC.Generics.K1 i c b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgjMz ds_sgjMA] ds_sgjMA;

Data.Functor.Contravariant.$fContravariant:*:_$c>$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgjMB w1_sgjMC w2_sgjMD w3_sgjME]
        case w3_sgjME of {
          GHC.Generics.:*: ww1_sgjMG [Occ=Once] ww2_sgjMH [Occ=Once] ->
              let {
                f1_sgjMI :: a_sgjEw -> b_sgjEv
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sgjMD] \r [ds_sgjMJ] w2_sgjMD; } in
              let {
                sat_sgjML [Occ=Once] :: g_sgjEs a_sgjEw
                [LclId] =
                    [w1_sgjMC ww2_sgjMH f1_sgjMI] \u []
                        Data.Functor.Contravariant.contramap
                            w1_sgjMC f1_sgjMI ww2_sgjMH; } in
              let {
                sat_sgjMK [Occ=Once] :: f_sgjEr a_sgjEw
                [LclId] =
                    [w_sgjMB ww1_sgjMG f1_sgjMI] \u []
                        Data.Functor.Contravariant.contramap w_sgjMB f1_sgjMI ww1_sgjMG;
              } in  GHC.Generics.:*: [sat_sgjMK sat_sgjML];
        };

Data.Functor.Contravariant.$fContravariant:.:1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall b a. b -> (GHC.Generics.:.:) f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgjMM $dContravariant_sgjMN x_sgjMO eta_sgjMP]
        let {
          sat_sgjMS [Occ=Once] :: g_XgjkT b_agjf1 -> g_XgjkT a_agjf2
          [LclId] =
              [$dContravariant_sgjMN x_sgjMO] \u []
                  let {
                    sat_sgjMR [Occ=Once] :: a_agjf2 -> b_agjf1
                    [LclId] =
                        [x_sgjMO] \r [ds_sgjMQ] x_sgjMO;
                  } in 
                    Data.Functor.Contravariant.contramap
                        $dContravariant_sgjMN sat_sgjMR;
        } in  GHC.Base.fmap $dFunctor_sgjMM sat_sgjMS eta_sgjMP;

Data.Functor.Contravariant.$fContravariantProduct_$c>$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgjMT w1_sgjMU w2_sgjMV w3_sgjMW]
        case w3_sgjMW of {
          Data.Functor.Product.Pair ww1_sgjMY [Occ=Once]
                                    ww2_sgjMZ [Occ=Once] ->
              let {
                f1_sgjN0 :: a_sgjEN -> b_sgjEM
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sgjMV] \r [ds_sgjN1] w2_sgjMV; } in
              let {
                sat_sgjN3 [Occ=Once] :: g_sgjEJ a_sgjEN
                [LclId] =
                    [w1_sgjMU ww2_sgjMZ f1_sgjN0] \u []
                        Data.Functor.Contravariant.contramap
                            w1_sgjMU f1_sgjN0 ww2_sgjMZ; } in
              let {
                sat_sgjN2 [Occ=Once] :: f_sgjEI a_sgjEN
                [LclId] =
                    [w_sgjMT ww1_sgjMY f1_sgjN0] \u []
                        Data.Functor.Contravariant.contramap w_sgjMT f1_sgjN0 ww1_sgjMY;
              } in  Data.Functor.Product.Pair [sat_sgjN2 sat_sgjN3];
        };

Data.Functor.Contravariant.$fContravariantConst1
  :: forall b a.
     b -> Data.Functor.Const.Const a b -> Data.Functor.Const.Const a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgjN4 ds_sgjN5] ds_sgjN5;

Data.Functor.Contravariant.$fContravariantCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall b a. b -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgjN6 $dContravariant_sgjN7 x_sgjN8 eta_sgjN9]
        let {
          sat_sgjNc [Occ=Once] :: g_XgjhX b_agjcg -> g_XgjhX a_agjch
          [LclId] =
              [$dContravariant_sgjN7 x_sgjN8] \u []
                  let {
                    sat_sgjNb [Occ=Once] :: a_agjch -> b_agjcg
                    [LclId] =
                        [x_sgjN8] \r [ds_sgjNa] x_sgjN8;
                  } in 
                    Data.Functor.Contravariant.contramap
                        $dContravariant_sgjN7 sat_sgjNb;
        } in  GHC.Base.fmap $dFunctor_sgjN6 sat_sgjNc eta_sgjN9;

Data.Functor.Contravariant.$fContravariantProxy_$c>$
  :: forall b a. b -> Data.Proxy.Proxy b -> Data.Proxy.Proxy a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sgjNd ds_sgjNe] Data.Proxy.Proxy [];

Data.Functor.Contravariant.$dm>$
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall b a. b -> f b -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjNf eta_sgjNg]
        let {
          sat_sgjNi [Occ=Once] :: a_agiRb -> b_agiRa
          [LclId] =
              [eta_sgjNg] \r [ds_sgjNh] eta_sgjNg;
        } in 
          Data.Functor.Contravariant.contramap
              $dContravariant_sgjNf sat_sgjNi;

Data.Functor.Contravariant.$fSemigroupOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sgjNj]
        let {
          sat_sgjNm [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgjNj] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$cstimes
                      $dSemigroup_sgjNj eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjNl [Occ=Once]
            :: GHC.Base.NonEmpty
                 (Data.Functor.Contravariant.Op a_agiSm b_agiSn)
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgjNj] \r [eta_B1]
                  GHC.Base.$fSemigroup(->)_$csconcat $dSemigroup_sgjNj eta_B1; } in
        let {
          sat_sgjNk [Occ=Once]
            :: Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgjNj] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$c<>
                      $dSemigroup_sgjNj eta_B3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sgjNk sat_sgjNl sat_sgjNm];

Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid
  :: forall a b.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgjNn]
        let {
          sat_sgjNo [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_XgiXu
          [LclId] =
              [$dMonoid_sgjNn] \u [] GHC.Base.$p1Monoid $dMonoid_sgjNn;
        } in  Data.Functor.Contravariant.$fSemigroupOp sat_sgjNo;

Data.Functor.Contravariant.$fMonoidOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_sgjNp]
        let {
          lvl7_sgjNq [Occ=OnceL] :: a_XgiXv
          [LclId] =
              [$dMonoid_sgjNp] \u [] GHC.Base.mempty $dMonoid_sgjNp; } in
        let {
          sat_sgjNv [Occ=Once]
            :: [Data.Functor.Contravariant.Op a_XgiXv b_XgiXx]
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [$dMonoid_sgjNp] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmconcat $dMonoid_sgjNp eta_B2 eta_B1; } in
        let {
          sat_sgjNu [Occ=Once]
            :: Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [$dMonoid_sgjNp] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmappend
                      $dMonoid_sgjNp eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjNt [Occ=Once]
            :: Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [lvl7_sgjNq] \r [ds_sgjNs] lvl7_sgjNq; } in
        let {
          sat_sgjNr [Occ=Once]
            :: GHC.Base.Semigroup
                 (Data.Functor.Contravariant.Op a_XgiXv b_XgiXx)
          [LclId] =
              [$dMonoid_sgjNp] \u []
                  Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid $dMonoid_sgjNp;
        } in  GHC.Base.C:Monoid [sat_sgjNr sat_sgjNt sat_sgjNu sat_sgjNv];

Data.Functor.Contravariant.$fMonoidComparison3
  :: forall a. a -> a -> GHC.Types.Ordering
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjNw ds1_sgjNx] GHC.Types.EQ [];

Data.Functor.Contravariant.$fMonoidComparison2
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgjNy g_sgjNz x_sgjNA]
        let {
          f1_sgjNB [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [f_sgjNy x_sgjNA] \u [] f_sgjNy x_sgjNA; } in
        let {
          g1_sgjNC [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [g_sgjNz x_sgjNA] \u [] g_sgjNz x_sgjNA; } in
        let {
          sat_sgjNF [Occ=OnceT[0]] :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [f1_sgjNB g1_sgjNC] \r [x1_sgjND]
                  case f1_sgjNB x1_sgjND of {
                    GHC.Types.LT -> GHC.Types.LT [];
                    GHC.Types.EQ -> g1_sgjNC x1_sgjND;
                    GHC.Types.GT -> GHC.Types.GT [];
                  };
        } in  sat_sgjNF;

Data.Functor.Contravariant.$fSemigroupComparison3
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgjNG g_sgjNH x_sgjNI]
        let {
          f1_sgjNJ [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [f_sgjNG x_sgjNI] \u [] f_sgjNG x_sgjNI; } in
        let {
          g1_sgjNK [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [g_sgjNH x_sgjNI] \u [] g_sgjNH x_sgjNI; } in
        let {
          sat_sgjNN [Occ=OnceT[0]] :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [f1_sgjNJ g1_sgjNK] \r [x1_sgjNL]
                  case f1_sgjNJ x1_sgjNL of {
                    GHC.Types.LT -> GHC.Types.LT [];
                    GHC.Types.EQ -> g1_sgjNK x1_sgjNL;
                    GHC.Types.GT -> GHC.Types.GT [];
                  };
        } in  sat_sgjNN;

Data.Functor.Contravariant.$fSemigroupComparison1
  :: forall a b.
     GHC.Real.Integral b =>
     b -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Str=<L,U><L,U><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sgjNO n_sgjNP f_sgjNQ e_sgjNR]
        let {
          f1_sgjNS [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiUz -> GHC.Types.Ordering
          [LclId] =
              [f_sgjNQ e_sgjNR] \u [] f_sgjNQ e_sgjNR; } in
        let {
          lvl7_sgjNT [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: b_agiVn -> GHC.Types.Ordering -> GHC.Types.Ordering
          [LclId] =
              [$dIntegral_sgjNO] \u []
                  GHC.Base.$fSemigroupOrdering_$cstimes $dIntegral_sgjNO; } in
        let {
          sat_sgjNW [Occ=OnceT[0]] :: a_agiUz -> GHC.Types.Ordering
          [LclId] =
              [n_sgjNP f1_sgjNS lvl7_sgjNT] \r [e1_sgjNU]
                  let {
                    sat_sgjNV [Occ=Once] :: GHC.Types.Ordering
                    [LclId] =
                        [f1_sgjNS e1_sgjNU] \u [] f1_sgjNS e1_sgjNU;
                  } in  lvl7_sgjNT n_sgjNP sat_sgjNV;
        } in  sat_sgjNW;

Data.Functor.Contravariant.$fContravariantM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant (GHC.Generics.M1 i c f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgjNX]
        let {
          sat_sgjNZ [Occ=Once]
            :: forall b a.
               b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r a
          [LclId] =
              [$dContravariant_sgjNX] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgjNX; } in
        let {
          sat_sgjNY [Occ=Once]
            :: forall a b.
               (a -> b)
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r a
          [LclId] =
              [$dContravariant_sgjNX] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgjNX;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjNY sat_sgjNZ];

Data.Functor.Contravariant.$fContravariantRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant (GHC.Generics.Rec1 f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgjO0]
        let {
          sat_sgjO2 [Occ=Once]
            :: forall b a.
               b -> GHC.Generics.Rec1 f_agiX0 b -> GHC.Generics.Rec1 f_agiX0 a
          [LclId] =
              [$dContravariant_sgjO0] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgjO0; } in
        let {
          sat_sgjO1 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> GHC.Generics.Rec1 f_agiX0 b -> GHC.Generics.Rec1 f_agiX0 a
          [LclId] =
              [$dContravariant_sgjO0] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgjO0;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjO1 sat_sgjO2];

Data.Functor.Contravariant.$fContravariantAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant
       (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgjO3]
        let {
          sat_sgjO5 [Occ=Once]
            :: forall b a.
               b
               -> Data.Semigroup.Internal.Alt f_agiY2 b
               -> Data.Semigroup.Internal.Alt f_agiY2 a
          [LclId] =
              [$dContravariant_sgjO3] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgjO3; } in
        let {
          sat_sgjO4 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Semigroup.Internal.Alt f_agiY2 b
               -> Data.Semigroup.Internal.Alt f_agiY2 a
          [LclId] =
              [$dContravariant_sgjO3] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgjO3;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjO4 sat_sgjO5];

sat_sgjO6 :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgjO7 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgjO6 GHC.Types.[]];

lvl_rgjLr :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgjO7;

lvl1_rgjLs :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Functor.Contravariant.$fFloatingOp_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjO8 eta_sgjO9]
        let {
          $dFractional_sgjOa [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgjO8] \s []
                  GHC.Float.$p1Floating $dFloating_sgjO8; } in
        let {
          $dNum_sgjOb [Dmd=<L,U(C(C1(U)),C(C1(U)),A,A,A,A,C(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgjOa] \u []
                  GHC.Real.$p1Fractional $dFractional_sgjOa; } in
        let {
          x_sgjOc [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgjOb] \u []
                  GHC.Num.fromInteger $dNum_sgjOb lvl1_rgjLs; } in
        let {
          x1_sgjOd [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgjOb] \u [] GHC.Num.fromInteger $dNum_sgjOb lvl_rgjLr; } in
        let {
          sat_sgjOj [Occ=Once] :: b_Xgj9Q -> a_Xgj9N
          [LclId] =
              [$dFloating_sgjO8
               eta_sgjO9
               $dNum_sgjOb
               x_sgjOc
               x1_sgjOd] \r [eta1_sgjOe]
                  let {
                    sat_sgjOi [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgjO8
                         eta_sgjO9
                         $dNum_sgjOb
                         x_sgjOc
                         x1_sgjOd
                         eta1_sgjOe] \u []
                            let {
                              sat_sgjOh [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [$dFloating_sgjO8 eta_sgjO9 $dNum_sgjOb x_sgjOc eta1_sgjOe] \u []
                                      let {
                                        sat_sgjOg [Occ=Once] :: a_Xgj9N
                                        [LclId] =
                                            [$dFloating_sgjO8 eta_sgjO9 eta1_sgjOe] \u []
                                                let {
                                                  sat_sgjOf [Occ=Once] :: a_Xgj9N
                                                  [LclId] =
                                                      [eta_sgjO9 eta1_sgjOe] \u []
                                                          eta_sgjO9 eta1_sgjOe;
                                                } in  GHC.Float.exp $dFloating_sgjO8 sat_sgjOf;
                                      } in  GHC.Num.- $dNum_sgjOb x_sgjOc sat_sgjOg;
                            } in  GHC.Num.+ $dNum_sgjOb x1_sgjOd sat_sgjOh;
                  } in  GHC.Float.log $dFloating_sgjO8 sat_sgjOi;
        } in  sat_sgjOj;

Data.Functor.Contravariant.$fFloatingOp_$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(A,C(C1(U)),A,A,A,A,1*C1(U)),A,A,A),A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOk eta_sgjOl]
        let {
          $dFractional_sgjOm [Occ=OnceL,
                              Dmd=<L,1*U(1*U(A,C(C1(U)),A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgjOk] \s []
                  GHC.Float.$p1Floating $dFloating_sgjOk; } in
        let {
          $dNum_sgjOn [Dmd=<L,U(A,C(C1(U)),A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgjOm] \u []
                  GHC.Real.$p1Fractional $dFractional_sgjOm; } in
        let {
          x_sgjOo [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgjOn] \u [] GHC.Num.fromInteger $dNum_sgjOn lvl_rgjLr; } in
        let {
          sat_sgjOs [Occ=Once] :: b_Xgj4c -> a_Xgj9N
          [LclId] =
              [$dFloating_sgjOk eta_sgjOl $dNum_sgjOn x_sgjOo] \r [a1_sgjOp]
                  let {
                    sat_sgjOr [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgjOk eta_sgjOl a1_sgjOp] \u []
                            let {
                              sat_sgjOq [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [eta_sgjOl a1_sgjOp] \u [] eta_sgjOl a1_sgjOp;
                            } in  GHC.Float.exp $dFloating_sgjOk sat_sgjOq;
                  } in  GHC.Num.- $dNum_sgjOn sat_sgjOr x_sgjOo;
        } in  sat_sgjOs;

Data.Functor.Contravariant.$fFloatingOp_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOt eta_sgjOu]
        let {
          $dFractional_sgjOv [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgjOt] \s []
                  GHC.Float.$p1Floating $dFloating_sgjOt; } in
        let {
          $dNum_sgjOw [Dmd=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgjOv] \u []
                  GHC.Real.$p1Fractional $dFractional_sgjOv; } in
        let {
          x_sgjOx [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgjOw] \u [] GHC.Num.fromInteger $dNum_sgjOw lvl_rgjLr; } in
        let {
          sat_sgjOC [Occ=Once] :: b_Xgj9Q -> a_Xgj9N
          [LclId] =
              [$dFloating_sgjOt eta_sgjOu $dNum_sgjOw x_sgjOx] \r [eta1_sgjOy]
                  let {
                    sat_sgjOB [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgjOt eta_sgjOu $dNum_sgjOw x_sgjOx eta1_sgjOy] \u []
                            let {
                              sat_sgjOA [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [$dFloating_sgjOt eta_sgjOu eta1_sgjOy] \u []
                                      let {
                                        sat_sgjOz [Occ=Once] :: a_Xgj9N
                                        [LclId] =
                                            [eta_sgjOu eta1_sgjOy] \u [] eta_sgjOu eta1_sgjOy;
                                      } in  GHC.Float.exp $dFloating_sgjOt sat_sgjOz;
                            } in  GHC.Num.+ $dNum_sgjOw x_sgjOx sat_sgjOA;
                  } in  GHC.Float.log $dFloating_sgjOt sat_sgjOB;
        } in  sat_sgjOC;

Data.Functor.Contravariant.$fFloatingOp_$clog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOD eta_sgjOE]
        let {
          $dFractional_sgjOF [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj4c
          [LclId] =
              [$dFloating_sgjOD] \s []
                  GHC.Float.$p1Floating $dFloating_sgjOD; } in
        let {
          $dNum_sgjOG [Dmd=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj4c
          [LclId] =
              [$dFractional_sgjOF] \u []
                  GHC.Real.$p1Fractional $dFractional_sgjOF; } in
        let {
          x_sgjOH [Occ=OnceL] :: a_Xgj4c
          [LclId] =
              [$dNum_sgjOG] \u [] GHC.Num.fromInteger $dNum_sgjOG lvl_rgjLr; } in
        let {
          sat_sgjOL [Occ=Once] :: b_Xgj4e -> a_Xgj4c
          [LclId] =
              [$dFloating_sgjOD eta_sgjOE $dNum_sgjOG x_sgjOH] \r [eta1_sgjOI]
                  let {
                    sat_sgjOK [Occ=Once] :: a_Xgj4c
                    [LclId] =
                        [eta_sgjOE $dNum_sgjOG x_sgjOH eta1_sgjOI] \u []
                            let {
                              sat_sgjOJ [Occ=Once] :: a_Xgj4c
                              [LclId] =
                                  [eta_sgjOE eta1_sgjOI] \u [] eta_sgjOE eta1_sgjOI;
                            } in  GHC.Num.+ $dNum_sgjOG x_sgjOH sat_sgjOJ;
                  } in  GHC.Float.log $dFloating_sgjOD sat_sgjOK;
        } in  sat_sgjOL;

Data.Functor.Contravariant.$fFloatingOp17
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLLLLLLLLLLLLLLLLLLL),1*U(A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOM ds_sgjON eta_sgjOO]
        let {
          sat_sgjOP [Occ=Once] :: a_XgjeT
          [LclId] =
              [ds_sgjON eta_sgjOO] \u [] ds_sgjON eta_sgjOO;
        } in  GHC.Float.exp $dFloating_sgjOM sat_sgjOP;

Data.Functor.Contravariant.$fFloatingOp16
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LLLLLLLLLLLLLLLLLLL),1*U(A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOQ ds_sgjOR eta_sgjOS]
        let {
          sat_sgjOT [Occ=Once] :: a_Xgj44
          [LclId] =
              [ds_sgjOR eta_sgjOS] \u [] ds_sgjOR eta_sgjOS;
        } in  GHC.Float.log $dFloating_sgjOQ sat_sgjOT;

Data.Functor.Contravariant.$fFloatingOp15
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)LLLLLLLLLLLLLLLLLL),1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOU ds_sgjOV eta_sgjOW]
        let {
          sat_sgjOX [Occ=Once] :: a_Xgj9g
          [LclId] =
              [ds_sgjOV eta_sgjOW] \u [] ds_sgjOV eta_sgjOW;
        } in  GHC.Float.sqrt $dFloating_sgjOU sat_sgjOX;

Data.Functor.Contravariant.$fFloatingOp14
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjOY ds_sgjOZ ds1_sgjP0 a1_sgjP1]
        let {
          sat_sgjP3 [Occ=Once] :: a_Xgj3W
          [LclId] =
              [ds1_sgjP0 a1_sgjP1] \u [] ds1_sgjP0 a1_sgjP1; } in
        let {
          sat_sgjP2 [Occ=Once] :: a_Xgj3W
          [LclId] =
              [ds_sgjOZ a1_sgjP1] \u [] ds_sgjOZ a1_sgjP1;
        } in  GHC.Float.** $dFloating_sgjOY sat_sgjP2 sat_sgjP3;

Data.Functor.Contravariant.$fFloatingOp13
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjP4 ds_sgjP5 ds1_sgjP6 a1_sgjP7]
        let {
          sat_sgjP9 [Occ=Once] :: a_Xgj4f
          [LclId] =
              [ds1_sgjP6 a1_sgjP7] \u [] ds1_sgjP6 a1_sgjP7; } in
        let {
          sat_sgjP8 [Occ=Once] :: a_Xgj4f
          [LclId] =
              [ds_sgjP5 a1_sgjP7] \u [] ds_sgjP5 a1_sgjP7;
        } in  GHC.Float.logBase $dFloating_sgjP4 sat_sgjP8 sat_sgjP9;

Data.Functor.Contravariant.$fFloatingOp12
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPa ds_sgjPb eta_sgjPc]
        let {
          sat_sgjPd [Occ=Once] :: a_Xgj49
          [LclId] =
              [ds_sgjPb eta_sgjPc] \u [] ds_sgjPb eta_sgjPc;
        } in  GHC.Float.sin $dFloating_sgjPa sat_sgjPd;

Data.Functor.Contravariant.$fFloatingOp11
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPe ds_sgjPf eta_sgjPg]
        let {
          sat_sgjPh [Occ=Once] :: a_Xgj43
          [LclId] =
              [ds_sgjPf eta_sgjPg] \u [] ds_sgjPf eta_sgjPg;
        } in  GHC.Float.cos $dFloating_sgjPe sat_sgjPh;

Data.Functor.Contravariant.$fFloatingOp10
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(S)LLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPi ds_sgjPj eta_sgjPk]
        let {
          sat_sgjPl [Occ=Once] :: a_Xgj3X
          [LclId] =
              [ds_sgjPj eta_sgjPk] \u [] ds_sgjPj eta_sgjPk;
        } in  GHC.Float.tan $dFloating_sgjPi sat_sgjPl;

Data.Functor.Contravariant.$fFloatingOp9
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLC(S)LLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPm ds_sgjPn eta_sgjPo]
        let {
          sat_sgjPp [Occ=Once] :: a_Xgj3R
          [LclId] =
              [ds_sgjPn eta_sgjPo] \u [] ds_sgjPn eta_sgjPo;
        } in  GHC.Float.asin $dFloating_sgjPm sat_sgjPp;

Data.Functor.Contravariant.$fFloatingOp8
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLC(S)LLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPq ds_sgjPr eta_sgjPs]
        let {
          sat_sgjPt [Occ=Once] :: a_Xgj3L
          [LclId] =
              [ds_sgjPr eta_sgjPs] \u [] ds_sgjPr eta_sgjPs;
        } in  GHC.Float.acos $dFloating_sgjPq sat_sgjPt;

Data.Functor.Contravariant.$fFloatingOp7
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLC(S)LLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPu ds_sgjPv eta_sgjPw]
        let {
          sat_sgjPx [Occ=Once] :: a_Xgj3F
          [LclId] =
              [ds_sgjPv eta_sgjPw] \u [] ds_sgjPv eta_sgjPw;
        } in  GHC.Float.atan $dFloating_sgjPu sat_sgjPx;

Data.Functor.Contravariant.$fFloatingOp6
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLC(S)LLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPy ds_sgjPz eta_sgjPA]
        let {
          sat_sgjPB [Occ=Once] :: a_Xgj3z
          [LclId] =
              [ds_sgjPz eta_sgjPA] \u [] ds_sgjPz eta_sgjPA;
        } in  GHC.Float.sinh $dFloating_sgjPy sat_sgjPB;

Data.Functor.Contravariant.$fFloatingOp5
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPC ds_sgjPD eta_sgjPE]
        let {
          sat_sgjPF [Occ=Once] :: a_Xgj3t
          [LclId] =
              [ds_sgjPD eta_sgjPE] \u [] ds_sgjPD eta_sgjPE;
        } in  GHC.Float.cosh $dFloating_sgjPC sat_sgjPF;

Data.Functor.Contravariant.$fFloatingOp4
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPG ds_sgjPH eta_sgjPI]
        let {
          sat_sgjPJ [Occ=Once] :: a_Xgj3n
          [LclId] =
              [ds_sgjPH eta_sgjPI] \u [] ds_sgjPH eta_sgjPI;
        } in  GHC.Float.tanh $dFloating_sgjPG sat_sgjPJ;

Data.Functor.Contravariant.$fFloatingOp3
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLC(S)LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPK ds_sgjPL eta_sgjPM]
        let {
          sat_sgjPN [Occ=Once] :: a_Xgj3h
          [LclId] =
              [ds_sgjPL eta_sgjPM] \u [] ds_sgjPL eta_sgjPM;
        } in  GHC.Float.asinh $dFloating_sgjPK sat_sgjPN;

Data.Functor.Contravariant.$fFloatingOp2
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLC(S)LLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPO ds_sgjPP eta_sgjPQ]
        let {
          sat_sgjPR [Occ=Once] :: a_Xgj3b
          [LclId] =
              [ds_sgjPP eta_sgjPQ] \u [] ds_sgjPP eta_sgjPQ;
        } in  GHC.Float.acosh $dFloating_sgjPO sat_sgjPR;

Data.Functor.Contravariant.$fFloatingOp1
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLC(S)LLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjPS ds_sgjPT eta_sgjPU]
        let {
          sat_sgjPV [Occ=Once] :: a_agiZ4
          [LclId] =
              [ds_sgjPT eta_sgjPU] \u [] ds_sgjPT eta_sgjPU;
        } in  GHC.Float.atanh $dFloating_sgjPS sat_sgjPV;

Data.Functor.Contravariant.$fFractionalOp2
  :: forall a b.
     GHC.Real.Fractional a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LL),1*U(A,1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgjPW ds_sgjPX ds1_sgjPY a1_sgjPZ]
        let {
          sat_sgjQ1 [Occ=Once] :: a_Xgj8K
          [LclId] =
              [ds1_sgjPY a1_sgjPZ] \u [] ds1_sgjPY a1_sgjPZ; } in
        let {
          sat_sgjQ0 [Occ=Once] :: a_Xgj8K
          [LclId] =
              [ds_sgjPX a1_sgjPZ] \u [] ds_sgjPX a1_sgjPZ;
        } in  GHC.Real./ $dFractional_sgjPW sat_sgjQ0 sat_sgjQ1;

Data.Functor.Contravariant.$fFractionalOp1
  :: forall a b.
     GHC.Real.Fractional a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)L),1*U(A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgjQ2 ds_sgjQ3 eta_sgjQ4]
        let {
          sat_sgjQ5 [Occ=Once] :: a_agj4M
          [LclId] =
              [ds_sgjQ3 eta_sgjQ4] \u [] ds_sgjQ3 eta_sgjQ4;
        } in  GHC.Real.recip $dFractional_sgjQ2 sat_sgjQ5;

Data.Functor.Contravariant.$fFractionalOp_$cfromRational
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Real.Rational -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgjQ6 eta_sgjQ7]
        let {
          x_sgjQ8 [Occ=OnceL] :: a_agj4M
          [LclId] =
              [$dFractional_sgjQ6 eta_sgjQ7] \u []
                  GHC.Real.fromRational $dFractional_sgjQ6 eta_sgjQ7; } in
        let {
          sat_sgjQa [Occ=Once] :: b_agj4N -> a_agj4M
          [LclId] =
              [x_sgjQ8] \r [ds_sgjQ9] x_sgjQ8;
        } in  sat_sgjQa;

Data.Functor.Contravariant.$fNumOp_$cnegate [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(U)),A,A,A,A,1*C1(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQb eta_sgjQc]
        let {
          x_sgjQd [Occ=OnceL] :: a_Xgjab
          [LclId] =
              [$dNum_sgjQb] \u []
                  GHC.Num.fromInteger $dNum_sgjQb lvl1_rgjLs; } in
        let {
          sat_sgjQg [Occ=Once] :: b_Xgjad -> a_Xgjab
          [LclId] =
              [$dNum_sgjQb eta_sgjQc x_sgjQd] \r [a1_sgjQe]
                  let {
                    sat_sgjQf [Occ=Once] :: a_Xgjab
                    [LclId] =
                        [eta_sgjQc a1_sgjQe] \u [] eta_sgjQc a1_sgjQe;
                  } in  GHC.Num.- $dNum_sgjQb x_sgjQd sat_sgjQf;
        } in  sat_sgjQg;

Data.Functor.Contravariant.$fNumOp5
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQh ds_sgjQi ds1_sgjQj a1_sgjQk]
        let {
          sat_sgjQm [Occ=Once] :: a_Xgja3
          [LclId] =
              [ds1_sgjQj a1_sgjQk] \u [] ds1_sgjQj a1_sgjQk; } in
        let {
          sat_sgjQl [Occ=Once] :: a_Xgja3
          [LclId] =
              [ds_sgjQi a1_sgjQk] \u [] ds_sgjQi a1_sgjQk;
        } in  GHC.Num.+ $dNum_sgjQh sat_sgjQl sat_sgjQm;

Data.Functor.Contravariant.$fNumOp4
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQn ds_sgjQo ds1_sgjQp a1_sgjQq]
        let {
          sat_sgjQs [Occ=Once] :: a_Xgj9W
          [LclId] =
              [ds1_sgjQp a1_sgjQq] \u [] ds1_sgjQp a1_sgjQq; } in
        let {
          sat_sgjQr [Occ=Once] :: a_Xgj9W
          [LclId] =
              [ds_sgjQo a1_sgjQq] \u [] ds_sgjQo a1_sgjQq;
        } in  GHC.Num.- $dNum_sgjQn sat_sgjQr sat_sgjQs;

Data.Functor.Contravariant.$fNumOp3
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQt ds_sgjQu ds1_sgjQv a1_sgjQw]
        let {
          sat_sgjQy [Occ=Once] :: a_Xgj9A
          [LclId] =
              [ds1_sgjQv a1_sgjQw] \u [] ds1_sgjQv a1_sgjQw; } in
        let {
          sat_sgjQx [Occ=Once] :: a_Xgj9A
          [LclId] =
              [ds_sgjQu a1_sgjQw] \u [] ds_sgjQu a1_sgjQw;
        } in  GHC.Num.* $dNum_sgjQt sat_sgjQx sat_sgjQy;

Data.Functor.Contravariant.$fNumOp2
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)LL),1*U(A,A,A,A,1*C1(U),A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQz ds_sgjQA eta_sgjQB]
        let {
          sat_sgjQC [Occ=Once] :: a_Xgj9u
          [LclId] =
              [ds_sgjQA eta_sgjQB] \u [] ds_sgjQA eta_sgjQB;
        } in  GHC.Num.abs $dNum_sgjQz sat_sgjQC;

Data.Functor.Contravariant.$fNumOp1
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(S)L),1*U(A,A,A,A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQD ds_sgjQE eta_sgjQF]
        let {
          sat_sgjQG [Occ=Once] :: a_agj5O
          [LclId] =
              [ds_sgjQE eta_sgjQF] \u [] ds_sgjQE eta_sgjQF;
        } in  GHC.Num.signum $dNum_sgjQD sat_sgjQG;

Data.Functor.Contravariant.$fNumOp_$cfromInteger
  :: forall a b.
     GHC.Num.Num a =>
     GHC.Integer.Type.Integer -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgjQH eta_sgjQI]
        let {
          x_sgjQJ [Occ=OnceL] :: a_agj5O
          [LclId] =
              [$dNum_sgjQH eta_sgjQI] \u []
                  GHC.Num.fromInteger $dNum_sgjQH eta_sgjQI; } in
        let {
          sat_sgjQL [Occ=Once] :: b_agj5P -> a_agj5O
          [LclId] =
              [x_sgjQJ] \r [ds_sgjQK] x_sgjQJ;
        } in  sat_sgjQL;

Data.Functor.Contravariant.$fNumOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>m] =
    [] \r [$dNum_sgjQM]
        let {
          sat_sgjQT [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B1]
                  Data.Functor.Contravariant.$fNumOp_$cfromInteger
                      $dNum_sgjQM eta_B1; } in
        let {
          sat_sgjQS [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp1 $dNum_sgjQM eta_B2 eta_B1; } in
        let {
          sat_sgjQR [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp2 $dNum_sgjQM eta_B2 eta_B1; } in
        let {
          sat_sgjQQ [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B1]
                  Data.Functor.Contravariant.$fNumOp_$cnegate
                      $dNum_sgjQM eta_B1; } in
        let {
          sat_sgjQP [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp3
                      $dNum_sgjQM eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjQO [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp4
                      $dNum_sgjQM eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjQN [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgjQM] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp5
                      $dNum_sgjQM eta_B3 eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_sgjQN
                         sat_sgjQO
                         sat_sgjQP
                         sat_sgjQQ
                         sat_sgjQR
                         sat_sgjQS
                         sat_sgjQT];

Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Num.Num (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgjQU]
        let {
          sat_sgjQV [Occ=Once,
                     Dmd=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>]
            :: GHC.Num.Num a_Xgj9j
          [LclId] =
              [$dFractional_sgjQU] \u []
                  GHC.Real.$p1Fractional $dFractional_sgjQU;
        } in  Data.Functor.Contravariant.$fNumOp sat_sgjQV;

Data.Functor.Contravariant.$fFractionalOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U))>m] =
    [] \r [$dFractional_sgjQW]
        let {
          sat_sgjR0 [Occ=Once]
            :: GHC.Real.Rational
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgjQW] \r [eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp_$cfromRational
                      $dFractional_sgjQW eta_B1; } in
        let {
          sat_sgjQZ [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgjQW] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp1
                      $dFractional_sgjQW eta_B2 eta_B1; } in
        let {
          sat_sgjQY [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgjQW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp2
                      $dFractional_sgjQW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjQX [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m)
          [LclId] =
              [$dFractional_sgjQW] \u []
                  Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
                      $dFractional_sgjQW;
        } in 
          GHC.Real.C:Fractional [sat_sgjQX sat_sgjQY sat_sgjQZ sat_sgjR0];

Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
  :: forall a b.
     GHC.Float.Floating a =>
     GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgjR1]
        let {
          sat_sgjR2 [Occ=Once,
                     Dmd=<L,U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U))>]
            :: GHC.Real.Fractional a_Xgj9H
          [LclId] =
              [$dFloating_sgjR1] \u [] GHC.Float.$p1Floating $dFloating_sgjR1;
        } in  Data.Functor.Contravariant.$fFractionalOp sat_sgjR2;

Data.Functor.Contravariant.$fFloatingOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Float.Floating a =>
     GHC.Float.Floating (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U)),1*U,C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),A,A,A,A)>] =
    [] \r [$dFloating_sgjR3]
        let {
          lvl7_sgjR4 [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dFloating_sgjR3] \u [] GHC.Float.pi $dFloating_sgjR3; } in
        let {
          sat_sgjRs [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1mexp
                      $dFloating_sgjR3 eta_B1; } in
        let {
          sat_sgjRr [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1pexp
                      $dFloating_sgjR3 eta_B1; } in
        let {
          sat_sgjRq [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$cexpm1
                      $dFloating_sgjR3 eta_B1; } in
        let {
          sat_sgjRp [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1p
                      $dFloating_sgjR3 eta_B1; } in
        let {
          sat_sgjRo [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp1
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRn [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp2
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRm [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp3
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRl [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp4
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRk [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp5
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRj [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp6
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRi [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp7
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRh [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp8
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRg [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp9
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRf [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp10
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRe [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp11
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRd [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp12
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjRc [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp13
                      $dFloating_sgjR3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjRb [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp14
                      $dFloating_sgjR3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgjRa [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp15
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjR9 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp16
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjR8 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgjR3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp17
                      $dFloating_sgjR3 eta_B2 eta_B1; } in
        let {
          sat_sgjR7 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [lvl7_sgjR4] \r [eta_sgjR6] lvl7_sgjR4; } in
        let {
          sat_sgjR5 [Occ=Once]
            :: GHC.Real.Fractional
                 (Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q)
          [LclId] =
              [$dFloating_sgjR3] \u []
                  Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
                      $dFloating_sgjR3;
        } in 
          GHC.Float.C:Floating [sat_sgjR5
                                sat_sgjR7
                                sat_sgjR8
                                sat_sgjR9
                                sat_sgjRa
                                sat_sgjRb
                                sat_sgjRc
                                sat_sgjRd
                                sat_sgjRe
                                sat_sgjRf
                                sat_sgjRg
                                sat_sgjRh
                                sat_sgjRi
                                sat_sgjRj
                                sat_sgjRk
                                sat_sgjRl
                                sat_sgjRm
                                sat_sgjRn
                                sat_sgjRo
                                sat_sgjRp
                                sat_sgjRq
                                sat_sgjRr
                                sat_sgjRs];

Data.Functor.Contravariant.$fCategoryTYPEOp1
  :: forall b c a.
     Data.Functor.Contravariant.Op b c
     -> Data.Functor.Contravariant.Op a b -> c -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgjRt ds1_sgjRu eta_B1]
        GHC.Base.. ds1_sgjRu ds_sgjRt eta_B1;

Data.Functor.Contravariant.$fCategoryTYPEOp [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Category.Category Data.Functor.Contravariant.Op
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Category.C:Category! [GHC.Base.id
                                                Data.Functor.Contravariant.$fCategoryTYPEOp1];

Data.Functor.Contravariant.$fMonoidEquivalence3
  :: forall a. a -> a -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjRv ds1_sgjRw] GHC.Types.True [];

Data.Functor.Contravariant.$fSemigroupEquivalence1 [Occ=LoopBreaker]
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> [Data.Functor.Contravariant.Equivalence a]
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgjRx ds1_sgjRy]
        case ds1_sgjRy of {
          [] -> b_sgjRx;
          : c_sgjRA [Occ=Once] cs_sgjRB [Occ=Once] ->
              let {
                ds_sgjRC [Occ=OnceL, Dmd=<L,C(C1(U))>]
                  :: Data.Functor.Contravariant.Equivalence a_XgjcG
                [LclId] =
                    [c_sgjRA cs_sgjRB] \u []
                        Data.Functor.Contravariant.$fSemigroupEquivalence1
                            c_sgjRA cs_sgjRB; } in
              let {
                sat_sgjRG [Occ=Once] :: a_XgjcG -> a_XgjcG -> GHC.Types.Bool
                [LclId] =
                    [b_sgjRx ds_sgjRC] \r [a1_sgjRD b1_sgjRE]
                        case b_sgjRx a1_sgjRD b1_sgjRE of {
                          GHC.Types.False -> GHC.Types.False [];
                          GHC.Types.True -> ds_sgjRC a1_sgjRD b1_sgjRE;
                        };
              } in  sat_sgjRG;
        };

Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Functor.Contravariant.Equivalence a)
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgjRH]
        case ds_sgjRH of {
          GHC.Base.:| a1_sgjRJ [Occ=Once] as_sgjRK [Occ=Once] ->
              Data.Functor.Contravariant.$fSemigroupEquivalence1
                  a1_sgjRJ as_sgjRK;
        };

Data.Functor.Contravariant.$fMonoidEquivalence2
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjRL ds1_sgjRM a1_sgjRN b_sgjRO]
        case ds_sgjRL a1_sgjRN b_sgjRO of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> ds1_sgjRM a1_sgjRN b_sgjRO;
        };

Data.Functor.Contravariant.$fSemigroupEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Equivalence a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fMonoidEquivalence2
                                         Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
                                         Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes];
Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgjRQ]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sgjRQ Data.Functor.Contravariant.$fSemigroupEquivalence;

Data.Functor.Contravariant.$fMonoidEquivalence1 [Occ=LoopBreaker]
  :: forall a.
     [Data.Functor.Contravariant.Equivalence a]
     -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjRR eta_sgjRS eta1_sgjRT]
        case ds_sgjRR of {
          [] -> GHC.Types.True [];
          : y_sgjRV [Occ=Once] ys_sgjRW [Occ=Once] ->
              case y_sgjRV eta_sgjRS eta1_sgjRT of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Functor.Contravariant.$fMonoidEquivalence1
                        ys_sgjRW eta_sgjRS eta1_sgjRT;
              };
        };

Data.Functor.Contravariant.$fMonoidEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupEquivalence
                                      Data.Functor.Contravariant.$fMonoidEquivalence3
                                      Data.Functor.Contravariant.$fMonoidEquivalence2
                                      Data.Functor.Contravariant.$fMonoidEquivalence1];

Data.Functor.Contravariant.$fMonoidPredicate3
  :: forall a. a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjRY] GHC.Types.True [];

Data.Functor.Contravariant.$fSemigroupPredicate1 [Occ=LoopBreaker]
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> [Data.Functor.Contravariant.Predicate a]
     -> Data.Functor.Contravariant.Predicate a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgjRZ ds1_sgjS0]
        case ds1_sgjS0 of {
          [] -> b_sgjRZ;
          : c_sgjS2 [Occ=Once] cs_sgjS3 [Occ=Once] ->
              let {
                ds_sgjS4 [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Data.Functor.Contravariant.Predicate a_Xgje6
                [LclId] =
                    [c_sgjS2 cs_sgjS3] \u []
                        Data.Functor.Contravariant.$fSemigroupPredicate1
                            c_sgjS2 cs_sgjS3; } in
              let {
                sat_sgjS7 [Occ=Once] :: a_Xgje6 -> GHC.Types.Bool
                [LclId] =
                    [b_sgjRZ ds_sgjS4] \r [a1_sgjS5]
                        case b_sgjRZ a1_sgjS5 of {
                          GHC.Types.False -> GHC.Types.False [];
                          GHC.Types.True -> ds_sgjS4 a1_sgjS5;
                        };
              } in  sat_sgjS7;
        };

Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Functor.Contravariant.Predicate a)
     -> Data.Functor.Contravariant.Predicate a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgjS8]
        case ds_sgjS8 of {
          GHC.Base.:| a1_sgjSa [Occ=Once] as_sgjSb [Occ=Once] ->
              Data.Functor.Contravariant.$fSemigroupPredicate1 a1_sgjSa as_sgjSb;
        };

Data.Functor.Contravariant.$fMonoidPredicate2
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjSc ds1_sgjSd a1_sgjSe]
        case ds_sgjSc a1_sgjSe of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> ds1_sgjSd a1_sgjSe;
        };

Data.Functor.Contravariant.$fSemigroupPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Predicate a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fMonoidPredicate2
                                         Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
                                         Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes];
Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgjSg]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sgjSg Data.Functor.Contravariant.$fSemigroupPredicate;

Data.Functor.Contravariant.$fMonoidPredicate1 [Occ=LoopBreaker]
  :: forall a.
     [Data.Functor.Contravariant.Predicate a] -> a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjSh eta_sgjSi]
        case ds_sgjSh of {
          [] -> GHC.Types.True [];
          : y_sgjSk [Occ=Once] ys_sgjSl [Occ=Once] ->
              case y_sgjSk eta_sgjSi of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Functor.Contravariant.$fMonoidPredicate1 ys_sgjSl eta_sgjSi;
              };
        };

Data.Functor.Contravariant.$fMonoidPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Predicate a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupPredicate
                                      Data.Functor.Contravariant.$fMonoidPredicate3
                                      Data.Functor.Contravariant.$fMonoidPredicate2
                                      Data.Functor.Contravariant.$fMonoidPredicate1];

Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
  :: forall a b. (a -> b) -> Data.Proxy.Proxy b -> Data.Proxy.Proxy a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjSn ds1_sgjSo] Data.Proxy.Proxy [];

Data.Functor.Contravariant.$fContravariantProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant Data.Proxy.Proxy
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantProxy_$c>$];

Data.Functor.Contravariant.$fContravariantCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgjSp $dContravariant_sgjSq f1_sgjSr ds_sgjSs]
        let {
          sat_sgjSt [Occ=Once] :: g_agjbQ b_agjbX -> g_agjbQ a_agjbW
          [LclId] =
              [$dContravariant_sgjSq f1_sgjSr] \u []
                  Data.Functor.Contravariant.contramap
                      $dContravariant_sgjSq f1_sgjSr;
        } in  GHC.Base.fmap $dFunctor_sgjSp sat_sgjSt ds_sgjSs;

Data.Functor.Contravariant.$fContravariantCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgjSu $dContravariant_sgjSv]
        let {
          sat_sgjSx [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW a
          [LclId] =
              [$dFunctor_sgjSu $dContravariant_sgjSv] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantCompose1
                      $dFunctor_sgjSu $dContravariant_sgjSv eta_B2 eta_B1; } in
        let {
          sat_sgjSw [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW a
          [LclId] =
              [$dFunctor_sgjSu $dContravariant_sgjSv] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantCompose2
                      $dFunctor_sgjSu $dContravariant_sgjSv eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjSw sat_sgjSx];

Data.Functor.Contravariant.$fContravariantConst2
  :: forall a1 a2 b.
     (a2 -> b)
     -> Data.Functor.Const.Const a1 b -> Data.Functor.Const.Const a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjSy ds1_sgjSz] ds1_sgjSz;

Data.Functor.Contravariant.$fContravariantConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Const.Const a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantConst2
                                                               Data.Functor.Contravariant.$fContravariantConst1];

Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjSA
           $dContravariant1_sgjSB
           f1_sgjSC
           ds_sgjSD]
        case ds_sgjSD of {
          Data.Functor.Product.Pair a1_sgjSF [Occ=Once]
                                    b1_sgjSG [Occ=Once] ->
              let {
                sat_sgjSI [Occ=Once] :: g_agjcM a_agjcS
                [LclId] =
                    [$dContravariant1_sgjSB f1_sgjSC b1_sgjSG] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgjSB f1_sgjSC b1_sgjSG; } in
              let {
                sat_sgjSH [Occ=Once] :: f_agjcL a_agjcS
                [LclId] =
                    [$dContravariant_sgjSA f1_sgjSC a1_sgjSF] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgjSA f1_sgjSC a1_sgjSF;
              } in  Data.Functor.Product.Pair [sat_sgjSH sat_sgjSI];
        };

Data.Functor.Contravariant.$fContravariantProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgjSJ $dContravariant1_sgjSK]
        let {
          sat_sgjSM [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Product.Product f_agjcL g_agjcM b
               -> Data.Functor.Product.Product f_agjcL g_agjcM a
          [LclId] =
              [$dContravariant_sgjSJ $dContravariant1_sgjSK] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantProduct_$c>$
                      $dContravariant_sgjSJ $dContravariant1_sgjSK eta_B2 eta_B1; } in
        let {
          sat_sgjSL [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Product.Product f_agjcL g_agjcM b
               -> Data.Functor.Product.Product f_agjcL g_agjcM a
          [LclId] =
              [$dContravariant_sgjSJ $dContravariant1_sgjSK] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
                      $dContravariant_sgjSJ $dContravariant1_sgjSK eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjSL sat_sgjSM];

Data.Functor.Contravariant.$fContravariantSum_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjSN
           $dContravariant1_sgjSO
           f1_sgjSP
           ds_sgjSQ]
        case ds_sgjSQ of {
          Data.Functor.Sum.InL xs_sgjSS [Occ=Once] ->
              let {
                sat_sgjST [Occ=Once] :: f_agjdk a_agjdr
                [LclId] =
                    [$dContravariant_sgjSN f1_sgjSP xs_sgjSS] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgjSN f1_sgjSP xs_sgjSS;
              } in  Data.Functor.Sum.InL [sat_sgjST];
          Data.Functor.Sum.InR ys_sgjSU [Occ=Once] ->
              let {
                sat_sgjSV [Occ=Once] :: g_agjdl a_agjdr
                [LclId] =
                    [$dContravariant1_sgjSO f1_sgjSP ys_sgjSU] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgjSO f1_sgjSP ys_sgjSU;
              } in  Data.Functor.Sum.InR [sat_sgjSV];
        };

Data.Functor.Contravariant.$fContravariantSum_$c>$
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjSW
           $dContravariant1_sgjSX
           x_sgjSY
           eta_sgjSZ]
        let {
          sat_sgjT1 [Occ=Once] :: a_agjdP -> b_agjdO
          [LclId] =
              [x_sgjSY] \r [ds_sgjT0] x_sgjSY;
        } in 
          Data.Functor.Contravariant.$fContravariantSum_$ccontramap
              $dContravariant_sgjSW $dContravariant1_sgjSX sat_sgjT1 eta_sgjSZ;

Data.Functor.Contravariant.$fContravariantSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgjT2 $dContravariant1_sgjT3]
        let {
          sat_sgjT5 [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl a
          [LclId] =
              [$dContravariant_sgjT2 $dContravariant1_sgjT3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantSum_$c>$
                      $dContravariant_sgjT2 $dContravariant1_sgjT3 eta_B2 eta_B1; } in
        let {
          sat_sgjT4 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl a
          [LclId] =
              [$dContravariant_sgjT2 $dContravariant1_sgjT3] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantSum_$ccontramap
                      $dContravariant_sgjT2 $dContravariant1_sgjT3 eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjT4 sat_sgjT5];

Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> (GHC.Generics.:+:) f g b -> (GHC.Generics.:+:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjT6
           $dContravariant1_sgjT7
           f1_sgjT8
           ds_sgjT9]
        case ds_sgjT9 of {
          GHC.Generics.L1 xs_sgjTb [Occ=Once] ->
              let {
                sat_sgjTc [Occ=Once] :: f_agjdX a_agje4
                [LclId] =
                    [$dContravariant_sgjT6 f1_sgjT8 xs_sgjTb] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgjT6 f1_sgjT8 xs_sgjTb;
              } in  GHC.Generics.L1 [sat_sgjTc];
          GHC.Generics.R1 ys_sgjTd [Occ=Once] ->
              let {
                sat_sgjTe [Occ=Once] :: g_agjdY a_agje4
                [LclId] =
                    [$dContravariant1_sgjT7 f1_sgjT8 ys_sgjTd] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgjT7 f1_sgjT8 ys_sgjTd;
              } in  GHC.Generics.R1 [sat_sgjTe];
        };

Data.Functor.Contravariant.$fContravariant:+:_$c>$
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> (GHC.Generics.:+:) f g b -> (GHC.Generics.:+:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjTf
           $dContravariant1_sgjTg
           x_sgjTh
           eta_sgjTi]
        let {
          sat_sgjTk [Occ=Once] :: a_agjes -> b_agjer
          [LclId] =
              [x_sgjTh] \r [ds_sgjTj] x_sgjTh;
        } in 
          Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
              $dContravariant_sgjTf $dContravariant1_sgjTg sat_sgjTk eta_sgjTi;

Data.Functor.Contravariant.$fContravariant:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgjTl $dContravariant1_sgjTm]
        let {
          sat_sgjTo [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY a
          [LclId] =
              [$dContravariant_sgjTl $dContravariant1_sgjTm] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:+:_$c>$
                      $dContravariant_sgjTl $dContravariant1_sgjTm eta_B2 eta_B1; } in
        let {
          sat_sgjTn [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:+:) f_agjdX g_agjdY b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY a
          [LclId] =
              [$dContravariant_sgjTl $dContravariant1_sgjTm] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
                      $dContravariant_sgjTl $dContravariant1_sgjTm eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjTn sat_sgjTo];

Data.Functor.Contravariant.$fContravariant:.:2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall a b. (a -> b) -> (GHC.Generics.:.:) f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgjTp $dContravariant_sgjTq f1_sgjTr ds_sgjTs]
        let {
          sat_sgjTt [Occ=Once] :: g_agjeB b_agjeI -> g_agjeB a_agjeH
          [LclId] =
              [$dContravariant_sgjTq f1_sgjTr] \u []
                  Data.Functor.Contravariant.contramap
                      $dContravariant_sgjTq f1_sgjTr;
        } in  GHC.Base.fmap $dFunctor_sgjTp sat_sgjTt ds_sgjTs;

Data.Functor.Contravariant.$fContravariant:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgjTu $dContravariant_sgjTv]
        let {
          sat_sgjTx [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS a
          [LclId] =
              [$dFunctor_sgjTu $dContravariant_sgjTv] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:.:1
                      $dFunctor_sgjTu $dContravariant_sgjTv eta_B2 eta_B1; } in
        let {
          sat_sgjTw [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS a
          [LclId] =
              [$dFunctor_sgjTu $dContravariant_sgjTv] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:.:2
                      $dFunctor_sgjTu $dContravariant_sgjTv eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjTw sat_sgjTx];

Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgjTy
           $dContravariant1_sgjTz
           f1_sgjTA
           ds_sgjTB]
        case ds_sgjTB of {
          GHC.Generics.:*: xs_sgjTD [Occ=Once] ys_sgjTE [Occ=Once] ->
              let {
                sat_sgjTG [Occ=Once] :: g_agjfb a_agjfh
                [LclId] =
                    [$dContravariant1_sgjTz f1_sgjTA ys_sgjTE] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgjTz f1_sgjTA ys_sgjTE; } in
              let {
                sat_sgjTF [Occ=Once] :: f_agjfa a_agjfh
                [LclId] =
                    [$dContravariant_sgjTy f1_sgjTA xs_sgjTD] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgjTy f1_sgjTA xs_sgjTD;
              } in  GHC.Generics.:*: [sat_sgjTF sat_sgjTG];
        };

Data.Functor.Contravariant.$fContravariant:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgjTH $dContravariant1_sgjTI]
        let {
          sat_sgjTK [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb a
          [LclId] =
              [$dContravariant_sgjTH $dContravariant1_sgjTI] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:*:_$c>$
                      $dContravariant_sgjTH $dContravariant1_sgjTI eta_B2 eta_B1; } in
        let {
          sat_sgjTJ [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:*:) f_agjfa g_agjfb b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb a
          [LclId] =
              [$dContravariant_sgjTH $dContravariant1_sgjTI] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
                      $dContravariant_sgjTH $dContravariant1_sgjTI eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgjTJ sat_sgjTK];

Data.Functor.Contravariant.$fContravariantK3
  :: forall i c a b.
     (a -> b) -> GHC.Generics.K1 i c b -> GHC.Generics.K1 i c b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgjTL ds1_sgjTM] ds1_sgjTM;

Data.Functor.Contravariant.$fContravariantK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c.
     Data.Functor.Contravariant.Contravariant (GHC.Generics.K1 i c)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantK3
                                                               Data.Functor.Contravariant.$fContravariantK2];

Data.Functor.Contravariant.$fContravariantU1_$ccontramap
  :: forall a b. (a -> b) -> GHC.Generics.U1 b -> GHC.Generics.U1 a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjTN ds1_sgjTO] GHC.Generics.U1 [];

Data.Functor.Contravariant.$fContravariantU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant GHC.Generics.U1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantU1_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantU1_$c>$];

Data.Functor.Contravariant.$fContravariantV1_$ccontramap
  :: forall a b. (a -> b) -> GHC.Generics.V1 b -> GHC.Generics.V1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sgjTP x_sgjTQ] x_sgjTQ;

Data.Functor.Contravariant.$fContravariantV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant GHC.Generics.V1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantV1_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantV1_$c>$];

lvl2_rgjLt
  :: forall a b1.
     GHC.Real.Integral b1 =>
     b1 -> (a -> GHC.Types.Ordering) -> a -> GHC.Types.Ordering
[GblId, Arity=4, Str=<L,U><L,U><L,1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgjTS n_sgjTT f_sgjTU e_sgjTV]
        let {
          sat_sgjTW [Occ=Once] :: GHC.Types.Ordering
          [LclId] =
              [f_sgjTU e_sgjTV] \u [] f_sgjTU e_sgjTV;
        } in 
          GHC.Base.$fSemigroupOrdering_$cstimes
              $dIntegral_sgjTS n_sgjTT sat_sgjTW;

lvl3_rgjLu
  :: forall a.
     GHC.Base.NonEmpty (a -> GHC.Types.Ordering)
     -> a -> GHC.Types.Ordering
[GblId, Arity=1, Str=<S(LS),1*U(U,1*U)>, Unf=OtherCon []] =
    [] \r [w1_sgjTX]
        case w1_sgjTX of {
          GHC.Base.:| ww1_sgjTZ [Occ=Once] ww2_sgjU0 [Occ=Once] ->
              GHC.Base.$w$csconcat3
                  GHC.Base.$fSemigroupOrdering ww1_sgjTZ ww2_sgjU0;
        };

lvl4_rgjLv
  :: forall a.
     (a -> GHC.Types.Ordering)
     -> (a -> GHC.Types.Ordering) -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgjU1 g_sgjU2 x_sgjU3]
        case f_sgjU1 x_sgjU3 of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> g_sgjU2 x_sgjU3;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (a -> GHC.Types.Ordering)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [lvl4_rgjLv
                                         lvl3_rgjLu
                                         lvl2_rgjLt];

Data.Functor.Contravariant.$fSemigroupComparison2
  :: forall a.
     GHC.Base.NonEmpty (a -> a -> GHC.Types.Ordering)
     -> a -> a -> GHC.Types.Ordering
[GblId, Arity=1, Str=<S(LS),1*U(U,1*U)>, Unf=OtherCon []] =
    [] \r [w1_sgjU5]
        case w1_sgjU5 of {
          GHC.Base.:| ww1_sgjU7 [Occ=Once] ww2_sgjU8 [Occ=Once] ->
              GHC.Base.$w$csconcat3
                  Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
                  ww1_sgjU7
                  ww2_sgjU8;
        };

Data.Functor.Contravariant.$fSemigroupComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Comparison a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fSemigroupComparison3
                                         Data.Functor.Contravariant.$fSemigroupComparison2
                                         Data.Functor.Contravariant.$fSemigroupComparison1];

lvl5_rgjLw :: forall a. a -> GHC.Types.Ordering
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgjU9] GHC.Types.EQ [];

lvl6_rgjLx
  :: forall a. [a -> GHC.Types.Ordering] -> a -> GHC.Types.Ordering
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fMonoid(->)_$cmconcat
            GHC.Base.$fMonoidOrdering eta_B2 eta_B1;

Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (a -> GHC.Types.Ordering)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
                                      lvl5_rgjLw
                                      lvl4_rgjLv
                                      lvl6_rgjLx];

Data.Functor.Contravariant.$fMonoidComparison1
  :: forall a.
     [a -> a -> GHC.Types.Ordering] -> a -> a -> GHC.Types.Ordering
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fMonoid(->)_$cmconcat
            Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)
            eta_B2
            eta_B1;

Data.Functor.Contravariant.$fMonoidComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupComparison
                                      Data.Functor.Contravariant.$fMonoidComparison3
                                      Data.Functor.Contravariant.$fMonoidComparison2
                                      Data.Functor.Contravariant.$fMonoidComparison1];

Data.Functor.Contravariant.C:Contravariant
  :: forall (f :: * -> *).
     (forall a b. (a -> b) -> f b -> f a)
     -> (forall b a. b -> f b -> f a)
     -> Data.Functor.Contravariant.Contravariant f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Functor.Contravariant.C:Contravariant [eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:12:16.583278063 UTC

Data.Functor.Contravariant.contramap
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall a b. (a -> b) -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sgm8b]
        case v_sgm8b of {
          Data.Functor.Contravariant.C:Contravariant v_sgm8d [Occ=Once]
                                                     _ [Occ=Dead] ->
              v_sgm8d;
        };

Data.Functor.Contravariant.>$
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall b a. b -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sgm8f]
        case v_sgm8f of {
          Data.Functor.Contravariant.C:Contravariant _ [Occ=Dead]
                                                     v_sgm8i [Occ=Once] ->
              v_sgm8i;
        };

Data.Functor.Contravariant.$tc'Op3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Op"#;

Data.Functor.Contravariant.$tc'Op2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Op3];

Data.Functor.Contravariant.$tcOp2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Op"#;

Data.Functor.Contravariant.$tcOp1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcOp2];

Data.Functor.Contravariant.$tc'Equivalence3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Equivalence"#;

Data.Functor.Contravariant.$tc'Equivalence2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Equivalence3];

Data.Functor.Contravariant.$tcEquivalence2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Equivalence"#;

Data.Functor.Contravariant.$tcEquivalence1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcEquivalence2];

Data.Functor.Contravariant.$tc'Comparison3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Comparison"#;

Data.Functor.Contravariant.$tc'Comparison2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Comparison3];

Data.Functor.Contravariant.$tcComparison2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Comparison"#;

Data.Functor.Contravariant.$tcComparison1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcComparison2];

Data.Functor.Contravariant.$tc'Predicate3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Predicate"#;

Data.Functor.Contravariant.$tc'Predicate2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Predicate3];

Data.Functor.Contravariant.$tcPredicate2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Predicate"#;

Data.Functor.Contravariant.$tcPredicate1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcPredicate2];

Data.Functor.Contravariant.$tcContravariant3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Contravariant"#;

Data.Functor.Contravariant.$tcContravariant2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcContravariant3];

$krep_rgjLa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rgjLb :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgjLa GHC.Types.[]];

$krep2_rgjLc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep3_rgjLd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_rgjLc $krep_rgjLa];

$krep4_rgjLe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgjLc GHC.Types.[]];

$krep5_rgjLf :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgjLa $krep4_rgjLe];

$krep6_rgjLg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep7_rgjLh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep6_rgjLg];

$krep8_rgjLi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep7_rgjLh];

$krep9_rgjLj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcOrdering
                                              GHC.Types.[]];

$krep10_rgjLk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep9_rgjLj];

$krep11_rgjLl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep10_rgjLk];

$krep12_rgjLm :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Functor.Contravariant.$tcContravariant1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep12_rgjLm];

Data.Functor.Contravariant.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Contravariant"#;

Data.Functor.Contravariant.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$trModule2];

Data.Functor.Contravariant.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Contravariant.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$trModule4];

Data.Functor.Contravariant.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Contravariant.$trModule3
                                     Data.Functor.Contravariant.$trModule1];

Data.Functor.Contravariant.$tcContravariant :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1944710495430526909##
                                    15571985404928937498##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcContravariant2
                                    0#
                                    Data.Functor.Contravariant.$tcContravariant1];

Data.Functor.Contravariant.$tcPredicate :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9927645946720114643##
                                    17478425232619398566##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcPredicate1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_rgjLn :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcPredicate
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Predicate1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rgjLh $krep13_rgjLn];

Data.Functor.Contravariant.$tc'Predicate :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10560326927625189840##
                                    8988710799443424590##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Predicate2
                                    1#
                                    Data.Functor.Contravariant.$tc'Predicate1];

Data.Functor.Contravariant.$tcComparison :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8128667979445988110##
                                    9034904213662261762##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcComparison1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_rgjLo :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcComparison
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Comparison1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_rgjLl $krep14_rgjLo];

Data.Functor.Contravariant.$tc'Comparison :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11047345948274903716##
                                    12707949450550295743##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Comparison2
                                    1#
                                    Data.Functor.Contravariant.$tc'Comparison1];

Data.Functor.Contravariant.$tcEquivalence :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9646573079009549553##
                                    12303965936368510845##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcEquivalence1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep15_rgjLp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcEquivalence
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Equivalence1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_rgjLi $krep15_rgjLp];

Data.Functor.Contravariant.$tc'Equivalence :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5667737350508967909##
                                    15093804341312440267##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Equivalence2
                                    1#
                                    Data.Functor.Contravariant.$tc'Equivalence1];

Data.Functor.Contravariant.$tcOp :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13209106975460307324##
                                    7546944290236364550##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcOp1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep16_rgjLq :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcOp
                                              $krep5_rgjLf];

Data.Functor.Contravariant.$tc'Op1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rgjLd $krep16_rgjLq];

Data.Functor.Contravariant.$tc'Op :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12479862397628491530##
                                    1381176546464080972##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Op2
                                    2#
                                    Data.Functor.Contravariant.$tc'Op1];

Data.Functor.Contravariant.comparisonEquivalence1
  :: forall a.
     Data.Functor.Contravariant.Comparison a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgm8j a1_sgm8k b_sgm8l]
        case ds_sgm8j a1_sgm8k b_sgm8l of {
          __DEFAULT -> GHC.Types.False [];
          GHC.Types.EQ -> GHC.Types.True [];
        };

Data.Functor.Contravariant.comparisonEquivalence
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Contravariant.comparisonEquivalence1
            eta_B3 eta_B2 eta_B1;

Data.Functor.Contravariant.defaultEquivalence
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Classes.== eta_B1;

Data.Functor.Contravariant.defaultComparison
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Contravariant.Comparison a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Classes.compare eta_B1;

Data.Functor.Contravariant.>$$<
  :: forall (f :: * -> *) b a.
     Data.Functor.Contravariant.Contravariant f =>
     f b -> (a -> b) -> f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgm8n eta_sgm8o eta1_sgm8p]
        Data.Functor.Contravariant.contramap
            $dContravariant_sgm8n eta1_sgm8p eta_sgm8o;

Data.Functor.Contravariant.>$<
  :: forall (f :: * -> *) a b.
     Data.Functor.Contravariant.Contravariant f =>
     (a -> b) -> f b -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgm8q]
        Data.Functor.Contravariant.contramap $dContravariant_sgm8q;

Data.Functor.Contravariant.phantom
  :: forall (f :: * -> *) a b.
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant f) =>
     f a -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)))><S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgm8r $dContravariant_sgm8s x_sgm8t]
        let {
          sat_sgm8u [Occ=Once] :: f_agiQT ()
          [LclId] =
              [$dFunctor_sgm8r x_sgm8t] \u []
                  GHC.Base.<$ $dFunctor_sgm8r GHC.Tuple.() x_sgm8t;
        } in 
          Data.Functor.Contravariant.>$
              $dContravariant_sgm8s GHC.Tuple.() sat_sgm8u;

Data.Functor.Contravariant.$<
  :: forall (f :: * -> *) b a.
     Data.Functor.Contravariant.Contravariant f =>
     f b -> b -> f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgm8v eta_sgm8w eta1_sgm8x]
        Data.Functor.Contravariant.>$
            $dContravariant_sgm8v eta1_sgm8x eta_sgm8w;

Data.Functor.Contravariant.$fContravariantOp1
  :: forall a1 b a2.
     b -> Data.Functor.Contravariant.Op a1 b -> a2 -> a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgm8y eta_sgm8z eta1_sgm8A] eta_sgm8z x_sgm8y;

Data.Functor.Contravariant.$fContravariantOp2
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Functor.Contravariant.Op a1 b -> a2 -> a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f_sgm8B g_sgm8C eta_B1] GHC.Base.. g_sgm8C f_sgm8B eta_B1;

Data.Functor.Contravariant.$fContravariantOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Contravariant.Op a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantOp2
                                                               Data.Functor.Contravariant.$fContravariantOp1];

Data.Functor.Contravariant.getOp1
  :: forall a b.
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgm8D] ds_sgm8D;

Data.Functor.Contravariant.getOp
  :: forall a b. Data.Functor.Contravariant.Op a b -> b -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getOp1 eta_B1;

Data.Functor.Contravariant.$fContravariantEquivalence1
  :: forall b a.
     b
     -> Data.Functor.Contravariant.Equivalence b
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),1*C1(C1(U))><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgm8E eta_sgm8F eta1_sgm8G eta2_sgm8H]
        eta_sgm8F x_sgm8E x_sgm8E;

Data.Functor.Contravariant.$fContravariantEquivalence2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Equivalence b
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgm8I g_sgm8J x_sgm8K y_sgm8L]
        let {
          sat_sgm8N [Occ=Once] :: b_agj9q
          [LclId] =
              [f_sgm8I y_sgm8L] \u [] f_sgm8I y_sgm8L; } in
        let {
          sat_sgm8M [Occ=Once] :: b_agj9q
          [LclId] =
              [f_sgm8I x_sgm8K] \u [] f_sgm8I x_sgm8K;
        } in  g_sgm8J sat_sgm8M sat_sgm8N;

Data.Functor.Contravariant.$fContravariantEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Equivalence
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantEquivalence2
                                                               Data.Functor.Contravariant.$fContravariantEquivalence1];

Data.Functor.Contravariant.getEquivalence1
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgm8O] ds_sgm8O;

Data.Functor.Contravariant.getEquivalence
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> a -> a -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getEquivalence1 eta_B1;

Data.Functor.Contravariant.$fContravariantComparison1
  :: forall b a.
     b
     -> Data.Functor.Contravariant.Comparison b
     -> a
     -> a
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),1*C1(C1(U))><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgm8P eta_sgm8Q eta1_sgm8R eta2_sgm8S]
        eta_sgm8Q x_sgm8P x_sgm8P;

Data.Functor.Contravariant.$fContravariantComparison2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Comparison b
     -> a
     -> a
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgm8T g_sgm8U x_sgm8V y_sgm8W]
        let {
          sat_sgm8Y [Occ=Once] :: b_agj9P
          [LclId] =
              [f_sgm8T y_sgm8W] \u [] f_sgm8T y_sgm8W; } in
        let {
          sat_sgm8X [Occ=Once] :: b_agj9P
          [LclId] =
              [f_sgm8T x_sgm8V] \u [] f_sgm8T x_sgm8V;
        } in  g_sgm8U sat_sgm8X sat_sgm8Y;

Data.Functor.Contravariant.$fContravariantComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Comparison
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantComparison2
                                                               Data.Functor.Contravariant.$fContravariantComparison1];

Data.Functor.Contravariant.getComparison1
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> Data.Functor.Contravariant.Comparison a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgm8Z] ds_sgm8Z;

Data.Functor.Contravariant.getComparison
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> a -> a -> GHC.Types.Ordering
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getComparison1 eta_B1;

Data.Functor.Contravariant.$fContravariantPredicate1
  :: forall b a.
     b -> Data.Functor.Contravariant.Predicate b -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgm90 eta_sgm91 eta1_sgm92] eta_sgm91 x_sgm90;

Data.Functor.Contravariant.$fContravariantPredicate2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Predicate b -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f_sgm93 g_sgm94 eta_B1] GHC.Base.. g_sgm94 f_sgm93 eta_B1;

Data.Functor.Contravariant.$fContravariantPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Predicate
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantPredicate2
                                                               Data.Functor.Contravariant.$fContravariantPredicate1];

Data.Functor.Contravariant.getPredicate1
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgm95] ds_sgm95;

Data.Functor.Contravariant.getPredicate
  :: forall a.
     Data.Functor.Contravariant.Predicate a -> a -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getPredicate1 eta_B1;

Data.Functor.Contravariant.$fContravariantV1_$c>$
  :: forall b a. b -> GHC.Generics.V1 b -> GHC.Generics.V1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [x_sgm96 x1_sgm97] x1_sgm97;

Data.Functor.Contravariant.$fContravariantU1_$c>$
  :: forall b a. b -> GHC.Generics.U1 b -> GHC.Generics.U1 a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sgm99 ds_sgm9a] GHC.Generics.U1 [];

Data.Functor.Contravariant.$fContravariantK2
  :: forall b c i.
     b -> GHC.Generics.K1 i c b -> GHC.Generics.K1 i c b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgm9b ds_sgm9c] ds_sgm9c;

Data.Functor.Contravariant.$fContravariant:*:_$c>$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgm9d w1_sgm9e w2_sgm9f w3_sgm9g]
        case w3_sgm9g of {
          GHC.Generics.:*: ww1_sgm9i [Occ=Once] ww2_sgm9j [Occ=Once] ->
              let {
                f1_sgm9k :: a_sgjEw -> b_sgjEv
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sgm9f] \r [ds_sgm9l] w2_sgm9f; } in
              let {
                sat_sgm9n [Occ=Once] :: g_sgjEs a_sgjEw
                [LclId] =
                    [w1_sgm9e ww2_sgm9j f1_sgm9k] \u []
                        Data.Functor.Contravariant.contramap
                            w1_sgm9e f1_sgm9k ww2_sgm9j; } in
              let {
                sat_sgm9m [Occ=Once] :: f_sgjEr a_sgjEw
                [LclId] =
                    [w_sgm9d ww1_sgm9i f1_sgm9k] \u []
                        Data.Functor.Contravariant.contramap w_sgm9d f1_sgm9k ww1_sgm9i;
              } in  GHC.Generics.:*: [sat_sgm9m sat_sgm9n];
        };

Data.Functor.Contravariant.$fContravariant:.:1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall b a. b -> (GHC.Generics.:.:) f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgm9o $dContravariant_sgm9p x_sgm9q eta_sgm9r]
        let {
          sat_sgm9u [Occ=Once] :: g_XgjkT b_agjf1 -> g_XgjkT a_agjf2
          [LclId] =
              [$dContravariant_sgm9p x_sgm9q] \u []
                  let {
                    sat_sgm9t [Occ=Once] :: a_agjf2 -> b_agjf1
                    [LclId] =
                        [x_sgm9q] \r [ds_sgm9s] x_sgm9q;
                  } in 
                    Data.Functor.Contravariant.contramap
                        $dContravariant_sgm9p sat_sgm9t;
        } in  GHC.Base.fmap $dFunctor_sgm9o sat_sgm9u eta_sgm9r;

Data.Functor.Contravariant.$fContravariantProduct_$c>$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgm9v w1_sgm9w w2_sgm9x w3_sgm9y]
        case w3_sgm9y of {
          Data.Functor.Product.Pair ww1_sgm9A [Occ=Once]
                                    ww2_sgm9B [Occ=Once] ->
              let {
                f1_sgm9C :: a_sgjEN -> b_sgjEM
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sgm9x] \r [ds_sgm9D] w2_sgm9x; } in
              let {
                sat_sgm9F [Occ=Once] :: g_sgjEJ a_sgjEN
                [LclId] =
                    [w1_sgm9w ww2_sgm9B f1_sgm9C] \u []
                        Data.Functor.Contravariant.contramap
                            w1_sgm9w f1_sgm9C ww2_sgm9B; } in
              let {
                sat_sgm9E [Occ=Once] :: f_sgjEI a_sgjEN
                [LclId] =
                    [w_sgm9v ww1_sgm9A f1_sgm9C] \u []
                        Data.Functor.Contravariant.contramap w_sgm9v f1_sgm9C ww1_sgm9A;
              } in  Data.Functor.Product.Pair [sat_sgm9E sat_sgm9F];
        };

Data.Functor.Contravariant.$fContravariantConst1
  :: forall b a.
     b -> Data.Functor.Const.Const a b -> Data.Functor.Const.Const a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgm9G ds_sgm9H] ds_sgm9H;

Data.Functor.Contravariant.$fContravariantCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall b a. b -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgm9I $dContravariant_sgm9J x_sgm9K eta_sgm9L]
        let {
          sat_sgm9O [Occ=Once] :: g_XgjhX b_agjcg -> g_XgjhX a_agjch
          [LclId] =
              [$dContravariant_sgm9J x_sgm9K] \u []
                  let {
                    sat_sgm9N [Occ=Once] :: a_agjch -> b_agjcg
                    [LclId] =
                        [x_sgm9K] \r [ds_sgm9M] x_sgm9K;
                  } in 
                    Data.Functor.Contravariant.contramap
                        $dContravariant_sgm9J sat_sgm9N;
        } in  GHC.Base.fmap $dFunctor_sgm9I sat_sgm9O eta_sgm9L;

Data.Functor.Contravariant.$fContravariantProxy_$c>$
  :: forall b a. b -> Data.Proxy.Proxy b -> Data.Proxy.Proxy a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sgm9P ds_sgm9Q] Data.Proxy.Proxy [];

Data.Functor.Contravariant.$dm>$
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall b a. b -> f b -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgm9R eta_sgm9S]
        let {
          sat_sgm9U [Occ=Once] :: a_agiRb -> b_agiRa
          [LclId] =
              [eta_sgm9S] \r [ds_sgm9T] eta_sgm9S;
        } in 
          Data.Functor.Contravariant.contramap
              $dContravariant_sgm9R sat_sgm9U;

Data.Functor.Contravariant.$fSemigroupOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sgm9V]
        let {
          sat_sgm9Y [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgm9V] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$cstimes
                      $dSemigroup_sgm9V eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgm9X [Occ=Once]
            :: GHC.Base.NonEmpty
                 (Data.Functor.Contravariant.Op a_agiSm b_agiSn)
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgm9V] \r [eta_B1]
                  GHC.Base.$fSemigroup(->)_$csconcat $dSemigroup_sgm9V eta_B1; } in
        let {
          sat_sgm9W [Occ=Once]
            :: Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgm9V] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$c<>
                      $dSemigroup_sgm9V eta_B3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sgm9W sat_sgm9X sat_sgm9Y];

Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid
  :: forall a b.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgm9Z]
        let {
          sat_sgma0 [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_XgiXu
          [LclId] =
              [$dMonoid_sgm9Z] \u [] GHC.Base.$p1Monoid $dMonoid_sgm9Z;
        } in  Data.Functor.Contravariant.$fSemigroupOp sat_sgma0;

Data.Functor.Contravariant.$fMonoidOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_sgma1]
        let {
          lvl7_sgma2 [Occ=OnceL] :: a_XgiXv
          [LclId] =
              [$dMonoid_sgma1] \u [] GHC.Base.mempty $dMonoid_sgma1; } in
        let {
          sat_sgma7 [Occ=Once]
            :: [Data.Functor.Contravariant.Op a_XgiXv b_XgiXx]
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [$dMonoid_sgma1] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmconcat $dMonoid_sgma1 eta_B2 eta_B1; } in
        let {
          sat_sgma6 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [$dMonoid_sgma1] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmappend
                      $dMonoid_sgma1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgma5 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [lvl7_sgma2] \r [ds_sgma4] lvl7_sgma2; } in
        let {
          sat_sgma3 [Occ=Once]
            :: GHC.Base.Semigroup
                 (Data.Functor.Contravariant.Op a_XgiXv b_XgiXx)
          [LclId] =
              [$dMonoid_sgma1] \u []
                  Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid $dMonoid_sgma1;
        } in  GHC.Base.C:Monoid [sat_sgma3 sat_sgma5 sat_sgma6 sat_sgma7];

Data.Functor.Contravariant.$fMonoidComparison3
  :: forall a. a -> a -> GHC.Types.Ordering
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgma8 ds1_sgma9] GHC.Types.EQ [];

Data.Functor.Contravariant.$fMonoidComparison2
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgmaa g_sgmab x_sgmac]
        let {
          f1_sgmad [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [f_sgmaa x_sgmac] \u [] f_sgmaa x_sgmac; } in
        let {
          g1_sgmae [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [g_sgmab x_sgmac] \u [] g_sgmab x_sgmac; } in
        let {
          sat_sgmah [Occ=OnceT[0]] :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [f1_sgmad g1_sgmae] \r [x1_sgmaf]
                  case f1_sgmad x1_sgmaf of {
                    GHC.Types.LT -> GHC.Types.LT [];
                    GHC.Types.EQ -> g1_sgmae x1_sgmaf;
                    GHC.Types.GT -> GHC.Types.GT [];
                  };
        } in  sat_sgmah;

Data.Functor.Contravariant.$fSemigroupComparison3
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgmai g_sgmaj x_sgmak]
        let {
          f1_sgmal [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [f_sgmai x_sgmak] \u [] f_sgmai x_sgmak; } in
        let {
          g1_sgmam [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [g_sgmaj x_sgmak] \u [] g_sgmaj x_sgmak; } in
        let {
          sat_sgmap [Occ=OnceT[0]] :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [f1_sgmal g1_sgmam] \r [x1_sgman]
                  case f1_sgmal x1_sgman of {
                    GHC.Types.LT -> GHC.Types.LT [];
                    GHC.Types.EQ -> g1_sgmam x1_sgman;
                    GHC.Types.GT -> GHC.Types.GT [];
                  };
        } in  sat_sgmap;

Data.Functor.Contravariant.$fSemigroupComparison1
  :: forall a b.
     GHC.Real.Integral b =>
     b -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Str=<L,U><L,U><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sgmaq n_sgmar f_sgmas e_sgmat]
        let {
          f1_sgmau [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiUz -> GHC.Types.Ordering
          [LclId] =
              [f_sgmas e_sgmat] \u [] f_sgmas e_sgmat; } in
        let {
          lvl7_sgmav [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: b_agiVn -> GHC.Types.Ordering -> GHC.Types.Ordering
          [LclId] =
              [$dIntegral_sgmaq] \u []
                  GHC.Base.$fSemigroupOrdering_$cstimes $dIntegral_sgmaq; } in
        let {
          sat_sgmay [Occ=OnceT[0]] :: a_agiUz -> GHC.Types.Ordering
          [LclId] =
              [n_sgmar f1_sgmau lvl7_sgmav] \r [e1_sgmaw]
                  let {
                    sat_sgmax [Occ=Once] :: GHC.Types.Ordering
                    [LclId] =
                        [f1_sgmau e1_sgmaw] \u [] f1_sgmau e1_sgmaw;
                  } in  lvl7_sgmav n_sgmar sat_sgmax;
        } in  sat_sgmay;

Data.Functor.Contravariant.$fContravariantM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant (GHC.Generics.M1 i c f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgmaz]
        let {
          sat_sgmaB [Occ=Once]
            :: forall b a.
               b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r a
          [LclId] =
              [$dContravariant_sgmaz] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgmaz; } in
        let {
          sat_sgmaA [Occ=Once]
            :: forall a b.
               (a -> b)
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r a
          [LclId] =
              [$dContravariant_sgmaz] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgmaz;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmaA sat_sgmaB];

Data.Functor.Contravariant.$fContravariantRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant (GHC.Generics.Rec1 f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgmaC]
        let {
          sat_sgmaE [Occ=Once]
            :: forall b a.
               b -> GHC.Generics.Rec1 f_agiX0 b -> GHC.Generics.Rec1 f_agiX0 a
          [LclId] =
              [$dContravariant_sgmaC] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgmaC; } in
        let {
          sat_sgmaD [Occ=Once]
            :: forall a b.
               (a -> b)
               -> GHC.Generics.Rec1 f_agiX0 b -> GHC.Generics.Rec1 f_agiX0 a
          [LclId] =
              [$dContravariant_sgmaC] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgmaC;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmaD sat_sgmaE];

Data.Functor.Contravariant.$fContravariantAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant
       (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgmaF]
        let {
          sat_sgmaH [Occ=Once]
            :: forall b a.
               b
               -> Data.Semigroup.Internal.Alt f_agiY2 b
               -> Data.Semigroup.Internal.Alt f_agiY2 a
          [LclId] =
              [$dContravariant_sgmaF] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgmaF; } in
        let {
          sat_sgmaG [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Semigroup.Internal.Alt f_agiY2 b
               -> Data.Semigroup.Internal.Alt f_agiY2 a
          [LclId] =
              [$dContravariant_sgmaF] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgmaF;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmaG sat_sgmaH];

sat_sgmaI :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgmaJ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgmaI GHC.Types.[]];

lvl_rgjLr :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgmaJ;

lvl1_rgjLs :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Functor.Contravariant.$fFloatingOp_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmaK eta_sgmaL]
        let {
          $dFractional_sgmaM [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgmaK] \s []
                  GHC.Float.$p1Floating $dFloating_sgmaK; } in
        let {
          $dNum_sgmaN [Dmd=<L,U(C(C1(U)),C(C1(U)),A,A,A,A,C(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgmaM] \u []
                  GHC.Real.$p1Fractional $dFractional_sgmaM; } in
        let {
          x_sgmaO [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgmaN] \u []
                  GHC.Num.fromInteger $dNum_sgmaN lvl1_rgjLs; } in
        let {
          x1_sgmaP [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgmaN] \u [] GHC.Num.fromInteger $dNum_sgmaN lvl_rgjLr; } in
        let {
          sat_sgmaV [Occ=Once] :: b_Xgj9Q -> a_Xgj9N
          [LclId] =
              [$dFloating_sgmaK
               eta_sgmaL
               $dNum_sgmaN
               x_sgmaO
               x1_sgmaP] \r [eta1_sgmaQ]
                  let {
                    sat_sgmaU [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgmaK
                         eta_sgmaL
                         $dNum_sgmaN
                         x_sgmaO
                         x1_sgmaP
                         eta1_sgmaQ] \u []
                            let {
                              sat_sgmaT [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [$dFloating_sgmaK eta_sgmaL $dNum_sgmaN x_sgmaO eta1_sgmaQ] \u []
                                      let {
                                        sat_sgmaS [Occ=Once] :: a_Xgj9N
                                        [LclId] =
                                            [$dFloating_sgmaK eta_sgmaL eta1_sgmaQ] \u []
                                                let {
                                                  sat_sgmaR [Occ=Once] :: a_Xgj9N
                                                  [LclId] =
                                                      [eta_sgmaL eta1_sgmaQ] \u []
                                                          eta_sgmaL eta1_sgmaQ;
                                                } in  GHC.Float.exp $dFloating_sgmaK sat_sgmaR;
                                      } in  GHC.Num.- $dNum_sgmaN x_sgmaO sat_sgmaS;
                            } in  GHC.Num.+ $dNum_sgmaN x1_sgmaP sat_sgmaT;
                  } in  GHC.Float.log $dFloating_sgmaK sat_sgmaU;
        } in  sat_sgmaV;

Data.Functor.Contravariant.$fFloatingOp_$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(A,C(C1(U)),A,A,A,A,1*C1(U)),A,A,A),A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmaW eta_sgmaX]
        let {
          $dFractional_sgmaY [Occ=OnceL,
                              Dmd=<L,1*U(1*U(A,C(C1(U)),A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgmaW] \s []
                  GHC.Float.$p1Floating $dFloating_sgmaW; } in
        let {
          $dNum_sgmaZ [Dmd=<L,U(A,C(C1(U)),A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgmaY] \u []
                  GHC.Real.$p1Fractional $dFractional_sgmaY; } in
        let {
          x_sgmb0 [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgmaZ] \u [] GHC.Num.fromInteger $dNum_sgmaZ lvl_rgjLr; } in
        let {
          sat_sgmb4 [Occ=Once] :: b_Xgj4c -> a_Xgj9N
          [LclId] =
              [$dFloating_sgmaW eta_sgmaX $dNum_sgmaZ x_sgmb0] \r [a1_sgmb1]
                  let {
                    sat_sgmb3 [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgmaW eta_sgmaX a1_sgmb1] \u []
                            let {
                              sat_sgmb2 [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [eta_sgmaX a1_sgmb1] \u [] eta_sgmaX a1_sgmb1;
                            } in  GHC.Float.exp $dFloating_sgmaW sat_sgmb2;
                  } in  GHC.Num.- $dNum_sgmaZ sat_sgmb3 x_sgmb0;
        } in  sat_sgmb4;

Data.Functor.Contravariant.$fFloatingOp_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmb5 eta_sgmb6]
        let {
          $dFractional_sgmb7 [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgmb5] \s []
                  GHC.Float.$p1Floating $dFloating_sgmb5; } in
        let {
          $dNum_sgmb8 [Dmd=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgmb7] \u []
                  GHC.Real.$p1Fractional $dFractional_sgmb7; } in
        let {
          x_sgmb9 [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgmb8] \u [] GHC.Num.fromInteger $dNum_sgmb8 lvl_rgjLr; } in
        let {
          sat_sgmbe [Occ=Once] :: b_Xgj9Q -> a_Xgj9N
          [LclId] =
              [$dFloating_sgmb5 eta_sgmb6 $dNum_sgmb8 x_sgmb9] \r [eta1_sgmba]
                  let {
                    sat_sgmbd [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgmb5 eta_sgmb6 $dNum_sgmb8 x_sgmb9 eta1_sgmba] \u []
                            let {
                              sat_sgmbc [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [$dFloating_sgmb5 eta_sgmb6 eta1_sgmba] \u []
                                      let {
                                        sat_sgmbb [Occ=Once] :: a_Xgj9N
                                        [LclId] =
                                            [eta_sgmb6 eta1_sgmba] \u [] eta_sgmb6 eta1_sgmba;
                                      } in  GHC.Float.exp $dFloating_sgmb5 sat_sgmbb;
                            } in  GHC.Num.+ $dNum_sgmb8 x_sgmb9 sat_sgmbc;
                  } in  GHC.Float.log $dFloating_sgmb5 sat_sgmbd;
        } in  sat_sgmbe;

Data.Functor.Contravariant.$fFloatingOp_$clog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbf eta_sgmbg]
        let {
          $dFractional_sgmbh [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj4c
          [LclId] =
              [$dFloating_sgmbf] \s []
                  GHC.Float.$p1Floating $dFloating_sgmbf; } in
        let {
          $dNum_sgmbi [Dmd=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj4c
          [LclId] =
              [$dFractional_sgmbh] \u []
                  GHC.Real.$p1Fractional $dFractional_sgmbh; } in
        let {
          x_sgmbj [Occ=OnceL] :: a_Xgj4c
          [LclId] =
              [$dNum_sgmbi] \u [] GHC.Num.fromInteger $dNum_sgmbi lvl_rgjLr; } in
        let {
          sat_sgmbn [Occ=Once] :: b_Xgj4e -> a_Xgj4c
          [LclId] =
              [$dFloating_sgmbf eta_sgmbg $dNum_sgmbi x_sgmbj] \r [eta1_sgmbk]
                  let {
                    sat_sgmbm [Occ=Once] :: a_Xgj4c
                    [LclId] =
                        [eta_sgmbg $dNum_sgmbi x_sgmbj eta1_sgmbk] \u []
                            let {
                              sat_sgmbl [Occ=Once] :: a_Xgj4c
                              [LclId] =
                                  [eta_sgmbg eta1_sgmbk] \u [] eta_sgmbg eta1_sgmbk;
                            } in  GHC.Num.+ $dNum_sgmbi x_sgmbj sat_sgmbl;
                  } in  GHC.Float.log $dFloating_sgmbf sat_sgmbm;
        } in  sat_sgmbn;

Data.Functor.Contravariant.$fFloatingOp17
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLLLLLLLLLLLLLLLLLLL),1*U(A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbo ds_sgmbp eta_sgmbq]
        let {
          sat_sgmbr [Occ=Once] :: a_XgjeT
          [LclId] =
              [ds_sgmbp eta_sgmbq] \u [] ds_sgmbp eta_sgmbq;
        } in  GHC.Float.exp $dFloating_sgmbo sat_sgmbr;

Data.Functor.Contravariant.$fFloatingOp16
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LLLLLLLLLLLLLLLLLLL),1*U(A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbs ds_sgmbt eta_sgmbu]
        let {
          sat_sgmbv [Occ=Once] :: a_Xgj44
          [LclId] =
              [ds_sgmbt eta_sgmbu] \u [] ds_sgmbt eta_sgmbu;
        } in  GHC.Float.log $dFloating_sgmbs sat_sgmbv;

Data.Functor.Contravariant.$fFloatingOp15
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)LLLLLLLLLLLLLLLLLL),1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbw ds_sgmbx eta_sgmby]
        let {
          sat_sgmbz [Occ=Once] :: a_Xgj9g
          [LclId] =
              [ds_sgmbx eta_sgmby] \u [] ds_sgmbx eta_sgmby;
        } in  GHC.Float.sqrt $dFloating_sgmbw sat_sgmbz;

Data.Functor.Contravariant.$fFloatingOp14
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbA ds_sgmbB ds1_sgmbC a1_sgmbD]
        let {
          sat_sgmbF [Occ=Once] :: a_Xgj3W
          [LclId] =
              [ds1_sgmbC a1_sgmbD] \u [] ds1_sgmbC a1_sgmbD; } in
        let {
          sat_sgmbE [Occ=Once] :: a_Xgj3W
          [LclId] =
              [ds_sgmbB a1_sgmbD] \u [] ds_sgmbB a1_sgmbD;
        } in  GHC.Float.** $dFloating_sgmbA sat_sgmbE sat_sgmbF;

Data.Functor.Contravariant.$fFloatingOp13
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbG ds_sgmbH ds1_sgmbI a1_sgmbJ]
        let {
          sat_sgmbL [Occ=Once] :: a_Xgj4f
          [LclId] =
              [ds1_sgmbI a1_sgmbJ] \u [] ds1_sgmbI a1_sgmbJ; } in
        let {
          sat_sgmbK [Occ=Once] :: a_Xgj4f
          [LclId] =
              [ds_sgmbH a1_sgmbJ] \u [] ds_sgmbH a1_sgmbJ;
        } in  GHC.Float.logBase $dFloating_sgmbG sat_sgmbK sat_sgmbL;

Data.Functor.Contravariant.$fFloatingOp12
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbM ds_sgmbN eta_sgmbO]
        let {
          sat_sgmbP [Occ=Once] :: a_Xgj49
          [LclId] =
              [ds_sgmbN eta_sgmbO] \u [] ds_sgmbN eta_sgmbO;
        } in  GHC.Float.sin $dFloating_sgmbM sat_sgmbP;

Data.Functor.Contravariant.$fFloatingOp11
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbQ ds_sgmbR eta_sgmbS]
        let {
          sat_sgmbT [Occ=Once] :: a_Xgj43
          [LclId] =
              [ds_sgmbR eta_sgmbS] \u [] ds_sgmbR eta_sgmbS;
        } in  GHC.Float.cos $dFloating_sgmbQ sat_sgmbT;

Data.Functor.Contravariant.$fFloatingOp10
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(S)LLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbU ds_sgmbV eta_sgmbW]
        let {
          sat_sgmbX [Occ=Once] :: a_Xgj3X
          [LclId] =
              [ds_sgmbV eta_sgmbW] \u [] ds_sgmbV eta_sgmbW;
        } in  GHC.Float.tan $dFloating_sgmbU sat_sgmbX;

Data.Functor.Contravariant.$fFloatingOp9
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLC(S)LLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbY ds_sgmbZ eta_sgmc0]
        let {
          sat_sgmc1 [Occ=Once] :: a_Xgj3R
          [LclId] =
              [ds_sgmbZ eta_sgmc0] \u [] ds_sgmbZ eta_sgmc0;
        } in  GHC.Float.asin $dFloating_sgmbY sat_sgmc1;

Data.Functor.Contravariant.$fFloatingOp8
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLC(S)LLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmc2 ds_sgmc3 eta_sgmc4]
        let {
          sat_sgmc5 [Occ=Once] :: a_Xgj3L
          [LclId] =
              [ds_sgmc3 eta_sgmc4] \u [] ds_sgmc3 eta_sgmc4;
        } in  GHC.Float.acos $dFloating_sgmc2 sat_sgmc5;

Data.Functor.Contravariant.$fFloatingOp7
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLC(S)LLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmc6 ds_sgmc7 eta_sgmc8]
        let {
          sat_sgmc9 [Occ=Once] :: a_Xgj3F
          [LclId] =
              [ds_sgmc7 eta_sgmc8] \u [] ds_sgmc7 eta_sgmc8;
        } in  GHC.Float.atan $dFloating_sgmc6 sat_sgmc9;

Data.Functor.Contravariant.$fFloatingOp6
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLC(S)LLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmca ds_sgmcb eta_sgmcc]
        let {
          sat_sgmcd [Occ=Once] :: a_Xgj3z
          [LclId] =
              [ds_sgmcb eta_sgmcc] \u [] ds_sgmcb eta_sgmcc;
        } in  GHC.Float.sinh $dFloating_sgmca sat_sgmcd;

Data.Functor.Contravariant.$fFloatingOp5
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmce ds_sgmcf eta_sgmcg]
        let {
          sat_sgmch [Occ=Once] :: a_Xgj3t
          [LclId] =
              [ds_sgmcf eta_sgmcg] \u [] ds_sgmcf eta_sgmcg;
        } in  GHC.Float.cosh $dFloating_sgmce sat_sgmch;

Data.Functor.Contravariant.$fFloatingOp4
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmci ds_sgmcj eta_sgmck]
        let {
          sat_sgmcl [Occ=Once] :: a_Xgj3n
          [LclId] =
              [ds_sgmcj eta_sgmck] \u [] ds_sgmcj eta_sgmck;
        } in  GHC.Float.tanh $dFloating_sgmci sat_sgmcl;

Data.Functor.Contravariant.$fFloatingOp3
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLC(S)LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmcm ds_sgmcn eta_sgmco]
        let {
          sat_sgmcp [Occ=Once] :: a_Xgj3h
          [LclId] =
              [ds_sgmcn eta_sgmco] \u [] ds_sgmcn eta_sgmco;
        } in  GHC.Float.asinh $dFloating_sgmcm sat_sgmcp;

Data.Functor.Contravariant.$fFloatingOp2
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLC(S)LLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmcq ds_sgmcr eta_sgmcs]
        let {
          sat_sgmct [Occ=Once] :: a_Xgj3b
          [LclId] =
              [ds_sgmcr eta_sgmcs] \u [] ds_sgmcr eta_sgmcs;
        } in  GHC.Float.acosh $dFloating_sgmcq sat_sgmct;

Data.Functor.Contravariant.$fFloatingOp1
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLC(S)LLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmcu ds_sgmcv eta_sgmcw]
        let {
          sat_sgmcx [Occ=Once] :: a_agiZ4
          [LclId] =
              [ds_sgmcv eta_sgmcw] \u [] ds_sgmcv eta_sgmcw;
        } in  GHC.Float.atanh $dFloating_sgmcu sat_sgmcx;

Data.Functor.Contravariant.$fFractionalOp2
  :: forall a b.
     GHC.Real.Fractional a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LL),1*U(A,1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgmcy ds_sgmcz ds1_sgmcA a1_sgmcB]
        let {
          sat_sgmcD [Occ=Once] :: a_Xgj8K
          [LclId] =
              [ds1_sgmcA a1_sgmcB] \u [] ds1_sgmcA a1_sgmcB; } in
        let {
          sat_sgmcC [Occ=Once] :: a_Xgj8K
          [LclId] =
              [ds_sgmcz a1_sgmcB] \u [] ds_sgmcz a1_sgmcB;
        } in  GHC.Real./ $dFractional_sgmcy sat_sgmcC sat_sgmcD;

Data.Functor.Contravariant.$fFractionalOp1
  :: forall a b.
     GHC.Real.Fractional a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)L),1*U(A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgmcE ds_sgmcF eta_sgmcG]
        let {
          sat_sgmcH [Occ=Once] :: a_agj4M
          [LclId] =
              [ds_sgmcF eta_sgmcG] \u [] ds_sgmcF eta_sgmcG;
        } in  GHC.Real.recip $dFractional_sgmcE sat_sgmcH;

Data.Functor.Contravariant.$fFractionalOp_$cfromRational
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Real.Rational -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgmcI eta_sgmcJ]
        let {
          x_sgmcK [Occ=OnceL] :: a_agj4M
          [LclId] =
              [$dFractional_sgmcI eta_sgmcJ] \u []
                  GHC.Real.fromRational $dFractional_sgmcI eta_sgmcJ; } in
        let {
          sat_sgmcM [Occ=Once] :: b_agj4N -> a_agj4M
          [LclId] =
              [x_sgmcK] \r [ds_sgmcL] x_sgmcK;
        } in  sat_sgmcM;

Data.Functor.Contravariant.$fNumOp_$cnegate [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(U)),A,A,A,A,1*C1(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmcN eta_sgmcO]
        let {
          x_sgmcP [Occ=OnceL] :: a_Xgjab
          [LclId] =
              [$dNum_sgmcN] \u []
                  GHC.Num.fromInteger $dNum_sgmcN lvl1_rgjLs; } in
        let {
          sat_sgmcS [Occ=Once] :: b_Xgjad -> a_Xgjab
          [LclId] =
              [$dNum_sgmcN eta_sgmcO x_sgmcP] \r [a1_sgmcQ]
                  let {
                    sat_sgmcR [Occ=Once] :: a_Xgjab
                    [LclId] =
                        [eta_sgmcO a1_sgmcQ] \u [] eta_sgmcO a1_sgmcQ;
                  } in  GHC.Num.- $dNum_sgmcN x_sgmcP sat_sgmcR;
        } in  sat_sgmcS;

Data.Functor.Contravariant.$fNumOp5
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmcT ds_sgmcU ds1_sgmcV a1_sgmcW]
        let {
          sat_sgmcY [Occ=Once] :: a_Xgja3
          [LclId] =
              [ds1_sgmcV a1_sgmcW] \u [] ds1_sgmcV a1_sgmcW; } in
        let {
          sat_sgmcX [Occ=Once] :: a_Xgja3
          [LclId] =
              [ds_sgmcU a1_sgmcW] \u [] ds_sgmcU a1_sgmcW;
        } in  GHC.Num.+ $dNum_sgmcT sat_sgmcX sat_sgmcY;

Data.Functor.Contravariant.$fNumOp4
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmcZ ds_sgmd0 ds1_sgmd1 a1_sgmd2]
        let {
          sat_sgmd4 [Occ=Once] :: a_Xgj9W
          [LclId] =
              [ds1_sgmd1 a1_sgmd2] \u [] ds1_sgmd1 a1_sgmd2; } in
        let {
          sat_sgmd3 [Occ=Once] :: a_Xgj9W
          [LclId] =
              [ds_sgmd0 a1_sgmd2] \u [] ds_sgmd0 a1_sgmd2;
        } in  GHC.Num.- $dNum_sgmcZ sat_sgmd3 sat_sgmd4;

Data.Functor.Contravariant.$fNumOp3
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmd5 ds_sgmd6 ds1_sgmd7 a1_sgmd8]
        let {
          sat_sgmda [Occ=Once] :: a_Xgj9A
          [LclId] =
              [ds1_sgmd7 a1_sgmd8] \u [] ds1_sgmd7 a1_sgmd8; } in
        let {
          sat_sgmd9 [Occ=Once] :: a_Xgj9A
          [LclId] =
              [ds_sgmd6 a1_sgmd8] \u [] ds_sgmd6 a1_sgmd8;
        } in  GHC.Num.* $dNum_sgmd5 sat_sgmd9 sat_sgmda;

Data.Functor.Contravariant.$fNumOp2
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)LL),1*U(A,A,A,A,1*C1(U),A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmdb ds_sgmdc eta_sgmdd]
        let {
          sat_sgmde [Occ=Once] :: a_Xgj9u
          [LclId] =
              [ds_sgmdc eta_sgmdd] \u [] ds_sgmdc eta_sgmdd;
        } in  GHC.Num.abs $dNum_sgmdb sat_sgmde;

Data.Functor.Contravariant.$fNumOp1
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(S)L),1*U(A,A,A,A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmdf ds_sgmdg eta_sgmdh]
        let {
          sat_sgmdi [Occ=Once] :: a_agj5O
          [LclId] =
              [ds_sgmdg eta_sgmdh] \u [] ds_sgmdg eta_sgmdh;
        } in  GHC.Num.signum $dNum_sgmdf sat_sgmdi;

Data.Functor.Contravariant.$fNumOp_$cfromInteger
  :: forall a b.
     GHC.Num.Num a =>
     GHC.Integer.Type.Integer -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmdj eta_sgmdk]
        let {
          x_sgmdl [Occ=OnceL] :: a_agj5O
          [LclId] =
              [$dNum_sgmdj eta_sgmdk] \u []
                  GHC.Num.fromInteger $dNum_sgmdj eta_sgmdk; } in
        let {
          sat_sgmdn [Occ=Once] :: b_agj5P -> a_agj5O
          [LclId] =
              [x_sgmdl] \r [ds_sgmdm] x_sgmdl;
        } in  sat_sgmdn;

Data.Functor.Contravariant.$fNumOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>m] =
    [] \r [$dNum_sgmdo]
        let {
          sat_sgmdv [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B1]
                  Data.Functor.Contravariant.$fNumOp_$cfromInteger
                      $dNum_sgmdo eta_B1; } in
        let {
          sat_sgmdu [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp1 $dNum_sgmdo eta_B2 eta_B1; } in
        let {
          sat_sgmdt [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp2 $dNum_sgmdo eta_B2 eta_B1; } in
        let {
          sat_sgmds [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B1]
                  Data.Functor.Contravariant.$fNumOp_$cnegate
                      $dNum_sgmdo eta_B1; } in
        let {
          sat_sgmdr [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp3
                      $dNum_sgmdo eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgmdq [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp4
                      $dNum_sgmdo eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgmdp [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp5
                      $dNum_sgmdo eta_B3 eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_sgmdp
                         sat_sgmdq
                         sat_sgmdr
                         sat_sgmds
                         sat_sgmdt
                         sat_sgmdu
                         sat_sgmdv];

Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Num.Num (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgmdw]
        let {
          sat_sgmdx [Occ=Once,
                     Dmd=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>]
            :: GHC.Num.Num a_Xgj9j
          [LclId] =
              [$dFractional_sgmdw] \u []
                  GHC.Real.$p1Fractional $dFractional_sgmdw;
        } in  Data.Functor.Contravariant.$fNumOp sat_sgmdx;

Data.Functor.Contravariant.$fFractionalOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U))>m] =
    [] \r [$dFractional_sgmdy]
        let {
          sat_sgmdC [Occ=Once]
            :: GHC.Real.Rational
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgmdy] \r [eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp_$cfromRational
                      $dFractional_sgmdy eta_B1; } in
        let {
          sat_sgmdB [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgmdy] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp1
                      $dFractional_sgmdy eta_B2 eta_B1; } in
        let {
          sat_sgmdA [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgmdy] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp2
                      $dFractional_sgmdy eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgmdz [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m)
          [LclId] =
              [$dFractional_sgmdy] \u []
                  Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
                      $dFractional_sgmdy;
        } in 
          GHC.Real.C:Fractional [sat_sgmdz sat_sgmdA sat_sgmdB sat_sgmdC];

Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
  :: forall a b.
     GHC.Float.Floating a =>
     GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmdD]
        let {
          sat_sgmdE [Occ=Once,
                     Dmd=<L,U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U))>]
            :: GHC.Real.Fractional a_Xgj9H
          [LclId] =
              [$dFloating_sgmdD] \u [] GHC.Float.$p1Floating $dFloating_sgmdD;
        } in  Data.Functor.Contravariant.$fFractionalOp sat_sgmdE;

Data.Functor.Contravariant.$fFloatingOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Float.Floating a =>
     GHC.Float.Floating (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U)),1*U,C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),A,A,A,A)>] =
    [] \r [$dFloating_sgmdF]
        let {
          lvl7_sgmdG [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dFloating_sgmdF] \u [] GHC.Float.pi $dFloating_sgmdF; } in
        let {
          sat_sgme4 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1mexp
                      $dFloating_sgmdF eta_B1; } in
        let {
          sat_sgme3 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1pexp
                      $dFloating_sgmdF eta_B1; } in
        let {
          sat_sgme2 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$cexpm1
                      $dFloating_sgmdF eta_B1; } in
        let {
          sat_sgme1 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1p
                      $dFloating_sgmdF eta_B1; } in
        let {
          sat_sgme0 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp1
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdZ [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp2
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdY [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp3
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdX [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp4
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdW [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp5
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdV [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp6
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdU [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp7
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdT [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp8
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdS [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp9
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdR [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp10
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdQ [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp11
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdP [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp12
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdO [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp13
                      $dFloating_sgmdF eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgmdN [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp14
                      $dFloating_sgmdF eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgmdM [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp15
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdL [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp16
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdK [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp17
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdJ [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [lvl7_sgmdG] \r [eta_sgmdI] lvl7_sgmdG; } in
        let {
          sat_sgmdH [Occ=Once]
            :: GHC.Real.Fractional
                 (Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q)
          [LclId] =
              [$dFloating_sgmdF] \u []
                  Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
                      $dFloating_sgmdF;
        } in 
          GHC.Float.C:Floating [sat_sgmdH
                                sat_sgmdJ
                                sat_sgmdK
                                sat_sgmdL
                                sat_sgmdM
                                sat_sgmdN
                                sat_sgmdO
                                sat_sgmdP
                                sat_sgmdQ
                                sat_sgmdR
                                sat_sgmdS
                                sat_sgmdT
                                sat_sgmdU
                                sat_sgmdV
                                sat_sgmdW
                                sat_sgmdX
                                sat_sgmdY
                                sat_sgmdZ
                                sat_sgme0
                                sat_sgme1
                                sat_sgme2
                                sat_sgme3
                                sat_sgme4];

Data.Functor.Contravariant.$fCategoryTYPEOp1
  :: forall b c a.
     Data.Functor.Contravariant.Op b c
     -> Data.Functor.Contravariant.Op a b -> c -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgme5 ds1_sgme6 eta_B1]
        GHC.Base.. ds1_sgme6 ds_sgme5 eta_B1;

Data.Functor.Contravariant.$fCategoryTYPEOp [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Category.Category Data.Functor.Contravariant.Op
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Category.C:Category! [GHC.Base.id
                                                Data.Functor.Contravariant.$fCategoryTYPEOp1];

Data.Functor.Contravariant.$fMonoidEquivalence3
  :: forall a. a -> a -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgme7 ds1_sgme8] GHC.Types.True [];

Data.Functor.Contravariant.$fSemigroupEquivalence1 [Occ=LoopBreaker]
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> [Data.Functor.Contravariant.Equivalence a]
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgme9 ds1_sgmea]
        case ds1_sgmea of {
          [] -> b_sgme9;
          : c_sgmec [Occ=Once] cs_sgmed [Occ=Once] ->
              let {
                ds_sgmee [Occ=OnceL, Dmd=<L,C(C1(U))>]
                  :: Data.Functor.Contravariant.Equivalence a_XgjcG
                [LclId] =
                    [c_sgmec cs_sgmed] \u []
                        Data.Functor.Contravariant.$fSemigroupEquivalence1
                            c_sgmec cs_sgmed; } in
              let {
                sat_sgmei [Occ=Once] :: a_XgjcG -> a_XgjcG -> GHC.Types.Bool
                [LclId] =
                    [b_sgme9 ds_sgmee] \r [a1_sgmef b1_sgmeg]
                        case b_sgme9 a1_sgmef b1_sgmeg of {
                          GHC.Types.False -> GHC.Types.False [];
                          GHC.Types.True -> ds_sgmee a1_sgmef b1_sgmeg;
                        };
              } in  sat_sgmei;
        };

Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Functor.Contravariant.Equivalence a)
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgmej]
        case ds_sgmej of {
          GHC.Base.:| a1_sgmel [Occ=Once] as_sgmem [Occ=Once] ->
              Data.Functor.Contravariant.$fSemigroupEquivalence1
                  a1_sgmel as_sgmem;
        };

Data.Functor.Contravariant.$fMonoidEquivalence2
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmen ds1_sgmeo a1_sgmep b_sgmeq]
        case ds_sgmen a1_sgmep b_sgmeq of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> ds1_sgmeo a1_sgmep b_sgmeq;
        };

Data.Functor.Contravariant.$fSemigroupEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Equivalence a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fMonoidEquivalence2
                                         Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
                                         Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes];
Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgmes]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sgmes Data.Functor.Contravariant.$fSemigroupEquivalence;

Data.Functor.Contravariant.$fMonoidEquivalence1 [Occ=LoopBreaker]
  :: forall a.
     [Data.Functor.Contravariant.Equivalence a]
     -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmet eta_sgmeu eta1_sgmev]
        case ds_sgmet of {
          [] -> GHC.Types.True [];
          : y_sgmex [Occ=Once] ys_sgmey [Occ=Once] ->
              case y_sgmex eta_sgmeu eta1_sgmev of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Functor.Contravariant.$fMonoidEquivalence1
                        ys_sgmey eta_sgmeu eta1_sgmev;
              };
        };

Data.Functor.Contravariant.$fMonoidEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupEquivalence
                                      Data.Functor.Contravariant.$fMonoidEquivalence3
                                      Data.Functor.Contravariant.$fMonoidEquivalence2
                                      Data.Functor.Contravariant.$fMonoidEquivalence1];

Data.Functor.Contravariant.$fMonoidPredicate3
  :: forall a. a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgmeA] GHC.Types.True [];

Data.Functor.Contravariant.$fSemigroupPredicate1 [Occ=LoopBreaker]
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> [Data.Functor.Contravariant.Predicate a]
     -> Data.Functor.Contravariant.Predicate a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgmeB ds1_sgmeC]
        case ds1_sgmeC of {
          [] -> b_sgmeB;
          : c_sgmeE [Occ=Once] cs_sgmeF [Occ=Once] ->
              let {
                ds_sgmeG [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Data.Functor.Contravariant.Predicate a_Xgje6
                [LclId] =
                    [c_sgmeE cs_sgmeF] \u []
                        Data.Functor.Contravariant.$fSemigroupPredicate1
                            c_sgmeE cs_sgmeF; } in
              let {
                sat_sgmeJ [Occ=Once] :: a_Xgje6 -> GHC.Types.Bool
                [LclId] =
                    [b_sgmeB ds_sgmeG] \r [a1_sgmeH]
                        case b_sgmeB a1_sgmeH of {
                          GHC.Types.False -> GHC.Types.False [];
                          GHC.Types.True -> ds_sgmeG a1_sgmeH;
                        };
              } in  sat_sgmeJ;
        };

Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Functor.Contravariant.Predicate a)
     -> Data.Functor.Contravariant.Predicate a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgmeK]
        case ds_sgmeK of {
          GHC.Base.:| a1_sgmeM [Occ=Once] as_sgmeN [Occ=Once] ->
              Data.Functor.Contravariant.$fSemigroupPredicate1 a1_sgmeM as_sgmeN;
        };

Data.Functor.Contravariant.$fMonoidPredicate2
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmeO ds1_sgmeP a1_sgmeQ]
        case ds_sgmeO a1_sgmeQ of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> ds1_sgmeP a1_sgmeQ;
        };

Data.Functor.Contravariant.$fSemigroupPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Predicate a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fMonoidPredicate2
                                         Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
                                         Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes];
Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgmeS]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sgmeS Data.Functor.Contravariant.$fSemigroupPredicate;

Data.Functor.Contravariant.$fMonoidPredicate1 [Occ=LoopBreaker]
  :: forall a.
     [Data.Functor.Contravariant.Predicate a] -> a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmeT eta_sgmeU]
        case ds_sgmeT of {
          [] -> GHC.Types.True [];
          : y_sgmeW [Occ=Once] ys_sgmeX [Occ=Once] ->
              case y_sgmeW eta_sgmeU of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Functor.Contravariant.$fMonoidPredicate1 ys_sgmeX eta_sgmeU;
              };
        };

Data.Functor.Contravariant.$fMonoidPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Predicate a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupPredicate
                                      Data.Functor.Contravariant.$fMonoidPredicate3
                                      Data.Functor.Contravariant.$fMonoidPredicate2
                                      Data.Functor.Contravariant.$fMonoidPredicate1];

Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
  :: forall a b. (a -> b) -> Data.Proxy.Proxy b -> Data.Proxy.Proxy a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgmeZ ds1_sgmf0] Data.Proxy.Proxy [];

Data.Functor.Contravariant.$fContravariantProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant Data.Proxy.Proxy
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantProxy_$c>$];

Data.Functor.Contravariant.$fContravariantCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgmf1 $dContravariant_sgmf2 f1_sgmf3 ds_sgmf4]
        let {
          sat_sgmf5 [Occ=Once] :: g_agjbQ b_agjbX -> g_agjbQ a_agjbW
          [LclId] =
              [$dContravariant_sgmf2 f1_sgmf3] \u []
                  Data.Functor.Contravariant.contramap
                      $dContravariant_sgmf2 f1_sgmf3;
        } in  GHC.Base.fmap $dFunctor_sgmf1 sat_sgmf5 ds_sgmf4;

Data.Functor.Contravariant.$fContravariantCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgmf6 $dContravariant_sgmf7]
        let {
          sat_sgmf9 [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW a
          [LclId] =
              [$dFunctor_sgmf6 $dContravariant_sgmf7] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantCompose1
                      $dFunctor_sgmf6 $dContravariant_sgmf7 eta_B2 eta_B1; } in
        let {
          sat_sgmf8 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW a
          [LclId] =
              [$dFunctor_sgmf6 $dContravariant_sgmf7] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantCompose2
                      $dFunctor_sgmf6 $dContravariant_sgmf7 eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmf8 sat_sgmf9];

Data.Functor.Contravariant.$fContravariantConst2
  :: forall a1 a2 b.
     (a2 -> b)
     -> Data.Functor.Const.Const a1 b -> Data.Functor.Const.Const a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmfa ds1_sgmfb] ds1_sgmfb;

Data.Functor.Contravariant.$fContravariantConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Const.Const a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantConst2
                                                               Data.Functor.Contravariant.$fContravariantConst1];

Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmfc
           $dContravariant1_sgmfd
           f1_sgmfe
           ds_sgmff]
        case ds_sgmff of {
          Data.Functor.Product.Pair a1_sgmfh [Occ=Once]
                                    b1_sgmfi [Occ=Once] ->
              let {
                sat_sgmfk [Occ=Once] :: g_agjcM a_agjcS
                [LclId] =
                    [$dContravariant1_sgmfd f1_sgmfe b1_sgmfi] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgmfd f1_sgmfe b1_sgmfi; } in
              let {
                sat_sgmfj [Occ=Once] :: f_agjcL a_agjcS
                [LclId] =
                    [$dContravariant_sgmfc f1_sgmfe a1_sgmfh] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgmfc f1_sgmfe a1_sgmfh;
              } in  Data.Functor.Product.Pair [sat_sgmfj sat_sgmfk];
        };

Data.Functor.Contravariant.$fContravariantProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgmfl $dContravariant1_sgmfm]
        let {
          sat_sgmfo [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Product.Product f_agjcL g_agjcM b
               -> Data.Functor.Product.Product f_agjcL g_agjcM a
          [LclId] =
              [$dContravariant_sgmfl $dContravariant1_sgmfm] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantProduct_$c>$
                      $dContravariant_sgmfl $dContravariant1_sgmfm eta_B2 eta_B1; } in
        let {
          sat_sgmfn [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Product.Product f_agjcL g_agjcM b
               -> Data.Functor.Product.Product f_agjcL g_agjcM a
          [LclId] =
              [$dContravariant_sgmfl $dContravariant1_sgmfm] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
                      $dContravariant_sgmfl $dContravariant1_sgmfm eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmfn sat_sgmfo];

Data.Functor.Contravariant.$fContravariantSum_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmfp
           $dContravariant1_sgmfq
           f1_sgmfr
           ds_sgmfs]
        case ds_sgmfs of {
          Data.Functor.Sum.InL xs_sgmfu [Occ=Once] ->
              let {
                sat_sgmfv [Occ=Once] :: f_agjdk a_agjdr
                [LclId] =
                    [$dContravariant_sgmfp f1_sgmfr xs_sgmfu] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgmfp f1_sgmfr xs_sgmfu;
              } in  Data.Functor.Sum.InL [sat_sgmfv];
          Data.Functor.Sum.InR ys_sgmfw [Occ=Once] ->
              let {
                sat_sgmfx [Occ=Once] :: g_agjdl a_agjdr
                [LclId] =
                    [$dContravariant1_sgmfq f1_sgmfr ys_sgmfw] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgmfq f1_sgmfr ys_sgmfw;
              } in  Data.Functor.Sum.InR [sat_sgmfx];
        };

Data.Functor.Contravariant.$fContravariantSum_$c>$
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmfy
           $dContravariant1_sgmfz
           x_sgmfA
           eta_sgmfB]
        let {
          sat_sgmfD [Occ=Once] :: a_agjdP -> b_agjdO
          [LclId] =
              [x_sgmfA] \r [ds_sgmfC] x_sgmfA;
        } in 
          Data.Functor.Contravariant.$fContravariantSum_$ccontramap
              $dContravariant_sgmfy $dContravariant1_sgmfz sat_sgmfD eta_sgmfB;

Data.Functor.Contravariant.$fContravariantSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgmfE $dContravariant1_sgmfF]
        let {
          sat_sgmfH [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl a
          [LclId] =
              [$dContravariant_sgmfE $dContravariant1_sgmfF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantSum_$c>$
                      $dContravariant_sgmfE $dContravariant1_sgmfF eta_B2 eta_B1; } in
        let {
          sat_sgmfG [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl a
          [LclId] =
              [$dContravariant_sgmfE $dContravariant1_sgmfF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantSum_$ccontramap
                      $dContravariant_sgmfE $dContravariant1_sgmfF eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmfG sat_sgmfH];

Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> (GHC.Generics.:+:) f g b -> (GHC.Generics.:+:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmfI
           $dContravariant1_sgmfJ
           f1_sgmfK
           ds_sgmfL]
        case ds_sgmfL of {
          GHC.Generics.L1 xs_sgmfN [Occ=Once] ->
              let {
                sat_sgmfO [Occ=Once] :: f_agjdX a_agje4
                [LclId] =
                    [$dContravariant_sgmfI f1_sgmfK xs_sgmfN] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgmfI f1_sgmfK xs_sgmfN;
              } in  GHC.Generics.L1 [sat_sgmfO];
          GHC.Generics.R1 ys_sgmfP [Occ=Once] ->
              let {
                sat_sgmfQ [Occ=Once] :: g_agjdY a_agje4
                [LclId] =
                    [$dContravariant1_sgmfJ f1_sgmfK ys_sgmfP] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgmfJ f1_sgmfK ys_sgmfP;
              } in  GHC.Generics.R1 [sat_sgmfQ];
        };

Data.Functor.Contravariant.$fContravariant:+:_$c>$
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> (GHC.Generics.:+:) f g b -> (GHC.Generics.:+:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmfR
           $dContravariant1_sgmfS
           x_sgmfT
           eta_sgmfU]
        let {
          sat_sgmfW [Occ=Once] :: a_agjes -> b_agjer
          [LclId] =
              [x_sgmfT] \r [ds_sgmfV] x_sgmfT;
        } in 
          Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
              $dContravariant_sgmfR $dContravariant1_sgmfS sat_sgmfW eta_sgmfU;

Data.Functor.Contravariant.$fContravariant:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgmfX $dContravariant1_sgmfY]
        let {
          sat_sgmg0 [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY a
          [LclId] =
              [$dContravariant_sgmfX $dContravariant1_sgmfY] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:+:_$c>$
                      $dContravariant_sgmfX $dContravariant1_sgmfY eta_B2 eta_B1; } in
        let {
          sat_sgmfZ [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:+:) f_agjdX g_agjdY b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY a
          [LclId] =
              [$dContravariant_sgmfX $dContravariant1_sgmfY] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
                      $dContravariant_sgmfX $dContravariant1_sgmfY eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmfZ sat_sgmg0];

Data.Functor.Contravariant.$fContravariant:.:2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall a b. (a -> b) -> (GHC.Generics.:.:) f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgmg1 $dContravariant_sgmg2 f1_sgmg3 ds_sgmg4]
        let {
          sat_sgmg5 [Occ=Once] :: g_agjeB b_agjeI -> g_agjeB a_agjeH
          [LclId] =
              [$dContravariant_sgmg2 f1_sgmg3] \u []
                  Data.Functor.Contravariant.contramap
                      $dContravariant_sgmg2 f1_sgmg3;
        } in  GHC.Base.fmap $dFunctor_sgmg1 sat_sgmg5 ds_sgmg4;

Data.Functor.Contravariant.$fContravariant:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgmg6 $dContravariant_sgmg7]
        let {
          sat_sgmg9 [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS a
          [LclId] =
              [$dFunctor_sgmg6 $dContravariant_sgmg7] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:.:1
                      $dFunctor_sgmg6 $dContravariant_sgmg7 eta_B2 eta_B1; } in
        let {
          sat_sgmg8 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS a
          [LclId] =
              [$dFunctor_sgmg6 $dContravariant_sgmg7] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:.:2
                      $dFunctor_sgmg6 $dContravariant_sgmg7 eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmg8 sat_sgmg9];

Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmga
           $dContravariant1_sgmgb
           f1_sgmgc
           ds_sgmgd]
        case ds_sgmgd of {
          GHC.Generics.:*: xs_sgmgf [Occ=Once] ys_sgmgg [Occ=Once] ->
              let {
                sat_sgmgi [Occ=Once] :: g_agjfb a_agjfh
                [LclId] =
                    [$dContravariant1_sgmgb f1_sgmgc ys_sgmgg] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgmgb f1_sgmgc ys_sgmgg; } in
              let {
                sat_sgmgh [Occ=Once] :: f_agjfa a_agjfh
                [LclId] =
                    [$dContravariant_sgmga f1_sgmgc xs_sgmgf] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgmga f1_sgmgc xs_sgmgf;
              } in  GHC.Generics.:*: [sat_sgmgh sat_sgmgi];
        };

Data.Functor.Contravariant.$fContravariant:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgmgj $dContravariant1_sgmgk]
        let {
          sat_sgmgm [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb a
          [LclId] =
              [$dContravariant_sgmgj $dContravariant1_sgmgk] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:*:_$c>$
                      $dContravariant_sgmgj $dContravariant1_sgmgk eta_B2 eta_B1; } in
        let {
          sat_sgmgl [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:*:) f_agjfa g_agjfb b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb a
          [LclId] =
              [$dContravariant_sgmgj $dContravariant1_sgmgk] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
                      $dContravariant_sgmgj $dContravariant1_sgmgk eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmgl sat_sgmgm];

Data.Functor.Contravariant.$fContravariantK3
  :: forall i c a b.
     (a -> b) -> GHC.Generics.K1 i c b -> GHC.Generics.K1 i c b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmgn ds1_sgmgo] ds1_sgmgo;

Data.Functor.Contravariant.$fContravariantK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c.
     Data.Functor.Contravariant.Contravariant (GHC.Generics.K1 i c)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantK3
                                                               Data.Functor.Contravariant.$fContravariantK2];

Data.Functor.Contravariant.$fContravariantU1_$ccontramap
  :: forall a b. (a -> b) -> GHC.Generics.U1 b -> GHC.Generics.U1 a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgmgp ds1_sgmgq] GHC.Generics.U1 [];

Data.Functor.Contravariant.$fContravariantU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant GHC.Generics.U1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantU1_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantU1_$c>$];

Data.Functor.Contravariant.$fContravariantV1_$ccontramap
  :: forall a b. (a -> b) -> GHC.Generics.V1 b -> GHC.Generics.V1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sgmgr x_sgmgs] x_sgmgs;

Data.Functor.Contravariant.$fContravariantV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant GHC.Generics.V1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantV1_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantV1_$c>$];

lvl2_rgjLt
  :: forall a b1.
     GHC.Real.Integral b1 =>
     b1 -> (a -> GHC.Types.Ordering) -> a -> GHC.Types.Ordering
[GblId, Arity=4, Str=<L,U><L,U><L,1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgmgu n_sgmgv f_sgmgw e_sgmgx]
        let {
          sat_sgmgy [Occ=Once] :: GHC.Types.Ordering
          [LclId] =
              [f_sgmgw e_sgmgx] \u [] f_sgmgw e_sgmgx;
        } in 
          GHC.Base.$fSemigroupOrdering_$cstimes
              $dIntegral_sgmgu n_sgmgv sat_sgmgy;

lvl3_rgjLu
  :: forall a.
     GHC.Base.NonEmpty (a -> GHC.Types.Ordering)
     -> a -> GHC.Types.Ordering
[GblId, Arity=1, Str=<S(LS),1*U(U,1*U)>, Unf=OtherCon []] =
    [] \r [w1_sgmgz]
        case w1_sgmgz of {
          GHC.Base.:| ww1_sgmgB [Occ=Once] ww2_sgmgC [Occ=Once] ->
              GHC.Base.$w$csconcat3
                  GHC.Base.$fSemigroupOrdering ww1_sgmgB ww2_sgmgC;
        };

lvl4_rgjLv
  :: forall a.
     (a -> GHC.Types.Ordering)
     -> (a -> GHC.Types.Ordering) -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgmgD g_sgmgE x_sgmgF]
        case f_sgmgD x_sgmgF of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> g_sgmgE x_sgmgF;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (a -> GHC.Types.Ordering)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [lvl4_rgjLv
                                         lvl3_rgjLu
                                         lvl2_rgjLt];

Data.Functor.Contravariant.$fSemigroupComparison2
  :: forall a.
     GHC.Base.NonEmpty (a -> a -> GHC.Types.Ordering)
     -> a -> a -> GHC.Types.Ordering
[GblId, Arity=1, Str=<S(LS),1*U(U,1*U)>, Unf=OtherCon []] =
    [] \r [w1_sgmgH]
        case w1_sgmgH of {
          GHC.Base.:| ww1_sgmgJ [Occ=Once] ww2_sgmgK [Occ=Once] ->
              GHC.Base.$w$csconcat3
                  Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
                  ww1_sgmgJ
                  ww2_sgmgK;
        };

Data.Functor.Contravariant.$fSemigroupComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Comparison a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fSemigroupComparison3
                                         Data.Functor.Contravariant.$fSemigroupComparison2
                                         Data.Functor.Contravariant.$fSemigroupComparison1];

lvl5_rgjLw :: forall a. a -> GHC.Types.Ordering
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgmgL] GHC.Types.EQ [];

lvl6_rgjLx
  :: forall a. [a -> GHC.Types.Ordering] -> a -> GHC.Types.Ordering
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fMonoid(->)_$cmconcat
            GHC.Base.$fMonoidOrdering eta_B2 eta_B1;

Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (a -> GHC.Types.Ordering)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
                                      lvl5_rgjLw
                                      lvl4_rgjLv
                                      lvl6_rgjLx];

Data.Functor.Contravariant.$fMonoidComparison1
  :: forall a.
     [a -> a -> GHC.Types.Ordering] -> a -> a -> GHC.Types.Ordering
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fMonoid(->)_$cmconcat
            Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)
            eta_B2
            eta_B1;

Data.Functor.Contravariant.$fMonoidComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupComparison
                                      Data.Functor.Contravariant.$fMonoidComparison3
                                      Data.Functor.Contravariant.$fMonoidComparison2
                                      Data.Functor.Contravariant.$fMonoidComparison1];

Data.Functor.Contravariant.C:Contravariant
  :: forall (f :: * -> *).
     (forall a b. (a -> b) -> f b -> f a)
     -> (forall b a. b -> f b -> f a)
     -> Data.Functor.Contravariant.Contravariant f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Functor.Contravariant.C:Contravariant [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:12:16.645442995 UTC

Data.Functor.Contravariant.contramap
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall a b. (a -> b) -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sgm8b]
        case v_sgm8b of {
          Data.Functor.Contravariant.C:Contravariant v_sgm8d [Occ=Once]
                                                     _ [Occ=Dead] ->
              v_sgm8d;
        };

Data.Functor.Contravariant.>$
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall b a. b -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sgm8f]
        case v_sgm8f of {
          Data.Functor.Contravariant.C:Contravariant _ [Occ=Dead]
                                                     v_sgm8i [Occ=Once] ->
              v_sgm8i;
        };

Data.Functor.Contravariant.$tc'Op3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Op"#;

Data.Functor.Contravariant.$tc'Op2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Op3];

Data.Functor.Contravariant.$tcOp2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Op"#;

Data.Functor.Contravariant.$tcOp1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcOp2];

Data.Functor.Contravariant.$tc'Equivalence3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Equivalence"#;

Data.Functor.Contravariant.$tc'Equivalence2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Equivalence3];

Data.Functor.Contravariant.$tcEquivalence2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Equivalence"#;

Data.Functor.Contravariant.$tcEquivalence1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcEquivalence2];

Data.Functor.Contravariant.$tc'Comparison3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Comparison"#;

Data.Functor.Contravariant.$tc'Comparison2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Comparison3];

Data.Functor.Contravariant.$tcComparison2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Comparison"#;

Data.Functor.Contravariant.$tcComparison1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcComparison2];

Data.Functor.Contravariant.$tc'Predicate3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Predicate"#;

Data.Functor.Contravariant.$tc'Predicate2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tc'Predicate3];

Data.Functor.Contravariant.$tcPredicate2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Predicate"#;

Data.Functor.Contravariant.$tcPredicate1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcPredicate2];

Data.Functor.Contravariant.$tcContravariant3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Contravariant"#;

Data.Functor.Contravariant.$tcContravariant2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$tcContravariant3];

$krep_rgjLa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_rgjLb :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgjLa GHC.Types.[]];

$krep2_rgjLc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep3_rgjLd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_rgjLc $krep_rgjLa];

$krep4_rgjLe :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgjLc GHC.Types.[]];

$krep5_rgjLf :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgjLa $krep4_rgjLe];

$krep6_rgjLg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep7_rgjLh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep6_rgjLg];

$krep8_rgjLi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep7_rgjLh];

$krep9_rgjLj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcOrdering
                                              GHC.Types.[]];

$krep10_rgjLk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep9_rgjLj];

$krep11_rgjLl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgjLa $krep10_rgjLk];

$krep12_rgjLm :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Functor.Contravariant.$tcContravariant1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep12_rgjLm];

Data.Functor.Contravariant.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor.Contravariant"#;

Data.Functor.Contravariant.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$trModule2];

Data.Functor.Contravariant.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.Contravariant.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.Contravariant.$trModule4];

Data.Functor.Contravariant.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.Contravariant.$trModule3
                                     Data.Functor.Contravariant.$trModule1];

Data.Functor.Contravariant.$tcContravariant :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1944710495430526909##
                                    15571985404928937498##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcContravariant2
                                    0#
                                    Data.Functor.Contravariant.$tcContravariant1];

Data.Functor.Contravariant.$tcPredicate :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9927645946720114643##
                                    17478425232619398566##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcPredicate1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_rgjLn :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcPredicate
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Predicate1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_rgjLh $krep13_rgjLn];

Data.Functor.Contravariant.$tc'Predicate :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10560326927625189840##
                                    8988710799443424590##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Predicate2
                                    1#
                                    Data.Functor.Contravariant.$tc'Predicate1];

Data.Functor.Contravariant.$tcComparison :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8128667979445988110##
                                    9034904213662261762##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcComparison1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep14_rgjLo :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcComparison
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Comparison1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_rgjLl $krep14_rgjLo];

Data.Functor.Contravariant.$tc'Comparison :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11047345948274903716##
                                    12707949450550295743##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Comparison2
                                    1#
                                    Data.Functor.Contravariant.$tc'Comparison1];

Data.Functor.Contravariant.$tcEquivalence :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9646573079009549553##
                                    12303965936368510845##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcEquivalence1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep15_rgjLp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcEquivalence
                                              $krep1_rgjLb];

Data.Functor.Contravariant.$tc'Equivalence1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_rgjLi $krep15_rgjLp];

Data.Functor.Contravariant.$tc'Equivalence :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5667737350508967909##
                                    15093804341312440267##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Equivalence2
                                    1#
                                    Data.Functor.Contravariant.$tc'Equivalence1];

Data.Functor.Contravariant.$tcOp :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13209106975460307324##
                                    7546944290236364550##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tcOp1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep16_rgjLq :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Functor.Contravariant.$tcOp
                                              $krep5_rgjLf];

Data.Functor.Contravariant.$tc'Op1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rgjLd $krep16_rgjLq];

Data.Functor.Contravariant.$tc'Op :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12479862397628491530##
                                    1381176546464080972##
                                    Data.Functor.Contravariant.$trModule
                                    Data.Functor.Contravariant.$tc'Op2
                                    2#
                                    Data.Functor.Contravariant.$tc'Op1];

Data.Functor.Contravariant.comparisonEquivalence1
  :: forall a.
     Data.Functor.Contravariant.Comparison a -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgm8j a1_sgm8k b_sgm8l]
        case ds_sgm8j a1_sgm8k b_sgm8l of {
          __DEFAULT -> GHC.Types.False [];
          GHC.Types.EQ -> GHC.Types.True [];
        };

Data.Functor.Contravariant.comparisonEquivalence
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Functor.Contravariant.comparisonEquivalence1
            eta_B3 eta_B2 eta_B1;

Data.Functor.Contravariant.defaultEquivalence
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Classes.== eta_B1;

Data.Functor.Contravariant.defaultComparison
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Functor.Contravariant.Comparison a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Classes.compare eta_B1;

Data.Functor.Contravariant.>$$<
  :: forall (f :: * -> *) b a.
     Data.Functor.Contravariant.Contravariant f =>
     f b -> (a -> b) -> f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgm8n eta_sgm8o eta1_sgm8p]
        Data.Functor.Contravariant.contramap
            $dContravariant_sgm8n eta1_sgm8p eta_sgm8o;

Data.Functor.Contravariant.>$<
  :: forall (f :: * -> *) a b.
     Data.Functor.Contravariant.Contravariant f =>
     (a -> b) -> f b -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgm8q]
        Data.Functor.Contravariant.contramap $dContravariant_sgm8q;

Data.Functor.Contravariant.phantom
  :: forall (f :: * -> *) a b.
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant f) =>
     f a -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)))><S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgm8r $dContravariant_sgm8s x_sgm8t]
        let {
          sat_sgm8u [Occ=Once] :: f_agiQT ()
          [LclId] =
              [$dFunctor_sgm8r x_sgm8t] \u []
                  GHC.Base.<$ $dFunctor_sgm8r GHC.Tuple.() x_sgm8t;
        } in 
          Data.Functor.Contravariant.>$
              $dContravariant_sgm8s GHC.Tuple.() sat_sgm8u;

Data.Functor.Contravariant.$<
  :: forall (f :: * -> *) b a.
     Data.Functor.Contravariant.Contravariant f =>
     f b -> b -> f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgm8v eta_sgm8w eta1_sgm8x]
        Data.Functor.Contravariant.>$
            $dContravariant_sgm8v eta1_sgm8x eta_sgm8w;

Data.Functor.Contravariant.$fContravariantOp1
  :: forall a1 b a2.
     b -> Data.Functor.Contravariant.Op a1 b -> a2 -> a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgm8y eta_sgm8z eta1_sgm8A] eta_sgm8z x_sgm8y;

Data.Functor.Contravariant.$fContravariantOp2
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Functor.Contravariant.Op a1 b -> a2 -> a1
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f_sgm8B g_sgm8C eta_B1] GHC.Base.. g_sgm8C f_sgm8B eta_B1;

Data.Functor.Contravariant.$fContravariantOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Contravariant.Op a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantOp2
                                                               Data.Functor.Contravariant.$fContravariantOp1];

Data.Functor.Contravariant.getOp1
  :: forall a b.
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgm8D] ds_sgm8D;

Data.Functor.Contravariant.getOp
  :: forall a b. Data.Functor.Contravariant.Op a b -> b -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getOp1 eta_B1;

Data.Functor.Contravariant.$fContravariantEquivalence1
  :: forall b a.
     b
     -> Data.Functor.Contravariant.Equivalence b
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),1*C1(C1(U))><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgm8E eta_sgm8F eta1_sgm8G eta2_sgm8H]
        eta_sgm8F x_sgm8E x_sgm8E;

Data.Functor.Contravariant.$fContravariantEquivalence2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Equivalence b
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgm8I g_sgm8J x_sgm8K y_sgm8L]
        let {
          sat_sgm8N [Occ=Once] :: b_agj9q
          [LclId] =
              [f_sgm8I y_sgm8L] \u [] f_sgm8I y_sgm8L; } in
        let {
          sat_sgm8M [Occ=Once] :: b_agj9q
          [LclId] =
              [f_sgm8I x_sgm8K] \u [] f_sgm8I x_sgm8K;
        } in  g_sgm8J sat_sgm8M sat_sgm8N;

Data.Functor.Contravariant.$fContravariantEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Equivalence
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantEquivalence2
                                                               Data.Functor.Contravariant.$fContravariantEquivalence1];

Data.Functor.Contravariant.getEquivalence1
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgm8O] ds_sgm8O;

Data.Functor.Contravariant.getEquivalence
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> a -> a -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getEquivalence1 eta_B1;

Data.Functor.Contravariant.$fContravariantComparison1
  :: forall b a.
     b
     -> Data.Functor.Contravariant.Comparison b
     -> a
     -> a
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),1*C1(C1(U))><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgm8P eta_sgm8Q eta1_sgm8R eta2_sgm8S]
        eta_sgm8Q x_sgm8P x_sgm8P;

Data.Functor.Contravariant.$fContravariantComparison2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Comparison b
     -> a
     -> a
     -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgm8T g_sgm8U x_sgm8V y_sgm8W]
        let {
          sat_sgm8Y [Occ=Once] :: b_agj9P
          [LclId] =
              [f_sgm8T y_sgm8W] \u [] f_sgm8T y_sgm8W; } in
        let {
          sat_sgm8X [Occ=Once] :: b_agj9P
          [LclId] =
              [f_sgm8T x_sgm8V] \u [] f_sgm8T x_sgm8V;
        } in  g_sgm8U sat_sgm8X sat_sgm8Y;

Data.Functor.Contravariant.$fContravariantComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Comparison
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantComparison2
                                                               Data.Functor.Contravariant.$fContravariantComparison1];

Data.Functor.Contravariant.getComparison1
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> Data.Functor.Contravariant.Comparison a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgm8Z] ds_sgm8Z;

Data.Functor.Contravariant.getComparison
  :: forall a.
     Data.Functor.Contravariant.Comparison a
     -> a -> a -> GHC.Types.Ordering
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getComparison1 eta_B1;

Data.Functor.Contravariant.$fContravariantPredicate1
  :: forall b a.
     b -> Data.Functor.Contravariant.Predicate b -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgm90 eta_sgm91 eta1_sgm92] eta_sgm91 x_sgm90;

Data.Functor.Contravariant.$fContravariantPredicate2
  :: forall a b.
     (a -> b)
     -> Data.Functor.Contravariant.Predicate b -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [f_sgm93 g_sgm94 eta_B1] GHC.Base.. g_sgm94 f_sgm93 eta_B1;

Data.Functor.Contravariant.$fContravariantPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant
       Data.Functor.Contravariant.Predicate
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantPredicate2
                                                               Data.Functor.Contravariant.$fContravariantPredicate1];

Data.Functor.Contravariant.getPredicate1
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgm95] ds_sgm95;

Data.Functor.Contravariant.getPredicate
  :: forall a.
     Data.Functor.Contravariant.Predicate a -> a -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Functor.Contravariant.getPredicate1 eta_B1;

Data.Functor.Contravariant.$fContravariantV1_$c>$
  :: forall b a. b -> GHC.Generics.V1 b -> GHC.Generics.V1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [x_sgm96 x1_sgm97] x1_sgm97;

Data.Functor.Contravariant.$fContravariantU1_$c>$
  :: forall b a. b -> GHC.Generics.U1 b -> GHC.Generics.U1 a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sgm99 ds_sgm9a] GHC.Generics.U1 [];

Data.Functor.Contravariant.$fContravariantK2
  :: forall b c i.
     b -> GHC.Generics.K1 i c b -> GHC.Generics.K1 i c b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgm9b ds_sgm9c] ds_sgm9c;

Data.Functor.Contravariant.$fContravariant:*:_$c>$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgm9d w1_sgm9e w2_sgm9f w3_sgm9g]
        case w3_sgm9g of {
          GHC.Generics.:*: ww1_sgm9i [Occ=Once] ww2_sgm9j [Occ=Once] ->
              let {
                f1_sgm9k :: a_sgjEw -> b_sgjEv
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sgm9f] \r [ds_sgm9l] w2_sgm9f; } in
              let {
                sat_sgm9n [Occ=Once] :: g_sgjEs a_sgjEw
                [LclId] =
                    [w1_sgm9e ww2_sgm9j f1_sgm9k] \u []
                        Data.Functor.Contravariant.contramap
                            w1_sgm9e f1_sgm9k ww2_sgm9j; } in
              let {
                sat_sgm9m [Occ=Once] :: f_sgjEr a_sgjEw
                [LclId] =
                    [w_sgm9d ww1_sgm9i f1_sgm9k] \u []
                        Data.Functor.Contravariant.contramap w_sgm9d f1_sgm9k ww1_sgm9i;
              } in  GHC.Generics.:*: [sat_sgm9m sat_sgm9n];
        };

Data.Functor.Contravariant.$fContravariant:.:1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall b a. b -> (GHC.Generics.:.:) f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgm9o $dContravariant_sgm9p x_sgm9q eta_sgm9r]
        let {
          sat_sgm9u [Occ=Once] :: g_XgjkT b_agjf1 -> g_XgjkT a_agjf2
          [LclId] =
              [$dContravariant_sgm9p x_sgm9q] \u []
                  let {
                    sat_sgm9t [Occ=Once] :: a_agjf2 -> b_agjf1
                    [LclId] =
                        [x_sgm9q] \r [ds_sgm9s] x_sgm9q;
                  } in 
                    Data.Functor.Contravariant.contramap
                        $dContravariant_sgm9p sat_sgm9t;
        } in  GHC.Base.fmap $dFunctor_sgm9o sat_sgm9u eta_sgm9r;

Data.Functor.Contravariant.$fContravariantProduct_$c>$ [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgm9v w1_sgm9w w2_sgm9x w3_sgm9y]
        case w3_sgm9y of {
          Data.Functor.Product.Pair ww1_sgm9A [Occ=Once]
                                    ww2_sgm9B [Occ=Once] ->
              let {
                f1_sgm9C :: a_sgjEN -> b_sgjEM
                [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
                    [w2_sgm9x] \r [ds_sgm9D] w2_sgm9x; } in
              let {
                sat_sgm9F [Occ=Once] :: g_sgjEJ a_sgjEN
                [LclId] =
                    [w1_sgm9w ww2_sgm9B f1_sgm9C] \u []
                        Data.Functor.Contravariant.contramap
                            w1_sgm9w f1_sgm9C ww2_sgm9B; } in
              let {
                sat_sgm9E [Occ=Once] :: f_sgjEI a_sgjEN
                [LclId] =
                    [w_sgm9v ww1_sgm9A f1_sgm9C] \u []
                        Data.Functor.Contravariant.contramap w_sgm9v f1_sgm9C ww1_sgm9A;
              } in  Data.Functor.Product.Pair [sat_sgm9E sat_sgm9F];
        };

Data.Functor.Contravariant.$fContravariantConst1
  :: forall b a.
     b -> Data.Functor.Const.Const a b -> Data.Functor.Const.Const a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgm9G ds_sgm9H] ds_sgm9H;

Data.Functor.Contravariant.$fContravariantCompose1
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall b a. b -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgm9I $dContravariant_sgm9J x_sgm9K eta_sgm9L]
        let {
          sat_sgm9O [Occ=Once] :: g_XgjhX b_agjcg -> g_XgjhX a_agjch
          [LclId] =
              [$dContravariant_sgm9J x_sgm9K] \u []
                  let {
                    sat_sgm9N [Occ=Once] :: a_agjch -> b_agjcg
                    [LclId] =
                        [x_sgm9K] \r [ds_sgm9M] x_sgm9K;
                  } in 
                    Data.Functor.Contravariant.contramap
                        $dContravariant_sgm9J sat_sgm9N;
        } in  GHC.Base.fmap $dFunctor_sgm9I sat_sgm9O eta_sgm9L;

Data.Functor.Contravariant.$fContravariantProxy_$c>$
  :: forall b a. b -> Data.Proxy.Proxy b -> Data.Proxy.Proxy a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sgm9P ds_sgm9Q] Data.Proxy.Proxy [];

Data.Functor.Contravariant.$dm>$
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     forall b a. b -> f b -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgm9R eta_sgm9S]
        let {
          sat_sgm9U [Occ=Once] :: a_agiRb -> b_agiRa
          [LclId] =
              [eta_sgm9S] \r [ds_sgm9T] eta_sgm9S;
        } in 
          Data.Functor.Contravariant.contramap
              $dContravariant_sgm9R sat_sgm9U;

Data.Functor.Contravariant.$fSemigroupOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sgm9V]
        let {
          sat_sgm9Y [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgm9V] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$cstimes
                      $dSemigroup_sgm9V eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgm9X [Occ=Once]
            :: GHC.Base.NonEmpty
                 (Data.Functor.Contravariant.Op a_agiSm b_agiSn)
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgm9V] \r [eta_B1]
                  GHC.Base.$fSemigroup(->)_$csconcat $dSemigroup_sgm9V eta_B1; } in
        let {
          sat_sgm9W [Occ=Once]
            :: Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
               -> Data.Functor.Contravariant.Op a_agiSm b_agiSn
          [LclId] =
              [$dSemigroup_sgm9V] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$c<>
                      $dSemigroup_sgm9V eta_B3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sgm9W sat_sgm9X sat_sgm9Y];

Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid
  :: forall a b.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgm9Z]
        let {
          sat_sgma0 [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_XgiXu
          [LclId] =
              [$dMonoid_sgm9Z] \u [] GHC.Base.$p1Monoid $dMonoid_sgm9Z;
        } in  Data.Functor.Contravariant.$fSemigroupOp sat_sgma0;

Data.Functor.Contravariant.$fMonoidOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_sgma1]
        let {
          lvl7_sgma2 [Occ=OnceL] :: a_XgiXv
          [LclId] =
              [$dMonoid_sgma1] \u [] GHC.Base.mempty $dMonoid_sgma1; } in
        let {
          sat_sgma7 [Occ=Once]
            :: [Data.Functor.Contravariant.Op a_XgiXv b_XgiXx]
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [$dMonoid_sgma1] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmconcat $dMonoid_sgma1 eta_B2 eta_B1; } in
        let {
          sat_sgma6 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
               -> Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [$dMonoid_sgma1] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmappend
                      $dMonoid_sgma1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgma5 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_XgiXv b_XgiXx
          [LclId] =
              [lvl7_sgma2] \r [ds_sgma4] lvl7_sgma2; } in
        let {
          sat_sgma3 [Occ=Once]
            :: GHC.Base.Semigroup
                 (Data.Functor.Contravariant.Op a_XgiXv b_XgiXx)
          [LclId] =
              [$dMonoid_sgma1] \u []
                  Data.Functor.Contravariant.$fMonoidOp_$cp1Monoid $dMonoid_sgma1;
        } in  GHC.Base.C:Monoid [sat_sgma3 sat_sgma5 sat_sgma6 sat_sgma7];

Data.Functor.Contravariant.$fMonoidComparison3
  :: forall a. a -> a -> GHC.Types.Ordering
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgma8 ds1_sgma9] GHC.Types.EQ [];

Data.Functor.Contravariant.$fMonoidComparison2
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgmaa g_sgmab x_sgmac]
        let {
          f1_sgmad [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [f_sgmaa x_sgmac] \u [] f_sgmaa x_sgmac; } in
        let {
          g1_sgmae [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [g_sgmab x_sgmac] \u [] g_sgmab x_sgmac; } in
        let {
          sat_sgmah [Occ=OnceT[0]] :: a_agiTx -> GHC.Types.Ordering
          [LclId] =
              [f1_sgmad g1_sgmae] \r [x1_sgmaf]
                  case f1_sgmad x1_sgmaf of {
                    GHC.Types.LT -> GHC.Types.LT [];
                    GHC.Types.EQ -> g1_sgmae x1_sgmaf;
                    GHC.Types.GT -> GHC.Types.GT [];
                  };
        } in  sat_sgmah;

Data.Functor.Contravariant.$fSemigroupComparison3
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C(U))><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgmai g_sgmaj x_sgmak]
        let {
          f1_sgmal [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [f_sgmai x_sgmak] \u [] f_sgmai x_sgmak; } in
        let {
          g1_sgmam [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [g_sgmaj x_sgmak] \u [] g_sgmaj x_sgmak; } in
        let {
          sat_sgmap [Occ=OnceT[0]] :: a_Xgj0p -> GHC.Types.Ordering
          [LclId] =
              [f1_sgmal g1_sgmam] \r [x1_sgman]
                  case f1_sgmal x1_sgman of {
                    GHC.Types.LT -> GHC.Types.LT [];
                    GHC.Types.EQ -> g1_sgmam x1_sgman;
                    GHC.Types.GT -> GHC.Types.GT [];
                  };
        } in  sat_sgmap;

Data.Functor.Contravariant.$fSemigroupComparison1
  :: forall a b.
     GHC.Real.Integral b =>
     b -> (a -> a -> GHC.Types.Ordering) -> a -> a -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Str=<L,U><L,U><L,1*C1(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sgmaq n_sgmar f_sgmas e_sgmat]
        let {
          f1_sgmau [Occ=OnceL!, Dmd=<L,C(U)>]
            :: a_agiUz -> GHC.Types.Ordering
          [LclId] =
              [f_sgmas e_sgmat] \u [] f_sgmas e_sgmat; } in
        let {
          lvl7_sgmav [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: b_agiVn -> GHC.Types.Ordering -> GHC.Types.Ordering
          [LclId] =
              [$dIntegral_sgmaq] \u []
                  GHC.Base.$fSemigroupOrdering_$cstimes $dIntegral_sgmaq; } in
        let {
          sat_sgmay [Occ=OnceT[0]] :: a_agiUz -> GHC.Types.Ordering
          [LclId] =
              [n_sgmar f1_sgmau lvl7_sgmav] \r [e1_sgmaw]
                  let {
                    sat_sgmax [Occ=Once] :: GHC.Types.Ordering
                    [LclId] =
                        [f1_sgmau e1_sgmaw] \u [] f1_sgmau e1_sgmaw;
                  } in  lvl7_sgmav n_sgmar sat_sgmax;
        } in  sat_sgmay;

Data.Functor.Contravariant.$fContravariantM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant (GHC.Generics.M1 i c f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgmaz]
        let {
          sat_sgmaB [Occ=Once]
            :: forall b a.
               b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r a
          [LclId] =
              [$dContravariant_sgmaz] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgmaz; } in
        let {
          sat_sgmaA [Occ=Once]
            :: forall a b.
               (a -> b)
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r b
               -> GHC.Generics.M1 i_Xgj1t c_Xgj1v f_Xgj1r a
          [LclId] =
              [$dContravariant_sgmaz] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgmaz;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmaA sat_sgmaB];

Data.Functor.Contravariant.$fContravariantRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant (GHC.Generics.Rec1 f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgmaC]
        let {
          sat_sgmaE [Occ=Once]
            :: forall b a.
               b -> GHC.Generics.Rec1 f_agiX0 b -> GHC.Generics.Rec1 f_agiX0 a
          [LclId] =
              [$dContravariant_sgmaC] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgmaC; } in
        let {
          sat_sgmaD [Occ=Once]
            :: forall a b.
               (a -> b)
               -> GHC.Generics.Rec1 f_agiX0 b -> GHC.Generics.Rec1 f_agiX0 a
          [LclId] =
              [$dContravariant_sgmaC] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgmaC;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmaD sat_sgmaE];

Data.Functor.Contravariant.$fContravariantAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Functor.Contravariant.Contravariant f =>
     Data.Functor.Contravariant.Contravariant
       (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dContravariant_sgmaF]
        let {
          sat_sgmaH [Occ=Once]
            :: forall b a.
               b
               -> Data.Semigroup.Internal.Alt f_agiY2 b
               -> Data.Semigroup.Internal.Alt f_agiY2 a
          [LclId] =
              [$dContravariant_sgmaF] \u []
                  Data.Functor.Contravariant.>$ $dContravariant_sgmaF; } in
        let {
          sat_sgmaG [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Semigroup.Internal.Alt f_agiY2 b
               -> Data.Semigroup.Internal.Alt f_agiY2 a
          [LclId] =
              [$dContravariant_sgmaF] \u []
                  Data.Functor.Contravariant.contramap $dContravariant_sgmaF;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmaG sat_sgmaH];

sat_sgmaI :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgmaJ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgmaI GHC.Types.[]];

lvl_rgjLr :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgmaJ;

lvl1_rgjLs :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Functor.Contravariant.$fFloatingOp_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmaK eta_sgmaL]
        let {
          $dFractional_sgmaM [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgmaK] \s []
                  GHC.Float.$p1Floating $dFloating_sgmaK; } in
        let {
          $dNum_sgmaN [Dmd=<L,U(C(C1(U)),C(C1(U)),A,A,A,A,C(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgmaM] \u []
                  GHC.Real.$p1Fractional $dFractional_sgmaM; } in
        let {
          x_sgmaO [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgmaN] \u []
                  GHC.Num.fromInteger $dNum_sgmaN lvl1_rgjLs; } in
        let {
          x1_sgmaP [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgmaN] \u [] GHC.Num.fromInteger $dNum_sgmaN lvl_rgjLr; } in
        let {
          sat_sgmaV [Occ=Once] :: b_Xgj9Q -> a_Xgj9N
          [LclId] =
              [$dFloating_sgmaK
               eta_sgmaL
               $dNum_sgmaN
               x_sgmaO
               x1_sgmaP] \r [eta1_sgmaQ]
                  let {
                    sat_sgmaU [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgmaK
                         eta_sgmaL
                         $dNum_sgmaN
                         x_sgmaO
                         x1_sgmaP
                         eta1_sgmaQ] \u []
                            let {
                              sat_sgmaT [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [$dFloating_sgmaK eta_sgmaL $dNum_sgmaN x_sgmaO eta1_sgmaQ] \u []
                                      let {
                                        sat_sgmaS [Occ=Once] :: a_Xgj9N
                                        [LclId] =
                                            [$dFloating_sgmaK eta_sgmaL eta1_sgmaQ] \u []
                                                let {
                                                  sat_sgmaR [Occ=Once] :: a_Xgj9N
                                                  [LclId] =
                                                      [eta_sgmaL eta1_sgmaQ] \u []
                                                          eta_sgmaL eta1_sgmaQ;
                                                } in  GHC.Float.exp $dFloating_sgmaK sat_sgmaR;
                                      } in  GHC.Num.- $dNum_sgmaN x_sgmaO sat_sgmaS;
                            } in  GHC.Num.+ $dNum_sgmaN x1_sgmaP sat_sgmaT;
                  } in  GHC.Float.log $dFloating_sgmaK sat_sgmaU;
        } in  sat_sgmaV;

Data.Functor.Contravariant.$fFloatingOp_$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(A,C(C1(U)),A,A,A,A,1*C1(U)),A,A,A),A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmaW eta_sgmaX]
        let {
          $dFractional_sgmaY [Occ=OnceL,
                              Dmd=<L,1*U(1*U(A,C(C1(U)),A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgmaW] \s []
                  GHC.Float.$p1Floating $dFloating_sgmaW; } in
        let {
          $dNum_sgmaZ [Dmd=<L,U(A,C(C1(U)),A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgmaY] \u []
                  GHC.Real.$p1Fractional $dFractional_sgmaY; } in
        let {
          x_sgmb0 [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgmaZ] \u [] GHC.Num.fromInteger $dNum_sgmaZ lvl_rgjLr; } in
        let {
          sat_sgmb4 [Occ=Once] :: b_Xgj4c -> a_Xgj9N
          [LclId] =
              [$dFloating_sgmaW eta_sgmaX $dNum_sgmaZ x_sgmb0] \r [a1_sgmb1]
                  let {
                    sat_sgmb3 [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgmaW eta_sgmaX a1_sgmb1] \u []
                            let {
                              sat_sgmb2 [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [eta_sgmaX a1_sgmb1] \u [] eta_sgmaX a1_sgmb1;
                            } in  GHC.Float.exp $dFloating_sgmaW sat_sgmb2;
                  } in  GHC.Num.- $dNum_sgmaZ sat_sgmb3 x_sgmb0;
        } in  sat_sgmb4;

Data.Functor.Contravariant.$fFloatingOp_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmb5 eta_sgmb6]
        let {
          $dFractional_sgmb7 [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj9N
          [LclId] =
              [$dFloating_sgmb5] \s []
                  GHC.Float.$p1Floating $dFloating_sgmb5; } in
        let {
          $dNum_sgmb8 [Dmd=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj9N
          [LclId] =
              [$dFractional_sgmb7] \u []
                  GHC.Real.$p1Fractional $dFractional_sgmb7; } in
        let {
          x_sgmb9 [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dNum_sgmb8] \u [] GHC.Num.fromInteger $dNum_sgmb8 lvl_rgjLr; } in
        let {
          sat_sgmbe [Occ=Once] :: b_Xgj9Q -> a_Xgj9N
          [LclId] =
              [$dFloating_sgmb5 eta_sgmb6 $dNum_sgmb8 x_sgmb9] \r [eta1_sgmba]
                  let {
                    sat_sgmbd [Occ=Once] :: a_Xgj9N
                    [LclId] =
                        [$dFloating_sgmb5 eta_sgmb6 $dNum_sgmb8 x_sgmb9 eta1_sgmba] \u []
                            let {
                              sat_sgmbc [Occ=Once] :: a_Xgj9N
                              [LclId] =
                                  [$dFloating_sgmb5 eta_sgmb6 eta1_sgmba] \u []
                                      let {
                                        sat_sgmbb [Occ=Once] :: a_Xgj9N
                                        [LclId] =
                                            [eta_sgmb6 eta1_sgmba] \u [] eta_sgmb6 eta1_sgmba;
                                      } in  GHC.Float.exp $dFloating_sgmb5 sat_sgmbb;
                            } in  GHC.Num.+ $dNum_sgmb8 x_sgmb9 sat_sgmbc;
                  } in  GHC.Float.log $dFloating_sgmb5 sat_sgmbd;
        } in  sat_sgmbe;

Data.Functor.Contravariant.$fFloatingOp_$clog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A),A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbf eta_sgmbg]
        let {
          $dFractional_sgmbh [Occ=OnceL,
                              Dmd=<L,1*U(1*U(C(C1(U)),A,A,A,A,A,1*C1(U)),A,A,A)>]
            :: GHC.Real.Fractional a_Xgj4c
          [LclId] =
              [$dFloating_sgmbf] \s []
                  GHC.Float.$p1Floating $dFloating_sgmbf; } in
        let {
          $dNum_sgmbi [Dmd=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>]
            :: GHC.Num.Num a_Xgj4c
          [LclId] =
              [$dFractional_sgmbh] \u []
                  GHC.Real.$p1Fractional $dFractional_sgmbh; } in
        let {
          x_sgmbj [Occ=OnceL] :: a_Xgj4c
          [LclId] =
              [$dNum_sgmbi] \u [] GHC.Num.fromInteger $dNum_sgmbi lvl_rgjLr; } in
        let {
          sat_sgmbn [Occ=Once] :: b_Xgj4e -> a_Xgj4c
          [LclId] =
              [$dFloating_sgmbf eta_sgmbg $dNum_sgmbi x_sgmbj] \r [eta1_sgmbk]
                  let {
                    sat_sgmbm [Occ=Once] :: a_Xgj4c
                    [LclId] =
                        [eta_sgmbg $dNum_sgmbi x_sgmbj eta1_sgmbk] \u []
                            let {
                              sat_sgmbl [Occ=Once] :: a_Xgj4c
                              [LclId] =
                                  [eta_sgmbg eta1_sgmbk] \u [] eta_sgmbg eta1_sgmbk;
                            } in  GHC.Num.+ $dNum_sgmbi x_sgmbj sat_sgmbl;
                  } in  GHC.Float.log $dFloating_sgmbf sat_sgmbm;
        } in  sat_sgmbn;

Data.Functor.Contravariant.$fFloatingOp17
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLLLLLLLLLLLLLLLLLLL),1*U(A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbo ds_sgmbp eta_sgmbq]
        let {
          sat_sgmbr [Occ=Once] :: a_XgjeT
          [LclId] =
              [ds_sgmbp eta_sgmbq] \u [] ds_sgmbp eta_sgmbq;
        } in  GHC.Float.exp $dFloating_sgmbo sat_sgmbr;

Data.Functor.Contravariant.$fFloatingOp16
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LLLLLLLLLLLLLLLLLLL),1*U(A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbs ds_sgmbt eta_sgmbu]
        let {
          sat_sgmbv [Occ=Once] :: a_Xgj44
          [LclId] =
              [ds_sgmbt eta_sgmbu] \u [] ds_sgmbt eta_sgmbu;
        } in  GHC.Float.log $dFloating_sgmbs sat_sgmbv;

Data.Functor.Contravariant.$fFloatingOp15
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)LLLLLLLLLLLLLLLLLL),1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbw ds_sgmbx eta_sgmby]
        let {
          sat_sgmbz [Occ=Once] :: a_Xgj9g
          [LclId] =
              [ds_sgmbx eta_sgmby] \u [] ds_sgmbx eta_sgmby;
        } in  GHC.Float.sqrt $dFloating_sgmbw sat_sgmbz;

Data.Functor.Contravariant.$fFloatingOp14
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbA ds_sgmbB ds1_sgmbC a1_sgmbD]
        let {
          sat_sgmbF [Occ=Once] :: a_Xgj3W
          [LclId] =
              [ds1_sgmbC a1_sgmbD] \u [] ds1_sgmbC a1_sgmbD; } in
        let {
          sat_sgmbE [Occ=Once] :: a_Xgj3W
          [LclId] =
              [ds_sgmbB a1_sgmbD] \u [] ds_sgmbB a1_sgmbD;
        } in  GHC.Float.** $dFloating_sgmbA sat_sgmbE sat_sgmbF;

Data.Functor.Contravariant.$fFloatingOp13
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbG ds_sgmbH ds1_sgmbI a1_sgmbJ]
        let {
          sat_sgmbL [Occ=Once] :: a_Xgj4f
          [LclId] =
              [ds1_sgmbI a1_sgmbJ] \u [] ds1_sgmbI a1_sgmbJ; } in
        let {
          sat_sgmbK [Occ=Once] :: a_Xgj4f
          [LclId] =
              [ds_sgmbH a1_sgmbJ] \u [] ds_sgmbH a1_sgmbJ;
        } in  GHC.Float.logBase $dFloating_sgmbG sat_sgmbK sat_sgmbL;

Data.Functor.Contravariant.$fFloatingOp12
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbM ds_sgmbN eta_sgmbO]
        let {
          sat_sgmbP [Occ=Once] :: a_Xgj49
          [LclId] =
              [ds_sgmbN eta_sgmbO] \u [] ds_sgmbN eta_sgmbO;
        } in  GHC.Float.sin $dFloating_sgmbM sat_sgmbP;

Data.Functor.Contravariant.$fFloatingOp11
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbQ ds_sgmbR eta_sgmbS]
        let {
          sat_sgmbT [Occ=Once] :: a_Xgj43
          [LclId] =
              [ds_sgmbR eta_sgmbS] \u [] ds_sgmbR eta_sgmbS;
        } in  GHC.Float.cos $dFloating_sgmbQ sat_sgmbT;

Data.Functor.Contravariant.$fFloatingOp10
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(S)LLLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbU ds_sgmbV eta_sgmbW]
        let {
          sat_sgmbX [Occ=Once] :: a_Xgj3X
          [LclId] =
              [ds_sgmbV eta_sgmbW] \u [] ds_sgmbV eta_sgmbW;
        } in  GHC.Float.tan $dFloating_sgmbU sat_sgmbX;

Data.Functor.Contravariant.$fFloatingOp9
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLC(S)LLLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmbY ds_sgmbZ eta_sgmc0]
        let {
          sat_sgmc1 [Occ=Once] :: a_Xgj3R
          [LclId] =
              [ds_sgmbZ eta_sgmc0] \u [] ds_sgmbZ eta_sgmc0;
        } in  GHC.Float.asin $dFloating_sgmbY sat_sgmc1;

Data.Functor.Contravariant.$fFloatingOp8
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLC(S)LLLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmc2 ds_sgmc3 eta_sgmc4]
        let {
          sat_sgmc5 [Occ=Once] :: a_Xgj3L
          [LclId] =
              [ds_sgmc3 eta_sgmc4] \u [] ds_sgmc3 eta_sgmc4;
        } in  GHC.Float.acos $dFloating_sgmc2 sat_sgmc5;

Data.Functor.Contravariant.$fFloatingOp7
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLC(S)LLLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmc6 ds_sgmc7 eta_sgmc8]
        let {
          sat_sgmc9 [Occ=Once] :: a_Xgj3F
          [LclId] =
              [ds_sgmc7 eta_sgmc8] \u [] ds_sgmc7 eta_sgmc8;
        } in  GHC.Float.atan $dFloating_sgmc6 sat_sgmc9;

Data.Functor.Contravariant.$fFloatingOp6
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLC(S)LLLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmca ds_sgmcb eta_sgmcc]
        let {
          sat_sgmcd [Occ=Once] :: a_Xgj3z
          [LclId] =
              [ds_sgmcb eta_sgmcc] \u [] ds_sgmcb eta_sgmcc;
        } in  GHC.Float.sinh $dFloating_sgmca sat_sgmcd;

Data.Functor.Contravariant.$fFloatingOp5
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmce ds_sgmcf eta_sgmcg]
        let {
          sat_sgmch [Occ=Once] :: a_Xgj3t
          [LclId] =
              [ds_sgmcf eta_sgmcg] \u [] ds_sgmcf eta_sgmcg;
        } in  GHC.Float.cosh $dFloating_sgmce sat_sgmch;

Data.Functor.Contravariant.$fFloatingOp4
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmci ds_sgmcj eta_sgmck]
        let {
          sat_sgmcl [Occ=Once] :: a_Xgj3n
          [LclId] =
              [ds_sgmcj eta_sgmck] \u [] ds_sgmcj eta_sgmck;
        } in  GHC.Float.tanh $dFloating_sgmci sat_sgmcl;

Data.Functor.Contravariant.$fFloatingOp3
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLC(S)LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmcm ds_sgmcn eta_sgmco]
        let {
          sat_sgmcp [Occ=Once] :: a_Xgj3h
          [LclId] =
              [ds_sgmcn eta_sgmco] \u [] ds_sgmcn eta_sgmco;
        } in  GHC.Float.asinh $dFloating_sgmcm sat_sgmcp;

Data.Functor.Contravariant.$fFloatingOp2
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLC(S)LLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmcq ds_sgmcr eta_sgmcs]
        let {
          sat_sgmct [Occ=Once] :: a_Xgj3b
          [LclId] =
              [ds_sgmcr eta_sgmcs] \u [] ds_sgmcr eta_sgmcs;
        } in  GHC.Float.acosh $dFloating_sgmcq sat_sgmct;

Data.Functor.Contravariant.$fFloatingOp1
  :: forall a b.
     GHC.Float.Floating a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLC(S)LLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmcu ds_sgmcv eta_sgmcw]
        let {
          sat_sgmcx [Occ=Once] :: a_agiZ4
          [LclId] =
              [ds_sgmcv eta_sgmcw] \u [] ds_sgmcv eta_sgmcw;
        } in  GHC.Float.atanh $dFloating_sgmcu sat_sgmcx;

Data.Functor.Contravariant.$fFractionalOp2
  :: forall a b.
     GHC.Real.Fractional a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LL),1*U(A,1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgmcy ds_sgmcz ds1_sgmcA a1_sgmcB]
        let {
          sat_sgmcD [Occ=Once] :: a_Xgj8K
          [LclId] =
              [ds1_sgmcA a1_sgmcB] \u [] ds1_sgmcA a1_sgmcB; } in
        let {
          sat_sgmcC [Occ=Once] :: a_Xgj8K
          [LclId] =
              [ds_sgmcz a1_sgmcB] \u [] ds_sgmcz a1_sgmcB;
        } in  GHC.Real./ $dFractional_sgmcy sat_sgmcC sat_sgmcD;

Data.Functor.Contravariant.$fFractionalOp1
  :: forall a b.
     GHC.Real.Fractional a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)L),1*U(A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgmcE ds_sgmcF eta_sgmcG]
        let {
          sat_sgmcH [Occ=Once] :: a_agj4M
          [LclId] =
              [ds_sgmcF eta_sgmcG] \u [] ds_sgmcF eta_sgmcG;
        } in  GHC.Real.recip $dFractional_sgmcE sat_sgmcH;

Data.Functor.Contravariant.$fFractionalOp_$cfromRational
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Real.Rational -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgmcI eta_sgmcJ]
        let {
          x_sgmcK [Occ=OnceL] :: a_agj4M
          [LclId] =
              [$dFractional_sgmcI eta_sgmcJ] \u []
                  GHC.Real.fromRational $dFractional_sgmcI eta_sgmcJ; } in
        let {
          sat_sgmcM [Occ=Once] :: b_agj4N -> a_agj4M
          [LclId] =
              [x_sgmcK] \r [ds_sgmcL] x_sgmcK;
        } in  sat_sgmcM;

Data.Functor.Contravariant.$fNumOp_$cnegate [InlPrag=INLINE (sat-args=1)]
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(U)),A,A,A,A,1*C1(U))><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmcN eta_sgmcO]
        let {
          x_sgmcP [Occ=OnceL] :: a_Xgjab
          [LclId] =
              [$dNum_sgmcN] \u []
                  GHC.Num.fromInteger $dNum_sgmcN lvl1_rgjLs; } in
        let {
          sat_sgmcS [Occ=Once] :: b_Xgjad -> a_Xgjab
          [LclId] =
              [$dNum_sgmcN eta_sgmcO x_sgmcP] \r [a1_sgmcQ]
                  let {
                    sat_sgmcR [Occ=Once] :: a_Xgjab
                    [LclId] =
                        [eta_sgmcO a1_sgmcQ] \u [] eta_sgmcO a1_sgmcQ;
                  } in  GHC.Num.- $dNum_sgmcN x_sgmcP sat_sgmcR;
        } in  sat_sgmcS;

Data.Functor.Contravariant.$fNumOp5
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmcT ds_sgmcU ds1_sgmcV a1_sgmcW]
        let {
          sat_sgmcY [Occ=Once] :: a_Xgja3
          [LclId] =
              [ds1_sgmcV a1_sgmcW] \u [] ds1_sgmcV a1_sgmcW; } in
        let {
          sat_sgmcX [Occ=Once] :: a_Xgja3
          [LclId] =
              [ds_sgmcU a1_sgmcW] \u [] ds_sgmcU a1_sgmcW;
        } in  GHC.Num.+ $dNum_sgmcT sat_sgmcX sat_sgmcY;

Data.Functor.Contravariant.$fNumOp4
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmcZ ds_sgmd0 ds1_sgmd1 a1_sgmd2]
        let {
          sat_sgmd4 [Occ=Once] :: a_Xgj9W
          [LclId] =
              [ds1_sgmd1 a1_sgmd2] \u [] ds1_sgmd1 a1_sgmd2; } in
        let {
          sat_sgmd3 [Occ=Once] :: a_Xgj9W
          [LclId] =
              [ds_sgmd0 a1_sgmd2] \u [] ds_sgmd0 a1_sgmd2;
        } in  GHC.Num.- $dNum_sgmcZ sat_sgmd3 sat_sgmd4;

Data.Functor.Contravariant.$fNumOp3
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b
     -> Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmd5 ds_sgmd6 ds1_sgmd7 a1_sgmd8]
        let {
          sat_sgmda [Occ=Once] :: a_Xgj9A
          [LclId] =
              [ds1_sgmd7 a1_sgmd8] \u [] ds1_sgmd7 a1_sgmd8; } in
        let {
          sat_sgmd9 [Occ=Once] :: a_Xgj9A
          [LclId] =
              [ds_sgmd6 a1_sgmd8] \u [] ds_sgmd6 a1_sgmd8;
        } in  GHC.Num.* $dNum_sgmd5 sat_sgmd9 sat_sgmda;

Data.Functor.Contravariant.$fNumOp2
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLC(S)LL),1*U(A,A,A,A,1*C1(U),A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmdb ds_sgmdc eta_sgmdd]
        let {
          sat_sgmde [Occ=Once] :: a_Xgj9u
          [LclId] =
              [ds_sgmdc eta_sgmdd] \u [] ds_sgmdc eta_sgmdd;
        } in  GHC.Num.abs $dNum_sgmdb sat_sgmde;

Data.Functor.Contravariant.$fNumOp1
  :: forall a b.
     GHC.Num.Num a =>
     Data.Functor.Contravariant.Op a b -> b -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(S)L),1*U(A,A,A,A,A,1*C1(U),A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmdf ds_sgmdg eta_sgmdh]
        let {
          sat_sgmdi [Occ=Once] :: a_agj5O
          [LclId] =
              [ds_sgmdg eta_sgmdh] \u [] ds_sgmdg eta_sgmdh;
        } in  GHC.Num.signum $dNum_sgmdf sat_sgmdi;

Data.Functor.Contravariant.$fNumOp_$cfromInteger
  :: forall a b.
     GHC.Num.Num a =>
     GHC.Integer.Type.Integer -> Data.Functor.Contravariant.Op a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgmdj eta_sgmdk]
        let {
          x_sgmdl [Occ=OnceL] :: a_agj5O
          [LclId] =
              [$dNum_sgmdj eta_sgmdk] \u []
                  GHC.Num.fromInteger $dNum_sgmdj eta_sgmdk; } in
        let {
          sat_sgmdn [Occ=Once] :: b_agj5P -> a_agj5O
          [LclId] =
              [x_sgmdl] \r [ds_sgmdm] x_sgmdl;
        } in  sat_sgmdn;

Data.Functor.Contravariant.$fNumOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>m] =
    [] \r [$dNum_sgmdo]
        let {
          sat_sgmdv [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B1]
                  Data.Functor.Contravariant.$fNumOp_$cfromInteger
                      $dNum_sgmdo eta_B1; } in
        let {
          sat_sgmdu [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp1 $dNum_sgmdo eta_B2 eta_B1; } in
        let {
          sat_sgmdt [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp2 $dNum_sgmdo eta_B2 eta_B1; } in
        let {
          sat_sgmds [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B1]
                  Data.Functor.Contravariant.$fNumOp_$cnegate
                      $dNum_sgmdo eta_B1; } in
        let {
          sat_sgmdr [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp3
                      $dNum_sgmdo eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgmdq [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp4
                      $dNum_sgmdo eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgmdp [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
               -> Data.Functor.Contravariant.Op a_Xgjaa b_Xgjac
          [LclId] =
              [$dNum_sgmdo] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fNumOp5
                      $dNum_sgmdo eta_B3 eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_sgmdp
                         sat_sgmdq
                         sat_sgmdr
                         sat_sgmds
                         sat_sgmdt
                         sat_sgmdu
                         sat_sgmdv];

Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Num.Num (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFractional_sgmdw]
        let {
          sat_sgmdx [Occ=Once,
                     Dmd=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>]
            :: GHC.Num.Num a_Xgj9j
          [LclId] =
              [$dFractional_sgmdw] \u []
                  GHC.Real.$p1Fractional $dFractional_sgmdw;
        } in  Data.Functor.Contravariant.$fNumOp sat_sgmdx;

Data.Functor.Contravariant.$fFractionalOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Real.Fractional a =>
     GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U))>m] =
    [] \r [$dFractional_sgmdy]
        let {
          sat_sgmdC [Occ=Once]
            :: GHC.Real.Rational
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgmdy] \r [eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp_$cfromRational
                      $dFractional_sgmdy eta_B1; } in
        let {
          sat_sgmdB [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgmdy] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp1
                      $dFractional_sgmdy eta_B2 eta_B1; } in
        let {
          sat_sgmdA [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
               -> Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m
          [LclId] =
              [$dFractional_sgmdy] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFractionalOp2
                      $dFractional_sgmdy eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgmdz [Occ=Once]
            :: GHC.Num.Num (Data.Functor.Contravariant.Op a_Xgj9k b_Xgj9m)
          [LclId] =
              [$dFractional_sgmdy] \u []
                  Data.Functor.Contravariant.$fFractionalOp_$cp1Fractional
                      $dFractional_sgmdy;
        } in 
          GHC.Real.C:Fractional [sat_sgmdz sat_sgmdA sat_sgmdB sat_sgmdC];

Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
  :: forall a b.
     GHC.Float.Floating a =>
     GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgmdD]
        let {
          sat_sgmdE [Occ=Once,
                     Dmd=<L,U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U))>]
            :: GHC.Real.Fractional a_Xgj9H
          [LclId] =
              [$dFloating_sgmdD] \u [] GHC.Float.$p1Floating $dFloating_sgmdD;
        } in  Data.Functor.Contravariant.$fFractionalOp sat_sgmdE;

Data.Functor.Contravariant.$fFloatingOp [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Float.Floating a =>
     GHC.Float.Floating (Data.Functor.Contravariant.Op a b)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U)),C(C1(U)),C(U),C(U)),1*U,C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),C(U),A,A,A,A)>] =
    [] \r [$dFloating_sgmdF]
        let {
          lvl7_sgmdG [Occ=OnceL] :: a_Xgj9N
          [LclId] =
              [$dFloating_sgmdF] \u [] GHC.Float.pi $dFloating_sgmdF; } in
        let {
          sat_sgme4 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1mexp
                      $dFloating_sgmdF eta_B1; } in
        let {
          sat_sgme3 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1pexp
                      $dFloating_sgmdF eta_B1; } in
        let {
          sat_sgme2 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$cexpm1
                      $dFloating_sgmdF eta_B1; } in
        let {
          sat_sgme1 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp_$clog1p
                      $dFloating_sgmdF eta_B1; } in
        let {
          sat_sgme0 [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp1
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdZ [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp2
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdY [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp3
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdX [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp4
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdW [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp5
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdV [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp6
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdU [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp7
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdT [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp8
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdS [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp9
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdR [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp10
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdQ [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp11
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdP [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp12
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdO [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp13
                      $dFloating_sgmdF eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgmdN [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B3 eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp14
                      $dFloating_sgmdF eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgmdM [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp15
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdL [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp16
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdK [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
               -> Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [$dFloating_sgmdF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fFloatingOp17
                      $dFloating_sgmdF eta_B2 eta_B1; } in
        let {
          sat_sgmdJ [Occ=Once]
            :: Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q
          [LclId] =
              [lvl7_sgmdG] \r [eta_sgmdI] lvl7_sgmdG; } in
        let {
          sat_sgmdH [Occ=Once]
            :: GHC.Real.Fractional
                 (Data.Functor.Contravariant.Op a_Xgj9N b_Xgj9Q)
          [LclId] =
              [$dFloating_sgmdF] \u []
                  Data.Functor.Contravariant.$fFloatingOp_$cp1Floating
                      $dFloating_sgmdF;
        } in 
          GHC.Float.C:Floating [sat_sgmdH
                                sat_sgmdJ
                                sat_sgmdK
                                sat_sgmdL
                                sat_sgmdM
                                sat_sgmdN
                                sat_sgmdO
                                sat_sgmdP
                                sat_sgmdQ
                                sat_sgmdR
                                sat_sgmdS
                                sat_sgmdT
                                sat_sgmdU
                                sat_sgmdV
                                sat_sgmdW
                                sat_sgmdX
                                sat_sgmdY
                                sat_sgmdZ
                                sat_sgme0
                                sat_sgme1
                                sat_sgme2
                                sat_sgme3
                                sat_sgme4];

Data.Functor.Contravariant.$fCategoryTYPEOp1
  :: forall b c a.
     Data.Functor.Contravariant.Op b c
     -> Data.Functor.Contravariant.Op a b -> c -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgme5 ds1_sgme6 eta_B1]
        GHC.Base.. ds1_sgme6 ds_sgme5 eta_B1;

Data.Functor.Contravariant.$fCategoryTYPEOp [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Category.Category Data.Functor.Contravariant.Op
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Control.Category.C:Category! [GHC.Base.id
                                                Data.Functor.Contravariant.$fCategoryTYPEOp1];

Data.Functor.Contravariant.$fMonoidEquivalence3
  :: forall a. a -> a -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgme7 ds1_sgme8] GHC.Types.True [];

Data.Functor.Contravariant.$fSemigroupEquivalence1 [Occ=LoopBreaker]
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> [Data.Functor.Contravariant.Equivalence a]
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgme9 ds1_sgmea]
        case ds1_sgmea of {
          [] -> b_sgme9;
          : c_sgmec [Occ=Once] cs_sgmed [Occ=Once] ->
              let {
                ds_sgmee [Occ=OnceL, Dmd=<L,C(C1(U))>]
                  :: Data.Functor.Contravariant.Equivalence a_XgjcG
                [LclId] =
                    [c_sgmec cs_sgmed] \u []
                        Data.Functor.Contravariant.$fSemigroupEquivalence1
                            c_sgmec cs_sgmed; } in
              let {
                sat_sgmei [Occ=Once] :: a_XgjcG -> a_XgjcG -> GHC.Types.Bool
                [LclId] =
                    [b_sgme9 ds_sgmee] \r [a1_sgmef b1_sgmeg]
                        case b_sgme9 a1_sgmef b1_sgmeg of {
                          GHC.Types.False -> GHC.Types.False [];
                          GHC.Types.True -> ds_sgmee a1_sgmef b1_sgmeg;
                        };
              } in  sat_sgmei;
        };

Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Functor.Contravariant.Equivalence a)
     -> Data.Functor.Contravariant.Equivalence a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgmej]
        case ds_sgmej of {
          GHC.Base.:| a1_sgmel [Occ=Once] as_sgmem [Occ=Once] ->
              Data.Functor.Contravariant.$fSemigroupEquivalence1
                  a1_sgmel as_sgmem;
        };

Data.Functor.Contravariant.$fMonoidEquivalence2
  :: forall a.
     Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
     -> a
     -> a
     -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmen ds1_sgmeo a1_sgmep b_sgmeq]
        case ds_sgmen a1_sgmep b_sgmeq of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> ds1_sgmeo a1_sgmep b_sgmeq;
        };

Data.Functor.Contravariant.$fSemigroupEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Equivalence a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fMonoidEquivalence2
                                         Data.Functor.Contravariant.$fSemigroupEquivalence_$csconcat
                                         Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes];
Data.Functor.Contravariant.$fSemigroupEquivalence_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Functor.Contravariant.Equivalence a
     -> Data.Functor.Contravariant.Equivalence a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgmes]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sgmes Data.Functor.Contravariant.$fSemigroupEquivalence;

Data.Functor.Contravariant.$fMonoidEquivalence1 [Occ=LoopBreaker]
  :: forall a.
     [Data.Functor.Contravariant.Equivalence a]
     -> a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmet eta_sgmeu eta1_sgmev]
        case ds_sgmet of {
          [] -> GHC.Types.True [];
          : y_sgmex [Occ=Once] ys_sgmey [Occ=Once] ->
              case y_sgmex eta_sgmeu eta1_sgmev of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Functor.Contravariant.$fMonoidEquivalence1
                        ys_sgmey eta_sgmeu eta1_sgmev;
              };
        };

Data.Functor.Contravariant.$fMonoidEquivalence [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupEquivalence
                                      Data.Functor.Contravariant.$fMonoidEquivalence3
                                      Data.Functor.Contravariant.$fMonoidEquivalence2
                                      Data.Functor.Contravariant.$fMonoidEquivalence1];

Data.Functor.Contravariant.$fMonoidPredicate3
  :: forall a. a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgmeA] GHC.Types.True [];

Data.Functor.Contravariant.$fSemigroupPredicate1 [Occ=LoopBreaker]
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> [Data.Functor.Contravariant.Predicate a]
     -> Data.Functor.Contravariant.Predicate a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgmeB ds1_sgmeC]
        case ds1_sgmeC of {
          [] -> b_sgmeB;
          : c_sgmeE [Occ=Once] cs_sgmeF [Occ=Once] ->
              let {
                ds_sgmeG [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Data.Functor.Contravariant.Predicate a_Xgje6
                [LclId] =
                    [c_sgmeE cs_sgmeF] \u []
                        Data.Functor.Contravariant.$fSemigroupPredicate1
                            c_sgmeE cs_sgmeF; } in
              let {
                sat_sgmeJ [Occ=Once] :: a_Xgje6 -> GHC.Types.Bool
                [LclId] =
                    [b_sgmeB ds_sgmeG] \r [a1_sgmeH]
                        case b_sgmeB a1_sgmeH of {
                          GHC.Types.False -> GHC.Types.False [];
                          GHC.Types.True -> ds_sgmeG a1_sgmeH;
                        };
              } in  sat_sgmeJ;
        };

Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Functor.Contravariant.Predicate a)
     -> Data.Functor.Contravariant.Predicate a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgmeK]
        case ds_sgmeK of {
          GHC.Base.:| a1_sgmeM [Occ=Once] as_sgmeN [Occ=Once] ->
              Data.Functor.Contravariant.$fSemigroupPredicate1 a1_sgmeM as_sgmeN;
        };

Data.Functor.Contravariant.$fMonoidPredicate2
  :: forall a.
     Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a -> a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmeO ds1_sgmeP a1_sgmeQ]
        case ds_sgmeO a1_sgmeQ of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> ds1_sgmeP a1_sgmeQ;
        };

Data.Functor.Contravariant.$fSemigroupPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Predicate a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fMonoidPredicate2
                                         Data.Functor.Contravariant.$fSemigroupPredicate_$csconcat
                                         Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes];
Data.Functor.Contravariant.$fSemigroupPredicate_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Functor.Contravariant.Predicate a
     -> Data.Functor.Contravariant.Predicate a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgmeS]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sgmeS Data.Functor.Contravariant.$fSemigroupPredicate;

Data.Functor.Contravariant.$fMonoidPredicate1 [Occ=LoopBreaker]
  :: forall a.
     [Data.Functor.Contravariant.Predicate a] -> a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmeT eta_sgmeU]
        case ds_sgmeT of {
          [] -> GHC.Types.True [];
          : y_sgmeW [Occ=Once] ys_sgmeX [Occ=Once] ->
              case y_sgmeW eta_sgmeU of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Functor.Contravariant.$fMonoidPredicate1 ys_sgmeX eta_sgmeU;
              };
        };

Data.Functor.Contravariant.$fMonoidPredicate [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Predicate a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupPredicate
                                      Data.Functor.Contravariant.$fMonoidPredicate3
                                      Data.Functor.Contravariant.$fMonoidPredicate2
                                      Data.Functor.Contravariant.$fMonoidPredicate1];

Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
  :: forall a b. (a -> b) -> Data.Proxy.Proxy b -> Data.Proxy.Proxy a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgmeZ ds1_sgmf0] Data.Proxy.Proxy [];

Data.Functor.Contravariant.$fContravariantProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant Data.Proxy.Proxy
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantProxy_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantProxy_$c>$];

Data.Functor.Contravariant.$fContravariantCompose2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> Data.Functor.Compose.Compose f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgmf1 $dContravariant_sgmf2 f1_sgmf3 ds_sgmf4]
        let {
          sat_sgmf5 [Occ=Once] :: g_agjbQ b_agjbX -> g_agjbQ a_agjbW
          [LclId] =
              [$dContravariant_sgmf2 f1_sgmf3] \u []
                  Data.Functor.Contravariant.contramap
                      $dContravariant_sgmf2 f1_sgmf3;
        } in  GHC.Base.fmap $dFunctor_sgmf1 sat_sgmf5 ds_sgmf4;

Data.Functor.Contravariant.$fContravariantCompose [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Compose.Compose f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgmf6 $dContravariant_sgmf7]
        let {
          sat_sgmf9 [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW a
          [LclId] =
              [$dFunctor_sgmf6 $dContravariant_sgmf7] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantCompose1
                      $dFunctor_sgmf6 $dContravariant_sgmf7 eta_B2 eta_B1; } in
        let {
          sat_sgmf8 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW b
               -> Data.Functor.Compose.Compose f_XgjhU g_XgjhW a
          [LclId] =
              [$dFunctor_sgmf6 $dContravariant_sgmf7] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantCompose2
                      $dFunctor_sgmf6 $dContravariant_sgmf7 eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmf8 sat_sgmf9];

Data.Functor.Contravariant.$fContravariantConst2
  :: forall a1 a2 b.
     (a2 -> b)
     -> Data.Functor.Const.Const a1 b -> Data.Functor.Const.Const a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmfa ds1_sgmfb] ds1_sgmfb;

Data.Functor.Contravariant.$fContravariantConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Const.Const a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantConst2
                                                               Data.Functor.Contravariant.$fContravariantConst1];

Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Product.Product f g b
     -> Data.Functor.Product.Product f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmfc
           $dContravariant1_sgmfd
           f1_sgmfe
           ds_sgmff]
        case ds_sgmff of {
          Data.Functor.Product.Pair a1_sgmfh [Occ=Once]
                                    b1_sgmfi [Occ=Once] ->
              let {
                sat_sgmfk [Occ=Once] :: g_agjcM a_agjcS
                [LclId] =
                    [$dContravariant1_sgmfd f1_sgmfe b1_sgmfi] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgmfd f1_sgmfe b1_sgmfi; } in
              let {
                sat_sgmfj [Occ=Once] :: f_agjcL a_agjcS
                [LclId] =
                    [$dContravariant_sgmfc f1_sgmfe a1_sgmfh] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgmfc f1_sgmfe a1_sgmfh;
              } in  Data.Functor.Product.Pair [sat_sgmfj sat_sgmfk];
        };

Data.Functor.Contravariant.$fContravariantProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant
       (Data.Functor.Product.Product f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgmfl $dContravariant1_sgmfm]
        let {
          sat_sgmfo [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Product.Product f_agjcL g_agjcM b
               -> Data.Functor.Product.Product f_agjcL g_agjcM a
          [LclId] =
              [$dContravariant_sgmfl $dContravariant1_sgmfm] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantProduct_$c>$
                      $dContravariant_sgmfl $dContravariant1_sgmfm eta_B2 eta_B1; } in
        let {
          sat_sgmfn [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Product.Product f_agjcL g_agjcM b
               -> Data.Functor.Product.Product f_agjcL g_agjcM a
          [LclId] =
              [$dContravariant_sgmfl $dContravariant1_sgmfm] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantProduct_$ccontramap
                      $dContravariant_sgmfl $dContravariant1_sgmfm eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmfn sat_sgmfo];

Data.Functor.Contravariant.$fContravariantSum_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b)
     -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmfp
           $dContravariant1_sgmfq
           f1_sgmfr
           ds_sgmfs]
        case ds_sgmfs of {
          Data.Functor.Sum.InL xs_sgmfu [Occ=Once] ->
              let {
                sat_sgmfv [Occ=Once] :: f_agjdk a_agjdr
                [LclId] =
                    [$dContravariant_sgmfp f1_sgmfr xs_sgmfu] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgmfp f1_sgmfr xs_sgmfu;
              } in  Data.Functor.Sum.InL [sat_sgmfv];
          Data.Functor.Sum.InR ys_sgmfw [Occ=Once] ->
              let {
                sat_sgmfx [Occ=Once] :: g_agjdl a_agjdr
                [LclId] =
                    [$dContravariant1_sgmfq f1_sgmfr ys_sgmfw] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgmfq f1_sgmfr ys_sgmfw;
              } in  Data.Functor.Sum.InR [sat_sgmfx];
        };

Data.Functor.Contravariant.$fContravariantSum_$c>$
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> Data.Functor.Sum.Sum f g b -> Data.Functor.Sum.Sum f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmfy
           $dContravariant1_sgmfz
           x_sgmfA
           eta_sgmfB]
        let {
          sat_sgmfD [Occ=Once] :: a_agjdP -> b_agjdO
          [LclId] =
              [x_sgmfA] \r [ds_sgmfC] x_sgmfA;
        } in 
          Data.Functor.Contravariant.$fContravariantSum_$ccontramap
              $dContravariant_sgmfy $dContravariant1_sgmfz sat_sgmfD eta_sgmfB;

Data.Functor.Contravariant.$fContravariantSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (Data.Functor.Sum.Sum f g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgmfE $dContravariant1_sgmfF]
        let {
          sat_sgmfH [Occ=Once]
            :: forall b a.
               b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl a
          [LclId] =
              [$dContravariant_sgmfE $dContravariant1_sgmfF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantSum_$c>$
                      $dContravariant_sgmfE $dContravariant1_sgmfF eta_B2 eta_B1; } in
        let {
          sat_sgmfG [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl b
               -> Data.Functor.Sum.Sum f_agjdk g_agjdl a
          [LclId] =
              [$dContravariant_sgmfE $dContravariant1_sgmfF] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariantSum_$ccontramap
                      $dContravariant_sgmfE $dContravariant1_sgmfF eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmfG sat_sgmfH];

Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> (GHC.Generics.:+:) f g b -> (GHC.Generics.:+:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmfI
           $dContravariant1_sgmfJ
           f1_sgmfK
           ds_sgmfL]
        case ds_sgmfL of {
          GHC.Generics.L1 xs_sgmfN [Occ=Once] ->
              let {
                sat_sgmfO [Occ=Once] :: f_agjdX a_agje4
                [LclId] =
                    [$dContravariant_sgmfI f1_sgmfK xs_sgmfN] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgmfI f1_sgmfK xs_sgmfN;
              } in  GHC.Generics.L1 [sat_sgmfO];
          GHC.Generics.R1 ys_sgmfP [Occ=Once] ->
              let {
                sat_sgmfQ [Occ=Once] :: g_agjdY a_agje4
                [LclId] =
                    [$dContravariant1_sgmfJ f1_sgmfK ys_sgmfP] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgmfJ f1_sgmfK ys_sgmfP;
              } in  GHC.Generics.R1 [sat_sgmfQ];
        };

Data.Functor.Contravariant.$fContravariant:+:_$c>$
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall b a.
     b -> (GHC.Generics.:+:) f g b -> (GHC.Generics.:+:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmfR
           $dContravariant1_sgmfS
           x_sgmfT
           eta_sgmfU]
        let {
          sat_sgmfW [Occ=Once] :: a_agjes -> b_agjer
          [LclId] =
              [x_sgmfT] \r [ds_sgmfV] x_sgmfT;
        } in 
          Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
              $dContravariant_sgmfR $dContravariant1_sgmfS sat_sgmfW eta_sgmfU;

Data.Functor.Contravariant.$fContravariant:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgmfX $dContravariant1_sgmfY]
        let {
          sat_sgmg0 [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY a
          [LclId] =
              [$dContravariant_sgmfX $dContravariant1_sgmfY] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:+:_$c>$
                      $dContravariant_sgmfX $dContravariant1_sgmfY eta_B2 eta_B1; } in
        let {
          sat_sgmfZ [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:+:) f_agjdX g_agjdY b
               -> (GHC.Generics.:+:) f_agjdX g_agjdY a
          [LclId] =
              [$dContravariant_sgmfX $dContravariant1_sgmfY] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:+:_$ccontramap
                      $dContravariant_sgmfX $dContravariant1_sgmfY eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmfZ sat_sgmg0];

Data.Functor.Contravariant.$fContravariant:.:2
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     forall a b. (a -> b) -> (GHC.Generics.:.:) f g b -> f (g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgmg1 $dContravariant_sgmg2 f1_sgmg3 ds_sgmg4]
        let {
          sat_sgmg5 [Occ=Once] :: g_agjeB b_agjeI -> g_agjeB a_agjeH
          [LclId] =
              [$dContravariant_sgmg2 f1_sgmg3] \u []
                  Data.Functor.Contravariant.contramap
                      $dContravariant_sgmg2 f1_sgmg3;
        } in  GHC.Base.fmap $dFunctor_sgmg1 sat_sgmg5 ds_sgmg4;

Data.Functor.Contravariant.$fContravariant:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(U),A)>m] =
    [] \r [$dFunctor_sgmg6 $dContravariant_sgmg7]
        let {
          sat_sgmg9 [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS a
          [LclId] =
              [$dFunctor_sgmg6 $dContravariant_sgmg7] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:.:1
                      $dFunctor_sgmg6 $dContravariant_sgmg7 eta_B2 eta_B1; } in
        let {
          sat_sgmg8 [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS b
               -> (GHC.Generics.:.:) f_XgjkQ g_XgjkS a
          [LclId] =
              [$dFunctor_sgmg6 $dContravariant_sgmg7] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:.:2
                      $dFunctor_sgmg6 $dContravariant_sgmg7 eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmg8 sat_sgmg9];

Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     forall a b.
     (a -> b) -> (GHC.Generics.:*:) f g b -> (GHC.Generics.:*:) f g a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dContravariant_sgmga
           $dContravariant1_sgmgb
           f1_sgmgc
           ds_sgmgd]
        case ds_sgmgd of {
          GHC.Generics.:*: xs_sgmgf [Occ=Once] ys_sgmgg [Occ=Once] ->
              let {
                sat_sgmgi [Occ=Once] :: g_agjfb a_agjfh
                [LclId] =
                    [$dContravariant1_sgmgb f1_sgmgc ys_sgmgg] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant1_sgmgb f1_sgmgc ys_sgmgg; } in
              let {
                sat_sgmgh [Occ=Once] :: f_agjfa a_agjfh
                [LclId] =
                    [$dContravariant_sgmga f1_sgmgc xs_sgmgf] \u []
                        Data.Functor.Contravariant.contramap
                            $dContravariant_sgmga f1_sgmgc xs_sgmgf;
              } in  GHC.Generics.:*: [sat_sgmgh sat_sgmgi];
        };

Data.Functor.Contravariant.$fContravariant:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Functor.Contravariant.Contravariant f,
      Data.Functor.Contravariant.Contravariant g) =>
     Data.Functor.Contravariant.Contravariant (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dContravariant_sgmgj $dContravariant1_sgmgk]
        let {
          sat_sgmgm [Occ=Once]
            :: forall b a.
               b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb a
          [LclId] =
              [$dContravariant_sgmgj $dContravariant1_sgmgk] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:*:_$c>$
                      $dContravariant_sgmgj $dContravariant1_sgmgk eta_B2 eta_B1; } in
        let {
          sat_sgmgl [Occ=Once]
            :: forall a b.
               (a -> b)
               -> (GHC.Generics.:*:) f_agjfa g_agjfb b
               -> (GHC.Generics.:*:) f_agjfa g_agjfb a
          [LclId] =
              [$dContravariant_sgmgj $dContravariant1_sgmgk] \r [eta_B2 eta_B1]
                  Data.Functor.Contravariant.$fContravariant:*:_$ccontramap
                      $dContravariant_sgmgj $dContravariant1_sgmgk eta_B2 eta_B1;
        } in 
          Data.Functor.Contravariant.C:Contravariant [sat_sgmgl sat_sgmgm];

Data.Functor.Contravariant.$fContravariantK3
  :: forall i c a b.
     (a -> b) -> GHC.Generics.K1 i c b -> GHC.Generics.K1 i c b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgmgn ds1_sgmgo] ds1_sgmgo;

Data.Functor.Contravariant.$fContravariantK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c.
     Data.Functor.Contravariant.Contravariant (GHC.Generics.K1 i c)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantK3
                                                               Data.Functor.Contravariant.$fContravariantK2];

Data.Functor.Contravariant.$fContravariantU1_$ccontramap
  :: forall a b. (a -> b) -> GHC.Generics.U1 b -> GHC.Generics.U1 a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sgmgp ds1_sgmgq] GHC.Generics.U1 [];

Data.Functor.Contravariant.$fContravariantU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant GHC.Generics.U1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantU1_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantU1_$c>$];

Data.Functor.Contravariant.$fContravariantV1_$ccontramap
  :: forall a b. (a -> b) -> GHC.Generics.V1 b -> GHC.Generics.V1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sgmgr x_sgmgs] x_sgmgs;

Data.Functor.Contravariant.$fContravariantV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Functor.Contravariant.Contravariant GHC.Generics.V1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Functor.Contravariant.C:Contravariant! [Data.Functor.Contravariant.$fContravariantV1_$ccontramap
                                                               Data.Functor.Contravariant.$fContravariantV1_$c>$];

lvl2_rgjLt
  :: forall a b1.
     GHC.Real.Integral b1 =>
     b1 -> (a -> GHC.Types.Ordering) -> a -> GHC.Types.Ordering
[GblId, Arity=4, Str=<L,U><L,U><L,1*C1(U)><L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgmgu n_sgmgv f_sgmgw e_sgmgx]
        let {
          sat_sgmgy [Occ=Once] :: GHC.Types.Ordering
          [LclId] =
              [f_sgmgw e_sgmgx] \u [] f_sgmgw e_sgmgx;
        } in 
          GHC.Base.$fSemigroupOrdering_$cstimes
              $dIntegral_sgmgu n_sgmgv sat_sgmgy;

lvl3_rgjLu
  :: forall a.
     GHC.Base.NonEmpty (a -> GHC.Types.Ordering)
     -> a -> GHC.Types.Ordering
[GblId, Arity=1, Str=<S(LS),1*U(U,1*U)>, Unf=OtherCon []] =
    [] \r [w1_sgmgz]
        case w1_sgmgz of {
          GHC.Base.:| ww1_sgmgB [Occ=Once] ww2_sgmgC [Occ=Once] ->
              GHC.Base.$w$csconcat3
                  GHC.Base.$fSemigroupOrdering ww1_sgmgB ww2_sgmgC;
        };

lvl4_rgjLv
  :: forall a.
     (a -> GHC.Types.Ordering)
     -> (a -> GHC.Types.Ordering) -> a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgmgD g_sgmgE x_sgmgF]
        case f_sgmgD x_sgmgF of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> g_sgmgE x_sgmgF;
          GHC.Types.GT -> GHC.Types.GT [];
        };

Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (a -> GHC.Types.Ordering)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [lvl4_rgjLv
                                         lvl3_rgjLu
                                         lvl2_rgjLt];

Data.Functor.Contravariant.$fSemigroupComparison2
  :: forall a.
     GHC.Base.NonEmpty (a -> a -> GHC.Types.Ordering)
     -> a -> a -> GHC.Types.Ordering
[GblId, Arity=1, Str=<S(LS),1*U(U,1*U)>, Unf=OtherCon []] =
    [] \r [w1_sgmgH]
        case w1_sgmgH of {
          GHC.Base.:| ww1_sgmgJ [Occ=Once] ww2_sgmgK [Occ=Once] ->
              GHC.Base.$w$csconcat3
                  Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
                  ww1_sgmgJ
                  ww2_sgmgK;
        };

Data.Functor.Contravariant.$fSemigroupComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup (Data.Functor.Contravariant.Comparison a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Functor.Contravariant.$fSemigroupComparison3
                                         Data.Functor.Contravariant.$fSemigroupComparison2
                                         Data.Functor.Contravariant.$fSemigroupComparison1];

lvl5_rgjLw :: forall a. a -> GHC.Types.Ordering
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgmgL] GHC.Types.EQ [];

lvl6_rgjLx
  :: forall a. [a -> GHC.Types.Ordering] -> a -> GHC.Types.Ordering
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fMonoid(->)_$cmconcat
            GHC.Base.$fMonoidOrdering eta_B2 eta_B1;

Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (a -> GHC.Types.Ordering)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fMonoidComparison_$s$fSemigroup(->)
                                      lvl5_rgjLw
                                      lvl4_rgjLv
                                      lvl6_rgjLx];

Data.Functor.Contravariant.$fMonoidComparison1
  :: forall a.
     [a -> a -> GHC.Types.Ordering] -> a -> a -> GHC.Types.Ordering
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fMonoid(->)_$cmconcat
            Data.Functor.Contravariant.$fMonoidComparison_$s$fMonoid(->)
            eta_B2
            eta_B1;

Data.Functor.Contravariant.$fMonoidComparison [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Functor.Contravariant.$fSemigroupComparison
                                      Data.Functor.Contravariant.$fMonoidComparison3
                                      Data.Functor.Contravariant.$fMonoidComparison2
                                      Data.Functor.Contravariant.$fMonoidComparison1];

Data.Functor.Contravariant.C:Contravariant
  :: forall (f :: * -> *).
     (forall a b. (a -> b) -> f b -> f a)
     -> (forall b a. b -> f b -> f a)
     -> Data.Functor.Contravariant.Contravariant f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Functor.Contravariant.C:Contravariant [eta_B2 eta_B1];

